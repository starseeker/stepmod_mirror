
(* ===================================================================================== *)
(* Long form schema generated by The EXPRESS Data Manager  compiler version 9.5B.2004.01.23*)
(* Thu Dec 16 16:40:13 2004                                                                *)
(* The schema is converted from ISO10303 P11-2003 to ISO10303 P11-1994                     *)
(* ===================================================================================== *)

SCHEMA Ap210_electronic_assembly_interconnect_and_packaging_design_mim_lf;

(* Pruned unused type: ap210_approval_item  *)


(* Pruned unused type: ap210_certification_item  *)


(* Pruned unused type: ap210_classification_item  *)


(* Pruned unused type: ap210_date_and_time_item  *)


(* Pruned unused type: ap210_document_reference_item  *)


(* Pruned unused type: ap210_frozen_assigned_item  *)


(* Pruned unused type: ap210_managed_design_object  *)


(* Pruned unused type: ap210_organization_item  *)


(* Pruned unused type: ap210_owner_assigned_item  *)


(* Pruned unused type: ap210_person_and_organization_item  *)


(* Pruned unused type: ap210_requirement_assigned_item  *)


(* Pruned unused type: dimension_identification_item  *)


(* Pruned unused type: dimension_tolerance_document_reference_item  *)


(* Pruned unused type: group_assigned_item  *)


(* NOTE: Empty SELECT set! *)
(* TYPE model_parameter_assigned_item = SELECT (); END_TYPE; *) 


ENTITY assembly_module_macro_component_join_terminal
  SUBTYPE OF (component_terminal);
WHERE
  WR1: NOT (SELF\shape_aspect.description IN 
      ['bare die component terminal', 
       'component termination passage join terminal', 
       'conductive interconnect element terminal', 
       'interconnect component join terminal', 
       'interconnect module component terminal', 'land join terminal', 
       'minimally defined component terminal',
       'non functional land join terminal', 
       'packaged component join terminal', 
       'printed component join terminal', 'package terminal occurrence',
       'via terminal']);
END_ENTITY;

ENTITY category_model_parameter 
 SUBTYPE OF (model_parameter);
END_ENTITY;

ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY;

ENTITY externally_defined_dimension_definition
  SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
  WR1: (SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification');
  WR2: 1 >= SIZEOF(QUERY ( adr <* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ));
END_ENTITY;

ENTITY material_functional_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN 
     ['bonding agent', 'potting compound', 'marking material'];
END_ENTITY;

ENTITY model_parameter 
 SUBTYPE OF (descriptive_representation_item,group_assignment, general_property);
  items : OPTIONAL SET [1:1] OF model_parameter_assigned_item;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_DOCUMENT_REFERENCE.ITEMS')) = 1;
  WR2: SIZEOF (QUERY (aga <* USEDIN (SELF, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETER_TYPE' IN 
       TYPEOF (aga.assigned_group)) AND
       (aga.assigned_group\group.name IN ['string property type', 
       'logical property type', 'physical property type', 
       'boolean property type']))) = 1;
END_ENTITY;

ENTITY named_unit_variable
  SUBTYPE OF (named_unit, variable_semantics); 
INVERSE
  associated_variable_environment: environment FOR semantics; 
END_ENTITY;

ENTITY parameter_assignment_override
  SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\representation ||
       SELF\representation_relationship || 
       SELF\parameter_assignment_override))) = 0;
  WR2: SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
  WR3: SELF\representation_relationship.name = '';
  WR4: SELF\representation.name = '';
  WR5: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_1);
  WR6: 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY parameter_assignment_representation
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (SELF.items) = 2;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       (SIZEOF (TYPEOF (it) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MODEL_PARAMETER']) 
       = 1))) = 1;
  WR3: SIZEOF (QUERY (it <* SELF.items |
       (SIZEOF (TYPEOF (it) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COORDINATED_REPRESENTATION_ITEM']) 
       = 1))) <= 1;
  WR4: SIZEOF (QUERY (it <* SELF.items |
        (SIZEOF (QUERY(aga <* USEDIN (it,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'APPLIED_GROUP_ASSIGNMENT.ITEMS') |
             (SIZEOF (TYPEOF ( aga\group_assignment.assigned_group) *
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHARACTERISTIC_TYPE']) = 1))) 
       = 1))) <= 1;
  WR5: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\representation ||
       SELF\parameter_assignment_representation)) = 0; 
END_ENTITY;

ENTITY placed_datum_target_feature
  SUBTYPE OF (datum_target);
DERIVE
  representation_associations : SET[0:?] OF property_definition_representation := get_shape_aspect_property_definition_representations(SELF);
WHERE
  WR1: SELF.description IN ['point','line','rectangle','circle', 'circular line'];
  WR2: SIZEOF (QUERY (pdr <* representation_associations | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF (pdr.used_representation) )) = 1;

  WR3: valid_datum_target_parameters(SELF);
END_ENTITY;

ENTITY product_specific_parameter_value_assignment
  SUBTYPE OF (characterized_object,
              product_related_product_category); 
WHERE
  WR1: SIZEOF(SELF\product_related_product_category.products) = 1;
  WR2: SIZEOF(QUERY(pd <* USEDIN(SELF,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       (pd\property_definition.description = 
                                'assigned parameter') AND
       (SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       (SIZEOF (
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETER_ASSIGNMENT_REPRESENTATION'] *
       TYPEOF (pdr.used_representation)) = 1))) = 1))) = 1;
  WR3: NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHARACTERIZED_PRODUCT_CATEGORY' IN
       TYPEOF(SELF));  
  WR4: SELF\characterized_object.name = SELF\product_category.name;  
END_ENTITY;

ENTITY schema_based_model_parameter 
 SUBTYPE OF (model_parameter);
END_ENTITY;

ENTITY shape_representation_with_parameters
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF( QUERY( i <* SELF.items | SIZEOF(['AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLACEMENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(i)) = 1 )) = SIZEOF(SELF.items);

END_ENTITY;

FUNCTION applied_date_correlation
  (e : applied_date_assignment;
  schema_name : STRING) : BOOLEAN;
  LOCAL
    d_role : STRING;
  END_LOCAL;
    d_role := e\date_assignment.role\date_role.name;
  CASE d_role OF
    'creation date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                (SIZEOF( [schema_name +
                                '.PRODUCT_DEFINITION',
                                schema_name +
                                '.DOCUMENT'] *
                                TYPEOF (x)) >= 1 )))
                                THEN RETURN(FALSE);
                              END_IF;
    'request date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.VERSIONED_ACTION_REQUEST'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'release date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign off date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification date'    : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification date'   : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification date' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);

END_FUNCTION;

FUNCTION applied_date_time_correlation
  (e : applied_date_and_time_assignment;
  schema_name : STRING) : BOOLEAN;
  LOCAL
    dt_role : STRING;
  END_LOCAL;
    dt_role := e\date_and_time_assignment.role\date_time_role.name;
  CASE dt_role OF
    'creation date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                               (SIZEOF( [schema_name +
                                '.PRODUCT_DEFINITION',
                                schema_name +
                                '.DOCUMENT'] *
                                TYPEOF (x)) >= 1 )))
                                THEN RETURN(FALSE);
                              END_IF;
    'request date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.VERSIONED_ACTION_REQUEST'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'release date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign off date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification date'    : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification date'   : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification date' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'participant date and time' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.RULE_ACTION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);

END_FUNCTION;

FUNCTION  bag_to_set

      ( the_bag : BAG OF GENERIC : intype ) : SET OF GENERIC : intype ;

LOCAL

      the_set : SET OF GENERIC : intype := [];
      i : INTEGER ;

END_LOCAL ;

      IF SIZEOF (the_bag) > 0 THEN
            REPEAT i := 1 TO HIINDEX (the_bag);
                  the_set := the_set + the_bag[i];
            END_REPEAT ;
      END_IF ;
      RETURN (the_set);


END_FUNCTION;

FUNCTION component_definition_located_by_component_location 
                   (cl : component_2d_location) : component_definition; 
LOCAL
  pdr : BAG OF property_definition_representation := USEDIN (cl,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
END_LOCAL;
   REPEAT i := 1 TO HIINDEX(pdr) BY 1;
    IF(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN 
                                  TYPEOF (pdr[i].definition.definition))
        AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_DEFINITION' IN 
        TYPEOF (pdr[i].definition.definition\product_definition_relationship.
                                                  related_product_definition)))
     THEN 
      RETURN(pdr[i].definition.definition\product_definition_relationship.
                                                   related_product_definition);
    END_IF;
   END_REPEAT;
 RETURN (?);

END_FUNCTION;

FUNCTION consistent_bus_structural_definition
     (input_rel : SET [1:?] OF product_definition_relationship) : BOOLEAN;    

LOCAL  
        input : SET OF product_definition := [];
       vertex : SET OF product_definition := []; 
         edge : INTEGER := SIZEOF(input);
           vc : INTEGER := 0;
vertex_degree : INTEGER := 0;    
END_LOCAL;    

REPEAT i := 1 to SIZEOF(input_rel) BY 1;
      input := input + input_rel[i].related_product_definition;
END_REPEAT;

REPEAT i := 1 TO SIZEOF(input) BY 1;
      vertex := vertex + input[i]\product_definition_relationship.relating_product_definition;
      vertex := vertex + input[i]\product_definition_relationship.related_product_definition;
END_REPEAT;
     vc := SIZEOF(vertex);
    IF ( vc <> ( edge + 1 )) THEN 
      RETURN(FALSE);
    END_IF;
REPEAT i := 1 TO vc BY 1;
      vertex_degree := 0;
      REPEAT j := 1 to SIZEOF(input) BY 1;
        IF input[j]\product_definition_relationship.relating_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
        IF input[j]\product_definition_relationship.related_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
      END_REPEAT;
      IF (vertex_degree > 2) THEN
        RETURN(FALSE);
      END_IF;
END_REPEAT;    
RETURN(TRUE);  

END_FUNCTION;

FUNCTION cto2d_determinant_test (cto2d: cartesian_transformation_operator_2d;
                             expected_value: REAL; delta: REAL ) : BOOLEAN;

LOCAL
  det : REAL := 0.0;
  DRs : LIST [4:4] OF REAL := [];
END_LOCAL;
     DRs[1] := cto2d.u[1].direction_ratios[1];
     DRs[2] := cto2d.u[1].direction_ratios[2];
     DRs[3] := cto2d.u[2].direction_ratios[1];
     DRs[4] := cto2d.u[2].direction_ratios[2];
     det  :=  (DRs[1] * DRs[4]) - (DRs[2] * DRs[3]);
IF (Abs(expected_value - det) < Abs(delta) ) THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION get_shape_aspect_property_definition_representations
 (s_a_instance : shape_aspect) : SET OF property_definition_representation; 
LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [] ;
END_LOCAL;
pd_set := bag_to_set(USEDIN(s_a_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) < 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + (QUERY(pdr <* USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION') |
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
END_REPEAT;
RETURN (pdr_set);      

END_FUNCTION;

FUNCTION instance_unique 

      ( the_bag : BAG OF GENERIC : intype ) : BOOLEAN;

LOCAL

      the_set : SET OF GENERIC : intype := [];
      i : INTEGER ;
      pass : BOOLEAN := TRUE;
END_LOCAL ;

      IF SIZEOF (the_bag) > 0 THEN
                  the_set := bag_to_set(the_bag);
      END_IF ;
      IF NOT(SIZEOF(the_set) = SIZEOF(the_bag)) THEN
       pass := FALSE;
      END_IF;

      RETURN (pass);


END_FUNCTION;

FUNCTION is_assembly_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_assembly_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_assembly_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_assembly_module_usage ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design usage'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_bottom_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN(pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'bottom')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_bottom_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_bottom_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_bottom_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN(pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'bottom')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_bottom_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_bottom_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_ee_product_definition ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (NOT(is_laminate_component(pd)) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF(pd))) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'STRATUM' IN TYPEOF(pd))) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NETWORK_NODE_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd)))
   ) 
THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_interconnect_module_component_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_interconnect_module_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_interconnect_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_interconnect_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_interconnect_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_laminate_component ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (pd\product_definition.description = 'laminate component') THEN
    RETURN (TRUE);
ELSE
  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PRINTED_COMPONENT' IN TYPEOF(pd)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_laminate_component_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_laminate_component(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_symmetrical_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'symmetrical')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_symmetrical_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_symmetrical_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_symmetrical_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'symmetrical')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_symmetrical_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_symmetrical_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_top_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'top')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_top_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_top_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION is_top_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'top')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);

END_FUNCTION;

FUNCTION is_top_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_top_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;

END_FUNCTION;

FUNCTION valid_2d_wireframe_edge_curve
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- recursively check for valid basic curve types
  IF SIZEOF ([schma + '.LINE',
              schma + '.B_SPLINE_CURVE',
              schma + '.CIRCLE',
              schma + '.HYPERBOLA',
              schma + '.ELLIPSE',
              schma + '.PARABOLA',
              schma + '.POLYLINE'] * TYPEOF (crv)) = 1
      THEN RETURN (TRUE);
  ELSE
    -- recursively check for valid basic curves for curve_replicas
    IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\curve_replica.parent_curve, schma));
    -- recursively check for valid basis curves for offset_curves
    ELSE
      IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF (crv)
        THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\offset_curve_2d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);

END_FUNCTION;

FUNCTION valid_datum_target_parameters
 (pdf : placed_datum_target_feature) : BOOLEAN; 
LOCAL

rep_set : SET OF representation := [] ;

parameter_representations: SET OF representation;
END_LOCAL;


REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
rep_set := rep_set + pdf.representation_associations[i].used_representation;
END_REPEAT;
 
parameter_representations := QUERY(rep <* rep_set |
('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
TYPEOF(rep)));


IF (SIZEOF( QUERY( srwp <* parameter_representations |
          (SIZEOF( QUERY( i <* srwp.items |
          (i.name='orientation') AND
          ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLACEMENT' IN TYPEOF(i)))) = 1))) <> 1) THEN
   RETURN(FALSE);
END_IF;

CASE pdf\shape_aspect.description OF
'point': RETURN(SIZEOF(QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 1))) = 1);

'circle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 2))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target diameter') AND
                (SIZEOF(['AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		   'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1));

'line': RETURN(SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1);

'rectangle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items)= 3))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2))) = 1))) = 1) AND
              (SIZEOF( QUERY( srwp <* parameter_representations |
               (SIZEOF( QUERY( i <* srwp.items |
                 (i.name='target width') AND
                 (SIZEOF(['AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
 		'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)

                  ) = 2))) = 1) )) = 1));
OTHERWISE : RETURN(FALSE);
END_CASE;

   END_FUNCTION;

RULE add_design_object_management_relationship_unique_constraint FOR
 ( add_design_object_assignment, add_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  adoa_bag : BAG OF add_design_object_assignment;
  adora_bag : BAG OF add_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(add_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(add_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(add_design_object_assignment[i].items[j]))
    AND (add_design_object_assignment[i].items[j].name = 
            'design object addition') ) THEN
      IF EXISTS( add_design_object_assignment[i].items[j].
                          related_product_definition ) 
                                                               THEN
        IF( NOT( add_design_object_assignment[i].items[j].
                           related_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                    add_design_object_assignment[i].items[j].
                             related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(add_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
        SIZEOF(add_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
           TYPEOF(add_design_object_request_assignment[i].items[j]))
AND (add_design_object_request_assignment[i].items[j].name = 
                             'design object addition') ) THEN
      IF EXISTS( 
           add_design_object_request_assignment[i].items[j].
                             related_product_definition ) 
                                                          THEN
        IF( NOT( 
           add_design_object_request_assignment[i].items[j].
                               related_product_definition 
                                           IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
             add_design_object_request_assignment[i].items[j].
                                    related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
                         (pdr\product_definition_relationship.name = 'design object addition') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adoa_bag := QUERY( adoa <* add_design_object_assignment | 
                                 (pdr_bag[j] IN adoa.items) );
    REPEAT k := 1 to SIZEOF(adoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adoa_bag[k].items) by 1;
        IF EXISTS( adoa_bag[k].items[l] ) THEN
          IF ( adoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + adoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adora_bag := QUERY( adora <* add_design_object_request_assignment | 
                                          (pdr_bag[j] IN adora.items) );
    REPEAT k := 1 to SIZEOF(adora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adora_bag[k].items) by 1;
        IF ( adora_bag[k].items[l] IN mdo_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          mdo_bag := mdo_bag + adora_bag[k].items[l];
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE adjacent_stratum_surface_definition_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'STRATUM_SURFACE' IN TYPEOF (sar.related_shape_aspect)) AND
   (sar.related_shape_aspect\shape_aspect.description IN ['secondary surface']))))) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'STRATUM_SURFACE' IN TYPEOF (sar.relating_shape_aspect)) AND
    (sar.relating_shape_aspect\shape_aspect.description IN ['primary surface']))))) = 0;
END_RULE;

RULE adjacent_stratum_surface_definition_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  assd : BAG OF shape_aspect_relationship := 
      QUERY( sar <* shape_aspect_relationship
| (sar\shape_aspect_relationship.description = 'adjacent stratum surface definition') );
  pass1 : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
  pss_bag : BAG OF stratum_surface := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass2 : BOOLEAN := TRUE;
  sss_bag : BAG OF stratum_surface;
END_LOCAL;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i]\shape_aspect_relationship.name ) THEN
    IF ( assd[i]\shape_aspect_relationship.name IN name_bag ) THEN
      pass1 := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + assd[i]\shape_aspect_relationship.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i].relating_shape_aspect ) THEN
    IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_SURFACE' IN TYPEOF(assd[i].relating_shape_aspect) ) THEN
      IF( NOT( assd[i].relating_shape_aspect IN pss_bag ) ) THEN
        pss_bag := pss_bag + assd[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pss_bag) by 1;
  IF ( NOT pass2 ) THEN ESCAPE;
  END_IF;
  sss_bag := [];
  sar_bag := QUERY( sar <* assd | (sar.relating_shape_aspect :=: 
              pss_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_SURFACE' IN TYPEOF(assd[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sss_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          sss_bag := sss_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE;

RULE aggregate_connectivity_requirement_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  acr : BAG OF product_definition_relationship := 
                     QUERY( pdr <* product_definition_relationship |
                     (pdr\product_definition_relationship.name = 'aggregate connectivity requirement') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].related_product_definition ) THEN
    IF ( acr[i].id = 'design composition path' ) THEN
      IF ( acr[i].related_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + acr[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE application_context_requires_ap_definition FOR
  (application_context, application_protocol_definition);
WHERE
  WR1: SIZEOF (QUERY (ac <* application_context |
       NOT (SIZEOF (QUERY (apd <* application_protocol_definition |
       (ac :=: apd\application_protocol_definition.application)
       AND
       (apd\application_protocol_definition.application_interpreted_model_schema_name =
         'electronic_assembly_interconnect_and_packaging_design'
       ))) = 1 ))) = 0;
END_RULE;

RULE approval_requires_approval_date_time FOR (approval,
         approval_date_time);
WHERE
  WR1: SIZEOF(QUERY ( app <* approval |
       NOT (SIZEOF (QUERY (adt <* approval_date_time |
       app :=: adt.dated_approval)) = 1))) = 0;
END_RULE;

RULE approval_requires_approval_person_organization FOR (approval,
         approval_person_organization);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (apo <* approval_person_organization |
       app :=: apo.authorized_approval)) >= 1))) = 0;
END_RULE;

RULE approval_role_constraint FOR
  (approval_role);
WHERE
  WR1: SIZEOF (QUERY (apr <* approval_role |
       NOT (apr\approval_role.role = 'authorizer')
       )) = 0;
END_RULE;

RULE approvals_are_assigned FOR
  (approval, approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (aa <* approval_assignment |
       app :=: aa.assigned_approval )) >= 1 ))) = 0;
END_RULE;

RULE assembly_composition_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  acr : BAG OF assembly_component_usage := 
 QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'assembly composition') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  cd_bag : BAG OF component_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].relating_product_definition ) THEN
    IF( (acr[i].relating_product_definition.frame_of_reference.name = 
         'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(acr[i].relating_product_definition)) ) THEN
      IF ( NOT ( acr[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + acr[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cd_bag := [];
  acu_bag := QUERY( acu <* acr | (acu.relating_product_definition :=: 
                               pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].related_product_definition ) THEN
      IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN 
             TYPEOF(acu_bag[j].related_product_definition) ) THEN
        IF ( acu_bag[j].related_product_definition IN cd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          cd_bag := cd_bag + acu_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE bare_die_unique_constraint FOR
 ( bare_die); --, externally_defined_bare_die, library_defined_bare_die );
LOCAL
  bd : BAG OF physical_unit := QUERY( r <* bare_die |
(r.frame_of_reference.name = 'physical design usage') );
(**  edbd : BAG OF physical_unit := QUERY( r <* externally_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') );
  ldbd : BAG OF physical_unit := QUERY( r <* library_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') ); *)
  pu : BAG OF physical_unit;
  pdr_bag : BAG OF product_definition_relationship;
  fu_bag : BAG OF functional_unit := [];
  pu_bag : BAG OF physical_unit;
  ut_bag : BAG OF property_definition;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition;
END_LOCAL;

pu := bd + edbd + ldbd;
REPEAT i := 1 to SIZEOF(pu) by 1;
  pdr_bag := QUERY( pdr <* USEDIN( pu[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
( (pdr\product_definition_relationship.name = 'implemented function') AND
(pdr.relating_product_definition.frame_of_reference.name = 
         'functional design usage')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) ) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].relating_product_definition ) THEN
      IF( NOT( pdr_bag[j].relating_product_definition IN fu_bag ) ) THEN
        fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pu_bag := QUERY( r <* pu | (SIZEOF(QUERY(pdr <* USEDIN( fu_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION' ) |
((pdr\product_definition_relationship.name = 'implemented function')AND
        (pdr.related_product_definition :=: r)) ))>0) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(pu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ut_bag := QUERY( pd <* USEDIN( pu_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION' ) | (pd\property_definition.name = 'unit technology') );
    REPEAT k := 1 to SIZEOF(ut_bag) by 1;
      IF EXISTS( ut_bag[k] ) THEN
        IF ( ut_bag[k] IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + ut_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE boundary_size_characteristic_constraint FOR
  (representation);
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'diametrical boundary size')
        OR (rep\representation.name = 'opposing boundary set size'))
       AND (NOT(SIZEOF(QUERY(lmwu <* rep.items |
       (lmwu\representation_item.name = 'tolerance value'))) = 1)))) = 0;
END_RULE;

RULE bus_structural_definition_unique_constraint FOR 
(bus_structural_definition, product_definition_formation, product);

LOCAL
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(bus_structural_definition) by 1;
  IF EXISTS( bus_structural_definition[i].formation.of_product.name ) THEN
    IF (bus_structural_definition[i].formation.of_product.name IN 
                                                       name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + 
bus_structural_definition[i]\product_definition.formation.of_product.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1: pass;

END_RULE;

RULE cartesian_coordinate_system_constraint FOR 
    (global_unit_assigned_context,
     geometric_representation_context,
     global_uncertainty_assigned_context);
LOCAL
  guac_inst : SET OF global_unit_assigned_context := 
              QUERY ( guac <* global_unit_assigned_context |
            ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (guac)) AND
            ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN TYPEOF (guac)));
END_LOCAL;
WHERE
  WR1: SIZEOF (QUERY (guac <* guac_inst |
       NOT (SIZEOF (guac.units) <= 3))) = 0;
  WR2: SIZEOF (QUERY (guac <* guac_inst | (NOT (
       (SIZEOF (QUERY (u <* guac.units |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT'
       IN TYPEOF (u)))) = 1) 
       AND 
       (SIZEOF (QUERY (u <* guac.units |
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PLANE_ANGLE_UNIT'
       IN TYPEOF (u)))) = 1) 
       AND
       (SIZEOF (QUERY (u <* guac.units |
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SOLID_ANGLE_UNIT'
       IN TYPEOF (u)) )) <= 1)
       )))) = 0;
  WR3: SIZEOF( QUERY( grc <* guac_inst |
       NOT( (grc.coordinate_space_dimension = 2) OR
       (grc.coordinate_space_dimension = 3)))) = 0;
  WR4: SIZEOF (QUERY (guac <* guac_inst |
       NOT ((SIZEOF (QUERY (u <* guac.uncertainty |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (u))) = 1)))) = 0;
  WR5: SIZEOF (QUERY (guac <* guac_inst | 
       NOT (SIZEOF (QUERY (u <* guac.units |NOT(
   NOT((
    'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'PLANE_ANGLE_UNIT' IN TYPEOF(u)) AND
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'CONVERSION_BASED_UNIT' IN TYPEOF(u)) AND
    (u\conversion_based_unit.name = 'degree'))
  OR
      ((abs(u\conversion_based_unit.
          conversion_factor\measure_with_unit.value_component - 
              0.0174532925) <= 0.001) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PLANE_ANGLE_MEASURE_WITH_UNIT' 
       IN TYPEOF(u\conversion_based_unit.conversion_factor)))
  ))) = 0)
  )) = 0;
END_RULE;

RULE cartesian_transformation_operator_2d_constraint FOR 
                  (cartesian_transformation_operator_2d);
WHERE
  WR1: SIZEOF(QUERY ( cto2 <* cartesian_transformation_operator_2d |  NOT(
       EXISTS(cto2.axis1) AND EXISTS(cto2.axis2)
       AND (cto2.scale > 0.0 )))) = 0;
END_RULE;

RULE certification_requires_date_or_date_and_time FOR
  (certification, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (cert <* certification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       cert IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       cert IN ada.items )) = 1 )))) = 0;
END_RULE;

RULE certification_unique_constraint FOR (certification);

LOCAL
  r :  BAG OF certification := QUERY (r <* certification | TRUE);
  pass :  BOOLEAN := TRUE;
  name_bag :  BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\certification.name ) THEN
    IF (r[i]\certification.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\certification.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1:  pass;

END_RULE;

RULE change_design_object_management_relationship_unique_constraint FOR
 (  change_from_design_object_assignment, 
 change_from_design_object_request_assignment,
change_to_design_object_assignment, 
change_to_design_object_request_assignment );
LOCAL
  pd_bag : BAG OF product_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  ctdoa_bag : BAG OF change_to_design_object_assignment;
  ctdora_bag : BAG OF change_to_design_object_request_assignment;
  cfdoa_bag : BAG OF change_from_design_object_assignment;
  cfdora_bag : BAG OF change_from_design_object_request_assignment;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(change_from_design_object_assignment) by 1;
  REPEAT j := 1 TO 
          SIZEOF(change_from_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
     TYPEOF(change_from_design_object_assignment[i].items[j]))
AND (change_from_design_object_assignment[i].items[j].name = 
                                   'design object change') ) THEN
      IF EXISTS
( change_from_design_object_assignment[i].items[j].
 relating_product_definition ) 
                                                             THEN
        IF( NOT
          ( change_from_design_object_assignment[i].items[j].
                               relating_product_definition 
                                               IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
            change_from_design_object_assignment[i].items[j].
                               relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to 
         SIZEOF(change_from_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
       SIZEOF(change_from_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(change_from_design_object_request_assignment[i].items[j]))
AND (change_from_design_object_request_assignment[i].items[j].name = 
                      'design object change') ) THEN
      IF EXISTS
  ( change_from_design_object_request_assignment[i].items[j].
                                    relating_product_definition )
                                                THEN
        IF( NOT
  ( change_from_design_object_request_assignment[i].items[j].
                                       relating_product_definition 
                                          IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
    change_from_design_object_request_assignment[i].items[j].
                                      relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT (pass1 AND pass2) ) THEN ESCAPE;
  END_IF;
  IF ( pass1 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
        (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdoa_bag := QUERY( ctdoa <* change_to_design_object_assignment | 
                (pdr_bag[j] IN ctdoa.items) );
      REPEAT k := 1 to SIZEOF(ctdoa_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdoa_bag[k].items) by 1;
          IF EXISTS( ctdoa_bag[k].items[l] ) THEN
            IF ( ctdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdora_bag := 
         QUERY( ctdora <* change_to_design_object_request_assignment | 
                    (pdr_bag[j] IN ctdora.items) );
      REPEAT k := 1 to SIZEOF(ctdora_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdora_bag[k].items) by 1;
          IF EXISTS( ctdora_bag[k].items[l] ) THEN
            IF ( ctdora_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  IF ( pass2 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
   (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdoa_bag := QUERY( cfdoa <* change_from_design_object_assignment | 
                                           (pdr_bag[j] IN cfdoa.items) );
      REPEAT k := 1 to SIZEOF(cfdoa_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdoa_bag[k].items) by 1;
          IF EXISTS( cfdoa_bag[k].items[l] ) THEN
            IF ( cfdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdora_bag := 
        QUERY( cfdora <* change_from_design_object_request_assignment | 
                                        (pdr_bag[j] IN cfdora.items) );
      REPEAT k := 1 to SIZEOF(cfdora_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdora_bag[k].items) by 1;
          IF EXISTS( cfdora_bag[k].items[l] ) THEN
            IF ( cfdora_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE;

RULE change_request_unique_constraint FOR
 ( versioned_action_request );
LOCAL
  cr : BAG OF versioned_action_request := 
          QUERY( v <* versioned_action_request
               | (SIZEOF(QUERY(ara <* 
USEDIN(v,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')|(
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CHANGE_REQUEST' IN TYPEOF(ara)) ))>0) );
  version_bag : BAG OF STRING := [];
  var_bag : BAG OF versioned_action_request;
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(versioned_action_request) by 1;
  IF EXISTS( versioned_action_request[i].version ) THEN
    IF( NOT( versioned_action_request[i].version IN version_bag ) ) THEN
      version_bag := version_bag + versioned_action_request[i].version;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(version_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  var_bag := QUERY( v <* versioned_action_request | 
                       (v\versioned_action_request.version = version_bag[i]) );
  id_bag := [];
  REPEAT j := 1 to SIZEOF(var_bag) by 1;
    IF EXISTS( var_bag[j].id ) THEN
      IF ( var_bag[j].id IN id_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        id_bag := id_bag + var_bag[j].id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_feature_to_layout_feature_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_TERMINAL']
       * TYPEOF(sar.relating_shape_aspect)) > 0)
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM_FEATURE']
       * TYPEOF(sar.related_shape_aspect)) > 0)
       )) = 0;
END_RULE;

RULE component_feature_unique_constraint FOR
 ( component_terminal, component_interface_terminal );
LOCAL
  ct : BAG OF shape_aspect := 
     QUERY( ct <* component_terminal | (ct\shape_aspect.description IN 
['assembly module component terminal',
'bare die component terminal',
'interconnect component join terminal',
'interconnect module component terminal',
'interconnect module component stratum based terminal',
'minimally defined component terminal',
'packaged component join terminal']) );
  cit : BAG OF shape_aspect := 
         QUERY( cit <* component_interface_terminal | (
cit\shape_aspect.description IN ['interconnect component interface terminal',
'packaged connector component interface terminal']) );
  cf : BAG OF shape_aspect;
  cd_bag : BAG OF component_definition := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  def_bag : BAG OF shape_aspect;
END_LOCAL;

cf := ct + cit;
REPEAT i := 1 to SIZEOF(cf) by 1;
  IF EXISTS( cf[i].of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN TYPEOF(cf[i].of_shape.definition) ) THEN
      IF ( NOT ( cf[i].of_shape.definition IN cd_bag )) THEN
        cd_bag := cd_bag + cf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  def_bag := [];
  sa_bag := QUERY( sa <* cf | (sa.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
             (sar\shape_aspect_relationship.name = 'instantiated feature') );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN def_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          def_bag := def_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_part_3d_geometric_representation_relationship_constraint FOR
( shape_representation_relationship );
LOCAL
 rr: SET OF representation_relationship :=
      QUERY ( srr <* shape_representation_relationship |
       srr\representation_relationship.name = 'component part 3d shape');
 pass: BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(rr) by 1;
IF ((rr[i].rep_1.context_of_items.coordinate_space_dimension) <> 
          (rr[i].rep_2.context_of_items.coordinate_space_dimension))
THEN
  pass := FALSE;
END_IF;
END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

RULE 
component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
              'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) ) 
    THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERCONNECT_MODULE_INTERFACE_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_join_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERCONNECT_MODULE_JOIN_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
             'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT' IN TYPEOF(cttamta[i].relating_shape_aspect)) AND
(cttamta[i].relating_shape_aspect\shape_aspect.description = 'pca terminal') ) THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE component_termination_passage_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  ctptt : BAG OF shape_aspect := QUERY( sa <* shape_aspect |
((sa\shape_aspect.description = 
'component termination passage template interface terminal') OR
(sa\shape_aspect.description = 
'component termination passage template join terminal')) );
  name_bag : BAG OF STRING := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ctptt) by 1;
  IF EXISTS( ctptt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ctptt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ctptt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ptd_bag := [];
  sa_bag := QUERY( sa <* ctptt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'access mechanism') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND
(sar.relating_shape_aspect\shape_aspect.name = 
       'component termination passage template')) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ptd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE conductive_interconnect_element_terminal_unique_constraint FOR
 ( component_terminal );
LOCAL
  ciet : BAG OF component_terminal := QUERY( ct <* component_terminal |
(ct\shape_aspect.description = 'conductive interconnect element terminal') );
  name_bag : BAG OF STRING := [];
  ct_bag : BAG OF component_terminal;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  csa_bag : BAG OF component_shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ciet) by 1;
  IF EXISTS( ciet[i]\shape_aspect.name ) THEN
    IF( NOT( ciet[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ciet[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ct_bag := QUERY( ct <* ciet | (ct\shape_aspect.name = name_bag[i]) );
  csa_bag := [];
  REPEAT j := 1 to SIZEOF(ct_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( ct_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'associated component') AND (sar.relating_shape_aspect\shape_aspect.description IN
['conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition'])
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF( sar_bag[k].relating_shape_aspect IN csa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          csa_bag := csa_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE configuration_item_requires_person_organization FOR
  (configuration_item,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (ci <* configuration_item |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       ci IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       ci IN aoa.items )) = 1 )))) = 0;
END_RULE;

RULE connection_zone_constraint FOR ( shape_aspect, representation );
WHERE
   WR1: SIZEOF( QUERY( sa <* shape_aspect | 
        (sa\shape_aspect.description = 'connection zone') AND NOT 
        (SIZEOF (USEDIN (sa, '')) >= 1))) = 0;
   WR2: SIZEOF( QUERY( sa <* shape_aspect | 
              (sa\shape_aspect.description = 'connection zone') AND 
        NOT(SIZEOF( QUERY( sar <* USEDIN(sa,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name IN [
        'connection',
        'minimum attachment region size',
        'maximum attachment region size',
        'external connection area', 
        'external connection zone',
        'internal connection zone',
        'mounting area', 
        'terminal connection zone'
         ]))) >= 1))) = 0;
END_RULE;

RULE contract_unique_constraint FOR (contract);

LOCAL
  r : BAG OF contract := QUERY (r <* contract | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\contract.name ) THEN
    IF (r[i]\contract.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\contract.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;

END_RULE;

RULE date_and_time_require_minute_and_second FOR ( date_and_time );
WHERE
  WR1: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.minute_component)))) = 0;
  WR2: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.second_component)))) = 0;
END_RULE;

RULE date_constraint FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       d.year_component < 1856)) = 0;
END_RULE;

RULE datum_feature_usage_in_datum_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  dfuidr : BAG OF shape_aspect_relationship := 
           QUERY( sar <* shape_aspect_relationship |
((sar\shape_aspect_relationship.name = 'datum feature usage in common datum') OR
(sar\shape_aspect_relationship.name = 'datum feature usage in single datum')) );
  pudf_bag : BAG OF physical_unit_datum_feature := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pud_bag : BAG OF physical_unit_datum;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuidr) by 1;
  IF EXISTS( dfuidr[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM' IN TYPEOF(dfuidr[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dfuidr[i].relating_shape_aspect IN pud_bag ) ) THEN
        pud_bag := pud_bag + dfuidr[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pud_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pudf_bag := [];
  sar_bag := 
  QUERY( sar <* dfuidr | ((sar.relating_shape_aspect :=: pud_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM_FEATURE' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pudf_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pudf_bag := pudf_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE datum_precedence_assignment_unique_constraint FOR
 ( property_definition );
LOCAL
  dpa : BAG OF property_definition := QUERY( pd <* property_definition |
(pd\property_definition.description = 'datum precedence assignment') );
  name_bag : BAG OF STRING := [];
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  pds : BAG OF property_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dpa) by 1;
  IF EXISTS( dpa[i]\property_definition.name ) THEN
    IF( NOT( dpa[i]\property_definition.name IN name_bag ) ) THEN
      name_bag := name_bag + dpa[i]\property_definition.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pds := [];
  pd_bag := QUERY( pd <* dpa | (pd\property_definition.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION' ) |
((pdr\property_definition_relationship.name = 'assigned datum precedence') AND
(pdr.relating_property_definition\property_definition.description IN [
'datum system property with material conditions',
'datum system property without material conditions'])) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_property_definition ) THEN
        IF ( pdr_bag[k].relating_property_definition IN pds ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pds := pds + pdr_bag[k].relating_property_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE default_passage_based_land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  dpblpt : BAG OF land_physical_template := 
QUERY( lpt <* land_physical_template |
(lpt\shape_aspect.description IN ['default via based',
'default attachment size and via based',
'default unsupported passage based',
'default component termination passage based',
'default attachment size and component termination passage based']) );
  sar_bag : BAG OF shape_aspect_relationship;
  pt_bag : BAG OF passage_technology := [];
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  st_bag : BAG OF stratum_technology;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dpblpt) by 1;
  sar_bag := QUERY( sar <* USEDIN(dpblpt[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PASSAGE_TECHNOLOGY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].related_shape_aspect IN pt_bag ) ) THEN
        pt_bag := pt_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pt_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  st_bag := [];
  sar_bag := QUERY( sar <* USEDIN(pt_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND (sar.relating_shape_aspect IN dpblpt)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := 
    QUERY( pdr <* USEDIN(sar_bag[j].relating_shape_aspect\shape_aspect.of_shape,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'technology usage') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_TECHNOLOGY' IN 
      TYPEOF(pdr.relating_property_definition.definition))) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_property_definition.definition ) THEN
        IF 
          ( pdr_bag[k].relating_property_definition.definition IN st_bag ) 
                                                                      THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          st_bag := st_bag + 
                       pdr_bag[k].relating_property_definition.definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE delete_design_object_management_relationship_unique_constraint FOR
 ( delete_design_object_assignment, 
   delete_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  ddoa_bag : BAG OF delete_design_object_assignment;
  ddora_bag : BAG OF delete_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(delete_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(delete_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
        IN TYPEOF(delete_design_object_assignment[i].items[j]))
AND (delete_design_object_assignment[i].items[j].name = 
                          'design object deletion') ) THEN
      IF EXISTS( delete_design_object_assignment[i].items[j].
                                      relating_product_definition )
                                                               THEN
        IF( NOT( delete_design_object_assignment[i].items[j].
                                          relating_product_definition 
                                                 IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                 delete_design_object_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(delete_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
         SIZEOF(delete_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
         IN TYPEOF(delete_design_object_request_assignment[i].items[j]))
AND (delete_design_object_request_assignment[i].items[j].name = 
                                     'design object deletion') ) THEN
      IF EXISTS
       ( delete_design_object_request_assignment[i].items[j].
                                        relating_product_definition )
                                                            THEN
        IF( NOT
( delete_design_object_request_assignment[i].items[j].
                                         relating_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
          delete_design_object_request_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
                        (pdr\product_definition_relationship.name = 'design object deletion') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddoa_bag := QUERY( ddoa <* delete_design_object_assignment | 
                                   (pdr_bag[j] IN ddoa.items) );
    REPEAT k := 1 to SIZEOF(ddoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddoa_bag[k].items) by 1;
        IF EXISTS( ddoa_bag[k].items[l] ) THEN
          IF ( ddoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddora_bag := 
        QUERY( ddora <* delete_design_object_request_assignment | 
                                    (pdr_bag[j] IN ddora.items) );
    REPEAT k := 1 to SIZEOF(ddora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddora_bag[k].items) by 1;
        IF EXISTS( ddora_bag[k].items[l] ) THEN
          IF ( ddora_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddora_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE dependent_instantiable_action_directive FOR (action_directive);
WHERE
  WR1: SIZEOF (QUERY (ad <* action_directive |
       NOT (SIZEOF (USEDIN (ad, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_approval_status FOR (approval_status);
WHERE
WR1: SIZEOF (QUERY (ast <* approval_status |
     NOT (SIZEOF (USEDIN (ast, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_certification_type FOR (certification_type);
WHERE
  WR1: SIZEOF (QUERY (ct <* certification_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_contract_type FOR (contract_type);
WHERE
  WR1: SIZEOF(QUERY ( ct <* contract_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (dt <* date |
       NOT (SIZEOF(USEDIN (dt, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (SIZEOF (USEDIN (dr, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_date_time_role FOR (date_time_role);
WHERE
  WR1: SIZEOF (QUERY (dtr <* date_time_role |
       NOT (SIZEOF (USEDIN (dtr, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_document_type FOR (document_type);
WHERE
  WR1: SIZEOF (QUERY (dt <* document_type |
       NOT (SIZEOF (USEDIN (dt, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_named_unit FOR (named_unit);
WHERE
  WR1: SIZEOF (QUERY (nu <* named_unit |
       NOT (SIZEOF (USEDIN (nu, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_organization_role FOR (
         organization_role);
WHERE
  WR1: SIZEOF (QUERY (org <* organization_role |
       NOT (SIZEOF (USEDIN (org, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_parametric_representation_context FOR
  (parametric_representation_context);
WHERE
  WR1: SIZEOF (QUERY (prc <* parametric_representation_context |
       NOT (SIZEOF (USEDIN (prc, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_person_and_organization_role FOR (
         person_and_organization_role);
WHERE
  WR1: SIZEOF (QUERY (poar <* person_and_organization_role |
       NOT (SIZEOF (USEDIN (poar, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF (QUERY (ri <* representation_item |
       NOT (SIZEOF (USEDIN (ri, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_security_classification_level FOR (
         security_classification_level);
WHERE
  WR1: SIZEOF (QUERY (scl <* security_classification_level |
       NOT (SIZEOF (USEDIN (scl, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_shape_representation FOR (
         shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
       NOT (SIZEOF(USEDIN(sr, '')) >= 1))) = 0;
END_RULE;

RULE dependent_instantiable_tolerance_value FOR (
         tolerance_value);
WHERE
  WR1: SIZEOF (QUERY (tv <* tolerance_value |
       NOT (SIZEOF(USEDIN(tv, '')) >= 1))) = 0;
END_RULE;

RULE design_functional_unit_allocation_to_assembly_component_constraint FOR
( product_definition_relationship );
WHERE
   WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
     (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
                 (NOT(
    (pdr.relating_product_definition\product_definition.description = 'design definition path')
                    AND
            (pdr.relating_product_definition.id = 'design composition path')
                 ))
               )) = 0;

   WR2: SIZEOF (QUERY (pdr <* product_definition_relationship |
   (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
     (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'COMPONENT_DEFINITION' IN TYPEOF (pdr.related_product_definition))) 
               )) = 0;
END_RULE;

RULE
design_functional_unit_allocation_to_assembly_component_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatac : BAG OF product_definition_relationship := 
QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') );
  cd_bag : BAG OF component_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatac) by 1;
  IF EXISTS( dfuatac[i].related_product_definition ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN 
TYPEOF(dfuatac[i].related_product_definition) ) THEN
      IF( NOT( dfuatac[i].related_product_definition IN cd_bag ) ) THEN
        cd_bag := cd_bag + dfuatac[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdr_bag := QUERY( pdr <* dfuatac | 
                 (pdr.related_product_definition :=: cd_bag[i]) );
  id_bag := [];
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].id ) THEN
      IF ( pdr_bag[j].id IN id_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        id_bag := id_bag + pdr_bag[j].id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE
design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  dfuataj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuataj) by 1;
  IF EXISTS( dfuataj[i].relating_product_definition ) THEN
    IF ( dfuataj[i].relating_product_definition.id = 
                         'design composition path' ) THEN
      IF ( dfuataj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuataj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE
design_functional_unit_allocation_to_fabrication_joint_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatfj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to fabrication joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatfj) by 1;
  IF EXISTS( dfuatfj[i].relating_product_definition ) THEN
    IF ( dfuatfj[i].relating_product_definition.id = 
                    'design composition path' ) THEN
      IF ( dfuatfj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuatfj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE design_intent_modification_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'positioned design intent modification 3d shape')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
END_RULE;

RULE design_intent_modification_planar_position_constraint FOR
( mapped_item );
WHERE
 WR1: SIZEOF(QUERY(mi <* mapped_item |
     (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
 WR2: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
       AND (SIZEOF(QUERY(rep <* USEDIN(mi,       
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REPRESENTATION.ITEMS') |
       SIZEOF(USEDIN(rep,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
     + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) = 0
       )) = 0))) = 0;
 WR3: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN
      TYPEOF(mi.mapping_source.mapped_representation)))) = 0;
END_RULE;

RULE design_intent_modification_sequence_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  dims : BAG OF shape_aspect_relationship := 
         QUERY( sar <* shape_aspect_relationship |
(sar\shape_aspect_relationship.name = 'shape modification sequence'));
  pm_bag : BAG OF shape_modification := [];
  sar_bag : BAG OF shape_aspect_relationship;
  sm_bag : BAG OF shape_modification;
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dims) by 1;
  IF EXISTS( dims[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_MODIFICATION' IN TYPEOF(dims[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dims[i].relating_shape_aspect IN pm_bag ) ) THEN
        pm_bag := pm_bag + dims[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pm_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* dims | 
         (sar.relating_shape_aspect :=: pm_bag[i]) );
  sm_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_MODIFICATION' IN 
                     TYPEOF(sar_bag[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sm_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sm_bag := sm_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE dimension_along_curve_unique_constraint FOR
 ( dimensional_location_with_path );
LOCAL
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location_with_path) by 1;
  IF EXISTS( dimensional_location_with_path[i].path ) THEN
    IF ( dimensional_location_with_path[i].path IN sa_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      sa_bag := sa_bag + dimensional_location_with_path[i].path;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE dimension_location_with_direction_vector_unique_constraint FOR
 ( dimensional_location );
LOCAL
  p_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_relationship;
  pdrep_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition := [];
  place_bag : BAG OF placement := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  p_bag := QUERY( pd <* USEDIN(dimensional_location[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | 
(pd\property_definition.description = 'dimensional location property') );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN(p_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'measurement orientation') AND
(pdr.related_property_definition\property_definition.description = 
         'datum based vector orientation')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].related_property_definition ) THEN
        IF ( pdr_bag[k].related_property_definition IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + pdr_bag[k].related_property_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdrep_bag := USEDIN(p_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdrep_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(pdrep_bag[k].used_representation.items) by 1;
        IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PLACEMENT' IN TYPEOF(pdrep_bag[k].used_representation.items[l])) AND
(pdrep_bag[k].used_representation.items[l]\representation_item.name = 'orientation') ) THEN
          IF EXISTS( pdrep_bag[k].used_representation.items[l] ) THEN
           IF ( pdrep_bag[k].used_representation.items[l] IN 
                                                 place_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              place_bag := place_bag + 
                           pdrep_bag[k].used_representation.items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE directed_action_requires_approval FOR
  (directed_action, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       da IN aaa.items )) = 1 ))) = 0;
END_RULE;

RULE directed_action_requires_date_or_date_and_time FOR
  (directed_action, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (da IN adata.items)
       AND (adata.role\date_time_role.name = 'start date'))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (da IN ada.items)
       AND (ada.role\date_role.name = 'start date'))) = 1 )))) = 0;
END_RULE;

RULE directed_axis_constraint FOR
  (derived_shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'derived axis')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       AND (sar\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'axis')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'end shape aspect')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'start shape aspect')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
END_RULE;

RULE directed_axis_unique_constraint FOR
 ( derived_shape_aspect );
LOCAL
  da : BAG OF derived_shape_aspect := QUERY( r <* derived_shape_aspect |
(r\shape_aspect.description = 'directed axis') );
  sar_bag : BAG OF shape_aspect_relationship;
  cos_bag : BAG OF centre_of_symmetry := [];
  sar2_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(da) by 1;
  sar_bag := QUERY( sar <* USEDIN(da[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.related_shape_aspect\shape_aspect.description = 'axis') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CENTRE_OF_SYMMETRY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( NOT( sar_bag[j].related_shape_aspect IN cos_bag ) ) THEN
        cos_bag := cos_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cos_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  sar_bag := QUERY( sar <* USEDIN(cos_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.relating_shape_aspect IN da)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar2_bag := QUERY( sar <* USEDIN(sar_bag[j].relating_shape_aspect,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
(sar\shape_aspect_relationship.name = 'start shape aspect') );
    REPEAT k := 1 to SIZEOF(sar2_bag) by 1;
      IF EXISTS( sar2_bag[k].related_shape_aspect ) THEN
        IF ( sar2_bag[k].related_shape_aspect IN sa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sa_bag := sa_bag + sar2_bag[k].related_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE direction_element_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'element direction vector')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'half datum plane direction vector')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'direction component')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description =
       'datum based vector orientation'))) = 1))) = 0;
END_RULE;

RULE edge_segment_vertex_constraint 
FOR (shape_aspect_relationship, edge_segment_vertex);
LOCAL
sar : BAG OF shape_aspect_relationship := [];
esv : BAG OF edge_segment_vertex := edge_segment_vertex;
pass : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 1 to SIZEOF (esv) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
      sar := QUERY (sar <* shape_aspect_relationship |
       esv[i] = sar\shape_aspect_relationship.related_shape_aspect);
       pass := (SIZEOF(sar) = 2);
      REPEAT j := 2 to SIZEOF (sar) by 1;
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( (sar[j]) :<>: (sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( TYPEOF(sar[j]) = TYPEOF(sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := (sar[j].relating_shape_aspect :=:
               sar[j-1].relating_shape_aspect);
      END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

RULE edge_segment_vertex_unique_constraint FOR
 ( edge_segment_vertex );
LOCAL
  esv : BAG OF edge_segment_vertex := QUERY( r <* edge_segment_vertex
| (r\shape_aspect.name = 'single datum') );
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(esv) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := QUERY( pd <* USEDIN( esv[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | 
(pd\property_definition.description = 'shape element characterization') );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := USEDIN( pd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      IF ( (pdr_bag[k].used_representation\representation.name = 
           'shape element characterization') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pdr_bag[k].used_representation.items[1])) ) THEN
        IF EXISTS
            ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description ) THEN
          IF ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description IN 
                   desc_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            desc_bag := desc_bag + 
                      pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE ee_document_constraint FOR ( document );
WHERE
  WR1: SIZEOF(QUERY(doc <* document |
       (SIZEOF(QUERY(adata <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(doc <* document |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'publisher')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'publisher')
       )) = 1)))) = 0;
  WR3: SIZEOF(QUERY(doc <* document |
       NOT (SIZEOF(USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS')) = 1)
       )) = 0;
END_RULE;

RULE ee_document_unique_constraint FOR
 ( document, document_identifier_assignment );
LOCAL
  pass : BOOLEAN := TRUE;
  rev_exists_bag : BAG OF document := [];
  dia_bag : BAG OF document_identifier_assignment := [];
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(document) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  IF NOT(EXISTS( document[i].description )) THEN
   pass := FALSE;
  END_IF;
END_REPEAT;


REPEAT i := 1 to SIZEOF(document_identifier_assignment) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(document_identifier_assignment[i].items) by 1;
     desc_bag := desc_bag + document_identifier_assignment[i].items[j]\document.description;
  END_REPEAT;
  IF NOT(value_unique(desc_bag)) THEN
    pass := FALSE;
  END_IF;
END_REPEAT;

WHERE
  WR1: pass;
END_RULE;

RULE ee_material_unique_constraint FOR
 ( material_designation );
LOCAL
  name_bag : BAG OF STRING := [];
  md_bag : BAG OF material_designation;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(material_designation) by 1;
  IF EXISTS( material_designation[i].name ) THEN
    IF( NOT( material_designation[i].name IN name_bag ) ) THEN
      name_bag := name_bag + material_designation[i].name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  md_bag := QUERY( md <* material_designation | (md\material_designation.name = name_bag[i]) );
  doc_bag := [];
  REPEAT j := 1 to SIZEOF(md_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( md_bag[j], 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DOCUMENT') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE ee_product_configuration_unique_constraint FOR
 ( configuration_item );
LOCAL
  id_bag : BAG OF STRING := [];
  ci_bag : BAG OF configuration_item;
  cd_bag : BAG OF configuration_design;
  pass : BOOLEAN := TRUE;
  pdf_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_item) by 1;
  IF EXISTS( configuration_item[i].id ) THEN
    IF( NOT( configuration_item[i].id IN id_bag ) ) THEN
      id_bag := id_bag + configuration_item[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdf_bag := [];
  ci_bag := QUERY( ci <* configuration_item | (ci.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(ci_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    cd_bag := USEDIN( ci_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'CONFIGURATION_DESIGN.CONFIGURATION');
    REPEAT k := 1 to SIZEOF(cd_bag) by 1;
      IF EXISTS( cd_bag[k].design ) THEN
        IF ( cd_bag[k].design IN pdf_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pdf_bag := pdf_bag + cd_bag[k].design;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE ee_product_constraint FOR ( product );
WHERE
  WR1: SIZEOF(QUERY(prod <* product |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(prod,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'design owner')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(prod,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'design owner')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(p <* product |
              SIZEOF(USEDIN(p,
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT')) = 0)) = 0;
END_RULE;

RULE ee_product_definition_constraint FOR 
( product_definition_with_associated_documents );
WHERE
  WR1: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(QUERY(adata <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'creator')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'creator')
       )) = 1))
       )) = 0;
  WR3: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
  WR4: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
END_RULE;

RULE ee_product_definition_unique_constraint FOR
 ( product_definition_with_associated_documents, 
   physical_unit, functional_unit );
LOCAL
  pdwad : BAG OF product_definition := 
QUERY( r <* product_definition_with_associated_documents | (TRUE) );
  pu : BAG OF product_definition := QUERY( r <* physical_unit | (TRUE) );
  fu : BAG OF product_definition := QUERY( r <* functional_unit | (TRUE) );
  epd : BAG OF product_definition;
  pdf_bag : BAG OF product_definition_formation;
  pd_bag : BAG OF product_definition;
  pass1 : BOOLEAN := TRUE;
  lcs_bag : BAG OF STRING;
  pass2 : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

epd := pdwad + pu + fu;
REPEAT i := 1 to SIZEOF(epd) by 1;
  IF EXISTS( epd[i].formation ) THEN
    IF( NOT( epd[i].formation IN pdf_bag ) ) THEN
      pdf_bag := pdf_bag + epd[i].formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  lcs_bag := [];
  id_bag := [];
  pd_bag := QUERY( pd <* epd | (pd.formation :=: pdf_bag[i]) );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass2 ) THEN
      IF EXISTS( pd_bag[j].id ) THEN
        IF ( pd_bag[j].id IN id_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + pd_bag[j].id;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass2;
END_RULE;

RULE ee_product_model_unique_constraint FOR (product_concept);

LOCAL
  r : BAG OF product_concept := QUERY (r <* product_concept | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\product_concept.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;
END_RULE;

RULE ee_product_unique_constraint FOR
 ( product );
LOCAL
  id_bag : BAG OF STRING := [];
  p_bag : BAG OF product;
  aoa_bag : BAG OF applied_organization_assignment;
  apaoa_bag : BAG OF applied_person_and_organization_assignment;
  pass : BOOLEAN := TRUE;
  o_bag : BAG OF organization;
  pao_bag : BAG OF person_and_organization;
END_LOCAL;

REPEAT i := 1 to SIZEOF(product) by 1;
  IF EXISTS( product[i].id ) THEN
    IF( NOT( product[i].id IN id_bag ) ) THEN
      id_bag := id_bag + product[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  o_bag := [];
  pao_bag := [];
  p_bag := QUERY( p <* product | (p.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aoa_bag := QUERY( aoa <* USEDIN( p_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ORGANIZATION' IN TYPEOF(aoa.assigned_organization)) AND 
(aoa.role\organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(aoa_bag) by 1;
      IF EXISTS( aoa_bag[k].assigned_organization ) THEN
        IF ( aoa_bag[k].assigned_organization IN o_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          o_bag := o_bag + aoa_bag[k].assigned_organization;
        END_IF;
      END_IF;
    END_REPEAT;
    apaoa_bag := QUERY( apaoa <* USEDIN( p_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PERSON_AND_ORGANIZATION' IN 
TYPEOF(apaoa.assigned_person_and_organization)) 
AND (apaoa.role\person_and_organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(apaoa_bag) by 1;
      IF EXISTS( apaoa_bag[k].assigned_person_and_organization ) THEN
        IF ( apaoa_bag[k].assigned_person_and_organization IN pao_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pao_bag := pao_bag + 
                     apaoa_bag[k].assigned_person_and_organization;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE ee_product_version_supersedence_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       ((pdfr\product_definition_formation_relationship.name = 'product version supersedence')
       AND (NOT(pdfr.relating_product_definition_formation.of_product :=:
           pdfr.related_product_definition_formation.of_product)))
       )) = 0;
END_RULE;

RULE explicitly_located_layer_connection_point_unique_constraint FOR
 ( layer_connection_point );
LOCAL
  ellcp : BAG OF layer_connection_point := 
   QUERY( lcp <* layer_connection_point
| (lcp\shape_aspect.description = 'explicitly located') );
  s_bag : BAG OF stratum := [];
  lcp_bag : BAG OF layer_connection_point;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  cp_bag : BAG OF cartesian_point;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ellcp) by 1;
  IF EXISTS( ellcp[i].of_shape.definition ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM' IN TYPEOF(ellcp[i].of_shape.definition) ) THEN
      IF( NOT( ellcp[i].of_shape.definition IN s_bag ) ) THEN
        s_bag := s_bag + ellcp[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cp_bag := [];
  lcp_bag := 
    QUERY( lcp <* ellcp | (lcp.of_shape.definition :=: s_bag[i]) );
  REPEAT j := 1 to SIZEOF(lcp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := USEDIN( lcp_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PROPERTY_DEFINITION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := QUERY( pdr <* USEDIN( pd_bag[k],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
((pdr.used_representation\representation.name =
'connection point location') AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CARTESIAN_POINT' IN TYPEOF(pdr.used_representation.items[1]))) );
      REPEAT l := 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].used_representation.items[1] ) THEN
          IF ( pdr_bag[l].used_representation.items[1] IN cp_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            cp_bag := cp_bag + pdr_bag[l].used_representation.items[1];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE feature_group_relationship_constraint FOR
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'feature group relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       )) = 0;
END_RULE;

RULE fill_area_occurrence_constraint FOR 
( annotation_fill_area_occurrence );
WHERE
  WR1: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'ANNOTATION_FILL_AREA' IN TYPEOF(afao.item))
       )) = 0;
  WR2: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CARTESIAN_POINT' IN TYPEOF(afao.fill_style_target))
       )) = 0;
  WR3: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       SIZEOF(QUERY(psa <* afao.styles |
       SIZEOF(QUERY(cs <* psa.styles |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CURVE_STYLE' IN TYPEOF(cs))
       )) = 0
       )) = 0
       )) = 0;
END_RULE;

RULE fill_area_style_constraint FOR ( fill_area_style );
WHERE
  WR1: SIZEOF(QUERY(fas <* fill_area_style |
       NOT (SIZEOF(fas.fill_styles) = 1 )
       )) = 0;
END_RULE;

RULE fill_area_style_unique_constraint FOR (fill_area_style);

LOCAL
  r :  BAG OF fill_area_style := QUERY (r <* fill_area_style | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\fill_area_style.name ) THEN
    IF (r[i]\fill_area_style.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\fill_area_style.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;

END_RULE;

RULE functional_unit_network_node_definition_unique_constraint FOR
 ( network_node_definition );
LOCAL
  funnd : BAG OF network_node_definition := 
 QUERY( nnd <* network_node_definition
| (nnd.frame_of_reference.name = 'functional network design') );
  name_bag : BAG OF STRING := [];
  nnd_bag : BAG OF network_node_definition;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(funnd) by 1;
  IF EXISTS( funnd[i]\product_definition.name ) THEN
    IF( NOT( funnd[i]\product_definition.name IN name_bag ) ) THEN
      name_bag := name_bag + funnd[i]\product_definition.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  nnd_bag := QUERY( nnd <* funnd | (nnd\product_definition.name = 
          name_bag[i]) );
  REPEAT j := 1 to SIZEOF(nnd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( nnd_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND 
                  (pdr\product_definition_relationship.name = 'functional unit network node')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE functional_unit_unique_constraint FOR
 ( component_functional_unit );
LOCAL
  fu : BAG OF component_functional_unit := 
QUERY( cfu <* component_functional_unit
| (cfu.frame_of_reference.name = 'functional occurrence') );
  id_bag : BAG OF STRING := [];
  cfu_bag : BAG OF component_functional_unit;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fu) by 1;
  IF EXISTS( fu[i].id ) THEN
    IF( NOT( fu[i].id IN id_bag ) ) THEN
      id_bag := id_bag + fu[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  cfu_bag := QUERY( cfu <* fu | (cfu.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(cfu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( cfu_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
((pdr\product_definition_relationship.name = 'network composition')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'FUNCTIONAL_UNIT'
IN TYPEOF(pdr.relating_product_definition)) AND 
      (pdr.relating_product_definition.frame_of_reference.name =
       'functional network design')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR
 ( functional_unit_terminal_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  futd_bag : BAG OF functional_unit_terminal_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(functional_unit_terminal_definition) by 1;
  IF EXISTS( functional_unit_terminal_definition[i]\shape_aspect.name ) THEN
    IF( NOT( functional_unit_terminal_definition[i]\shape_aspect.name IN 
                                              name_bag ) ) THEN
      name_bag := name_bag + 
                    functional_unit_terminal_definition[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  futd_bag := QUERY( futd <* functional_unit_terminal_definition |
((futd\shape_aspect.name = name_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(futd.of_shape.definition)) AND
(futd.of_shape.definition.frame_of_reference.name = 
                                    'functional design usage')) );
  REPEAT j := 1 to SIZEOF(futd_bag) by 1;
    IF EXISTS( futd_bag[j].of_shape.definition ) THEN
      IF ( futd_bag[j].of_shape.definition IN fu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        fu_bag := fu_bag + futd_bag[j].of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE geometric_tolerance_qualifier_constraint FOR
  (measure_qualification);
WHERE
  WR1: SIZEOF(QUERY(mq <* measure_qualification |
       ((mq\measure_qualification.name = 'predefined geometric tolerance qualifier')
       OR (mq\measure_qualification.name = 'user defined geometric tolerance qualifier'))
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MEASURE_WITH_UNIT' IN TYPEOF(mq.qualified_measure))
       AND(SIZEOF(QUERY(pugt <* USEDIN(mq.qualified_measure,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GEOMETRIC_TOLERANCE.MAGNITUDE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt)))) = 0)
       ))) = 0;
END_RULE;

RULE inter_stratum_extent_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'inter stratum extent') AND
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.related_product_definition)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.relating_product_definition)) 
       ))) = 0;
END_RULE;

RULE interconnect_module_stratum_assembly_relationship_constraint FOR
( assembly_component_usage );
WHERE
  WR1: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT' IN TYPEOF(acu.relating_product_definition))
       )) = 0;
  WR2: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(acu.related_product_definition))
       )) = 0;
END_RULE;

RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  imsar : BAG OF assembly_component_usage := 
QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(imsar) by 1;
  IF EXISTS( imsar[i].relating_product_definition ) THEN
    IF( (imsar[i].relating_product_definition.frame_of_reference.name = 
        'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(imsar[i].relating_product_definition)) ) THEN
      IF ( NOT ( imsar[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + imsar[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  acu_bag := 
   QUERY( acu <* imsar | (acu.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].reference_designator ) THEN
      IF ( acu_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + acu_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE internal_stratum_access_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  isa : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'internal stratum access'));
  paa_bag : BAG OF probe_access_area := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pp_bag : BAG OF plated_passage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(isa) by 1;
  IF EXISTS( isa[i].relating_shape_aspect ) THEN
    IF ( (isa[i].relating_shape_aspect\shape_aspect.description = 
'internal probe access area') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROBE_ACCESS_AREA' IN TYPEOF(isa[i].relating_shape_aspect)) ) THEN
      IF ( NOT ( isa[i].relating_shape_aspect IN paa_bag ) ) THEN
        paa_bag := paa_bag + isa[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(paa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pp_bag := [];
  sar_bag := QUERY( sar <* isa | ((sar.relating_shape_aspect :=: 
paa_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PLATED_PASSAGE' IN TYPEOF(sar.related_shape_aspect)) AND
(sar.related_shape_aspect\shape_aspect.description IN 
['bonded conductive base blind via',
'buried via','interfacial connection','non conductive base blind via',
'plated conductive base blind via'])) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pp_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pp_bag := pp_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  adr_bag : BAG OF applied_document_reference;
  duc : BAG OF document_usage_constraint;
  pass : BOOLEAN := TRUE;
  duc_bag : BAG OF document_usage_constraint := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(land_physical_template) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  adr_bag := USEDIN(land_physical_template[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
  REPEAT j := 1 to SIZEOF(adr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    duc := QUERY( r <* USEDIN(adr_bag[j].assigned_document,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (r\document_usage_constraint.subject_element =
'predefined classification code') );
    REPEAT k := 1 to SIZEOF(duc) by 1;
      IF EXISTS( duc[k] ) THEN
        IF ( duc[k] IN duc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          duc_bag := duc_bag + duc[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE land_template_terminal_unique_constraint FOR
 ( land_template_terminal );
LOCAL
  ltt : BAG OF land_template_terminal := 
QUERY( sa <* land_template_terminal |
(sa\shape_aspect.description IN ['interface terminal','join terminal']) );
  name_bag : BAG OF STRING := [];
  ltt_bag : BAG OF land_template_terminal;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  lpt_bag : BAG OF land_physical_template;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ltt) by 1;
  IF EXISTS( ltt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ltt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ltt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  lpt_bag := [];
  ltt_bag := QUERY( sa <* ltt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(ltt_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(ltt_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'associated definition') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN lpt_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          lpt_bag := lpt_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE marking_constraint FOR ( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'marking')
       AND (SIZEOF(QUERY(pdr <* USEDIN(rep,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition)))) > 0))
       AND NOT (SIZEOF(QUERY(place <* rep.items |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PLACEMENT' IN TYPEOF (place))
       AND (place\representation_item.name = 'marking location'))
       )) = 1)
       )) = 0;
END_RULE;

RULE mating_connector_placement_relationship_constraint FOR
( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'mating connector placement')
       AND (SIZEOF(QUERY(p <* sr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PLACEMENT' IN TYPEOF(p))
       AND (p\representation_item.name = 'connector placement'))) = 0))) = 0;
END_RULE;

RULE model_parameter_unique_constraint FOR
 ( model_parameter );
LOCAL
  name_bag : BAG OF STRING := [];
  mp_bag : BAG OF model_parameter;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  d_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(model_parameter) by 1;
  IF EXISTS( model_parameter[i]\representation_item.name ) THEN
    IF( NOT( model_parameter[i]\representation_item.name IN name_bag ) ) THEN
      name_bag := name_bag + model_parameter[i]\representation_item.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mp_bag := QUERY( mp <* model_parameter | (mp\representation_item.name = name_bag[i]) );
  d_bag := [];
  REPEAT j := 1 to SIZEOF(mp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := USEDIN( mp_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN d_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          d_bag := d_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE next_higher_assembly_interface_requirement_constraint FOR 
( specified_higher_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(shuo <* specified_higher_usage_occurrence |
       NOT(SIZEOF(QUERY(pd <* USEDIN(shuo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))
       AND (pdr.used_representation\representation.name = '3d bound volume shape'))) = 0)
       )) = 0)
       )) = 0;
END_RULE;

RULE next_higher_assembly_relationship_unique_constraint FOR
 ( next_assembly_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  nauo_bag : BAG OF next_assembly_usage_occurrence;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(next_assembly_usage_occurrence) by 1;
  IF EXISTS( next_assembly_usage_occurrence[i].relating_product_definition )
                                                               THEN
    IF( 
(next_assembly_usage_occurrence[i].
                relating_product_definition.frame_of_reference.name 
                                                  = 'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' 
     IN TYPEOF(next_assembly_usage_occurrence[i].
                                relating_product_definition)) ) THEN
      IF ( NOT ( next_assembly_usage_occurrence[i].
                                  relating_product_definition 
                                              IN pu_bag )) THEN
        pu_bag := pu_bag + 
             next_assembly_usage_occurrence[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  nauo_bag := QUERY( nauo <* next_assembly_usage_occurrence | 
                  (nauo.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(nauo_bag) by 1;
    IF EXISTS( nauo_bag[j].reference_designator ) THEN
      IF ( nauo_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + nauo_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE no_shape_for_make_from FOR
  (make_from_usage_option);
WHERE
  WR1: SIZEOF (QUERY (mfuo <* make_from_usage_option |
       NOT (SIZEOF (QUERY (pd <* USEDIN (mfuo, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE' IN 
       TYPEOF (pd))) = 0))) = 0;
END_RULE;

RULE organization_unique_constraint FOR (organization);

LOCAL
  r : BAG OF organization := QUERY (r <* organization | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\organization.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;
END_RULE;

RULE origin_constraint FOR (placement);
LOCAL
 origin_2d : SET OF axis2_placement_2d := QUERY(pl <* placement | ((pl\representation_item.name = 'origin') AND 
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D' IN TYPEOF(pl))));
 origin_3d : SET OF axis2_placement_3d := QUERY(pl <* placement | ((pl\representation_item.name = 'origin') AND 
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(pl))));
pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(origin_2d) by 1;
  IF (NOT pass) THEN ESCAPE; END_IF;
  IF (NOT((origin_2d[i].location.coordinates[1] = 0.0) AND
   (origin_2d[i].location.coordinates[2] = 0.0) AND
   NOT EXISTS(origin_2d[i].ref_direction)))
  THEN
   pass := FALSE;
  END_IF;
END_REPEAT;
REPEAT i := 1 to SIZEOF(origin_3d) by 1;
  IF (NOT pass) THEN ESCAPE; END_IF;
  IF NOT(
   (origin_3d[i].location.coordinates[1] = 0.0) AND
   (origin_3d[i].location.coordinates[2] = 0.0) AND
   (origin_3d[i].location.coordinates[3] = 0.0) AND
   (NOT(EXISTS(origin_3d[i].ref_direction))) AND 
   (NOT(EXISTS(origin_3d[i].axis)))
   )
  THEN
   pass := FALSE;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass; 
END_RULE;

RULE package_external_reference_constraint FOR
  (representation);
WHERE
   WR1: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'design owner')))) = 1)))=0;
   WR2: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'part number')))) = 1)))=0;
   WR3: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'revision code')))) = 1)))=0;
   WR4: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'product definition id')))) = 1)))=0;
END_RULE;

RULE package_terminal_external_reference_constraint FOR
  (descriptive_representation_item);
WHERE
  WR1: SIZEOF(QUERY(dri <* descriptive_representation_item |
       (dri\representation_item.name = 'package terminal external reference')
       AND (SIZEOF(QUERY(rep <* USEDIN(dri,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REPRESENTATION.ITEMS') |
       (rep\representation.name = 'package external reference'))) = 0)
       )) = 0;
END_RULE;

RULE package_terminal_external_reference_unique_constraint FOR
 ( descriptive_representation_item );
LOCAL
  pter : BAG OF descriptive_representation_item := 
                QUERY( dri <* descriptive_representation_item
| (dri\representation_item.name = 'package terminal external reference') );
  desc_bag : BAG OF STRING := [];
  dri_bag : BAG OF descriptive_representation_item;
  rep_bag : BAG OF representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  IF EXISTS( pter[i]\descriptive_representation_item.description ) THEN
    IF ( NOT ( pter[i]\descriptive_representation_item.description IN desc_bag )) THEN
      desc_bag := desc_bag + pter[i]\descriptive_representation_item.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(desc_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  r_bag := [];
  dri_bag := QUERY( dri <* pter | (dri\descriptive_representation_item.description = desc_bag[i]) );
  REPEAT j := 1 to SIZEOF(dri_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rep_bag := QUERY( r <* USEDIN( dri_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'REPRESENTATION.ITEMS' ) | (r\representation.name = 'package external reference') );
    REPEAT k := 1 to SIZEOF(rep_bag) by 1;
      IF EXISTS( rep_bag[k] ) THEN
        IF ( rep_bag[k] IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + rep_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE package_unique_constraint FOR
 ( package); --, externally_defined_package, library_defined_package );
LOCAL
  p : BAG OF physical_unit := QUERY( r <* package |
(r.frame_of_reference.name = 'physical design usage') );
(**  edp : BAG OF physical_unit := QUERY( r <* externally_defined_package |
(r.frame_of_reference.name = 'physical design usage') );
  ldp : BAG OF physical_unit := QUERY( r <* library_defined_package |
(r.frame_of_reference.name = 'physical design usage') ); *)
  pu : BAG OF physical_unit;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation := [];
END_LOCAL;

pu := p + edp + ldp;

REPEAT i := 1 to SIZEOF(pu) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := USEDIN( pu[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION' );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( pd_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | 
(pdr.used_representation\representation.name =
'registered case style') );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].used_representation ) THEN
        IF ( pdr_bag[k].used_representation IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + pdr_bag[k].used_representation;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE packaged_connector_terminal_relationship_unique_constraint FOR
 ( packaged_connector_terminal_relationship );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  pctr_bag : BAG OF packaged_connector_terminal_relationship;
  it_bag : BAG OF packaged_part_terminal;
  jt_bag : BAG OF packaged_part_terminal;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(packaged_connector_terminal_relationship) by 1;
  IF EXISTS( packaged_connector_terminal_relationship[i].
                               of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' 
   IN TYPEOF(packaged_connector_terminal_relationship[i].
                               of_shape.definition) ) THEN
      IF ( NOT ( packaged_connector_terminal_relationship[i].
                               of_shape.definition 
                                           IN pu_bag )) THEN
        pu_bag := pu_bag + 
    packaged_connector_terminal_relationship[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  it_bag := [];
  jt_bag := [];
  pctr_bag := QUERY( r <* packaged_connector_terminal_relationship | 
                            (r.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pctr_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass1 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].relating_shape_aspect))
AND (pctr_bag[j].relating_shape_aspect\shape_aspect.description = 'join terminal') ) THEN
      IF EXISTS( pctr_bag[j].relating_shape_aspect ) THEN
        IF ( pctr_bag[j].relating_shape_aspect IN jt_bag ) THEN
          pass1 := FALSE;
          ESCAPE;
        ELSE
          jt_bag := jt_bag + pctr_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
    IF ( pass2 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].related_shape_aspect))
AND (pctr_bag[j].related_shape_aspect\shape_aspect.description = 
'interface terminal') ) THEN
      IF EXISTS( pctr_bag[j].related_shape_aspect ) THEN
        IF ( pctr_bag[j].related_shape_aspect IN it_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          it_bag := it_bag + pctr_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE;

RULE packaged_part_unique_constraint FOR
 ( packaged_part); --, externally_defined_packaged_part, library_defined_packaged_part);
LOCAL
  pp : SET OF physical_unit := packaged_part; -- + externally_defined_packaged_part + library_defined_packaged_part;
  pdr_bag : BAG OF product_definition_relationship;
  pdf_bag : BAG OF product_definition_formation := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pp) by 1;
  IF ( NOT pass ) THEN ESCAPE; END_IF;
    pdf_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN( pp[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
((pdr\product_definition_relationship.name = 'used package')
AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGE' IN TYPEOF(pdr.relating_product_definition)) (** OR
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EXTERNALLY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition)) OR
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LIBRARY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition))  *)
) ) );
    pdf_bag := pdf_bag + pdr_bag[1].relating_product_definition.formation;
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
     IF ( NOT pass ) THEN ESCAPE; END_IF;
      IF EXISTS( pdr_bag[k].relating_product_definition.formation ) THEN
        IF NOT( pdr_bag[k].relating_product_definition.formation IN pdf_bag ) THEN
          pass := FALSE;
        END_IF;
      END_IF;
    END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE part_device_terminal_model_port_assignment_unique_constraint FOR
 ( property_definition_representation );
LOCAL
  amp_bag : BAG OF analytical_model_port := [];
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(property_definition_representation) by 1;
  IF EXISTS( property_definition_representation[i].used_representation )
                                                            THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ANALYTICAL_MODEL_PORT' IN TYPEOF(
property_definition_representation[i].used_representation) ) THEN
      IF( NOT( property_definition_representation[i].used_representation IN 
                                              amp_bag ) )
                                                               THEN
        amp_bag := amp_bag + 
              property_definition_representation[i].used_representation;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(amp_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  pdr_bag := QUERY( pdr <* property_definition_representation | 
                            (pdr.used_representation :=: amp_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].definition.definition ) THEN
      IF ( pdr_bag[j].definition.definition IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + pdr_bag[j].definition.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE part_device_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  sa_bag : BAG OF shape_aspect;
  pd_bag : BAG OF property_definition;
  sa : BAG OF bare_die_terminal;
  pass : BOOLEAN := TRUE;
  bdt_bag : BAG OF bare_die_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect) by 1;
  IF EXISTS( shape_aspect[i].of_shape.definition ) THEN
    IF( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
TYPEOF(shape_aspect[i].of_shape.definition)) AND
(shape_aspect[i].of_shape.definition.description = 'part device') ) THEN
      IF( NOT( shape_aspect[i].of_shape.definition IN pdr_bag ) ) THEN
        pdr_bag := pdr_bag + shape_aspect[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  bdt_bag := [];
  sa_bag := QUERY( sa <* shape_aspect | (sa.of_shape.definition :=: 
                   pdr_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := QUERY( pd <* USEDIN(
sa_bag[j].of_shape.definition.related_product_definition,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF([
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'BARE_DIE'
-- ,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE',
-- 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE'
] * TYPEOF(pd.definition))>0) );
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      sa := QUERY( bdt <* USEDIN(pd_bag[k],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT.OF_SHAPE') |
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'BARE_DIE_TERMINAL' IN TYPEOF(bdt)) );
      REPEAT l := 1 to SIZEOF(sa) by 1;
        IF EXISTS( sa[l] ) THEN
          IF ( sa[l] IN bdt_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            bdt_bag := bdt_bag + sa[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE part_device_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  pd : BAG OF product_definition_relationship := QUERY( pdr <*
product_definition_relationship | (pdr\product_definition_relationship.description = 'part device') );
  pu_bag : BAG OF physical_unit := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pd) by 1;
  IF EXISTS( pd[i].relating_product_definition ) THEN
    IF( (pd[i].relating_product_definition.frame_of_reference.name =
'physical design usage') AND (SIZEOF(
['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART'
-- ,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART',
-- 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART'
] * 
TYPEOF(pd[i].relating_product_definition))>0) ) THEN
      IF( NOT( pd[i].relating_product_definition IN pu_bag ) ) THEN
        pu_bag := pu_bag + pd[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  pdr_bag := QUERY( pdr <* pd | (pdr.relating_product_definition :=: 
                                                       pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j]\product_definition_relationship.name ) THEN
      IF ( pdr_bag[j]\product_definition_relationship.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + pdr_bag[j]\product_definition_relationship.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE part_feature_constraint FOR
  (shape_aspect, product_definition, shape_aspect_relationship);
LOCAL
pass : BOOLEAN := TRUE;
name_bag : BAG OF STRING := [];
sa : BAG OF shape_aspect := [];
pd : BAG OF product_definition := QUERY ( pd <* product_definition |
       pd.frame_of_reference\application_context_element.name
       = 'physical design usage');
END_LOCAL;
 REPEAT i := 1 to SIZEOF (pd) by 1;
name_bag := [];
sa := QUERY ( sa <* shape_aspect | (
(sa.of_shape\property_definition.definition = pd[i]) AND
(sa.product_definitional) AND
(NOT (sa\shape_aspect.description = 'connection zone'))
));
  REPEAT j := 1 to SIZEOF (sa) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
 IF sa[j]\shape_aspect.name in name_bag THEN pass := FALSE;
 ELSE
  name_bag := name_bag + sa[j]\shape_aspect.name;
 END_IF;
  END_REPEAT;
 END_REPEAT;
WHERE
 WR1: pass;
 WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
      (sar\shape_aspect_relationship.name = 'precedent feature') AND
      (sar.related_shape_aspect = sar.relating_shape_aspect))) = 0;
 WR3: SIZEOF(QUERY(sa <* shape_aspect | 
      ((sa\shape_aspect.description = 'part group feature') OR
      (sa\shape_aspect.description = 'part generic feature') OR
      (sa\shape_aspect.description = 'polarity indication feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 1))) = 0;
 WR4: SIZEOF(QUERY(sa <* shape_aspect |
      ((sa\shape_aspect.description = 'interconnect module edge segment surface') OR
      (sa\shape_aspect.description = 'interconnect module cavity surface') OR
      (sa\shape_aspect.description = 'interconnect module cutout surface') OR
      (sa\shape_aspect.description = 'interconnect module edge surface') OR
      (sa\shape_aspect.description = 'interconnect module primary surface') OR
      (sa\shape_aspect.description = 'interconnect module secondary surface') OR
      (sa\shape_aspect.description = 'interconnect module surface feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 0))) = 0;
END_RULE;

RULE part_feature_unique_constraint FOR
 ( composite_shape_aspect, shape_aspect, primary_orientation_feature,
tertiary_orientation_feature,
secondary_orientation_feature, package_body, part_tooling_feature,
thermal_feature, part_mounting_feature, package_terminal,
assembly_module_terminal, bare_die_terminal, interconnect_module_terminal,
minimally_defined_bare_die_terminal, packaged_part_terminal, 
package_body_surface );
LOCAL
  csa : BAG OF shape_aspect := QUERY( r <* composite_shape_aspect |
(r\shape_aspect.description = 'part group feature') );
  sa : BAG OF shape_aspect := QUERY( r <* shape_aspect |
(r\shape_aspect.description IN ['part generic feature','polarity indication feature',
'interconnect module edge segment surface',
'interconnect module cavity surface',
'interconnect module cutout surface',
'interconnect module edge surface',
'interconnect module primary surface',
'interconnect module secondary surface',
'interconnect module surface feature']) );
  pof : BAG OF shape_aspect := QUERY( r <* 
                  primary_orientation_feature | (TRUE) );
  sof : BAG OF shape_aspect := QUERY( r <* 
                 secondary_orientation_feature | (TRUE) );
  tof : BAG OF shape_aspect := QUERY( r <* 
                 tertiary_orientation_feature | (TRUE) );
  pb : BAG OF shape_aspect := QUERY( r <* 
                                package_body | (TRUE) );
  ptf : BAG OF shape_aspect := QUERY( r <* part_tooling_feature | (TRUE) );
  tf : BAG OF shape_aspect := QUERY( r <* thermal_feature | (TRUE) );
  pmf : BAG OF shape_aspect := QUERY( r <* part_mounting_feature | (TRUE) );
  pt : BAG OF shape_aspect := QUERY( r <* package_terminal | (TRUE) );
  amt : BAG OF shape_aspect := QUERY( r <* 
                            assembly_module_terminal | (TRUE) );
  bdt : BAG OF shape_aspect := QUERY( r <* bare_die_terminal | (TRUE) );
  imt : BAG OF shape_aspect := QUERY( r <* 
                          interconnect_module_terminal | (TRUE) );
  mdbdt : BAG OF shape_aspect := QUERY( r <* 
                    minimally_defined_bare_die_terminal | (TRUE) );
  ppt : BAG OF shape_aspect := QUERY( r <* 
                                  packaged_part_terminal | (TRUE) );
  pbs : BAG OF shape_aspect := QUERY( r <* 
                                       package_body_surface | (TRUE) );
  pf : BAG OF shape_aspect := [];
  pu_bag : BAG OF physical_unit := [];
  sa_bag : BAG OF shape_aspect;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

sa := csa + sa + pof + sof +tof + pb + ptf + tf + pmf + 
          pt + amt + bdt + imt + mdbdt + ppt + pbs;
REPEAT i := 1 to SIZEOF(sa) by 1;
  IF EXISTS( sa[i] ) THEN
    IF ( NOT ( sa[i] IN pf )) THEN
      pf := pf + sa[i];
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pf) by 1;
  IF EXISTS( pf[i].of_shape.definition ) THEN
    IF ( (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(pf[i].of_shape.definition)) AND
(pf[i].of_shape.definition.frame_of_reference.name = 
'physical design usage') ) THEN
      IF ( NOT ( pf[i].of_shape.definition IN pu_bag )) THEN
        pu_bag := pu_bag + pf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  sa_bag := QUERY( sa <* pf | (sa.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF EXISTS( sa_bag[j]\shape_aspect.name ) THEN
      IF ( sa_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sa_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE part_template_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'part template non planar 2d shape')
       AND NOT(SIZEOF(QUERY(a2p3d <* mssr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(a2p3d))
       )) = 1)
       )) = 0;
END_RULE;

RULE part_terminal_external_reference_unique_constraint FOR
 ( representation );
LOCAL
  pter : BAG OF representation := QUERY( r <* representation |
(r\representation.name = 'part terminal external reference'));
  fn_bag : BAG OF STRING := [];
  ft_bag : BAG OF STRING := [];
  r_bag : BAG OF representation;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  REPEAT j := 1 to SIZEOF(pter[i].items) by 1;
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pter[i].items[j]) ) THEN
      IF ( (pter[i].items[j]\representation_item.name = 'feature name') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                                                  IN fn_bag )) ) THEN
        fn_bag := fn_bag + pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
      IF ( (pter[i].items[j]\representation_item.name = 'feature type') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                 IN ft_bag )) ) THEN
        ft_bag := ft_bag + 
        pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fn_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  REPEAT j := 1 to SIZEOF(ft_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    r_bag := QUERY( r <* pter | ((SIZEOF(
QUERY(ri <* r.items | ((ri\descriptive_representation_item.description =
ft_bag[j]) AND (ri\representation_item.name = 'feature type')) ) )>0) AND 
(SIZEOF(QUERY(ri <* r.items |
((ri\descriptive_representation_item.description = fn_bag[i]) AND 
         (ri\representation_item.name = 'feature name')) ) )>0)) );
    ptd_bag := [];
    REPEAT k := 1 to SIZEOF(r_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := USEDIN( r_bag[k], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION' );
      REPEAT l:= 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].definition.definition ) THEN
          IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF( pdr_bag[l].definition.definition ) ) THEN
            IF ( pdr_bag[l].definition.definition IN ptd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ptd_bag := ptd_bag + pdr_bag[l].definition.definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE planar_curve_constraint FOR ( shape_representation );
WHERE
WR1: SIZEOF (QUERY (sr <* shape_representation | 
(
NOT(NOT ( sr\representation.name IN ['planar projected shape',
       'bevel edge feature shape',
       'step edge feature shape',
       'radius edge feature shape']) OR
(sr\representation.
context_of_items\geometric_representation_context.
coordinate_space_dimension = 2)
))
)) = 0;
END_RULE;

RULE planned_effectivity_constraint FOR ( configuration_effectivity );
WHERE
  WR1: SIZEOF(QUERY(ce <* configuration_effectivity |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage))
       AND (ce.usage\product_definition_relationship.name = 'assembly composition'))
       )) = 0;
  WR2: SIZEOF(QUERY(ce <* configuration_effectivity |
       SIZEOF(USEDIN(ce,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0 
       )) = 0;

END_RULE;

RULE planned_effectivity_unique_constraint FOR
 ( configuration_effectivity );
LOCAL
  ce_bag : BAG OF configuration_effectivity;
  ci_bag : BAG OF configuration_item := [];
  pass : BOOLEAN := TRUE;
  acu_bag : BAG OF assembly_component_usage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_effectivity) by 1;
  IF EXISTS( configuration_effectivity[i].configuration.configuration ) THEN
    IF( NOT( configuration_effectivity[i].configuration.configuration IN 
                                                            ci_bag ) ) THEN
      ci_bag := ci_bag + 
               configuration_effectivity[i].configuration.configuration;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ci_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ce_bag := QUERY( r <* configuration_effectivity |
((r.configuration.configuration :=: ci_bag[i]) AND 
                              (r.usage\product_definition_relationship.name = 'assembly composition')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(r.usage)) ) );
  acu_bag := [];
  REPEAT j := 1 to SIZEOF(ce_bag) by 1;
    IF EXISTS( ce_bag[j].usage ) THEN
      IF ( ce_bag[j].usage IN acu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        acu_bag := acu_bag + ce_bag[j].usage;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE plus_minus_tolerance_range_representation_constraint FOR
  (shape_dimension_representation, plus_minus_tolerance);
WHERE
  WR1: SIZEOF(QUERY(pmt <* plus_minus_tolerance |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'TOLERANCE_VALUE' IN TYPEOF (pmt.range))
       )) = 0;
END_RULE;

RULE positional_boundary_member_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition))))) = 0; 
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'DIMENSIONAL_SIZE_PROPERTY' IN 
       TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'boundary member associated dimension')
       )) = 1))) = 0; 
END_RULE;

RULE positional_boundary_offset_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF (pd.definition)) AND
 (pd.definition\shape_aspect_relationship.name = 'positional boundary and profile boundary member'))
       )) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'boundary offset') AND
       (pdr.relating_property_definition\property_definition.name =
       'profile related positional boundary property'))) = 1)
       )) = 0;
END_RULE;

RULE product_association_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       (pdfr\product_definition_formation_relationship.name = 'product association')
       AND (SIZEOF(QUERY(adr <* USEDIN(pdfr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document))
       )) = 0))) = 0;
END_RULE;

RULE product_association_unique_constraint FOR
 ( product_definition_formation_relationship );
LOCAL
  pdfr : BAG OF product_definition_formation_relationship := QUERY( r <*
product_definition_formation_relationship | 
  (r\product_definition_formation_relationship.name = 'product association' ) );
  pdf_bag : BAG OF product_definition_formation := [];
  pdfr_bag : BAG OF product_definition_formation_relationship;
  pass : BOOLEAN := TRUE;
  adr_bag : BAG OF applied_document_reference;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pdfr) by 1;
  IF EXISTS( pdfr[i].relating_product_definition_formation ) THEN
    IF( NOT( pdfr[i].relating_product_definition_formation IN pdf_bag ) )
                                                              THEN
      pdf_bag := pdf_bag + pdfr[i].
                 relating_product_definition_formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdfr_bag := QUERY( r <* pdfr | 
             (r.relating_product_definition_formation :=: pdf_bag[i]) );
  es_bag := [];
  REPEAT j := 1 to SIZEOF(pdfr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( pdfr_bag[j], 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EE_SPECIFICATION') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE product_concept_requires_configuration_item FOR
  (product_concept, configuration_item);
WHERE
  WR1: SIZEOF (QUERY (pc <* product_concept |
       NOT (SIZEOF (QUERY (ci <* configuration_item |
       pc :=: ci.item_concept)) >=1 ))) = 0;
END_RULE;

RULE product_definition_formation_requires_approval FOR
(product_definition,
  applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       pd.formation IN aaa.items )) = 1 )))) = 0;
END_RULE;

RULE product_definition_formation_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition|
       (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       (pd.formation IN apaoa.items) AND (apaoa.role\person_and_organization_role.name = 'creator'))) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       (pd.formation IN aoa.items) AND (aoa.role\organization_role.name = 'creator'))) = 1 ))))) = 0;
END_RULE;

RULE product_definition_requires_date_or_date_and_time FOR
  (product_definition, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT 
       (NOT(is_ee_product_definition(pd)) OR 
       ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       pd IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       pd IN ada.items )) = 1 )))
       )) = 0;
END_RULE;

RULE product_definition_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT
       (NOT(is_ee_product_definition(pd)) OR
       ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       pd IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       pd IN aoa.items )) = 1 )))
       )) = 0;
END_RULE;

RULE product_requires_person_organization FOR
  (product, applied_person_and_organization_assignment,
   applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       prod IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       prod IN aoa.items )) = 1 )))) = 0;
END_RULE;

RULE product_requires_product_definition_formation FOR
  (product, product_definition_formation);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT (SIZEOF (QUERY (pdf <* product_definition_formation |
       prod :=: pdf.of_product )) >= 1 ))) = 0;
END_RULE;

RULE profile_boundary_definition_with_offsets_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       ((pd\property_definition.description = 'boundary zone definition with specified size')
       AND (pd\property_definition.name = 'profile boundary with offsets'))
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN
       TYPEOF(pd.definition))
       )) = 0;
END_RULE;

RULE profile_related_positional_boundary_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition)) AND
       (pd.definition\shape_aspect.description = 'profile related positional boundary')
       ))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
(pdr.related_property_definition\property_definition.description = 'positional boundary offset')
       AND (pdr\property_definition_relationship.name = 'boundary offset'))) = 1))) = 0;
END_RULE;

RULE projected_zone_and_base_relationship_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end))
       OR (pzd.projection_end.product_definitional = TRUE)))) = 0;
END_RULE;

RULE projected_zone_height_characteristic_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length))
       )) = 0;
END_RULE;

RULE promissory_usage_relationship_constraint FOR 
( promissory_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT' IN TYPEOF (puo.relating_product_definition))
       AND (puo.relating_product_definition.frame_of_reference.name
       = 'physical design'))) = 0;
  WR2: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       SIZEOF(USEDIN(puo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 0)) = 0;
END_RULE;

RULE promissory_usage_relationship_unique_constraint FOR
 ( promissory_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  puo_bag : BAG OF promissory_usage_occurrence;
  pass : BOOLEAN := TRUE;
  comp_bag : BAG OF physical_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(promissory_usage_occurrence) by 1;
  IF EXISTS( promissory_usage_occurrence[i].relating_product_definition ) 
                                                      THEN
    IF( (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_UNIT') IN
TYPEOF(promissory_usage_occurrence[i].relating_product_definition)) AND (
promissory_usage_occurrence[i].relating_product_definition.
frame_of_reference.name =
'physical design') ) THEN
      IF( NOT( promissory_usage_occurrence[i].
                                relating_product_definition IN pu_bag ) ) 
                                                                THEN
        pu_bag := pu_bag + promissory_usage_occurrence[i].
                                             relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  puo_bag := QUERY( puo <* promissory_usage_occurrence | 
      (puo.relating_product_definition :=: pu_bag[i]) );
  comp_bag := [];
  REPEAT j := 1 to SIZEOF(puo_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF ( ((
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_UNIT') IN
TYPEOF(puo_bag[j].related_product_definition)) AND (
puo_bag[j].related_product_definition.frame_of_reference.name IN [
'physical design',
'physical design usage']) ) THEN
      IF EXISTS( puo_bag[j].related_product_definition ) THEN
        IF ( puo_bag[j].related_product_definition IN comp_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          comp_bag := comp_bag + puo_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE radius_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum radius length')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum radius length')
       )) = 0))) = 0;
END_RULE;

RULE reference_composition_path_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
           TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'reference definition path')
       AND (pdr.relating_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
  WR2: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
         TYPEOF(pdr.related_product_definition))
       AND (pdr.related_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
END_RULE;

RULE reference_functional_unit_assignment_to_part_constraint FOR
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.related_product_definition))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLICATION_CONTEXT_ELEMENT' IN
       TYPEOF(pdr.related_product_definition.frame_of_reference))
       AND ((pdr.relating_product_definition.frame_of_reference.name
              = 'physical design')
       OR (pdr.relating_product_definition.frame_of_reference.name
              = 'physical design usage'))))) = 0; 
  WR2: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'design definition path')
       AND (pdr.relating_product_definition.id = 
         'reference composition path')
       ))) = 0; 
END_RULE;

RULE reference_functional_unit_assignment_to_part_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name =
'reference functional unit assignment to part' ) );
  d_bag : BAG OF STRING := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i]\shape_aspect_relationship.description ) THEN
    IF( NOT( sar[i]\shape_aspect_relationship.description IN d_bag ) ) THEN
      d_bag := d_bag + sar[i]\shape_aspect_relationship.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(d_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.description = d_bag[i]) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect.of_shape.definition ) THEN
      IF ( sar_bag[j].related_shape_aspect.of_shape.definition IN pd_bag )
                                                                    THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + 
                    sar_bag[j].related_shape_aspect.of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE registered_font_constraint FOR ( externally_defined_text_font );
WHERE
  WR1: SIZEOF(QUERY(edtf <* externally_defined_text_font |
       (SIZEOF(QUERY(adr <* USEDIN(edtf,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adr.assigned_document.kind\document_type.product_data_type = 
                     'font registration document')
       )) = 0))) = 0;
END_RULE;

RULE registered_font_unique_constraint FOR
 ( externally_defined_text_font );
LOCAL
  ii_bag : BAG OF STRING := [];
  edtf_bag : BAG OF externally_defined_text_font;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(externally_defined_text_font) by 1;
  IF EXISTS( externally_defined_text_font[i].item_id ) THEN
    IF ( NOT ( externally_defined_text_font[i].item_id IN ii_bag ) ) THEN
      ii_bag := ii_bag + externally_defined_text_font[i].item_id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ii_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  edtf_bag := QUERY( edtf <* externally_defined_text_font | 
            (edtf.item_id = ii_bag[i]) );
  REPEAT j := 1 to SIZEOF(edtf_bag) by 1;
    adr_bag := QUERY( adr <* USEDIN( edtf_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) | 
         (adr.assigned_document.kind\document_type.product_data_type =
'font registration document') );
    es_bag := [];
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE requirements_property_constraint FOR 
           (product_definition,
            descriptive_representation_item,
            requirements_property);
LOCAL
ri : BAG OF descriptive_representation_item := 
         QUERY (dri <* descriptive_representation_item 
                              | dri\representation_item.name = 
                                          'requirements name');
pd : BAG OF product_definition:=
         QUERY(tpd <* product_definition
               | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                  'APPLICATION_CONTEXT_ELEMENT' IN
                  TYPEOF(tpd.frame_of_reference)) AND
                  (tpd.frame_of_reference.name IN ['requirement',
                                                   'design requirement',
                                                   'assembly requirement'])
                  AND
                  (tpd.name = 'requirements model'));

r : BAG OF representation := [];
pdr : BAG OF property_definition_representation := [];
pass1 : BOOLEAN := TRUE;

rp : BAG OF property_definition := [];
pass2 : BOOLEAN := TRUE;

END_LOCAL;
  (* WR1 Test *)
  REPEAT i := 1 to SIZEOF (ri) by 1;
     r := [];
     pdr := [];
     r := (USEDIN(ri[i],
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REPRESENTATION.ITEMS'));
     pass1 := (SIZEOF(r) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pdr := (USEDIN(r[1],
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
     pass1 := (SIZEOF(pdr) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pass1 := ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr[1].definition));
     IF (NOT pass1) THEN ESCAPE; END_IF;
  END_REPEAT;
  (* WR2 Test *)
  REPEAT i := 1 to SIZEOF (pd) by 1;
     rp := [];
     IF (NOT pass2) THEN ESCAPE; END_IF;
     rp := QUERY(rp <* USEDIN(pd[i],
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION.DEFINITION') |
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
     pass2 := (SIZEOF(rp) = 1);
  END_REPEAT;
WHERE
 WR1: pass1;
 WR2: pass2;
END_RULE;

RULE requirements_property_unique_constraint FOR 
           (descriptive_representation_item,
            requirements_property);
LOCAL
desc_bag : BAG OF STRING := [];
pass1 : BOOLEAN := TRUE;
pdr : BAG OF property_definition_representation := [];
rep : BAG OF representation := [];
pd : BAG OF product_definition := [];

END_LOCAL;
  REPEAT i := 1 to SIZEOF (requirements_property) by 1;
     IF (NOT pass1) THEN ESCAPE; END_IF;
     IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PRODUCT_DEFINITION' IN TYPEOF(requirements_property[i].definition))
      THEN pd := pd + requirements_property[i].definition;
     END_IF;
  END_REPEAT;
  IF (instance_unique(pd) = FALSE ) THEN pass1 := FALSE; END_IF;
WHERE
 WR1: pass1;
END_RULE;

RULE restraint_condition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       ((pd\property_definition.description = 'restraint') 
       OR (pd\property_definition.description = 'tolerance specific restraint'))
       AND (SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
    + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
    + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'restraint description'))) = 0))) = 0;
END_RULE;

RULE restrict_action_request_status FOR (action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ars <* action_request_status |
       NOT (ars\action_request_status.status IN
       ['proposed', 'in work', 'issued', 'hold']))) = 0;
END_RULE;

RULE restrict_approval_status FOR (approval_status);
WHERE
  WR1: SIZEOF (QUERY (ast <* approval_status |
       NOT (ast\approval_status.name IN
       ['approved', 'not yet approved', 'disapproved', 'withdrawn']))) = 0;
END_RULE;

RULE restrict_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (dr\date_role.name IN ['creation date', 'request date', 'release date',
       'start date', 'contract date', 'certification date', 'sign off date',
       'classification date', 'declassification date']))) = 0;
END_RULE;

RULE restrict_manifold_surface_shape_representation FOR
  (manifold_surface_shape_representation);
  WHERE
    WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
         (mssr\representation.name IN ['stratum feature non planar 2d shape',
         'open shell based surface',
         'design intent modification non planar 2d shape', 
         'part template non planar 2d shape']) AND
         (NOT(SIZEOF(QUERY(sbsm <* mssr.items | 
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'SHELL_BASED_SURFACE_MODEL' IN TYPEOF(sbsm)) AND
         (SIZEOF(QUERY(os <* sbsm\shell_based_surface_model.sbsm_boundary |
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'OPEN_SHELL' IN TYPEOF(os))) = 1)
         )) = 1)))) = 0;
END_RULE;

RULE rule_action_unique_constraint FOR
 ( rule_action );
LOCAL
  adta : BAG OF applied_date_and_time_assignment;
  adta_bag : BAG OF applied_date_and_time_assignment := [];
  ra_bag : BAG OF rule_action;
  aaa_bag : BAG OF applied_action_assignment;
  pass : BOOLEAN := TRUE;
  rd_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_action) by 1;
  adta := USEDIN( rule_action[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' );
  REPEAT j := 1 to SIZEOF(adta) by 1;
    IF EXISTS( adta[j] ) THEN
      IF( NOT( adta[j] IN adta_bag ) ) THEN
        adta_bag := adta_bag + adta[j];
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(adta_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ra_bag := QUERY( r <* rule_action | (r IN adta_bag[i].items) );
  rd_bag := [];
  REPEAT j := 1 to SIZEOF(ra_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aaa_bag := QUERY( aa <* USEDIN( ra_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ACTION_ASSIGNMENT.ASSIGNED_ACTION' ) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_ACTION_ASSIGNMENT') IN TYPEOF(aa) ) );
    REPEAT k := 1 to SIZEOF(aaa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(aaa_bag[k].items) by 1;
        IF EXISTS( aaa_bag[k].items[l] ) THEN
          IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_FORMATION'  IN TYPEOF(aaa_bag[k].items[l])) AND
(aaa_bag[k].items[l]\product_definition_formation.description = 'rule version') ) THEN
            IF ( aaa_bag[k].items[l] IN rd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              rd_bag := rd_bag + aaa_bag[k].items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE rule_conclusion_definition_unique_constraint FOR 
(rule_conclusion_definition,
representation,representation_relationship);
LOCAL
r : BAG of representation := 
           QUERY (r <* representation | r\representation.name = 
                                             'rule definition');
rr : BAG OF representation_relationship := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
name_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   count := 0;
   name_bag := [];
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr := USEDIN(r[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'REPRESENTATION_RELATIONSHIP.REP_1');
   REPEAT j := 1 to SIZEOF (rr) by 1;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_CONCLUSION_DEFINITION' IN
       TYPEOF (rr[j].rep_2)
    THEN
      IF EXISTS( rr[j].rep_2\representation.name ) THEN
        IF rr[j].rep_2\representation.name IN name_bag
        THEN
         pass := FALSE;
        ELSE
         name_bag := name_bag + rr[j].rep_2\representation.name;
        END_IF;
      END_IF;
    END_IF;
   END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

RULE rule_function_unique_constraint FOR
 ( rule_function_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  rfd_bag : BAG OF rule_function_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_function_definition) by 1;
  IF EXISTS( rule_function_definition[i]\representation.name ) THEN
    IF( NOT( rule_function_definition[i]\representation.name IN name_bag ) ) THEN
      name_bag := name_bag + rule_function_definition[i]\representation.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  doc_bag := [];
  rfd_bag := QUERY( am <* rule_function_definition | 
               (am\representation.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(rfd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( rfd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) |
(adr.assigned_document.kind\document_type.product_data_type = 'reference document') );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE rule_premise_definition_unique_constraint FOR (rule_premise_definition,
representation,representation_relationship);
local
rr : BAG OF representation_relationship := [];
rpd : BAG OF rule_premise_definition := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
END_LOCAL;
  REPEAT i := 1 to SIZEOF (rule_premise_definition) by 1;
   count := 0;
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr :=
USEDIN(rule_premise_definition[i],'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_2');
    REPEAT j := 1 to SIZEOF (rr) by 1;
     IF NOT pass THEN ESCAPE;
     END_IF;
     IF (rr[j]\representation_relationship.rep_1\representation.description IN
              ['rule definition']) THEN
     count := count + 1;
     END_IF;
     IF count = 2 THEN pass := FALSE;
     END_IF;
    END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

RULE security_classification_constraint FOR (security_classification,
     applied_date_and_time_assignment, applied_date_assignment,
     applied_person_and_organization_assignment, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (sc IN adata.items) AND
       ('classification date' = adata.role\date_time_role.name))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (sc IN ada.items) AND
       ('classification date' = ada.role\date_role.name))) = 1 )))) = 0;
  WR2: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (apa <* applied_person_and_organization_assignment |
       (sc IN apa.items) AND
       (apa.role\person_and_organization_role.name = 'classification officer')
       )) = 0)) = 0;
  WR3: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (aaa <* applied_approval_assignment |
       (sc IN aaa.items))) = 0)) = 0;
END_RULE;

RULE shape_dimension_representation_constraint FOR
  (shape_dimension_representation);
WHERE
    wr1: SIZEOF (QUERY (sdr <* shape_dimension_representation | 
          NOT (SIZEOF (QUERY (i <* sdr.items |
            (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
            + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
             (SIZEOF (QUERY (mq <* USEDIN (i,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE') |
              mq\measure_qualification.name = 'dimension value qualifier')) <= 1))
            )) >= 1
         ))) = 0;
    wr2: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | (mq\measure_qualification.name = 'dimension value qualifier')
            AND             
              (SIZEOF (QUERY (q <* mq.qualifiers |
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                 + 'TYPE_QUALIFIER' IN TYPEOF (q))
               ) <> 1)
             )) > 0)
           )) > 0
         )) = 0;
    wr3: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | (mq\measure_qualification.name = 'dimension value qualifier')
            AND             
              (SIZEOF (QUERY (q <* mq.qualifiers |
                ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                 + 'TYPE_QUALIFIER' IN TYPEOF (q))
            AND
              (NOT (q\type_qualifier.name IN ['theoretically exact',
                               'maximum dimension',
                               'minumum dimersion',
                               'lower value',
                               'upper value',
                               'basic value']))
               )) > 0)
             )) > 0)
           )) > 0
         )) = 0;
    wr4: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | NOT (mq\measure_qualification.name IN ['dimension value qualifier',
                                   'predefined dimension qualifier',
                                   'user defined dimension qualifier'])
                )) > 0)
              )) > 0
            )) = 0;
     wr5: SIZEOF (QUERY (sdr <* shape_dimension_representation | NOT (
            SIZEOF (USEDIN (sdr, 
                   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                             + 'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.'
                                 + 'REPRESENTATION')) >= 1
           ))) = 0;
         

END_RULE;

RULE shape_element_constituent_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name IN [
'constituent', 'composing', 
'bare die terminal surface constituent relationship',
'interconnect module terminal surface constituent relationship',
'package terminal surface constituent relationship'] ) );
  sa_bag : BAG OF shape_aspect := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i].relating_shape_aspect ) THEN
    IF( NOT( sar[i].relating_shape_aspect IN sa_bag ) ) THEN
      sa_bag := sa_bag + sar[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE shape_element_deriving_relationship_unique_constraint FOR
 ( shape_aspect_deriving_relationship );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  sadr_bag : BAG OF shape_aspect_deriving_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect_deriving_relationship) by 1;
  IF EXISTS( shape_aspect_deriving_relationship[i].relating_shape_aspect )
                                                    THEN
    IF( NOT( shape_aspect_deriving_relationship[i].
                           relating_shape_aspect IN sa_bag ) ) 
                                                  THEN
      sa_bag := sa_bag + 
            shape_aspect_deriving_relationship[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sadr_bag := QUERY( r <* shape_aspect_deriving_relationship | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sadr_bag) by 1;
    IF EXISTS( sadr_bag[j].related_shape_aspect ) THEN
      IF ( sadr_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sadr_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE shape_element_locating_relationship_unique_constraint FOR
 ( dimensional_location );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  dl_bag : BAG OF dimensional_location;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location) by 1;
  IF EXISTS( dimensional_location[i].relating_shape_aspect ) THEN
    IF( NOT( dimensional_location[i].relating_shape_aspect IN sa_bag ) )
                                                              THEN
      sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  dl_bag := QUERY( r <* dimensional_location | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(dl_bag) by 1;
    IF EXISTS( dl_bag[j].related_shape_aspect ) THEN
      IF ( dl_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE shape_element_unique_constraint FOR 
           (representation,representation_item,
              property_definition_representation);
LOCAL
r : BAG OF representation := 
         QUERY (r <* representation | r\representation.name = 
                                          'shape element name');
ri : BAG OF representation_item := [];
pass : BOOLEAN := TRUE;
description_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
      pass := SIZEOF(QUERY(pdr <* 
  	     (USEDIN(r[i],
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))| 
   (pdr.definition\property_definition.description = 'shape element characterization'))) = 1;
      IF (NOT pass) THEN ESCAPE; END_IF;
      ri := QUERY ( ri <* representation_item | ri IN r[i].items);
      pass := (SIZEOF(ri) = 1);
      IF (NOT pass) THEN ESCAPE; END_IF;
      IF (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                     'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (ri)))
        THEN
         pass := FALSE;
         ESCAPE;
      END_IF;
      REPEAT j := 1 to SIZEOF (ri) by 1;
        IF EXISTS( ri[j]\descriptive_representation_item.description ) THEN
          IF (ri[j]\descriptive_representation_item.description IN 
                                               description_bag) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            description_bag := description_bag + 
                 ri[j]\descriptive_representation_item.description;
          END_IF;
        END_IF;
      END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

RULE shape_representation_requires_origin FOR (shape_representation);
WHERE
  WR1: 
(* 
pseudocode
co:FOREACH (sr <* shape_representation |c1);
c1:EXACTLYONE(it <* sr\representation.items |c2) 
   or ATLEASTONE(it <* sr\representation.items |c3)
   or EXACTLYNONE(it <* sr\representation.items |c4);
c2:((it.name = 'origin') or (it.name = 'orientation')) and 
   (AXIS2_PLACEMENT_2D in TYPEOF(it)  OR
    AXIS2_PLACEMENT_3D in TYPEOF(it));
c3:STYLED_ITEM in TYPEOF(it);
c4:((it.name = 'origin') or (it.name = 'orientation')) and
   ((sr.name = 'zone shape') or 
   (sr.context_of_items.context_type = 'connection zone colour'));
*)
SIZEOF(QUERY ( sr <* shape_representation |  NOT(
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and 
   (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it))  OR
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it)))
))) = 1
) 
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'STYLED_ITEM' in TYPEOF(it))
))) >= 1
)
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and
   ((sr\representation.name = 'zone shape') or 
   (sr.context_of_items\representation_context.context_type = 'connection zone colour'))
))) = 0
)
))) = 0;
END_RULE;

RULE step_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step depth')
       )) = 1))) = 0; 
 WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step width')
       )) = 1))) = 0; 
 WR3: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step depth')
       )) = 1))) = 0; 
 WR4: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step width')
       )) = 1))) = 0; 
END_RULE;

RULE stratum_average_surface_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum average surface shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'STRATUM_SURFACE' IN TYPEOF(pdr.definition.definition))
       AND (pdr.definition.definition\shape_aspect.description = 
                                            'average surface'))) = 1
       ))) = 0;

END_RULE;

RULE stratum_feature_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum feature non planar 2d shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'STRATUM_FEATURE' IN TYPEOF(pdr.definition.definition))
       )) = 1
       ))) = 0;
END_RULE;

RULE 
stratum_feature_shape_stratum_average_surface_shape_relationship_constraint
 FOR 
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum average surface shape')
       ))) = 0;
END_RULE;

RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
        'stratum feature shape stratum surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
            'stratum feature shape stratum surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum surface shape')
       ))) = 0;
END_RULE;

RULE stratum_feature_unique_constraint FOR
 ( stratum_feature );
LOCAL
  sf_bag : BAG OF stratum_feature;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_feature) by 1;
  IF EXISTS( stratum_feature[i].of_shape.definition ) THEN
    IF( NOT( stratum_feature[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_feature[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sf_bag := QUERY( r <* stratum_feature | 
             (r.of_shape.definition :=: s_bag[i]) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sf_bag) by 1;
    IF EXISTS( sf_bag[j]\shape_aspect.name ) THEN
      IF ( sf_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sf_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = '3d positioned stratum shape in interconnect module')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE;

RULE stratum_interconnect_module_planar_position_constraint FOR 
          (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 
          'planar positioned stratum shape in interconnect module')
    AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE;

RULE stratum_make_from_relationship_constraint FOR
(make_from_usage_option);
WHERE
  WR1: SIZEOF(QUERY(mfuo <* make_from_usage_option |
       (mfuo\product_definition_relationship.name = 'stratum make from')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(mfuo.related_product_definition)
       ))) = 0;
  WR2: SIZEOF(QUERY(mfuo <* make_from_usage_option |
       (mfuo\product_definition_relationship.name = 'stratum make from')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(mfuo.relating_product_definition)
       ))) = 0;
END_RULE;

RULE stratum_planar_shape_constraint FOR (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       NOT( NOT ((sr\representation.name = 'planar projected shape') AND 
       (SIZEOF(QUERY(pdr <* USEDIN(sr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.definition.definition))
       )) = 1))
       OR (SIZEOF(QUERY(a2p2d <* sr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(a2p2d))
       )) >= 0)))) = 0;
END_RULE;

RULE stratum_surface_in_stratum_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'stratum surface in stratum 3d position')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE;

RULE stratum_surface_unique_constraint FOR
 ( stratum_surface );
LOCAL
  ss_bag : BAG OF stratum_surface;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_surface) by 1;
  IF EXISTS( stratum_surface[i].of_shape.definition ) THEN
    IF( NOT( stratum_surface[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_surface[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ss_bag := QUERY( r <* stratum_surface | 
               (r.of_shape.definition :=: s_bag[i]) );
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(ss_bag) by 1;
    IF EXISTS( ss_bag[j]\shape_aspect.description ) THEN
      IF ( ss_bag[j]\shape_aspect.description IN desc_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        desc_bag := desc_bag + ss_bag[j]\shape_aspect.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE stratum_technology_line_width_tolerance_assignment_constraint FOR
(representation);
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(lmwu <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum positive deviation')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(si <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STYLED_ITEM' IN TYPEOF (si))
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(lmwu <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum negative deviation')
       )) = 1))) = 0;
END_RULE;

RULE substitute_product_constraint FOR (product,
assembly_component_usage_substitute);
WHERE
  WR1: SIZEOF(QUERY(acus <* assembly_component_usage_substitute |
       EXISTS(acus.substitute.reference_designator))) = 0;
END_RULE;

RULE subtype_combination_shape_aspect FOR (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DERIVED_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR2: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR3: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DERIVED_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR4: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PHYSICAL_UNIT_DATUM']
       * TYPEOF(sa)) <= 1))) = 0;

END_RULE;

RULE subtype_exclusive_action_request_assignment FOR 
  (action_request_assignment);
WHERE
  WR1: SIZEOF (QUERY (ara <* action_request_assignment |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHANGE_REQUEST',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'START_REQUEST']
       * TYPEOF(ara)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_dimensional_location FOR
  (dimensional_location);
WHERE  
  WR1: SIZEOF (QUERY (dl <* dimensional_location |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANGULAR_DIMENSION_WITH_ORIENTATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION_WITH_PATH']
       * TYPEOF(dl)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_dimensional_size FOR
  (dimensional_size);
WHERE  
  WR1: SIZEOF (QUERY (ds <* dimensional_size |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CURVE_DIMENSION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANGULAR_SIZE']
       * TYPEOF(ds)) <= 1) OR
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CURVE_DIMENSION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE']
       * TYPEOF(ds)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_mapped_item FOR (mapped_item);
WHERE
  WR1: SIZEOF (QUERY (mi <* mapped_item |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANNOTATION_TEXT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANNOTATION_SYMBOL'] *
       TYPEOF(mi)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_product_definition FOR (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NETWORK_NODE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_product_definition_relationship FOR
  (product_definition_relationship);
WHERE
  WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_USAGE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SUPPLIED_PART_RELATIONSHIP']
       * TYPEOF(pdr)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_property_definition FOR
  (property_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* property_definition |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_SIZE_PROPERTY',   
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_GROUP', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_PROPERTY', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SIGNAL']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_property_definition_representation FOR 
  (property_definition_representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* property_definition_representation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_DEFINITION_REPRESENTATION',   
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_PROPERTY_REPRESENTATION']
       * TYPEOF(pdr)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_representation FOR 
  (representation);
WHERE
  WR1: SIZEOF (QUERY (rep <* representation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'ANALYTICAL_MODEL_PORT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_FUNCTION_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_STRING_REPRESENTATION']
       * TYPEOF(rep)) <= 1))) = 0;
END_RULE;

RULE subtype_exclusive_representation_context FOR 
  (representation_context);
LOCAL
 pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(representation_context) by 1;
  pass := (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_CONTEXT' IN 
                          TYPEOF(representation_context[i]))
          OR (SIZEOF (TYPEOF(representation_context[i])) <= 2 )) 
       AND 
          (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
         * TYPEOF(representation_context[i])) <= 2 )) 
      AND
          (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT' IN 
                        TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
        * TYPEOF(representation_context[i])) <= 2 ));
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE subtype_exclusive_shape_aspect_relationship FOR 
  (shape_aspect_relationship);
WHERE
  WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_CONNECTIVITY_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_FEATURE_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_DERIVING_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP']
       * TYPEOF(sar)) <= 1))) = 0;
END_RULE;

RULE subtype_mandatory_action FOR (action);
WHERE
  WR1: SIZEOF (QUERY (act <* action |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIRECTED_ACTION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXECUTED_ACTION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_ACTION'] * 
       TYPEOF(act)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_address FOR (address);
WHERE
  WR1: SIZEOF (QUERY (add <* address |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PERSONAL_ADDRESS',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ORGANIZATIONAL_ADDRESS'] * 
       TYPEOF (add)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_composite_shape_aspect FOR
  (composite_shape_aspect);
WHERE  
  WR1: SIZEOF (QUERY (csa <* composite_shape_aspect |
       NOT (SIZEOF
       (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPOSITE_GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPOSITE_UNIT_SHAPE_ASPECT']
       * TYPEOF(csa)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_compound_representation_item FOR (compound_representation_item);
WHERE
  WR1: SIZEOF (QUERY (tl <* compound_representation_item |
       NOT ((
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATA_SET_REPRESENTATION_ITEM' IN TYPEOF (tl)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TABLE_REPRESENTATION_ITEM' IN
       TYPEOF(tl))))) = 0;
END_RULE;

RULE subtype_mandatory_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       NOT (
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CALENDAR_DATE'
       IN TYPEOF (d)))) = 0;
END_RULE;

RULE subtype_mandatory_externally_defined_item FOR 
                                       (externally_defined_item);
WHERE
  WR1: SIZEOF (QUERY (edi <* externally_defined_item |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BOND_CATEGORY',  
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_CURVE_FONT',
--       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
--       'EXTERNALLY_DEFINED_FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_HATCH_STYLE',
--       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
--       'EXTERNALLY_DEFINED_PHYSICAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'EXTERNALLY_DEFINED_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_SYMBOL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TEXT_FONT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TILE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TILE_STYLE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SIGNAL_CATEGORY'] * 
       TYPEOF (edi)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_geometric_tolerance FOR
  (geometric_tolerance);
WHERE  
  WR1: SIZEOF (QUERY (gt <* geometric_tolerance |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE'] *
       TYPEOF (gt)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item);
WHERE
  WR1: SIZEOF (QUERY (pdi <* pre_defined_item |
       NOT (SIZEOF 
       (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_TEXT_FONT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_CURVE_FONT'] *
       TYPEOF(pdi)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_product_definition_usage FOR
  (product_definition_usage);
WHERE
  WR1: SIZEOF (QUERY (pdu <* product_definition_usage |
       NOT (SIZEOF([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_USAGE_OPTION'] * 
       TYPEOF(pdu)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_runout_zone_orientation FOR
  (runout_zone_orientation);
WHERE  
  WR1: SIZEOF (QUERY (rzo <* runout_zone_orientation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION'] *
       TYPEOF (rzo)) = 1))) = 0;
END_RULE;

RULE subtype_mandatory_text_literal FOR (text_literal);
WHERE
  WR1: SIZEOF (QUERY (tl <* text_literal |
       NOT ((
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL_WITH_EXTENT' IN TYPEOF (tl)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN
       TYPEOF(tl))))) = 0;
END_RULE;

RULE supplied_product_version_unique_constraint FOR
 ( product_definition_formation_with_specified_source );
LOCAL
  spv : BAG OF product_definition_formation_with_specified_source := 
QUERY( r <*
product_definition_formation_with_specified_source | 
(SIZEOF(QUERY( pd <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PRODUCT_DEFINITION.FORMATION') |
(SIZEOF(QUERY( pdr <* USEDIN(pd, 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'SUPPLIED_PART_RELATIONSHIP')
IN TYPEOF(pdr))))>0)))>0));
  aoa_bag : BAG OF applied_organization_assignment;
  o_bag : BAG OF organization := [];
  pdf_bag : BAG OF product_definition_formation_with_specified_source;
  spn_bag : BAG OF STRING;
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(spv) by 1;
  aoa_bag := QUERY( aoa <* USEDIN( spv[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (aoa.role\organization_role.name = 'supplier') );
  REPEAT j := 1 to SIZEOF(aoa_bag) by 1;
    IF EXISTS( aoa_bag[j].assigned_organization ) THEN
      IF ( NOT ( aoa_bag[j].assigned_organization IN o_bag ) ) THEN
        o_bag := o_bag + aoa_bag[j].assigned_organization;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(o_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdf_bag := QUERY( pdf <* spv | (SIZEOF(QUERY( aoa <* USEDIN(pdf,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|
((aoa.role\organization_role.name = 'supplier') AND (aoa.assigned_organization :=: 
                                              o_bag[i])) ) )>0) );
  spn_bag := [];
  REPEAT j := 1 to SIZEOF(pdf_bag) by 1;
    IF EXISTS( pdf_bag[j].of_product.id ) THEN
      IF ( pdf_bag[j].of_product.id IN spn_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        spn_bag := spn_bag + pdf_bag[j].of_product.id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE transmission_line_functional_unit_terminal_allocation_unique_constraint
 FOR ( shape_aspect_relationship );
LOCAL
  tlfuta : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'transmission line functional terminal allocation'));
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  ut_bag : BAG OF shape_aspect := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(tlfuta) by 1;
  IF EXISTS( tlfuta[i].relating_shape_aspect ) THEN
    IF ( tlfuta[i].relating_shape_aspect\shape_aspect.description = 'unit terminal' )
                                                              THEN
      IF ( NOT ( tlfuta[i].relating_shape_aspect IN ut_bag ) ) THEN
        ut_bag := ut_bag + tlfuta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ut_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* tlfuta | 
((sar.related_shape_aspect\shape_aspect.description =
'printed component join terminal') AND 
(sar.relating_shape_aspect :=: ut_bag[i])) );
  sa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE versioned_action_request_requires_approval FOR
  (versioned_action_request, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       varq IN aaa.items )) = 1 ))) = 0;
END_RULE;

RULE versioned_action_request_requires_date_or_date_and_time FOR
  (versioned_action_request, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       varq IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       varq IN ada.items )) = 1 )))) = 0;
END_RULE;

RULE versioned_action_request_requires_person_organization FOR
  (versioned_action_request,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       varq IN apaoa.items )) >= 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       varq IN aoa.items )) >= 1 )))) = 0;
END_RULE;

RULE versioned_action_request_requires_status FOR
  (versioned_action_request, action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ar <* versioned_action_request |
       NOT (SIZEOF (QUERY (ars <* action_request_status |
       ar :=: ars.assigned_request)) = 1))) = 0;
END_RULE;

RULE via_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  vt : BAG OF shape_aspect := 
         QUERY( r <* shape_aspect | (r\shape_aspect.description = 'via template'));
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(vt) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* USEDIN( vt[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
 + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'access mechanism') AND 
(sar.related_shape_aspect\shape_aspect.description = 
'via template terminal' )) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect\shape_aspect.name ) THEN
      IF ( sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE work_order_unique_constraint FOR
 ( directed_action );
LOCAL
  r : BAG OF directed_action := 
    QUERY( r <* directed_action | (SIZEOF(QUERY( aa <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'ACTION_ASSIGNMENT.ASSIGNED_ACTION' ) |
((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'CHANGE') IN TYPEOF(aa)) OR
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'START_WORK') IN TYPEOF(aa))))) > 0 ) );
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(r) by 1;
  IF EXISTS( r[i].directive\action_directive.name ) THEN
    IF ( r[i].directive\action_directive.name IN name_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i].directive\action_directive.name;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

RULE work_request_unique_constraint FOR
 ( versioned_action_request );
LOCAL
  r : BAG OF versioned_action_request := 
QUERY( r <* versioned_action_request | 
(SIZEOF(QUERY( ara <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST' ) |
((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'CHANGE_REQUEST') IN TYPEOF(ara)) OR
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'START_REQUEST') IN TYPEOF(ara))))) > 0 ) );
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF ( r[i].id IN id_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE;

(* E2: SUBTYPE_CONSTRAINT component_definition_subtypes FOR COMPONENT_DEFINITION; *)

(* E2: SUBTYPE_CONSTRAINT component_terminal_subtypes FOR COMPONENT_TERMINAL; *)

(* E2: SUBTYPE_CONSTRAINT model_parameter_subtypes FOR MODEL_PARAMETER; *)

(* E2: SUBTYPE_CONSTRAINT physical_unit_subtypes FOR PHYSICAL_UNIT; *)

(* E2: SUBTYPE_CONSTRAINT shape_definition_3d_intersection_subtypes FOR SHAPE_DEFINITION_3D_INTERSECTION; *)


END_SCHEMA;

