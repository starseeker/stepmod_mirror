(* Concatenated File produced by Express Engine v 4.2.0
   GIT ID: "79fcbd6"
*)

(* 88 Schemata for Concatenated File

action_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/action_schema/action_schema.exp
   CVS Rev:   1.20
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:59 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) action_schema(1)}'

activity_method_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/activity_method_assignment/mim.exp
   CVS Rev:   1.5
   File Status: up-to-date
   Timestamp: 2004-11-19 21:37:33 GMT
   Version:   '<<None Found>>'

activity_method_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/activity_method/mim.exp
   CVS Rev:   1.13
   File Status: up-to-date
   Timestamp: 2004-10-21 14:45:33 GMT
   Version:   '<<None Found>>'

analytical_model_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/analytical_model/mim.exp
   CVS Rev:   1.41
   File Status: up-to-date
   Timestamp: 2014-07-01 22:15:09 GMT
   Version:   '<<None Found>>'

application_context_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/application_context_schema/application_context_schema.exp
   CVS Rev:   1.14
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:58 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) application_context_schema(2)}'

approval_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/approval_schema/approval_schema.exp
   CVS Rev:   1.15
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:56 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) approval_schema(3)}'

assembly_structure_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/assembly_structure/mim.exp
   CVS Rev:   1.17
   File Status: up-to-date
   Timestamp: 2012-10-17 14:09:41 GMT
   Version:   '<<None Found>>'

basic_attribute_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/basic_attribute_schema/basic_attribute_schema.exp
   CVS Rev:   1.15
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:56 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) basic_attribute_schema(4)}'

basic_data_representation_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/basic_data_representation/mim.exp
   CVS Rev:   1.10
   File Status: up-to-date
   Timestamp: 2015-10-09 00:11:11 GMT
   Version:   '<<None Found>>'

certification_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/certification_schema/certification_schema.exp
   CVS Rev:   1.14
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:55 GMT
   Version:   '{iso standard 10303 part(41) version(3) object(1) certification_schema(5)}'

characteristic_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/characteristic/mim.exp
   CVS Rev:   1.45
   File Status: up-to-date
   Timestamp: 2015-10-09 00:11:14 GMT
   Version:   '<<None Found>>'

classification_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/classification_assignment/mim.exp
   CVS Rev:   1.12
   File Status: up-to-date
   Timestamp: 2009-07-21 21:58:29 GMT
   Version:   '<<None Found>>'

classification_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/classification_schema/classification_schema.exp
   CVS Rev:   1.11
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:57 GMT
   Version:   '{iso standard 10303 part(54) version(1) object(1) classification_schema(1)}'

classification_with_attributes_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/classification_with_attributes/mim.exp
   CVS Rev:   1.33
   File Status: up-to-date
   Timestamp: 2015-10-09 00:11:17 GMT
   Version:   '<<None Found>>'

class_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/class/mim.exp
   CVS Rev:   1.9
   File Status: up-to-date
   Timestamp: 2004-11-19 21:37:34 GMT
   Version:   '<<None Found>>'

contract_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/contract_schema/contract_schema.exp
   CVS Rev:   1.12
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:55 GMT
   Version:   '{iso standard 10303 part(41) version(3) object(1) contract_schema(6)}'

date_time_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/date_time/mim.exp
   CVS Rev:   1.10
   File Status: up-to-date
   Timestamp: 2013-11-27 22:36:51 GMT
   Version:   '<<None Found>>'

date_time_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/date_time_schema/date_time_schema.exp
   CVS Rev:   1.24
   File Status: needs-patch
   Timestamp: 2014-04-09 22:47:54 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) date_time_schema(7)}'

document_and_version_identification_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/document_and_version_identification/mim.exp
   CVS Rev:   1.18
   File Status: up-to-date
   Timestamp: 2012-10-17 14:10:14 GMT
   Version:   '<<None Found>>'

document_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/document_assignment/mim.exp
   CVS Rev:   1.25
   File Status: up-to-date
   Timestamp: 2015-11-16 21:37:13 GMT
   Version:   '<<None Found>>'

document_definition_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/document_definition/mim.exp
   CVS Rev:   1.19
   File Status: up-to-date
   Timestamp: 2004-10-28 18:51:31 GMT
   Version:   '<<None Found>>'

document_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/document_schema/document_schema.exp
   CVS Rev:   1.15
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:56 GMT
   Version:   '{iso standard 10303 part(41) version(4) object(1) document_schema(8)}'

document_structure_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/document_structure/mim.exp
   CVS Rev:   1.9
   File Status: up-to-date
   Timestamp: 2004-10-21 17:26:29 GMT
   Version:   '<<None Found>>'

effectivity_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/effectivity_schema/effectivity_schema.exp
   CVS Rev:   1.13
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:56 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) effectivity_schema(9)}'

elemental_geometric_shape_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/elemental_geometric_shape/mim.exp
   CVS Rev:   1.31
   File Status: needs-patch
   Timestamp: 2015-10-09 00:11:26 GMT
   Version:   '<<None Found>>'

elemental_topology_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/elemental_topology/mim.exp
   CVS Rev:   1.7
   File Status: up-to-date
   Timestamp: 2012-10-17 14:10:25 GMT
   Version:   '<<None Found>>'

experience_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/experience_schema/experience_schema.exp
   CVS Rev:   1.19
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:57 GMT
   Version:   '{iso standard 10303 part(41) version(4) object(1) experience_schema(10)}'

extended_date_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/extended_date/mim.exp
   CVS Rev:   1.7
   File Status: up-to-date
   Timestamp: 2012-10-17 14:10:32 GMT
   Version:   '<<None Found>>'

extended_measure_representation_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/extended_measure_representation/mim.exp
   CVS Rev:   1.33
   File Status: up-to-date
   Timestamp: 2012-11-09 21:40:58 GMT
   Version:   '<<None Found>>'

external_class_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/external_class/mim.exp
   CVS Rev:   1.17
   File Status: up-to-date
   Timestamp: 2008-09-12 12:13:34 GMT
   Version:   '<<None Found>>'

external_item_identification_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/external_item_identification_assignment/mim.exp
   CVS Rev:   1.12
   File Status: up-to-date
   Timestamp: 2004-10-21 17:58:55 GMT
   Version:   '<<None Found>>'

external_library_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/external_library/mim.exp
   CVS Rev:   1.7
   File Status: up-to-date
   Timestamp: 2009-04-22 20:07:48 GMT
   Version:   '<<None Found>>'

external_model_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/external_model/mim.exp
   CVS Rev:   1.4
   File Status: up-to-date
   Timestamp: 2012-10-17 14:10:38 GMT
   Version:   '<<None Found>>'

external_properties_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/external_properties/mim.exp
   CVS Rev:   1.26
   File Status: up-to-date
   Timestamp: 2012-10-17 14:10:38 GMT
   Version:   '<<None Found>>'

external_reference_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/external_reference_schema/external_reference_schema.exp
   CVS Rev:   1.13
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:56 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) external_reference_schema(11)}'

external_source_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/external_source/mim.exp
   CVS Rev:   1.5
   File Status: up-to-date
   Timestamp: 2010-02-19 14:23:11 GMT
   Version:   '<<None Found>>'

file_identification_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/file_identification/mim.exp
   CVS Rev:   1.18
   File Status: up-to-date
   Timestamp: 2011-10-12 13:33:57 GMT
   Version:   '<<None Found>>'

foundation_representation_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/foundation_representation/mim.exp
   CVS Rev:   1.19
   File Status: up-to-date
   Timestamp: 2010-02-19 14:23:17 GMT
   Version:   '<<None Found>>'

geometric_model_relationship_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/geometric_model_relationship/mim.exp
   CVS Rev:   1.7
   File Status: up-to-date
   Timestamp: 2012-10-17 14:10:57 GMT
   Version:   '<<None Found>>'

geometric_model_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/geometric_model_schema/geometric_model_schema.exp
   CVS Rev:   1.16
   File Status: needs-patch
   Timestamp: 2015-09-25 21:08:24 GMT
   Version:   '{iso standard 10303 part(42) version(10) object(1) geometric_model_schema(3)}'

geometry_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/geometry_schema/geometry_schema.exp
   CVS Rev:   1.23
   File Status: needs-patch
   Timestamp: 2015-11-12 18:10:41 GMT
   Version:   '{iso standard 10303 part(42) version(10) object(1) geometry_schema(1)}'

group_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/group/mim.exp
   CVS Rev:   1.8
   File Status: up-to-date
   Timestamp: 2006-03-24 18:45:20 GMT
   Version:   '<<None Found>>'

group_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/group_schema/group_schema.exp
   CVS Rev:   1.13
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:59 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) group_schema(12)}'

identification_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/identification_assignment/mim.exp
   CVS Rev:   1.13
   File Status: up-to-date
   Timestamp: 2010-06-15 16:49:23 GMT
   Version:   '<<None Found>>'

independent_property_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/independent_property/mim.exp
   CVS Rev:   1.10
   File Status: up-to-date
   Timestamp: 2004-10-22 14:15:40 GMT
   Version:   '<<None Found>>'

independent_property_representation_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/independent_property_representation/mim.exp
   CVS Rev:   1.11
   File Status: up-to-date
   Timestamp: 2006-05-18 11:42:07 GMT
   Version:   '<<None Found>>'

information_product_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/information_product/mim.exp
   CVS Rev:   1.6
   File Status: up-to-date
   Timestamp: 2009-04-22 20:17:39 GMT
   Version:   '<<None Found>>'

iso13584_expressions_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/iso13584_expressions_schema/iso13584_expressions_schema.exp
   CVS Rev:   1.15
   File Status: up-to-date
   Timestamp: 2015-08-07 17:45:06 GMT
   Version:   '<<None Found>>'

iso13584_generic_expressions_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/iso13584_generic_expressions_schema/iso13584_generic_expressions_schema.exp
   CVS Rev:   1.8
   File Status: up-to-date
   Timestamp: 2015-08-07 17:45:27 GMT
   Version:   '<<None Found>>'

location_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/location_schema/location_schema.exp
   CVS Rev:   1.17
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:57 GMT
   Version:   '{iso standard 10303 part(41) version(4) object(1) location_schema(13)}'

management_resources_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/management_resources_schema/management_resources_schema.exp
   CVS Rev:   1.34
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:56 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) management_resources_schema(14)}'

material_property_definition_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/material_property_definition_schema/material_property_definition_schema.exp
   CVS Rev:   1.4
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:57 GMT
   Version:   '{iso standard 10303 part(45) version(3) object(1) material_property_definition_schema(1)}'

material_property_representation_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/material_property_representation_schema/material_property_representation_schema.exp
   CVS Rev:   1.5
   File Status: up-to-date
   Timestamp: 2015-04-29 22:18:56 GMT
   Version:   '{iso standard 10303 part(45) version(1) object(1) material_property_representation_schema(2)}'

mathematical_functions_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/mathematical_functions_schema/mathematical_functions_schema.exp
   CVS Rev:   1.23
   File Status: up-to-date
   Timestamp: 2014-05-27 16:52:41 GMT
   Version:   '{iso standard 10303 part(50) version(3) object(1) mathematical_functions_schema(1)}'

measure_representation_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/measure_representation/mim.exp
   CVS Rev:   1.4
   File Status: up-to-date
   Timestamp: 2004-10-22 14:22:50 GMT
   Version:   '<<None Found>>'

measure_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/measure_schema/measure_schema.exp
   CVS Rev:   1.28
   File Status: up-to-date
   Timestamp: 2015-08-04 17:41:33 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) measure_schema(15)}'

model_parameter_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/model_parameter/mim.exp
   CVS Rev:   1.45
   File Status: up-to-date
   Timestamp: 2015-10-09 00:11:46 GMT
   Version:   '<<None Found>>'

name_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/name_assignment/mim.exp
   CVS Rev:   1.6
   File Status: up-to-date
   Timestamp: 2004-11-19 21:37:37 GMT
   Version:   '<<None Found>>'

person_organization_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/person_organization_assignment/mim.exp
   CVS Rev:   1.8
   File Status: up-to-date
   Timestamp: 2010-06-15 16:49:41 GMT
   Version:   '<<None Found>>'

person_organization_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/person_organization/mim.exp
   CVS Rev:   1.11
   File Status: up-to-date
   Timestamp: 2004-10-29 16:20:10 GMT
   Version:   '<<None Found>>'

person_organization_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/person_organization_schema/person_organization_schema.exp
   CVS Rev:   1.26
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:59 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) person_organization_schema(16)}'

plib_class_reference_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/plib_class_reference/mim.exp
   CVS Rev:   1.11
   File Status: up-to-date
   Timestamp: 2008-09-13 12:26:56 GMT
   Version:   '<<None Found>>'

process_property_representation_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/process_property_representation_schema/process_property_representation_schema.exp
   CVS Rev:   1.4
   File Status: up-to-date
   Timestamp: 2015-08-07 17:46:15 GMT
   Version:   '{iso standard 10303 part(49) version(1) object(1) process_property_representation_schema(2)}'

process_property_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/process_property_schema/process_property_schema.exp
   CVS Rev:   1.4
   File Status: up-to-date
   Timestamp: 2015-08-07 17:46:38 GMT
   Version:   '{iso standard 10303 part(49) version(1) object(1) process_property_schema(3)}'

product_definition_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/product_definition_schema/product_definition_schema.exp
   CVS Rev:   1.18
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:55 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) product_definition_schema(17)}'

product_identification_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/product_identification/mim.exp
   CVS Rev:   1.13
   File Status: up-to-date
   Timestamp: 2009-08-11 07:57:32 GMT
   Version:   '<<None Found>>'

product_property_definition_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/product_property_definition_schema/product_property_definition_schema.exp
   CVS Rev:   1.17
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:59 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) product_property_definition_schema(18)}'

product_property_representation_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/product_property_representation_schema/product_property_representation_schema.exp
   CVS Rev:   1.41
   File Status: up-to-date
   Timestamp: 2015-07-13 20:54:19 GMT
   Version:   '{iso standard 10303 part(41) version(8) object(1) product_property_representation_schema(19)}'

product_structure_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/product_structure_schema/product_structure_schema.exp
   CVS Rev:   1.21
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:53 GMT
   Version:   '{iso standard 10303 part(44) version(3) object(1) product_structure_schema(1)}'

product_version_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/product_version/mim.exp
   CVS Rev:   1.6
   File Status: up-to-date
   Timestamp: 2004-01-13 10:15:26 GMT
   Version:   '<<None Found>>'

product_view_definition_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/product_view_definition/mim.exp
   CVS Rev:   1.18
   File Status: up-to-date
   Timestamp: 2015-10-09 00:11:58 GMT
   Version:   '<<None Found>>'

product_view_definition_reference_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/product_view_definition_reference/mim.exp
   CVS Rev:   1.2
   File Status: up-to-date
   Timestamp: 2012-10-17 14:12:13 GMT
   Version:   '<<None Found>>'

product_view_definition_relationship_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/product_view_definition_relationship/mim.exp
   CVS Rev:   1.6
   File Status: up-to-date
   Timestamp: 2012-09-22 18:15:05 GMT
   Version:   '<<None Found>>'

property_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/property_assignment/mim.exp
   CVS Rev:   1.15
   File Status: up-to-date
   Timestamp: 2012-10-17 14:12:17 GMT
   Version:   '<<None Found>>'

qualifications_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/qualifications_schema/qualifications_schema.exp
   CVS Rev:   1.16
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:53 GMT
   Version:   '{iso standard 10303 part(41) version(6) object(1) qualifications_schema(20)}'

qualified_measure_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/qualified_measure/mim.exp
   CVS Rev:   1.10
   File Status: up-to-date
   Timestamp: 2012-10-17 14:12:19 GMT
   Version:   '<<None Found>>'

qualified_measure_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/qualified_measure_schema/qualified_measure_schema.exp
   CVS Rev:   1.9
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:56 GMT
   Version:   '{iso standard 10303 part(45) version(3) object(1) qualified_measure_schema(3)}'

representation_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/representation_schema/representation_schema.exp
   CVS Rev:   1.15
   File Status: needs-patch
   Timestamp: 2016-03-15 00:31:12 GMT
   Version:   '{iso standard 10303 part(43) version(6) object(1) representation_schema(1)}'

scan_data_3d_shape_model_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/scan_data_3d_shape_model_schema/scan_data_3d_shape_model_schema.exp
   CVS Rev:   1.7
   File Status: up-to-date
   Timestamp: 2016-06-03 19:44:23 GMT
   Version:   '<<None Found>>'

security_classification_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/security_classification_schema/security_classification_schema.exp
   CVS Rev:   1.11
   File Status: up-to-date
   Timestamp: 2014-04-09 22:47:58 GMT
   Version:   '{iso standard 10303 part(41) version(3) object(1) security_classification_schema(21)}'

shape_dimension_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/shape_dimension_schema/shape_dimension_schema.exp
   CVS Rev:   1.23
   File Status: up-to-date
   Timestamp: 2015-04-29 22:31:18 GMT
   Version:   '{iso standard 10303 part(47) version(2) object(1) shape_dimension_schema(2)}'

shape_property_assignment_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/shape_property_assignment/mim.exp
   CVS Rev:   1.33
   File Status: up-to-date
   Timestamp: 2015-10-09 00:12:08 GMT
   Version:   '<<None Found>>'

software_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/software/mim.exp
   CVS Rev:   1.10
   File Status: up-to-date
   Timestamp: 2009-04-23 08:59:14 GMT
   Version:   '<<None Found>>'

support_resource_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/support_resource/mim.exp
   CVS Rev:   1.4
   File Status: up-to-date
   Timestamp: 2012-10-17 14:12:49 GMT
   Version:   '<<None Found>>'

support_resource_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/support_resource_schema/support_resource_schema.exp
   CVS Rev:   1.17
   File Status: up-to-date
   Timestamp: 2015-10-09 21:11:17 GMT
   Version:   '{iso standard 10303 part(41) version(7) object(1) support_resource_schema(22)}'

topology_schema
   Filename: /Users/tom/workspace_422/stepmod/data/resources/topology_schema/topology_schema.exp
   CVS Rev:   1.14
   File Status: up-to-date
   Timestamp: 2016-04-30 21:51:45 GMT
   Version:   '{iso standard 10303 part(42) version(10) object(1) topology_schema(2)}'

value_with_unit_extension_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/value_with_unit_extension/mim.exp
   CVS Rev:   1.27
   File Status: locally-modified
   Timestamp: 2016-05-03 23:19:36 GMT
   Version:   '<<None Found>>'

value_with_unit_mim
   Filename: /Users/tom/workspace_422/stepmod/data/modules/value_with_unit/mim.exp
   CVS Rev:   1.15
   File Status: up-to-date
   Timestamp: 2012-10-17 14:13:02 GMT
   Version:   '<<None Found>>'

 *)

(*
  Id: action_schema.exp,v 1.20 2014/03/04 00:30:24 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Action schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Action schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                  15 *)
(*  Functions:                  4 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      4 *)

SCHEMA action_schema '{iso standard 10303 part(41) version(7) object(1) action_schema(1)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_id_value,
   get_name_value,
   id_attribute,
   id_attribute_select,
   name_attribute,
   name_attribute_select);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE as_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (action_request_solution);
END_TYPE;

TYPE as_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (action);
END_TYPE;

TYPE as_name_attribute_select = SELECT BASED_ON name_attribute_select WITH 
  (action_request_solution);
END_TYPE;

TYPE supported_item = SELECT 
  (action_directive,
   action,
   action_method);
END_TYPE;

ENTITY action;
  name          : label;
  description   : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_directive;
  name        : label;
  description : OPTIONAL text;
  analysis    : text;
  comment     : text;
  requests    : SET [1:?] OF versioned_action_request;
END_ENTITY;

ENTITY action_method;
  name        : label;
  description : OPTIONAL text;
  consequence : text;
  purpose     : text;
END_ENTITY;

ENTITY action_method_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_method : action_method;
  related_method  : action_method;
END_ENTITY;

ENTITY action_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_action : action;
  related_action  : action;
END_ENTITY;

ENTITY action_request_solution;
  method  : action_method;
  request : versioned_action_request;
DERIVE
  description : text  := get_description_value(SELF);
  name        : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY action_request_status;
  status           : label;
  assigned_request : versioned_action_request;
END_ENTITY;

ENTITY action_resource;
  name        : label;
  description : OPTIONAL text;
  usage       : SET [1:?] OF supported_item;
  kind        : action_resource_type;
END_ENTITY;

ENTITY action_resource_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_resource : action_resource;
  related_resource  : action_resource;
END_ENTITY;

ENTITY action_resource_type;
  name : label;
END_ENTITY;

ENTITY action_status;
  status          : label;
  assigned_action : executed_action;
END_ENTITY;

ENTITY directed_action
  SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;

ENTITY executed_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY versioned_action_request;
  id          : identifier;
  version     : OPTIONAL label;
  purpose     : text;
  description : OPTIONAL text;
END_ENTITY;

ENTITY versioned_action_request_relationship;
  id                                : identifier;
  name                              : label;
  description                       : OPTIONAL text;
  relating_versioned_action_request : versioned_action_request;
  related_versioned_action_request  : versioned_action_request;
END_ENTITY;

FUNCTION acyclic_action_method_relationship(relation : action_method_relationship;
                                            relatives : SET [1:?] OF action_method;
                                            specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF action_method_relationship;
END_LOCAL;
  IF relation.relating_method IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(am <* bag_to_set(
                   USEDIN(relation.relating_method,
                   'ACTION_SCHEMA.ACTION_METHOD_RELATIONSHIP.RELATED_METHOD')) | specific_relation IN TYPEOF(am));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_action_relationship(relation : action_relationship;
                                     relatives : SET [1:?] OF action;
                                     specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF action_relationship;
END_LOCAL;
  IF relation.relating_action IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(actn <* bag_to_set(
                     USEDIN(relation.relating_action,
                     'ACTION_SCHEMA.ACTION_RELATIONSHIP.RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_action_resource_relationship(relation : action_resource_relationship;
                                              relatives : SET [1:?] OF action_resource;
                                              specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF action_resource_relationship;
END_LOCAL;
  IF relation.relating_resource IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(ar <* bag_to_set(
                   USEDIN(relation.relating_resource,
                   'ACTION_SCHEMA.ACTION_RESOURCE_RELATIONSHIP.RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_versioned_action_request_relationship(relation : versioned_action_request_relationship;
                                                       relatives : SET OF versioned_action_request;
                                                       specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF versioned_action_request_relationship;
END_LOCAL;
  IF relation.relating_versioned_action_request IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(varr <* bag_to_set(
                     USEDIN(relation.relating_versioned_action_request,
                     'ACTION_SCHEMA.VERSIONED_ACTION_REQUEST_RELATIONSHIP.RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN
                                                                                                                TYPEOF(
                                                                                                                varr));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.5 2004/11/19 21:37:33 robbod Exp
  ISO TC184/SC4/WG12 N2999 - ISO/TS 10303-1249 Activity method assignment - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N2307
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA activity_method_assignment_mim;
USE FROM action_schema
  (action_method_relationship);
USE FROM activity_method_mim;
USE FROM management_resources_schema
  (action_method_assignment);

TYPE action_method_items = EXTENSIBLE SELECT ;
END_TYPE;

ENTITY applied_action_method_assignment
  SUBTYPE OF (action_method_assignment);
  items : SET [1:?] OF action_method_items;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.13 2004/10/21 14:45:33 darla Exp
  ISO TC184/SC4/WG12 N1163 - ISO/TS 10303-1049 Activity method - EXPRESS MIM
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA activity_method_mim;
USE FROM action_schema
  (action_method);
END_SCHEMA;


(*
  Id: mim.exp,v 1.41 2014/02/10 21:59:41 thomasrthurman Exp
  ISO TC184/SC4/WG12 N8426 - ISO/TS 10303-1603 Analytical model - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N8302
  *)
(*  Interfaces:                 6 *)
(*  Constants:                  0 *)
(*  Entities:                  17 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      3 *)

SCHEMA analytical_model_mim;
USE FROM model_parameter_mim;
USE FROM software_mim;
USE FROM document_structure_mim;
USE FROM product_view_definition_relationship_mim;
USE FROM product_definition_schema
  (product_related_product_category);
USE FROM date_time_schema
  (date_time_role,
   date_role);

TYPE am_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
  (analytical_model_definition);
END_TYPE;

TYPE am_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
  (digital_analytical_model_vector_port);
END_TYPE;

TYPE am_parameter_assignment_select = SELECT BASED_ON parameter_assignment_select WITH 
  (analytical_model_parameter);
END_TYPE;

ENTITY across_port_variable
  SUBTYPE OF (port_variable);
END_ENTITY;

ENTITY analog_analytical_model_port
  SUBTYPE OF (analytical_model_port);
END_ENTITY;

ENTITY analytical_model_definition
  SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY analytical_model_make_from_relationship
  SUBTYPE OF (product_definition_relationship);
  SELF\product_definition_relationship.relating_product_definition : analytical_model_definition;
  SELF\product_definition_relationship.related_product_definition : analytical_model_definition;
UNIQUE
  UR1: SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
END_ENTITY;

ENTITY analytical_model_parameter
  SUBTYPE OF (property_definition);
END_ENTITY;

ENTITY analytical_model_port
  SUBTYPE OF (property_definition, property_definition_representation, representation);
DERIVE
  SELF\property_definition_representation.definition                       : property_definition := SELF;
  SELF\property_definition_representation.used_representation              : representation      := SELF;
END_ENTITY;

ENTITY analytical_model_port_assignment
  SUBTYPE OF (property_definition_representation, representation_relationship);
  SELF\property_definition_representation.used_representation   : analytical_model_port;
  SELF\representation_relationship.rep_1                 : analytical_representation;
DERIVE
  SELF\representation_relationship.rep_2 : analytical_model_port := SELF\property_definition_representation
                                                                        .used_representation;
END_ENTITY;

ENTITY analytical_model_scalar_port
  SUBTYPE OF (analytical_model_vector_port);
END_ENTITY;

ENTITY analytical_model_vector_port
  SUBTYPE OF (analytical_model_port, compound_representation_item);
END_ENTITY;

ENTITY analytical_representation
  SUBTYPE OF (representation);
UNIQUE
  UR1: SELF\representation.name;
END_ENTITY;

ENTITY digital_analytical_model_port
  SUBTYPE OF (analytical_model_port);
END_ENTITY;

ENTITY digital_analytical_model_scalar_port
  SUBTYPE OF (digital_analytical_model_vector_port, analytical_model_scalar_port);
END_ENTITY;

ENTITY digital_analytical_model_vector_port
  SUBTYPE OF (analytical_model_vector_port);
END_ENTITY;

ENTITY make_from_model_port_relationship
  SUBTYPE OF (representation, representation_relationship);
  SELF\representation_relationship.rep_1 : analytical_model_port;
  SELF\representation_relationship.rep_2 : analytical_model_port;
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: rep_1 :<>: rep_2;
END_ENTITY;

ENTITY port_variable
  SUPERTYPE OF (ONEOF(across_port_variable, through_port_variable, transform_port_variable))
  SUBTYPE OF (representation, representation_item);
END_ENTITY;

ENTITY through_port_variable
  SUBTYPE OF (port_variable);
END_ENTITY;

ENTITY transform_port_variable
  SUBTYPE OF (port_variable);
END_ENTITY;
END_SCHEMA;


(*
  Id: application_context_schema.exp,v 1.14 2014/03/04 00:30:29 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Application context schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Application context schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   8 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA application_context_schema '{iso standard 10303 part(41) version(7) object(1) application_context_schema(2)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_id_value,
   id_attribute,
   id_attribute_select);
REFERENCE FROM date_time_schema
  (year_number);
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text);

TYPE acs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (application_context);
END_TYPE;

TYPE acs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (application_context);
END_TYPE;

ENTITY application_context;
  application : label;
DERIVE
  description : text       := get_description_value(SELF);
  id          : identifier := get_id_value(SELF);
INVERSE
  context_elements : SET [1:?]OF application_context_element FOR frame_of_reference;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY application_context_element
  SUPERTYPE OF (ONEOF(library_context, product_concept_context, product_context, product_definition_context));
  name               : label;
  frame_of_reference : application_context;
END_ENTITY;

ENTITY application_context_relationship;
  name             : label;
  description      : OPTIONAL text;
  relating_context : application_context;
  related_context  : application_context;
END_ENTITY;

ENTITY application_protocol_definition;
  status                                    : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year                 : year_number;
  application                               : application_context;
END_ENTITY;

ENTITY library_context
  SUBTYPE OF (application_context_element);
  library_reference : label;
END_ENTITY;

ENTITY product_concept_context
  SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;

ENTITY product_context
  SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;

ENTITY product_definition_context
  SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;
END_SCHEMA;


(*
  Id: approval_schema.exp,v 1.15 2014/03/04 00:30:30 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Approval schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Approval schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   6 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA approval_schema '{iso standard 10303 part(41) version(7) object(1) approval_schema(3)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_role,
   object_role,
   role_association,
   role_select);
REFERENCE FROM date_time_schema
  (date_time_select);
REFERENCE FROM person_organization_schema
  (person_organization_select);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   label,
   text);

TYPE apps_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (approval_role);
END_TYPE;

TYPE apps_role_select = SELECT BASED_ON role_select WITH 
  (approval_date_time);
END_TYPE;

ENTITY approval;
  status : approval_status;
  level  : label;
END_ENTITY;

ENTITY approval_date_time;
  date_time      : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role                : approval_role;
END_ENTITY;

ENTITY approval_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_approval : approval;
  related_approval  : approval;
END_ENTITY;

ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY approval_status;
  name : label;
END_ENTITY;

FUNCTION acyclic_approval_relationship(relation : approval_relationship;
                                       relatives : SET [1:?] OF approval;
                                       specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF approval_relationship;
END_LOCAL;
  IF relation.relating_approval IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(app <* bag_to_set(
                    USEDIN(relation.relating_approval,
                    'APPROVAL_SCHEMA.APPROVAL_RELATIONSHIP.RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.17 2012/10/11 23:20:18 thomasrthurman Exp
  ISO TC184/SC4/WG12 N7730 - ISO/TS 10303-1026 Assembly structure - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N6112
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA assembly_structure_mim;
USE FROM product_view_definition_mim;
USE FROM product_view_definition_reference_mim;
USE FROM value_with_unit_mim;
USE FROM product_structure_schema
  (assembly_component_usage,
   next_assembly_usage_occurrence,
   promissory_usage_occurrence,
   quantified_assembly_component_usage,
   specified_higher_usage_occurrence,
   multi_level_reference_designator);
END_SCHEMA;


(*
  Id: basic_attribute_schema.exp,v 1.15 2014/03/04 00:30:30 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Basic attribute schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Basic attribute schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   5 *)
(*  Functions:                  4 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      4 *)

SCHEMA basic_attribute_schema '{iso standard 10303 part(41) version(7) object(1) basic_attribute_schema(4)}';
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text);

TYPE description_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE id_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE name_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE role_select = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY description_attribute;
  attribute_value : text;
  described_item  : description_attribute_select;
END_ENTITY;

ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;

ENTITY name_attribute;
  attribute_value : label;
  named_item      : name_attribute_select;
END_ENTITY;

ENTITY object_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY role_association;
  role           : object_role;
  item_with_role : role_select;
END_ENTITY;

FUNCTION get_description_value(obj : description_attribute_select) : text;
LOCAL
  description_bag : BAG OF description_attribute := (USEDIN(obj,
                                                     'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'));
END_LOCAL;
  IF SIZEOF(description_bag) = 1
  THEN
    RETURN(description_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION get_id_value(obj : id_attribute_select) : identifier;
LOCAL
  id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM'));
END_LOCAL;
  IF SIZEOF(id_bag) = 1
  THEN
    RETURN(id_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION get_name_value(obj : name_attribute_select) : label;
LOCAL
  name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM'));
END_LOCAL;
  IF SIZEOF(name_bag) = 1
  THEN
    RETURN(name_bag[1].attribute_value);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION get_role(obj : role_select) : object_role;
LOCAL
  role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE'));
END_LOCAL;
  IF SIZEOF(role_bag) = 1
  THEN
    RETURN(role_bag[1].role);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.10 2015/09/24 11:01:19 lothartklein Exp
  ISO TC184/SC4/WG12 N7952 - ISO/TS 10303-1773 Basic data representation - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N6217
  *)
(*  Interfaces:                 5 *)
(*  Constants:                  0 *)
(*  Entities:                   7 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        1 *)
(*  Types:                      0 *)

SCHEMA basic_data_representation_mim;
USE FROM extended_date_mim;
USE FROM foundation_representation_mim;
USE FROM iso13584_expressions_schema
  (boolean_literal,
   int_literal,
   slash_expression,
   real_literal);
USE FROM iso13584_generic_expressions_schema
  (binary_generic_expression);
USE FROM mathematical_functions_schema
  (logical_literal);

ENTITY boolean_representation_item
  SUBTYPE OF (representation_item, boolean_literal);
END_ENTITY;

ENTITY date_representation_item
  SUBTYPE OF (representation_item, date);
END_ENTITY;

ENTITY date_time_representation_item
  SUBTYPE OF (representation_item, date_and_time);
END_ENTITY;

ENTITY integer_representation_item
  SUBTYPE OF (representation_item, int_literal);
END_ENTITY;

ENTITY logical_representation_item
  SUBTYPE OF (representation_item, logical_literal);
END_ENTITY;

ENTITY rational_representation_item
  SUBTYPE OF (representation_item, slash_expression);
WHERE
  WR1: SIZEOF(
       QUERY(operand <* SELF\binary_generic_expression.operands | NOT ('ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN
                                                                       TYPEOF(operand)))) =
       0;
END_ENTITY;

ENTITY real_representation_item
  SUBTYPE OF (representation_item, real_literal);
END_ENTITY;

SUBTYPE_CONSTRAINT representation_item_subtypes FOR representation_item;
  (ONEOF(boolean_representation_item, date_representation_item, date_time_representation_item,
         integer_representation_item, logical_representation_item, rational_representation_item,
         real_representation_item));
END_SUBTYPE_CONSTRAINT;
END_SCHEMA;


(*
  Id: certification_schema.exp,v 1.14 2014/03/04 00:30:31 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Certification schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Certification schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA certification_schema '{iso standard 10303 part(41) version(3) object(1) certification_schema(5)}';
REFERENCE FROM support_resource_schema
  (label,
   text);

ENTITY certification;
  name    : label;
  purpose : text;
  kind    : certification_type;
END_ENTITY;

ENTITY certification_type;
  description : label;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.45 2015/09/24 09:59:51 kevletu Exp
  ISO TC184/SC4/WG12 N8651 - ISO/TS 10303-1654 Characteristic - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7958
  *)
(*  Interfaces:                 8 *)
(*  Constants:                  0 *)
(*  Entities:                   9 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        1 *)
(*  Types:                      1 *)

SCHEMA characteristic_mim;
USE FROM basic_data_representation_mim;
USE FROM document_assignment_mim;
USE FROM extended_measure_representation_mim;
USE FROM external_library_mim;
USE FROM value_with_unit_extension_mim;
USE FROM property_assignment_mim;
USE FROM external_properties_mim;
USE FROM group_schema
  (group);

TYPE c_document_reference_item = SELECT BASED_ON document_reference_item WITH 
  (representation);
END_TYPE;

ENTITY characteristic_data_column_header
  SUBTYPE OF (general_property);
END_ENTITY;

ENTITY characteristic_data_column_header_link
  SUBTYPE OF (general_property_relationship);
END_ENTITY;

ENTITY characteristic_data_table_header
  SUBTYPE OF (general_property);
END_ENTITY;

ENTITY characteristic_data_table_header_decomposition
  SUBTYPE OF (general_property_relationship);
END_ENTITY;

ENTITY characteristic_type
  SUBTYPE OF (group);
END_ENTITY;

ENTITY null_representation_item
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY range_characteristic
  SUBTYPE OF (representation, descriptive_representation_item);
WHERE
  WR1: NOT (SELF\representation.name IN
            ['tolerance',
             'minimum tolerance',
             'maximum tolerance',
             'nominal tolerance',
             'plus minus tolerance',
             'symmetrical tolerance',
             'statistical tolerance']);
END_ENTITY;

ENTITY row_representation_item
  SUBTYPE OF (compound_representation_item);
  SELF\compound_representation_item.item_element      : list_representation_item;
END_ENTITY;

ENTITY table_representation_item
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: SIZEOF(
       QUERY(itet <* SELF\compound_representation_item
                         .item_element | NOT ('CHARACTERISTIC_MIM.ROW_REPRESENTATION_ITEM' IN TYPEOF(itet)))) =
       0;
END_ENTITY;

SUBTYPE_CONSTRAINT c_compound_representation_item_subtypes FOR compound_representation_item;
  (ONEOF(row_representation_item, table_representation_item));
END_SUBTYPE_CONSTRAINT;
END_SCHEMA;


(*
  Id: mim.exp,v 1.12 2009/07/21 21:58:29 thomasrthurman Exp
  ISO TC184/SC4/WG12 N3249 - ISO/TS 10303-1114 Classification assignment - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N2230
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA classification_assignment_mim;
USE FROM class_mim;
USE FROM management_resources_schema
  (classification_assignment);

TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET [1:?] OF classification_item;
END_ENTITY;
END_SCHEMA;


(*
  Id: classification_schema.exp,v 1.11 2014/03/04 00:30:32 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N3213

  EXPRESS Source:
  ISO 10303-54 ed1 Classification and set theory - Classification schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-54 ed1 Classification and set theory - Classification schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   7 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        1 *)
(*  Types:                      2 *)

SCHEMA classification_schema '{iso standard 10303 part(54) version(1) object(1) classification_schema(1)}';
REFERENCE FROM group_schema
  (group);
REFERENCE FROM management_resources_schema
  (classification_assignment);

TYPE classification_select = EXTENSIBLE SELECT ;
END_TYPE;

TYPE complete_membership_select = EXTENSIBLE SELECT ;
END_TYPE;

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY classification
  SUBTYPE OF (classification_assignment);
  classified : classification_select;
DERIVE
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY complete_membership
  SUBTYPE OF (classification_assignment);
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership_of_empty_set
  SUBTYPE OF (complete_membership);
END_ENTITY;

ENTITY complete_membership_of_non_empty_set
  SUBTYPE OF (complete_membership);
  members : SET [1:?] OF complete_membership_select;
END_ENTITY;

SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
  ONEOF(classification, complete_membership);
END_SUBTYPE_CONSTRAINT;
END_SCHEMA;


(*

  Id: mim.exp,v 1.33 2015/09/24 09:59:56 kevletu Exp
  ISO TC184/SC4/WG12 N8653 - ISO/CD-TS 10303-1111 Classification with attributes - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7961
  *)
(*  Interfaces:                11 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      2 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      5 *)

SCHEMA classification_with_attributes_mim;
USE FROM classification_assignment_mim;
USE FROM extended_measure_representation_mim;
USE FROM identification_assignment_mim;
USE FROM independent_property_mim;
USE FROM plib_class_reference_mim;
USE FROM product_view_definition_mim;
USE FROM group_schema
  (group,
   group_relationship);
USE FROM product_property_definition_schema
  (characterized_object,
   general_property,
   general_property_association,
   property_definition);
USE FROM product_property_representation_schema
  (property_definition_representation);
USE FROM representation_schema
  (set_representation_item);
USE FROM management_resources_schema
  (classification_role);

TYPE classification_classification_item = SELECT BASED_ON classification_item WITH 
  (class);
END_TYPE;

TYPE classification_identification_item = SELECT BASED_ON identification_item WITH 
  (class);
END_TYPE;

TYPE classification_item_extended = SELECT BASED_ON classification_item WITH 
  (characterized_class,
   classified_item);
END_TYPE;

TYPE classified_item = SELECT 
  (product,
   product_definition_formation,
   product_definition);
END_TYPE;

TYPE cwa_identification_item = SELECT BASED_ON identification_item WITH 
  (characterized_class);
END_TYPE;

ENTITY characterized_class
  SUBTYPE OF (characterized_object, class);
END_ENTITY;

ENTITY class_system
  SUBTYPE OF (group);
END_ENTITY;

FUNCTION class_assignment_is_valid(aia : applied_classification_assignment) : BOOLEAN;
LOCAL
  item : classification_item;
  role : classification_role;
END_LOCAL;
  role := aia\classification_assignment.role;
  IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS_SYSTEM' IN TYPEOF(aia\classification_assignment.assigned_class))
  THEN
    IF (role\classification_role.name <> 'class system membership')
    THEN
      RETURN(false);
    END_IF;
    REPEAT i := LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(
                                                                        aia\applied_classification_assignment.items);
      item := aia\applied_classification_assignment.items[i];
      IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.CHARACTERIZED_CLASS'] * TYPEOF(item)) = 0)
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
  END_IF;
  IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CHARACTERIZED_CLASS' IN TYPEOF(aia\classification_assignment.assigned_class))
  THEN
    IF NOT (role\classification_role.name IN ['definitional','non-definitional',''])
    THEN
      RETURN(false);
    END_IF;
    REPEAT i := LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(
                                                                        aia\applied_classification_assignment.items);
      item := aia\applied_classification_assignment.items[i];
      IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASSIFIED_ITEM'] * TYPEOF(item)) = 0)
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
  END_IF;
  IF (role\classification_role.name = 'definitional')
  THEN
    IF NOT (SIZEOF(
            QUERY(it <* aia\applied_classification_assignment
                           .items | NOT (SIZEOF(
                                         ['PRODUCT_DEFINITION_SCHEMA.PRODUCT',
                                          'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION',
                                          'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION'] *
                                         TYPEOF(it)) =
                                         1))) =
            0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  RETURN(true);
END_FUNCTION;

RULE restrict_classification_assignments FOR (applied_classification_assignment);
WHERE
  WR1: SIZEOF(QUERY(aia <* applied_classification_assignment | NOT class_assignment_is_valid(aia))) = 0;
END_RULE;

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship);
WHERE
  WR1: SIZEOF(
       QUERY(gr <* group_relationship | (gr\group_relationship.name = 'class hierarchy') AND
                                        (NOT ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN
                                              TYPEOF(gr\group_relationship.related_group)) OR
                                             NOT ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN
                                                  TYPEOF(gr\group_relationship.relating_group))))) =
       0;
END_RULE;
END_SCHEMA;


(*
  Id: mim.exp,v 1.9 2004/11/19 21:37:34 robbod Exp
  ISO TC184/SC4/WG12 N3023 - ISO/TS 10303-1070 Class - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N2259
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA class_mim;
USE FROM classification_schema
  (class,
   class_by_extension,
   class_by_intension);
USE FROM group_schema
  (group);
END_SCHEMA;


(*
  Id: contract_schema.exp,v 1.12 2014/03/04 00:30:32 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Contract schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Contract schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   3 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA contract_schema '{iso standard 10303 part(41) version(3) object(1) contract_schema(6)}';
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

ENTITY contract;
  name    : label;
  purpose : text;
  kind    : contract_type;
END_ENTITY;

ENTITY contract_relationship;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  relating_contract : contract;
  related_contract  : contract;
END_ENTITY;

ENTITY contract_type;
  description : label;
END_ENTITY;

FUNCTION acyclic_contract_relationship(relation : contract_relationship;
                                       relatives : SET [1:?] OF contract;
                                       specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF contract_relationship;
END_LOCAL;
  IF relation.relating_contract IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(cont <* bag_to_set(
                     USEDIN(relation.relating_contract,
                     'CONTRACT_SCHEMA.CONTRACT_RELATIONSHIP.RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.10 2013/11/19 16:12:42 darla Exp
  ISO TC184/SC4/WG12 N8395 - ISO/TS 10303-1010 Date time - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7979
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA date_time_mim;
USE FROM date_time_schema
  (calendar_date,
   date_and_time,
   coordinated_universal_time_offset,
   local_time);
END_SCHEMA;


(*
  Id: date_time_schema.exp,v 1.24 2014/03/04 00:30:32 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Date time schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Date time schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                  20 *)
(*  Functions:                  7 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                     13 *)

SCHEMA date_time_schema '{iso standard 10303 part(41) version(7) object(1) date_time_schema(7)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value);
REFERENCE FROM measure_schema
  (measure_with_unit,
   time_measure_with_unit);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE ahead_or_behind = ENUMERATION OF
  (ahead,
   exact,
   behind);
END_TYPE;

TYPE date_time_or_event_occurrence = SELECT 
  (date_time_select,
   event_occurrence);
END_TYPE;

TYPE date_time_select = SELECT 
  (date,
   date_and_time,
   local_time);
END_TYPE;

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE;

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 7};
END_TYPE;

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE;

TYPE dts_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (date_role,
   date_time_role,
   time_role);
END_TYPE;

TYPE hour_in_day = INTEGER;
WHERE
  WR1: {0 <= SELF < 24};
END_TYPE;

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: {0 <= SELF <= 59};
END_TYPE;

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 12};
END_TYPE;

TYPE second_in_minute = REAL;
WHERE
  WR1: {0 <= SELF < 60.0};
END_TYPE;

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 53};
END_TYPE;

TYPE year_number = INTEGER;
WHERE
  WR1: (SELF > 1581);
END_TYPE;

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component   : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date(SELF);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset   : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense         : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset, 0);
WHERE
  WR1: {0 <= hour_offset < 24};
  WR2: {0 <= actual_minute_offset <= 59};
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF(calendar_date, ordinal_date, week_of_year_and_day_date, year_month));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY event_occurrence;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_event : event_occurrence;
  related_event  : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY local_time;
  hour_component   : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone             : coordinated_universal_time_offset;
WHERE
  WR1: valid_time(SELF);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND {1 <= day_component <= 365}) OR
       (leap_year(SELF.year_component) AND {1 <= day_component <= 366});
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset     : time_measure_with_unit;
END_ENTITY;

ENTITY time_interval;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_relationship;
  name                   : label;
  description            : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval  : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound   : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration        : OPTIONAL time_measure_with_unit;
WHERE
  WR1: EXISTS(primary_bound) OR EXISTS(secondary_bound);
  WR2: NOT (EXISTS(primary_bound) AND EXISTS(secondary_bound) AND EXISTS(duration));
  WR3: EXISTS(primary_bound) AND NOT EXISTS(secondary_bound) AND
       (NOT EXISTS(duration) OR duration_is_positive(duration));
  WR4: EXISTS(secondary_bound) AND NOT EXISTS(primary_bound) AND EXISTS(duration) AND duration_is_negative(duration);
END_ENTITY;

ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component  : OPTIONAL day_in_week_number;
WHERE
  WR1: NOT (leap_year(SELF\date.year_component)) OR {1 <= (day_component + (7 * (week_component - 1))) <= 366};
  WR2: leap_year(SELF\date.year_component) OR {1 <= (day_component + (7 * (week_component - 1))) <= 365};
END_ENTITY;

ENTITY year_month
  SUBTYPE OF (date);
  month_component : month_in_year_number;
END_ENTITY;

FUNCTION acyclic_event_occurrence_relationship(relation : event_occurrence_relationship;
                                               relatives : SET [1:?] OF event_occurrence;
                                               specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF event_occurrence_relationship;
END_LOCAL;
  IF relation.relating_event IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(evnt <* bag_to_set(
                     USEDIN(relation.relating_event,
                     'DATE_TIME_SCHEMA.EVENT_OCCURRENCE_RELATIONSHIP.RELATED_EVENT')) | specific_relation IN
                                                                                        TYPEOF(evnt));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_time_interval_relationship(relation : time_interval_relationship;
                                            relatives : SET [1:?] OF time_interval;
                                            specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF time_interval_relationship;
END_LOCAL;
  IF relation.relating_time_interval IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(ti <* bag_to_set(
                   USEDIN(relation.relating_time_interval,
                   'DATE_TIME_SCHEMA.TIME_INTERVAL_RELATIONSHIP.RELATED_TIME_INTERVAL')) | specific_relation IN
                                                                                           TYPEOF(ti));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION duration_is_negative(duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component < 0.0)
  THEN
    RETURN(true);
  ELSE
    RETURN(false);
  END_IF;
END_FUNCTION;

FUNCTION duration_is_positive(duration : time_measure_with_unit) : BOOLEAN;
  IF (duration\measure_with_unit.value_component > 0.0)
  THEN
    RETURN(true);
  ELSE
    RETURN(false);
  END_IF;
END_FUNCTION;

FUNCTION leap_year(year : year_number) : BOOLEAN;
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0))
  THEN
    RETURN(true);
  ELSE
    RETURN(false);
  END_IF;
END_FUNCTION;

FUNCTION valid_calendar_date(date : calendar_date) : LOGICAL;
  CASE date.month_component OF
    1 : RETURN({1 <= date.day_component <= 31});
    2 : BEGIN  
               IF (leap_year(date.year_component))
               THEN
                 RETURN({1 <= date.day_component <= 29});
               ELSE
                 RETURN({1 <= date.day_component <= 28});
               END_IF;
    END;
    3 : RETURN({1 <= date.day_component <= 31});
    4 : RETURN({1 <= date.day_component <= 30});
    5 : RETURN({1 <= date.day_component <= 31});
    6 : RETURN({1 <= date.day_component <= 30});
    7 : RETURN({1 <= date.day_component <= 31});
    8 : RETURN({1 <= date.day_component <= 31});
    9 : RETURN({1 <= date.day_component <= 30});
    10 : RETURN({1 <= date.day_component <= 31});
    11 : RETURN({1 <= date.day_component <= 30});
    12 : RETURN({1 <= date.day_component <= 31});
  END_CASE;
  RETURN(false);
END_FUNCTION;

FUNCTION valid_time(time : local_time) : BOOLEAN;
  IF EXISTS(time.second_component)
  THEN
    RETURN(EXISTS(time.minute_component));
  ELSE
    RETURN(true);
  END_IF;
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.18 2012/10/06 20:09:56 liutkuviene Exp
  ISO TC184/SC4/WG12 N7709 - ISO/TS 10303-1121 Document and version identification - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N6577
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA document_and_version_identification_mim;
USE FROM product_identification_mim;
USE FROM product_version_mim;
USE FROM product_definition_schema
  (product_category,
   product_related_product_category);
END_SCHEMA;


(*
  Id: mim.exp,v 1.25 2015/10/20 20:37:44 lothartklein Exp
  ISO TC184/SC4/WG12 N8680 - ISO/TS 10303-1122 Document assignment - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7715
  *)
(*  Interfaces:                 6 *)
(*  Constants:                  0 *)
(*  Entities:                   3 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        1 *)
(*  Types:                      1 *)

SCHEMA document_assignment_mim;
USE FROM document_and_version_identification_mim;
USE FROM document_definition_mim;
USE FROM document_schema
  (document_product_association);
USE FROM file_identification_mim;
USE FROM management_resources_schema
  (document_reference,
   document_usage_constraint_assignment);
USE FROM basic_attribute_schema
  (role_association,
   object_role);

TYPE document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET [1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET [1:?] OF document_reference_item;
END_ENTITY;

ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document') AND
            (SIZEOF(
             QUERY(prpc <* USEDIN(SELF\document_product_association.related_product,
                           'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name =
                                                                                                    'document')) =
             1));
  WR3: NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document version') AND
            (SIZEOF(
             QUERY(prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product,
                           'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name =
                                                                                                    'document')) =
             1));
  WR4: NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR
           ((SELF\document_product_association.relating_document.kind.product_data_type =
             'configuration controlled document definition') AND
            (SIZEOF(
             QUERY(prpc <* USEDIN(
                           SELF\document_product_association.related_product\product_definition.formation.of_product,
                           'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name =
                                                                                                    'document')) =
             1));
END_ENTITY;

SUBTYPE_CONSTRAINT subtype_mandatory_document_product_association FOR document_product_association;
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;
END_SCHEMA;


(*
  Id: mim.exp,v 1.19 2004/10/28 18:51:31 darla Exp
  ISO TC184/SC4/WG12 N2961 - ISO/TS 10303-1123 Document definition - EXPRESS MIM
  *)
(*  Interfaces:                 5 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA document_definition_mim;
USE FROM document_and_version_identification_mim;
USE FROM external_item_identification_assignment_mim;
USE FROM file_identification_mim;
USE FROM product_definition_schema
  (product_definition,
   product_definition_with_associated_documents);
USE FROM product_view_definition_mim;

TYPE document_location_select = SELECT BASED_ON external_identification_item WITH 
  (product_definition);
END_TYPE;
END_SCHEMA;


(*
  Id: document_schema.exp,v 1.15 2014/03/04 00:30:33 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Document schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Document schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   7 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA document_schema '{iso standard 10303 part(41) version(4) object(1) document_schema(8)}';
REFERENCE FROM product_definition_schema
  (product,
   product_definition,
   product_definition_formation);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE product_or_formation_or_definition = SELECT 
  (product,
   product_definition_formation,
   product_definition);
END_TYPE;

ENTITY document;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  kind        : document_type;
INVERSE
  representation_types : SET [0:?]OF document_representation_type FOR represented_document;
END_ENTITY;

ENTITY document_product_association;
  name              : label;
  description       : OPTIONAL text;
  relating_document : document;
  related_product   : product_or_formation_or_definition;
END_ENTITY;

ENTITY document_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_document : document;
  related_document  : document;
END_ENTITY;

ENTITY document_representation_type;
  name                 : label;
  represented_document : document;
END_ENTITY;

ENTITY document_type;
  product_data_type : label;
END_ENTITY;

ENTITY document_usage_constraint;
  source                : document;
  subject_element       : label;
  subject_element_value : text;
END_ENTITY;

ENTITY document_with_class
  SUBTYPE OF (document);
  class : identifier;
END_ENTITY;

FUNCTION acyclic_document_relationship(relation : document_relationship;
                                       relatives : SET [1:?] OF document;
                                       specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF document_relationship;
END_LOCAL;
  IF relation.relating_document IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(doc <* bag_to_set(
                    USEDIN(relation.relating_document,
                    'DOCUMENT_SCHEMA.DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.9 2004/10/21 17:26:29 darla Exp
  ISO TC184/SC4/WG12 N1196 - ISO/TS 10303-1124 Document structure - EXPRESS MIM
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA document_structure_mim;
USE FROM document_definition_mim;
USE FROM file_identification_mim;
USE FROM document_schema
  (document_relationship);
USE FROM product_definition_schema
  (product_definition_formation_relationship,
   product_definition_relationship);
END_SCHEMA;


(*
  Id: effectivity_schema.exp,v 1.13 2014/03/04 00:30:35 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Effectivity schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Effectivity schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   6 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA effectivity_schema '{iso standard 10303 part(41) version(7) object(1) effectivity_schema(9)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_name_value,
   name_attribute,
   name_attribute_select);
REFERENCE FROM date_time_schema
  (date_time_or_event_occurrence,
   time_interval);
REFERENCE FROM measure_schema
  (measure_with_unit);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE effs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (effectivity);
END_TYPE;

TYPE effs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH 
  (effectivity);
END_TYPE;

ENTITY dated_effectivity
  SUBTYPE OF (effectivity);
  effectivity_end_date   : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : OPTIONAL date_time_or_event_occurrence;
WHERE
  WR1: EXISTS(effectivity_end_date) OR EXISTS(effectivity_start_date);
END_ENTITY;

ENTITY effectivity
  SUPERTYPE OF (ONEOF(serial_numbered_effectivity, dated_effectivity, lot_effectivity,
                      time_interval_based_effectivity));
  id : identifier;
DERIVE
  name        : label := get_name_value(SELF);
  description : text  := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY effectivity_relationship;
  name                 : label;
  description          : OPTIONAL text;
  related_effectivity  : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;

ENTITY lot_effectivity
  SUBTYPE OF (effectivity);
  effectivity_lot_id   : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;

ENTITY serial_numbered_effectivity
  SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id   : OPTIONAL identifier;
END_ENTITY;

ENTITY time_interval_based_effectivity
  SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;

FUNCTION acyclic_effectivity_relationship(relation : effectivity_relationship;
                                          relatives : SET [1:?] OF effectivity;
                                          specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF effectivity_relationship;
END_LOCAL;
  IF relation.relating_effectivity IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(eff <* bag_to_set(
                    USEDIN(relation.relating_effectivity,
                    'EFFECTIVITY_SCHEMA.EFFECTIVITY_RELATIONSHIP.RELATED_EFFECTIVITY')) | specific_relation IN
                                                                                          TYPEOF(eff));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.31 2015/09/24 09:59:50 kevletu Exp
  ISO TC184/SC4/WG12 N8689 - ISO/TS 10303-1004 Elemental geometric shape - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N8006
  *)
(*  Interfaces:                 7 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA elemental_geometric_shape_mim;
USE FROM foundation_representation_mim;
USE FROM elemental_topology_mim;
USE FROM geometry_schema
  (axis1_placement,
   axis2_placement_2d,
   axis2_placement_3d,
   cartesian_point,
   cartesian_transformation_operator_2d,
   cartesian_transformation_operator_3d,
   direction,
   geometric_representation_context,
   geometric_representation_item);
USE FROM identification_assignment_mim;
USE FROM product_property_representation_schema
  (shape_representation);
USE FROM qualified_measure_schema
  (measure_representation_item);
USE FROM representation_schema
  (mapped_item,
   representation_map,
   value_representation_item);

TYPE representation_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
  (shape_representation);
END_TYPE;
END_SCHEMA;


(*
  Id: mim.exp,v 1.7 2012/10/11 05:49:05 liutkuviene Exp
  ISO TC184/SC4/WG12 N8009 - ISO/TS 10303-1005 Elemental topology - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N6897
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA elemental_topology_mim;
USE FROM foundation_representation_mim;
USE FROM topology_schema
  (connected_edge_set,
   connected_face_set,
   edge,
   edge_loop,
   face,
   face_bound,
   face_outer_bound,
   loop,
   oriented_edge,
   path,
   topological_representation_item,
   vertex,
   vertex_loop);
END_SCHEMA;


(*
  Id: experience_schema.exp,v 1.19 2014/03/04 00:30:35 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Experience schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Experience schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   4 *)
(*  Functions:                  2 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA experience_schema '{iso standard 10303 part(41) version(4) object(1) experience_schema(10)}';
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text,
   bag_to_set);

ENTITY experience;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_relationship;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  relating_experience : experience;
  related_experience  : experience;
END_ENTITY;

ENTITY experience_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_relationship;
  id                       : identifier;
  name                     : label;
  description              : OPTIONAL text;
  relating_experience_type : experience_type;
  related_experience_type  : experience_type;
END_ENTITY;

FUNCTION acyclic_experience_relationship(relation : experience_relationship;
                                         relatives : SET OF experience;
                                         specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF experience_relationship;
END_LOCAL;
  IF relation.relating_experience IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(expr <* bag_to_set(
                     USEDIN(relation.relating_experience,
                     'EXPERIENCE_SCHEMA.EXPERIENCE_RELATIONSHIP.RELATED_EXPERIENCE')) | specific_relation IN
                                                                                        TYPEOF(expr));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_experience_type_relationship(relation : experience_type_relationship;
                                              relatives : SET OF experience_type;
                                              specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF experience_type_relationship;
END_LOCAL;
  IF relation.relating_experience_type IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(exptyp <* bag_to_set(
                       USEDIN(relation.relating_experience_type,
                       'EXPERIENCE_SCHEMA.EXPERIENCE_TYPE_RELATIONSHIP.RELATED_EXPERIENCE_TYPE')) | specific_relation IN
                                                                                                    TYPEOF(exptyp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.7 2012/10/11 05:49:26 liutkuviene Exp
  ISO TC184/SC4/WG12 N8012 - ISO/TS 10303-1776 Extended date - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N5369
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA extended_date_mim;
USE FROM date_time_mim;
USE FROM date_time_schema
  (date,
   day_in_month_number,
   ordinal_date,
   week_of_year_and_day_date,
   year_month);
REFERENCE FROM date_time_schema
  (leap_year);
END_SCHEMA;


(*
  Id: mim.exp,v 1.33 2012/11/09 21:40:58 thomasrthurman Exp
  ISO TC184/SC4/WG12 N8266 - ISO/TS 10303-1106 Extended measure representation - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N5372
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  3 *)
(*  Procedures:                 0 *)
(*  Rules:                      1 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA extended_measure_representation_mim;
USE FROM qualified_measure_mim;
USE FROM representation_schema
  (compound_item_definition,
   compound_representation_item,
   list_representation_item,
   set_representation_item);
REFERENCE FROM support_resource_schema
  (type_check_function);

ENTITY value_range
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: ('REPRESENTATION_SCHEMA.SET_REPRESENTATION_ITEM' IN TYPEOF(item_element)) AND value_range_wr1(item_element);
  WR2: value_range_wr2(item_element);
  WR3: value_range_wr3(item_element);
END_ENTITY;

FUNCTION value_range_wr1(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF (SIZEOF(agg) = 2) AND
            ((SIZEOF(QUERY(i1 <* agg | ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)))) = 2) OR
             (SIZEOF(QUERY(i2 <* agg | ('REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF(i2)))) = 2))
         THEN
           RETURN(true);
         ELSE
           RETURN(false);
         END_IF;
  END;
END_FUNCTION;

FUNCTION value_range_wr2(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF ((SIZEOF(QUERY(i <* agg | (i\representation_item.name = 'upper limit'))) = 1) AND
             (SIZEOF(QUERY(i <* agg | (i\representation_item.name = 'lower limit'))) = 1))
         THEN
           RETURN(true);
         ELSE
           RETURN(false);
         END_IF;
  END;
END_FUNCTION;

FUNCTION value_range_wr3(agg : compound_item_definition) : BOOLEAN;
  BEGIN  
         IF (SIZEOF(
             QUERY(i1 <* agg | ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) AND
                               (SIZEOF(
                                QUERY(i2 <* agg | ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN
                                                   TYPEOF(i2)) AND
                                                  (i1 :<>: i2) AND
                                                  (i1\measure_with_unit.unit_component :=:
                                                   i2\measure_with_unit.unit_component))) =
                                1))) =
             2)
         THEN
           RETURN(true);
         ELSE
           RETURN(false);
         END_IF;
  END;
END_FUNCTION;

RULE subtype_exclusiveness_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF(
       QUERY(cri <* representation_item | NOT (type_check_function(cri,
                                               ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
                                                'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM',
                                                'REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM'],
                                               3)))) =
       0;
END_RULE;
END_SCHEMA;


(*
  Id: mim.exp,v 1.17 2008/09/12 12:13:34 liutkuviene Exp
  ISO TC184/SC4/WG12 N5375 - ISO/TS 10303-1275 External class - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4733
  *)
(*  Interfaces:                 6 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA external_class_mim;
USE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select);
USE FROM class_mim;
USE FROM external_source_mim;
USE FROM classification_schema
  (class);
USE FROM external_reference_schema
  (external_source,
   externally_defined_item);
USE FROM name_assignment_mim;

TYPE external_class_name_item = SELECT BASED_ON name_item WITH 
  (external_class_library);
END_TYPE;

ENTITY externally_defined_class
  SUBTYPE OF (class, externally_defined_item);
END_ENTITY;

ENTITY external_class_library
  SUBTYPE OF (external_source);
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.12 2004/10/21 17:58:55 darla Exp
  ISO TC184/SC4/WG12 N1208 - ISO/TS 10303-1128 External item identification assignment - EXPRESS MIM
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA external_item_identification_assignment_mim;
USE FROM management_resources_schema
  (external_identification_assignment);
USE FROM support_resource_schema
  (identifier);

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_external_identification_assignment
  SUBTYPE OF (external_identification_assignment);
  items : SET [1:?] OF external_identification_item;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.7 2009/04/22 20:07:48 liutkuviene Exp
  ISO TC184/SC4/WG12 N6235 - ISO/TS 10303-1778 External library - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N5381
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA external_library_mim;
USE FROM external_source_mim;
USE FROM plib_class_reference_mim;

TYPE el_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
  (external_source);
END_TYPE;
END_SCHEMA;


(*
  Id: mim.exp,v 1.4 2012/10/06 20:09:56 liutkuviene Exp
  ISO TC184/SC4/WG12 N7679 - ISO/TS 10303-1033 External model - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N1229
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA external_model_mim;
USE FROM elemental_geometric_shape_mim;
USE FROM file_identification_mim;
USE FROM product_property_definition_schema
  (property_definition);
USE FROM product_property_representation_schema
  (property_definition_representation);
END_SCHEMA;


(*
  Id: mim.exp,v 1.26 2012/10/11 19:02:51 thomasrthurman Exp
  ISO TC184/SC4/WG12 N8015 - ISO/TS 10303-1129 External properties - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7440
  *)
(*  Interfaces:                 7 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      3 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA external_properties_mim;
USE FROM external_library_mim;
USE FROM identification_assignment_mim;
USE FROM independent_property_mim;
USE FROM plib_class_reference_mim;
USE FROM external_reference_schema
  (externally_defined_item,
   externally_defined_item_with_multiple_references,
   externally_defined_item_relationship);
USE FROM support_resource_schema
  (identifier);
REFERENCE FROM management_resources_schema
  (identification_role);

TYPE external_identification_for_plib_property = SELECT BASED_ON external_identification_item WITH 
  (externally_defined_general_property);
END_TYPE;

ENTITY externally_defined_general_property
  SUBTYPE OF (general_property, externally_defined_item);
END_ENTITY;

FUNCTION external_version_assignment_is_valid(aia : applied_external_identification_assignment) : BOOLEAN;
LOCAL
  item : external_identification_item;
  role : identification_role;
END_LOCAL;
  role := aia.role;
  IF role.name = 'version'
  THEN
    REPEAT i := LOINDEX(aia\applied_external_identification_assignment.items) TO HIINDEX(
                                                                                 aia
                                                                                    \applied_external_identification_assignment
                                                                                    .items);
      item := aia\applied_external_identification_assignment.items[i];
      IF (SIZEOF(['EXTERNAL_PROPERTIES_MIM.EXTERNALLY_DEFINED_GENERAL_PROPERTY'] * TYPEOF(item)) = 0)
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(true);
  ELSE
    RETURN(true);
  END_IF;
END_FUNCTION;

RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);
WHERE
  WR1: SIZEOF(
       QUERY(aia <* applied_external_identification_assignment | NOT external_version_assignment_is_valid(aia))) =
       0;
END_RULE;

RULE plib_property_reference_requires_name_scope FOR (externally_defined_general_property);
LOCAL
  known_sourced_properties : SET OF externally_defined_general_property;
END_LOCAL;
  known_sourced_properties := QUERY(edc <* externally_defined_general_property | 'PLIB_CLASS_REFERENCE_MIM.KNOWN_SOURCE' IN
                                                                                 TYPEOF(edc.source));
WHERE
  WR1: SIZEOF(
       QUERY(edgp <* known_sourced_properties | (SIZEOF(
                                                 QUERY(edir <* USEDIN(edgp,
                                                               'EXTERNAL_REFERENCE_SCHEMA.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM') | (edir
                                                                                                                                                      .name =
                                                                                                                                                  'name scope') AND
                                                                                                                                                 ('EXTERNAL_CLASS_MIM.EXTERNALLY_DEFINED_CLASS' IN
                                                                                                                                                  TYPEOF(
                                                                                                                                                  edir
                                                                                                                                                      .related_item)) AND
                                                                                                                                                 ('PLIB_CLASS_REFERENCE_MIM.KNOWN_SOURCE' IN
                                                                                                                                                  TYPEOF(
                                                                                                                                                  edir
                                                                                                                                                      .related_item
                                                                                                                                                      .source)))) <>
                                                 1))) =
       0;
END_RULE;

RULE plib_property_reference_requires_version FOR (externally_defined_general_property);
LOCAL
  plib_properties : SET OF externally_defined_general_property := [];
END_LOCAL;
  plib_properties := QUERY(edgp <* externally_defined_general_property | ('EXTERNAL_PROPERTIES_MIM.KNOWN_SOURCE' IN
                                                                          TYPEOF(edgp.source)) AND
                                                                         ('EXTERNAL_PROPERTIES_MIM.KNOWN_SOURCE.NAME' =
                                                                          'ISO 13584 library'));
WHERE
  WR1: SIZEOF(
       QUERY(edgp <* plib_properties | (SIZEOF(
                                        QUERY(edir <* USEDIN(edgp,
                                                      'EXTERNAL_ITEM_IDENTIFICATION_ASSIGNMENT_MIM.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | (edir
                                                                                                                                                             .role
                                                                                                                                                             .name =
                                                                                                                                                         'version'))) <>
                                        1))) =
       0;
END_RULE;
END_SCHEMA;


(*
  Id: external_reference_schema.exp,v 1.13 2014/03/04 00:30:36 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - External reference schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - External reference schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   6 *)
(*  Functions:                  2 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      3 *)

SCHEMA external_reference_schema '{iso standard 10303 part(41) version(7) object(1) external_reference_schema(11)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value);
REFERENCE FROM support_resource_schema
  (label,
   text,
   identifier,
   bag_to_set);

TYPE ers_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (external_source);
END_TYPE;

TYPE message = STRING;
END_TYPE;

TYPE source_item = SELECT 
  (identifier,
   message);
END_TYPE;

ENTITY externally_defined_item;
  item_id : source_item;
  source  : external_source;
END_ENTITY;

ENTITY externally_defined_item_relationship;
  name          : label;
  description   : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item  : externally_defined_item;
END_ENTITY;

ENTITY externally_defined_item_with_multiple_references
  SUBTYPE OF (externally_defined_item);
  references : LIST [1:?] OF UNIQUE source_item;
UNIQUE
  UR1: references;
WHERE
  WR1: NOT (SELF\externally_defined_item.item_id IN references);
END_ENTITY;

ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY external_source_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_source : external_source;
  related_source  : external_source;
END_ENTITY;

ENTITY pre_defined_item;
  name : label;
END_ENTITY;

FUNCTION acyclic_externally_defined_item_relationship(relation : externally_defined_item_relationship;
                                                      relatives : SET [1:?] OF externally_defined_item;
                                                      specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF externally_defined_item_relationship;
END_LOCAL;
  IF relation.relating_item IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(edi <* bag_to_set(
                    USEDIN(relation.relating_item,
                    'EXTERNAL_REFERENCE_SCHEMA.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATED_ITEM')) | specific_relation IN
                                                                                                      TYPEOF(edi));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_external_source_relationship(relation : external_source_relationship;
                                              relatives : SET [1:?] OF external_source;
                                              specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF external_source_relationship;
END_LOCAL;
  IF relation.relating_source IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(es <* bag_to_set(
                   USEDIN(relation.relating_source,
                   'EXTERNAL_REFERENCE_SCHEMA.EXTERNAL_SOURCE_RELATIONSHIP.RELATED_SOURCE')) | specific_relation IN
                                                                                               TYPEOF(es));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.5 2009/12/18 15:04:40 robbod Exp
  ISO TC184/SC4/WG12 N5387 - ISO/TS 10303-1331 External source - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N5076
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA external_source_mim;
USE FROM external_reference_schema;
END_SCHEMA;


(*
  Id: mim.exp,v 1.18 2011/10/12 08:46:47 philsp Exp
  ISO TC184/SC4/WG12 N7112 - ISO/TS 10303-1127 File identification - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N1205
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA file_identification_mim;
USE FROM document_schema
  (document,
   document_representation_type);
USE FROM external_item_identification_assignment_mim;
USE FROM identification_assignment_mim;
USE FROM product_property_definition_schema
  (characterized_object);

TYPE file_identification_item = SELECT BASED_ON identification_item WITH 
  (document_file);
END_TYPE;

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH 
  (document_file);
END_TYPE;

ENTITY document_file
  SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN ['digital','physical'])) = 1;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.19 2009/12/21 09:20:21 liutkuviene Exp
  ISO TC184/SC4/WG12 N6903 - ISO/TS 10303-1006 Foundation representation - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4349
  *)
(*  Interfaces:                 6 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA foundation_representation_mim;
USE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   id_attribute,
   id_attribute_select);
USE FROM measure_schema
  (global_unit_assigned_context);
USE FROM qualified_measure_schema
  (descriptive_representation_item);
USE FROM representation_schema
  (global_uncertainty_assigned_context,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   uncertainty_measure_with_unit);
USE FROM support_resource_mim;
USE FROM value_with_unit_mim;
END_SCHEMA;


(*
  Id: mim.exp,v 1.7 2012/10/11 05:49:26 liutkuviene Exp
  ISO TC184/SC4/WG12 N8024 - ISO/TS 10303-1403 Geometric model relationship - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N6906
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA geometric_model_relationship_mim;
USE FROM elemental_geometric_shape_mim;
USE FROM representation_schema
  (definitional_representation_relationship);
USE FROM product_property_representation_schema
  (shape_representation_relationship);
END_SCHEMA;


(*Updated March 2015 with curved triangle additions to tesselated geometry
  Id: geometric_model_schema.exp,v 1.16 2015/08/18 06:55:13 kevletu Exp
  ISO 10303 TC184/SC4/WG12 N8545 (3 schemas)

  EXPRESS Source:
  ISO 10303-42 ed5 Geometric and topological representation - Geometric model schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-42 ed4 Geometric and topological representation - Geometric model schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 5 *)
(*  Constants:                  0 *)
(*  Entities:                  74 *)
(*  Functions:                  6 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                     12 *)

SCHEMA geometric_model_schema '{iso standard 10303 part(42) version(10) object(1) geometric_model_schema(3)}';
REFERENCE FROM geometry_schema;
REFERENCE FROM topology_schema;
REFERENCE FROM measure_schema
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure);
REFERENCE FROM representation_schema
  (founded_item,
   representation,
   representation_item,
   using_representations);
REFERENCE FROM product_property_representation_schema
  (shape_representation);

TYPE boolean_operand = SELECT 
  (boolean_result,
   csg_primitive,
   half_space_2d,
   half_space_solid,
   solid_model);
END_TYPE;

TYPE boolean_operator = ENUMERATION OF
  (union,
   intersection,
   difference);
END_TYPE;

TYPE bounded_primitive_2d = EXTENSIBLE GENERIC_ENTITY SELECT 
  (area_with_outer_boundary,
   circular_area,
   elliptic_area,
   polygonal_area,
   rectangular_area);
END_TYPE;

TYPE csg_primitive = SELECT 
  (block,
   bounded_primitive_2d,
   cyclide_segment_solid,
   eccentric_cone,
   ellipsoid,
   faceted_primitive,
   rectangular_pyramid,
   right_angular_wedge,
   right_circular_cone,
   right_circular_cylinder,
   sphere,
   torus);
END_TYPE;

TYPE csg_select = SELECT 
  (boolean_result,
   csg_primitive);
END_TYPE;

TYPE edge_or_curve = SELECT 
  (curve,
   edge);
END_TYPE;

TYPE face_or_surface = SELECT 
  (face,
   surface);
END_TYPE;

TYPE geometric_set_select = SELECT 
  (curve,
   point,
   surface);
END_TYPE;

TYPE path_or_composite_curve = SELECT 
  (composite_curve,
   path);
END_TYPE;

TYPE surface_model = SELECT 
  (face_based_surface_model,
   shell_based_surface_model);
END_TYPE;

TYPE tessellated_edge_or_vertex = SELECT 
  (tessellated_edge,
   tessellated_vertex);
END_TYPE;

TYPE wireframe_model = SELECT 
  (edge_based_wireframe_model,
   shell_based_wireframe_model);
END_TYPE;

ENTITY area_with_outer_boundary
  SUBTYPE OF (half_space_2d);
  SELF\half_space_2d.base_curve : composite_curve;
WHERE
  WR1: base_curve\composite_curve.closed_curve = true;
END_ENTITY;

ENTITY block
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x        : positive_length_measure;
  y        : positive_length_measure;
  z        : positive_length_measure;
END_ENTITY;

ENTITY boolean_result
  SUBTYPE OF (geometric_representation_item);
  operator       : boolean_operator;
  first_operand  : boolean_operand;
  second_operand : boolean_operand;
END_ENTITY;

ENTITY boxed_half_space
  SUBTYPE OF (half_space_solid);
  enclosure : box_domain;
END_ENTITY;

ENTITY box_domain
  SUBTYPE OF (founded_item);
  corner  : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  zlength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '') | NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0;
END_ENTITY;

ENTITY brep_2d
  SUBTYPE OF (solid_model);
  extent : face;
WHERE
  WR1: SIZEOF(
       ['TOPOLOGY_SCHEMA.FACE_SURFACE','TOPOLOGY_SCHEMA.SUBFACE','TOPOLOGY_SCHEMA.ORIENTED_FACE'] *
       TYPEOF(SELF.extent)) =
       0;
  WR2: SIZEOF(QUERY(bnds <* extent.bounds | NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)))) = 0;
  WR3: SIZEOF(QUERY(bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
  WR4: SIZEOF(
       QUERY(elp_fbnds <* QUERY(bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN
                                                        TYPEOF(bnds.bound)) | NOT (SIZEOF(
                                                                                   QUERY(oe <* elp_fbnds.bound\path
                                                                                                        .edge_list | NOT (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN
                                                                                                                           TYPEOF(
                                                                                                                           oe
                                                                                                                             .edge_element)) AND
                                                                                                                          (oe
                                                                                                                             .edge_element
                                                                                                                             \geometric_representation_item
                                                                                                                             .dim =
                                                                                                                           2)))) =
                                                                                   0))) =
       0;
END_ENTITY;

ENTITY brep_with_voids
  SUBTYPE OF (manifold_solid_brep);
  voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY;

ENTITY circular_area
  SUBTYPE OF (primitive_2d);
  centre : cartesian_point;
  radius : positive_length_measure;
END_ENTITY;

ENTITY complex_triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex         : LIST [0:?] OF INTEGER;
  triangle_strips : LIST [0:?] OF LIST [3:?] OF INTEGER;
  triangle_fans   : LIST [0:?] OF LIST [3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY complex_triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex         : LIST [0:?] OF INTEGER;
  triangle_strips : LIST [0:?] OF LIST [3:?] OF INTEGER;
  triangle_fans   : LIST [0:?] OF LIST [3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY convex_hexahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 8;
  WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR8: same_side([points[1],points[2],points[3]], [points[5],points[6],points[7],points[8]]);
  WR9: same_side([points[1],points[4],points[8]], [points[3],points[7],points[6],points[2]]);
  WR10: same_side([points[1],points[2],points[5]], [points[3],points[7],points[8],points[4]]);
  WR11: same_side([points[5],points[6],points[7]], [points[1],points[2],points[3],points[4]]);
  WR12: same_side([points[3],points[7],points[6]], [points[1],points[4],points[8],points[5]]);
  WR13: same_side([points[3],points[7],points[8]], [points[1],points[5],points[6],points[2]]);
END_ENTITY;

ENTITY coordinates_list
  SUBTYPE OF (tessellated_item);
  npoints         : INTEGER;
  position_coords : LIST [1:?] OF LIST [3:3] OF REAL;
WHERE
  WR1: npoints = SIZEOF(position_coords);
  WR2: SIZEOF(['GEOMETRIC_MODEL_SCHEMA.REPOSITIONED_TESSELLATED_ITEM'] * TYPEOF(SELF)) = 0;
END_ENTITY;

ENTITY csg_solid
  SUBTYPE OF (solid_model);
  tree_root_expression : csg_select;
END_ENTITY;

ENTITY cubic_bezier_tessellated_edge
  SUBTYPE OF (tessellated_edge);
  SELF\tessellated_edge.line_strip : LIST [4:?] OF INTEGER;
END_ENTITY;

ENTITY cubic_bezier_triangulated_face
  SUBTYPE OF (tessellated_face);
  ctriangles : LIST [1:?] OF LIST [10:10] OF INTEGER;
WHERE
  WR1: SIZEOF(SELF\tessellated_face.normals) = 0;
END_ENTITY;

ENTITY cubic_tessellated_connecting_edge
  SUBTYPE OF (cubic_bezier_tessellated_edge);
  smooth : LOGICAL;
  face1  : cubic_bezier_triangulated_face;
  face2  : cubic_bezier_triangulated_face;
END_ENTITY;

ENTITY cyclide_segment_solid
  SUBTYPE OF (geometric_representation_item);
  position    : axis2_placement_3d;
  radius1     : positive_length_measure;
  radius2     : positive_length_measure;
  cone_angle1 : plane_angle_measure;
  cone_angle2 : plane_angle_measure;
  turn_angle  : plane_angle_measure;
END_ENTITY;

ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
  position    : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height      : positive_length_measure;
  x_offset    : length_measure;
  y_offset    : length_measure;
  ratio       : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY edge_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  ebwm_boundary : SET [1:?] OF connected_edge_set;
END_ENTITY;

ENTITY ellipsoid
  SUBTYPE OF (geometric_representation_item);
  position    : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY elliptic_area
  SUBTYPE OF (primitive_2d);
  position    : axis2_placement_2d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY extruded_area_solid
  SUBTYPE OF (swept_area_solid);
  extruded_direction : direction;
  depth              : positive_length_measure;
WHERE
  WR1: dot_product((SELF\swept_area_solid.swept_area.basis_surface\elementary_surface.position.p[3]),
       extruded_direction) <>
       0.0;
END_ENTITY;

ENTITY extruded_face_solid
  SUBTYPE OF (swept_face_solid);
  extruded_direction : direction;
  depth              : positive_length_measure;
WHERE
  WR1: dot_product((SELF\swept_face_solid.swept_face.face_geometry\elementary_surface.position.p[3]),
       extruded_direction) <>
       0.0;
END_ENTITY;

ENTITY faceted_brep
  SUBTYPE OF (manifold_solid_brep);
END_ENTITY;

ENTITY faceted_primitive
  SUPERTYPE OF (ONEOF(tetrahedron, convex_hexahedron))
  SUBTYPE OF (geometric_representation_item);
  points : LIST [4:?] OF UNIQUE cartesian_point;
WHERE
  WR1: points[1].dim = 3;
END_ENTITY;

ENTITY face_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  fbsm_faces : SET [1:?] OF connected_face_set;
END_ENTITY;

ENTITY geometric_curve_set
  SUBTYPE OF (geometric_set);
WHERE
  WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements | 'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp))) = 0;
END_ENTITY;

ENTITY geometric_set
  SUPERTYPE OF (ONEOF(geometric_curve_set, geometric_set_replica))
  SUBTYPE OF (geometric_representation_item);
  elements : SET [1:?] OF geometric_set_select;
END_ENTITY;

ENTITY geometric_set_replica
  SUBTYPE OF (geometric_set);
  parent_set     : geometric_set;
  transformation : cartesian_transformation_operator;
DERIVE
  SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := build_transformed_set(transformation, parent_set);
WHERE
  WR1: acyclic_set_replica(SELF, parent_set);
END_ENTITY;

ENTITY half_space_2d
  SUBTYPE OF (primitive_2d);
  base_curve     : curve;
  agreement_flag : BOOLEAN;
END_ENTITY;

ENTITY half_space_solid
  SUBTYPE OF (geometric_representation_item);
  base_surface   : surface;
  agreement_flag : BOOLEAN;
END_ENTITY;

ENTITY manifold_solid_brep
  SUBTYPE OF (solid_model);
  outer : closed_shell;
END_ENTITY;

ENTITY polygonal_area
  SUBTYPE OF (primitive_2d);
  bounds : LIST [3:?] OF UNIQUE cartesian_point;
END_ENTITY;

ENTITY primitive_2d
  SUPERTYPE OF (ONEOF(circular_area, elliptic_area, rectangular_area, polygonal_area, half_space_2d))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY rectangled_half_space
  SUBTYPE OF (half_space_2d);
  enclosure : rectangle_domain;
END_ENTITY;

ENTITY rectangle_domain
  SUBTYPE OF (founded_item);
  corner  : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '') | NOT ('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) =
       0;
END_ENTITY;

ENTITY rectangular_area
  SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  x        : positive_length_measure;
  y        : positive_length_measure;
END_ENTITY;

ENTITY rectangular_pyramid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  xlength  : positive_length_measure;
  ylength  : positive_length_measure;
  height   : positive_length_measure;
END_ENTITY;

ENTITY repositioned_tessellated_item
  SUBTYPE OF (tessellated_item);
  location : axis2_placement_3d;
WHERE
  WR1: NOT (SIZEOF(
            ['GEOMETRIC_MODEL_SCHEMA.TESSELLATED_CURVE_SET',
             'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_GEOMETRIC_SET',
             'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_POINT_SET',
             'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SURFACE_SET',
             'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHELL',
             'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SOLID',
             'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_WIRE'] *
            TYPEOF(SELF)) =
            0);
END_ENTITY;

ENTITY revolved_area_solid
  SUBTYPE OF (swept_area_solid);
  axis  : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('') || geometric_representation_item() || curve() ||
                      line(axis.location,
                           representation_item('') || geometric_representation_item() || vector(axis.z, 1.0));
END_ENTITY;

ENTITY revolved_face_solid
  SUBTYPE OF (swept_face_solid);
  axis  : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('') || geometric_representation_item() || curve() ||
                      line(axis.location,
                           representation_item('') || geometric_representation_item() || vector(axis.z, 1.0));
END_ENTITY;

ENTITY right_angular_wedge
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x        : positive_length_measure;
  y        : positive_length_measure;
  z        : positive_length_measure;
  ltx      : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

ENTITY right_circular_cone
  SUBTYPE OF (geometric_representation_item);
  position   : axis1_placement;
  height     : positive_length_measure;
  radius     : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

ENTITY right_circular_cylinder
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height   : positive_length_measure;
  radius   : positive_length_measure;
END_ENTITY;

ENTITY sectioned_spine
  SUBTYPE OF (geometric_curve_set);
  cross_sections : LIST [2:?] OF curve;
  spine_points   : LIST [2:?] OF point;
WHERE
  WR1: SIZEOF(SELF\geometric_set.elements) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF\geometric_set.elements[1]);
  WR3: SIZEOF(cross_sections) = SIZEOF(spine_points);
  WR4: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY shell_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  sbsm_boundary : SET [1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY;

ENTITY shell_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  sbwm_boundary : SET [1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY;

ENTITY solid_model
  SUPERTYPE OF (ONEOF(csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid,
                      solid_replica, brep_2d, trimmed_volume))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY solid_replica
  SUBTYPE OF (solid_model);
  parent_solid   : solid_model;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_solid_replica(SELF, parent_solid);
  WR2: parent_solid\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY sphere
  SUBTYPE OF (geometric_representation_item);
  radius : positive_length_measure;
  centre : point;
END_ENTITY;

ENTITY surface_curve_swept_area_solid
  SUBTYPE OF (swept_area_solid);
  directrix         : curve;
  start_param       : REAL;
  end_param         : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
       (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY surface_curve_swept_face_solid
  SUBTYPE OF (swept_face_solid);
  directrix         : curve;
  start_param       : REAL;
  end_param         : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
       (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY swept_area_solid
  SUPERTYPE OF (ONEOF(revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid))
  SUBTYPE OF (solid_model);
  swept_area : curve_bounded_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY;

ENTITY swept_disk_solid
  SUBTYPE OF (solid_model);
  directrix    : curve;
  radius       : positive_length_measure;
  inner_radius : OPTIONAL positive_length_measure;
  start_param  : REAL;
  end_param    : REAL;
WHERE
  WR1: directrix.dim = 3;
  WR2: (NOT EXISTS(inner_radius)) OR (radius > inner_radius);
END_ENTITY;

ENTITY swept_face_solid
  SUPERTYPE OF (ONEOF(extruded_face_solid, revolved_face_solid, surface_curve_swept_face_solid))
  SUBTYPE OF (solid_model);
  swept_face : face_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY;

ENTITY tessellated_connecting_edge
  SUBTYPE OF (tessellated_edge);
  smooth           : LOGICAL;
  face1            : tessellated_face;
  face2            : tessellated_face;
  line_strip_face1 : LIST [2:?] OF INTEGER;
  line_strip_face2 : LIST [2:?] OF INTEGER;
WHERE
  WR1: SIZEOF(line_strip_face1) = SIZEOF(line_strip_face2);
  WR2: SIZEOF(line_strip_face1) = SIZEOF(SELF\tessellated_edge.line_strip);
  WR3: NOT (('GEOMETRIC_MODEL_SCHEMA.CUBIC_BEZIER_TRIANGULATED_FACE') IN TYPEOF(face1));
  WR4: NOT (('GEOMETRIC_MODEL_SCHEMA.CUBIC_BEZIER_TRIANGULATED_FACE') IN TYPEOF(face2));
END_ENTITY;

ENTITY tessellated_curve_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  line_strips : LIST [1:?] OF LIST [2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_edge
  SUPERTYPE OF (ONEOF(tessellated_connecting_edge, cubic_bezier_tessellated_edge))
  SUBTYPE OF (tessellated_structured_item);
  coordinates    : coordinates_list;
  geometric_link : OPTIONAL edge_or_curve;
  line_strip     : LIST [2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_face
  ABSTRACT SUPERTYPE OF (ONEOF(triangulated_face, complex_triangulated_face, cubic_bezier_triangulated_face))
  SUBTYPE OF (tessellated_structured_item);
  coordinates    : coordinates_list;
  pnmax          : INTEGER;
  normals        : LIST [0:?] OF LIST [3:3] OF REAL;
  geometric_link : OPTIONAL face_or_surface;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY tessellated_geometric_set
  SUBTYPE OF (tessellated_item);
  children : SET [1:?] OF tessellated_item;
END_ENTITY;

ENTITY tessellated_item
  ABSTRACT SUPERTYPE OF (ONEOF(coordinates_list, tessellated_solid, tessellated_shell, tessellated_wire,
                               tessellated_geometric_set, tessellated_curve_set, tessellated_point_set,
                               tessellated_surface_set, tessellated_structured_item))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SIZEOF(
       QUERY(using_rep <* using_representations(
                          SELF) | NOT ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHAPE_REPRESENTATION' IN
                                       TYPEOF(using_rep)))) =
       0;
END_ENTITY;

ENTITY tessellated_point_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  point_list  : LIST [1:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: 'REPRESENTATION_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
  WR2: NOT (SIZEOF(QUERY(it <* SELF.items | 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_ITEM' IN TYPEOF(it))) = 0);
END_ENTITY;

ENTITY tessellated_shell
  SUBTYPE OF (tessellated_item);
  items            : SET [1:?] OF tessellated_structured_item;
  topological_link : OPTIONAL connected_face_set;
END_ENTITY;

ENTITY tessellated_solid
  SUBTYPE OF (tessellated_item);
  items          : SET [1:?] OF tessellated_structured_item;
  geometric_link : OPTIONAL manifold_solid_brep;
END_ENTITY;

ENTITY tessellated_structured_item
  SUPERTYPE OF (ONEOF(tessellated_face, tessellated_edge, tessellated_vertex))
  SUBTYPE OF (tessellated_item);
END_ENTITY;

ENTITY tessellated_surface_set
  ABSTRACT SUPERTYPE OF (ONEOF(triangulated_surface_set, complex_triangulated_surface_set))
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  pnmax       : INTEGER;
  normals     : LIST [0:?] OF LIST [3:3] OF REAL;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY tessellated_vertex
  SUBTYPE OF (tessellated_structured_item);
  coordinates      : coordinates_list;
  topological_link : OPTIONAL vertex_point;
  point_index      : INTEGER;
END_ENTITY;

ENTITY tessellated_wire
  SUBTYPE OF (tessellated_item);
  items                : SET [1:?] OF tessellated_edge_or_vertex;
  geometric_model_link : OPTIONAL path_or_composite_curve;
END_ENTITY;

ENTITY tetrahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 4;
  WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
END_ENTITY;

ENTITY torus
  SUBTYPE OF (geometric_representation_item);
  position     : axis1_placement;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: major_radius > minor_radius;
END_ENTITY;

ENTITY triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex   : LIST [0:?] OF INTEGER;
  triangles : LIST [1:?] OF LIST [3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex   : LIST [0:?] OF INTEGER;
  triangles : LIST [1:?] OF LIST [3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT ((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY trimmed_volume
  SUBTYPE OF (solid_model);
  basis_volume : volume;
  u1           : parameter_value;
  u2           : parameter_value;
  v1           : parameter_value;
  v2           : parameter_value;
  w1           : parameter_value;
  w2           : parameter_value;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: w1 <> w2;
END_ENTITY;

FUNCTION acyclic_set_replica(rep : geometric_set_replica;
                             parent : geometric_set) : BOOLEAN;
  IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(true);
  END_IF;
  IF (parent :=: rep)
  THEN
    RETURN(false);
  ELSE
    RETURN(acyclic_set_replica(rep, parent\geometric_set_replica.parent_set));
  END_IF;
END_FUNCTION;

FUNCTION acyclic_solid_replica(rep : solid_replica;
                               parent : solid_model) : BOOLEAN;
  IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(true);
  END_IF;
  IF (parent :=: rep)
  THEN
    RETURN(false);
  ELSE
    RETURN(acyclic_solid_replica(rep, parent\solid_replica.parent_solid));
  END_IF;
END_FUNCTION;

FUNCTION build_transformed_set(tr : cartesian_transformation_operator;
                               gset : geometric_set) : SET [0:?] OF geometric_set_select;
LOCAL
  s     : SET [1:?] OF geometric_set_select := gset.elements;
  trset : SET [0:?] OF geometric_set_select := [];
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(s);
    IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j]))
    THEN
      trset := trset + dummy_gri || curve() || curve_replica(s[j], tr);
    ELSE
      IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j]))
      THEN
        trset := trset + dummy_gri || point() || point_replica(s[j], tr);
      ELSE
        IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j]))
        THEN
          trset := trset +
                   dummy_gri || surface() || surface_replica(s[j], tr || cartesian_transformation_operator_3d(?));
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
  RETURN(trset);
END_FUNCTION;

FUNCTION constraints_geometry_shell_based_surface_model(m : shell_based_surface_model) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
    IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(m.sbsm_boundary[j])) AND
            (NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary[j]))))
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION constraints_geometry_shell_based_wireframe_model(m : shell_based_wireframe_model) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
    IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(m.sbwm_boundary[j])) AND
            (NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary[j]))))
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION msb_shells(brep : manifold_solid_brep) : SET [1:?] OF closed_shell;
LOCAL
  return_set : SET [1:?] OF closed_shell := [brep.outer];
END_LOCAL;
  IF SIZEOF(QUERY(msbtype <* TYPEOF(brep) | msbtype LIKE '*BREP_WITH_VOIDS')) >= 1
  THEN
    return_set := return_set + brep\brep_with_voids.voids;
  END_IF;
  RETURN(return_set);
END_FUNCTION;
END_SCHEMA;


(*
  Id: geometry_schema.exp,v 1.23 2015/10/21 15:51:25 lothartklein Exp *)
(*Geometry schema from STEPMOD with proposed isogeometry additions and changes - these are annotated with isogeometry comment
  Part of Part 42 Edition 5 EXPRESS WG12 N8381

  EXPRESS Source:
  ISO 10303-42 ed5 Geometric and topological representation - Geometry schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-42 ed4 Geometric and topological representation - Geometry schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD

  *)
(*  Interfaces:                 5 *)
(*  Constants:                  1 *)
(*  Entities:                 107 *)
(*  Functions:                 39 *)
(*  Procedures:                 0 *)
(*  Rules:                      1 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                     17 *)

SCHEMA geometry_schema '{iso standard 10303 part(42) version(10) object(1) geometry_schema(1)}';
REFERENCE FROM representation_schema
  (definitional_representation,
   founded_item,
   functionally_defined_transformation,
   item_in_context,
   representation,
   representation_context,
   representation_item,
   using_representations);
REFERENCE FROM measure_schema
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure);
REFERENCE FROM topology_schema
  (edge_curve,
   face_surface,
   poly_loop,
   vertex_point,
   volume_with_faces);
REFERENCE FROM geometric_model_schema
  (block,
   boolean_result,
   cyclide_segment_solid,
   eccentric_cone,
   edge_based_wireframe_model,
   ellipsoid,
   face_based_surface_model,
   faceted_primitive,
   geometric_set,
   half_space_solid,
   primitive_2d,
   rectangular_pyramid,
   right_angular_wedge,
   right_circular_cone,
   right_circular_cylinder,
   shell_based_surface_model,
   shell_based_wireframe_model,
   solid_model,
   sphere,
   tessellated_item,
   torus);
REFERENCE FROM scan_data_3d_shape_model_schema
  (scanned_data_item);
CONSTANT
  dummy_gri : geometric_representation_item := representation_item('') || geometric_representation_item();
END_CONSTANT;

TYPE axis2_placement = SELECT 
  (axis2_placement_2d,
   axis2_placement_3d);
END_TYPE;

TYPE b_spline_curve_form = ENUMERATION OF
  (polyline_form,
   circular_arc,
   elliptic_arc,
   parabolic_arc,
   hyperbolic_arc,
   unspecified);
END_TYPE;

TYPE b_spline_surface_form = ENUMERATION OF
  (plane_surf,
   cylindrical_surf,
   conical_surf,
   spherical_surf,
   toroidal_surf,
   surf_of_revolution,
   ruled_surf,
   generalised_cone,
   quadric_surf,
   surf_of_linear_extrusion,
   unspecified);
END_TYPE;

TYPE curve_on_surface = SELECT 
  (composite_curve_on_surface,
   pcurve,
   surface_curve);
END_TYPE;

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE;

TYPE extent_enumeration = ENUMERATION OF
  (invalid,
   zero,
   finite_non_zero,
   infinite);
END_TYPE;

TYPE knot_type = ENUMERATION OF
  (uniform_knots,
   quasi_uniform_knots,
   piecewise_bezier_knots,
   unspecified);
END_TYPE;

TYPE linearly_independent_enum = ENUMERATION OF
  (independent,
   not_independent,
   not_tested);
END_TYPE;

TYPE locally_refined_spline_type_enum = ENUMERATION OF
  (analysis_suitable_t_spline,
   hierarchical_b_spline,
   lr_b_spline,
   semi_standard_t_spline,
   standard_t_spline);
END_TYPE;

TYPE pcurve_or_surface = SELECT 
  (pcurve,
   surface);
END_TYPE;

TYPE preferred_surface_curve_representation = ENUMERATION OF
  (curve_3d,
   pcurve_s1,
   pcurve_s2);
END_TYPE;

TYPE spline_knot_values = LIST [2:?] OF REAL;
WHERE
  WR1: increasing_values_in_list(SELF);
END_TYPE;

TYPE surface_boundary = SELECT 
  (boundary_curve,
   degenerate_pcurve);
END_TYPE;

TYPE transition_code = ENUMERATION OF
  (discontinuous,
   continuous,
   cont_same_gradient,
   cont_same_gradient_same_curvature);
END_TYPE;

TYPE trimming_preference = ENUMERATION OF
  (cartesian,
   parameter,
   unspecified);
END_TYPE;

TYPE trimming_select = SELECT 
  (cartesian_point,
   parameter_value);
END_TYPE;

TYPE vector_or_direction = SELECT 
  (direction,
   vector);
END_TYPE;

ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [2:2] OF direction := build_2axes(ref_direction);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis          : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST [3:3] OF direction := build_axes(axis, ref_direction);
WHERE
  WR1: SELF\placement.location.dim = 3;
  WR2: (NOT (EXISTS(axis))) OR (axis.dim = 3);
  WR3: (NOT (EXISTS(ref_direction))) OR (ref_direction.dim = 3);
  WR4: (NOT (EXISTS(axis))) OR (NOT (EXISTS(ref_direction))) OR (cross_product(axis, ref_direction).magnitude > 0.0);
END_ENTITY;

ENTITY bezier_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY bezier_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY bezier_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY block_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x        : positive_length_measure;
  y        : positive_length_measure;
  z        : positive_length_measure;
END_ENTITY;

ENTITY boundary_curve
  SUBTYPE OF (composite_curve_on_surface);
WHERE
  WR1: SELF\composite_curve.closed_curve;
END_ENTITY;

ENTITY bounded_curve
  SUPERTYPE OF (ONEOF(polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve,
                      locally_refined_spline_curve))
  SUBTYPE OF (curve);
END_ENTITY;

ENTITY bounded_pcurve
  SUBTYPE OF (pcurve, bounded_curve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
END_ENTITY;

ENTITY bounded_surface
  SUPERTYPE OF (ONEOF(b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface,
                      rectangular_composite_surface, locally_refined_spline_surface))
  SUBTYPE OF (surface);
END_ENTITY;

ENTITY bounded_surface_curve
  SUBTYPE OF (surface_curve, bounded_curve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d));
END_ENTITY;

ENTITY b_spline_curve
  SUPERTYPE OF (ONEOF(uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR
                rational_b_spline_curve)
  SUBTYPE OF (bounded_curve);
  degree              : INTEGER;
  control_points_list : LIST [2:?] OF cartesian_point;
  curve_form          : b_spline_curve_form;
  closed_curve        : LOGICAL;
  self_intersect      : LOGICAL;
DERIVE
  upper_index_on_control_points : INTEGER                                                    := (SIZEOF(
                                                                                                 control_points_list) -
                                                                                                 1);
  control_points                : ARRAY [0:upper_index_on_control_points] OF cartesian_point := list_to_array(
                                                                                                control_points_list, 0,
                                                                                                upper_index_on_control_points);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(SELF)) OR
       ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(SELF)) OR
       ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_curve_with_knots
  SUBTYPE OF (b_spline_curve);
  knot_multiplicities : LIST [2:?] OF INTEGER;
  knots               : LIST [2:?] OF parameter_value;
  knot_spec           : knot_type;
DERIVE
  upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
  WR1: constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities,
       knots);
  WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

ENTITY b_spline_surface
  SUPERTYPE OF (ONEOF(b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR
                rational_b_spline_surface)
  SUBTYPE OF (bounded_surface);
  u_degree            : INTEGER;
  v_degree            : INTEGER;
  control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
  surface_form        : b_spline_surface_form;
  u_closed            : LOGICAL;
  v_closed            : LOGICAL;
  self_intersect      : LOGICAL;
DERIVE
  u_upper        : INTEGER                                                   := SIZEOF(control_points_list) - 1;
  v_upper        : INTEGER                                                   := SIZEOF(control_points_list[1]) - 1;
  control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF cartesian_point := make_array_of_array(
                                                                                control_points_list, 0, u_upper, 0,
                                                                                v_upper);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
       ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
       ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
       ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_surface_with_knots
  SUBTYPE OF (b_spline_surface);
  u_multiplicities : LIST [2:?] OF INTEGER;
  v_multiplicities : LIST [2:?] OF INTEGER;
  u_knots          : LIST [2:?] OF parameter_value;
  v_knots          : LIST [2:?] OF parameter_value;
  knot_spec        : knot_type;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper,
       u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper,
       v_multiplicities, v_knots);
  WR3: SIZEOF(u_multiplicities) = knot_u_upper;
  WR4: SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY;

ENTITY b_spline_volume
  SUPERTYPE OF (ONEOF(b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume, bezier_volume) ANDOR
                rational_b_spline_volume)
  SUBTYPE OF (volume);
  u_degree            : INTEGER;
  v_degree            : INTEGER;
  w_degree            : INTEGER;
  control_points_list : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF cartesian_point;
DERIVE
  u_upper        : INTEGER                                                                        := SIZEOF(
                                                                                                     control_points_list) -
                                                                                                     1;
  v_upper        : INTEGER                                                                        := SIZEOF(
                                                                                                     control_points_list
                                                                                                                        [1]) -
                                                                                                     1;
  w_upper        : INTEGER                                                                        := SIZEOF(
                                                                                                     control_points_list
                                                                                                                        [1]
                                                                                                                        [1]) -
                                                                                                     1;
  control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF ARRAY [0:w_upper] OF cartesian_point := make_array_of_array_of_array(
                                                                                                     control_points_list,
                                                                                                     0, u_upper, 0,
                                                                                                     v_upper, 0,
                                                                                                     w_upper);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
       ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
       ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_volume_with_knots
  SUBTYPE OF (b_spline_volume);
  u_multiplicities : LIST [2:?] OF INTEGER;
  v_multiplicities : LIST [2:?] OF INTEGER;
  w_multiplicities : LIST [2:?] OF INTEGER;
  u_knots          : LIST [2:?] OF parameter_value;
  v_knots          : LIST [2:?] OF parameter_value;
  w_knots          : LIST [2:?] OF parameter_value;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
  knot_w_upper : INTEGER := SIZEOF(w_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_volume.u_degree, knot_u_upper, SELF\b_spline_volume.u_upper,
       u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_volume.v_degree, knot_v_upper, SELF\b_spline_volume.v_upper,
       v_multiplicities, v_knots);
  WR3: constraints_param_b_spline(SELF\b_spline_volume.w_degree, knot_w_upper, SELF\b_spline_volume.w_upper,
       w_multiplicities, w_knots);
  WR4: SIZEOF(u_multiplicities) = knot_u_upper;
  WR5: SIZEOF(v_multiplicities) = knot_v_upper;
  WR6: SIZEOF(w_multiplicities) = knot_w_upper;
END_ENTITY;

ENTITY cartesian_point
  SUPERTYPE OF (ONEOF(cylindrical_point, polar_point, spherical_point))
  SUBTYPE OF (point);
  coordinates : LIST [1:3] OF length_measure;
END_ENTITY;

ENTITY cartesian_transformation_operator
  SUPERTYPE OF (ONEOF(cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))
  SUBTYPE OF (functionally_defined_transformation, geometric_representation_item);
  axis1        : OPTIONAL direction;
  axis2        : OPTIONAL direction;
  local_origin : cartesian_point;
  scale        : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  WR1: scl > 0.0;
END_ENTITY;

ENTITY cartesian_transformation_operator_2d
  SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u : LIST [2:2] OF direction := base_axis(2, SELF\cartesian_transformation_operator.axis1,
                                 SELF\cartesian_transformation_operator.axis2, ?);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY cartesian_transformation_operator_3d
  SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u : LIST [3:3] OF direction := base_axis(3, SELF\cartesian_transformation_operator.axis1,
                                 SELF\cartesian_transformation_operator.axis2, axis3);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY circle
  SUBTYPE OF (conic);
  radius : positive_length_measure;
END_ENTITY;

ENTITY circular_involute
  SUBTYPE OF (curve);
  position    : axis2_placement;
  base_radius : positive_length_measure;
END_ENTITY;

ENTITY clothoid
  SUBTYPE OF (curve);
  position          : axis2_placement;
  clothoid_constant : length_measure;
END_ENTITY;

ENTITY composite_curve
  SUBTYPE OF (bounded_curve);
  segments       : LIST [1:?] OF composite_curve_segment;
  self_intersect : LOGICAL;
DERIVE
  n_segments   : INTEGER := SIZEOF(segments);
  closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
WHERE
  WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 1)) OR
       ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 0));
END_ENTITY;

ENTITY composite_curve_on_surface
  SUPERTYPE OF (boundary_curve)
  SUBTYPE OF (composite_curve);
DERIVE
  basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: SIZEOF(basis_surface) > 0;
  WR2: constraints_composite_curve_on_surface(SELF);
END_ENTITY;

ENTITY composite_curve_segment
  SUBTYPE OF (founded_item);
  transition   : transition_code;
  same_sense   : BOOLEAN;
  parent_curve : curve;
INVERSE
  using_curves : BAG [1:?]OF composite_curve FOR segments;
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY;

ENTITY conic
  SUPERTYPE OF (ONEOF(circle, ellipse, hyperbola, parabola))
  SUBTYPE OF (curve);
  position : axis2_placement;
END_ENTITY;

ENTITY conical_surface
  SUBTYPE OF (elementary_surface);
  radius     : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

ENTITY curve
  SUPERTYPE OF (ONEOF(line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d,
                      offset_curve_3d, curve_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY curve_bounded_surface
  SUBTYPE OF (bounded_surface);
  basis_surface  : surface;
  boundaries     : SET [1:?] OF boundary_curve;
  implicit_outer : BOOLEAN;
WHERE
  WR1: (NOT implicit_outer) OR
       (SIZEOF(QUERY(temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
  WR2: (NOT (implicit_outer)) OR ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
  WR3: SIZEOF(QUERY(temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) <= 1;
  WR4: SIZEOF(QUERY(temp <* boundaries | (temp\composite_curve_on_surface.basis_surface[1] <> SELF.basis_surface))) = 0;
END_ENTITY;

ENTITY curve_replica
  SUBTYPE OF (curve);
  parent_curve   : curve;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_curve.dim;
  WR2: acyclic_curve_replica(SELF, parent_curve);
END_ENTITY;

ENTITY cylindrical_point
  SUBTYPE OF (cartesian_point);
  r     : length_measure;
  theta : plane_angle_measure;
  z     : length_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST [3:3] OF length_measure := [r * COS(theta),r * SIN(theta),z];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY cylindrical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY cylindrical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius   : positive_length_measure;
  height   : positive_length_measure;
END_ENTITY;

ENTITY degenerate_pcurve
  SUBTYPE OF (point);
  basis_surface      : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY degenerate_toroidal_surface
  SUBTYPE OF (toroidal_surface);
  select_outer : BOOLEAN;
WHERE
  WR1: major_radius < minor_radius;
END_ENTITY;

ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST [2:3] OF REAL;
WHERE
  WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;

ENTITY dupin_cyclide_surface
  SUBTYPE OF (elementary_surface);
  generalised_major_radius : positive_length_measure;
  generalised_minor_radius : positive_length_measure;
  skewness                 : length_measure;
WHERE
  WR1: skewness >= 0.0;
END_ENTITY;

ENTITY eccentric_conical_volume
  SUBTYPE OF (volume);
  position    : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height      : positive_length_measure;
  x_offset    : length_measure;
  y_offset    : length_measure;
  ratio       : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY elementary_surface
  SUPERTYPE OF (ONEOF(plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))
  SUBTYPE OF (surface);
  position : axis2_placement_3d;
END_ENTITY;

ENTITY ellipse
  SUBTYPE OF (conic);
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY ellipsoid_volume
  SUBTYPE OF (volume);
  position    : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY evaluated_degenerate_pcurve
  SUBTYPE OF (degenerate_pcurve);
  equivalent_point : cartesian_point;
END_ENTITY;

ENTITY fixed_reference_swept_surface
  SUBTYPE OF (swept_surface);
  directrix       : curve;
  fixed_reference : direction;
END_ENTITY;

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF(point, direction, vector, placement, cartesian_transformation_operator, curve, surface,
                      edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere,
                      right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge,
                      ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume,
                      half_space_solid, shell_based_surface_model, face_based_surface_model,
                      shell_based_wireframe_model, edge_based_wireframe_model, geometric_set, tessellated_item,
                      volume_with_faces, scanned_data_item))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF(
       QUERY(using_rep <* using_representations(SELF) | NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
                                                             TYPEOF(using_rep.context_of_items)))) =
       0;
END_ENTITY;

ENTITY hexahedron_volume
  SUBTYPE OF (volume);
  points : LIST [8:8] OF cartesian_point;
WHERE
  WR1: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR2: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR3: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR4: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR5: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR6: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR7: same_side([points[1],points[2],points[3]], [points[5],points[6],points[7],points[8]]);
  WR8: same_side([points[1],points[4],points[8]], [points[3],points[7],points[6],points[2]]);
  WR9: same_side([points[1],points[2],points[5]], [points[3],points[7],points[8],points[4]]);
  WR10: same_side([points[5],points[6],points[7]], [points[1],points[2],points[3],points[4]]);
  WR11: same_side([points[3],points[7],points[6]], [points[1],points[4],points[8],points[5]]);
  WR12: same_side([points[3],points[7],points[8]], [points[1],points[5],points[6],points[2]]);
  WR13: points[1].dim = 3;
END_ENTITY;

ENTITY hyperbola
  SUBTYPE OF (conic);
  semi_axis      : positive_length_measure;
  semi_imag_axis : positive_length_measure;
END_ENTITY;

ENTITY intersection_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <>
       associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY line
  SUBTYPE OF (curve);
  pnt : cartesian_point;
  dir : vector;
WHERE
  WR1: dir.dim = pnt.dim;
END_ENTITY;

ENTITY locally_refined_spline_curve
  SUBTYPE OF (bounded_curve);
  b_splines                   : LIST [2:?] OF local_b_spline;
  knot_values                 : spline_knot_values;
  control_points_list         : LIST [2:?] OF cartesian_point;
  scaling_factors             : LIST [2:?] OF REAL;
  closed_curve                : LOGICAL;
  locally_refined_spline_type : locally_refined_spline_type_enum;
  self_intersect              : LOGICAL;
  domain                      : LIST [2:2] OF REAL;
WHERE
  WR1: SIZEOF(b_splines) = SIZEOF(control_points_list);
  WR2: SIZEOF(scaling_factors) = SIZEOF(control_points_list);
END_ENTITY;

ENTITY locally_refined_spline_surface
  SUBTYPE OF (bounded_surface);
  u_b_splines                 : LIST [4:?] OF local_b_spline;
  v_b_splines                 : LIST [4:?] OF local_b_spline;
  u_knots                     : spline_knot_values;
  v_knots                     : spline_knot_values;
  control_points_list         : LIST [4:?] OF cartesian_point;
  scaling_factors             : LIST [4:?] OF REAL;
  linearly_independent        : linearly_independent_enum;
  locally_refined_spline_type : locally_refined_spline_type_enum;
  self_intersect              : LOGICAL;
  u_closed                    : LOGICAL;
  v_closed                    : LOGICAL;
  domain                      : LIST [2:2] OF LIST [2:2] OF REAL;
WHERE
  WR1: SIZEOF(u_b_splines) = SIZEOF(control_points_list);
  WR2: SIZEOF(v_b_splines) = SIZEOF(control_points_list);
  WR3: SIZEOF(scaling_factors) = SIZEOF(control_points_list);
  WR4: constraints_scaling(SELF.scaling_factors);
END_ENTITY;

ENTITY locally_refined_spline_volume
  SUBTYPE OF (volume);
  u_b_splines                 : LIST [8:?] OF local_b_spline;
  v_b_splines                 : LIST [8:?] OF local_b_spline;
  w_b_splines                 : LIST [8:?] OF local_b_spline;
  u_knots                     : spline_knot_values;
  v_knots                     : spline_knot_values;
  w_knots                     : spline_knot_values;
  control_points_list         : LIST [8:?] OF cartesian_point;
  scaling_factors             : LIST [8:?] OF REAL;
  linearly_independent        : linearly_independent_enum;
  locally_refined_spline_type : locally_refined_spline_type_enum;
  domain                      : LIST [3:3] OF LIST [2:2] OF REAL;
WHERE
  WR1: SIZEOF(u_b_splines) = SIZEOF(control_points_list);
  WR2: SIZEOF(v_b_splines) = SIZEOF(control_points_list);
  WR3: SIZEOF(w_b_splines) = SIZEOF(control_points_list);
  WR4: SIZEOF(scaling_factors) = SIZEOF(control_points_list);
  WR5: constraints_scaling(SELF.scaling_factors);
END_ENTITY;

ENTITY local_b_spline
  SUBTYPE OF (representation_item);
  degree         : INTEGER;
  knots          : LIST [2:?] OF INTEGER;
  multiplicities : LIST [2:?] OF INTEGER;
WHERE
  WR1: degree > 0;
  WR2: SIZEOF(knots) = SIZEOF(multiplicities);
  WR3: constraints_param_local_b_spline(degree, knots, multiplicities);
END_ENTITY;

ENTITY offset_curve_2d
  SUBTYPE OF (curve);
  basis_curve    : curve;
  distance       : length_measure;
  self_intersect : LOGICAL;
WHERE
  WR1: basis_curve.dim = 2;
END_ENTITY;

ENTITY offset_curve_3d
  SUBTYPE OF (curve);
  basis_curve    : curve;
  distance       : length_measure;
  self_intersect : LOGICAL;
  ref_direction  : direction;
WHERE
  WR1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
END_ENTITY;

ENTITY offset_surface
  SUBTYPE OF (surface);
  basis_surface  : surface;
  distance       : length_measure;
  self_intersect : LOGICAL;
END_ENTITY;

ENTITY oriented_surface
  SUBTYPE OF (surface);
  orientation : BOOLEAN;
END_ENTITY;

ENTITY outer_boundary_curve
  SUBTYPE OF (boundary_curve);
END_ENTITY;

ENTITY parabola
  SUBTYPE OF (conic);
  focal_dist : length_measure;
WHERE
  WR1: focal_dist <> 0.0;
END_ENTITY;

ENTITY pcurve
  SUBTYPE OF (curve);
  basis_surface      : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY placement
  SUPERTYPE OF (ONEOF(axis1_placement, axis2_placement_2d, axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;

ENTITY plane
  SUBTYPE OF (elementary_surface);
END_ENTITY;

ENTITY point
  SUPERTYPE OF (ONEOF(cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica,
                      degenerate_pcurve))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY point_in_volume
  SUBTYPE OF (point);
  basis_volume      : volume;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
  point_parameter_w : parameter_value;
END_ENTITY;

ENTITY point_on_curve
  SUBTYPE OF (point);
  basis_curve     : curve;
  point_parameter : parameter_value;
END_ENTITY;

ENTITY point_on_surface
  SUBTYPE OF (point);
  basis_surface     : surface;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
END_ENTITY;

ENTITY point_replica
  SUBTYPE OF (point);
  parent_pt      : point;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_pt.dim;
  WR2: acyclic_point_replica(SELF, parent_pt);
END_ENTITY;

ENTITY polar_point
  SUBTYPE OF (cartesian_point);
  r     : length_measure;
  theta : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates     : LIST [2:2] OF length_measure := [r * COS(theta),r * SIN(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY polyline
  SUBTYPE OF (bounded_curve);
  points : LIST [2:?] OF cartesian_point;
END_ENTITY;

ENTITY pyramid_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  xlength  : positive_length_measure;
  ylength  : positive_length_measure;
  height   : positive_length_measure;
END_ENTITY;

ENTITY quasi_uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY quasi_uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY quasi_uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY rational_b_spline_curve
  SUBTYPE OF (b_spline_curve);
  weights_data : LIST [2:?] OF REAL;
DERIVE
  weights : ARRAY [0:upper_index_on_control_points] OF REAL := list_to_array(weights_data, 0,
                                                               upper_index_on_control_points);
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.control_points_list);
  WR2: curve_weights_positive(SELF);
END_ENTITY;

ENTITY rational_b_spline_surface
  SUBTYPE OF (b_spline_surface);
  weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
  weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := make_array_of_array(weights_data, 0, u_upper, 0, v_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND
       (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
  WR2: surface_weights_positive(SELF);
END_ENTITY;

ENTITY rational_b_spline_volume
  SUBTYPE OF (b_spline_volume);
  weights_data : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
  weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF ARRAY [0:w_upper] OF REAL := make_array_of_array_of_array(
                                                                                   weights_data, 0, u_upper, 0,
                                                                                   v_upper, 0, w_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_volume.control_points_list)) AND
       (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1])) AND
       (SIZEOF(weights_data[1][1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
  WR2: volume_weights_positive(SELF);
END_ENTITY;

ENTITY rational_locally_refined_spline_curve
  SUBTYPE OF (locally_refined_spline_curve);
  weights_data : LIST [2:?] OF REAL;
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_curve.control_points_list);
  WR2: weights_positive(SELF.weights_data);
END_ENTITY;

ENTITY rational_locally_refined_spline_surface
  SUBTYPE OF (locally_refined_spline_surface);
  weights_data : LIST [4:?] OF REAL;
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_surface.control_points_list);
  WR2: weights_positive(SELF.weights_data);
END_ENTITY;

ENTITY rational_locally_refined_spline_volume
  SUBTYPE OF (locally_refined_spline_volume);
  weights_data : LIST [8:?] OF REAL;
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\locally_refined_spline_volume.control_points_list);
  WR2: weights_positive(SELF.weights_data);
END_ENTITY;

ENTITY rectangular_composite_surface
  SUBTYPE OF (bounded_surface);
  segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
DERIVE
  n_u : INTEGER := SIZEOF(segments);
  n_v : INTEGER := SIZEOF(segments[1]);
WHERE
  WR1: SIZEOF(QUERY(s <* segments | n_v <> SIZEOF(s))) = 0;
  WR2: constraints_rectangular_composite_surface(SELF);
END_ENTITY;

ENTITY rectangular_trimmed_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  u1            : parameter_value;
  u2            : parameter_value;
  v1            : parameter_value;
  v2            : parameter_value;
  usense        : BOOLEAN;
  vsense        : BOOLEAN;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: (('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND
        (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR
       ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR (usense = (u2 > u1));
  WR4: (('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR
        ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR
       (vsense = (v2 > v1));
END_ENTITY;

ENTITY reparametrised_composite_curve_segment
  SUBTYPE OF (composite_curve_segment);
  param_length : parameter_value;
WHERE
  WR1: param_length > 0.0;
END_ENTITY;

ENTITY seam_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) =
       associated_surface(SELF\surface_curve.associated_geometry[2]);
  WR3: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
  WR4: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY spherical_point
  SUBTYPE OF (cartesian_point);
  r     : length_measure;
  theta : plane_angle_measure;
  phi   : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST [3:3] OF length_measure := [r * SIN(theta) * COS(phi),
                                                                      r * SIN(theta) * SIN(phi),
                                                                      r * COS(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY spherical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY spherical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius   : positive_length_measure;
END_ENTITY;

ENTITY surface
  SUPERTYPE OF (ONEOF(elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY surface_curve
  SUPERTYPE OF (ONEOF(intersection_curve, seam_curve) ANDOR bounded_surface_curve)
  SUBTYPE OF (curve);
  curve_3d              : curve;
  associated_geometry   : LIST [1:2] OF pcurve_or_surface;
  master_representation : preferred_surface_curve_representation;
DERIVE
  basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: curve_3d.dim = 3;
  WR2: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation <> pcurve_s1);
  WR3: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation <> pcurve_s2);
  WR4: NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY;

ENTITY surface_curve_swept_surface
  SUBTYPE OF (swept_surface);
  directrix         : curve;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
       (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY surface_of_linear_extrusion
  SUBTYPE OF (swept_surface);
  extrusion_axis : vector;
END_ENTITY;

ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
  axis_position : axis1_placement;
DERIVE
  axis_line : line := representation_item('') || geometric_representation_item() || curve() ||
                      line(axis_position.location,
                           representation_item('') || geometric_representation_item() || vector(axis_position.z, 1.0));
END_ENTITY;

ENTITY surface_patch
  SUBTYPE OF (founded_item);
  parent_surface : bounded_surface;
  u_transition   : transition_code;
  v_transition   : transition_code;
  u_sense        : BOOLEAN;
  v_sense        : BOOLEAN;
INVERSE
  using_surfaces : BAG [1:?]OF rectangular_composite_surface FOR segments;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)));
END_ENTITY;

ENTITY surface_replica
  SUBTYPE OF (surface);
  parent_surface : surface;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_surface_replica(SELF, parent_surface);
END_ENTITY;

ENTITY swept_surface
  SUPERTYPE OF (ONEOF(surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface,
                      fixed_reference_swept_surface))
  SUBTYPE OF (surface);
  swept_curve : curve;
END_ENTITY;

ENTITY tetrahedron_volume
  SUBTYPE OF (volume);
  point_1 : cartesian_point;
  point_2 : cartesian_point;
  point_3 : cartesian_point;
  point_4 : cartesian_point;
WHERE
  WR1: point_1.dim = 3;
  WR2: above_plane(point_1, point_2, point_3, point_4) <> 0.0;
END_ENTITY;

ENTITY toroidal_surface
  SUBTYPE OF (elementary_surface);
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
END_ENTITY;

ENTITY toroidal_volume
  SUBTYPE OF (volume);
  position     : axis2_placement_3d;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: minor_radius < major_radius;
END_ENTITY;

ENTITY trimmed_curve
  SUBTYPE OF (bounded_curve);
  basis_curve           : curve;
  trim_1                : SET [1:2] OF trimming_select;
  trim_2                : SET [1:2] OF trimming_select;
  sense_agreement       : BOOLEAN;
  master_representation : trimming_preference;
WHERE
  WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
  WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
END_ENTITY;

ENTITY uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude   : length_measure;
WHERE
  WR1: magnitude >= 0.0;
END_ENTITY;

ENTITY volume
  SUPERTYPE OF (ONEOF(block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume,
                      toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume,
                      hexahedron_volume, locally_refined_spline_volume))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY wedge_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x        : positive_length_measure;
  y        : positive_length_measure;
  z        : positive_length_measure;
  ltx      : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

FUNCTION above_plane(p1 : cartesian_point;
                     p2 : cartesian_point;
                     p3 : cartesian_point;
                     p4 : cartesian_point) : REAL;
LOCAL
  dir2 : direction := dummy_gri || direction([1.0,0.0,0.0]);
  dir3 : direction := dummy_gri || direction([1.0,0.0,0.0]);
  dir4 : direction := dummy_gri || direction([1.0,0.0,0.0]);
  val  : REAL;
  mag  : REAL;
END_LOCAL;
  IF (p1.dim <> 3)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := 1 TO 3;
    dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
    dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
    dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
    mag := dir4.direction_ratios[i] * dir4.direction_ratios[i];
  END_REPEAT;
  mag := SQRT(mag);
  val := mag * dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);
END_FUNCTION;

FUNCTION acyclic_curve_replica(rep : curve_replica;
                               parent : curve) : BOOLEAN;
  IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(true);
  END_IF;
  IF (parent :=: rep)
  THEN
    RETURN(false);
  ELSE
    RETURN(acyclic_curve_replica(rep, parent\curve_replica.parent_curve));
  END_IF;
END_FUNCTION;

FUNCTION acyclic_point_replica(rep : point_replica;
                               parent : point) : BOOLEAN;
  IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(true);
  END_IF;
  IF (parent :=: rep)
  THEN
    RETURN(false);
  ELSE
    RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
  END_IF;
END_FUNCTION;

FUNCTION acyclic_surface_replica(rep : surface_replica;
                                 parent : surface) : BOOLEAN;
  IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent))
  THEN
    RETURN(true);
  END_IF;
  IF (parent :=: rep)
  THEN
    RETURN(false);
  ELSE
    RETURN(acyclic_surface_replica(rep, parent\surface_replica.parent_surface));
  END_IF;
END_FUNCTION;

FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
LOCAL
  surf : surface;
END_LOCAL;
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg)
  THEN
    surf := arg\pcurve.basis_surface;
  ELSE
    surf := arg;
  END_IF;
  RETURN(surf);
END_FUNCTION;

FUNCTION base_axis(dim : INTEGER;
                   axis1 : direction;
                   axis2 : direction;
                   axis3 : direction) : LIST [2:3] OF direction;
LOCAL
  u      : LIST [2:3] OF direction;
  factor : REAL;
  d1     : direction;
  d2     : direction;
END_LOCAL;
  IF (dim = 3)
  THEN
    d1 := NVL(normalise(axis3), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, axis1);
    u := [d2,second_proj_axis(d1, d2, axis2),d1];
  ELSE
    IF EXISTS(axis1)
    THEN
      d1 := normalise(axis1);
      u := [d1,orthogonal_complement(d1)];
      IF EXISTS(axis2)
      THEN
        factor := dot_product(axis2, u[2]);
        IF (factor < 0.0)
        THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2)
      THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1),d1];
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0,0.0]),dummy_gri || direction([0.0,1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);
END_FUNCTION;

FUNCTION build_2axes(ref_direction : direction) : LIST [2:2] OF direction;
LOCAL
  d : direction := NVL(normalise(ref_direction), dummy_gri || direction([1.0,0.0]));
END_LOCAL;
  RETURN([d,orthogonal_complement(d)]);
END_FUNCTION;

FUNCTION build_axes(axis : direction;
                    ref_direction : direction) : LIST [3:3] OF direction;
LOCAL
  d1 : direction;
  d2 : direction;
END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2,normalise(cross_product(d1, d2))\vector.orientation,d1]);
END_FUNCTION;

FUNCTION check_geometric_dimension(capt : SET [0:?] OF cartesian_point;
                                   dir : SET [0:?] OF direction;
                                   grc : SET [0:?] OF geometric_representation_context) : BOOLEAN;
LOCAL
  globaldim : INTEGER                     := 0;
  reps      : SET [0:?] OF representation := [];
  result    : BOOLEAN                     := true;
END_LOCAL;
  IF (SIZEOF(grc) = 0)
  THEN
    RETURN(false);
  END_IF;
  globaldim := geometric_dimensionalities_in_contexts(grc);
  IF (globaldim > 0)
  THEN
    IF (SIZEOF(capt) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(capt);
        IF (HIINDEX(capt[i].coordinates) <> globaldim)
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
    END_IF;
    IF (SIZEOF(dir) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(dir);
        IF (HIINDEX(dir[i].direction_ratios) <> globaldim)
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN(result);
  ELSE
    IF (SIZEOF(capt) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(capt);
        reps := using_representations(capt[i]);
        IF (SIZEOF(reps) > 0)
        THEN
          REPEAT j := 1 TO HIINDEX(reps);
            IF (HIINDEX(capt[i].coordinates) <>
                reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension)
            THEN
              RETURN(false);
            END_IF;
          END_REPEAT;
        ELSE
          RETURN(false);
        END_IF;
      END_REPEAT;
    END_IF;
    IF (SIZEOF(dir) > 0)
    THEN
      REPEAT i := 1 TO HIINDEX(dir);
        reps := using_representations(dir[i]);
        IF (SIZEOF(reps) > 0)
        THEN
          REPEAT j := 1 TO HIINDEX(reps);
            IF (HIINDEX(dir[i].direction_ratios) <>
                reps[j].context_of_items\geometric_representation_context.coordinate_space_dimension)
            THEN
              RETURN(false);
            END_IF;
          END_REPEAT;
        ELSE
          RETURN(false);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION constraints_composite_curve_on_surface(c : composite_curve_on_surface) : BOOLEAN;
LOCAL
  n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
  REPEAT k := 1 TO n_segments;
    IF (NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
       (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
       (NOT ('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c\composite_curve.segments[k].parent_curve)))
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION constraints_param_b_spline(degree : INTEGER;
                                    up_knots : INTEGER;
                                    up_cp : INTEGER;
                                    knot_mult : LIST [0:?] OF INTEGER;
                                    knots : LIST [0:?] OF parameter_value) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
  k      : INTEGER;
  sum    : INTEGER;
END_LOCAL;
  sum := knot_mult[1];
  REPEAT i := 2 TO up_knots;
    sum := sum + knot_mult[i];
  END_REPEAT;
  IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> (degree + up_cp + 2))
  THEN
    result := false;
    RETURN(result);
  END_IF;
  k := knot_mult[1];
  IF (k < 1) OR (k > degree + 1)
  THEN
    result := false;
    RETURN(result);
  END_IF;
  REPEAT i := 2 TO up_knots;
    IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1])
    THEN
      result := false;
      RETURN(result);
    END_IF;
    k := knot_mult[i];
    IF (i < up_knots) AND (k > degree)
    THEN
      result := false;
      RETURN(result);
    END_IF;
    IF (i = up_knots) AND (k > degree + 1)
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION constraints_param_local_b_spline(degree : INTEGER;
                                          knot_mult : LIST OF INTEGER;
                                          knots : LIST OF INTEGER) : BOOLEAN;
LOCAL
  result   : BOOLEAN := true;
  k        : INTEGER;
  up_knots : INTEGER;
  sum      : INTEGER;
END_LOCAL;
  up_knots := SIZEOF(knots);
  sum := knot_mult[1];
  REPEAT i := 2 TO up_knots;
    sum := sum + knot_mult[i];
  END_REPEAT;
  IF (degree < 1) OR (up_knots < 2) OR (sum <> (degree + 2))
  THEN
    result := false;
    RETURN(result);
  END_IF;
  k := knot_mult[1];
  IF (k < 1) OR (k > degree + 1)
  THEN
    result := false;
    RETURN(result);
  END_IF;
  IF (knots[1] < 1)
  THEN
    result := false;
  END_IF;
  REPEAT i := 2 TO up_knots;
    IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1])
    THEN
      result := false;
      RETURN(result);
    END_IF;
    k := knot_mult[i];
    IF (i < up_knots) AND (k > degree)
    THEN
      result := false;
      RETURN(result);
    END_IF;
    IF (i = up_knots) AND (k > degree + 1)
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION constraints_rectangular_composite_surface(s : rectangular_composite_surface) : BOOLEAN;
  REPEAT i := 1 TO s.n_u;
    REPEAT j := 1 TO s.n_v;
      IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF(s.segments[i][j].parent_surface)) OR
              ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.segments[i][j].parent_surface)))
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT i := 1 TO s.n_u - 1;
    REPEAT j := 1 TO s.n_v;
      IF s.segments[i][j].u_transition = discontinuous
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT i := 1 TO s.n_u;
    REPEAT j := 1 TO s.n_v - 1;
      IF s.segments[i][j].v_transition = discontinuous
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION constraints_scaling(factors : LIST OF REAL) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(factors);
    IF NOT ({0.0 < factors[i] <= 1.0})
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION cross_product(arg1 : direction;
                       arg2 : direction) : vector;
LOCAL
  mag    : REAL;
  res    : direction;
  v1     : LIST [3:3] OF REAL;
  v2     : LIST [3:3] OF REAL;
  result : vector;
END_LOCAL;
  IF (NOT EXISTS(arg1) OR (arg1.dim = 2)) OR (NOT EXISTS(arg2) OR (arg2.dim = 2))
  THEN
    RETURN(?);
  ELSE
    BEGIN  
           v1 := normalise(arg1).direction_ratios;
           v2 := normalise(arg2).direction_ratios;
           res := dummy_gri ||
                  direction([(v1[2] * v2[3] - v1[3] * v2[2]),
                             (v1[3] * v2[1] - v1[1] * v2[3]),
                             (v1[1] * v2[2] - v1[2] * v2[1])]);
           mag := 0.0;
           REPEAT i := 1 TO 3;
             mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
           END_REPEAT;
           IF (mag > 0.0)
           THEN
             result := dummy_gri || vector(res, SQRT(mag));
           ELSE
             result := dummy_gri || vector(arg1, 0.0);
           END_IF;
           RETURN(result);
    END;
  END_IF;
END_FUNCTION;

FUNCTION curve_weights_positive(b : rational_b_spline_curve) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  REPEAT i := 0 TO b.upper_index_on_control_points;
    IF b.weights[i] <= 0.0
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION default_b_spline_curve_weights(up_cp : INTEGER) : ARRAY [0:up_cp] OF REAL;
  RETURN([1:up_cp + 1]);
END_FUNCTION;

FUNCTION default_b_spline_knots(degree : INTEGER;
                                up_knots : INTEGER;
                                uniform : knot_type) : LIST [2:?] OF parameter_value;
LOCAL
  knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
  ishift : INTEGER                              := 1;
END_LOCAL;
  IF (uniform = uniform_knots)
  THEN
    ishift := degree + 1;
  END_IF;
  IF (uniform = uniform_knots) OR (uniform = quasi_uniform_knots) OR (uniform = piecewise_bezier_knots)
  THEN
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);
END_FUNCTION;

FUNCTION default_b_spline_knot_mult(degree : INTEGER;
                                    up_knots : INTEGER;
                                    uniform : knot_type) : LIST [2:?] OF INTEGER;
LOCAL
  knot_mult : LIST [1:up_knots] OF INTEGER;
END_LOCAL;
  IF uniform = uniform_knots
  THEN
    knot_mult := [1:up_knots];
  ELSE
    IF uniform = quasi_uniform_knots
    THEN
      knot_mult := [1:up_knots];
      knot_mult[1] := degree + 1;
      knot_mult[up_knots] := degree + 1;
    ELSE
      IF uniform = piecewise_bezier_knots
      THEN
        knot_mult := [degree:up_knots];
        knot_mult[1] := degree + 1;
        knot_mult[up_knots] := degree + 1;
      ELSE
        knot_mult := [0:up_knots];
      END_IF;
    END_IF;
  END_IF;
  RETURN(knot_mult);
END_FUNCTION;

FUNCTION default_b_spline_surface_weights(u_upper : INTEGER;
                                          v_upper : INTEGER) : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL;
  RETURN([[1:v_upper + 1]:u_upper + 1]);
END_FUNCTION;

FUNCTION dimension_of(item : geometric_representation_item) : dimension_count;
LOCAL
  x   : SET OF representation;
  y   : representation_context;
  dim : dimension_count;
END_LOCAL;
  IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\cartesian_point.coordinates);
    RETURN(dim);
  END_IF;
  IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\direction.direction_ratios);
    RETURN(dim);
  END_IF;
  IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item)
  THEN
    dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
    RETURN(dim);
  END_IF;
  x := using_representations(item);
  IF (SIZEOF(x) > 0)
  THEN
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN(dim);
  ELSE
    RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION dot_product(arg1 : direction;
                     arg2 : direction) : REAL;
LOCAL
  scalar : REAL;
  vec1   : direction;
  vec2   : direction;
  ndim   : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2)
  THEN
    scalar := ?;
  ELSE
    IF (arg1.dim <> arg2.dim)
    THEN
      scalar := ?;
    ELSE
      BEGIN  
             vec1 := normalise(arg1);
             vec2 := normalise(arg2);
             ndim := arg1.dim;
             scalar := 0.0;
             REPEAT i := 1 TO ndim;
               scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
             END_REPEAT;
      END;
    END_IF;
  END_IF;
  RETURN(scalar);
END_FUNCTION;

FUNCTION first_proj_axis(z_axis : direction;
                         arg : direction) : direction;
LOCAL
  x_axis : direction;
  v      : direction;
  z      : direction;
  x_vec  : vector;
END_LOCAL;
  IF (NOT EXISTS(z_axis))
  THEN
    RETURN(?);
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg)
    THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND (z.direction_ratios <> [-1.0,0.0,0.0]))
      THEN
        v := dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF (arg.dim <> 3)
      THEN
        RETURN(?);
      END_IF;
      IF ((cross_product(arg, z).magnitude) = 0.0)
      THEN
        RETURN(?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);
END_FUNCTION;

FUNCTION geometric_dimensionalities_in_contexts(grcs : SET [1:?] OF geometric_representation_context) : INTEGER;
LOCAL
  grcs_1d : INTEGER := 0;
  grcs_2d : INTEGER := 0;
  grcs_3d : INTEGER := 0;
END_LOCAL;
  IF (SIZEOF(grcs) = 1)
  THEN
    RETURN(grcs[1]\geometric_representation_context.coordinate_space_dimension);
  ELSE
    REPEAT i := 1 TO HIINDEX(grcs);
      IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 1)
      THEN
        grcs_1d := grcs_1d + 1;
      ELSE
        IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 2)
        THEN
          grcs_2d := grcs_2d + 1;
        ELSE
          IF (grcs[i]\geometric_representation_context.coordinate_space_dimension = 3)
          THEN
            grcs_3d := grcs_3d + 1;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_IF;
  IF (grcs_1d + grcs_2d = 0)
  THEN
    RETURN(3);
  ELSE
    IF (grcs_1d + grcs_3d = 0)
    THEN
      RETURN(2);
    ELSE
      IF (grcs_2d + grcs_3d = 0)
      THEN
        RETURN(1);
      ELSE
        RETURN(0);
      END_IF;
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION get_basis_surface(c : curve_on_surface) : SET [0:2] OF surface;
LOCAL
  surfs : SET [0:2] OF surface;
  n     : INTEGER;
END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(c)
  THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(c)
    THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
        surfs := surfs + associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)
  THEN
    n := SIZEOF(c\composite_curve.segments);
    surfs := get_basis_surface(c\composite_curve.segments[1].parent_curve);
    IF n > 1
    THEN
      REPEAT i := 2 TO n;
        surfs := surfs * get_basis_surface(c\composite_curve.segments[i].parent_curve);
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(surfs);
END_FUNCTION;

FUNCTION increasing_values_in_list(values : LIST [2:?] OF REAL) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
  limit  : INTEGER := SIZEOF(values);
END_LOCAL;
  REPEAT i := 2 TO limit;
    IF values[i] <= values[i - 1]
    THEN
      result := false;
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION list_to_array(lis : LIST [0:?] OF GENERIC:t;
                       low : INTEGER;
                       u : INTEGER) : ARRAY [low:u] OF GENERIC:t;
LOCAL
  n   : INTEGER;
  res : ARRAY [low:u] OF GENERIC:t;
END_LOCAL;
  n := SIZEOF(lis);
  IF (n <> (u - low + 1))
  THEN
    RETURN(?);
  ELSE
    res := [lis[1]:n];
    REPEAT i := 2 TO n;
      res[low + i - 1] := lis[i];
    END_REPEAT;
    RETURN(res);
  END_IF;
END_FUNCTION;

FUNCTION make_array_of_array(lis : LIST [1:?] OF LIST [1:?] OF GENERIC:t;
                             low1 : INTEGER;
                             u1 : INTEGER;
                             low2 : INTEGER;
                             u2 : INTEGER) : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
LOCAL
  res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC:t;
END_LOCAL;
  IF (u1 - low1 + 1) <> SIZEOF(lis)
  THEN
    RETURN(?);
  END_IF;
  IF (u2 - low2 + 1) <> SIZEOF(lis[1])
  THEN
    RETURN(?);
  END_IF;
  res := [list_to_array(lis[1], low2, u2):(u1 - low1 + 1)];
  REPEAT i := 2 TO HIINDEX(lis);
    IF (u2 - low2 + 1) <> SIZEOF(lis[i])
    THEN
      RETURN(?);
    END_IF;
    res[low1 + i - 1] := list_to_array(lis[i], low2, u2);
  END_REPEAT;
  RETURN(res);
END_FUNCTION;

FUNCTION make_array_of_array_of_array(lis : LIST [1:?] OF LIST [1:?] OF LIST [1:?] OF GENERIC:t;
                                      low1 : INTEGER;
                                      u1 : INTEGER;
                                      low2 : INTEGER;
                                      u2 : INTEGER;
                                      low3 : INTEGER;
                                      u3 : INTEGER) : ARRAY [low1:u1] OF ARRAY [low2:u2] OF ARRAY [low3:u3] OF GENERIC:t;
LOCAL
  res : ARRAY [low1:u1] OF ARRAY [low2:u2] OF ARRAY [low3:u3] OF GENERIC:t;
END_LOCAL;
  IF (u1 - low1 + 1) <> SIZEOF(lis)
  THEN
    RETURN(?);
  END_IF;
  IF (u2 - low2 + 1) <> SIZEOF(lis[1])
  THEN
    RETURN(?);
  END_IF;
  res := [make_array_of_array(lis[1], low2, u2, low3, u3):(u1 - low1 + 1)];
  REPEAT i := 2 TO HIINDEX(lis);
    IF (u2 - low2 + 1) <> SIZEOF(lis[i])
    THEN
      RETURN(?);
    END_IF;
    res[low1 + i - 1] := make_array_of_array(lis[i], low2, u2, low3, u3);
  END_REPEAT;
  RETURN(res);
END_FUNCTION;

FUNCTION normalise(arg : vector_or_direction) : vector_or_direction;
LOCAL
  ndim   : INTEGER;
  v      : direction := dummy_gri || direction([1.0,0.0,0.0]);
  result : vector_or_direction;
  vec    : vector := dummy_gri || vector(v, 1.0);
  mag    : REAL;
END_LOCAL;
  IF NOT EXISTS(arg)
  THEN
    result := ?;
  ELSE
    ndim := arg.dim;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg)
    THEN
      BEGIN  
             v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
             IF arg\vector.magnitude = 0.0
             THEN
               RETURN(?);
             ELSE
               vec := dummy_gri || vector(v, 1.0);
             END_IF;
      END;
    ELSE
      v := dummy_gri || direction(arg.direction_ratios);
    END_IF;
    mag := 0.0;
    REPEAT i := 1 TO ndim;
      mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0
    THEN
      mag := SQRT(mag);
      REPEAT i := 1 TO ndim;
        v.direction_ratios[i] := v.direction_ratios[i] / mag;
      END_REPEAT;
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg)
      THEN
        vec.orientation := v;
        result := vec;
      ELSE
        result := v;
      END_IF;
    ELSE
      RETURN(?);
    END_IF;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION orthogonal_complement(vec : direction) : direction;
LOCAL
  result : direction;
END_LOCAL;
  IF (vec.dim <> 2) OR NOT EXISTS(vec)
  THEN
    RETURN(?);
  ELSE
    result := dummy_gri || direction([-vec.direction_ratios[2],vec.direction_ratios[1]]);
    RETURN(result);
  END_IF;
END_FUNCTION;

FUNCTION same_side(plane_pts : LIST [3:3] OF cartesian_point;
                   test_points : LIST [2:?] OF cartesian_point) : BOOLEAN;
LOCAL
  val1 : REAL;
  val2 : REAL;
  n    : INTEGER;
END_LOCAL;
  IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2)
  THEN
    RETURN(?);
  END_IF;
  n := SIZEOF(test_points);
  val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[1]);
  REPEAT i := 2 TO n;
    val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[i]);
    IF (val1 * val2 <= 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION scalar_times_vector(scalar : REAL;
                             vec : vector_or_direction) : vector;
LOCAL
  v      : direction;
  mag    : REAL;
  result : vector;
END_LOCAL;
  IF NOT EXISTS(scalar) OR NOT EXISTS(vec)
  THEN
    RETURN(?);
  ELSE
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(vec)
    THEN
      v := dummy_gri || direction(vec\vector.orientation.direction_ratios);
      mag := scalar * vec\vector.magnitude;
    ELSE
      v := dummy_gri || direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF (mag < 0.0)
    THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios);
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri || vector(normalise(v), mag);
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION second_proj_axis(z_axis : direction;
                          x_axis : direction;
                          arg : direction) : direction;
LOCAL
  y_axis : vector;
  v      : direction;
  temp   : vector;
END_LOCAL;
  IF NOT EXISTS(arg)
  THEN
    v := dummy_gri || direction([0.0,1.0,0.0]);
  ELSE
    v := arg;
  END_IF;
  temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
  y_axis := vector_difference(v, temp);
  temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
  y_axis := vector_difference(y_axis, temp);
  y_axis := normalise(y_axis);
  RETURN(y_axis.orientation);
END_FUNCTION;

FUNCTION surface_weights_positive(b : rational_b_spline_surface) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  REPEAT i := 0 TO b.u_upper;
    REPEAT j := 0 TO b.v_upper;
      IF (b.weights[i][j] <= 0.0)
      THEN
        result := false;
        RETURN(result);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION vector_difference(arg1 : vector_or_direction;
                           arg2 : vector_or_direction) : vector;
LOCAL
  result : vector;
  res    : direction;
  vec1   : direction;
  vec2   : direction;
  mag    : REAL;
  mag1   : REAL;
  mag2   : REAL;
  ndim   : INTEGER;
END_LOCAL;
  IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim <> arg2.dim)
  THEN
    RETURN(?);
  ELSE
    BEGIN  
           IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1)
           THEN
             mag1 := arg1\vector.magnitude;
             vec1 := arg1\vector.orientation;
           ELSE
             mag1 := 1.0;
             vec1 := arg1;
           END_IF;
           IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2)
           THEN
             mag2 := arg2\vector.magnitude;
             vec2 := arg2\vector.orientation;
           ELSE
             mag2 := 1.0;
             vec2 := arg2;
           END_IF;
           vec1 := normalise(vec1);
           vec2 := normalise(vec2);
           ndim := SIZEOF(vec1.direction_ratios);
           mag := 0.0;
           res := dummy_gri || direction(vec1.direction_ratios);
           REPEAT i := 1 TO ndim;
             res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] - mag2 * vec2.direction_ratios[i];
             mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
           END_REPEAT;
           IF (mag > 0.0)
           THEN
             result := dummy_gri || vector(res, SQRT(mag));
           ELSE
             result := dummy_gri || vector(vec1, 0.0);
           END_IF;
    END;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION vector_sum(arg1 : vector_or_direction;
                    arg2 : vector_or_direction) : vector;
LOCAL
  result : vector;
  res    : direction;
  vec1   : direction;
  vec2   : direction;
  mag    : REAL;
  mag1   : REAL;
  mag2   : REAL;
  ndim   : INTEGER;
END_LOCAL;
  IF ((NOT EXISTS(arg1)) OR (NOT EXISTS(arg2))) OR (arg1.dim <> arg2.dim)
  THEN
    RETURN(?);
  ELSE
    BEGIN  
           IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1)
           THEN
             mag1 := arg1\vector.magnitude;
             vec1 := arg1\vector.orientation;
           ELSE
             mag1 := 1.0;
             vec1 := arg1;
           END_IF;
           IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2)
           THEN
             mag2 := arg2\vector.magnitude;
             vec2 := arg2\vector.orientation;
           ELSE
             mag2 := 1.0;
             vec2 := arg2;
           END_IF;
           vec1 := normalise(vec1);
           vec2 := normalise(vec2);
           ndim := SIZEOF(vec1.direction_ratios);
           mag := 0.0;
           res := dummy_gri || direction(vec1.direction_ratios);
           REPEAT i := 1 TO ndim;
             res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] + mag2 * vec2.direction_ratios[i];
             mag := mag + (res.direction_ratios[i] * res.direction_ratios[i]);
           END_REPEAT;
           IF (mag > 0.0)
           THEN
             result := dummy_gri || vector(res, SQRT(mag));
           ELSE
             result := dummy_gri || vector(vec1, 0.0);
           END_IF;
    END;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION volume_weights_positive(b : rational_b_spline_volume) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  REPEAT i := 0 TO b.u_upper;
    REPEAT j := 0 TO b.v_upper;
      REPEAT k := 0 TO b.w_upper;
        IF (b.weights[i][j][k] <= 0.0)
        THEN
          result := false;
          RETURN(result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION weights_positive(weights : LIST OF REAL) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(weights);
    IF weights[i] <= 0.0
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

RULE compatible_dimension FOR (cartesian_point, direction, geometric_representation_context);
WHERE
  WR1: check_geometric_dimension(cartesian_point, direction, geometric_representation_context);
END_RULE;
END_SCHEMA;


(*
  Id: mim.exp,v 1.8 2006/03/24 18:45:20 thendrix Exp
  ISO TC184/SC4/WG12 N4276 - ISO/TS 10303-1113 Group - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N3246
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA group_mim;
USE FROM group_schema
  (group,
   group_relationship);
USE FROM management_resources_schema
  (group_assignment);
USE FROM basic_attribute_schema
  (id_attribute,
   id_attribute_select);

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
WHERE
  WR1: NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF));
END_TYPE;

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET [1:?] OF groupable_item;
END_ENTITY;
END_SCHEMA;


(*
  Id: group_schema.exp,v 1.13 2014/03/04 00:30:37 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Group schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Group schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA group_schema '{iso standard 10303 part(41) version(7) object(1) group_schema(12)}';
REFERENCE FROM support_resource_schema
  (label,
   bag_to_set,
   identifier,
   text);
REFERENCE FROM basic_attribute_schema
  (get_id_value,
   id_attribute,
   id_attribute_select);

TYPE gs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (group);
END_TYPE;

ENTITY group;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY group_relationship;
  name           : label;
  description    : OPTIONAL text;
  relating_group : group;
  related_group  : group;
END_ENTITY;

FUNCTION acyclic_group_relationship(relation : group_relationship;
                                    relatives : SET [1:?] OF group;
                                    specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF group_relationship;
END_LOCAL;
  IF relation.relating_group IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(grp <* bag_to_set(
                    USEDIN(relation.relating_group,
                    'GROUP_SCHEMA.GROUP_RELATIONSHIP.RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.13 2010/06/09 22:02:45 philsp Exp
  ISO TC184/SC4/WG12 N7115 - ISO/TS 10303-1021 Identification assignment - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N2915
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA identification_assignment_mim;
USE FROM management_resources_schema
  (identification_assignment);

TYPE identification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET [1:?] OF identification_item;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.10 2004/10/22 14:15:40 darla Exp
  ISO TC184/SC4/WG12 N1238 - ISO/TS 10303-1036 Independent property - EXPRESS MIM
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA independent_property_mim;
USE FROM product_property_definition_schema
  (general_property,
   general_property_relationship);
END_SCHEMA;


(*
  Id: mim.exp,v 1.11 2006/05/18 11:42:07 liutkuviene Exp
  ISO TC184/SC4/WG12 N4372 - ISO/TS 10303-1038 Independent property representation - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N1244
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA independent_property_representation_mim;
USE FROM property_assignment_mim;
END_SCHEMA;


(*
  Id: mim.exp,v 1.6 2009/04/22 20:17:39 liutkuviene Exp
  ISO TC184/SC4/WG12 N6238 - ISO/TS 10303-1761 Information product - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4228
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA information_product_mim;
USE FROM product_view_definition_mim;
USE FROM file_identification_mim;
USE FROM product_definition_schema
  (product_related_product_category);
END_SCHEMA;


(*
  Id: iso13584_expressions_schema.exp,v 1.15 2015/06/29 18:57:38 dgnedwards Exp
  ISO 13584-20:1998/Cor.1:2013 Logical model of expressions - EXPRESS
  ISO TC184/SC4/WG12 N8549

  The following permission notice and disclaimer shall be included in all copies of these EXPRESS schemas
  ("the Schema"), and derivations of the Schema:

  Copyright ISO 2013  All rights reserved

  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of
  developing, implementing, installing and using software based on the Schema, and to permit persons to
  whom the Schema is furnished to do so, subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
  LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
  EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN ISO 13584-20:1998/Cor.1:2013, AND SHOULD NOT BE INTERPRETED AS
  COMPLYING WITH THAT STANDARD.

  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                  78 *)
(*  Functions:                  3 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA iso13584_expressions_schema;
REFERENCE FROM iso13584_generic_expressions_schema
  (generic_expression,
   simple_generic_expression,
   generic_variable,
   generic_literal,
   unary_generic_expression,
   binary_generic_expression,
   multiple_arity_generic_expression);

ENTITY abs_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY acos_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY and_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY asin_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY atan_function
  SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY binary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(xor_expression, equals_expression))
  SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

ENTITY binary_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(atan_function))
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY binary_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(minus_expression, div_expression, mod_expression, slash_expression, power_expression,
                               binary_function_call))
  SUBTYPE OF (numeric_expression, binary_generic_expression);
  SELF\binary_generic_expression.operands : LIST [2:2] OF numeric_expression;
END_ENTITY;

ENTITY boolean_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY;

ENTITY boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_boolean_expression, unary_boolean_expression, binary_boolean_expression,
                               multiple_arity_boolean_expression, comparison_expression, interval_expression,
                               boolean_defined_function))
  SUBTYPE OF (expression);
END_ENTITY;

ENTITY boolean_literal
  SUBTYPE OF (simple_boolean_expression, generic_literal);
  the_value : BOOLEAN;
END_ENTITY;

ENTITY boolean_variable
  SUBTYPE OF (simple_boolean_expression, variable);
END_ENTITY;

ENTITY comparison_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_expression
  ABSTRACT SUPERTYPE OF (ONEOF(comparison_equal, comparison_greater, comparison_greater_equal, comparison_less,
                               comparison_less_equal, comparison_not_equal, like_expression))
  SUBTYPE OF (boolean_expression, binary_generic_expression);
  SELF\binary_generic_expression.operands     : LIST [2:2] OF expression;
WHERE
  WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[2]))) OR
       (('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[2]))) OR
       (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND
        ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[2])));
END_ENTITY;

ENTITY comparison_greater
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_not_equal
  SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY concat_expression
  SUBTYPE OF (string_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands                 : LIST [2:?] OF string_expression;
END_ENTITY;

ENTITY cos_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY defined_function
  ABSTRACT SUPERTYPE OF ((ONEOF(numeric_defined_function, string_defined_function, boolean_defined_function)) ANDOR
                         sql_mappable_defined_function);
END_ENTITY;

ENTITY div_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY equals_expression
  SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

ENTITY expression
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_expression, boolean_expression, string_expression))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY exp_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY format_function
  SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
  value_to_format : generic_expression := SELF\binary_generic_expression.operands[1];
  format_string   : generic_expression := SELF\binary_generic_expression.operands[2];
WHERE
  WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION') IN TYPEOF(value_to_format)) AND
       (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION') IN TYPEOF(format_string));
END_ENTITY;

ENTITY index_expression
  SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
  operand : generic_expression := SELF\binary_generic_expression.operands[1];
  index   : generic_expression := SELF\binary_generic_expression.operands[2];
WHERE
  WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(operand)) AND
       ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(index));
  WR2: is_int_expr(index);
END_ENTITY;

ENTITY integer_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (numeric_defined_function);
END_ENTITY;

ENTITY interval_expression
  SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
DERIVE
  interval_low  : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
  interval_item : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
  interval_high : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' IN TYPEOF(interval_low)) AND
       ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' IN TYPEOF(interval_item)) AND
       ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' IN TYPEOF(interval_high));
  WR2: (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND
        ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF.interval_high)) AND
        ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF.interval_item))) OR
       (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_low)) AND
        ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_item)) AND
        ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_high)));
END_ENTITY;

ENTITY int_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value    : INTEGER;
END_ENTITY;

ENTITY int_numeric_variable
  SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY int_value_function
  SUBTYPE OF (value_function);
END_ENTITY;

ENTITY length_function
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand          : string_expression;
END_ENTITY;

ENTITY like_expression
  SUBTYPE OF (comparison_expression);
WHERE
  WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND
       ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

ENTITY literal_number
  ABSTRACT SUPERTYPE OF (ONEOF(int_literal, real_literal))
  SUBTYPE OF (simple_numeric_expression, generic_literal);
  the_value : NUMBER;
END_ENTITY;

ENTITY log10_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log2_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY maximum_function
  SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minimum_function
  SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minus_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY minus_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY mod_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(and_expression, or_expression))
  SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF boolean_expression;
END_ENTITY;

ENTITY multiple_arity_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(maximum_function, minimum_function))
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(plus_expression, mult_expression, multiple_arity_function_call))
  SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF numeric_expression;
END_ENTITY;

ENTITY mult_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY not_expression
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand           : boolean_expression;
END_ENTITY;

ENTITY numeric_defined_function
  ABSTRACT SUPERTYPE OF (ONEOF(integer_defined_function, real_defined_function))
  SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

ENTITY numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_numeric_expression, unary_numeric_expression, binary_numeric_expression,
                               multiple_arity_numeric_expression, length_function, value_function,
                               numeric_defined_function))
  SUBTYPE OF (expression);
DERIVE
  is_int       : BOOLEAN := is_int_expr(SELF);
  sql_mappable : BOOLEAN := is_sql_mappable(SELF);
END_ENTITY;

ENTITY numeric_variable
  SUPERTYPE OF (ONEOF(int_numeric_variable, real_numeric_variable))
  SUBTYPE OF (simple_numeric_expression, variable);
WHERE
  WR1: ('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(SELF)) OR
       ('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(SELF));
END_ENTITY;

ENTITY odd_function
  SUBTYPE OF (unary_boolean_expression);
  SELF\unary_generic_expression.operand             : numeric_expression;
WHERE
  WR1: is_int_expr(operand);
END_ENTITY;

ENTITY or_expression
  SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY plus_expression
  SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY power_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY real_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (numeric_defined_function);
END_ENTITY;

ENTITY real_literal
  SUBTYPE OF (literal_number);
  SELF\literal_number.the_value   : REAL;
END_ENTITY;

ENTITY real_numeric_variable
  SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY simple_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(boolean_literal, boolean_variable))
  SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

ENTITY simple_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(literal_number, numeric_variable))
  SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

ENTITY simple_string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(string_literal, string_variable))
  SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

ENTITY sin_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY slash_expression
  SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY sql_mappable_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function);
END_ENTITY;

ENTITY square_root_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY string_defined_function
  ABSTRACT SUPERTYPE
  SUBTYPE OF (defined_function, string_expression);
END_ENTITY;

ENTITY string_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_string_expression, index_expression, substring_expression, concat_expression,
                               format_function, string_defined_function))
  SUBTYPE OF (expression);
END_ENTITY;

ENTITY string_literal
  SUBTYPE OF (simple_string_expression, generic_literal);
  the_value : STRING;
END_ENTITY;

ENTITY string_variable
  SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

ENTITY substring_expression
  SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
  operand : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
  index1  : generic_expression := SELF\multiple_arity_generic_expression.operands[2];
  index2  : generic_expression := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' IN TYPEOF(operand)) AND
       ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(index1)) AND
       ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' IN TYPEOF(index2));
  WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands) = 3;
  WR3: is_int_expr(index1);
  WR4: is_int_expr(index2);
END_ENTITY;

ENTITY tan_function
  SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY unary_boolean_expression
  ABSTRACT SUPERTYPE OF (ONEOF(not_expression, odd_function))
  SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

ENTITY unary_function_call
  ABSTRACT SUPERTYPE OF (ONEOF(abs_function, minus_function, sin_function, cos_function, tan_function, asin_function,
                               acos_function, exp_function, log_function, log2_function, log10_function,
                               square_root_function))
  SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

ENTITY unary_numeric_expression
  ABSTRACT SUPERTYPE OF (ONEOF(unary_function_call))
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand : numeric_expression;
END_ENTITY;

ENTITY value_function
  SUPERTYPE OF (int_value_function)
  SUBTYPE OF (numeric_expression, unary_generic_expression);
  SELF\unary_generic_expression.operand           : string_expression;
END_ENTITY;

ENTITY variable
  ABSTRACT SUPERTYPE OF (ONEOF(numeric_variable, boolean_variable, string_variable))
  SUBTYPE OF (generic_variable);
END_ENTITY;

ENTITY xor_expression
  SUBTYPE OF (binary_boolean_expression);
  SELF\binary_generic_expression.operands            : LIST [2:2] OF boolean_expression;
END_ENTITY;

FUNCTION is_int_expr(arg : numeric_expression) : BOOLEAN;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_LITERAL' IN TYPEOF(arg)
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg)
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_int_expr(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(false);
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_int_expr(arg\multiple_arity_numeric_expression.operands[i])
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(true);
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_int_expr(arg\binary_numeric_expression.operands[1]) AND
           is_int_expr(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)
  THEN
    IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_VALUE_FUNCTION' IN TYPEOF(arg)
    THEN
      RETURN(true);
    ELSE
      RETURN(false);
    END_IF;
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.INTEGER_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(false);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION is_sql_mappable(arg : expression) : BOOLEAN;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\unary_numeric_expression.operand));
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(false);
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_numeric_expression.operands[i])
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(true);
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_sql_mappable(arg\binary_numeric_expression.operands[1]) AND
           is_sql_mappable(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.NOT_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\unary_generic_expression.operand));
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.ODD_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.XOR_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(false);
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.AND_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.OR_EXPRESSION' IN TYPEOF(arg))
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_boolean_expression.operands);
      IF NOT is_sql_mappable(arg\multiple_arity_boolean_expression.operands[i])
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(true);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\binary_generic_expression.operands[1]) AND
           is_sql_mappable(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EQUAL' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER_EQUAL' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS_EQUAL' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_NOT_EQUAL' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF(arg))
  THEN
    RETURN(is_sql_mappable(arg\comparison_expression.operands[1]) AND
           is_sql_mappable(arg\comparison_expression.operands[2]));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(is_sql_mappable(arg\interval_expression.interval_low) AND
           is_sql_mappable(arg\interval_expression.interval_high) AND
           is_sql_mappable(arg\interval_expression.interval_item));
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_DEFINED_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_STRING_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(true);
  END_IF;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF(arg)) OR
     ('ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN(false);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION used_functions(arg : expression) : SET OF defined_function;
LOCAL
  result : SET OF defined_function := [];
END_LOCAL;
  IF ('ISO13584_EXPRESSIONS_SCHEMA.DEFINED_FUNCTION' IN TYPEOF(arg))
  THEN
    RETURN([arg]);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_NUMERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\unary_numeric_expression.operand));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_NUMERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\binary_numeric_expression.operands[1]) +
           used_functions(arg\binary_numeric_expression.operands[2]));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_numeric_expression.operands);
      result := result + used_functions(arg\multiple_arity_numeric_expression.operands[i]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\unary_generic_expression.operand));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_BOOLEAN_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\binary_generic_expression.operands[1]) +
           used_functions(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' IN TYPEOF(arg)
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_boolean_expression.operands);
      result := result + used_functions(arg\multiple_arity_boolean_expression.operands[i]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\comparison_expression.operands[1]) +
           used_functions(arg\comparison_expression.operands[2]));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\interval_expression.interval_low) +
           used_functions(arg\interval_expression.interval_high) +
           used_functions(arg\interval_expression.interval_item));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\index_expression.operand) + used_functions(arg\index_expression.index));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\substring_expression.operand) + used_functions(arg\substring_expression.index1) +
           used_functions(arg\substring_expression.index2));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF(arg)
  THEN
    REPEAT i := 1 TO SIZEOF(arg\concat_expression.operands);
      result := result + used_functions(arg\concat_expression.operands[i]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\format_function.value_to_format) + used_functions(arg\format_function.format_string));
  END_IF;
  IF 'ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_functions(arg\comparison_expression.operands[1]) +
           used_functions(arg\comparison_expression.operands[2]));
  END_IF;
  RETURN([]);
END_FUNCTION;
END_SCHEMA;


(*
  Id: iso13584_generic_expressions_schema.exp,v 1.8 2015/06/29 18:58:17 dgnedwards Exp
  ISO 13584-20:1998/Cor.1:2013 Logical model of expressions - EXPRESS
  ISO TC184/SC4/WG12 N8550
  The following permission notice and disclaimer shall be included in all copies of these EXPRESS schemas
  ("the Schema"), and derivations of the Schema:

  Copyright ISO 2013  All rights reserved

  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of
  developing, implementing, installing and using software based on the Schema, and to permit persons to
  whom the Schema is furnished to do so, subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
  LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO
  EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
  IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN ISO 13584-20:1998/Cor.1:2013, AND SHOULD NOT BE INTERPRETED AS
  COMPLYING WITH THAT STANDARD.

  *)
(*  Interfaces:                 0 *)
(*  Constants:                  0 *)
(*  Entities:                   9 *)
(*  Functions:                  3 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA iso13584_generic_expressions_schema;


ENTITY binary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST [2:2] OF generic_expression;
END_ENTITY;

ENTITY environment;
  syntactic_representation : generic_variable;
  semantics                : variable_semantics;
END_ENTITY;

ENTITY generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(simple_generic_expression, unary_generic_expression, binary_generic_expression,
                               multiple_arity_generic_expression));
WHERE
  WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY generic_literal
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
END_ENTITY;

ENTITY generic_variable
  ABSTRACT SUPERTYPE
  SUBTYPE OF (simple_generic_expression);
INVERSE
  interpretation : environment FOR syntactic_representation;
END_ENTITY;

ENTITY multiple_arity_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operands : LIST [2:?] OF generic_expression;
END_ENTITY;

ENTITY simple_generic_expression
  ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY unary_generic_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (generic_expression);
  operand : generic_expression;
END_ENTITY;

ENTITY variable_semantics
  ABSTRACT SUPERTYPE;
END_ENTITY;

FUNCTION acyclic(arg1 : generic_expression;
                 arg2 : SET OF generic_expression) : BOOLEAN;
LOCAL
  result : BOOLEAN := true;
END_LOCAL;
  IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.SIMPLE_GENERIC_EXPRESSION' IN TYPEOF(arg1))
  THEN
    RETURN(true);
  END_IF;
  IF arg1 IN arg2
  THEN
    RETURN(false);
  END_IF;
  IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    RETURN(acyclic(arg1\unary_generic_expression.operand, arg2 + [arg1]));
  END_IF;
  IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    RETURN(acyclic(arg1\binary_generic_expression.operands[1], arg2 + [arg1]) AND
           acyclic(arg1\binary_generic_expression.operands[2], arg2 + [arg1]));
  END_IF;
  IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg1)
  THEN
    result := true;
    REPEAT i := 1 TO SIZEOF(arg1\multiple_arity_generic_expression.operands);
      result := result AND acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2 + [arg1]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION is_acyclic(arg : generic_expression) : BOOLEAN;
  RETURN(acyclic(arg, []));
END_FUNCTION;

FUNCTION used_variables(arg : generic_expression) : SET OF generic_variable;
LOCAL
  result : SET OF generic_variable := [];
END_LOCAL;
  IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_VARIABLE' IN TYPEOF(arg)
  THEN
    RETURN([arg]);
  END_IF;
  IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_variables(arg\unary_generic_expression.operand));
  END_IF;
  IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    RETURN(used_variables(arg\binary_generic_expression.operands[1]) +
           used_variables(arg\binary_generic_expression.operands[2]));
  END_IF;
  IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg)
  THEN
    REPEAT i := 1 TO SIZEOF(arg\multiple_arity_generic_expression.operands);
      result := result + used_variables(arg\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  RETURN([]);
END_FUNCTION;
END_SCHEMA;


(*
  Id: location_schema.exp,v 1.17 2014/03/04 00:30:38 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Location schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Location schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA location_schema '{iso standard 10303 part(41) version(4) object(1) location_schema(13)}';
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text,
   bag_to_set);

ENTITY location;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_relationship;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  relating_location : location;
  related_location  : location;
END_ENTITY;

FUNCTION acyclic_location_relationship(relation : location_relationship;
                                       relatives : SET OF location;
                                       specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF location_relationship;
END_LOCAL;
  IF relation.relating_location IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(lctn <* bag_to_set(
                     USEDIN(relation.relating_location,
                     'LOCATION_SCHEMA.LOCATION_RELATIONSHIP.RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: management_resources_schema.exp,v 1.34 2014/03/04 00:30:38 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Management resources schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Management resources schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                17 *)
(*  Constants:                  0 *)
(*  Entities:                  60 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA management_resources_schema '{iso standard 10303 part(41) version(7) object(1) management_resources_schema(14)}';
REFERENCE FROM action_schema;
REFERENCE FROM application_context_schema
  (library_context);
REFERENCE FROM approval_schema;
REFERENCE FROM basic_attribute_schema
  (get_role,
   object_role,
   role_association,
   role_select);
REFERENCE FROM certification_schema;
REFERENCE FROM contract_schema;
REFERENCE FROM date_time_schema;
REFERENCE FROM document_schema;
REFERENCE FROM effectivity_schema;
REFERENCE FROM experience_schema;
REFERENCE FROM external_reference_schema
  (external_source);
REFERENCE FROM group_schema;
REFERENCE FROM location_schema;
REFERENCE FROM person_organization_schema;
REFERENCE FROM qualifications_schema;
REFERENCE FROM security_classification_schema;
REFERENCE FROM support_resource_schema;

TYPE attribute_type = SELECT 
  (label,
   text);
END_TYPE;

TYPE mrs_role_select = SELECT BASED_ON role_select WITH 
  (action_assignment,
   action_request_assignment,
   approval_assignment,
   certification_assignment,
   contract_assignment,
   document_reference,
   effectivity_assignment,
   external_referent_assignment,
   group_assignment,
   name_assignment,
   security_classification_assignment);
END_TYPE;

ENTITY action_assignment
  ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY action_method_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_method : action_method;
  role                   : action_method_role;
END_ENTITY;

ENTITY action_method_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY action_request_assignment
  ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY approval_assignment
  ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY attribute_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class : group;
  attribute_name : label;
  role           : classification_role;
END_ENTITY;

ENTITY attribute_value_assignment
  ABSTRACT SUPERTYPE;
  attribute_name  : label;
  attribute_value : attribute_type;
  role            : attribute_value_role;
END_ENTITY;

ENTITY attribute_value_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY certification_assignment
  ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_class : group;
  role           : classification_role;
END_ENTITY;

ENTITY classification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY contract_assignment
  ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY date_and_time_assignment
  ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role                   : date_time_role;
END_ENTITY;

ENTITY date_assignment
  ABSTRACT SUPERTYPE;
  assigned_date : date;
  role          : date_role;
END_ENTITY;

ENTITY document_reference
  ABSTRACT SUPERTYPE;
  assigned_document : document;
  source            : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY document_usage_constraint_assignment
  ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role                    : document_usage_role;
END_ENTITY;

ENTITY document_usage_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY effectivity_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY effectivity_context_assignment
  ABSTRACT SUPERTYPE;
  assigned_effectivity_assignment : effectivity_assignment;
  role                            : effectivity_context_role;
END_ENTITY;

ENTITY effectivity_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_assignment
  ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role                      : event_occurrence_role;
END_ENTITY;

ENTITY event_occurrence_context_assignment
  ABSTRACT SUPERTYPE;
  assigned_event_occurrence_assignment : event_occurrence_assignment;
  role                                 : event_occurrence_context_role;
END_ENTITY;

ENTITY experience_assignment
  ABSTRACT SUPERTYPE;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  assigned_experience : experience;
  role                : experience_role;
END_ENTITY;

ENTITY experience_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY experience_type_assignment
  ABSTRACT SUPERTYPE;
  id                       : identifier;
  name                     : label;
  description              : OPTIONAL text;
  assigned_experience_type : experience_type;
  role                     : experience_type_role;
END_ENTITY;

ENTITY experience_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY external_identification_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;

ENTITY external_referent_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role(SELF);
UNIQUE
  UR1: assigned_name;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY group_assignment
  ABSTRACT SUPERTYPE;
  assigned_group : group;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY identification_assignment
  ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role        : identification_role;
END_ENTITY;

ENTITY identification_assignment_relationship;
  name                               : label;
  description                        : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment  : identification_assignment;
END_ENTITY;

ENTITY identification_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY library_assignment
  ABSTRACT SUPERTYPE
  SUBTYPE OF (external_referent_assignment);
  frame_of_reference : library_context;
UNIQUE
  UR1: frame_of_reference;
END_ENTITY;

ENTITY location_assignment
  ABSTRACT SUPERTYPE;
  id                : identifier;
  name              : label;
  description       : OPTIONAL text;
  assigned_location : location;
  role              : location_role;
END_ENTITY;

ENTITY location_representation_assignment
  ABSTRACT SUPERTYPE;
  id                   : identifier;
  name                 : label;
  description          : OPTIONAL text;
  represented_location : location;
  role                 : location_representation_role;
END_ENTITY;

ENTITY location_representation_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY location_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY name_assignment
  ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY organizational_project_assignment
  ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role                            : organizational_project_role;
END_ENTITY;

ENTITY organizational_project_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role                  : organization_role;
END_ENTITY;

ENTITY organization_type_assignment
  ABSTRACT SUPERTYPE;
  id                         : identifier;
  name                       : label;
  description                : OPTIONAL text;
  assigned_organization_type : organization_type;
  role                       : organization_type_role;
END_ENTITY;

ENTITY organization_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_and_organization_assignment
  ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role                             : person_and_organization_role;
END_ENTITY;

ENTITY person_assignment
  ABSTRACT SUPERTYPE;
  assigned_person : person;
  role            : person_role;
END_ENTITY;

ENTITY person_type_assignment
  ABSTRACT SUPERTYPE;
  id                   : identifier;
  name                 : label;
  description          : OPTIONAL text;
  assigned_person_type : person_type;
  role                 : person_type_role;
END_ENTITY;

ENTITY person_type_definition_assignment
  ABSTRACT SUPERTYPE;
  id                              : identifier;
  name                            : label;
  description                     : OPTIONAL text;
  assigned_person_type_definition : person_type_definition;
  role                            : person_type_definition_role;
END_ENTITY;

ENTITY person_type_definition_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_assignment
  ABSTRACT SUPERTYPE;
  id                                : identifier;
  name                              : label;
  description                       : OPTIONAL text;
  assigned_position_in_organization : position_in_organization;
  role                              : position_in_organization_role;
END_ENTITY;

ENTITY position_in_organization_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_type_assignment
  ABSTRACT SUPERTYPE;
  id                                     : identifier;
  name                                   : label;
  description                            : OPTIONAL text;
  assigned_position_in_organization_type : position_in_organization_type;
  role                                   : position_in_organization_type_role;
END_ENTITY;

ENTITY position_in_organization_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_assignment
  ABSTRACT SUPERTYPE;
  id                     : identifier;
  name                   : label;
  description            : OPTIONAL text;
  assigned_qualification : qualification;
  role                   : qualification_role;
END_ENTITY;

ENTITY qualification_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_assignment
  ABSTRACT SUPERTYPE;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  assigned_qualification_type : qualification_type;
  role                        : qualification_type_role;
END_ENTITY;

ENTITY qualification_type_role;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY security_classification_assignment
  ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
END_ENTITY;

ENTITY time_assignment
  ABSTRACT SUPERTYPE;
  assigned_time : local_time;
  role          : time_role;
END_ENTITY;

ENTITY time_interval_assignment
  ABSTRACT SUPERTYPE;
  assigned_time_interval : time_interval;
  role                   : time_interval_role;
END_ENTITY;

FUNCTION acyclic_identification_assignment_relationship(relation : identification_assignment_relationship;
                                                        relatives : SET [1:?] OF identification_assignment;
                                                        specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF identification_assignment_relationship;
END_LOCAL;
  IF relation.relating_identification_assignment IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(ia <* bag_to_set(
                   USEDIN(relation.relating_identification_assignment,
                   'MANAGEMENT_RESOURCES_SCHEMA.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN
                                                                                                                              TYPEOF(
                                                                                                                              ia));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_identification_assignment_relationship(x[i],
           relatives + relation.relating_identification_assignment, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: material_property_definition_schema.exp,v 1.4 2014/03/04 00:30:38 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N6751

  EXPRESS Source:
  ISO 10303-45 ed3 Material and other engineering properties - Material property definition schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-45 ed3 Material and other engineering properties - Material property definition schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 6 *)
(*  Constants:                  0 *)
(*  Entities:                   5 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA material_property_definition_schema '{iso standard 10303 part(45) version(3) object(1) material_property_definition_schema(1)}';
REFERENCE FROM material_property_representation_schema
  (material_property_representation);
REFERENCE FROM measure_schema
  (measure_with_unit);
REFERENCE FROM product_definition_schema
  (product_definition_relationship);
REFERENCE FROM product_property_definition_schema
  (characterized_definition,
   property_definition);
REFERENCE FROM qualified_measure_schema
  (maths_value_with_unit);
REFERENCE FROM support_resource_schema
  (label,
   text,
   bag_to_set);

TYPE characterized_material_property = SELECT 
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

TYPE characterized_product_composition_value = SELECT 
  (maths_value_with_unit,
   measure_with_unit);
END_TYPE;

ENTITY material_designation;
  name        : label;
  definitions : SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name        : label;
  description : text;
  designation : material_designation;
  property    : characterized_material_property;
END_ENTITY;

ENTITY material_property
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(
        bag_to_set(
        USEDIN(SELF, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
        QUERY(temp <* bag_to_set(
                      USEDIN(SELF,
                      'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) | ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.MATERIAL_PROPERTY_REPRESENTATION' IN
                                                                                                                  TYPEOF(
                                                                                                                  temp)))) =
        0);
END_ENTITY;

ENTITY product_material_composition_relationship
  SUBTYPE OF (product_definition_relationship);
  class                : label;
  constituent_amount   : SET [1:?] OF characterized_product_composition_value;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

ENTITY property_definition_relationship;
  name                         : label;
  description                  : text;
  relating_property_definition : property_definition;
  related_property_definition  : property_definition;
END_ENTITY;

FUNCTION acyclic_property_definition_relationship(relation : property_definition_relationship;
                                                  relatives : SET [1:?] OF property_definition;
                                                  specific_relation : STRING) : LOGICAL;
LOCAL
  x : SET OF property_definition_relationship;
END_LOCAL;
  IF relation.relating_property_definition IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(pd <* bag_to_set(
                   USEDIN(relation.relating_property_definition,
                   'MATERIAL_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')) | specific_relation IN
                                                                                                                          TYPEOF(
                                                                                                                          pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_property_definition_relationship(x[i], relatives + relation.relating_property_definition,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: material_property_representation_schema.exp,v 1.5 2015/04/22 08:13:06 lothartklein Exp
  ISO 10303 TC184/SC4/WG12 N6751

  EXPRESS Source:
  ISO 10303-45 ed3 Material and other engineering properties - Material property representation schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-45 ed3 Material and other engineering properties - Material property representation schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   4 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA material_property_representation_schema '{iso standard 10303 part(45) version(1) object(1) material_property_representation_schema(2)}';
REFERENCE FROM product_property_representation_schema
  (property_definition_representation);
REFERENCE FROM shape_dimension_schema
  (dimensional_characteristic_representation);
REFERENCE FROM process_property_representation_schema
  (action_property_representation,
   resource_property_representation);
REFERENCE FROM support_resource_schema
  (label,
   text);

TYPE characterized_property_representation = SELECT 
  (action_property_representation,
   dimensional_characteristic_representation,
   property_definition_representation,
   resource_property_representation);
END_TYPE;

ENTITY data_environment;
  name        : label;
  description : text;
  elements    : SET [1:?] OF characterized_property_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                      : label;
  description               : text;
  relating_data_environment : data_environment;
  related_data_environment  : data_environment;
END_ENTITY;

ENTITY material_dimensional_characteristic_representation
  SUBTYPE OF (dimensional_characteristic_representation);
  dependent_environment : data_environment;
END_ENTITY;

ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;
END_SCHEMA;


(*
  Id: mathematical_functions_schema.exp,v 1.23 2014/05/26 12:22:03 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8315

  EXPRESS Source:
  ISO 10303-50 ed1 Mathematical constructs - Mathematical functions schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-50 ed1 Mathematical constructs - Mathematical functions schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 5 *)
(*  Constants:                 27 *)
(*  Entities:                  78 *)
(*  Functions:                148 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                     36 *)

SCHEMA mathematical_functions_schema '{iso standard 10303 part(50) version(3) object(1) mathematical_functions_schema(1)}';
REFERENCE FROM iso13584_generic_expressions_schema
  (binary_generic_expression,
   environment,
   generic_expression,
   generic_literal,
   generic_variable,
   multiple_arity_generic_expression,
   simple_generic_expression,
   unary_generic_expression,
   variable_semantics);
REFERENCE FROM iso13584_expressions_schema
  (abs_function AS abs_expression,
   acos_function AS acos_expression,
   and_expression,
   asin_function AS asin_expression,
   atan_function AS atan_expression,
   binary_boolean_expression,
   binary_function_call AS binary_numeric_call_expression,
   binary_numeric_expression,
   boolean_defined_function AS boolean_defined_expression,
   boolean_expression,
   boolean_literal,
   boolean_variable,
   comparison_equal,
   comparison_expression,
   comparison_greater,
   comparison_greater_equal,
   comparison_less,
   comparison_less_equal,
   comparison_not_equal,
   concat_expression,
   cos_function AS cos_expression,
   defined_function AS defined_expression,
   div_expression,
   equals_expression,
   exp_function AS exp_expression,
   expression,
   format_function AS format_expression,
   index_expression,
   int_literal,
   int_numeric_variable,
   int_value_function AS int_value_expression,
   integer_defined_function AS integer_defined_expression,
   interval_expression,
   length_function AS length_expression,
   like_expression,
   literal_number,
   log_function AS log_expression,
   log10_function AS log10_expression,
   log2_function AS log2_expression,
   maximum_function AS maximum_expression,
   minimum_function AS minimum_expression,
   minus_expression,
   minus_function AS unary_minus_expression,
   mod_expression,
   mult_expression,
   multiple_arity_boolean_expression,
   multiple_arity_function_call AS multiple_arity_numeric_call_expression,
   multiple_arity_numeric_expression,
   not_expression,
   numeric_defined_function AS numeric_defined_expression,
   numeric_expression,
   numeric_variable,
   odd_function AS odd_expression,
   or_expression,
   plus_expression,
   power_expression,
   real_defined_function AS real_defined_expression,
   real_literal,
   real_numeric_variable,
   simple_boolean_expression,
   simple_numeric_expression,
   simple_string_expression,
   sin_function AS sin_expression,
   slash_expression,
   sql_mappable_defined_function AS sql_mappable_defined_expression,
   square_root_function AS square_root_expression,
   string_defined_function AS string_defined_expression,
   string_expression,
   string_literal,
   string_variable,
   substring_expression,
   tan_function AS tan_expression,
   unary_boolean_expression,
   unary_function_call AS unary_numeric_call_expression,
   unary_numeric_expression,
   value_function AS value_expression,
   variable,
   xor_expression);
REFERENCE FROM support_resource_schema
  (label,
   text);
REFERENCE FROM external_reference_schema
  (externally_defined_item);
REFERENCE FROM geometry_schema
  (curve,
   dimension_of,
   point,
   surface,
   volume);
CONSTANT
  schema_prefix                 : STRING                 := 'MATHEMATICAL_FUNCTIONS_SCHEMA.';
  the_binarys                   : elementary_space       := make_elementary_space(es_binarys);
  the_booleans                  : elementary_space       := make_elementary_space(es_booleans);
  the_complex_numbers           : elementary_space       := make_elementary_space(es_complex_numbers);
  the_complex_tuples            : extended_tuple_space   :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_complex_numbers);
  the_empty_atom_based_tuple    : atom_based_tuple       := [];
  the_empty_atom_based_value    : atom_based_value       := the_empty_atom_based_tuple;
  the_empty_maths_tuple         : maths_tuple            := [];
  the_empty_maths_value         : maths_value            := the_empty_maths_tuple;
  the_empty_space               : finite_space           := make_finite_space([]);
  the_generics                  : elementary_space       := make_elementary_space(es_generics);
  the_integers                  : elementary_space       := make_elementary_space(es_integers);
  the_integer_tuples            : extended_tuple_space   :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_integers);
  the_logicals                  : elementary_space       := make_elementary_space(es_logicals);
  the_maths_spaces              : elementary_space       := make_elementary_space(es_maths_spaces);
  the_neg1_one_interval         : finite_real_interval   := make_finite_real_interval(-1.0, closed, 1.0, closed);
  the_neghalfpi_halfpi_interval : finite_real_interval   :=
                                  make_finite_real_interval(-0.5 * PI, closed, 0.5 * PI, closed);
  the_negpi_pi_interval         : finite_real_interval   := make_finite_real_interval(-PI, open, PI, closed);
  the_nonnegative_reals         : real_interval_from_min := make_real_interval_from_min(0.0, closed);
  the_numbers                   : elementary_space       := make_elementary_space(es_numbers);
  the_reals                     : elementary_space       := make_elementary_space(es_reals);
  the_real_tuples               : extended_tuple_space   := make_extended_tuple_space(the_zero_tuple_space, the_reals);
  the_strings                   : elementary_space       := make_elementary_space(es_strings);
  the_tuples                    : extended_tuple_space   :=
                                  make_extended_tuple_space(the_zero_tuple_space, the_generics);
  the_zero_one_interval         : finite_real_interval   := make_finite_real_interval(0.0, closed, 1.0, closed);
  the_zero_pi_interval          : finite_real_interval   := make_finite_real_interval(0.0, closed, PI, closed);
  the_zero_tuple_space          : listed_product_space   := make_listed_product_space([]);
END_CONSTANT;

TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;

TYPE atom_based_value = SELECT 
  (maths_atom,
   atom_based_tuple);
END_TYPE;

TYPE dotted_express_identifier = STRING;
WHERE
  SYNTAX: dotted_identifiers_syntax(SELF);
END_TYPE;

TYPE elementary_function_enumerators = ENUMERATION OF
  (ef_and,
   ef_or,
   ef_not,
   ef_xor,
   ef_negate_i,
   ef_add_i,
   ef_subtract_i,
   ef_multiply_i,
   ef_divide_i,
   ef_mod_i,
   ef_exponentiate_i,
   ef_eq_i,
   ef_ne_i,
   ef_gt_i,
   ef_lt_i,
   ef_ge_i,
   ef_le_i,
   ef_abs_i,
   ef_max_i,
   ef_min_i,
   ef_if_i,
   ef_negate_r,
   ef_reciprocal_r,
   ef_add_r,
   ef_subtract_r,
   ef_multiply_r,
   ef_divide_r,
   ef_mod_r,
   ef_exponentiate_r,
   ef_exponentiate_ri,
   ef_eq_r,
   ef_ne_r,
   ef_gt_r,
   ef_lt_r,
   ef_ge_r,
   ef_le_r,
   ef_abs_r,
   ef_max_r,
   ef_min_r,
   ef_acos_r,
   ef_asin_r,
   ef_atan2_r,
   ef_cos_r,
   ef_exp_r,
   ef_ln_r,
   ef_log2_r,
   ef_log10_r,
   ef_sin_r,
   ef_sqrt_r,
   ef_tan_r,
   ef_if_r,
   ef_form_c,
   ef_rpart_c,
   ef_ipart_c,
   ef_negate_c,
   ef_reciprocal_c,
   ef_add_c,
   ef_subtract_c,
   ef_multiply_c,
   ef_divide_c,
   ef_exponentiate_c,
   ef_exponentiate_ci,
   ef_eq_c,
   ef_ne_c,
   ef_conjugate_c,
   ef_abs_c,
   ef_arg_c,
   ef_cos_c,
   ef_exp_c,
   ef_ln_c,
   ef_sin_c,
   ef_sqrt_c,
   ef_tan_c,
   ef_if_c,
   ef_subscript_s,
   ef_eq_s,
   ef_ne_s,
   ef_gt_s,
   ef_lt_s,
   ef_ge_s,
   ef_le_s,
   ef_subsequence_s,
   ef_concat_s,
   ef_size_s,
   ef_format,
   ef_value,
   ef_like,
   ef_if_s,
   ef_subscript_b,
   ef_eq_b,
   ef_ne_b,
   ef_gt_b,
   ef_lt_b,
   ef_ge_b,
   ef_le_b,
   ef_subsequence_b,
   ef_concat_b,
   ef_size_b,
   ef_if_b,
   ef_subscript_t,
   ef_eq_t,
   ef_ne_t,
   ef_concat_t,
   ef_size_t,
   ef_entuple,
   ef_detuple,
   ef_insert,
   ef_remove,
   ef_if_t,
   ef_sum_it,
   ef_product_it,
   ef_add_it,
   ef_subtract_it,
   ef_scalar_mult_it,
   ef_dot_prod_it,
   ef_sum_rt,
   ef_product_rt,
   ef_add_rt,
   ef_subtract_rt,
   ef_scalar_mult_rt,
   ef_dot_prod_rt,
   ef_norm_rt,
   ef_sum_ct,
   ef_product_ct,
   ef_add_ct,
   ef_subtract_ct,
   ef_scalar_mult_ct,
   ef_dot_prod_ct,
   ef_norm_ct,
   ef_if,
   ef_ensemble,
   ef_member_of);
END_TYPE;

TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;

TYPE express_identifier = dotted_express_identifier;
WHERE
  SYNTAX: dot_count(SELF) = 0;
END_TYPE;

TYPE extension_options = ENUMERATION OF
  (eo_none,
   eo_cont,
   eo_cont_right,
   eo_cont_left);
END_TYPE;

TYPE input_selector = positive_integer;
END_TYPE;

TYPE lower_upper = ENUMERATION OF
  (lower,
   upper);
END_TYPE;

TYPE maths_atom = SELECT 
  (maths_simple_atom,
   maths_enum_atom);
END_TYPE;

TYPE maths_binary = BINARY;
END_TYPE;

TYPE maths_boolean = BOOLEAN;
END_TYPE;

TYPE maths_enum_atom = SELECT 
  (elementary_space_enumerators,
   ordering_type,
   lower_upper,
   symmetry_type,
   elementary_function_enumerators,
   open_closed,
   space_constraint_type,
   repackage_options,
   extension_options);
END_TYPE;

TYPE maths_expression = SELECT 
  (atom_based_value,
   maths_tuple,
   generic_expression);
END_TYPE;

TYPE maths_function_select = SELECT 
  (maths_function,
   elementary_function_enumerators);
END_TYPE;

TYPE maths_integer = INTEGER;
END_TYPE;

TYPE maths_logical = LOGICAL;
END_TYPE;

TYPE maths_number = NUMBER;
END_TYPE;

TYPE maths_real = REAL;
END_TYPE;

TYPE maths_simple_atom = SELECT 
  (maths_number,
   maths_real,
   maths_integer,
   maths_logical,
   maths_boolean,
   maths_string,
   maths_binary);
END_TYPE;

TYPE maths_space_or_function = SELECT 
  (maths_space,
   maths_function);
END_TYPE;

TYPE maths_string = STRING;
END_TYPE;

TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;

TYPE maths_value = SELECT 
  (atom_based_value,
   maths_tuple,
   generic_expression);
WHERE
  CONSTANCY: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR expression_is_constant(SELF);
END_TYPE;

TYPE nonnegative_integer = INTEGER;
WHERE
  NONNEGATIVITY: SELF >= 0;
END_TYPE;

TYPE one_or_two = positive_integer;
WHERE
  IN_RANGE: (SELF = 1) OR (SELF = 2);
END_TYPE;

TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;

TYPE ordering_type = ENUMERATION OF
  (by_rows,
   by_columns);
END_TYPE;

TYPE positive_integer = nonnegative_integer;
WHERE
  POSITIVITY: SELF > 0;
END_TYPE;

TYPE product_space = SELECT 
  (uniform_product_space,
   listed_product_space);
END_TYPE;

TYPE real_interval = SELECT 
  (real_interval_from_min,
   real_interval_to_max,
   finite_real_interval,
   elementary_space);
WHERE
  WR1: NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR (SELF\elementary_space.space_id = es_reals);
END_TYPE;

TYPE repackage_options = ENUMERATION OF
  (ro_nochange,
   ro_wrap_as_tuple,
   ro_unwrap_tuple);
END_TYPE;

TYPE space_constraint_type = ENUMERATION OF
  (sc_equal,
   sc_subspace,
   sc_member);
END_TYPE;

TYPE symmetry_type = ENUMERATION OF
  (identity,
   skew,
   hermitian,
   skew_hermitian);
END_TYPE;

TYPE tuple_space = EXTENSIBLE GENERIC_ENTITY SELECT 
  (product_space,
   extended_tuple_space);
END_TYPE;

TYPE zero_or_one = nonnegative_integer;
WHERE
  IN_RANGE: (SELF = 0) OR (SELF = 1);
END_TYPE;

ENTITY abstracted_expression_function
  SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
  SELF\quantifier_expression.variables : LIST [1:?] OF UNIQUE generic_variable := remove_first(
                                                                                  SELF\multiple_arity_generic_expression
                                                                                      .operands);
  expr                                 : generic_expression                    := SELF\multiple_arity_generic_expression
                                                                                      .operands[1];
WHERE
  WR1: SIZEOF(QUERY(operand <* SELF\multiple_arity_generic_expression.operands | NOT (has_values_space(operand)))) = 0;
END_ENTITY;

ENTITY application_defined_function
  SUBTYPE OF (maths_function);
  explicit_domain : tuple_space;
  explicit_range  : tuple_space;
  parameters      : LIST OF maths_value;
WHERE
  WR1: expression_is_constant(explicit_domain);
  WR2: expression_is_constant(explicit_range);
END_ENTITY;

ENTITY atom_based_literal
  SUBTYPE OF (generic_literal);
  lit_value : atom_based_value;
END_ENTITY;

ENTITY banded_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  below         : INTEGER;
  above         : INTEGER;
  order         : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: -below <= above;
  WR3: member_of(default_entry, factor1(SELF\linearized_table_function.source.range));
END_ENTITY;

ENTITY basic_sparse_matrix
  SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands               : LIST [3:3] OF maths_function;
  default_entry                                   : maths_value;
  order                                           : ordering_type;
DERIVE
  index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
  loc   : maths_function := SELF\multiple_arity_generic_expression.operands[2];
  val   : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: function_is_1d_table(index);
  WR2: function_is_1d_table(loc);
  WR3: function_is_1d_table(val);
  WR4: check_sparse_index_domain(index.domain, index_base, shape, order);
  WR5: check_sparse_index_to_loc(index.range, loc.domain);
  WR6: loc.domain = val.domain;
  WR7: check_sparse_loc_range(loc.range, index_base, shape, order);
  WR8: member_of(default_entry, val.range);
END_ENTITY;

ENTITY binary_literal
  SUBTYPE OF (generic_literal);
  lit_value : BINARY;
END_ENTITY;

ENTITY bound_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

ENTITY b_spline_basis
  SUBTYPE OF (maths_function, generic_literal);
  degree         : nonnegative_integer;
  repeated_knots : LIST [2:?] OF REAL;
DERIVE
  order     : positive_integer := degree + 1;
  num_basis : positive_integer := SIZEOF(repeated_knots) - order;
WHERE
  WR1: num_basis >= order;
  WR2: nondecreasing(repeated_knots);
  WR3: repeated_knots[order] < repeated_knots[num_basis + 1];
END_ENTITY;

ENTITY b_spline_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand        : maths_function;
  basis                                 : LIST [1:?] OF b_spline_basis;
DERIVE
  coef : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_table(coef);
  WR2: (space_dimension(coef.range) = 1) AND (number_superspace_of(factor1(coef.range)) = the_reals);
  WR3: SIZEOF(basis) <= SIZEOF(shape_of_array(coef));
  WR4: compare_basis_and_coef(basis, coef);
END_ENTITY;

ENTITY cartesian_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  real_constraint : real_interval;
  imag_constraint : real_interval;
WHERE
  WR1: min_exists(real_constraint) OR max_exists(real_constraint) OR min_exists(imag_constraint) OR
       max_exists(imag_constraint);
END_ENTITY;

ENTITY complex_number_literal
  SUBTYPE OF (generic_literal);
  real_part : REAL;
  imag_part : REAL;
END_ENTITY;

ENTITY complex_number_literal_polar
  SUBTYPE OF (complex_number_literal);
  modulus  : REAL;
  argument : REAL;
DERIVE
  SELF\complex_number_literal.real_part : REAL := modulus * COS(argument);
  SELF\complex_number_literal.imag_part : REAL := modulus * SIN(argument);
WHERE
  WR1: modulus >= 0;
  WR2: {0 <= argument <= 2 * PI};
END_ENTITY;

ENTITY constant_function
  SUBTYPE OF (maths_function, generic_literal);
  sole_output      : maths_value;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;

ENTITY definite_integral_expression
  SUBTYPE OF (quantifier_expression);
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand                            : generic_expression                    := SELF\multiple_arity_generic_expression
                                                                                      .operands[1];
  variable_of_integration              : maths_variable                        := SELF\multiple_arity_generic_expression
                                                                                      .operands[2];
  SELF\quantifier_expression.variables : LIST [1:1] OF UNIQUE generic_variable := [variable_of_integration];
WHERE
  WR1: has_values_space(integrand);
  WR2: space_is_continuum(values_space_of(integrand));
  WR3: definite_integral_expr_check(SELF\multiple_arity_generic_expression.operands, lower_limit_neg_infinity,
       upper_limit_pos_infinity);
END_ENTITY;

ENTITY definite_integral_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  variable_of_integration               : input_selector;
  lower_limit_neg_infinity              : BOOLEAN;
  upper_limit_pos_infinity              : BOOLEAN;
DERIVE
  integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum(integrand.range);
  WR2: definite_integral_check(integrand.domain, variable_of_integration, lower_limit_neg_infinity,
       upper_limit_pos_infinity);
END_ENTITY;

ENTITY dependent_variable_definition
  SUBTYPE OF (unary_generic_expression);
  name        : label;
  description : text;
END_ENTITY;

ENTITY elementary_function
  SUBTYPE OF (maths_function, generic_literal);
  func_id : elementary_function_enumerators;
END_ENTITY;

ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;

ENTITY explicit_table_function
  ABSTRACT SUPERTYPE OF (ONEOF(listed_real_data, listed_integer_data, listed_logical_data, listed_string_data,
                               listed_complex_number_data, listed_data, externally_listed_data,
                               linearized_table_function, basic_sparse_matrix))
  SUBTYPE OF (maths_function);
  index_base : zero_or_one;
  shape      : LIST [1:?] OF positive_integer;
END_ENTITY;

ENTITY expression_denoted_function
  SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
  expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF(values_space_of(expr));
END_ENTITY;

ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : tuple_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;

ENTITY externally_listed_data
  SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
  value_range : maths_space;
WHERE
  WR1: expression_is_constant(value_range);
END_ENTITY;

ENTITY finite_function
  SUBTYPE OF (maths_function, generic_literal);
  pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;

ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
  max : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;

ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;

ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF(
       QUERY(expr <* QUERY(member <* members | 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN
                                               TYPEOF(member)) | NOT expression_is_constant(expr))) =
       0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;

ENTITY free_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

ENTITY function_application
  SUBTYPE OF (multiple_arity_generic_expression);
  func      : maths_function_select;
  arguments : LIST [1:?] OF maths_expression;
DERIVE
  SELF\multiple_arity_generic_expression.operands              : LIST [2:?] OF generic_expression := [convert_to_maths_function(
                                                                                                      func)] +
                                                                                                     convert_to_operands(
                                                                                                     arguments);
WHERE
  WR1: function_applicability(func, arguments);
END_ENTITY;

ENTITY function_space
  SUBTYPE OF (maths_space, generic_literal);
  domain_constraint : space_constraint_type;
  domain_argument   : maths_space;
  range_constraint  : space_constraint_type;
  range_argument    : maths_space;
WHERE
  WR1: expression_is_constant(domain_argument) AND expression_is_constant(range_argument);
  WR2: (domain_argument <> the_empty_space) AND (range_argument <> the_empty_space);
  WR3: (domain_constraint <> sc_member) OR NOT member_of(the_empty_space, domain_argument);
  WR4: (range_constraint <> sc_member) OR NOT member_of(the_empty_space, range_argument);
  WR5: NOT (any_space_satisfies(domain_constraint, domain_argument) AND
            any_space_satisfies(range_constraint, range_argument));
END_ENTITY;

ENTITY general_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand  : maths_function;
  sum_index                             : one_or_two;
DERIVE
  mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY;

ENTITY homogeneous_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index                             : one_or_two;
DERIVE
  mat : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY;

ENTITY imported_curve_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : curve;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

ENTITY imported_point_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry : point;
END_ENTITY;

ENTITY imported_surface_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : surface;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

ENTITY imported_volume_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : volume;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;

ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;

ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;

ENTITY integer_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF INTEGER;
END_ENTITY;

ENTITY linearized_table_function
  SUPERTYPE OF (ONEOF(standard_table_function, regular_table_function, triangular_matrix, symmetric_matrix,
                      banded_matrix))
  SUBTYPE OF (explicit_table_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  first                                 : INTEGER;
DERIVE
  source : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_1d_array(source);
  WR2: member_of(first, source\maths_function.domain);
END_ENTITY;

ENTITY listed_complex_number_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [2:?] OF REAL;
DERIVE
  SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [SIZEOF(values) DIV 2];
WHERE
  WR1: NOT ODD(SIZEOF(values));
END_ENTITY;

ENTITY listed_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values      : LIST [1:?] OF maths_value;
  value_range : maths_space;
DERIVE
  SELF\explicit_table_function.shape             : LIST [1:?] OF positive_integer := [SIZEOF(values)];
WHERE
  WR1: expression_is_constant(value_range);
  WR2: SIZEOF(QUERY(val <* values | NOT (member_of(val, value_range)))) = 0;
END_ENTITY;

ENTITY listed_integer_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF INTEGER;
DERIVE
  SELF\explicit_table_function.shape     : LIST [1:?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY listed_logical_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF LOGICAL;
DERIVE
  SELF\explicit_table_function.shape     : LIST [1:?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF(QUERY(space <* factors | NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;

ENTITY listed_real_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF REAL;
DERIVE
  SELF\explicit_table_function.shape        : LIST [1:?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY listed_string_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF STRING;
DERIVE
  SELF\explicit_table_function.shape      : LIST [1:?] OF positive_integer := [SIZEOF(values)];
END_ENTITY;

ENTITY logical_literal
  SUBTYPE OF (generic_literal);
  lit_value : LOGICAL;
END_ENTITY;

ENTITY mathematical_description;
  described  : maths_expression;
  describing : STRING;
  encoding   : label;
END_ENTITY;

ENTITY maths_boolean_variable
  SUBTYPE OF (maths_variable, boolean_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_booleans);
END_ENTITY;

ENTITY maths_enum_literal
  SUBTYPE OF (generic_literal);
  lit_value : maths_enum_atom;
END_ENTITY;

ENTITY maths_function
  ABSTRACT SUPERTYPE OF (ONEOF(finite_function, constant_function, selector_function, elementary_function,
                               restriction_function, repackaging_function, reindexed_array_function,
                               series_composed_function, parallel_composed_function, explicit_table_function,
                               homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function,
                               rationalize_function, partial_derivative_function, definite_integral_function,
                               abstracted_expression_function, expression_denoted_function, imported_point_function,
                               imported_curve_function, imported_surface_function, imported_volume_function,
                               application_defined_function))
  SUBTYPE OF (generic_expression);
DERIVE
  domain : tuple_space := derive_function_domain(SELF);
  range  : tuple_space := derive_function_range(SELF);
END_ENTITY;

ENTITY maths_integer_variable
  SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_integers);
END_ENTITY;

ENTITY maths_real_variable
  SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_reals);
END_ENTITY;

ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF(elementary_space, finite_integer_interval, integer_interval_from_min,
                               integer_interval_to_max, finite_real_interval, real_interval_from_min,
                               real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region,
                               finite_space, uniform_product_space, listed_product_space, extended_tuple_space,
                               function_space))
  SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY maths_string_variable
  SUBTYPE OF (maths_variable, string_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space, es_strings);
END_ENTITY;

ENTITY maths_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST OF maths_value;
END_ENTITY;

ENTITY maths_variable
  SUBTYPE OF (generic_variable);
  values_space : maths_space;
  name         : label;
WHERE
  WR1: expression_is_constant(values_space);
END_ENTITY;

ENTITY parallel_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  source_of_domain : maths_space_or_function;
  prep_functions   : LIST [1:?] OF maths_function;
  final_function   : maths_function_select;
DERIVE
  SELF\multiple_arity_generic_expression.operands        : LIST [2:?] OF generic_expression := convert_to_operands_prcmfn(
                                                                                               source_of_domain,
                                                                                               prep_functions,
                                                                                               final_function);
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
  WR3: parallel_composed_function_domain_check(domain_from(source_of_domain), prep_functions);
  WR4: parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;

ENTITY partial_derivative_expression
  SUBTYPE OF (unary_generic_expression);
  d_variables : LIST [1:?] OF maths_variable;
  extension   : extension_options;
DERIVE
  derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: has_values_space(derivand);
  WR2: space_is_continuum(values_space_of(derivand));
  WR3: SIZEOF(
       QUERY(vbl <* d_variables | (NOT subspace_of(values_space_of(vbl), the_reals)) AND
                                  (NOT subspace_of(values_space_of(vbl), the_complex_numbers)))) =
       0;
END_ENTITY;

ENTITY partial_derivative_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  d_variables                           : LIST [1:?] OF input_selector;
  extension                             : extension_options;
DERIVE
  derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum(derivand.range);
  WR2: partial_derivative_check(derivand.domain, d_variables);
END_ENTITY;

ENTITY polar_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  centre               : complex_number_literal;
  distance_constraint  : real_interval;
  direction_constraint : finite_real_interval;
WHERE
  WR1: min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
  WR2: {-PI <= direction_constraint.min < PI};
  WR3: direction_constraint.max - direction_constraint.min <= 2.0 * PI;
  WR4: (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.min_closure = open);
  WR5: (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
  WR6: (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0 * PI) OR (direction_constraint.max_closure = open);
END_ENTITY;

ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1:?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF(QUERY(vrbl <* variables | NOT (vrbl IN SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF(
       QUERY(vrbl <* variables | NOT ((schema_prefix + 'BOUND_VARIABLE_SEMANTICS') IN
                                      TYPEOF(vrbl.interpretation.semantics)))) =
       0;
END_ENTITY;

ENTITY rationalize_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand     : maths_function;
DERIVE
  fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
  WR2: number_tuple_subspace_check(factor1(fun.range));
  WR3: space_dimension(factor1(fun.range)) > 1;
END_ENTITY;

ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;

ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;

ENTITY real_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF REAL;
END_ENTITY;

ENTITY regular_table_function
  SUBTYPE OF (linearized_table_function);
  increments : LIST [1:?] OF INTEGER;
WHERE
  WR1: SIZEOF(increments) = SIZEOF(SELF\explicit_table_function.shape);
  WR2: extremal_position_check(SELF);
END_ENTITY;

ENTITY reindexed_array_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  starting_indices                      : LIST [1:?] OF INTEGER;
WHERE
  WR1: function_is_array(SELF\unary_generic_expression.operand);
  WR2: SIZEOF(starting_indices) = SIZEOF(shape_of_array(SELF\unary_generic_expression.operand));
END_ENTITY;

ENTITY repackaging_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand     : maths_function;
  input_repack                          : repackage_options;
  output_repack                         : repackage_options;
  selected_output                       : nonnegative_integer;
WHERE
  WR1: (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(operand.domain))));
  WR2: (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(operand.range))));
  WR3: selected_output <= space_dimension(repackage(operand.range, output_repack));
END_ENTITY;

ENTITY restriction_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand     : maths_space;
END_ENTITY;

ENTITY selector_function
  SUBTYPE OF (maths_function, generic_literal);
  selector         : input_selector;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;

ENTITY series_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands          : LIST [2:?] OF maths_function;
WHERE
  WR1: composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;

ENTITY standard_table_function
  SUBTYPE OF (linearized_table_function);
  order : ordering_type;
WHERE
  WR1: extremal_position_check(SELF);
END_ENTITY;

ENTITY strict_triangular_matrix
  SUBTYPE OF (triangular_matrix);
  main_diagonal_value : maths_value;
END_ENTITY;

ENTITY symmetric_banded_matrix
  SUBTYPE OF (symmetric_matrix);
  default_entry : maths_value;
  above         : nonnegative_integer;
WHERE
  WR1: member_of(default_entry, factor1(SELF\linearized_table_function.source.range));
END_ENTITY;

ENTITY symmetric_matrix
  SUBTYPE OF (linearized_table_function);
  symmetry : symmetry_type;
  triangle : lower_upper;
  order    : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: SELF\explicit_table_function.shape[1] = SELF\explicit_table_function.shape[2];
  WR3: NOT (symmetry = symmetry_type.skew) OR
           ((space_dimension(SELF\linearized_table_function.source.range) = 1) AND
            subspace_of_es(factor1(SELF\linearized_table_function.source.range), es_numbers));
  WR4: NOT ((symmetry = symmetry_type.hermitian) OR (symmetry = symmetry_type.skew_hermitian)) OR
           ((space_dimension(SELF\linearized_table_function.source.range) = 1) AND
            subspace_of_es(factor1(SELF\linearized_table_function.source.range), es_complex_numbers));
END_ENTITY;

ENTITY triangular_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  lo_up         : lower_upper;
  order         : ordering_type;
WHERE
  WR1: SIZEOF(SELF\explicit_table_function.shape) = 2;
  WR2: member_of(default_entry, SELF\maths_function.range);
END_ENTITY;

ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;

FUNCTION all_members_of_es(sv : SET OF maths_value;
                           es : elementary_space_enumerators) : LOGICAL;

CONSTANT
  base_types : SET OF STRING :=
               ['NUMBER',
                'COMPLEX_NUMBER_LITERAL',
                'REAL',
                'INTEGER',
                'LOGICAL',
                'BOOLEAN',
                'STRING',
                'BINARY',
                'MATHS_SPACE',
                'MATHS_FUNCTION',
                'LIST',
                'ELEMENTARY_SPACE_ENUMERATORS',
                'ORDERING_TYPE',
                'LOWER_UPPER',
                'SYMMETRY_TYPE',
                'ELEMENTARY_FUNCTION_ENUMERATORS',
                'OPEN_CLOSED',
                'SPACE_CONSTRAINT_TYPE',
                'REPACKAGE_OPTIONS',
                'EXTENSION_OPTIONS'];
END_CONSTANT;
LOCAL
  v        : maths_value;
  key_type : STRING             := '';
  types    : SET OF STRING;
  ge       : generic_expression;
  cum      : LOGICAL            := true;
  vspc     : maths_space;
END_LOCAL;
  IF NOT EXISTS(sv) OR NOT EXISTS(es)
  THEN
    RETURN(false);
  END_IF;
  CASE es OF
    es_numbers : key_type := 'NUMBER';
    es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
    es_reals : key_type := 'REAL';
    es_integers : key_type := 'INTEGER';
    es_logicals : key_type := 'LOGICAL';
    es_booleans : key_type := 'BOOLEAN';
    es_strings : key_type := 'STRING';
    es_binarys : key_type := 'BINARY';
    es_maths_spaces : key_type := 'MATHS_SPACE';
    es_maths_functions : key_type := 'MATHS_FUNCTION';
    es_generics : RETURN(true);
  END_CASE;
  REPEAT i := 1 TO SIZEOF(sv);
    IF NOT EXISTS(sv[i])
    THEN
      RETURN(false);
    END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types
    THEN
      SKIP;
    END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types)
    THEN
      SKIP;
    END_IF;
    IF SIZEOF(base_types * types) > 0
    THEN
      RETURN(false);
    END_IF;
    ge := v;
    IF has_values_space(ge)
    THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc, es)
      THEN
        IF NOT compatible_spaces(vspc, make_elementary_space(es))
        THEN
          RETURN(false);
        END_IF;
        cum := unknown;
      END_IF;
    ELSE
      cum := unknown;
    END_IF;
    IF cum = false
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(cum);
END_FUNCTION;

FUNCTION any_space_satisfies(sc : space_constraint_type;
                             spc : maths_space) : BOOLEAN;
LOCAL
  spc_id : elementary_space_enumerators;
END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc))
  THEN
    RETURN(false);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace
  THEN
    RETURN(bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member
  THEN
    RETURN(bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION assoc_product_space(ts1 : tuple_space;
                             ts2 : tuple_space) : tuple_space;
LOCAL
  types1  : SET OF STRING         := stripped_typeof(ts1);
  types2  : SET OF STRING         := stripped_typeof(ts2);
  up1     : uniform_product_space := make_uniform_product_space(the_reals, 1);
  up2     : uniform_product_space := make_uniform_product_space(the_reals, 1);
  lp1     : listed_product_space := the_zero_tuple_space;
  lp2     : listed_product_space := the_zero_tuple_space;
  lps     : listed_product_space := the_zero_tuple_space;
  et1     : extended_tuple_space := the_tuples;
  et2     : extended_tuple_space := the_tuples;
  ets     : extended_tuple_space := the_tuples;
  use_up1 : BOOLEAN;
  use_up2 : BOOLEAN;
  use_lp1 : BOOLEAN;
  use_lp2 : BOOLEAN;
  factors : LIST OF maths_space   := [];
  tspace  : tuple_space;
END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1
  THEN
    up1 := ts1;
    use_up1 := true;
    use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1
    THEN
      lp1 := ts1;
      use_up1 := false;
      use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1)
      THEN
        RETURN(?);
      END_IF;
      et1 := ts1;
      use_up1 := false;
      use_lp1 := false;
    END_IF;
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types2
  THEN
    up2 := ts2;
    use_up2 := true;
    use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      lp2 := ts2;
      use_up2 := false;
      use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2)
      THEN
        RETURN(?);
      END_IF;
      et2 := ts2;
      use_up2 := false;
      use_lp2 := false;
    END_IF;
  END_IF;
  IF use_up1
  THEN
    IF use_up2
    THEN
      IF up1.base = up2.base
      THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base:up1.exponent,up2.base:up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2
      THEN
        factors := [up1.base:up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1
    THEN
      IF use_up2
      THEN
        factors := [up2.base:up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2
        THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2
      THEN
        IF et1.extender = up2.base
        THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          RETURN(?);
        END_IF;
      ELSE
        IF use_lp2
        THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF(factors);
            IF et1.extender <> factors[i]
            THEN
              RETURN(?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender
          THEN
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            RETURN(?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN(tspace);
END_FUNCTION;

FUNCTION atan2(y : REAL;
               x : REAL) : REAL;
LOCAL
  r : REAL;
END_LOCAL;
  IF (y = 0.0) AND (x = 0.0)
  THEN
    RETURN(?);
  END_IF;
  r := ATAN(y, x);
  IF x < 0.0
  THEN
    IF y < 0.0
    THEN
      r := r - PI;
    ELSE
      r := r + PI;
    END_IF;
  END_IF;
  RETURN(r);
END_FUNCTION;

FUNCTION bool(lgcl : LOGICAL) : BOOLEAN;
  IF NOT EXISTS(lgcl)
  THEN
    RETURN(false);
  END_IF;
  IF lgcl <> true
  THEN
    RETURN(false);
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION check_sparse_index_domain(idxdom : tuple_space;
                                   base : zero_or_one;
                                   shape : LIST [1:?] OF positive_integer;
                                   order : ordering_type) : BOOLEAN;
LOCAL
  mthspc   : maths_space;
  interval : finite_integer_interval;
  i        : INTEGER;
END_LOCAL;
  mthspc := factor1(idxdom);
  interval := mthspc;
  IF order = by_rows
  THEN
    i := 1;
  ELSE
    i := 2;
  END_IF;
  RETURN(bool((interval.min <= base) AND (interval.max >= base + shape[i])));
END_FUNCTION;

FUNCTION check_sparse_index_to_loc(index_range : tuple_space;
                                   loc_domain : tuple_space) : BOOLEAN;
LOCAL
  temp         : maths_space;
  idx_rng_itvl : finite_integer_interval;
  loc_dmn_itvl : finite_integer_interval;
END_LOCAL;
  temp := factor1(index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(temp)
  THEN
    temp := factor1(temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(false);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1(loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(temp)
  THEN
    temp := factor1(temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(false);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN(bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND (idx_rng_itvl.max <= loc_dmn_itvl.max + 1)));
END_FUNCTION;

FUNCTION check_sparse_loc_range(locrng : tuple_space;
                                base : zero_or_one;
                                shape : LIST [1:?] OF positive_integer;
                                order : ordering_type) : BOOLEAN;
LOCAL
  mthspc   : maths_space;
  interval : finite_integer_interval;
  i        : INTEGER;
END_LOCAL;
  IF space_dimension(locrng) <> 1
  THEN
    RETURN(false);
  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(mthspc))
  THEN
    RETURN(false);
  END_IF;
  interval := mthspc;
  IF order = by_rows
  THEN
    i := 2;
  ELSE
    i := 1;
  END_IF;
  RETURN(bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;

FUNCTION compare_basis_and_coef(basis : LIST [1:?] OF b_spline_basis;
                                coef : maths_function) : BOOLEAN;
LOCAL
  shape : LIST OF positive_integer;
END_LOCAL;
  IF NOT EXISTS(basis) OR NOT EXISTS(coef)
  THEN
    RETURN(false);
  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS(shape)
  THEN
    RETURN(false);
  END_IF;
  IF SIZEOF(shape) < SIZEOF(basis)
  THEN
    RETURN(false);
  END_IF;
  REPEAT i := 1 TO SIZEOF(basis);
    IF (basis[i].num_basis = shape[i]) <> true
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION compare_list_and_value(lv : LIST OF GENERIC:g;
                                op : elementary_function_enumerators;
                                v : GENERIC:g) : BOOLEAN;
  IF NOT EXISTS(lv) OR NOT EXISTS(op) OR NOT EXISTS(v)
  THEN
    RETURN(false);
  END_IF;
  REPEAT i := 1 TO SIZEOF(lv);
    IF NOT compare_values(lv[i], op, v)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION compare_values(v1 : GENERIC:g;
                        op : elementary_function_enumerators;
                        v2 : GENERIC:g) : BOOLEAN;
LOCAL
  logl : LOGICAL := unknown;
END_LOCAL;
  IF NOT EXISTS(v1) OR NOT EXISTS(op) OR NOT EXISTS(v2)
  THEN
    RETURN(false);
  END_IF;
  CASE op OF
    ef_eq_i : logl := (v1 = v2);
    ef_ne_i : logl := (v1 <> v2);
    ef_gt_i : logl := (v1 > v2);
    ef_lt_i : logl := (v1 < v2);
    ef_ge_i : logl := (v1 >= v2);
    ef_le_i : logl := (v1 <= v2);
  END_CASE;
  IF EXISTS(logl)
  THEN
    IF logl = true
    THEN
      RETURN(true);
    END_IF;
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION compatible_complex_number_regions(sp1 : maths_space;
                                           sp2 : maths_space) : BOOLEAN;
LOCAL
  typenames   : SET OF STRING                   := stripped_typeof(sp1);
  crgn1       : cartesian_complex_number_region;
  crgn2       : cartesian_complex_number_region;
  prgn1       : polar_complex_number_region;
  prgn2       : polar_complex_number_region;
  prgn1c2     : polar_complex_number_region;
  prgn2c1     : polar_complex_number_region;
  sp1_is_crgn : BOOLEAN;
  sp2_is_crgn : BOOLEAN;
END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames
  THEN
    sp1_is_crgn := true;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames
    THEN
      sp1_is_crgn := false;
      prgn1 := sp1;
    ELSE
      RETURN(true);
    END_IF;
  END_IF;
  typenames := stripped_typeof(sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames
  THEN
    sp2_is_crgn := true;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames
    THEN
      sp2_is_crgn := false;
      prgn2 := sp2;
    ELSE
      RETURN(true);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn
  THEN
    RETURN(compatible_intervals(crgn1.real_constraint, crgn2.real_constraint) AND
           compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND (prgn1.centre.real_part = prgn2.centre.real_part) AND
     (prgn1.centre.imag_part = prgn2.centre.imag_part)
  THEN
    IF NOT compatible_intervals(prgn1.distance_constraint, prgn2.distance_constraint)
    THEN
      RETURN(false);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint, prgn2.direction_constraint)
    THEN
      RETURN(true);
    END_IF;
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
    THEN
      RETURN(compatible_intervals(prgn2.direction_constraint,
             make_finite_real_interval(-PI, open, prgn1.direction_constraint.max - 2.0 * PI,
             prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
    THEN
      RETURN(compatible_intervals(prgn1.direction_constraint,
             make_finite_real_interval(-PI, open, prgn2.direction_constraint.max - 2.0 * PI,
             prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN(false);
  END_IF;
  IF sp1_is_crgn AND NOT sp2_is_crgn
  THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1, prgn2.centre);
    RETURN(compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn
  THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2, prgn1.centre);
    RETURN(compatible_complex_number_regions(crgn1, crgn2) AND compatible_complex_number_regions(prgn1, prgn2));
  END_IF;
  prgn1c2 := enclose_pregion_in_pregion(prgn1, prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2, prgn1.centre);
  RETURN(compatible_complex_number_regions(prgn1, prgn2c1) AND compatible_complex_number_regions(prgn1c2, prgn2));
END_FUNCTION;

FUNCTION compatible_es_values(esval1 : elementary_space_enumerators;
                              esval2 : elementary_space_enumerators) : BOOLEAN;
LOCAL
  esval1_is_numeric : LOGICAL;
  esval2_is_numeric : LOGICAL;
END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics)
  THEN
    RETURN(true);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR (esval2_is_numeric AND (esval1 = es_numbers))
  THEN
    RETURN(true);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric
  THEN
    RETURN(false);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR ((esval1 = es_booleans) AND (esval2 = es_logicals))
  THEN
    RETURN(true);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION compatible_intervals(sp1 : maths_space;
                              sp2 : maths_space) : BOOLEAN;
LOCAL
  amin : REAL;
  amax : REAL;
END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2)
  THEN
    amin := real_min(sp1);
    amax := real_max(sp2);
    IF amin > amax
    THEN
      RETURN(false);
    END_IF;
    IF amin = amax
    THEN
      RETURN(min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1)
  THEN
    amin := real_min(sp2);
    amax := real_max(sp1);
    IF amin > amax
    THEN
      RETURN(false);
    END_IF;
    IF amin = amax
    THEN
      RETURN(min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION compatible_spaces(sp1 : maths_space;
                           sp2 : maths_space) : BOOLEAN;
LOCAL
  types1 : SET OF STRING := stripped_typeof(sp1);
  types2 : SET OF STRING := stripped_typeof(sp2);
  lgcl   : LOGICAL       := unknown;
  m      : INTEGER;
  n      : INTEGER;
  s1     : maths_space;
  s2     : maths_space;
END_LOCAL;
  IF 'FINITE_SPACE' IN types1
  THEN
    REPEAT i := 1 TO SIZEOF(sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> false
      THEN
        RETURN(true);
      END_IF;
    END_REPEAT;
    RETURN(false);
  END_IF;
  IF 'FINITE_SPACE' IN types2
  THEN
    REPEAT i := 1 TO SIZEOF(sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> false
      THEN
        RETURN(true);
      END_IF;
    END_REPEAT;
    RETURN(false);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1
  THEN
    IF sp1\elementary_space.space_id = es_generics
    THEN
      RETURN(true);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
       ('INTEGER_INTERVAL_TO_MAX' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2) OR ('REAL_INTERVAL_TO_MAX' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types2)
    THEN
      RETURN(compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN(true);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2
  THEN
    IF sp2\elementary_space.space_id = es_generics
    THEN
      RETURN(true);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
       ('INTEGER_INTERVAL_TO_MAX' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR ('REAL_INTERVAL_FROM_MIN' IN types1) OR ('REAL_INTERVAL_TO_MAX' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types1)
    THEN
      RETURN(compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1
    THEN
      RETURN(false);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1
    THEN
      RETURN(bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    RETURN(true);
  END_IF;
  IF subspace_of_es(sp1, es_integers)
  THEN
    IF subspace_of_es(sp2, es_integers)
    THEN
      RETURN(compatible_intervals(sp1, sp2));
    END_IF;
    RETURN(false);
  END_IF;
  IF subspace_of_es(sp2, es_integers)
  THEN
    RETURN(false);
  END_IF;
  IF subspace_of_es(sp1, es_reals)
  THEN
    IF subspace_of_es(sp2, es_reals)
    THEN
      RETURN(compatible_intervals(sp1, sp2));
    END_IF;
    RETURN(false);
  END_IF;
  IF subspace_of_es(sp2, es_reals)
  THEN
    RETURN(false);
  END_IF;
  IF subspace_of_es(sp1, es_complex_numbers)
  THEN
    IF subspace_of_es(sp2, es_complex_numbers)
    THEN
      RETURN(compatible_complex_number_regions(sp1, sp2));
    END_IF;
    RETURN(false);
  END_IF;
  IF subspace_of_es(sp2, es_complex_numbers)
  THEN
    RETURN(false);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1
  THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2
    THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent
      THEN
        RETURN(false);
      END_IF;
      RETURN(compatible_spaces(sp1\uniform_product_space.base, sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      n := SIZEOF(sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n
      THEN
        RETURN(false);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base, sp2\listed_product_space.factors[i])
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(true);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n
      THEN
        RETURN(false);
      END_IF;
      IF m = n
      THEN
        RETURN(compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN(compatible_spaces(sp1,
             assoc_product_space(sp2\extended_tuple_space.base,
             make_uniform_product_space(sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(false);
    END_IF;
    RETURN(true);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1
  THEN
    n := SIZEOF(sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2
    THEN
      IF n <> sp2\uniform_product_space.exponent
      THEN
        RETURN(false);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base, sp1\listed_product_space.factors[i])
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(true);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2
    THEN
      IF n <> SIZEOF(sp2\listed_product_space.factors)
      THEN
        RETURN(false);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i], sp2\listed_product_space.factors[i])
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(true);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m
      THEN
        RETURN(false);
      END_IF;
      IF n = m
      THEN
        RETURN(compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN(compatible_spaces(sp1,
             assoc_product_space(sp2\extended_tuple_space.base,
             make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2
    THEN
      RETURN(false);
    END_IF;
    RETURN(true);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1
  THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR ('LISTED_PRODUCT_SPACE' IN types2)
    THEN
      RETURN(compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender, sp2\extended_tuple_space.extender)
      THEN
        RETURN(false);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m
      THEN
        RETURN(compatible_spaces(
               assoc_product_space(sp1\extended_tuple_space.base,
               make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
               sp2\extended_tuple_space.base));
      END_IF;
      IF n = m
      THEN
        RETURN(compatible_spaces(sp1\extended_tuple_space.base, sp2\extended_tuple_space.base));
      END_IF;
      IF n > m
      THEN
        RETURN(compatible_spaces(sp1\extended_tuple_space.base,
               assoc_product_space(sp2\extended_tuple_space.base,
               make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      RETURN(false);
    END_IF;
    RETURN(true);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1
  THEN
    IF 'FUNCTION_SPACE' IN types2
    THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
        sc_equal : BEGIN  
                          CASE sp2\function_space.domain_constraint OF
                            sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
                            sc_subspace : lgcl := subspace_of(s1, s2);
                            sc_member : lgcl := member_of(s1, s2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE sp2\function_space.domain_constraint OF
                               sc_equal : lgcl := subspace_of(s2, s1);
                               sc_subspace : lgcl := compatible_spaces(s1, s2);
                               sc_member : lgcl := unknown;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE sp2\function_space.domain_constraint OF
                             sc_equal : lgcl := member_of(s2, s1);
                             sc_subspace : lgcl := unknown;
                             sc_member : lgcl := compatible_spaces(s1, s2);
                           END_CASE;
        END;
      END_CASE;
      IF lgcl = false
      THEN
        RETURN(false);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
        sc_equal : BEGIN  
                          CASE sp2\function_space.range_constraint OF
                            sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
                            sc_subspace : lgcl := subspace_of(s1, s2);
                            sc_member : lgcl := member_of(s1, s2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE sp2\function_space.range_constraint OF
                               sc_equal : lgcl := subspace_of(s2, s1);
                               sc_subspace : lgcl := compatible_spaces(s1, s2);
                               sc_member : lgcl := unknown;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE sp2\function_space.range_constraint OF
                             sc_equal : lgcl := member_of(s2, s1);
                             sc_subspace : lgcl := unknown;
                             sc_member : lgcl := compatible_spaces(s1, s2);
                           END_CASE;
        END;
      END_CASE;
      IF lgcl = false
      THEN
        RETURN(false);
      END_IF;
      RETURN(true);
    END_IF;
    RETURN(true);
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION composable_sequence(operands : LIST [2:?] OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(operands) - 1;
    IF NOT compatible_spaces(operands[i].range, operands[i + 1].domain)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION convert_to_literal(val : maths_atom) : generic_literal;
LOCAL
  types : SET OF STRING := TYPEOF(val);
END_LOCAL;
  IF 'INTEGER' IN types
  THEN
    RETURN(make_int_literal(val));
  END_IF;
  IF 'REAL' IN types
  THEN
    RETURN(make_real_literal(val));
  END_IF;
  IF 'BOOLEAN' IN types
  THEN
    RETURN(make_boolean_literal(val));
  END_IF;
  IF 'STRING' IN types
  THEN
    RETURN(make_string_literal(val));
  END_IF;
  IF 'LOGICAL' IN types
  THEN
    RETURN(make_logical_literal(val));
  END_IF;
  IF 'BINARY' IN types
  THEN
    RETURN(make_binary_literal(val));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types
  THEN
    RETURN(make_maths_enum_literal(val));
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION convert_to_maths_function(func : maths_function_select) : maths_function;
LOCAL
  efenum : elementary_function_enumerators;
  mthfun : maths_function;
END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF(func)
  THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function(efenum);
  END_IF;
  RETURN(mthfun);
END_FUNCTION;

FUNCTION convert_to_maths_value(val : GENERIC:g) : maths_value;
LOCAL
  types : SET OF STRING := TYPEOF(val);
  ival  : maths_integer;
  rval  : maths_real;
  nval  : maths_number;
  tfval : maths_boolean;
  lval  : maths_logical;
  sval  : maths_string;
  bval  : maths_binary;
  tval  : maths_tuple := the_empty_maths_tuple;
  mval  : maths_value;
END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types
  THEN
    RETURN(val);
  END_IF;
  IF 'INTEGER' IN types
  THEN
    ival := val;
    RETURN(ival);
  END_IF;
  IF 'REAL' IN types
  THEN
    rval := val;
    RETURN(rval);
  END_IF;
  IF 'NUMBER' IN types
  THEN
    nval := val;
    RETURN(nval);
  END_IF;
  IF 'BOOLEAN' IN types
  THEN
    tfval := val;
    RETURN(tfval);
  END_IF;
  IF 'LOGICAL' IN types
  THEN
    lval := val;
    RETURN(lval);
  END_IF;
  IF 'STRING' IN types
  THEN
    sval := val;
    RETURN(sval);
  END_IF;
  IF 'BINARY' IN types
  THEN
    bval := val;
    RETURN(bval);
  END_IF;
  IF 'LIST' IN types
  THEN
    REPEAT i := 1 TO SIZEOF(val);
      mval := convert_to_maths_value(val[i]);
      IF NOT EXISTS(mval)
      THEN
        RETURN(?);
      END_IF;
      INSERT(tval, mval, i - 1);
    END_REPEAT;
    RETURN(tval);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION convert_to_operand(val : maths_value) : generic_expression;
LOCAL
  types : SET OF STRING := stripped_typeof(val);
END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN types
  THEN
    RETURN(val);
  END_IF;
  IF 'MATHS_ATOM' IN types
  THEN
    RETURN(convert_to_literal(val));
  END_IF;
  IF 'ATOM_BASED_VALUE' IN types
  THEN
    RETURN(make_atom_based_literal(val));
  END_IF;
  IF 'MATHS_TUPLE' IN types
  THEN
    RETURN(make_maths_tuple_literal(val));
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION convert_to_operands(values : AGGREGATE OF maths_value) : LIST OF generic_expression;
LOCAL
  operands : LIST OF generic_expression := [];
  loc      : INTEGER                    := 0;
END_LOCAL;
  IF NOT EXISTS(values)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := LOINDEX(values) TO HIINDEX(values);
    INSERT(operands, convert_to_operand(values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN(operands);
END_FUNCTION;

FUNCTION convert_to_operands_prcmfn(srcdom : maths_space_or_function;
                                    prepfun : LIST OF maths_function;
                                    finfun : maths_function_select) : LIST [2:?] OF generic_expression;
LOCAL
  operands : LIST OF generic_expression := [];
END_LOCAL;
  INSERT(operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF(prepfun);
    INSERT(operands, prepfun[i], i);
  END_REPEAT;
  INSERT(operands, convert_to_maths_function(finfun), SIZEOF(prepfun) + 1);
  RETURN(operands);
END_FUNCTION;

FUNCTION definite_integral_check(domain : tuple_space;
                                 vrblint : input_selector;
                                 lowerinf : BOOLEAN;
                                 upperinf : BOOLEAN) : BOOLEAN;
LOCAL
  domn : tuple_space := domain;
  fspc : maths_space;
  dim  : nonnegative_integer;
  k    : positive_integer;
END_LOCAL;
  IF (space_dimension(domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(domain)))
  THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  k := vrblint;
  IF k > dim
  THEN
    RETURN(false);
  END_IF;
  fspc := factor_space(domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF(fspc))
  THEN
    RETURN(false);
  END_IF;
  IF lowerinf AND min_exists(fspc)
  THEN
    RETURN(false);
  END_IF;
  IF upperinf AND max_exists(fspc)
  THEN
    RETURN(false);
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION definite_integral_expr_check(operands : LIST [2:?] OF generic_expression;
                                      lowerinf : BOOLEAN;
                                      upperinf : BOOLEAN) : BOOLEAN;
LOCAL
  nops : INTEGER             := 2;
  vspc : maths_space;
  dim  : nonnegative_integer;
  k    : positive_integer;
  bspc : maths_space;
END_LOCAL;
  IF NOT lowerinf
  THEN
    nops := nops + 1;
  END_IF;
  IF NOT upperinf
  THEN
    nops := nops + 1;
  END_IF;
  IF SIZEOF(operands) <> nops
  THEN
    RETURN(false);
  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2]))
  THEN
    RETURN(false);
  END_IF;
  IF NOT has_values_space(operands[2])
  THEN
    RETURN(false);
  END_IF;
  vspc := values_space_of(operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc))
  THEN
    RETURN(false);
  END_IF;
  IF lowerinf
  THEN
    IF min_exists(vspc)
    THEN
      RETURN(false);
    END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space(operands[3])
    THEN
      RETURN(false);
    END_IF;
    bspc := values_space_of(operands[3]);
    IF NOT compatible_spaces(bspc, vspc)
    THEN
      RETURN(false);
    END_IF;
    k := 4;
  END_IF;
  IF upperinf
  THEN
    IF max_exists(vspc)
    THEN
      RETURN(false);
    END_IF;
  ELSE
    IF NOT has_values_space(operands[k])
    THEN
      RETURN(false);
    END_IF;
    bspc := values_space_of(operands[k]);
    IF NOT compatible_spaces(bspc, vspc)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION derive_definite_integral_domain(igrl : definite_integral_function) : tuple_space;
FUNCTION process_product_space(spc : product_space;
                               idx : INTEGER;
                               prefix : INTEGER;
                               vdomn : maths_space) : product_space;
LOCAL
  uspc    : uniform_product_space;
  expnt   : INTEGER;
  factors : LIST OF maths_space;
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF(spc)
  THEN
    uspc := spc;
    expnt := uspc.exponent + prefix;
    IF idx <= uspc.exponent
    THEN
      expnt := expnt - 1;
    END_IF;
    IF expnt = 0
    THEN
      RETURN(make_listed_product_space([]));
    ELSE
      RETURN(make_uniform_product_space(uspc.base, expnt));
    END_IF;
  ELSE
    factors := spc\listed_product_space.factors;
    IF idx <= SIZEOF(factors)
    THEN
      REMOVE(factors, idx);
    END_IF;
    IF prefix > 0
    THEN
      INSERT(factors, vdomn, 0);
      IF prefix > 1
      THEN
        INSERT(factors, vdomn, 0);
      END_IF;
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
END_FUNCTION;
LOCAL
  idomn  : tuple_space := igrl.integrand.domain;
  types  : SET OF STRING        := TYPEOF(idomn);
  idx    : INTEGER              := igrl.variable_of_integration;
  tupled : BOOLEAN              := bool(((space_dimension(idomn) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN types)));
  prefix : INTEGER              := 0;
  espc   : extended_tuple_space;
  vdomn  : maths_space;
END_LOCAL;
  IF tupled
  THEN
    idomn := factor1(idomn);
    types := TYPEOF(idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity
  THEN
    prefix := prefix + 1;
  END_IF;
  IF igrl.upper_limit_pos_infinity
  THEN
    prefix := prefix + 1;
  END_IF;
  vdomn := factor_space(idomn, idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base, idx, prefix, vdomn), espc.extender);
  ELSE
    idomn := process_product_space(idomn, idx, prefix, vdomn);
  END_IF;
  IF tupled
  THEN
    RETURN(one_tuples_of(idomn));
  ELSE
    RETURN(idomn);
  END_IF;
END_FUNCTION;

FUNCTION derive_elementary_function_domain(ef_val : elementary_function_enumerators) : tuple_space;
  IF NOT EXISTS(ef_val)
  THEN
    RETURN(?);
  END_IF;
  CASE ef_val OF
    ef_and : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_or : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
    ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
    ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_i : RETURN(the_integer_tuples);
    ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_multiply_i : RETURN(the_integer_tuples);
    ef_divide_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_mod_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_eq_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_ne_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_gt_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_lt_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_ge_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_le_i : RETURN(make_uniform_product_space(the_integers, 2));
    ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_i : RETURN(make_listed_product_space([the_logicals,the_integers,the_integers]));
    ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_r : RETURN(the_real_tuples);
    ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_multiply_r : RETURN(the_real_tuples);
    ef_divide_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_mod_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_exponentiate_r : RETURN(make_listed_product_space([the_nonnegative_reals,the_reals]));
    ef_exponentiate_ri : RETURN(make_listed_product_space([the_reals,the_integers]));
    ef_eq_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_ne_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_gt_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_lt_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_ge_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_le_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_abs_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_acos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_asin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_atan2_r : RETURN(make_uniform_product_space(the_reals, 2));
    ef_cos_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exp_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_ln_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log2_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_log10_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_sin_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_if_r : RETURN(make_listed_product_space([the_logicals,the_reals,the_reals]));
    ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c : RETURN(the_complex_tuples);
    ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_multiply_c : RETURN(the_complex_tuples);
    ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_exponentiate_ci : RETURN(make_listed_product_space([the_complex_numbers,the_integers]));
    ef_eq_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_ne_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
    ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_arg_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c : RETURN(make_listed_product_space([the_logicals,the_complex_numbers,the_complex_numbers]));
    ef_subscript_s : RETURN(make_listed_product_space([the_strings,the_integers]));
    ef_eq_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_ne_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_gt_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_lt_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_ge_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_le_s : RETURN(make_uniform_product_space(the_strings, 2));
    ef_subsequence_s : RETURN(make_listed_product_space([the_strings,the_integers,the_integers]));
    ef_concat_s : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_strings));
    ef_size_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_format : RETURN(make_listed_product_space([the_numbers,the_strings]));
    ef_value : RETURN(make_uniform_product_space(the_strings, 1));
    ef_like : RETURN(make_uniform_product_space(the_strings, 2));
    ef_if_s : RETURN(make_listed_product_space([the_logicals,the_strings,the_strings]));
    ef_subscript_b : RETURN(make_listed_product_space([the_binarys,the_integers]));
    ef_eq_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_ne_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_gt_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_lt_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_ge_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_le_b : RETURN(make_uniform_product_space(the_binarys, 2));
    ef_subsequence_b : RETURN(make_listed_product_space([the_binarys,the_integers,the_integers]));
    ef_concat_b : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_binarys));
    ef_size_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_if_b : RETURN(make_listed_product_space([the_logicals,the_binarys,the_binarys]));
    ef_subscript_t : RETURN(make_listed_product_space([the_tuples,the_integers]));
    ef_eq_t : RETURN(make_uniform_product_space(the_tuples, 2));
    ef_ne_t : RETURN(make_uniform_product_space(the_tuples, 2));
    ef_concat_t : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_tuples));
    ef_size_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_entuple : RETURN(the_tuples);
    ef_detuple : RETURN(make_uniform_product_space(the_generics, 1));
    ef_insert : RETURN(make_listed_product_space([the_tuples,the_generics,the_integers]));
    ef_remove : RETURN(make_listed_product_space([the_tuples,the_integers]));
    ef_if_t : RETURN(make_listed_product_space([the_logicals,the_tuples,the_tuples]));
    ef_sum_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_product_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_add_it : RETURN(make_extended_tuple_space(the_integer_tuples, the_integer_tuples));
    ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
    ef_scalar_mult_it : RETURN(make_listed_product_space([the_integers,the_integer_tuples]));
    ef_dot_prod_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
    ef_sum_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_product_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_add_rt : RETURN(make_extended_tuple_space(the_real_tuples, the_real_tuples));
    ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
    ef_scalar_mult_rt : RETURN(make_listed_product_space([the_reals,the_real_tuples]));
    ef_dot_prod_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
    ef_norm_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_sum_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_product_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_add_ct : RETURN(make_extended_tuple_space(the_complex_tuples, the_complex_tuples));
    ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
    ef_scalar_mult_ct : RETURN(make_listed_product_space([the_complex_numbers,the_complex_tuples]));
    ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
    ef_norm_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_if : RETURN(make_listed_product_space([the_logicals,the_generics,the_generics]));
    ef_ensemble : RETURN(the_tuples);
    ef_member_of : RETURN(make_listed_product_space([the_generics,the_maths_spaces]));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION derive_elementary_function_range(ef_val : elementary_function_enumerators) : tuple_space;
  IF NOT EXISTS(ef_val)
  THEN
    RETURN(?);
  END_IF;
  CASE ef_val OF
    ef_and : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_or : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
    ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_multiply_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_divide_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_mod_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_eq_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_i : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_i : RETURN(make_uniform_product_space(the_integers, 1));
    ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_multiply_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_divide_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_mod_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exponentiate_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_exponentiate_ri : RETURN(make_uniform_product_space(the_reals, 1));
    ef_eq_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_r : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_abs_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_acos_r : RETURN(make_uniform_product_space(the_zero_pi_interval, 1));
    ef_asin_r : RETURN(make_uniform_product_space(the_neghalfpi_halfpi_interval, 1));
    ef_atan2_r : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_exp_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_ln_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_log2_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_log10_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
    ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_if_r : RETURN(make_uniform_product_space(the_reals, 1));
    ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_multiply_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exponentiate_ci : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_eq_c : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_c : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_abs_c : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_arg_c : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
    ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_if_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_subscript_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_eq_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_s : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_subsequence_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_concat_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_size_s : RETURN(make_uniform_product_space(the_integers, 1));
    ef_format : RETURN(make_uniform_product_space(the_strings, 1));
    ef_value : RETURN(make_uniform_product_space(the_reals, 1));
    ef_like : RETURN(make_uniform_product_space(the_booleans, 1));
    ef_if_s : RETURN(make_uniform_product_space(the_strings, 1));
    ef_subscript_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_eq_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_gt_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_lt_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ge_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_le_b : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_subsequence_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_concat_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_size_b : RETURN(make_uniform_product_space(the_integers, 1));
    ef_if_b : RETURN(make_uniform_product_space(the_binarys, 1));
    ef_subscript_t : RETURN(make_uniform_product_space(the_generics, 1));
    ef_eq_t : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_ne_t : RETURN(make_uniform_product_space(the_logicals, 1));
    ef_concat_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_size_t : RETURN(make_uniform_product_space(the_integers, 1));
    ef_entuple : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_detuple : RETURN(the_tuples);
    ef_insert : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_remove : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_if_t : RETURN(make_uniform_product_space(the_tuples, 1));
    ef_sum_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_product_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_add_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_scalar_mult_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
    ef_dot_prod_it : RETURN(make_uniform_product_space(the_integers, 1));
    ef_sum_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_product_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_add_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_scalar_mult_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
    ef_dot_prod_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_norm_rt : RETURN(make_uniform_product_space(the_reals, 1));
    ef_sum_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_product_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_add_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_scalar_mult_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
    ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
    ef_norm_ct : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
    ef_if : RETURN(make_uniform_product_space(the_generics, 1));
    ef_ensemble : RETURN(make_uniform_product_space(the_maths_spaces, 1));
    ef_member_of : RETURN(make_uniform_product_space(the_logicals, 1));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION derive_finite_function_domain(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
LOCAL
  result : SET OF maths_value := [];
END_LOCAL;
  result := result + list_selected_components(pairs, 1);
  RETURN(one_tuples_of(make_finite_space(result)));
END_FUNCTION;

FUNCTION derive_finite_function_range(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
LOCAL
  result : SET OF maths_value := [];
END_LOCAL;
  result := result + list_selected_components(pairs, 2);
  RETURN(one_tuples_of(make_finite_space(result)));
END_FUNCTION;

FUNCTION derive_function_domain(func : maths_function) : tuple_space;
LOCAL
  typenames  : SET OF STRING                   := stripped_typeof(func);
  tspace     : tuple_space := make_listed_product_space([]);
  shape      : LIST OF positive_integer;
  sidxs      : LIST OF INTEGER                 := [0];
  itvl       : finite_integer_interval;
  factors    : LIST OF finite_integer_interval := [];
  is_uniform : BOOLEAN                         := true;
END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames
  THEN
    RETURN(derive_finite_function_domain(func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames
  THEN
    RETURN(derive_elementary_function_domain(func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames
  THEN
    IF func\repackaging_function.input_repack = ro_nochange
    THEN
      RETURN(func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple
    THEN
      RETURN(factor1(func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple
    THEN
      RETURN(one_tuples_of(func\repackaging_function.operand.domain));
    END_IF;
    RETURN(?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames
  THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[i], sidxs[i] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] <> shape[1]
      THEN
        is_uniform := false;
      END_IF;
    END_REPEAT;
    IF is_uniform
    THEN
      RETURN(make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames
  THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF(shape);
      itvl := make_finite_integer_interval(sidxs[1], sidxs[1] + shape[i] - 1);
      INSERT(factors, itvl, i - 1);
      IF shape[i] <> shape[1]
      THEN
        is_uniform := false;
      END_IF;
    END_REPEAT;
    IF is_uniform
    THEN
      RETURN(make_uniform_product_space(factors[1], SIZEOF(shape)));
    END_IF;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(
           make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range),
           func\homogeneous_linear_function.mat\explicit_table_function.shape
               [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(
           make_uniform_product_space(factor1(func\general_linear_function.mat.range),
           func\general_linear_function.mat\explicit_table_function.shape[func\general_linear_function.sum_index] -
           1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames
  THEN
    RETURN(one_tuples_of(
           make_finite_real_interval(func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
           func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis + 1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(func\b_spline_function.basis);
      tspace := assoc_product_space(tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN(one_tuples_of(tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames
  THEN
    RETURN(func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames
  THEN
    RETURN(func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames
  THEN
    RETURN(derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(func\abstracted_expression_function.variables);
      tspace := assoc_product_space(tspace,
                one_tuples_of(values_space_of(func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN(tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames
  THEN
    RETURN(values_space_of(func\expression_denoted_function.expr)\function_space.domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_listed_product_space([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames
  THEN
    RETURN(func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames
  THEN
    RETURN(func\application_defined_function.explicit_domain);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION derive_function_range(func : maths_function) : tuple_space;
LOCAL
  typenames : SET OF STRING       := stripped_typeof(func);
  tspace    : tuple_space := make_listed_product_space([]);
  m         : nonnegative_integer := 0;
  n         : nonnegative_integer := 0;
  temp      : INTEGER             := 0;
END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames
  THEN
    RETURN(derive_finite_function_range(func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(make_finite_space([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(tspace))
    THEN
      tspace := factor1(tspace);
    END_IF;
    RETURN(one_tuples_of(factor_space(tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames
  THEN
    RETURN(derive_elementary_function_range(func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames
  THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple
    THEN
      tspace := one_tuples_of(tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple
    THEN
      tspace := factor1(tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0
    THEN
      tspace := one_tuples_of(factor_space(tspace, func\repackaging_function.selected_output));
    END_IF;
    RETURN(tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames
  THEN
    RETURN(func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\series_composed_function.operands[SIZEOF(func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames
  THEN
    IF 'LISTED_REAL_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames
    THEN
      RETURN(one_tuples_of(func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames
    THEN
      RETURN(func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames
    THEN
      RETURN(func\basic_sparse_matrix.val.range);
    END_IF;
    RETURN(?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(
           make_uniform_product_space(factor1(func\homogeneous_linear_function.mat.range),
           func\homogeneous_linear_function.mat\explicit_table_function.shape
               [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(
           make_uniform_product_space(factor1(func\general_linear_function.mat.range),
           func\general_linear_function.mat\explicit_table_function.shape
               [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames
  THEN
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames
  THEN
    tspace := factor1(func\b_spline_function.coef.domain);
    m := SIZEOF(func\b_spline_function.basis);
    n := space_dimension(tspace);
    IF m = n
    THEN
      RETURN(one_tuples_of(the_reals));
    END_IF;
    IF m = n - 1
    THEN
      RETURN(one_tuples_of(
             make_uniform_product_space(the_reals, factor_space(tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors(tspace, m + 1, n);
    RETURN(one_tuples_of(
           make_function_space(sc_equal, tspace, sc_subspace,
           number_superspace_of(func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames
  THEN
    tspace := factor1(func\rationalize_function.fun.range);
    n := space_dimension(tspace);
    RETURN(one_tuples_of(make_uniform_product_space(number_superspace_of(factor1(tspace)), n - 1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames
  THEN
    RETURN(drop_numeric_constraints(func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames
  THEN
    RETURN(drop_numeric_constraints(func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames
  THEN
    RETURN(one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames
  THEN
    RETURN(values_space_of(func\expression_denoted_function.expr)\function_space.range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_point_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_curve_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_surface_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames
  THEN
    temp := dimension_of(func\imported_volume_function.geometry);
    RETURN(one_tuples_of(make_uniform_product_space(the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames
  THEN
    RETURN(func\application_defined_function.explicit_range);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION domain_from(ref : maths_space_or_function) : tuple_space;
LOCAL
  typenames : SET OF STRING  := stripped_typeof(ref);
  func      : maths_function;
END_LOCAL;
  IF NOT EXISTS(ref)
  THEN
    RETURN(?);
  END_IF;
  IF 'TUPLE_SPACE' IN typenames
  THEN
    RETURN(ref);
  END_IF;
  IF 'MATHS_SPACE' IN typenames
  THEN
    RETURN(one_tuples_of(ref));
  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames
  THEN
    RETURN(domain_from(func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN(func.domain);
END_FUNCTION;

FUNCTION dotted_identifiers_syntax(str : STRING) : BOOLEAN;
LOCAL
  k : positive_integer;
  m : positive_integer;
END_LOCAL;
  IF NOT EXISTS(str)
  THEN
    RETURN(false);
  END_IF;
  k := parse_express_identifier(str, 1);
  IF k = 1
  THEN
    RETURN(false);
  END_IF;
  REPEAT WHILE k <= LENGTH(str);
    IF (str[k] <> '.') OR (k = LENGTH(str))
    THEN
      RETURN(false);
    END_IF;
    m := parse_express_identifier(str, k + 1);
    IF m = k + 1
    THEN
      RETURN(false);
    END_IF;
    k := m;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION dot_count(str : STRING) : INTEGER;
LOCAL
  n : INTEGER := 0;
END_LOCAL;
  REPEAT i := 1 TO LENGTH(str);
    IF str[i] = '.'
    THEN
      n := n + 1;
    END_IF;
  END_REPEAT;
  RETURN(n);
END_FUNCTION;

FUNCTION drop_numeric_constraints(spc : maths_space) : maths_space;
LOCAL
  typenames : SET OF STRING        := stripped_typeof(spc);
  tspc      : listed_product_space;
  factors   : LIST OF maths_space  := [];
  xspc      : extended_tuple_space;
END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames
  THEN
    RETURN(make_uniform_product_space(drop_numeric_constraints(spc\uniform_product_space.base),
           spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames
  THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF(tspc.factors);
      INSERT(factors, drop_numeric_constraints(tspc.factors[i]), i - 1);
    END_REPEAT;
    RETURN(make_listed_product_space(factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames
  THEN
    xspc := spc;
    RETURN(make_extended_tuple_space(drop_numeric_constraints(xspc.base), drop_numeric_constraints(xspc.extender)));
  END_IF;
  IF subspace_of_es(spc, es_numbers)
  THEN
    RETURN(number_superspace_of(spc));
  END_IF;
  RETURN(spc);
END_FUNCTION;

FUNCTION enclose_cregion_in_pregion(crgn : cartesian_complex_number_region;
                                    centre : complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
  REPEAT WHILE a > PI;
    a := a - 2.0 * PI;
  END_REPEAT;
  REPEAT WHILE a <= -PI;
    a := a + 2.0 * PI;
  END_REPEAT;
  RETURN(a);
END_FUNCTION;
FUNCTION strictly_in(z : REAL;
                     zitv : real_interval) : LOGICAL;
  RETURN((NOT min_exists(zitv) OR (z > real_min(zitv))) AND (NOT max_exists(zitv) OR (z < real_max(zitv))));
END_FUNCTION;
PROCEDURE angle_minmax(ab : REAL; a : REAL; a_in : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN;
                       VAR amax_in : BOOLEAN);
  a := angle(a - ab);
  IF amin = a
  THEN
    amin_in := amin_in OR a_in;
  END_IF;
  IF amin > a
  THEN
    amin := a;
    amin_in := a_in;
  END_IF;
  IF amax = a
  THEN
    amax_in := amax_in OR a_in;
  END_IF;
  IF amax < a
  THEN
    amax := a;
    amax_in := a_in;
  END_IF;
END_PROCEDURE;
PROCEDURE range_max(r : REAL; incl : BOOLEAN; VAR rmax : REAL; VAR rmax_in : BOOLEAN);
  IF rmax = r
  THEN
    rmax_in := rmax_in OR incl;
  END_IF;
  IF rmax < r
  THEN
    rmax := r;
    rmax_in := incl;
  END_IF;
END_PROCEDURE;
PROCEDURE range_min(r : REAL; incl : BOOLEAN; VAR rmin : REAL; VAR rmin_in : BOOLEAN);
  IF rmin = r
  THEN
    rmin_in := rmin_in OR incl;
  END_IF;
  IF (rmin < 0.0) OR (rmin > r)
  THEN
    rmin := r;
    rmin_in := incl;
  END_IF;
END_PROCEDURE;
LOCAL
  xitv        : real_interval;
  yitv        : real_interval;
  is_xmin     : BOOLEAN;
  is_xmax     : BOOLEAN;
  is_ymin     : BOOLEAN;
  is_ymax     : BOOLEAN;
  xmin        : REAL                 := 0.0;
  xmax        : REAL                 := 0.0;
  ymin        : REAL                 := 0.0;
  ymax        : REAL                 := 0.0;
  xc          : REAL                 := 0.0;
  yc          : REAL                 := 0.0;
  xmin_in     : BOOLEAN              := false;
  xmax_in     : BOOLEAN              := false;
  ymin_in     : BOOLEAN              := false;
  ymax_in     : BOOLEAN              := false;
  rmin        : REAL                 := -1.0;
  rmax        : REAL                 := -1.0;
  amin        : REAL                 := 4.0;
  amax        : REAL                 := -4.0;
  rmax_exists : BOOLEAN              := true;
  outside     : BOOLEAN              := true;
  rmin_in     : BOOLEAN              := false;
  rmax_in     : BOOLEAN              := false;
  amin_in     : BOOLEAN              := false;
  amax_in     : BOOLEAN              := false;
  ab          : REAL                 := 0.0;
  a           : REAL                 := 0.0;
  r           : REAL                 := 0.0;
  incl        : BOOLEAN;
  ritv        : real_interval;
  aitv        : finite_real_interval;
  minclo      : open_closed := open;
  maxclo      : open_closed := open;
END_LOCAL;
  IF NOT EXISTS(crgn) OR NOT EXISTS(centre)
  THEN
    RETURN(?);
  END_IF;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin
  THEN
    xmin := real_min(xitv);
    xmin_in := min_included(xitv);
  END_IF;
  IF is_xmax
  THEN
    xmax := real_max(xitv);
    xmax_in := max_included(xitv);
  END_IF;
  IF is_ymin
  THEN
    ymin := real_min(yitv);
    ymin_in := min_included(yitv);
  END_IF;
  IF is_ymax
  THEN
    ymax := real_max(yitv);
    ymax_in := max_included(yitv);
  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  IF is_xmin AND (xc <= xmin)
  THEN
    ab := 0.0;
  ELSE
    IF is_ymin AND (yc <= ymin)
    THEN
      ab := 0.5 * PI;
    ELSE
      IF is_ymax AND (yc >= ymax)
      THEN
        ab := -0.5 * PI;
      ELSE
        IF is_xmax AND (xc >= xmax)
        THEN
          ab := PI;
        ELSE
          outside := false;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF NOT outside AND NOT rmax_exists
  THEN
    RETURN(?);
  END_IF;
  IF is_xmin AND (xc <= xmin) AND strictly_in(yc, yitv)
  THEN
    rmin := xmin - xc;
    rmin_in := xmin_in;
  ELSE
    IF is_ymin AND (yc <= ymin) AND strictly_in(xc, xitv)
    THEN
      rmin := ymin - yc;
      rmin_in := ymin_in;
    ELSE
      IF is_ymax AND (yc >= ymax) AND strictly_in(xc, xitv)
      THEN
        rmin := yc - ymax;
        rmin_in := ymax_in;
      ELSE
        IF is_xmax AND (xc >= xmax) AND strictly_in(yc, yitv)
        THEN
          rmin := xc - xmax;
          rmin_in := xmax_in;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF is_xmin
  THEN
    IF is_ymin
    THEN
      r := SQRT((xmin - xc) ** 2 + (ymin - yc) ** 2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmin - xc) - ab);
          IF xc = xmin
          THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymin
          THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0 - ab);
          amin_in := ymin_in;
          amax := angle(0.5 * PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF xc <= xmin
      THEN
        angle_minmax(ab, -0.5 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymax AND (xc <= xmin)
    THEN
      angle_minmax(ab, 0.5 * PI, (xc = xmin) AND xmin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymin
  THEN
    IF is_xmax
    THEN
      r := SQRT((xmax - xc) ** 2 + (ymin - yc) ** 2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymin - yc, xmax - xc) - ab);
          IF xc = xmax
          THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymin
          THEN
            incl := ymin_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5 * PI - ab);
          amin_in := ymin_in;
          amax := angle(PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF yc <= ymin
      THEN
        angle_minmax(ab, 0.0, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmin AND (yc <= ymin)
    THEN
      angle_minmax(ab, PI, (yc = ymin) AND ymin_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_xmax
  THEN
    IF is_ymax
    THEN
      r := SQRT((xmax - xc) ** 2 + (ymax - yc) ** 2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmax - xc) - ab);
          IF xc = xmax
          THEN
            incl := xmax_in;
          END_IF;
          IF yc = ymax
          THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI - ab);
          amin_in := ymax_in;
          amax := angle(-0.5 * PI - ab);
          amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE
      IF xc >= xmax
      THEN
        angle_minmax(ab, 0.5 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_ymin AND (xc >= xmax)
    THEN
      angle_minmax(ab, -0.5 * PI, (xc = xmax) AND xmax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF is_ymax
  THEN
    IF is_xmin
    THEN
      r := SQRT((xmin - xc) ** 2 + (ymax - yc) ** 2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists
      THEN
        range_max(r, incl, rmax, rmax_in);
      END_IF;
      IF outside
      THEN
        IF r > 0.0
        THEN
          range_min(r, incl, rmin, rmin_in);
          a := angle(atan2(ymax - yc, xmin - xc) - ab);
          IF xc = xmin
          THEN
            incl := xmin_in;
          END_IF;
          IF yc = ymax
          THEN
            incl := ymax_in;
          END_IF;
          angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
        ELSE
          rmin := 0.0;
          rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5 * PI - ab);
          amin_in := ymax_in;
          amax := angle(PI - ab);
          amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE
      IF yc >= ymax
      THEN
        angle_minmax(ab, PI, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
      END_IF;
    END_IF;
    IF NOT is_xmax AND (yc >= ymax)
    THEN
      angle_minmax(ab, 0.0, (yc = ymax) AND ymax_in, amin, amax, amin_in, amax_in);
    END_IF;
  END_IF;
  IF outside
  THEN
    amin := angle(amin + ab);
    IF amin = PI
    THEN
      amin := -PI;
    END_IF;
    amax := angle(amax + ab);
    IF amax <= amin
    THEN
      amax := amax + 2.0 * PI;
    END_IF;
  ELSE
    amin := -PI;
    amin_in := false;
    amax := PI;
    amax_in := false;
  END_IF;
  IF amin_in
  THEN
    minclo := closed;
  END_IF;
  IF amax_in
  THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  minclo := open;
  IF rmin_in
  THEN
    minclo := closed;
  END_IF;
  IF rmax_exists
  THEN
    maxclo := open;
    IF rmax_in
    THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  RETURN(make_polar_complex_number_region(centre, ritv, aitv));
END_FUNCTION;

FUNCTION enclose_pregion_in_cregion(prgn : polar_complex_number_region) : cartesian_complex_number_region;
PROCEDURE nearest_good_direction(acart : REAL; aitv : finite_real_interval; VAR a : REAL; VAR a_in : BOOLEAN);
  a := acart;
  a_in := true;
  IF a < aitv.min
  THEN
    IF a + 2.0 * PI < aitv.max
    THEN
      RETURN;
    END_IF;
    IF a + 2.0 * PI = aitv.max
    THEN
      a_in := max_included(aitv);
      RETURN;
    END_IF;
  ELSE
    IF a = aitv.min
    THEN
      a_in := min_included(aitv);
      RETURN;
    ELSE
      IF a < aitv.max
      THEN
        RETURN;
      ELSE
        IF a = aitv.max
        THEN
          a_in := max_included(aitv);
          RETURN;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  IF COS(acart - aitv.max) >= COS(acart - aitv.min)
  THEN
    a := aitv.max;
    a_in := max_included(aitv);
  ELSE
    a := aitv.min;
    a_in := min_included(aitv);
  END_IF;
END_PROCEDURE;
LOCAL
  xc          : REAL                 := 0.0;
  yc          : REAL                 := 0.0;
  xmin        : REAL                 := 0.0;
  xmax        : REAL                 := 0.0;
  ymin        : REAL                 := 0.0;
  ymax        : REAL                 := 0.0;
  ritv        : real_interval;
  xitv        : real_interval;
  yitv        : real_interval;
  aitv        : finite_real_interval;
  xmin_exists : BOOLEAN;
  xmax_exists : BOOLEAN;
  ymin_exists : BOOLEAN;
  ymax_exists : BOOLEAN;
  xmin_in     : BOOLEAN              := false;
  xmax_in     : BOOLEAN              := false;
  ymin_in     : BOOLEAN              := false;
  ymax_in     : BOOLEAN              := false;
  a           : REAL                 := 0.0;
  r           : REAL                 := 0.0;
  a_in        : BOOLEAN              := false;
  min_clo     : open_closed := open;
  max_clo     : open_closed := open;
END_LOCAL;
  IF NOT EXISTS(prgn)
  THEN
    RETURN(?);
  END_IF;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  nearest_good_direction(PI, aitv, a, a_in);
  IF COS(a) >= 0.0
  THEN
    xmin_exists := true;
    xmin := xc + real_min(ritv) * COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      xmin_exists := true;
      xmin := xc + real_max(ritv) * COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := false;
    END_IF;
  END_IF;
  nearest_good_direction(0.0, aitv, a, a_in);
  IF COS(a) <= 0.0
  THEN
    xmax_exists := true;
    xmax := xc + real_min(ritv) * COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      xmax_exists := true;
      xmax := xc + real_max(ritv) * COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := false;
    END_IF;
  END_IF;
  nearest_good_direction(-0.5 * PI, aitv, a, a_in);
  IF SIN(a) >= 0.0
  THEN
    ymin_exists := true;
    ymin := yc + real_min(ritv) * SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      ymin_exists := true;
      ymin := yc + real_max(ritv) * SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := false;
    END_IF;
  END_IF;
  nearest_good_direction(0.5 * PI, aitv, a, a_in);
  IF SIN(a) <= 0.0
  THEN
    ymax_exists := true;
    ymax := yc + real_min(ritv) * SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv)
    THEN
      ymax_exists := true;
      ymax := yc + real_max(ritv) * SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := false;
    END_IF;
  END_IF;
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists)
  THEN
    RETURN(?);
  END_IF;
  IF xmin_exists
  THEN
    IF xmin_in
    THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF xmax_exists
    THEN
      IF xmax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_finite_real_interval(xmin, min_clo, xmax, max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin, min_clo);
    END_IF;
  ELSE
    IF xmax_exists
    THEN
      IF xmax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      xitv := make_real_interval_to_max(xmax, max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  IF ymin_exists
  THEN
    IF ymin_in
    THEN
      min_clo := closed;
    ELSE
      min_clo := open;
    END_IF;
    IF ymax_exists
    THEN
      IF ymax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_finite_real_interval(ymin, min_clo, ymax, max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin, min_clo);
    END_IF;
  ELSE
    IF ymax_exists
    THEN
      IF ymax_in
      THEN
        max_clo := closed;
      ELSE
        max_clo := open;
      END_IF;
      yitv := make_real_interval_to_max(ymax, max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  RETURN(make_cartesian_complex_number_region(xitv, yitv));
END_FUNCTION;

FUNCTION enclose_pregion_in_pregion(prgn : polar_complex_number_region;
                                    centre : complex_number_literal) : polar_complex_number_region;
FUNCTION angle(a : REAL) : REAL;
  REPEAT WHILE a > PI;
    a := a - 2.0 * PI;
  END_REPEAT;
  REPEAT WHILE a <= -PI;
    a := a + 2.0 * PI;
  END_REPEAT;
  RETURN(a);
END_FUNCTION;
PROCEDURE angle_range(VAR amin : REAL; VAR amax : REAL);
  amin := angle(amin);
  IF amin = PI
  THEN
    amin := -PI;
  END_IF;
  amax := angle(amax);
  IF amax <= amin
  THEN
    amax := amax + 2.0 * PI;
  END_IF;
END_PROCEDURE;
FUNCTION strictly_in(a : REAL;
                     aitv : finite_real_interval) : LOGICAL;
  a := angle(a);
  RETURN({aitv.min < a < aitv.max} OR {aitv.min < a + 2.0 * PI < aitv.max});
END_FUNCTION;
PROCEDURE find_aminmax(ab : REAL; a0 : REAL; a1 : REAL; a2 : REAL; a3 : REAL; in0 : BOOLEAN; in1 : BOOLEAN;
                       in2 : BOOLEAN; in3 : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN;
                       VAR amax_in : BOOLEAN);
 LOCAL  
        a : REAL;
 END_LOCAL;
  amin := angle(a0 - ab);
  amin_in := in0;
  amax := amin;
  amax_in := in0;
  a := angle(a1 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in1;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in1;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in1;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in1;
  END_IF;
  a := angle(a2 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in2;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in2;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in2;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in2;
  END_IF;
  a := angle(a3 - ab);
  IF a = amin
  THEN
    amin_in := amin_in OR in3;
  END_IF;
  IF a < amin
  THEN
    amin := a;
    amin_in := in3;
  END_IF;
  IF a = amax
  THEN
    amax_in := amax_in OR in3;
  END_IF;
  IF a > amax
  THEN
    amax := a;
    amax_in := in3;
  END_IF;
  amin := amin + ab;
  amax := amax + ab;
  angle_range(amin, amax);
END_PROCEDURE;
LOCAL
  ritp    : real_interval;
  ritv    : real_interval;
  aitp    : finite_real_interval;
  aitv    : finite_real_interval;
  xp      : REAL                 := 0.0;
  yp      : REAL                 := 0.0;
  xc      : REAL                 := 0.0;
  yc      : REAL                 := 0.0;
  rmax    : REAL                 := 0.0;
  rmin    : REAL                 := 0.0;
  amin    : REAL                 := 0.0;
  amax    : REAL                 := 0.0;
  rc      : REAL                 := 0.0;
  acp     : REAL                 := 0.0;
  apc     : REAL                 := 0.0;
  rmax_in : BOOLEAN              := false;
  rmin_in : BOOLEAN              := false;
  amin_in : BOOLEAN              := false;
  amax_in : BOOLEAN              := false;
  rmxp    : REAL                 := 0.0;
  rmnp    : REAL                 := 0.0;
  x       : REAL                 := 0.0;
  y       : REAL                 := 0.0;
  r       : REAL                 := 0.0;
  a       : REAL                 := 0.0;
  ab      : REAL                 := 0.0;
  r0      : REAL                 := 0.0;
  a0      : REAL                 := 0.0;
  r1      : REAL                 := 0.0;
  a1      : REAL                 := 0.0;
  r2      : REAL                 := 0.0;
  a2      : REAL                 := 0.0;
  r3      : REAL                 := 0.0;
  a3      : REAL                 := 0.0;
  in0     : BOOLEAN              := false;
  in1     : BOOLEAN              := false;
  in2     : BOOLEAN              := false;
  in3     : BOOLEAN              := false;
  inn     : BOOLEAN              := false;
  minclo  : open_closed := open;
  maxclo  : open_closed := open;
END_LOCAL;
  IF NOT EXISTS(prgn) OR NOT EXISTS(centre)
  THEN
    RETURN(?);
  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp)
  THEN
    RETURN(prgn);
  END_IF;
  rc := SQRT((xp - xc) ** 2 + (yp - yc) ** 2);
  acp := atan2(yp - yc, xp - xc);
  apc := atan2(yc - yp, xc - xp);
  rmnp := real_min(ritp);
  IF max_exists(ritp)
  THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0 * PI
    THEN
      inn := NOT max_included(aitp);
      a := angle(aitp.min);
      rmax := rc + rmxp;
      rmax_in := max_included(ritp);
      IF inn AND (acp = a)
      THEN
        rmax_in := false;
      END_IF;
      IF rc > rmxp
      THEN
        a0 := ASIN(rmxp / rc);
        amin := angle(acp - a0);
        amin_in := max_included(ritp);
        IF amin = PI
        THEN
          amin := -PI;
        END_IF;
        amax := angle(acp + a0);
        amax_in := amin_in;
        IF amax < amin
        THEN
          amax := amax + 2.0 * PI;
        END_IF;
        rmin := rc - rmxp;
        rmin_in := amin_in;
        IF inn
        THEN
          IF apc = a
          THEN
            rmin_in := false;
          END_IF;
          IF angle(amin + 0.5 * PI) = a
          THEN
            amin_in := false;
          END_IF;
          IF angle(amax - 0.5 * PI) = a
          THEN
            amax_in := false;
          END_IF;
        END_IF;
      ELSE
        IF rc = rmxp
        THEN
          amin := angle(acp - 0.5 * PI);
          amin_in := false;
          IF amin = PI
          THEN
            amin := -PI;
          END_IF;
          amax := angle(acp + 0.5 * PI);
          amax_in := false;
          IF amax < amin
          THEN
            amax := amax + 2.0 * PI;
          END_IF;
          rmin := 0.0;
          rmin_in := max_included(ritp);
          IF inn AND (apc = a)
          THEN
            rmin_in := false;
          END_IF;
        ELSE
          IF rc > rmnp
          THEN
            IF inn AND (apc = a)
            THEN
              rmin := 0.0;
              rmin_in := false;
              amin := aitp.min;
              amin_in := false;
              amax := aitp.max;
              amax_in := false;
            ELSE
              rmin := 0.0;
              rmin_in := true;
              amin := -PI;
              amin_in := false;
              amax := PI;
              amax_in := true;
            END_IF;
          ELSE
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
            amin := -PI;
            amin_in := false;
            amax := PI;
            amax_in := true;
            IF inn
            THEN
              IF apc = a
              THEN
                rmin_in := false;
                amin := aitp.min;
                amin_in := false;
                amax := aitp.max;
                amax_in := false;
              ELSE
                IF acp = a
                THEN
                  amin := aitp.min;
                  amin_in := false;
                  amax := aitp.max;
                  amax_in := false;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      x := xp + rmxp * COS(aitp.min) - xc;
      y := yp + rmxp * SIN(aitp.min) - yc;
      r0 := SQRT(x ** 2 + y ** 2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0
      THEN
        a0 := atan2(y, x);
      END_IF;
      x := xp + rmxp * COS(aitp.max) - xc;
      y := yp + rmxp * SIN(aitp.max) - yc;
      r1 := SQRT(x ** 2 + y ** 2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0
      THEN
        a1 := atan2(y, x);
      END_IF;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x ** 2 + y ** 2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0
      THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      IF r1 = 0.0
      THEN
        a1 := a2;
        in1 := in2;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x ** 2 + y ** 2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0
      THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF r0 = 0.0
      THEN
        a0 := a3;
        in0 := in3;
      END_IF;
      IF rmnp = 0.0
      THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min))
      THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max))
        THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(acp, aitp)
      THEN
        rmax := rc + rmxp;
        rmax_in := max_included(ritp);
      ELSE
        rmax := r0;
        rmax_in := in0;
        IF rmax = r1
        THEN
          rmax_in := rmax_in OR in1;
        END_IF;
        IF rmax < r1
        THEN
          rmax := r1;
          rmax_in := in1;
        END_IF;
        IF rmax = r2
        THEN
          rmax_in := rmax_in OR in2;
        END_IF;
        IF rmax < r2
        THEN
          rmax := r2;
          rmax_in := in2;
        END_IF;
        IF rmax = r3
        THEN
          rmax_in := rmax_in OR in3;
        END_IF;
        IF rmax < r3
        THEN
          rmax := r3;
          rmax_in := in3;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp)
      THEN
        IF rc >= rmxp
        THEN
          rmin := rc - rmxp;
          rmin_in := max_included(ritp);
        ELSE
          IF rc <= rmnp
          THEN
            rmin := rmnp - rc;
            rmin_in := min_included(ritp);
          ELSE
            rmin := 0.0;
            rmin_in := true;
          END_IF;
        END_IF;
      ELSE
        rmin := r0;
        rmin_in := in0;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF {rmnp < r < rmxp}
        THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF {rmnp < r < rmxp}
        THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin
          THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r < rmin
          THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r1 = rmin
        THEN
          rmin_in := rmin_in OR in1;
        END_IF;
        IF r1 < rmin
        THEN
          rmin := r1;
          rmin_in := in1;
        END_IF;
        IF r2 = rmin
        THEN
          rmin_in := rmin_in OR in2;
        END_IF;
        IF r2 < rmin
        THEN
          rmin := r2;
          rmin_in := in2;
        END_IF;
        IF r3 = rmin
        THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 < rmin
        THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      IF rc >= rmxp
      THEN
        ab := acp;
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        a := ACOS(rmxp / rc);
        IF strictly_in(apc - a, aitp)
        THEN
          amin := ab - ASIN(rmxp / rc);
          amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc + a, aitp)
        THEN
          amax := ab + ASIN(rmxp / rc);
          amax_in := max_included(ritp);
        END_IF;
        angle_range(amin, amax);
      ELSE
        IF rc > rmnp
        THEN
          ab := angle(0.5 * (aitp.min + aitp.max));
          find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
        ELSE
          ab := angle(0.5 * (aitp.min + aitp.max));
          a0 := angle(a0 - ab);
          a1 := angle(a1 - ab);
          a2 := angle(a2 - ab);
          a3 := angle(a3 - ab);
          IF a3 > a2
          THEN
            a2 := a2 + 2.0 * PI;
          END_IF;
          IF a0 > a1
          THEN
            a0 := a0 + 2.0 * PI;
          END_IF;
          IF a3 < a0
          THEN
            amin := a3;
            amin_in := in3;
          ELSE
            amin := a0;
            amin_in := in0;
          END_IF;
          IF a2 > a1
          THEN
            amax := a2;
            amax_in := in2;
          ELSE
            amax := a1;
            amax_in := in1;
          END_IF;
          IF (amax - amin > 2.0 * PI) OR ((amax - amin = 2.0 * PI) AND (amin_in OR amax_in))
          THEN
            amin := -PI;
            amin_in := false;
            amax := PI;
            amax_in := true;
          ELSE
            amin := amin + ab;
            amax := amax + ab;
            angle_range(amin, amax);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in
    THEN
      minclo := closed;
    END_IF;
    IF rmax_in
    THEN
      maxclo := closed;
    END_IF;
    ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
  ELSE
    IF (rc > rmnp) AND strictly_in(apc, aitp)
    THEN
      RETURN(?);
    END_IF;
    IF aitp.max - aitp.min = 2.0 * PI
    THEN
      a := angle(aitp.min);
      IF rc > rmnp
      THEN
        IF max_included(aitp)
        THEN
          RETURN(?);
        END_IF;
        rmin := 0.0;
        rmin_in := false;
        amin := aitp.min;
        amin_in := false;
        amax := aitp.max;
        amax_in := false;
      ELSE
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
        amin := -PI;
        amin_in := false;
        amax := PI;
        amax_in := true;
        IF NOT max_included(aitp)
        THEN
          IF apc = a
          THEN
            rmin_in := false;
            amin := aitp.min;
            amin_in := false;
            amax := aitp.max;
            amax_in := false;
          ELSE
            IF acp = a
            THEN
              amin := aitp.min;
              amin_in := false;
              amax := aitp.max;
              amax_in := false;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    ELSE
      a0 := angle(aitp.min);
      in0 := false;
      a1 := angle(aitp.max);
      in1 := false;
      x := xp + rmnp * COS(aitp.max) - xc;
      y := yp + rmnp * SIN(aitp.max) - yc;
      r2 := SQRT(x ** 2 + y ** 2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0
      THEN
        a2 := atan2(y, x);
      ELSE
        a2 := a1;
        in2 := in1;
      END_IF;
      x := xp + rmnp * COS(aitp.min) - xc;
      y := yp + rmnp * SIN(aitp.min) - yc;
      r3 := SQRT(x ** 2 + y ** 2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0
      THEN
        a3 := atan2(y, x);
      ELSE
        a3 := a0;
        in3 := in0;
      END_IF;
      IF rmnp = 0.0
      THEN
        in2 := min_included(ritp);
        in3 := in2;
      END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min))
      THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE
        IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max))
        THEN
          in1 := max_included(aitp);
          in2 := in1;
        END_IF;
      END_IF;
      IF strictly_in(apc, aitp)
      THEN
        rmin := rmnp - rc;
        rmin_in := min_included(ritp);
      ELSE
        rmin := r2;
        rmin_in := in2;
        a := apc - aitp.min;
        r := rc * COS(a);
        IF rmnp < r
        THEN
          rmin := rc * SIN(ABS(a));
          rmin_in := min_included(aitp);
        END_IF;
        a := apc - aitp.max;
        r := rc * COS(a);
        IF rmnp < r
        THEN
          r := rc * SIN(ABS(a));
          inn := max_included(aitp);
          IF r = rmin
          THEN
            rmin_in := rmin_in OR inn;
          END_IF;
          IF r < rmin
          THEN
            rmin := r;
            rmin_in := inn;
          END_IF;
        END_IF;
        IF r3 = rmin
        THEN
          rmin_in := rmin_in OR in3;
        END_IF;
        IF r3 < rmin
        THEN
          rmin := r3;
          rmin_in := in3;
        END_IF;
      END_IF;
      ab := angle(0.5 * (aitp.min + aitp.max));
      IF rc > rmnp
      THEN
        find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
      ELSE
        a0 := angle(a0 - ab);
        a1 := angle(a1 - ab);
        a2 := angle(a2 - ab);
        a3 := angle(a3 - ab);
        IF a3 > a2
        THEN
          a2 := a2 + 2.0 * PI;
        END_IF;
        IF a0 > a1
        THEN
          a0 := a0 + 2.0 * PI;
        END_IF;
        IF a3 < a0
        THEN
          amin := a3;
          amin_in := in3;
        ELSE
          amin := a0;
          amin_in := in0;
        END_IF;
        IF a2 > a1
        THEN
          amax := a2;
          amax_in := in2;
        ELSE
          amax := a1;
          amax_in := in1;
        END_IF;
        IF (amax - amin > 2.0 * PI) OR ((amax - amin = 2.0 * PI) AND (amin_in OR amax_in))
        THEN
          amin := -PI;
          amin_in := false;
          amax := PI;
          amax_in := true;
          IF (rmin = 0.0) AND rmin_in
          THEN
            RETURN(?);
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin, amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in
    THEN
      minclo := closed;
    END_IF;
    ritv := make_real_interval_from_min(rmin, minclo);
  END_IF;
  minclo := open;
  maxclo := open;
  IF amin_in
  THEN
    minclo := closed;
  END_IF;
  IF amax_in
  THEN
    maxclo := closed;
  END_IF;
  aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
  RETURN(make_polar_complex_number_region(centre, ritv, aitv));
END_FUNCTION;

FUNCTION equal_cregion_pregion(crgn : cartesian_complex_number_region;
                               prgn : polar_complex_number_region) : LOGICAL;
LOCAL
  arng : REAL;
  amin : REAL;
  xc   : REAL;
  yc   : REAL;
  aitv : real_interval;
  xitv : real_interval;
  yitv : real_interval;
  c_in : BOOLEAN;
END_LOCAL;
  IF NOT EXISTS(crgn) OR NOT EXISTS(prgn)
  THEN
    RETURN(false);
  END_IF;
  IF max_exists(prgn.distance_constraint)
  THEN
    RETURN(false);
  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0
  THEN
    RETURN(false);
  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5 * PI
  THEN
    IF amin = 0.0
    THEN
      RETURN(NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv) AND min_exists(yitv) AND
             (real_min(xitv) = xc) AND (real_min(yitv) = yc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND min_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
               NOT min_included(yitv)) OR
              (NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND
               min_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND
               NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5 * PI
    THEN
      RETURN(max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv) AND min_exists(yitv) AND
             (real_max(xitv) = xc) AND (real_min(yitv) = yc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND min_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
               NOT min_included(yitv)) OR
              (NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND
               min_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND
               NOT min_included(yitv))));
    END_IF;
    IF amin = -PI
    THEN
      RETURN(max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv) AND NOT min_exists(yitv) AND
             (real_max(xitv) = xc) AND (real_max(yitv) = yc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND max_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND max_included(xitv) AND
               NOT max_included(yitv)) OR
              (NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND
               max_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv) AND
               NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5 * PI
    THEN
      RETURN(NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv) AND NOT min_exists(yitv) AND
             (real_min(xitv) = xc) AND (real_max(yitv) = yc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND max_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND max_included(aitv) AND min_included(xitv) AND
               NOT max_included(yitv)) OR
              (NOT c_in AND min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND
               max_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv) AND
               NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI
  THEN
    IF amin = 0.0
    THEN
      RETURN(NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv) AND min_exists(yitv) AND
             (real_min(yitv) = yc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5 * PI
    THEN
      RETURN(max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv) AND NOT min_exists(yitv) AND
             (real_max(xitv) = xc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(xitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI
    THEN
      RETURN(NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv) AND NOT min_exists(yitv) AND
             (real_max(yitv) = yc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND max_included(yitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5 * PI
    THEN
      RETURN(NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv) AND NOT min_exists(yitv) AND
             (real_min(xitv) = xc) AND
             ((c_in AND min_included(aitv) AND max_included(aitv) AND min_included(xitv)) OR
              (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv) AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION equal_maths_functions(fun1 : maths_function;
                               fun2 : maths_function) : LOGICAL;
LOCAL
  cum : LOGICAL;
END_LOCAL;
  IF fun1 = fun2
  THEN
    RETURN(true);
  END_IF;
  cum := equal_maths_spaces(fun1.domain, fun2.domain);
  IF cum = false
  THEN
    RETURN(false);
  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range, fun2.range);
  IF cum = false
  THEN
    RETURN(false);
  END_IF;
  RETURN(unknown);
END_FUNCTION;

FUNCTION equal_maths_spaces(spc1 : maths_space;
                            spc2 : maths_space) : LOGICAL;
LOCAL
  spc1types : SET OF STRING       := stripped_typeof(spc1);
  spc2types : SET OF STRING       := stripped_typeof(spc2);
  set1      : SET OF maths_value;
  set2      : SET OF maths_value;
  cum       : LOGICAL             := true;
  base      : maths_space;
  expnt     : INTEGER;
  factors   : LIST OF maths_space;
  factors2  : LIST OF maths_space;
  fs1       : function_space;
  fs2       : function_space;
  cum2      : LOGICAL;
END_LOCAL;
  IF spc1 = spc2
  THEN
    RETURN(true);
  END_IF;
  IF 'FINITE_SPACE' IN spc1types
  THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types
    THEN
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF(set1);
        cum := cum AND member_of(set1[i], spc2);
        IF cum = false
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      IF cum = true
      THEN
        REPEAT i := 1 TO SIZEOF(set2);
          cum := cum AND member_of(set2[i], spc1);
          IF cum = false
          THEN
            RETURN(false);
          END_IF;
        END_REPEAT;
      END_IF;
      RETURN(cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types
    THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN(equal_maths_spaces(spc1, make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types)
  THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN(equal_maths_spaces(make_finite_space(set1), spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types)
  THEN
    RETURN(equal_cregion_pregion(spc1, spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types)
  THEN
    RETURN(equal_cregion_pregion(spc2, spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types
  THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types
    THEN
      IF expnt <> spc2\uniform_product_space.exponent
      THEN
        RETURN(false);
      END_IF;
      RETURN(equal_maths_spaces(base, spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types
    THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF(factors)
      THEN
        RETURN(false);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = false
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types
  THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types
    THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF(factors)
      THEN
        RETURN(false);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(base, factors[i]);
        IF cum = false
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types
    THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF(factors) <> SIZEOF(factors2)
      THEN
        RETURN(false);
      END_IF;
      REPEAT i := 1 TO SIZEOF(factors);
        cum := cum AND equal_maths_spaces(factors[i], factors2[i]);
        IF cum = false
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND ('EXTENDED_TUPLE_SPACE' IN spc2types)
  THEN
    RETURN(equal_maths_spaces(spc1\extended_tuple_space.extender, spc2\extended_tuple_space.extender) AND
           equal_maths_spaces(spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND ('FUNCTION_SPACE' IN spc2types)
  THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint
    THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal)
      THEN
        RETURN(false);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace)
      THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR (fs2.domain_constraint <> sc_member)
      THEN
        RETURN(unknown);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint, fs1.domain_argument) <>
         any_space_satisfies(fs2.domain_constraint, fs2.domain_argument)
      THEN
        RETURN(false);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument))
      THEN
        RETURN(false);
      END_IF;
      IF SIZEOF(['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] * stripped_typeof(fs1.domain_argument)) = 0
      THEN
        RETURN(false);
      END_IF;
      RETURN(unknown);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument, fs2.domain_argument);
    IF cum = false
    THEN
      RETURN(false);
    END_IF;
    IF fs1.range_constraint <> fs2.range_constraint
    THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal)
      THEN
        RETURN(false);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace)
      THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR (fs2.range_constraint <> sc_member)
      THEN
        RETURN(unknown);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint, fs1.range_argument) <>
         any_space_satisfies(fs2.range_constraint, fs2.range_argument)
      THEN
        RETURN(false);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument))
      THEN
        RETURN(false);
      END_IF;
      IF SIZEOF(['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] * stripped_typeof(fs1.range_argument)) = 0
      THEN
        RETURN(false);
      END_IF;
      RETURN(unknown);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument, fs2.range_argument);
    RETURN(cum);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION equal_maths_values(val1 : maths_value;
                            val2 : maths_value) : LOGICAL;
FUNCTION mem_of_vs(val1 : maths_value;
                   val2 : maths_value) : LOGICAL;
  IF NOT has_values_space(val2)
  THEN
    RETURN(unknown);
  END_IF;
  IF NOT member_of(val1, values_space_of(val2))
  THEN
    RETURN(false);
  END_IF;
  RETURN(unknown);
END_FUNCTION;
LOCAL
  types1 : SET OF STRING;
  types2 : SET OF STRING;
  list1  : LIST OF maths_value;
  list2  : LIST OF maths_value;
  cum    : LOGICAL             := true;
END_LOCAL;
  IF NOT EXISTS(val1) OR NOT EXISTS(val2)
  THEN
    RETURN(false);
  END_IF;
  IF val1 = val2
  THEN
    RETURN(true);
  END_IF;
  types1 := stripped_typeof(val1);
  types2 := stripped_typeof(val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1)
  THEN
    IF 'MATHS_ATOM' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'LIST' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(unknown);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2)
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'LIST' IN types1
  THEN
    IF 'LIST' IN types2
    THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF(list1) <> SIZEOF(list2)
      THEN
        RETURN(false);
      END_IF;
      REPEAT i := 1 TO SIZEOF(list1);
        cum := cum AND equal_maths_values(list1[i], list2[i]);
        IF cum = false
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(unknown);
  END_IF;
  IF 'LIST' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'MATHS_SPACE' IN types1
  THEN
    IF 'MATHS_SPACE' IN types2
    THEN
      RETURN(equal_maths_spaces(val1, val2));
    END_IF;
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(false);
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(unknown);
  END_IF;
  IF 'MATHS_SPACE' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF 'MATHS_FUNCTION' IN types1
  THEN
    IF 'MATHS_FUNCTION' IN types2
    THEN
      RETURN(equal_maths_functions(val1, val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2
    THEN
      RETURN(mem_of_vs(val1, val2));
    END_IF;
    RETURN(unknown);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2
  THEN
    RETURN(equal_maths_values(val2, val1));
  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2)
  THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2)
    THEN
      RETURN(unknown);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1), values_space_of(val2))
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  RETURN(unknown);
END_FUNCTION;

FUNCTION es_subspace_of_es(es1 : elementary_space_enumerators;
                           es2 : elementary_space_enumerators) : BOOLEAN;
  IF NOT EXISTS(es1) OR NOT EXISTS(es2)
  THEN
    RETURN(false);
  END_IF;
  IF es1 = es2
  THEN
    RETURN(true);
  END_IF;
  IF es2 = es_generics
  THEN
    RETURN(true);
  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals)
  THEN
    RETURN(true);
  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR (es1 = es_integers))
  THEN
    RETURN(true);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN(bool(SIZEOF(free_variables_of(expr)) = 0));
END_FUNCTION;

FUNCTION extract_factors(tspace : tuple_space;
                         m : INTEGER;
                         n : INTEGER) : tuple_space;
LOCAL
  tsp : tuple_space := the_zero_tuple_space;
END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space(tsp, factor_space(tspace, i));
  END_REPEAT;
  RETURN(tsp);
END_FUNCTION;

FUNCTION extremal_position_check(fun : linearized_table_function) : BOOLEAN;
LOCAL
  source_domain   : maths_space;
  source_interval : finite_integer_interval;
  index           : INTEGER                  := 1;
  base            : INTEGER;
  shape           : LIST OF positive_integer;
  ndim            : positive_integer;
  slo             : INTEGER;
  shi             : INTEGER;
  sublo           : LIST OF INTEGER          := [];
  subhi           : LIST OF INTEGER          := [];
END_LOCAL;
  IF NOT EXISTS(fun)
  THEN
    RETURN(false);
  END_IF;
  source_domain := factor1(fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF(source_domain)
  THEN
    source_domain := factor1(source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(source_domain))
  THEN
    RETURN(false);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF(fun)
  THEN
    REPEAT j := 1 TO SIZEOF(shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN(bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF(fun)
  THEN
    ndim := SIZEOF(fun\explicit_table_function.shape);
    REPEAT j := 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0
      THEN
        INSERT(sublo, slo, j - 1);
        INSERT(subhi, shi, j - 1);
      ELSE
        INSERT(sublo, shi, j - 1);
        INSERT(subhi, slo, j - 1);
      END_IF;
    END_REPEAT;
    index := regular_indexing(sublo, base, shape, fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max})
    THEN
      RETURN(false);
    END_IF;
    index := regular_indexing(subhi, base, shape, fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max})
    THEN
      RETURN(false);
    END_IF;
    RETURN(true);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION factor1(tspace : tuple_space) : maths_space;
LOCAL
  typenames : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(tspace\listed_product_space.factors[1]);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames
  THEN
    RETURN(factor1(tspace\extended_tuple_space.base));
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION factor_space(tspace : tuple_space;
                      idx : positive_integer) : maths_space;
LOCAL
  typenames : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    IF idx <= tspace\uniform_product_space.exponent
    THEN
      RETURN(tspace\uniform_product_space.base);
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    IF idx <= SIZEOF(tspace\listed_product_space.factors)
    THEN
      RETURN(tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames
  THEN
    IF idx <= space_dimension(tspace\extended_tuple_space.base)
    THEN
      RETURN(factor_space(tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN(tspace\extended_tuple_space.extender);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
LOCAL
  typenames : SET OF STRING              := stripped_typeof(expr);
  result    : SET OF generic_variable    := [];
  exprs     : LIST OF generic_expression := [];
END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames
  THEN
    RETURN(result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames
  THEN
    result := result + expr;
    RETURN(result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames
  THEN
    exprs := QUERY(ge <* expr\multiple_arity_generic_expression.operands | NOT (ge IN
                                                                                expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF(exprs);
      result := result + free_variables_of(exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF(expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN(result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames
  THEN
    RETURN(free_variables_of(expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames
  THEN
    result := free_variables_of(expr\binary_generic_expression.operands[1]);
    RETURN(result + free_variables_of(expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames
  THEN
    REPEAT i := 1 TO SIZEOF(expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of(expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN(result);
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION function_applicability(func : maths_function_select;
                                arguments : LIST [1:?] OF maths_value) : BOOLEAN;
LOCAL
  domain       : tuple_space := convert_to_maths_function(func).domain;
  domain_types : SET OF STRING      := TYPEOF(domain);
  narg         : positive_integer := SIZEOF(arguments);
  arg          : generic_expression;
END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types
  THEN
    IF space_dimension(domain) <> narg
    THEN
      RETURN(false);
    END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types
    THEN
      IF space_dimension(domain) > narg
      THEN
        RETURN(false);
      END_IF;
    ELSE
      RETURN(false);
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand(arguments[i]);
    IF NOT has_values_space(arg)
    THEN
      RETURN(false);
    END_IF;
    IF NOT compatible_spaces(factor_space(domain, i), values_space_of(arg))
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION function_is_1d_array(func : maths_function) : BOOLEAN;
LOCAL
  temp : maths_space;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(false);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(false);
  END_IF;
  temp := factor1(func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(temp)
  THEN
    IF space_dimension(temp) <> 1
    THEN
      RETURN(false);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp)
  THEN
    RETURN(true);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION function_is_1d_table(func : maths_function) : BOOLEAN;
LOCAL
  temp : maths_space;
  itvl : finite_integer_interval;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(false);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(false);
  END_IF;
  temp := factor1(func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(temp)
  THEN
    IF space_dimension(temp) <> 1
    THEN
      RETURN(false);
    END_IF;
    temp := factor1(temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp)
  THEN
    itvl := temp;
    RETURN(bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION function_is_2d_table(func : maths_function) : BOOLEAN;
LOCAL
  temp   : maths_space;
  pspace : product_space;
  itvl1  : finite_integer_interval;
  itvl2  : finite_integer_interval;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(false);
  END_IF;
  IF space_dimension(func.domain) <> 1
  THEN
    RETURN(false);
  END_IF;
  temp := factor1(func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp))
  THEN
    RETURN(false);
  END_IF;
  pspace := temp;
  IF space_dimension(pspace) <> 2
  THEN
    RETURN(false);
  END_IF;
  temp := factor1(pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))
  THEN
    RETURN(false);
  END_IF;
  itvl1 := temp;
  temp := factor_space(pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))
  THEN
    RETURN(false);
  END_IF;
  itvl2 := temp;
  RETURN(bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;

FUNCTION function_is_array(func : maths_function) : BOOLEAN;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(false);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(tspace))
  THEN
    RETURN(false);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION function_is_table(func : maths_function) : BOOLEAN;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
  base   : INTEGER;
END_LOCAL;
  IF NOT EXISTS(func)
  THEN
    RETURN(false);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF(tspace))
  THEN
    RETURN(false);
  END_IF;
  temp := factor1(tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
  THEN
    RETURN(false);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1)
  THEN
    RETURN(false);
  END_IF;
  REPEAT i := 2 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(false);
    END_IF;
    IF temp\finite_integer_interval.min <> base
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION has_values_space(expr : generic_expression) : BOOLEAN;
LOCAL
  typenames : SET OF STRING := stripped_typeof(expr);
END_LOCAL;
  IF 'EXPRESSION' IN typenames
  THEN
    RETURN(bool(
           ('NUMERIC_EXPRESSION' IN typenames) OR ('STRING_EXPRESSION' IN typenames) OR
           ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'MATHS_SPACE' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames
  THEN
    RETURN(has_values_space(expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames
  THEN
    RETURN(true);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames
  THEN
    RETURN(true);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION list_selected_components(aggr : AGGREGATE OF LIST OF maths_value;
                                  k : positive_integer) : LIST OF maths_value;
LOCAL
  result : LIST OF maths_value := [];
  j      : INTEGER             := 0;
END_LOCAL;
  REPEAT i := LOINDEX(aggr) TO HIINDEX(aggr);
    IF k <= SIZEOF(aggr[i])
    THEN
      INSERT(result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION make_abstracted_expression_function(operands : LIST [2:?] OF generic_expression) : abstracted_expression_function;
  RETURN(abstracted_expression_function() || maths_function() || generic_expression() ||
         quantifier_expression(remove_first(operands)) || multiple_arity_generic_expression(operands));
END_FUNCTION;

FUNCTION make_atom_based_literal(lit_value : atom_based_value) : atom_based_literal;
  RETURN(atom_based_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_banded_matrix(index_base : zero_or_one;
                            shape : LIST [1:?] OF positive_integer;
                            source : maths_function;
                            first : INTEGER;
                            default_entry : maths_value;
                            below : INTEGER;
                            above : INTEGER;
                            order : ordering_type) : banded_matrix;
  RETURN(banded_matrix(default_entry, below, above, order) || linearized_table_function(first) ||
         explicit_table_function(index_base, shape) || maths_function() || generic_expression() ||
         unary_generic_expression(source));
END_FUNCTION;

FUNCTION make_basic_sparse_matrix(index_base : zero_or_one;
                                  shape : LIST [1:?] OF positive_integer;
                                  operands : LIST [3:3] OF maths_function;
                                  default_entry : maths_value;
                                  order : ordering_type) : basic_sparse_matrix;
  RETURN(basic_sparse_matrix(default_entry, order) || explicit_table_function(index_base, shape) || maths_function() ||
         generic_expression() || multiple_arity_generic_expression(operands));
END_FUNCTION;

FUNCTION make_binary_literal(lit_value : BINARY) : binary_literal;
  RETURN(binary_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_boolean_literal(lit_value : BOOLEAN) : boolean_literal;
  RETURN(boolean_literal(lit_value) || simple_boolean_expression() || boolean_expression() || expression() ||
         generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_b_spline_basis(degree : nonnegative_integer;
                             repeated_knots : LIST [2:?] OF REAL) : b_spline_basis;
  RETURN(b_spline_basis(degree, repeated_knots) || maths_function() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_b_spline_function(coef : maths_function;
                                bases : LIST [1:?] OF b_spline_basis) : b_spline_function;
  RETURN(b_spline_function(bases) || maths_function() || generic_expression() || unary_generic_expression(coef));
END_FUNCTION;

FUNCTION make_cartesian_complex_number_region(real_constraint : real_interval;
                                              imag_constraint : real_interval) : cartesian_complex_number_region;
  RETURN(cartesian_complex_number_region(real_constraint, imag_constraint) || maths_space() || generic_expression() ||
         generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_complex_number_literal(rpart : REAL;
                                     ipart : REAL) : complex_number_literal;
  RETURN(complex_number_literal(rpart, ipart) || generic_literal() || simple_generic_expression() ||
         generic_expression());
END_FUNCTION;

FUNCTION make_constant_function(sole_value : maths_value;
                                src_of_domn : maths_space_or_function) : constant_function;
  RETURN(constant_function(sole_value, src_of_domn) || maths_function() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_cos_expression(operand : numeric_expression) : cos_expression;
  RETURN(cos_expression() || unary_numeric_call_expression() || unary_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || unary_generic_expression(operand));
END_FUNCTION;

FUNCTION make_definite_integral_expression(operands : LIST [2:4] OF generic_expression;
                                           loinf : BOOLEAN;
                                           upinf : BOOLEAN) : definite_integral_expression;
  RETURN(definite_integral_expression(loinf, upinf) || quantifier_expression([operands[2]]) ||
         multiple_arity_generic_expression(operands) || generic_expression());
END_FUNCTION;

FUNCTION make_definite_integral_function(integrand : maths_function;
                                         varintg : input_selector;
                                         loinf : BOOLEAN;
                                         upinf : BOOLEAN) : definite_integral_function;
  RETURN(definite_integral_function(varintg, loinf, upinf) || maths_function() || generic_expression() ||
         unary_generic_expression(integrand));
END_FUNCTION;

FUNCTION make_elementary_function(func_id : elementary_function_enumerators) : elementary_function;
  RETURN(elementary_function(func_id) || maths_function() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_elementary_space(space_id : elementary_space_enumerators) : elementary_space;
  RETURN(elementary_space(space_id) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_environment(varbl : generic_variable;
                          sem : variable_semantics) : environment;
  RETURN(environment(varbl, sem));
END_FUNCTION;

FUNCTION make_expression_denoted_function(expression : generic_expression) : expression_denoted_function;
  RETURN(expression_denoted_function() || maths_function() || generic_expression() ||
         unary_generic_expression(expression));
END_FUNCTION;

FUNCTION make_extended_tuple_space(base : tuple_space;
                                   extender : maths_space) : extended_tuple_space;
  RETURN(extended_tuple_space(base, extender) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_finite_function(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : finite_function;
  RETURN(finite_function(pairs) || maths_function() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_finite_integer_interval(min : INTEGER;
                                      max : INTEGER) : finite_integer_interval;
  RETURN(finite_integer_interval(min, max) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_finite_real_interval(min : REAL;
                                   minclo : open_closed;
                                   max : REAL;
                                   maxclo : open_closed) : finite_real_interval;
  RETURN(finite_real_interval(min, minclo, max, maxclo) || maths_space() || generic_expression() ||
         generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN(finite_space(members) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_function_application(afunction : maths_function_select;
                                   arguments : LIST [1:?] OF maths_value) : function_application;
  RETURN(function_application(afunction, arguments) ||
         multiple_arity_generic_expression(convert_to_maths_function(afunction) + convert_to_operands(arguments)) ||
         generic_expression());
END_FUNCTION;

FUNCTION make_function_space(domain_constraint : space_constraint_type;
                             domain_argument : maths_space;
                             range_constraint : space_constraint_type;
                             range_argument : maths_space) : function_space;
  RETURN(function_space(domain_constraint, domain_argument, range_constraint, range_argument) || maths_space() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_general_linear_function(mat : maths_function;
                                      sum_index : one_or_two) : general_linear_function;
  RETURN(general_linear_function(sum_index) || maths_function() || generic_expression() ||
         unary_generic_expression(mat));
END_FUNCTION;

FUNCTION make_integer_interval_from_min(min : INTEGER) : integer_interval_from_min;
  RETURN(integer_interval_from_min(min) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_int_literal(lit_value : INTEGER) : int_literal;
  RETURN(int_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_listed_complex_number_data(index_base : zero_or_one;
                                         values : LIST [2:?] OF REAL) : listed_complex_number_data;
  RETURN(listed_complex_number_data(values) || explicit_table_function(index_base, [SIZEOF(values) / 2]) ||
         maths_function() || generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_listed_data(index_base : zero_or_one;
                          values : LIST [2:?] OF maths_value;
                          value_range : maths_space) : listed_data;
  RETURN(listed_data(values, value_range) || explicit_table_function(index_base, [SIZEOF(values)]) ||
         maths_function() || generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_listed_integer_data(index_base : zero_or_one;
                                  values : LIST [1:?] OF INTEGER) : listed_integer_data;
  RETURN(listed_integer_data(values) || explicit_table_function(index_base, [SIZEOF(values)]) || maths_function() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_listed_product_space(factors : LIST OF maths_space) : listed_product_space;
  RETURN(listed_product_space(factors) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_listed_real_data(index_base : zero_or_one;
                               values : LIST [1:?] OF REAL) : listed_real_data;
  RETURN(listed_real_data(values) || explicit_table_function(index_base, [SIZEOF(values)]) || maths_function() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_logical_literal(lit_value : LOGICAL) : logical_literal;
  RETURN(logical_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_maths_enum_literal(lit_value : maths_enum_atom) : maths_enum_literal;
  RETURN(maths_enum_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_maths_real_variable(values_space : maths_space;
                                  name : label) : maths_real_variable;
  RETURN(expression() || numeric_expression() || simple_numeric_expression() || maths_real_variable() ||
         maths_variable(values_space, name) || generic_variable() || simple_generic_expression() ||
         generic_expression() || real_numeric_variable() || numeric_variable() || variable());
END_FUNCTION;

FUNCTION make_maths_tuple_literal(lit_value : LIST OF maths_value) : maths_tuple_literal;
  RETURN(maths_tuple_literal(lit_value) || generic_literal() || simple_generic_expression() || generic_expression());
END_FUNCTION;

FUNCTION make_mult_expression(operands : LIST [2:?] OF generic_expression) : mult_expression;
  RETURN(mult_expression() || multiple_arity_numeric_expression() || numeric_expression() || expression() ||
         generic_expression() || multiple_arity_generic_expression(operands));
END_FUNCTION;

FUNCTION make_parallel_composed_function(srcdom : maths_space_or_function;
                                         prepfuncs : LIST [2:?] OF maths_function;
                                         finfunc : maths_function_select) : parallel_composed_function;
  RETURN(parallel_composed_function(srcdom, prepfuncs, finfunc) || maths_function() || generic_expression() ||
         multiple_arity_generic_expression(convert_to_operands_prcmfn(srcdom, prepfuncs, finfunc)));
END_FUNCTION;

FUNCTION make_partial_derivative_expression(derivand : generic_expression;
                                            dvars : LIST [1:?] OF maths_variable;
                                            extend : extension_options) : partial_derivative_expression;
  RETURN(partial_derivative_expression(dvars, extend) || unary_generic_expression(derivand) || generic_expression());
END_FUNCTION;

FUNCTION make_partial_derivative_function(derivand : maths_function;
                                          dvars : LIST [1:?] OF input_selector;
                                          extend : extension_options) : partial_derivative_function;
  RETURN(partial_derivative_function(dvars, extend) || maths_function() || generic_expression() ||
         unary_generic_expression(derivand));
END_FUNCTION;

FUNCTION make_polar_complex_number_region(centre : complex_number_literal;
                                          dis_constraint : real_interval;
                                          dir_constraint : finite_real_interval) : polar_complex_number_region;
  RETURN(polar_complex_number_region(centre, dis_constraint, dir_constraint) || maths_space() ||
         generic_expression() || generic_literal() || simple_generic_expression());
END_FUNCTION;

FUNCTION make_rationalize_function(fun : maths_function) : rationalize_function;
  RETURN(rationalize_function() || maths_function() || generic_expression() || unary_generic_expression(fun));
END_FUNCTION;

FUNCTION make_real_interval_from_min(min : REAL;
                                     minclo : open_closed) : real_interval_from_min;
  RETURN(real_interval_from_min(min, minclo) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_real_interval_to_max(max : REAL;
                                   maxclo : open_closed) : real_interval_to_max;
  RETURN(real_interval_to_max(max, maxclo) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_real_literal(lit_value : REAL) : real_literal;
  RETURN(real_literal() || literal_number(lit_value) || simple_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_regular_table_function(index_base : zero_or_one;
                                     shape : LIST [1:?] OF positive_integer;
                                     operand : maths_function;
                                     first : INTEGER;
                                     increments : LIST [1:?] OF INTEGER) : regular_table_function;
  RETURN(regular_table_function(increments) || linearized_table_function(first) ||
         explicit_table_function(index_base, shape) || maths_function() || generic_expression() ||
         unary_generic_expression(operand));
END_FUNCTION;

FUNCTION make_reindexed_array_function(func : maths_function;
                                       start_idxs : LIST [1:?] OF INTEGER) : reindexed_array_function;
  RETURN(reindexed_array_function(start_idxs) || maths_function() || generic_expression() ||
         unary_generic_expression(func));
END_FUNCTION;

FUNCTION make_repackaging_function(operand : maths_function;
                                   input_repack : repackage_options;
                                   output_repack : repackage_options;
                                   selected_output : nonnegative_integer) : repackaging_function;
  RETURN(repackaging_function(input_repack, output_repack, selected_output) || maths_function() ||
         generic_expression() || unary_generic_expression(operand));
END_FUNCTION;

FUNCTION make_selector_function(selector : input_selector;
                                src_of_domn : maths_space_or_function) : selector_function;
  RETURN(selector_function(selector, src_of_domn) || maths_function() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION make_series_composed_function(functions : LIST [2:?] OF maths_function) : series_composed_function;
  RETURN(series_composed_function() || maths_function() || generic_expression() ||
         multiple_arity_generic_expression(functions));
END_FUNCTION;

FUNCTION make_sin_expression(operand : numeric_expression) : sin_expression;
  RETURN(sin_expression() || unary_numeric_call_expression() || unary_numeric_expression() || numeric_expression() ||
         expression() || generic_expression() || unary_generic_expression(operand));
END_FUNCTION;

FUNCTION make_standard_table_function(index_base : zero_or_one;
                                      shape : LIST [1:?] OF positive_integer;
                                      operand : maths_function;
                                      first : INTEGER;
                                      order : ordering_type) : standard_table_function;
  RETURN(standard_table_function(order) || linearized_table_function(first) ||
         explicit_table_function(index_base, shape) || maths_function() || generic_expression() ||
         unary_generic_expression(operand));
END_FUNCTION;

FUNCTION make_strict_triangular_matrix(index_base : zero_or_one;
                                       shape : LIST [1:?] OF positive_integer;
                                       source : maths_function;
                                       first : INTEGER;
                                       default_entry : maths_value;
                                       lo_up : lower_upper;
                                       order : ordering_type;
                                       main_diagonal_value : maths_value) : strict_triangular_matrix;
  RETURN(strict_triangular_matrix(main_diagonal_value) || triangular_matrix(default_entry, lo_up, order) ||
         linearized_table_function(first) || explicit_table_function(index_base, shape) || maths_function() ||
         generic_expression() || unary_generic_expression(source));
END_FUNCTION;

FUNCTION make_string_literal(lit_value : STRING) : string_literal;
  RETURN(string_literal(lit_value) || simple_string_expression() || string_expression() || expression() ||
         generic_expression() || simple_generic_expression() || generic_literal());
END_FUNCTION;

FUNCTION make_unary_minus_expression(operand : numeric_expression) : unary_minus_expression;
  RETURN(unary_minus_expression() || unary_numeric_call_expression() || unary_numeric_expression() ||
         numeric_expression() || expression() || generic_expression() || unary_generic_expression(operand));
END_FUNCTION;

FUNCTION make_uniform_product_space(base : maths_space;
                                    exponent : positive_integer) : uniform_product_space;
  RETURN(uniform_product_space(base, exponent) || maths_space() || generic_expression() || generic_literal() ||
         simple_generic_expression());
END_FUNCTION;

FUNCTION max_exists(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  RETURN(bool(
         ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
         ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
         ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;

FUNCTION max_included(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(true);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION member_of(val : GENERIC:g;
                   spc : maths_space) : LOGICAL;
FUNCTION fedex(val : AGGREGATE OF GENERIC:x;
               i : INTEGER) : GENERIC:x;
  RETURN(val[i]);
END_FUNCTION;
LOCAL
  v         : maths_value := simplify_maths_value(convert_to_maths_value(val));
  vtypes    : SET OF STRING          := stripped_typeof(v);
  s         : maths_space := simplify_maths_space(spc);
  stypes    : SET OF STRING          := stripped_typeof(s);
  tmp_int   : INTEGER;
  tmp_real  : REAL;
  tmp_cmplx : complex_number_literal;
  lgcl      : LOGICAL;
  cum       : LOGICAL;
  vspc      : maths_space;
  sspc      : maths_space;
  smem      : SET OF maths_value;
  factors   : LIST OF maths_space;
END_LOCAL;
  IF NOT EXISTS(s)
  THEN
    RETURN(false);
  END_IF;
  IF NOT EXISTS(v)
  THEN
    RETURN(s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
     NOT ('MATHS_SPACE' IN vtypes) AND NOT ('MATHS_FUNCTION' IN vtypes) AND NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes)
  THEN
    IF has_values_space(v)
    THEN
      vspc := values_space_of(v);
      IF subspace_of(vspc, s)
      THEN
        RETURN(true);
      END_IF;
      IF NOT compatible_spaces(vspc, s)
      THEN
        RETURN(false);
      END_IF;
      RETURN(unknown);
    END_IF;
    RETURN(unknown);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes
  THEN
    CASE s\elementary_space.space_id OF
      es_numbers : RETURN(('NUMBER' IN vtypes) OR ('COMPLEX_NUMBER_LITERAL' IN vtypes));
      es_complex_numbers : RETURN('COMPLEX_NUMBER_LITERAL' IN vtypes);
      es_reals : RETURN(('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
      es_integers : RETURN('INTEGER' IN vtypes);
      es_logicals : RETURN('LOGICAL' IN vtypes);
      es_booleans : RETURN('BOOLEAN' IN vtypes);
      es_strings : RETURN('STRING' IN vtypes);
      es_binarys : RETURN('BINARY' IN vtypes);
      es_maths_spaces : RETURN('MATHS_SPACE' IN vtypes);
      es_maths_functions : RETURN('MATHS_FUNCTION' IN vtypes);
      es_generics : RETURN(true);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN({s\finite_integer_interval.min <= tmp_int <= s\finite_integer_interval.max});
    END_IF;
    RETURN(false);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN(s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN(false);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes
  THEN
    IF 'INTEGER' IN vtypes
    THEN
      tmp_int := v;
      RETURN(tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN(false);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed
      THEN
        IF s\finite_real_interval.max_closure = closed
        THEN
          RETURN({s\finite_real_interval.min <= tmp_real <= s\finite_real_interval.max});
        ELSE
          RETURN({s\finite_real_interval.min <= tmp_real < s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed
        THEN
          RETURN({s\finite_real_interval.min < tmp_real <= s\finite_real_interval.max});
        ELSE
          RETURN({s\finite_real_interval.min < tmp_real < s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN(false);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed
      THEN
        RETURN(s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN(s\real_interval_from_min.min < tmp_real);
      END_IF;
    END_IF;
    RETURN(false);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes
  THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes)
    THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed
      THEN
        RETURN(tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN(tmp_real < s\real_interval_to_max.max);
      END_IF;
    END_IF;
    RETURN(false);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes
  THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes
    THEN
      RETURN(member_of(v\complex_number_literal.real_part, s\cartesian_complex_number_region.real_constraint) AND
             member_of(v\complex_number_literal.imag_part, s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN(false);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes
  THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes
    THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part - s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part - s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT(tmp_cmplx.real_part ** 2 + tmp_cmplx.imag_part ** 2);
      IF NOT member_of(tmp_real, s\polar_complex_number_region.distance_constraint)
      THEN
        RETURN(false);
      END_IF;
      IF tmp_real = 0.0
      THEN
        RETURN(true);
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part, tmp_cmplx.real_part);
      RETURN(member_of(tmp_real, s\polar_complex_number_region.direction_constraint) OR
             member_of(tmp_real + 2.0 * PI, s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN(false);
  END_IF;
  IF 'FINITE_SPACE' IN stypes
  THEN
    smem := s\finite_space.members;
    cum := false;
    REPEAT i := 1 TO SIZEOF(smem);
      cum := cum OR equal_maths_values(v, smem[i]);
      IF cum = true
      THEN
        RETURN(true);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      IF SIZEOF(v) = s\uniform_product_space.exponent
      THEN
        sspc := s\uniform_product_space.base;
        cum := true;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = false
          THEN
            RETURN(false);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(false);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF(v) = SIZEOF(factors)
      THEN
        cum := true;
        REPEAT i := 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], factors[i]);
          IF cum = false
          THEN
            RETURN(false);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(false);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes
  THEN
    IF 'LIST' IN vtypes
    THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF(v) >= tmp_int
      THEN
        cum := true;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i], factor_space(sspc, i));
          IF cum = false
          THEN
            RETURN(false);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int + 1 TO SIZEOF(v);
          cum := cum AND member_of(v[i], sspc);
          IF cum = false
          THEN
            RETURN(false);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(false);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes
  THEN
    IF 'MATHS_FUNCTION' IN vtypes
    THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
        sc_equal : cum := equal_maths_spaces(vspc, sspc);
        sc_subspace : cum := subspace_of(vspc, sspc);
        sc_member : cum := member_of(vspc, sspc);
      END_CASE;
      IF cum = false
      THEN
        RETURN(false);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces(vspc, sspc);
        sc_subspace : cum := cum AND subspace_of(vspc, sspc);
        sc_member : cum := cum AND member_of(vspc, sspc);
      END_CASE;
      RETURN(cum);
    END_IF;
    RETURN(false);
  END_IF;
  RETURN(unknown);
END_FUNCTION;

FUNCTION min_exists(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  RETURN(bool(
         ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
         ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
         ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;

FUNCTION min_included(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(true);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION nondecreasing(lr : LIST OF REAL) : BOOLEAN;
  IF NOT EXISTS(lr)
  THEN
    RETURN(false);
  END_IF;
  REPEAT j := 2 TO SIZEOF(lr);
    IF lr[j] < lr[j - 1]
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION no_cyclic_domain_reference(ref : maths_space_or_function;
                                    used : SET OF maths_function) : BOOLEAN;
LOCAL
  typenames : SET OF STRING  := TYPEOF(ref);
  func      : maths_function;
END_LOCAL;
  IF (NOT EXISTS(ref)) OR (NOT EXISTS(used))
  THEN
    RETURN(false);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames
  THEN
    RETURN(true);
  END_IF;
  func := ref;
  IF func IN used
  THEN
    RETURN(false);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\constant_function.source_of_domain, used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\selector_function.source_of_domain, used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames
  THEN
    RETURN(no_cyclic_domain_reference(func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION no_cyclic_space_reference(spc : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
LOCAL
  types     : SET OF STRING;
  refs_plus : SET OF maths_space;
END_LOCAL;
  IF (spc IN refs)
  THEN
    RETURN(false);
  END_IF;
  types := TYPEOF(spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types
  THEN
    RETURN(bool(
           SIZEOF(
           QUERY(sp <* QUERY(mem <* spc\finite_space.members | (schema_prefix + 'MATHS_SPACE') IN
                                                               TYPEOF(mem)) | NOT no_cyclic_space_reference(sp,
                                                                                  refs_plus))) =
           0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types
  THEN
    RETURN(no_cyclic_space_reference(spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types
  THEN
    RETURN(bool(
           SIZEOF(QUERY(fac <* spc\listed_product_space.factors | NOT no_cyclic_space_reference(fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    RETURN(no_cyclic_space_reference(spc\extended_tuple_space.base, refs_plus) AND
           no_cyclic_space_reference(spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION number_superspace_of(spc : maths_space) : elementary_space;
  IF subspace_of_es(spc, es_integers)
  THEN
    RETURN(the_integers);
  END_IF;
  IF subspace_of_es(spc, es_reals)
  THEN
    RETURN(the_reals);
  END_IF;
  IF subspace_of_es(spc, es_complex_numbers)
  THEN
    RETURN(the_complex_numbers);
  END_IF;
  IF subspace_of_es(spc, es_numbers)
  THEN
    RETURN(the_numbers);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION number_tuple_subspace_check(spc : maths_space) : LOGICAL;
LOCAL
  types   : SET OF STRING       := stripped_typeof(spc);
  factors : LIST OF maths_space;
  cum     : LOGICAL             := true;
END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types
  THEN
    RETURN(subspace_of_es(spc\uniform_product_space.base, es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types
  THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      cum := cum AND subspace_of_es(factors[i], es_numbers);
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types
  THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender, es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN(cum);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION one_tuples_of(spc : maths_space) : tuple_space;
  RETURN(make_uniform_product_space(spc, 1));
END_FUNCTION;

FUNCTION parallel_composed_function_composability_check(funcs : LIST OF maths_function;
                                                        final : maths_function_select) : BOOLEAN;
LOCAL
  tplsp  : tuple_space := the_zero_tuple_space;
  finfun : maths_function := convert_to_maths_function(final);
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(funcs);
    tplsp := assoc_product_space(tplsp, funcs[i].range);
  END_REPEAT;
  RETURN(compatible_spaces(tplsp, finfun.domain));
END_FUNCTION;

FUNCTION parallel_composed_function_domain_check(comdom : tuple_space;
                                                 funcs : LIST OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(funcs);
    IF NOT (compatible_spaces(comdom, funcs[i].domain))
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION parse_express_identifier(s : STRING;
                                  i : positive_integer) : positive_integer;
LOCAL
  k : positive_integer;
END_LOCAL;
  k := i;
  IF i <= LENGTH(s)
  THEN
    IF (s[i] LIKE '@')
    THEN
      REPEAT UNTIL (k > LENGTH(s)) OR ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(k);
END_FUNCTION;

FUNCTION partial_derivative_check(domain : tuple_space;
                                  d_vars : LIST [1:?] OF input_selector) : BOOLEAN;
LOCAL
  domn : tuple_space := domain;
  fspc : maths_space;
  dim  : INTEGER;
  k    : INTEGER;
END_LOCAL;
  IF (space_dimension(domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(domain)))
  THEN
    domn := factor1(domain);
  END_IF;
  dim := space_dimension(domn);
  REPEAT i := 1 TO SIZEOF(d_vars);
    k := d_vars[i];
    IF k > dim
    THEN
      RETURN(false);
    END_IF;
    fspc := factor_space(domn, k);
    IF (NOT subspace_of_es(fspc, es_reals)) AND (NOT subspace_of_es(fspc, es_complex_numbers))
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION real_max(spc : maths_space) : REAL;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)
  THEN
    RETURN(spc\real_interval_to_max.max);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION real_min(spc : maths_space) : REAL;
LOCAL
  types : SET OF STRING := TYPEOF(spc);
END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types)
  THEN
    RETURN(spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)
  THEN
    RETURN(spc\real_interval_from_min.min);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION regular_indexing(sub : LIST OF INTEGER;
                          base : zero_or_one;
                          shape : LIST [1:?] OF positive_integer;
                          inc : LIST [1:?] OF INTEGER;
                          first : INTEGER) : INTEGER;
LOCAL
  k     : INTEGER;
  index : INTEGER;
END_LOCAL;
  IF NOT EXISTS(sub) OR NOT EXISTS(base) OR NOT EXISTS(shape) OR NOT EXISTS(inc) OR NOT EXISTS(first)
  THEN
    RETURN(?);
  END_IF;
  IF (SIZEOF(sub) <> SIZEOF(inc)) OR (SIZEOF(sub) <> SIZEOF(shape))
  THEN
    RETURN(?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF(sub);
    IF NOT EXISTS(sub[j]) OR NOT EXISTS(inc[j])
    THEN
      RETURN(?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]})
    THEN
      RETURN(?);
    END_IF;
    index := index + k * inc[j];
  END_REPEAT;
  RETURN(index);
END_FUNCTION;

FUNCTION remove_first(alist : LIST OF GENERIC:gen) : LIST OF GENERIC:gen;
LOCAL
  blist : LIST OF GENERIC:gen := alist;
END_LOCAL;
  IF SIZEOF(blist) > 0
  THEN
    REMOVE(blist, 1);
  END_IF;
  RETURN(blist);
END_FUNCTION;

FUNCTION repackage(tspace : tuple_space;
                   repckg : repackage_options) : tuple_space;
  CASE repckg OF
    ro_nochange : RETURN(tspace);
    ro_wrap_as_tuple : RETURN(one_tuples_of(tspace));
    ro_unwrap_tuple : RETURN(factor1(tspace));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION shape_of_array(func : maths_function) : LIST OF positive_integer;
LOCAL
  tspace : tuple_space;
  temp   : maths_space;
  result : LIST OF positive_integer := [];
END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF(func)
  THEN
    RETURN(func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF(factor1(tspace)))
  THEN
    tspace := factor1(tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension(tspace);
    temp := factor_space(tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF(temp))
    THEN
      RETURN(?);
    END_IF;
    INSERT(result, temp\finite_integer_interval.size, i - 1);
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

FUNCTION simplify_function_application(expr : function_application) : maths_value;
FUNCTION ctmv(x : GENERIC:g) : maths_value;
  RETURN(convert_to_maths_value(x));
END_FUNCTION;
PROCEDURE parts(c : complex_number_literal; VAR x : REAL; VAR y : REAL);
  x := c.real_part;
  y := c.imag_part;
END_PROCEDURE;
FUNCTION makec(x : REAL;
               y : REAL) : complex_number_literal;
  RETURN(make_complex_number_literal(x, y));
END_FUNCTION;
FUNCTION good_t(v : maths_value;
                tn : STRING) : BOOLEAN;
LOCAL
  tpl : LIST OF maths_value;
END_LOCAL;
  IF 'LIST' IN TYPEOF(v)
  THEN
    tpl := v;
    REPEAT i := 1 TO SIZEOF(tpl);
      IF NOT (tn IN TYPEOF(tpl[i]))
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(true);
  END_IF;
  RETURN(false);
END_FUNCTION;

CONSTANT
  cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
END_CONSTANT;
LOCAL
  types         : SET OF STRING                          := stripped_typeof(expr.func);
  ef_val        : elementary_function_enumerators;
  is_elementary : BOOLEAN                                := false;
  v             : maths_value;
  v1            : maths_value;
  v2            : maths_value;
  v3            : maths_value;
  vlist         : LIST OF maths_value                    := [];
  gexpr         : generic_expression;
  pairs         : SET [1:?] OF LIST [2:2] OF maths_value;
  boo           : BOOLEAN;
  lgc           : LOGICAL;
  cum           : LOGICAL;
  j             : INTEGER;
  k             : INTEGER;
  n             : INTEGER;
  p             : REAL;
  q             : REAL;
  r             : REAL;
  s             : REAL;
  t             : REAL;
  u             : REAL;
  str           : STRING;
  st2           : STRING;
  bin           : BINARY;
  bi2           : BINARY;
  tpl           : LIST OF maths_value;
  tp2           : LIST OF maths_value;
  mem           : SET OF maths_value                     := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT(vlist, v, i - 1);
  END_REPEAT;
  IF SIZEOF(vlist) >= 1
  THEN
    v1 := vlist[1];
  END_IF;
  IF SIZEOF(vlist) >= 2
  THEN
    v2 := vlist[2];
  END_IF;
  IF SIZEOF(vlist) >= 3
  THEN
    v3 := vlist[3];
  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types
  THEN
    ef_val := expr.func;
    is_elementary := true;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types
  THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := true;
  END_IF;
  IF is_elementary
  THEN
    CASE ef_val OF
      ef_and : BEGIN  
                      cum := true;
                      REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                        IF 'LOGICAL' IN TYPEOF(vlist[i])
                        THEN
                          lgc := vlist[i];
                          cum := cum AND lgc;
                          IF lgc = false
                          THEN
                            RETURN(ctmv(false));
                          END_IF;
                          REMOVE(vlist, i);
                        END_IF;
                      END_REPEAT;
                      IF SIZEOF(vlist) = 0
                      THEN
                        RETURN(ctmv(cum));
                      END_IF;
                      IF cum <> true
                      THEN
                        INSERT(vlist, ctmv(cum), 0);
                      END_IF;
                      IF SIZEOF(vlist) = 1
                      THEN
                        RETURN(vlist[1]);
                      END_IF;
      END;
      ef_or : BEGIN  
                     cum := false;
                     REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                       IF 'LOGICAL' IN TYPEOF(vlist[i])
                       THEN
                         lgc := vlist[i];
                         cum := cum OR lgc;
                         IF lgc = true
                         THEN
                           RETURN(ctmv(true));
                         END_IF;
                         REMOVE(vlist, i);
                       END_IF;
                     END_REPEAT;
                     IF SIZEOF(vlist) = 0
                     THEN
                       RETURN(ctmv(cum));
                     END_IF;
                     IF cum <> false
                     THEN
                       INSERT(vlist, ctmv(cum), 0);
                     END_IF;
                     IF SIZEOF(vlist) = 1
                     THEN
                       RETURN(vlist[1]);
                     END_IF;
      END;
      ef_not : IF 'LOGICAL' IN TYPEOF(v1)
      THEN
        lgc := v1;
        RETURN(ctmv(NOT lgc));
      END_IF;
      ef_xor : BEGIN  
                      IF 'LOGICAL' IN TYPEOF(v1)
                      THEN
                        lgc := v1;
                        IF 'LOGICAL' IN TYPEOF(v2)
                        THEN
                          cum := v2;
                          RETURN(ctmv(lgc XOR cum));
                        ELSE
                          IF lgc = false
                          THEN
                            RETURN(ctmv(v2));
                          ELSE
                            IF lgc = unknown
                            THEN
                              RETURN(ctmv(unknown));
                            ELSE
                              RETURN(make_function_application(ef_not, [v2]));
                            END_IF;
                          END_IF;
                        END_IF;
                      ELSE
                        IF 'LOGICAL' IN TYPEOF(v2)
                        THEN
                          lgc := v2;
                          IF lgc = false
                          THEN
                            RETURN(ctmv(v1));
                          ELSE
                            IF lgc = unknown
                            THEN
                              RETURN(ctmv(unknown));
                            ELSE
                              RETURN(make_function_application(ef_not, [v1]));
                            END_IF;
                          END_IF;
                        END_IF;
                      END_IF;
      END;
      ef_negate_i : IF 'INTEGER' IN TYPEOF(v1)
      THEN
        j := v1;
        RETURN(ctmv(-j));
      END_IF;
      ef_add_i : BEGIN  
                        j := 0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            k := vlist[i];
                            j := j + k;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF j <> 0
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j - k));
      END_IF;
      ef_multiply_i : BEGIN  
                             j := 1;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF 'INTEGER' IN TYPEOF(vlist[i])
                               THEN
                                 k := vlist[i];
                                 j := j * k;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(ctmv(j));
                             END_IF;
                             IF j <> 1
                             THEN
                               INSERT(vlist, ctmv(j), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j DIV k));
      END_IF;
      ef_mod_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j MOD k));
      END_IF;
      ef_exponentiate_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        n := 1;
        REPEAT i := 1 TO ABS(k);
          n := n * j;
        END_REPEAT;
        IF k < 0
        THEN
          n := 1 DIV n;
        END_IF;
        RETURN(ctmv(n));
      END_IF;
      ef_eq_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j = k));
      END_IF;
      ef_ne_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j <> k));
      END_IF;
      ef_gt_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j > k));
      END_IF;
      ef_lt_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j < k));
      END_IF;
      ef_ge_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j >= k));
      END_IF;
      ef_le_i : IF ('INTEGER' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        j := v1;
        k := v2;
        RETURN(ctmv(j <= k));
      END_IF;
      ef_abs_i : IF 'INTEGER' IN TYPEOF(v1)
      THEN
        j := v1;
        RETURN(ctmv(ABS(j)));
      END_IF;
      ef_max_i : BEGIN  
                        boo := false;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              k := vlist[i];
                              IF k > j
                              THEN
                                j := k;
                              END_IF;
                            ELSE
                              j := vlist[i];
                              boo := true;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_min_i : BEGIN  
                        boo := false;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'INTEGER' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              k := vlist[i];
                              IF k < j
                              THEN
                                j := k;
                              END_IF;
                            ELSE
                              j := vlist[i];
                              boo := true;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(j));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(j), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_negate_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(-r));
      END_IF;
      ef_reciprocal_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(1.0 / r));
      END_IF;
      ef_add_r : BEGIN  
                        r := 0.0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            s := vlist[i];
                            r := r + s;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF r <> 0.0
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r - s));
      END_IF;
      ef_multiply_r : BEGIN  
                             r := 1.0;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF 'REAL' IN TYPEOF(vlist[i])
                               THEN
                                 s := vlist[i];
                                 r := r * s;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(ctmv(r));
                             END_IF;
                             IF r <> 1.0
                             THEN
                               INSERT(vlist, ctmv(r), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r / s));
      END_IF;
      ef_mod_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        t := r / s;
        j := t DIV 1;
        IF (t < 0.0) AND (j <> t)
        THEN
          j := j - 1;
        END_IF;
        RETURN(ctmv(r - j * s));
      END_IF;
      ef_exponentiate_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r ** s));
      END_IF;
      ef_exponentiate_ri : IF ('REAL' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        r := v1;
        k := v2;
        t := 1.0;
        REPEAT i := 1 TO ABS(k);
          t := t * r;
        END_REPEAT;
        IF k < 0
        THEN
          t := 1.0 / t;
        END_IF;
        RETURN(ctmv(t));
      END_IF;
      ef_eq_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r = s));
      END_IF;
      ef_ne_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r <> s));
      END_IF;
      ef_gt_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r > s));
      END_IF;
      ef_lt_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r < s));
      END_IF;
      ef_ge_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r >= s));
      END_IF;
      ef_le_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(r <= s));
      END_IF;
      ef_abs_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ABS(r)));
      END_IF;
      ef_max_r : BEGIN  
                        boo := false;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              s := vlist[i];
                              IF s > r
                              THEN
                                r := s;
                              END_IF;
                            ELSE
                              r := vlist[i];
                              boo := true;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_min_r : BEGIN  
                        boo := false;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF 'REAL' IN TYPEOF(vlist[i])
                          THEN
                            IF boo
                            THEN
                              s := vlist[i];
                              IF s < r
                              THEN
                                r := s;
                              END_IF;
                            ELSE
                              r := vlist[i];
                              boo := true;
                            END_IF;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(ctmv(r));
                        END_IF;
                        IF boo
                        THEN
                          INSERT(vlist, ctmv(r), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_acos_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ACOS(r)));
      END_IF;
      ef_asin_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(ASIN(r)));
      END_IF;
      ef_atan2_r : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(ctmv(atan2(r, s)));
      END_IF;
      ef_cos_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(COS(r)));
      END_IF;
      ef_exp_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(EXP(r)));
      END_IF;
      ef_ln_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG(r)));
      END_IF;
      ef_log2_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG2(r)));
      END_IF;
      ef_log10_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(LOG10(r)));
      END_IF;
      ef_sin_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(SIN(r)));
      END_IF;
      ef_sqrt_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_tan_r : IF 'REAL' IN TYPEOF(v1)
      THEN
        r := v1;
        RETURN(ctmv(TAN(r)));
      END_IF;
      ef_form_c : IF ('REAL' IN TYPEOF(v1)) AND ('REAL' IN TYPEOF(v2))
      THEN
        r := v1;
        s := v2;
        RETURN(makec(r, s));
      END_IF;
      ef_rpart_c : IF cnlit IN TYPEOF(v1)
      THEN
        RETURN(ctmv(v1\complex_number_literal.real_part));
      END_IF;
      ef_ipart_c : IF cnlit IN TYPEOF(v1)
      THEN
        RETURN(ctmv(v1\complex_number_literal.imag_part));
      END_IF;
      ef_negate_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(-p, -q));
      END_IF;
      ef_reciprocal_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := p * p + q * q;
        RETURN(makec(p / t, -q / t));
      END_IF;
      ef_add_c : BEGIN  
                        p := 0.0;
                        q := 0.0;
                        REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                          IF cnlit IN TYPEOF(vlist[i])
                          THEN
                            parts(vlist[i], r, s);
                            p := p + r;
                            q := q + s;
                            REMOVE(vlist, i);
                          END_IF;
                        END_REPEAT;
                        IF SIZEOF(vlist) = 0
                        THEN
                          RETURN(makec(p, q));
                        END_IF;
                        IF p * p + q * q <> 0.0
                        THEN
                          INSERT(vlist, makec(p, q), 0);
                        END_IF;
                        IF SIZEOF(vlist) = 1
                        THEN
                          RETURN(vlist[1]);
                        END_IF;
      END;
      ef_subtract_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(makec(p - r, q - s));
      END_IF;
      ef_multiply_c : BEGIN  
                             p := 1.0;
                             q := 0.0;
                             REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                               IF cnlit IN TYPEOF(vlist[i])
                               THEN
                                 parts(vlist[i], r, s);
                                 p := p * r - q * s;
                                 q := p * s + q * r;
                                 REMOVE(vlist, i);
                               END_IF;
                             END_REPEAT;
                             IF SIZEOF(vlist) = 0
                             THEN
                               RETURN(makec(p, q));
                             END_IF;
                             IF (p <> 1.0) OR (q <> 0.0)
                             THEN
                               INSERT(vlist, makec(p, q), 0);
                             END_IF;
                             IF SIZEOF(vlist) = 1
                             THEN
                               RETURN(vlist[1]);
                             END_IF;
      END;
      ef_divide_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        t := r * r + s * s;
        RETURN(makec((p * r + q * s) / t, (q * r - p * s) / t));
      END_IF;
      ef_exponentiate_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        t := 0.5 * LOG(p * p + q * q);
        u := atan2(q, p);
        p := r * t - s * u;
        q := r * u + s * t;
        r := EXP(p);
        RETURN(makec(r * COS(q), r * SIN(q)));
      END_IF;
      ef_exponentiate_ci : IF (cnlit IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        k := v2;
        r := 1.0;
        s := 0.0;
        REPEAT i := 1 TO ABS(k);
          r := p * r - q * s;
          s := p * s + q * r;
        END_REPEAT;
        IF k < 0
        THEN
          t := r * r + s * s;
          r := r / t;
          s := -s / t;
        END_IF;
        RETURN(makec(r, s));
      END_IF;
      ef_eq_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(ctmv((p = r) AND (q = s)));
      END_IF;
      ef_ne_c : IF (cnlit IN TYPEOF(v1)) AND (cnlit IN TYPEOF(v2))
      THEN
        parts(v1, p, q);
        parts(v2, r, s);
        RETURN(ctmv((p <> r) OR (q <> s)));
      END_IF;
      ef_conjugate_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(p, -q));
      END_IF;
      ef_abs_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(ctmv(SQRT(p * p + q * q)));
      END_IF;
      ef_arg_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(ctmv(atan2(q, p)));
      END_IF;
      ef_cos_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := 0.5 * EXP(-q);
        u := 0.5 * EXP(q);
        RETURN(makec((t + u) * COS(p), (t - u) * SIN(p)));
      END_IF;
      ef_exp_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(EXP(p) * COS(q), EXP(p) * SIN(q)));
      END_IF;
      ef_ln_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        RETURN(makec(0.5 * LOG(p * p + q * q), atan2(q, p)));
      END_IF;
      ef_sin_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := 0.5 * EXP(-q);
        u := 0.5 * EXP(q);
        RETURN(makec((t + u) * SIN(p), (u - t) * COS(p)));
      END_IF;
      ef_sqrt_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := SQRT(SQRT(p * p + q * q));
        u := 0.5 * atan2(q, p);
        RETURN(makec(t * COS(u), t * SIN(u)));
      END_IF;
      ef_tan_c : IF cnlit IN TYPEOF(v1)
      THEN
        parts(v1, p, q);
        t := EXP(2.0 * q) + EXP(-2.0 * q) + 2.0 * COS(2.0 * p);
        RETURN(makec(2.0 * SIN(2.0 * p) / t, (EXP(-2.0 * q) - EXP(2.0 * q)) / t));
      END_IF;
      ef_subscript_s : IF ('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        str := v1;
        k := v2;
        RETURN(ctmv(str[k]));
      END_IF;
      ef_eq_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str = st2));
      END_IF;
      ef_ne_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str <> st2));
      END_IF;
      ef_gt_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str > st2));
      END_IF;
      ef_lt_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str < st2));
      END_IF;
      ef_ge_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str >= st2));
      END_IF;
      ef_le_s : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        str := v1;
        st2 := v2;
        RETURN(ctmv(str <= st2));
      END_IF;
      ef_subsequence_s : IF ('STRING' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        str := v1;
        j := v2;
        k := v3;
        RETURN(ctmv(str[j:k]));
      END_IF;
      ef_concat_s : BEGIN  
                           str := '';
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'STRING' IN TYPEOF(vlist[i])
                             THEN
                               st2 := vlist[i];
                               str := str + st2;
                               REMOVE(vlist, i);
                             ELSE
                               IF str <> ''
                               THEN
                                 INSERT(vlist, ctmv(str), i);
                                 str := '';
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(str));
                           END_IF;
                           IF str <> ''
                           THEN
                             INSERT(vlist, ctmv(str), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_s : IF 'STRING' IN TYPEOF(v1)
      THEN
        str := v1;
        RETURN(ctmv(LENGTH(str)));
      END_IF;
      ef_format : IF ('NUMBER' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        RETURN(ctmv(FORMAT(v1, v2)));
      END_IF;
      ef_value : IF 'STRING' IN TYPEOF(v1)
      THEN
        str := v1;
        RETURN(ctmv(VALUE(str)));
      END_IF;
      ef_like : IF ('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
      THEN
        RETURN(ctmv(v1 LIKE v2));
      END_IF;
      ef_subscript_b : IF ('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        bin := v1;
        k := v2;
        RETURN(ctmv(bin[k]));
      END_IF;
      ef_eq_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin = bi2));
      END_IF;
      ef_ne_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin <> bi2));
      END_IF;
      ef_gt_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin > bi2));
      END_IF;
      ef_lt_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin < bi2));
      END_IF;
      ef_ge_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin >= bi2));
      END_IF;
      ef_le_b : IF ('BINARY' IN TYPEOF(v1)) AND ('BINARY' IN TYPEOF(v2))
      THEN
        bin := v1;
        bi2 := v2;
        RETURN(ctmv(bin <= bi2));
      END_IF;
      ef_subsequence_b : IF ('BINARY' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        bin := v1;
        j := v2;
        k := v3;
        RETURN(ctmv(bin[j:k]));
      END_IF;
      ef_concat_b : BEGIN  
                           boo := false;
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'BINARY' IN TYPEOF(vlist[i])
                             THEN
                               IF boo
                               THEN
                                 bi2 := vlist[i];
                                 bin := bin + bi2;
                               ELSE
                                 bin := vlist[i];
                                 boo := true;
                               END_IF;
                               REMOVE(vlist, i);
                             ELSE
                               IF boo
                               THEN
                                 INSERT(vlist, ctmv(bin), i);
                                 boo := false;
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(bin));
                           END_IF;
                           IF boo
                           THEN
                             INSERT(vlist, ctmv(bin), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_b : IF 'BINARY' IN TYPEOF(v1)
      THEN
        bin := v1;
        RETURN(ctmv(BLENGTH(bin)));
      END_IF;
      ef_subscript_t : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        tpl := v1;
        k := v2;
        RETURN(ctmv(tpl[k]));
      END_IF;
      ef_eq_t : IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2))
      THEN
        lgc := equal_maths_values(v1, v2);
        IF lgc <> unknown
        THEN
          RETURN(ctmv(lgc));
        END_IF;
      END_IF;
      ef_ne_t : IF ('LIST' IN TYPEOF(v1)) AND ('LIST' IN TYPEOF(v2))
      THEN
        lgc := equal_maths_values(v1, v2);
        IF lgc <> unknown
        THEN
          RETURN(ctmv(NOT lgc));
        END_IF;
      END_IF;
      ef_concat_t : BEGIN  
                           tpl := [];
                           REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                             IF 'STRING' IN TYPEOF(vlist[i])
                             THEN
                               tp2 := vlist[i];
                               tpl := tpl + tp2;
                               REMOVE(vlist, i);
                             ELSE
                               IF SIZEOF(tpl) <> 0
                               THEN
                                 INSERT(vlist, ctmv(tpl), i);
                                 tpl := [];
                               END_IF;
                             END_IF;
                           END_REPEAT;
                           IF SIZEOF(vlist) = 0
                           THEN
                             RETURN(ctmv(tpl));
                           END_IF;
                           IF SIZEOF(tpl) <> 0
                           THEN
                             INSERT(vlist, ctmv(tpl), 0);
                           END_IF;
                           IF SIZEOF(vlist) = 1
                           THEN
                             RETURN(vlist[1]);
                           END_IF;
      END;
      ef_size_t : IF 'LIST' IN TYPEOF(v1)
      THEN
        tpl := v1;
        RETURN(ctmv(SIZEOF(tpl)));
      END_IF;
      ef_entuple : RETURN(ctmv(vlist));
      ef_detuple : IF 'LIST' IN TYPEOF(v1)
      THEN
        tpl := v1;
        RETURN(ctmv(tpl[1]));
      END_IF;
      ef_insert : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v3))
      THEN
        tpl := v1;
        k := v3;
        INSERT(tpl, v2, k);
        RETURN(ctmv(tpl));
      END_IF;
      ef_remove : IF ('LIST' IN TYPEOF(v1)) AND ('INTEGER' IN TYPEOF(v2))
      THEN
        tpl := v1;
        k := v2;
        REMOVE(tpl, k);
        RETURN(ctmv(tpl));
      END_IF;
      ef_sum_it : IF good_t(v1, 'INTEGER')
      THEN
        tpl := v1;
        j := 0;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j + tpl[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_product_it : IF good_t(v1, 'INTEGER')
      THEN
        tpl := v1;
        j := 1;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j * tpl[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_add_it : BEGIN  
                         boo := false;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], 'INTEGER')
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := true;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_it : IF good_t(v1, 'INTEGER') AND good_t(v2, 'INTEGER')
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := tpl[i] - tp2[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_it : IF ('INTEGER' IN TYPEOF(v1)) AND good_t(v2, 'INTEGER')
      THEN
        j := v1;
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := j * tpl[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_it : IF good_t(v1, 'INTEGER') AND good_t(v2, 'INTEGER')
      THEN
        tpl := v1;
        tp2 := v2;
        j := 0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          j := j + tpl[i] * tp2[i];
        END_REPEAT;
        RETURN(ctmv(j));
      END_IF;
      ef_sum_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_product_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 1.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r * tpl[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_add_rt : BEGIN  
                         boo := false;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], 'REAL')
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := true;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 tpl[j] := tpl[j] + tp2[j];
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_rt : IF good_t(v1, 'REAL') AND good_t(v2, 'REAL')
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := tpl[i] - tp2[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_rt : IF ('REAL' IN TYPEOF(v1)) AND good_t(v2, 'REAL')
      THEN
        r := v1;
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          tpl[i] := r * tpl[i];
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_rt : IF good_t(v1, 'REAL') AND good_t(v2, 'REAL')
      THEN
        tpl := v1;
        tp2 := v2;
        r := 0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i] * tp2[i];
        END_REPEAT;
        RETURN(ctmv(r));
      END_IF;
      ef_norm_rt : IF good_t(v1, 'REAL')
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          r := r + tpl[i] * tpl[i];
        END_REPEAT;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_sum_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        p := 0.0;
        q := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          p := p + r;
          q := q + s;
        END_REPEAT;
        RETURN(makec(p, q));
      END_IF;
      ef_product_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        p := 1.0;
        q := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          p := p * r - q * s;
          q := p * s + q * r;
        END_REPEAT;
        RETURN(makec(p, q));
      END_IF;
      ef_add_ct : BEGIN  
                         boo := false;
                         REPEAT i := SIZEOF(vlist) TO 1 BY -1;
                           IF good_t(vlist[i], cnlit)
                           THEN
                             IF NOT boo
                             THEN
                               tpl := vlist[i];
                               boo := true;
                             ELSE
                               tp2 := vlist[i];
                               IF SIZEOF(tpl) <> SIZEOF(tp2)
                               THEN
                                 RETURN(?);
                               END_IF;
                               REPEAT l := 1 TO SIZEOF(tpl);
                                 parts(tpl[j], p, q);
                                 parts(tp2[j], r, s);
                                 tpl[j] := makec(p + r, q + s);
                               END_REPEAT;
                             END_IF;
                             REMOVE(vlist, i);
                           END_IF;
                         END_REPEAT;
                         IF SIZEOF(vlist) = 0
                         THEN
                           RETURN(ctmv(tpl));
                         END_IF;
                         IF boo
                         THEN
                           INSERT(vlist, ctmv(tpl), 0);
                         END_IF;
                         IF SIZEOF(vlist) = 1
                         THEN
                           RETURN(vlist[1]);
                         END_IF;
      END;
      ef_subtract_ct : IF good_t(v1, cnlit) AND good_t(v2, cnlit)
      THEN
        tpl := v1;
        tp2 := v2;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          parts(tp2[i], r, s);
          tpl[i] := makec(p - r, q - s);
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_scalar_mult_ct : IF (cnlit IN TYPEOF(v1)) AND good_t(v2, cnlit)
      THEN
        parts(v1, p, q);
        tpl := v2;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], r, s);
          tpl[i] := makec(p * r - q * s, p * s + q * r);
        END_REPEAT;
        RETURN(ctmv(tpl));
      END_IF;
      ef_dot_prod_ct : IF good_t(v1, cnlit) AND good_t(v2, cnlit)
      THEN
        tpl := v1;
        tp2 := v2;
        t := 0.0;
        u := 0.0;
        IF SIZEOF(tpl) <> SIZEOF(tp2)
        THEN
          RETURN(?);
        END_IF;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          parts(tp2[i], r, s);
          t := t + p * r + q * s;
          u := u + q * r - p * s;
        END_REPEAT;
        RETURN(makec(t, u));
      END_IF;
      ef_norm_ct : IF good_t(v1, cnlit)
      THEN
        tpl := v1;
        r := 0.0;
        REPEAT i := 1 TO SIZEOF(tpl);
          parts(tpl[i], p, q);
          r := r + p * p + q * q;
        END_REPEAT;
        RETURN(ctmv(SQRT(r)));
      END_IF;
      ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t : IF 'LOGICAL' IN TYPEOF(v1)
      THEN
        lgc := v1;
        IF lgc
        THEN
          RETURN(v2);
        ELSE
          RETURN(v3);
        END_IF;
      END_IF;
      ef_ensemble : RETURN(make_finite_space(mem + vlist));
      ef_member_of : IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF(v2)
      THEN
        lgc := member_of(v1, v2);
        IF lgc <> unknown
        THEN
          RETURN(ctmv(lgc));
        END_IF;
      END_IF;
    END_CASE;
    RETURN(make_function_application(expr.func, vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types
  THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr, expr.func\quantifier_expression.variables,
             vlist);
    RETURN(simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types
  THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF(pairs);
      IF equal_maths_values(vlist[1], pairs[i][1])
      THEN
        RETURN(simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN(make_function_application(expr.func, vlist));
  END_IF;
  RETURN(expr);
END_FUNCTION;

FUNCTION simplify_generic_expression(expr : generic_expression) : maths_value;
FUNCTION restore_unary(expr : unary_generic_expression;
                       opnd : generic_expression) : generic_expression;
  expr.operand := opnd;
  RETURN(expr);
END_FUNCTION;
FUNCTION restore_binary(expr : binary_generic_expression;
                        opd1 : generic_expression;
                        opd2 : generic_expression) : generic_expression;
  expr.operands[1] := opd1;
  expr.operands[2] := opd2;
  RETURN(expr);
END_FUNCTION;
FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                        ops : LIST OF generic_expression) : generic_expression;
  expr.operands := ops;
  RETURN(expr);
END_FUNCTION;
FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
  IF 'INTEGER' IN TYPEOF(nmb)
  THEN
    RETURN(make_int_literal(nmb));
  END_IF;
  RETURN(make_real_literal(nmb));
END_FUNCTION;
LOCAL
  types  : SET OF STRING                    := stripped_typeof(expr);
  v1     : maths_value;
  v2     : maths_value;
  vlist  : LIST OF maths_value              := [];
  op1    : generic_expression;
  op2    : generic_expression;
  oplist : LIST OF generic_expression       := [];
  opnds  : LIST [2:?] OF generic_expression;
  n      : INTEGER;
  m      : INTEGER;
  finfun : maths_function_select;
  boo    : BOOLEAN;
  str    : STRING;
  nmb    : NUMBER;
END_LOCAL;
  IF 'INT_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types
  THEN
    RETURN(expr);
  END_IF;
  IF 'LOGICAL_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types
  THEN
    RETURN(expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types
  THEN
    RETURN(expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types
  THEN
    RETURN(convert_to_maths_value(expr\maths_tuple_literal.lit_value));
  END_IF;
  IF 'MATHS_SPACE' IN types
  THEN
    RETURN(simplify_maths_space(expr));
  END_IF;
  IF 'FUNCTION_APPLICATION' IN types
  THEN
    RETURN(simplify_function_application(expr));
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT(vlist, v1, i - 1);
      INSERT(oplist, convert_to_operand(v1), i - 1);
    END_REPEAT;
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types
  THEN
    v1 := vlist[1];
    n := SIZEOF(vlist);
    finfun := vlist[n];
    REMOVE(vlist, n);
    REMOVE(vlist, 1);
    RETURN(make_parallel_composed_function(v1, vlist, finfun));
  END_IF;
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types
  THEN
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF(vlist[i])
      THEN
        boo := vlist[i];
        IF NOT boo
        THEN
          RETURN(convert_to_maths_value(false));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(true));
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(ATAN(v1, v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND
     ((('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))) OR
      (('STRING' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))) OR
      (('BOOLEAN' IN TYPEOF(v1)) AND ('BOOLEAN' IN TYPEOF(v2))))
  THEN
    IF 'COMPARISON_EQUAL' IN types
    THEN
      boo := bool(v1 = v2);
    ELSE
      IF 'COMPARISON_GREATER' IN types
      THEN
        boo := bool(v1 > v2);
      ELSE
        IF 'COMPARISON_GREATER_EQUAL' IN types
        THEN
          boo := bool(v1 >= v2);
        ELSE
          IF 'COMPARISON_LESS' IN types
          THEN
            boo := bool(v1 < v2);
          ELSE
            IF 'COMPARISON_LESS_EQUAL' IN types
            THEN
              boo := bool(v1 <= v2);
            ELSE
              IF 'COMPARISON_NOT_EQUAL' IN types
              THEN
                boo := bool(v1 <> v2);
              ELSE
                IF 'LIKE_EXPRESSION' IN types
                THEN
                  boo := bool(v1 LIKE v2);
                ELSE
                  RETURN(?);
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN(convert_to_maths_value(boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types
  THEN
    str := '';
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF(vlist[i])
      THEN
        str := vlist[i] + str;
        REMOVE(oplist, i);
      ELSE
        IF LENGTH(str) > 0
        THEN
          INSERT(oplist, make_string_literal(str), i);
          str := '';
        END_IF;
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(str));
    END_IF;
    IF LENGTH(str) > 0
    THEN
      INSERT(oplist, make_string_literal(str), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types
  THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN(convert_to_maths_value(opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('STRING' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(FORMAT(v1, v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    str := v1;
    n := v2;
    RETURN(convert_to_maths_value(str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types
  THEN
    str := '';
    IF 'NUMBER' IN TYPEOF(vlist[1])
    THEN
      str := 'NUMBER';
    END_IF;
    IF 'STRING' IN TYPEOF(vlist[1])
    THEN
      str := 'STRING';
    END_IF;
    IF 'BOOLEAN' IN TYPEOF(vlist[1])
    THEN
      str := 'BOOLEAN';
    END_IF;
    IF (LENGTH(str) > 0) AND (str IN TYPEOF(vlist[2])) AND (str IN TYPEOF(vlist[3]))
    THEN
      RETURN(convert_to_maths_value({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types
  THEN
    boo := false;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        IF boo
        THEN
          IF nmb < vlist[i]
          THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := true;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF boo
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types
  THEN
    boo := false;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        IF boo
        THEN
          IF nmb > vlist[i]
          THEN
            nmb := vlist[i];
          END_IF;
        ELSE
          nmb := vlist[i];
          boo := true;
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF boo
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types
  THEN
    nmb := 1;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        nmb := nmb * vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF nmb <> 1
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1))
  THEN
    boo := v1;
    RETURN(convert_to_maths_value(NOT (boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types
  THEN
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF(vlist[i])
      THEN
        boo := vlist[i];
        IF boo
        THEN
          RETURN(convert_to_maths_value(true));
        END_IF;
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(false));
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types
  THEN
    nmb := 0;
    REPEAT i := SIZEOF(vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF(vlist[i])
      THEN
        nmb := nmb + vlist[i];
        REMOVE(oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF(oplist) = 0
    THEN
      RETURN(convert_to_maths_value(nmb));
    END_IF;
    IF nmb <> 0
    THEN
      INSERT(oplist, make_number_literal(nmb), 0);
    END_IF;
    IF SIZEOF(oplist) = 1
    THEN
      RETURN(oplist[1]);
    END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1)) AND ('NUMBER' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(vlist[1])) AND ('NUMBER' IN TYPEOF(vlist[2])) AND
     ('NUMBER' IN TYPEOF(vlist[3]))
  THEN
    str := vlist[1];
    n := vlist[2];
    m := vlist[3];
    RETURN(convert_to_maths_value(str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF(v1))
  THEN
    nmb := v1;
    RETURN(convert_to_maths_value(-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF(v1))
  THEN
    RETURN(convert_to_maths_value(VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF(v1)) AND ('BOOLEAN' IN TYPEOF(v2))
  THEN
    RETURN(convert_to_maths_value(v1 XOR v2));
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_unary(expr, op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_binary(expr, op1, op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    RETURN(restore_mulary(expr, oplist));
  END_IF;
  RETURN(expr);
END_FUNCTION;

FUNCTION simplify_maths_space(spc : maths_space) : maths_space;
LOCAL
  stypes   : SET OF STRING       := stripped_typeof(spc);
  sset     : SET OF maths_value;
  zset     : SET OF maths_value  := [];
  zval     : maths_value;
  zspc     : maths_space;
  zallint  : BOOLEAN             := true;
  zint     : INTEGER;
  zmin     : INTEGER;
  zmax     : INTEGER;
  factors  : LIST OF maths_space;
  zfactors : LIST OF maths_space := [];
  rspc     : maths_space;
END_LOCAL;
  IF 'FINITE_SPACE' IN stypes
  THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF(sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF(zval))
      THEN
        zint := zval;
        IF i = 1
        THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin
          THEN
            zmin := zint;
          END_IF;
          IF zint > zmax
          THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := false;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax - zmin + 1)
    THEN
      RETURN(make_finite_integer_interval(zmin, zmax));
    END_IF;
    RETURN(make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN(make_uniform_product_space(zspc, spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes
  THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF(factors);
      INSERT(zfactors, simplify_maths_space(factors[i]), i - 1);
    END_REPEAT;
    RETURN(make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN(make_extended_tuple_space(zspc, rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes
  THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN(make_function_space(spc\function_space.domain_constraint, zspc, spc\function_space.range_constraint, rspc));
  END_IF;
  RETURN(spc);
END_FUNCTION;

FUNCTION simplify_maths_value(val : maths_value) : maths_value;
LOCAL
  vtypes : SET OF STRING       := stripped_typeof(val);
  vlist  : LIST OF maths_value;
  nlist  : LIST OF maths_value := [];
END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes
  THEN
    RETURN(simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes
  THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF(vlist);
      INSERT(nlist, simplify_maths_value(vlist[i]), i - 1);
    END_REPEAT;
    RETURN(convert_to_maths_value(nlist));
  END_IF;
  RETURN(val);
END_FUNCTION;

FUNCTION singleton_member_of(spc : maths_space) : maths_value;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF 'FINITE_SPACE' IN types
  THEN
    IF SIZEOF(spc\finite_space.members) = 1
    THEN
      RETURN(spc\finite_space.members[1]);
    END_IF;
    RETURN(?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types
  THEN
    IF spc\finite_integer_interval.size = 1
    THEN
      RETURN(spc\finite_integer_interval.min);
    END_IF;
    RETURN(?);
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION space_dimension(tspace : tuple_space) : nonnegative_integer;
LOCAL
  types : SET OF STRING := TYPEOF(tspace);
END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types
  THEN
    RETURN(tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types
  THEN
    RETURN(SIZEOF(tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types
  THEN
    RETURN(space_dimension(tspace\extended_tuple_space.base));
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION space_is_continuum(space : maths_space) : BOOLEAN;
LOCAL
  typenames : SET OF STRING       := TYPEOF(space);
  factors   : LIST OF maths_space;
END_LOCAL;
  IF NOT EXISTS(space)
  THEN
    RETURN(false);
  END_IF;
  IF subspace_of_es(space, es_reals) OR subspace_of_es(space, es_complex_numbers)
  THEN
    RETURN(true);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames
  THEN
    RETURN(space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames
  THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0
    THEN
      RETURN(false);
    END_IF;
    REPEAT i := 1 TO SIZEOF(factors);
      IF NOT space_is_continuum(factors[i])
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(true);
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION space_is_singleton(spc : maths_space) : BOOLEAN;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF 'FINITE_SPACE' IN types
  THEN
    RETURN(bool(SIZEOF(spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types
  THEN
    RETURN(bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION stripped_typeof(arg : GENERIC:g) : SET OF STRING;
LOCAL
  types  : SET OF STRING := TYPEOF(arg);
  stypes : SET OF STRING := [];
  n      : INTEGER       := LENGTH(schema_prefix);
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(types);
    IF types[i][1:n] = schema_prefix
    THEN
      stypes := stypes + types[i][n + 1:LENGTH(types[i])];
    ELSE
      stypes := stypes + types[i];
    END_IF;
  END_REPEAT;
  RETURN(stypes);
END_FUNCTION;

FUNCTION subspace_of(space1 : maths_space;
                     space2 : maths_space) : LOGICAL;
LOCAL
  spc1   : maths_space := simplify_maths_space(space1);
  spc2   : maths_space := simplify_maths_space(space2);
  types1 : SET OF STRING                := stripped_typeof(spc1);
  types2 : SET OF STRING                := stripped_typeof(spc2);
  lgcl   : LOGICAL;
  cum    : LOGICAL;
  es_val : elementary_space_enumerators;
  bnd1   : REAL;
  bnd2   : REAL;
  n      : INTEGER;
  sp1    : maths_space;
  sp2    : maths_space;
  prgn1  : polar_complex_number_region;
  prgn2  : polar_complex_number_region;
  aitv   : finite_real_interval;
END_LOCAL;
  IF NOT EXISTS(spc1) OR NOT EXISTS(spc2)
  THEN
    RETURN(false);
  END_IF;
  IF spc2 = the_generics
  THEN
    RETURN(true);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1
  THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2)
    THEN
      RETURN(false);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val
    THEN
      RETURN(true);
    END_IF;
    CASE spc1\elementary_space.space_id OF
      es_numbers : RETURN(false);
      es_complex_numbers : RETURN(es_val = es_numbers);
      es_reals : RETURN(es_val = es_numbers);
      es_integers : RETURN(es_val = es_numbers);
      es_logicals : RETURN(false);
      es_booleans : RETURN(es_val = es_logicals);
      es_strings : RETURN(false);
      es_binarys : RETURN(false);
      es_maths_spaces : RETURN(false);
      es_maths_functions : RETURN(false);
      es_generics : RETURN(false);
    END_CASE;
    RETURN(unknown);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1
  THEN
    cum := true;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of(i, spc2);
      IF cum = false
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2
    THEN
      RETURN(spc1\integer_interval_from_min.min >= spc2\integer_interval_from_min.min);
    END_IF;
    RETURN(false);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2
    THEN
      RETURN(spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN(false);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR ('REAL_INTERVAL_FROM_MIN' IN types2) OR ('REAL_INTERVAL_TO_MAX' IN types2)
    THEN
      IF min_exists(spc2)
      THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min(spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included(spc1) AND NOT min_included(spc2))
        THEN
          RETURN(false);
        END_IF;
      END_IF;
      IF max_exists(spc2)
      THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max(spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included(spc1) AND NOT max_included(spc2))
        THEN
          RETURN(false);
        END_IF;
      END_IF;
      RETURN(true);
    END_IF;
    RETURN(false);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2
    THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included(spc2) OR NOT min_included(spc1))));
    END_IF;
    RETURN(false);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2
    THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included(spc2) OR NOT max_included(spc1))));
    END_IF;
    RETURN(false);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(spc1\cartesian_complex_number_region.real_constraint,
             spc2\cartesian_complex_number_region.real_constraint) AND
             subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
             spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(enclose_cregion_in_pregion(spc1, spc2\polar_complex_number_region.centre), spc2));
    END_IF;
    RETURN(false);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      es_val := spc2\elementary_space.space_id;
      RETURN((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2
    THEN
      RETURN(subspace_of(enclose_pregion_in_cregion(spc1), spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2
    THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre
      THEN
        IF prgn2.direction_constraint.max > PI
        THEN
          aitv := make_finite_real_interval(-PI, open, prgn2.direction_constraint.max - 2.0 * PI,
                  prgn2.direction_constraint.max_closure);
          RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND
                 (subspace_of(prgn1.direction_constraint, prgn2.direction_constraint) OR
                  subspace_of(prgn1.direction_constraint, aitv)));
        ELSE
          RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint) AND
                 subspace_of(prgn1.direction_constraint, prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN(subspace_of(enclose_pregion_in_pregion(prgn1, prgn2.centre), prgn2));
    END_IF;
    RETURN(false);
  END_IF;
  IF 'FINITE_SPACE' IN types1
  THEN
    cum := true;
    REPEAT i := 1 TO SIZEOF(spc1\finite_space.members);
      cum := cum AND member_of(spc1\finite_space.members[i], spc2);
      IF cum = false
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
    RETURN(cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1
  THEN
    IF 'PRODUCT_SPACE' IN types2
    THEN
      IF space_dimension(spc1) = space_dimension(spc2)
      THEN
        cum := true;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = false
          THEN
            RETURN(false);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      IF space_dimension(spc1) >= space_dimension(spc2)
      THEN
        cum := true;
        REPEAT i := 1 TO space_dimension(spc1);
          cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
          IF cum = false
          THEN
            RETURN(false);
          END_IF;
        END_REPEAT;
        RETURN(cum);
      END_IF;
    END_IF;
    RETURN(false);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1
  THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2
    THEN
      n := space_dimension(spc1);
      IF n < space_dimension(spc2)
      THEN
        n := space_dimension(spc2);
      END_IF;
      cum := true;
      REPEAT i := 1 TO n + 1;
        cum := cum AND subspace_of(factor_space(spc1, i), factor_space(spc2, i));
        IF cum = false
        THEN
          RETURN(false);
        END_IF;
      END_REPEAT;
      RETURN(cum);
    END_IF;
    RETURN(false);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1
  THEN
    IF 'ELEMENTARY_SPACE' IN types2
    THEN
      RETURN(spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2
    THEN
      cum := true;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
        sc_equal : BEGIN  
                          CASE spc2\function_space.domain_constraint OF
                            sc_equal : cum := cum AND equal_maths_spaces(sp1, sp2);
                            sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                            sc_member : cum := cum AND member_of(sp1, sp2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE spc2\function_space.domain_constraint OF
                               sc_equal : RETURN(false);
                               sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                               sc_member : BEGIN  
                                                  IF NOT member_of(sp1, sp2)
                                                  THEN
                                                    RETURN(false);
                                                  END_IF;
                                                  cum := unknown;
                               END;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE spc2\function_space.domain_constraint OF
                             sc_equal : cum := cum AND space_is_singleton(sp1) AND
                                               equal_maths_spaces(singleton_member_of(sp1), sp2);
                             sc_subspace : BEGIN  
                                                  IF NOT member_of(sp2, sp1)
                                                  THEN
                                                    RETURN(false);
                                                  END_IF;
                                                  cum := unknown;
                             END;
                             sc_member : cum := cum AND (subspace_of(sp1, sp2));
                           END_CASE;
        END;
      END_CASE;
      IF cum = false
      THEN
        RETURN(false);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
        sc_equal : BEGIN  
                          CASE spc2\function_space.range_constraint OF
                            sc_equal : cum := cum AND equal_maths_spaces(sp1, sp2);
                            sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                            sc_member : cum := cum AND member_of(sp1, sp2);
                          END_CASE;
        END;
        sc_subspace : BEGIN  
                             CASE spc2\function_space.domain_constraint OF
                               sc_equal : RETURN(false);
                               sc_subspace : cum := cum AND subspace_of(sp1, sp2);
                               sc_member : BEGIN  
                                                  IF NOT member_of(sp1, sp2)
                                                  THEN
                                                    RETURN(false);
                                                  END_IF;
                                                  cum := unknown;
                               END;
                             END_CASE;
        END;
        sc_member : BEGIN  
                           CASE spc2\function_space.domain_constraint OF
                             sc_equal : cum := cum AND space_is_singleton(sp1) AND
                                               equal_maths_spaces(singleton_member_of(sp1), sp2);
                             sc_subspace : BEGIN  
                                                  IF NOT member_of(sp2, sp1)
                                                  THEN
                                                    RETURN(false);
                                                  END_IF;
                                                  cum := unknown;
                             END;
                             sc_member : cum := cum AND subspace_of(sp1, sp2);
                           END_CASE;
        END;
      END_CASE;
      RETURN(cum);
    END_IF;
    RETURN(false);
  END_IF;
  RETURN(unknown);
END_FUNCTION;

FUNCTION subspace_of_es(spc : maths_space;
                        es : elementary_space_enumerators) : LOGICAL;
LOCAL
  types : SET OF STRING := stripped_typeof(spc);
END_LOCAL;
  IF NOT EXISTS(spc) OR NOT EXISTS(es)
  THEN
    RETURN(false);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types
  THEN
    RETURN(es_subspace_of_es(spc\elementary_space.space_id, es));
  END_IF;
  IF 'FINITE_SPACE' IN types
  THEN
    RETURN(all_members_of_es(spc\finite_space.members, es));
  END_IF;
  CASE es OF
    es_numbers : RETURN(('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
                        ('INTEGER_INTERVAL_TO_MAX' IN types) OR ('FINITE_REAL_INTERVAL' IN types) OR
                        ('REAL_INTERVAL_FROM_MIN' IN types) OR ('REAL_INTERVAL_TO_MAX' IN types) OR
                        ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR ('POLAR_COMPLEX_NUMBER_REGION' IN types));
    es_complex_numbers : RETURN(('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
                                ('POLAR_COMPLEX_NUMBER_REGION' IN types));
    es_reals : RETURN(('FINITE_REAL_INTERVAL' IN types) OR ('REAL_INTERVAL_FROM_MIN' IN types) OR
                      ('REAL_INTERVAL_TO_MAX' IN types));
    es_integers : RETURN(('FINITE_INTEGER_INTERVAL' IN types) OR ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
                         ('INTEGER_INTERVAL_TO_MAX' IN types));
    es_logicals : RETURN(false);
    es_booleans : RETURN(false);
    es_strings : RETURN(false);
    es_binarys : RETURN(false);
    es_maths_spaces : RETURN(false);
    es_maths_functions : RETURN('FUNCTION_SPACE' IN types);
    es_generics : RETURN(true);
  END_CASE;
  RETURN(unknown);
END_FUNCTION;

FUNCTION substitute(expr : generic_expression;
                    vars : LIST [1:?] OF generic_variable;
                    vals : LIST [1:?] OF maths_value) : generic_expression;
LOCAL
  types  : SET OF STRING                := stripped_typeof(expr);
  opnds  : LIST OF generic_expression;
  op1    : generic_expression;
  op2    : generic_expression;
  qvars  : LIST OF generic_variable;
  srcdom : maths_space_or_function;
  prpfun : LIST [1:?] OF maths_function;
  finfun : maths_function_select;
END_LOCAL;
  IF SIZEOF(vars) <> SIZEOF(vals)
  THEN
    RETURN(?);
  END_IF;
  IF 'GENERIC_LITERAL' IN types
  THEN
    RETURN(expr);
  END_IF;
  IF 'GENERIC_VARIABLE' IN types
  THEN
    REPEAT i := 1 TO SIZEOF(vars);
      IF expr :=: vars[i]
      THEN
        RETURN(vals[i]);
      END_IF;
    END_REPEAT;
    RETURN(expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types
  THEN
    qvars := expr\quantifier_expression.variables;
    REPEAT i := SIZEOF(vars) TO 1 BY -1;
      IF vars[i] IN qvars
      THEN
        REMOVE(vars, i);
        REMOVE(vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      IF NOT (opnds[i] IN qvars)
      THEN
        expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
      END_IF;
    END_REPEAT;
    RETURN(expr);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types
  THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types
  THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types
  THEN
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom, vars, vals);
    REPEAT i := 1 TO SIZEOF(prpfun);
      prpfun[i] := substitute(prpfun[i], vars, vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun)
    THEN
      finfun := substitute(finfun, vars, vals);
    END_IF;
    RETURN(make_parallel_composed_function(srcdom, prpfun, finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types
  THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF(opnds);
      expr\multiple_arity_generic_expression.operands[i] := substitute(opnds[i], vars, vals);
    END_REPEAT;
  END_IF;
  RETURN(expr);
END_FUNCTION;

FUNCTION values_space_of(expr : generic_expression) : maths_space;
LOCAL
  e_prefix  : STRING        := 'ISO13584_EXPRESSIONS_SCHEMA.';
  typenames : SET OF STRING := TYPEOF(expr);
END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames
  THEN
    RETURN(expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames
  THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames
    THEN
      IF expr\numeric_expression.is_int
      THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames
        THEN
          RETURN(make_finite_space([expr\int_literal.the_value]));
        ELSE
          RETURN(the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames
        THEN
          RETURN(make_finite_space([expr\real_literal.the_value]));
        ELSE
          RETURN(the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames
    THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames
      THEN
        RETURN(make_finite_space([expr\boolean_literal.the_value]));
      ELSE
        RETURN(the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames
    THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames
      THEN
        RETURN(make_finite_space([expr\string_literal.the_value]));
      ELSE
        RETURN(the_strings);
      END_IF;
    END_IF;
    RETURN(?);
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames
  THEN
    IF expression_is_constant(expr)
    THEN
      RETURN(make_finite_space([expr]));
    ELSE
      RETURN(make_function_space(sc_equal, expr\maths_function.domain, sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames
  THEN
    RETURN(expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames
  THEN
    IF expression_is_constant(expr)
    THEN
      RETURN(make_finite_space([expr]));
    ELSE
      RETURN(make_elementary_space(es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames
  THEN
    RETURN(values_space_of(expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames
  THEN
    RETURN(make_finite_space([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames
  THEN
    RETURN(drop_numeric_constraints(values_space_of(expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames
  THEN
    RETURN(drop_numeric_constraints(values_space_of(expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN(?);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.4 2004/10/22 14:22:50 darla Exp
  ISO TC184/SC4/WG12 N1217 - ISO/TS 10303-1118 Measure representation - EXPRESS MIM
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA measure_representation_mim;
USE FROM foundation_representation_mim;
USE FROM qualified_measure_schema
  (measure_representation_item);
USE FROM representation_schema
  (value_representation_item);
USE FROM value_with_unit_mim;
END_SCHEMA;


(*
  Id: measure_schema.exp,v 1.28 2015/08/04 17:41:33 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Measure schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Measure schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                  91 *)
(*  Functions:                  3 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                     47 *)

SCHEMA measure_schema '{iso standard 10303 part(41) version(7) object(1) measure_schema(15)}';
REFERENCE FROM basic_attribute_schema
  (get_name_value,
   name_attribute,
   name_attribute_select);
REFERENCE FROM representation_schema
  (representation_context);
REFERENCE FROM support_resource_schema;

TYPE absorbed_dose_measure = REAL;
END_TYPE;

TYPE acceleration_measure = REAL;
END_TYPE;

TYPE amount_of_substance_measure = REAL;
END_TYPE;

TYPE area_measure = REAL;
END_TYPE;

TYPE capacitance_measure = REAL;
END_TYPE;

TYPE celsius_temperature_measure = REAL;
END_TYPE;

TYPE conductance_measure = REAL;
END_TYPE;

TYPE context_dependent_measure = REAL;
END_TYPE;

TYPE count_measure = NUMBER;
END_TYPE;

TYPE descriptive_measure = STRING;
END_TYPE;

TYPE dose_equivalent_measure = REAL;
END_TYPE;

TYPE electric_charge_measure = REAL;
END_TYPE;

TYPE electric_current_measure = REAL;
END_TYPE;

TYPE electric_potential_measure = REAL;
END_TYPE;

TYPE energy_measure = REAL;
END_TYPE;

TYPE force_measure = REAL;
END_TYPE;

TYPE frequency_measure = REAL;
END_TYPE;

TYPE illuminance_measure = REAL;
END_TYPE;

TYPE inductance_measure = REAL;
END_TYPE;

TYPE length_measure = REAL;
END_TYPE;

TYPE luminous_flux_measure = REAL;
END_TYPE;

TYPE luminous_intensity_measure = REAL;
END_TYPE;

TYPE magnetic_flux_density_measure = REAL;
END_TYPE;

TYPE magnetic_flux_measure = REAL;
END_TYPE;

TYPE mass_measure = REAL;
END_TYPE;

TYPE measure_value = SELECT 
  (absorbed_dose_measure,
   dose_equivalent_measure,
   radioactivity_measure,
   acceleration_measure,
   amount_of_substance_measure,
   area_measure,
   celsius_temperature_measure,
   context_dependent_measure,
   count_measure,
   descriptive_measure,
   capacitance_measure,
   electric_charge_measure,
   conductance_measure,
   electric_current_measure,
   electric_potential_measure,
   energy_measure,
   magnetic_flux_density_measure,
   force_measure,
   frequency_measure,
   illuminance_measure,
   inductance_measure,
   length_measure,
   luminous_flux_measure,
   luminous_intensity_measure,
   magnetic_flux_measure,
   mass_measure,
   numeric_measure,
   non_negative_length_measure,
   parameter_value,
   plane_angle_measure,
   positive_length_measure,
   positive_plane_angle_measure,
   positive_ratio_measure,
   power_measure,
   pressure_measure,
   ratio_measure,
   resistance_measure,
   solid_angle_measure,
   thermodynamic_temperature_measure,
   time_measure,
   velocity_measure,
   volume_measure);
END_TYPE;

TYPE non_negative_length_measure = length_measure;
WHERE
  WR1: SELF >= 0.0;
END_TYPE;

TYPE numeric_measure = NUMBER;
END_TYPE;

TYPE parameter_value = REAL;
END_TYPE;

TYPE plane_angle_measure = REAL;
END_TYPE;

TYPE positive_length_measure = non_negative_length_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE positive_ratio_measure = ratio_measure;
WHERE
  WR1: SELF > 0.0;
END_TYPE;

TYPE power_measure = REAL;
END_TYPE;

TYPE pressure_measure = REAL;
END_TYPE;

TYPE radioactivity_measure = REAL;
END_TYPE;

TYPE ratio_measure = REAL;
END_TYPE;

TYPE resistance_measure = REAL;
END_TYPE;

TYPE si_prefix = ENUMERATION OF
  (exa,
   peta,
   tera,
   giga,
   mega,
   kilo,
   hecto,
   deca,
   deci,
   centi,
   milli,
   micro,
   nano,
   pico,
   femto,
   atto);
END_TYPE;

TYPE si_unit_name = ENUMERATION OF
  (metre,
   gram,
   second,
   ampere,
   kelvin,
   mole,
   candela,
   radian,
   steradian,
   hertz,
   newton,
   pascal,
   joule,
   watt,
   coulomb,
   volt,
   farad,
   ohm,
   siemens,
   weber,
   tesla,
   henry,
   degree_celsius,
   lumen,
   lux,
   becquerel,
   gray,
   sievert);
END_TYPE;

TYPE solid_angle_measure = REAL;
END_TYPE;

TYPE s_name_attribute_select = SELECT BASED_ON name_attribute_select WITH 
  (derived_unit);
END_TYPE;

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;

TYPE time_measure = REAL;
END_TYPE;

TYPE unit = SELECT 
  (derived_unit,
   named_unit);
END_TYPE;

TYPE velocity_measure = REAL;
END_TYPE;

TYPE volume_measure = REAL;
END_TYPE;

ENTITY absorbed_dose_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY absorbed_dose_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.gray);
END_ENTITY;

ENTITY acceleration_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ACCELERATION_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY acceleration_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

ENTITY amount_of_substance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY amount_of_substance_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY area_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY area_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

ENTITY capacitance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY capacitance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.farad);
END_ENTITY;

ENTITY celsius_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY conductance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY conductance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.siemens);
END_ENTITY;

ENTITY context_dependent_unit
  SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;

ENTITY conversion_based_unit
  SUBTYPE OF (named_unit);
  name              : label;
  conversion_factor : measure_with_unit;
WHERE
  WR1: SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
END_ENTITY;

ENTITY derived_unit
  SUPERTYPE OF (ONEOF(absorbed_dose_unit, acceleration_unit, radioactivity_unit, area_unit, capacitance_unit,
                      dose_equivalent_unit, electric_charge_unit, conductance_unit, electric_potential_unit,
                      energy_unit, magnetic_flux_density_unit, force_unit, frequency_unit, illuminance_unit,
                      inductance_unit, magnetic_flux_unit, power_unit, pressure_unit, resistance_unit, velocity_unit,
                      volume_unit));
  elements : SET [1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY derived_unit_element;
  unit     : named_unit;
  exponent : REAL;
END_ENTITY;

ENTITY dimensional_exponents;
  length_exponent                    : REAL;
  mass_exponent                      : REAL;
  time_exponent                      : REAL;
  electric_current_exponent          : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent       : REAL;
  luminous_intensity_exponent        : REAL;
END_ENTITY;

ENTITY dose_equivalent_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY dose_equivalent_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.sievert);
END_ENTITY;

ENTITY electric_charge_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_charge_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.coulomb);
END_ENTITY;

ENTITY electric_current_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_current_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY electric_potential_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY electric_potential_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.volt);
END_ENTITY;

ENTITY energy_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY energy_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.joule);
END_ENTITY;

ENTITY force_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY force_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.newton);
END_ENTITY;

ENTITY frequency_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY frequency_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.hertz);
END_ENTITY;

ENTITY global_unit_assigned_context
  SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY;

ENTITY illuminance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY illuminance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.lux);
END_ENTITY;

ENTITY inductance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY inductance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.henry);
END_ENTITY;

ENTITY length_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY length_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY luminous_flux_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY luminous_flux_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.lumen);
END_ENTITY;

ENTITY luminous_intensity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY luminous_intensity_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY;

ENTITY magnetic_flux_density_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY magnetic_flux_density_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.tesla);
END_ENTITY;

ENTITY magnetic_flux_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY magnetic_flux_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.weber);
END_ENTITY;

ENTITY mass_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY mass_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY measure_with_unit
  SUPERTYPE OF (ONEOF(length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit,
                      electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit,
                      celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit,
                      luminous_intensity_measure_with_unit, plane_angle_measure_with_unit,
                      solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit,
                      ratio_measure_with_unit, acceleration_measure_with_unit, capacitance_measure_with_unit,
                      electric_charge_measure_with_unit, conductance_measure_with_unit,
                      electric_potential_measure_with_unit, energy_measure_with_unit,
                      magnetic_flux_density_measure_with_unit, force_measure_with_unit, frequency_measure_with_unit,
                      illuminance_measure_with_unit, inductance_measure_with_unit, luminous_flux_measure_with_unit,
                      magnetic_flux_measure_with_unit, power_measure_with_unit, pressure_measure_with_unit,
                      resistance_measure_with_unit, velocity_measure_with_unit, absorbed_dose_measure_with_unit,
                      radioactivity_measure_with_unit, dose_equivalent_measure_with_unit));
  value_component : measure_value;
  unit_component  : unit;
WHERE
  WR1: valid_units(SELF);
END_ENTITY;

ENTITY named_unit
  SUPERTYPE OF (ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR
                ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit,
                      amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit,
                      solid_angle_unit, ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;

ENTITY plane_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY plane_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY power_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY power_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.watt);
END_ENTITY;

ENTITY pressure_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY pressure_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.pascal);
END_ENTITY;

ENTITY radioactivity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY radioactivity_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.becquerel);
END_ENTITY;

ENTITY ratio_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY ratio_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY resistance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY resistance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit(si_unit_name.ohm);
END_ENTITY;

ENTITY si_absorbed_dose_unit
  SUBTYPE OF (absorbed_dose_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.gray;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_capacitance_unit
  SUBTYPE OF (capacitance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.farad;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_conductance_unit
  SUBTYPE OF (conductance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.siemens;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_dose_equivalent_unit
  SUBTYPE OF (dose_equivalent_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.sievert;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_electric_charge_unit
  SUBTYPE OF (electric_charge_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.coulomb;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_electric_potential_unit
  SUBTYPE OF (electric_potential_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.volt;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_energy_unit
  SUBTYPE OF (energy_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.joule;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_force_unit
  SUBTYPE OF (force_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.newton;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_frequency_unit
  SUBTYPE OF (frequency_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.hertz;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_illuminance_unit
  SUBTYPE OF (illuminance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.lux;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_inductance_unit
  SUBTYPE OF (inductance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.henry;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_magnetic_flux_density_unit
  SUBTYPE OF (magnetic_flux_density_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.tesla;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_magnetic_flux_unit
  SUBTYPE OF (magnetic_flux_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.weber;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_power_unit
  SUBTYPE OF (power_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.watt;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_pressure_unit
  SUBTYPE OF (pressure_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.pascal;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_radioactivity_unit
  SUBTYPE OF (radioactivity_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.becquerel;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_resistance_unit
  SUBTYPE OF (resistance_unit, si_unit);
WHERE
  WR1: SELF\si_unit.name = si_unit_name.ohm;
  WR2: NOT EXISTS(SELF\derived_unit.name);
END_ENTITY;

ENTITY si_unit
  SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name   : si_unit_name;
DERIVE
  SELF\named_unit.dimensions    : dimensional_exponents := dimensions_for_si_unit(name);
WHERE
  WR1: NOT (('MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF)) AND
            (SIZEOF(USEDIN(SELF, 'MEASURE_SCHEMA.DERIVED_UNIT_ELEMENT.UNIT')) > 0)) OR
           (prefix = si_prefix.kilo);
END_ENTITY;

ENTITY solid_angle_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY solid_angle_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY thermodynamic_temperature_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermodynamic_temperature_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 0.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY time_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY time_unit
  SUBTYPE OF (named_unit);
WHERE
  WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
       (SELF\named_unit.dimensions.time_exponent = 1.0) AND
       (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
       (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
       (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
       (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY;

ENTITY velocity_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.VELOCITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY velocity_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

ENTITY volume_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY volume_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_ENTITY;

FUNCTION derive_dimensional_exponents(x : unit) : dimensional_exponents;
LOCAL
  result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
END_LOCAL;
  IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x)
  THEN
    REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
      result.length_exponent := result.length_exponent +
                                (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                 x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions
                                  .length_exponent);
      result.mass_exponent := result.mass_exponent +
                              (x\derived_unit.elements[i]\derived_unit_element.exponent *
                               x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions
                                .mass_exponent);
      result.time_exponent := result.time_exponent +
                              (x\derived_unit.elements[i]\derived_unit_element.exponent *
                               x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions
                                .time_exponent);
      result.electric_current_exponent := result.electric_current_exponent +
                                          (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                           x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions
                                            .electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent +
                                                   (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                                    x\derived_unit.elements[i]\derived_unit_element.unit\named_unit
                                                     .dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent +
                                             (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                              x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions
                                               .amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent +
                                            (x\derived_unit.elements[i]\derived_unit_element.exponent *
                                             x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions
                                              .luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x\named_unit.dimensions;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION dimensions_for_si_unit(n : si_unit_name) : dimensional_exponents;
  CASE n OF
    metre : RETURN(dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram : RETURN(dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz : RETURN(dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton : RETURN(dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal : RETURN(dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule : RETURN(dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt : RETURN(dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt : RETURN(dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad : RETURN(dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0));
    ohm : RETURN(dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens : RETURN(dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber : RETURN(dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla : RETURN(dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry : RETURN(dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_celsius : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux : RETURN(dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel : RETURN(dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray : RETURN(dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert : RETURN(dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE: RETURN(?);
  END_CASE;
END_FUNCTION;

FUNCTION valid_units(m : measure_with_unit) : BOOLEAN;
  IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ACCELERATION_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ENERGY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.FORCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.FREQUENCY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.POWER_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.PRESSURE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.RESISTANCE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.VELOCITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  IF 'MEASURE_SCHEMA.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component)
  THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    THEN
      RETURN(false);
    END_IF;
  END_IF;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.45 2015/09/24 09:59:56 kevletu Exp
  ISO TC184/SC4/WG12 N8963 - ISO/TS 10303-1703 Model parameter - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N8271
  *)
(*  Interfaces:                 7 *)
(*  Constants:                  0 *)
(*  Entities:                  10 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      4 *)

SCHEMA model_parameter_mim;
USE FROM activity_method_assignment_mim;
USE FROM characteristic_mim;
USE FROM classification_with_attributes_mim;
USE FROM independent_property_representation_mim;
USE FROM group_mim;
USE FROM product_definition_schema
  (product_related_product_category);
USE FROM product_property_definition_schema
  (characterized_definition);

TYPE mp_action_method_items = SELECT BASED_ON action_method_items WITH 
  (test_method_based_parameter_assignment);
END_TYPE;

TYPE mp_document_reference_item = SELECT BASED_ON document_reference_item WITH 
  (model_parameter);
END_TYPE;

TYPE mp_groupable_item = SELECT BASED_ON groupable_item WITH 
  (group_relationship);
END_TYPE;

TYPE parameter_assignment_select = EXTENSIBLE GENERIC_ENTITY SELECT 
  (model_parameter);
END_TYPE;

ENTITY category_model_parameter
  SUBTYPE OF (model_parameter);
END_ENTITY;

ENTITY default_value_property_definition_representation
  SUBTYPE OF (property_definition_representation);
END_ENTITY;

ENTITY model_parameter
  SUBTYPE OF (general_property);
END_ENTITY;

ENTITY model_parameter_with_unit
  SUBTYPE OF (model_parameter);
WHERE
  WR1: NOT ('MODEL_PARAMETER_MIM.SCHEMA_BASED_MODEL_PARAMETER' IN TYPEOF(SELF));
END_ENTITY;

ENTITY parameter_assignment
  SUBTYPE OF (property_definition_representation, representation);
  SELF\property_definition_representation.definition               : parameter_assignment_select;
END_ENTITY;

ENTITY parameter_assignment_override
  SUBTYPE OF (representation, representation_relationship);
  SELF\representation_relationship.rep_1 : parameter_assignment;
  SELF\representation_relationship.rep_2 : parameter_assignment;
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SELF\representation_relationship.rep_1 <> SELF\representation_relationship.rep_2;
END_ENTITY;

ENTITY product_specific_parameter_value_assignment
  SUBTYPE OF (characterized_object, product_related_product_category);
END_ENTITY;

ENTITY schema_based_model_parameter
  SUBTYPE OF (model_parameter);
END_ENTITY;

ENTITY test_method_based_parameter_assignment
  SUBTYPE OF (parameter_assignment);
END_ENTITY;

ENTITY valid_range_property_definition_representation
  SUBTYPE OF (property_definition_representation);
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.6 2004/11/19 21:37:37 robbod Exp
  ISO TC184/SC4/WG12 N3086 - ISO/TS 10303-1340 Name assignment - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N2283
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA name_assignment_mim;
USE FROM management_resources_schema
  (name_assignment);

TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.8 2010/06/09 21:51:47 philsp Exp
  ISO TC184/SC4/WG12 N7123 - ISO/TS 10303-1013 Person organization assignment - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N1091
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA person_organization_assignment_mim;
USE FROM management_resources_schema
  (organization_assignment,
   person_and_organization_assignment);
USE FROM person_organization_mim;
USE FROM person_organization_schema
  (organization_role,
   person_and_organization_role);

TYPE organization_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_item;
END_ENTITY;

ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_item;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.11 2004/10/29 16:20:10 thendrix Exp
  ISO TC184/SC4/WG12 N2922 - ISO/TS 10303-1011 Person organization - EXPRESS MIM
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA person_organization_mim;
USE FROM basic_attribute_schema
  (id_attribute,
   id_attribute_select,
   name_attribute,
   name_attribute_select);
USE FROM person_organization_schema
  (address,
   organization,
   organization_relationship,
   organizational_address,
   person,
   person_and_organization,
   personal_address);

ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET [1:1] OF organization;
  SELF\personal_address.people : SET [1:1] OF person;
WHERE
  WR1: SIZEOF(
       QUERY(pao <* USEDIN(SELF\personal_address.people[1],
                    'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=:
                                                                                       SELF\organizational_address
                                                                                           .organizations[1])) =
       1;
END_ENTITY;
END_SCHEMA;


(*
  Id: person_organization_schema.exp,v 1.26 2014/03/04 00:30:38 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Person organization schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Person organization schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                  21 *)
(*  Functions:                  5 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      4 *)

SCHEMA person_organization_schema '{iso standard 10303 part(41) version(7) object(1) person_organization_schema(16)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_id_value,
   get_name_value,
   get_role,
   id_attribute,
   id_attribute_select,
   name_attribute,
   name_attribute_select,
   object_role,
   role_association);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE person_organization_select = SELECT 
  (person,
   organization,
   person_and_organization);
END_TYPE;

TYPE pos_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (person_and_organization_role,
   person_and_organization,
   person_role,
   organization_role,
   organizational_project);
END_TYPE;

TYPE pos_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (address,
   organizational_project);
END_TYPE;

TYPE pos_name_attribute_select = SELECT BASED_ON name_attribute_select WITH 
  (address,
   person_and_organization);
END_TYPE;

ENTITY address;
  internal_location       : OPTIONAL label;
  street_number           : OPTIONAL label;
  street                  : OPTIONAL label;
  postal_box              : OPTIONAL label;
  town                    : OPTIONAL label;
  region                  : OPTIONAL label;
  postal_code             : OPTIONAL label;
  country                 : OPTIONAL label;
  facsimile_number        : OPTIONAL label;
  telephone_number        : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number            : OPTIONAL label;
DERIVE
  name : label      := get_name_value(SELF);
  url  : identifier := get_id_value(SELF);
WHERE
  WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR
       EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR
       EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;

ENTITY organization;
  id          : OPTIONAL identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organizational_address
  SUBTYPE OF (address);
  organizations : SET [1:?] OF organization;
  description   : OPTIONAL text;
END_ENTITY;

ENTITY organizational_project;
  name                      : label;
  description               : OPTIONAL text;
  responsible_organizations : SET [1:?] OF organization;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY organizational_project_relationship;
  name                            : label;
  description                     : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project  : organizational_project;
END_ENTITY;

ENTITY organization_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_organization : organization;
  related_organization  : organization;
END_ENTITY;

ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY organization_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY organization_type_relationship;
  id                         : identifier;
  name                       : label;
  description                : OPTIONAL text;
  relating_organization_type : organization_type;
  related_organization_type  : organization_type;
END_ENTITY;

ENTITY person;
  id            : identifier;
  last_name     : OPTIONAL label;
  first_name    : OPTIONAL label;
  middle_names  : OPTIONAL LIST [1:?] OF label;
  prefix_titles : OPTIONAL LIST [1:?] OF label;
  suffix_titles : OPTIONAL LIST [1:?] OF label;
WHERE
  WR1: EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;

ENTITY personal_address
  SUBTYPE OF (address);
  people      : SET [1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_and_organization;
  the_person       : person;
  the_organization : organization;
DERIVE
  name        : label := get_name_value(SELF);
  description : text  := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY person_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY person_type_definition;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
  formation   : person_type_definition_formation;
END_ENTITY;

ENTITY person_type_definition_formation;
  id             : identifier;
  name           : label;
  description    : OPTIONAL text;
  of_person_type : person_type;
END_ENTITY;

ENTITY person_type_definition_relationship;
  id                              : identifier;
  name                            : label;
  description                     : OPTIONAL text;
  relating_person_type_definition : person_type_definition;
  related_person_type_definition  : person_type_definition;
END_ENTITY;

ENTITY position_in_organization;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY position_in_organization_relationship;
  id                                : identifier;
  name                              : label;
  description                       : OPTIONAL text;
  relating_position_in_organization : position_in_organization;
  related_position_in_organization  : position_in_organization;
END_ENTITY;

ENTITY position_in_organization_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

FUNCTION acyclic_organizational_project_relationship(relation : organizational_project_relationship;
                                                     relatives : SET [1:?] OF organizational_project;
                                                     specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF organizational_project_relationship;
END_LOCAL;
  IF relation.relating_organizational_project IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(op <* bag_to_set(
                   USEDIN(relation.relating_organizational_project,
                   'PERSON_ORGANIZATION_SCHEMA.ORGANIZATIONAL_PROJECT_RELATIONSHIP.RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN
                                                                                                                       TYPEOF(
                                                                                                                       op));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_organization_relationship(relation : organization_relationship;
                                           relatives : SET [1:?] OF organization;
                                           specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF organization_relationship;
END_LOCAL;
  IF relation.relating_organization IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(org <* bag_to_set(
                    USEDIN(relation.relating_organization,
                    'PERSON_ORGANIZATION_SCHEMA.ORGANIZATION_RELATIONSHIP.RELATED_ORGANIZATION')) | specific_relation IN
                                                                                                    TYPEOF(org));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_organization_type_relationship(relation : organization_type_relationship;
                                                relatives : SET OF organization_type;
                                                specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF organization_type_relationship;
END_LOCAL;
  IF relation.relating_organization_type IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(orgtyp <* bag_to_set(
                       USEDIN(relation.relating_organization_type,
                       'PERSON_ORGANIZATION_SCHEMA.ORGANIZATION_TYPE_RELATIONSHIP.RELATED_ORGANIZATION_TYPE')) | specific_relation IN
                                                                                                                 TYPEOF(
                                                                                                                 orgtyp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_person_type_definition_relationship(relation : person_type_definition_relationship;
                                                     relatives : SET OF person_type_definition;
                                                     specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF person_type_definition_relationship;
END_LOCAL;
  IF relation.relating_person_type_definition IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(ptdef <* bag_to_set(
                      USEDIN(relation.relating_person_type_definition,
                      'PERSON_ORGANIZATION_SCHEMA.PERSON_TYPE_DEFINITION_RELATIONSHIP.RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN
                                                                                                                          TYPEOF(
                                                                                                                          ptdef));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_position_in_organization_relationship(relation : position_in_organization_relationship;
                                                       relatives : SET OF position_in_organization;
                                                       specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF position_in_organization_relationship;
END_LOCAL;
  IF relation.relating_position_in_organization IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(piorg <* bag_to_set(
                      USEDIN(relation.relating_position_in_organization,
                      'PERSON_ORGANIZATION_SCHEMA.POSITION_IN_ORGANIZATION_RELATIONSHIP.RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN
                                                                                                                              TYPEOF(
                                                                                                                              piorg));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.11 2008/09/13 12:26:56 liutkuviene Exp
  ISO TC184/SC4/WG12 N5456 - ISO/TS 10303-1291 Plib class reference - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4841
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   1 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA plib_class_reference_mim;
USE FROM external_class_mim;
USE FROM external_item_identification_assignment_mim;
USE FROM person_organization_assignment_mim;
USE FROM external_reference_schema
  (external_source,
   pre_defined_item);

TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH 
  (externally_defined_class);
END_TYPE;

TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH 
  (class);
END_TYPE;

ENTITY known_source
  SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY;
END_SCHEMA;


(*
  Id: process_property_representation_schema.exp,v 1.4 2015/06/29 19:32:11 dgnedwards Exp
  ISO 10303 TC184/SC4/WG12 N8547

  EXPRESS Source:
  ISO 10303-49 ed1 Process structure and properties - Process property representation schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-49 ed1 Process structure and properties - Process property representation schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA process_property_representation_schema '{iso standard 10303 part(49) version(1) object(1) process_property_representation_schema(2)}';
REFERENCE FROM support_resource_schema
  (label,
   text);
REFERENCE FROM representation_schema
  (representation);
REFERENCE FROM process_property_schema
  (action_property,
   resource_property);

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;
END_SCHEMA;


(*
  Id: process_property_schema.exp,v 1.4 2015/06/29 19:32:44 dgnedwards Exp
  ISO 10303 TC184/SC4/WG12 N8548

  EXPRESS Source:
  ISO 10303-49 ed1 Process structure and properties - Process property schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-49 ed1 Process structure and properties - Process property schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                  14 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      3 *)

SCHEMA process_property_schema '{iso standard 10303 part(49) version(1) object(1) process_property_schema(3)}';
REFERENCE FROM action_schema
  (action,
   action_method,
   action_method_relationship,
   action_relationship,
   action_resource,
   action_resource_relationship,
   acyclic_action_relationship);
REFERENCE FROM product_property_definition_schema
  (characterized_product_definition,
   property_definition,
   shape_definition);
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text);

TYPE characterized_action_definition = SELECT 
  (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT 
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT 
  (property_definition,
   shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: related_action_resource_requirement;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  product_definitions : SET [1:?]OF process_product_association FOR process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?]OF process_property_association FOR process;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship(SELF, [SELF\action_relationship.related_action],
       'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;
END_SCHEMA;


(*
  Id: product_definition_schema.exp,v 1.18 2014/03/04 00:30:39 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Product definition schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Product definition schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 7 *)
(*  Constants:                  0 *)
(*  Entities:                  19 *)
(*  Functions:                  6 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      4 *)

SCHEMA product_definition_schema '{iso standard 10303 part(41) version(7) object(1) product_definition_schema(17)}';
REFERENCE FROM application_context_schema
  (product_context,
   product_definition_context);
REFERENCE FROM basic_attribute_schema
  (get_id_value,
   get_name_value,
   id_attribute,
   id_attribute_select,
   name_attribute,
   name_attribute_select);
REFERENCE FROM product_property_definition_schema
  (characterized_object);
REFERENCE FROM document_schema
  (document);
REFERENCE FROM effectivity_schema
  (effectivity);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);
REFERENCE FROM external_reference_schema
  (external_source);

TYPE pds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (product_category);
END_TYPE;

TYPE pds_name_attribute_select = SELECT BASED_ON name_attribute_select WITH 
  (product_definition,
   product_definition_substitute);
END_TYPE;

TYPE product_definition_or_reference = SELECT 
  (product_definition,
   generic_product_definition_reference);
END_TYPE;

TYPE source = ENUMERATION OF
  (made,
   bought,
   not_known);
END_TYPE;

ENTITY characterized_product
  SUBTYPE OF (characterized_object, product);
END_ENTITY;

ENTITY generic_product_definition_reference
  ABSTRACT SUPERTYPE OF (ONEOF(product_definition_reference, product_definition_reference_with_local_representation));
  source : external_source;
END_ENTITY;

ENTITY product;
  id                 : identifier;
  name               : label;
  description        : OPTIONAL text;
  frame_of_reference : SET [1:?] OF product_context;
END_ENTITY;

ENTITY product_category;
  name        : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_category_relationship;
  name         : label;
  description  : OPTIONAL text;
  category     : product_category;
  sub_category : product_category;
WHERE
  WR1: acyclic_product_category_relationship(SELF, [SELF.sub_category]);
END_ENTITY;

ENTITY product_definition;
  id                 : identifier;
  description        : OPTIONAL text;
  formation          : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_context_association;
  definition         : product_definition;
  frame_of_reference : product_definition_context;
  role               : product_definition_context_role;
END_ENTITY;

ENTITY product_definition_context_role;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_definition_effectivity
  SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
END_ENTITY;

ENTITY product_definition_formation;
  id          : identifier;
  description : OPTIONAL text;
  of_product  : product;
UNIQUE
  UR1: id, of_product;
END_ENTITY;

ENTITY product_definition_formation_relationship;
  id                                    : identifier;
  name                                  : label;
  description                           : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation  : product_definition_formation;
END_ENTITY;

ENTITY product_definition_formation_with_specified_source
  SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;

ENTITY product_definition_reference
  SUBTYPE OF (generic_product_definition_reference);
  product_id                      : identifier;
  product_definition_formation_id : identifier;
  product_definition_id           : identifier;
  id_owning_organization_name     : OPTIONAL label;
END_ENTITY;

ENTITY product_definition_reference_with_local_representation
  SUBTYPE OF (generic_product_definition_reference, product_definition);
END_ENTITY;

ENTITY product_definition_relationship;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  relating_product_definition : product_definition_or_reference;
  related_product_definition  : product_definition_or_reference;
END_ENTITY;

ENTITY product_definition_substitute;
  description           : OPTIONAL text;
  context_relationship  : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  WR1: context_relationship.related_product_definition :<>: substitute_definition;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY product_definition_with_associated_documents
  SUBTYPE OF (product_definition);
  documentation_ids : SET [1:?] OF document;
END_ENTITY;

ENTITY product_related_product_category
  SUBTYPE OF (product_category);
  products : SET [1:?] OF product;
END_ENTITY;

ENTITY product_relationship;
  id               : identifier;
  name             : label;
  description      : OPTIONAL text;
  relating_product : product;
  related_product  : product;
END_ENTITY;

FUNCTION acyclic_product_category_relationship(relation : product_category_relationship;
                                               children : SET OF product_category) : BOOLEAN;
LOCAL
  x              : SET OF product_category_relationship;
  local_children : SET OF product_category;
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(children);
    IF relation.category :=: children[i]
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
  local_children := children + relation.category;
  IF SIZEOF(x) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_category_relationship(x[i], local_children)
      THEN
        RETURN(false);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_product_definition_formation_relationship(relation : product_definition_formation_relationship;
                                                           relatives : SET [1:?] OF product_definition_formation;
                                                           specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_definition_formation_relationship;
END_LOCAL;
  IF relation.relating_product_definition_formation IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(pdf <* bag_to_set(
                    USEDIN(relation.relating_product_definition_formation,
                    'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN
                                                                                                                                   TYPEOF(
                                                                                                                                   pdf));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_formation_relationship(x[i],
           relatives + relation.relating_product_definition_formation, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_product_definition_relationship(relation : product_definition_relationship;
                                                 relatives : SET [1:?] OF product_definition_or_reference;
                                                 specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_definition_relationship;
END_LOCAL;
  IF relation.relating_product_definition IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(pd <* bag_to_set(
                   USEDIN(relation.relating_product_definition,
                   'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')) | specific_relation IN
                                                                                                              TYPEOF(
                                                                                                              pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_product_relationship(relation : product_relationship;
                                      relatives : SET [1:?] OF product;
                                      specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_relationship;
END_LOCAL;
  IF relation.relating_product IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(prod <* bag_to_set(
                     USEDIN(relation.relating_product,
                     'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATIONSHIP.RELATED_PRODUCT')) | specific_relation IN
                                                                                          TYPEOF(prod));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION categories_of_product(obj : product) : SET OF STRING;
LOCAL
  category_assignments : BAG OF product_category;
  categories           : SET OF STRING           := [];
END_LOCAL;
  category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
  REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
    categories := categories + category_assignments[i].name;
  END_REPEAT;
  RETURN(categories);
END_FUNCTION;

FUNCTION get_product_definitions(c_def_instance : product) : SET OF product_definition;
LOCAL
  pd_set  : SET OF product_definition_formation := [];
  pdr_set : SET OF product_definition           := [];
END_LOCAL;
  pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
  IF (SIZEOF(pd_set) < 1)
  THEN
    RETURN(pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
  END_REPEAT;
  RETURN(pdr_set);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.13 2009/08/11 07:57:32 robbod Exp
  ISO TC184/SC4/WG12 N6066 - ISO/TS 10303-1017 Product identification - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N2926
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA product_identification_mim;
USE FROM product_definition_schema
  (product);
END_SCHEMA;


(*
  Id: product_property_definition_schema.exp,v 1.17 2014/03/04 00:30:39 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Product property definition schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Product property definition schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 5 *)
(*  Constants:                  0 *)
(*  Entities:                  10 *)
(*  Functions:                  4 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      7 *)

SCHEMA product_property_definition_schema '{iso standard 10303 part(41) version(7) object(1) product_property_definition_schema(18)}';
REFERENCE FROM process_property_schema
  (action_property,
   resource_property);
REFERENCE FROM product_definition_schema
  (product_definition,
   product_definition_relationship);
REFERENCE FROM product_structure_schema
  (assembly_component_usage,
   multi_level_reference_designator,
   next_assembly_usage_occurrence);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);
REFERENCE FROM basic_attribute_schema
  (get_id_value,
   id_attribute,
   id_attribute_select);

TYPE characterized_definition = SELECT 
  (characterized_object,
   characterized_product_definition,
   shape_definition);
END_TYPE;

TYPE characterized_product_definition = SELECT 
  (product_definition,
   product_definition_relationship);
END_TYPE;

TYPE derived_property_select = SELECT 
  (property_definition,
   action_property,
   resource_property);
END_TYPE;

TYPE internal_or_reflected_shape_aspect = SELECT 
  (shape_aspect,
   identifier);
END_TYPE;

TYPE multi_or_next_assembly_usage_occurrence = SELECT 
  (multi_level_reference_designator,
   next_assembly_usage_occurrence);
END_TYPE;

TYPE ppds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (property_definition,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

TYPE shape_definition = SELECT 
  (product_definition_shape,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

ENTITY characterized_object;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY characterized_object_relationship;
  name            : label;
  description     : OPTIONAL text;
  relating_object : characterized_object;
  related_object  : characterized_object;
END_ENTITY;

ENTITY component_path_shape_aspect
  SUBTYPE OF (shape_aspect);
  location               : multi_or_next_assembly_usage_occurrence;
  component_shape_aspect : internal_or_reflected_shape_aspect;
UNIQUE
  UR1: location, component_shape_aspect;
END_ENTITY;

ENTITY general_property;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY general_property_association;
  name               : label;
  description        : OPTIONAL text;
  base_definition    : general_property;
  derived_definition : derived_property_select;
WHERE
  WR1: SIZEOF(
       USEDIN(derived_definition,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION')) =
       1;
  WR2: derived_definition.name = base_definition.name;
END_ENTITY;

ENTITY general_property_relationship;
  name              : label;
  description       : OPTIONAL text;
  relating_property : general_property;
  related_property  : general_property;
END_ENTITY;

ENTITY product_definition_shape
  SUBTYPE OF (property_definition);
UNIQUE
  UR1: SELF\property_definition.definition;
WHERE
  WR1: SIZEOF(
       ['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION',
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] *
       TYPEOF(SELF\property_definition.definition)) >
       0;
END_ENTITY;

ENTITY property_definition;
  name        : label;
  description : OPTIONAL text;
  definition  : characterized_definition;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect;
  name                 : label;
  description          : OPTIONAL text;
  of_shape             : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, of_shape;
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_aspect_relationship;
  name                  : label;
  description           : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect  : shape_aspect;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

FUNCTION acyclic_characterized_object_relationship(relation : characterized_object_relationship;
                                                   relatives : SET [1:?] OF characterized_object;
                                                   specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF characterized_object_relationship;
END_LOCAL;
  IF relation.relating_object IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(ca <* bag_to_set(
                   USEDIN(relation.relating_object,
                   'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT_RELATIONSHIP.RELATED_OBJECT')) | specific_relation IN
                                                                                                             TYPEOF(
                                                                                                             ca));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_general_property_relationship(relation : general_property_relationship;
                                               relatives : SET [1:?] OF general_property;
                                               specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF general_property_relationship;
END_LOCAL;
  IF relation.relating_property IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(genp <* bag_to_set(
                     USEDIN(relation.relating_property,
                     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.GENERAL_PROPERTY_RELATIONSHIP.RELATED_PROPERTY')) | specific_relation IN
                                                                                                             TYPEOF(
                                                                                                             genp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_shape_aspect_relationship(relation : shape_aspect_relationship;
                                           relatives : SET [1:?] OF shape_aspect;
                                           specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF shape_aspect_relationship;
END_LOCAL;
  IF relation.relating_shape_aspect IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(sa <* bag_to_set(
                   USEDIN(relation.relating_shape_aspect,
                   'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | specific_relation IN 
                                                                                                           TYPEOF(sa));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION get_shape_aspects(c_def_instance : characterized_definition) : SET OF shape_aspect;
LOCAL
  pd_set  : SET OF product_definition_shape := [];
  pdr_set : SET OF shape_aspect             := [];
END_LOCAL;
  pd_set := bag_to_set(
            QUERY(pd <* USEDIN(c_def_instance,
                        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
                                                                                               TYPEOF(pd)));
  IF (SIZEOF(pd_set) < 1)
  THEN
    RETURN(pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
  END_REPEAT;
  RETURN(pdr_set);
END_FUNCTION;
END_SCHEMA;


(*
  Id: product_property_representation_schema.exp,v 1.41 2015/07/13 20:54:19 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8572

  EXPRESS Source:
  ISO 10303-41 ed5 Fundamentals of product description and support - Product property representation schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2015  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed5 Fundamentals of product description and support - Product property representation schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 6 *)
(*  Constants:                  0 *)
(*  Entities:                  10 *)
(*  Functions:                  4 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      7 *)

SCHEMA product_property_representation_schema '{iso standard 10303 part(41) version(8) object(1) product_property_representation_schema(19)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_name_value,
   name_attribute,
   name_attribute_select);
REFERENCE FROM material_property_definition_schema
  (property_definition_relationship);
REFERENCE FROM product_definition_schema
  (product_definition,
   product_definition_relationship);
REFERENCE FROM product_property_definition_schema
  (characterized_object,
   characterized_definition,
   general_property,
   product_definition_shape,
   property_definition,
   shape_aspect,
   shape_aspect_relationship);
REFERENCE FROM representation_schema
  (representation,
   representation_item,
   representation_relationship,
   using_representations,
   mapped_item,
   representation_context,
   representation_map,
   list_representation_item,
   set_representation_item);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   label,
   text);

TYPE chained_representation_link = SELECT 
  (mapped_item,
   representation_context,
   representation_relationship);
END_TYPE;

TYPE denoted_object_select = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

TYPE item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT 
  (represented_definition);
END_TYPE;

TYPE item_identified_representation_usage_select = SELECT 
  (representation_item,
   list_representation_item,
   set_representation_item);
END_TYPE;

TYPE pprs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (context_dependent_shape_representation,
   property_definition_representation);
END_TYPE;

TYPE pprs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH 
  (context_dependent_shape_representation,
   property_definition_representation);
END_TYPE;

TYPE represented_definition = SELECT 
  (general_property,
   property_definition,
   property_definition_relationship,
   shape_aspect,
   shape_aspect_relationship);
END_TYPE;

ENTITY chain_based_item_identified_representation_usage
  SUBTYPE OF (item_identified_representation_usage);
  nodes           : LIST [2:?] OF UNIQUE representation;
  undirected_link : LIST [1:?] OF chained_representation_link;
DERIVE
  root                                                          : representation                            := nodes[1];
  SELF\item_identified_representation_usage.used_representation    : representation                            := nodes
                                                                                                                       [HIINDEX(
                                                                                                                        nodes)];
  directed_link                                                 : LIST [1:?] OF representation_relationship := get_directed_link(
                                                                                                               nodes,
                                                                                                               undirected_link);
WHERE
  WR1: EXISTS(directed_link);
END_ENTITY;

ENTITY characterized_chain_based_item_within_representation
  SUBTYPE OF (characterized_item_within_representation);
  nodes           : LIST [2:?] OF UNIQUE representation;
  undirected_link : LIST [1:?] OF chained_representation_link;
DERIVE
  root                                              : representation                            := nodes[1];
  SELF\characterized_item_within_representation.rep : representation                            := nodes
                                                                                                        [HIINDEX(
                                                                                                         nodes)];
  directed_link                                     : LIST [1:?] OF representation_relationship := get_directed_link(
                                                                                                   nodes,
                                                                                                   undirected_link);
WHERE
  WR1: EXISTS(directed_link);
END_ENTITY;

ENTITY characterized_item_within_representation
  SUBTYPE OF (characterized_object);
  item : representation_item;
  rep  : representation;
UNIQUE
  WR1: item, rep;
WHERE
  WR2: rep IN using_representations(item);
END_ENTITY;

ENTITY context_dependent_shape_representation;
  representation_relation      : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text  := get_description_value(SELF);
  name        : label := get_name_value(SELF);
WHERE
  WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN
       TYPEOF(SELF.represented_product_relation.definition);
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR3: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY item_identified_representation_usage;
  name                : label;
  description         : OPTIONAL text;
  definition          : item_identified_representation_usage_definition;
  used_representation : representation;
  identified_item     : item_identified_representation_usage_select;
WHERE
  WR1: SELF.used_representation IN using_representations(SELF.identified_item);
END_ENTITY;

ENTITY property_definition_denotation;
  name           : OPTIONAL label;
  description    : OPTIONAL text;
  definition     : represented_definition;
  denoted_object : denoted_object_select;
END_ENTITY;

ENTITY property_definition_representation;
  definition          : represented_definition;
  used_representation : representation;
DERIVE
  description : text  := get_description_value(SELF);
  name        : label := get_name_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;

ENTITY shape_definition_representation
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition             : property_definition;
  SELF\property_definition_representation.used_representation    : shape_representation;
WHERE
  WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(definition)) OR
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(definition\property_definition.definition));
END_ENTITY;

ENTITY shape_representation
  SUBTYPE OF (representation);
END_ENTITY;

ENTITY shape_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN
       (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY;

FUNCTION get_directed_link(nodes : LIST OF representation;
                           undirected_link : LIST OF chained_representation_link) : LIST OF representation_relationship;
LOCAL
  directed_link : LIST OF representation_relationship := [];
END_LOCAL;
  IF (SIZEOF(nodes) <> SIZEOF(undirected_link) + 1) OR (VALUE_UNIQUE(nodes) = false)
  THEN
    RETURN(?);
  END_IF;
  REPEAT i := 1 TO SIZEOF(undirected_link);
    CASE true OF
      ('REPRESENTATION_SCHEMA.REPRESENTATION_CONTEXT' IN TYPEOF(undirected_link[i])) : BEGIN  
                                                                                              IF ((nodes[i]
                                                                                                        \representation
                                                                                                        .context_of_items :=:
                                                                                                   undirected_link
                                                                                                                  [i]) AND
                                                                                                  (nodes[i + 1]
                                                                                                        \representation
                                                                                                        .context_of_items :=:
                                                                                                   undirected_link[i]))
                                                                                              THEN
                                                                                                INSERT(directed_link,
                                                                                                       representation_relationship('',
                                                                                                                                   '',
                                                                                                                                   nodes
                                                                                                                                        [i +
                                                                                                                                         1],
                                                                                                                                   nodes
                                                                                                                                        [i]),
                                                                                                       (i - 1));
                                                                                              ELSE
                                                                                                RETURN(?);
                                                                                              END_IF;
      END;
      ('REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP' IN TYPEOF(undirected_link[i])) : BEGIN  
                                                                                                   IF (((nodes[i] :=:
                                                                                                         undirected_link
                                                                                                                        [i]
                                                                                                                        \representation_relationship
                                                                                                                        .rep_1) AND
                                                                                                        (nodes
                                                                                                              [i +
                                                                                                               1] :=:
                                                                                                         undirected_link
                                                                                                                        [i]
                                                                                                                        \representation_relationship
                                                                                                                        .rep_2)) OR
                                                                                                       ((nodes[i] :=:
                                                                                                         undirected_link
                                                                                                                        [i]
                                                                                                                        \representation_relationship
                                                                                                                        .rep_2) AND
                                                                                                        (nodes
                                                                                                              [i +
                                                                                                               1] :=:
                                                                                                         undirected_link
                                                                                                                        [i]
                                                                                                                        \representation_relationship
                                                                                                                        .rep_1)))
                                                                                                   THEN
                                                                                                     INSERT(directed_link,
                                                                                                            representation_relationship('',
                                                                                                                                        '',
                                                                                                                                        nodes
                                                                                                                                             [i +
                                                                                                                                              1],
                                                                                                                                        nodes
                                                                                                                                             [i]),
                                                                                                            (i - 1));
                                                                                                   ELSE
                                                                                                     RETURN(?);
                                                                                                   END_IF;
      END;
      ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(undirected_link[i])) : BEGIN  
                                                                                   IF ((nodes[i] IN
                                                                                        using_representations(
                                                                                        undirected_link[i])) AND
                                                                                       (nodes[i + 1] :=:
                                                                                        undirected_link[i]\mapped_item
                                                                                                       .mapping_source
                                                                                                       \representation_map
                                                                                                       .mapped_representation))
                                                                                   THEN
                                                                                     INSERT(directed_link,
                                                                                            representation_relationship('',
                                                                                                                        '',
                                                                                                                        nodes
                                                                                                                             [i +
                                                                                                                              1],
                                                                                                                        nodes
                                                                                                                             [i]),
                                                                                            (i - 1));
                                                                                   ELSE
                                                                                     RETURN(?);
                                                                                   END_IF;
      END;
      OTHERWISE: RETURN(?);
    END_CASE;
  END_REPEAT;
  IF (VALUE_UNIQUE(directed_link) = false)
  THEN
    RETURN(?);
  END_IF;
  RETURN(directed_link);
END_FUNCTION;

FUNCTION get_property_definition_representations(c_def_instance : characterized_definition) : SET OF property_definition_representation;
LOCAL
  pd_set  : SET OF property_definition                := [];
  pdr_set : SET OF property_definition_representation := [];
END_LOCAL;
  pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
  IF (SIZEOF(pd_set) < 1)
  THEN
    RETURN(pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set +
               bag_to_set(
               USEDIN(pd_set[i],
               'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
  END_REPEAT;
  RETURN(pdr_set);
END_FUNCTION;

FUNCTION relatives_of_product_definitions(definition_set : SET OF product_definition;
                                          relation_subtype : STRING) : SET OF product_definition;
FUNCTION local_relatives_of_product_definitions(definition_set : SET OF product_definition;
                                                total_definitions : SET OF product_definition;
                                                relation_subtype : STRING) : SET OF product_definition;
LOCAL
  local_def   : SET OF product_definition              := [];
  local_pdr   : SET OF product_definition_relationship := [];
  local_total : SET OF product_definition              := [];
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(definition_set);
    local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(local_pdr);
    local_def := local_def + local_pdr[i].related_product_definition;
  END_REPEAT;
  IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0
  THEN
    RETURN(local_def);
  ELSE
    local_total := total_definitions + local_def;
    RETURN(local_def +
           (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
  END_IF;
END_FUNCTION;
  RETURN(local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
END_FUNCTION;

FUNCTION relatives_of_shape_representations(shape_representation_set : SET OF shape_representation) : SET OF shape_representation;
FUNCTION local_relatives_of_shape_representations(shape_representation_set : SET OF shape_representation;
                                                  total_reps : SET OF shape_representation) : SET OF shape_representation;
LOCAL
  local_shape_rep : SET OF shape_representation              := [];
  local_srr       : SET OF shape_representation_relationship := [];
  local_total     : SET OF shape_representation              := [];
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(shape_representation_set);
    local_srr := local_srr +
                 QUERY(rr <* bag_to_set(
                             USEDIN(shape_representation_set[i],
                             'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN
                                                                                           TYPEOF(rr));
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(local_srr);
    IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i])
    THEN
      local_shape_rep := local_shape_rep + local_srr[i].rep_2;
    END_IF;
  END_REPEAT;
  IF SIZEOF(local_shape_rep - total_reps) = 0
  THEN
    RETURN(shape_representation_set);
  ELSE
    local_total := total_reps + local_shape_rep;
    RETURN(local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
  END_IF;
END_FUNCTION;
  RETURN(local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));
END_FUNCTION;
END_SCHEMA;


(*
  Id: product_structure_schema.exp,v 1.21 2014/03/04 00:30:40 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8371

  EXPRESS Source:
  ISO 10303-44 ed3 Product structure configuration - Product structure schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-44 ed3 Product structure configuration - Product structure schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                  13 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA product_structure_schema '{iso standard 10303 part(44) version(3) object(1) product_structure_schema(1)}';
REFERENCE FROM product_definition_schema
  (product,
   product_definition,
   product_definition_formation,
   product_definition_reference,
   product_definition_relationship,
   acyclic_product_definition_relationship,
   product_definition_or_reference);
REFERENCE FROM measure_schema
  (measure_with_unit);
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text);

ENTITY alternate_product_relationship;
  name       : label;
  definition : OPTIONAL text;
  alternate  : product;
  base       : product;
  basis      : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (quantified_assembly_component_usage ANDOR
                ONEOF(multi_level_reference_designator, next_assembly_usage_occurrence, promissory_usage_occurrence,
                      specified_higher_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name       : label;
  definition : OPTIONAL text;
  base       : assembly_component_usage;
  substitute : assembly_component_usage;
UNIQUE
  UR1: base, substitute;
WHERE
  WR1: base.relating_product_definition :=: substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF(
       QUERY(example <* members | example.related_product_definition :=: members[1].related_product_definition)) =
       SIZEOF(members);
END_ENTITY;

ENTITY multi_level_reference_designator
  SUBTYPE OF (assembly_component_usage);
  location : LIST [1:?] OF UNIQUE next_assembly_usage_occurrence;
DERIVE
  SELF\product_definition_relationship.relating_product_definition                       : product_definition              := location
                                                                                                                                      [1]
                                                                                                                                      \product_definition_relationship
                                                                                                                                      .relating_product_definition;
  SELF\product_definition_relationship.related_product_definition                       : product_definition_or_reference := location
                                                                                                                                     [HIINDEX(
                                                                                                                                      location)]
                                                                                                                                     \product_definition_relationship
                                                                                                                                     .related_product_definition;
UNIQUE
  UR1: location;
WHERE
  WR1: unambiguously_specified_multi_level_reference_designator(location);
  WR2: SIZEOF(QUERY(cp <* location | NOT (EXISTS(cp\assembly_component_usage.reference_designator)))) = 0;
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
UNIQUE
  UR1: SELF\assembly_component_usage.reference_designator,
       SELF\product_definition_relationship.relating_product_definition;
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: occurrence;
  WR2: occurrence_usage.related_product_definition :<>: occurrence;
  WR3: occurrence.formation :=: occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF(make_from_usage_option, assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id, SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1: acyclic_product_definition_relationship(SELF, [SELF\product_definition_relationship.related_product_definition],
       'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component))) OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage : assembly_component_usage;
  next_usage  : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=: next_usage.relating_product_definition) OR
       (SIZEOF(
        QUERY(pdr <* USEDIN(upper_usage.related_product_definition,
                     'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | pdr
                                                                                                                  .relating_product_definition :=:
                                                                                                               next_usage
                                                                                                                         .relating_product_definition)) =
        1);
  WR5: SIZEOF(
       ['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
        'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE'] *
       TYPEOF(upper_usage)) =
       1;
END_ENTITY;

FUNCTION unambiguously_specified_multi_level_reference_designator(links : LIST [1:?] OF next_assembly_usage_occurrence) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF(links) - 1;
    CASE true OF
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.relating_product_definition)) AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN
       TYPEOF(links[i + 1]\product_definition_relationship.relating_product_definition)) : BEGIN  
                                                                                                  IF NOT ((links[i]
                                                                                                                \product_definition_relationship
                                                                                                                .related_product_definition :=:
                                                                                                           links[i + 1]
                                                                                                                \product_definition_relationship
                                                                                                                .relating_product_definition) OR
                                                                                                          ((SIZEOF(
                                                                                                            QUERY(pdr <* USEDIN(
                                                                                                                         links
                                                                                                                              [i]
                                                                                                                              \product_definition_relationship
                                                                                                                              .related_product_definition,
                                                                                                                         'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | pdr
                                                                                                                                                                                                                      \product_definition_relationship
                                                                                                                                                                                                                      .relating_product_definition :=:
                                                                                                                                                                                                                   links
                                                                                                                                                                                                                        [i +
                                                                                                                                                                                                                         1]
                                                                                                                                                                                                                        \product_definition_relationship
                                                                                                                                                                                                                        .relating_product_definition)) =
                                                                                                            1) AND
                                                                                                           (links[i]
                                                                                                                 \product_definition_relationship
                                                                                                                 .related_product_definition
                                                                                                                 \product_definition
                                                                                                                 .formation
                                                                                                                 \product_definition_formation
                                                                                                                 .of_product :=:
                                                                                                            links[i + 1]
                                                                                                                 \product_definition_relationship
                                                                                                                 .relating_product_definition
                                                                                                                 \product_definition
                                                                                                                 .formation
                                                                                                                 \product_definition_formation
                                                                                                                 .of_product)))
                                                                                                  THEN
                                                                                                    RETURN(false);
                                                                                                  END_IF;
      END;
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i + 1]\product_definition_relationship.relating_product_definition)) : BEGIN  
                                                                                                  IF NOT ((links[i]
                                                                                                                \product_definition_relationship
                                                                                                                .related_product_definition :=:
                                                                                                           links[i + 1]
                                                                                                                \product_definition_relationship
                                                                                                                .relating_product_definition) OR
                                                                                                          ((SIZEOF(
                                                                                                            QUERY(pdr <* USEDIN(
                                                                                                                         links
                                                                                                                              [i]
                                                                                                                              \product_definition_relationship
                                                                                                                              .related_product_definition,
                                                                                                                         'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | pdr
                                                                                                                                                                                                                      \product_definition_relationship
                                                                                                                                                                                                                      .relating_product_definition :=:
                                                                                                                                                                                                                   links
                                                                                                                                                                                                                        [i +
                                                                                                                                                                                                                         1]
                                                                                                                                                                                                                        \product_definition_relationship
                                                                                                                                                                                                                        .relating_product_definition)) =
                                                                                                            1) AND
                                                                                                           (links[i]
                                                                                                                 \product_definition_relationship
                                                                                                                 .related_product_definition
                                                                                                                 \product_definition_reference
                                                                                                                 .product_id =
                                                                                                            links[i + 1]
                                                                                                                 \product_definition_relationship
                                                                                                                 .relating_product_definition
                                                                                                                 \product_definition_reference
                                                                                                                 .product_id) AND
                                                                                                           (links[i]
                                                                                                                 \product_definition_relationship
                                                                                                                 .related_product_definition
                                                                                                                 \product_definition_reference
                                                                                                                 .id_owning_organization_name =
                                                                                                            links[i + 1]
                                                                                                                 \product_definition_relationship
                                                                                                                 .relating_product_definition
                                                                                                                 \product_definition_reference
                                                                                                                 .id_owning_organization_name) AND
                                                                                                           (links[i]
                                                                                                                 \product_definition_relationship
                                                                                                                 .related_product_definition
                                                                                                                 \product_definition_reference
                                                                                                                 .product_definition_id <>
                                                                                                            links[i + 1]
                                                                                                                 \product_definition_relationship
                                                                                                                 .relating_product_definition
                                                                                                                 \product_definition_reference
                                                                                                                 .product_definition_id)))
                                                                                                  THEN
                                                                                                    RETURN(false);
                                                                                                  END_IF;
      END;
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_REFERENCE' IN
       TYPEOF(links[i]\product_definition_relationship.relating_product_definition)) AND
      ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN
       TYPEOF(links[i]\product_definition_relationship.related_product_definition)) : RETURN(false);
      OTHERWISE: RETURN(false);
    END_CASE;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.6 2004/01/13 10:15:26 robbod Exp
  ISO TC184/SC4/WG12 N2528 - ISO/TS 10303-1018 Product version - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N1106
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA product_version_mim;
USE FROM product_identification_mim;
USE FROM product_definition_schema
  (product_definition_formation);
END_SCHEMA;


(*
  Id: mim.exp,v 1.18 2015/09/08 15:35:29 sophieherail Exp
  ISO TC184/SC4/WG12 N8867 - ISO/TS 10303-1019 Product view definition - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4352
  *)
(*  Interfaces:                 6 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA product_view_definition_mim;
USE FROM product_version_mim;
USE FROM shape_property_assignment_mim;
USE FROM application_context_schema
  (product_definition_context);
USE FROM basic_attribute_schema
  (name_attribute,
   name_attribute_select);
USE FROM product_definition_schema
  (product_definition,
   product_definition_context_association);
REFERENCE FROM support_resource_schema
  (bag_to_set);
END_SCHEMA;


(*
  Id: mim.exp,v 1.2 2012/10/11 05:49:13 liutkuviene Exp
  ISO TC184/SC4/WG12 N7769 - ISO/TS 10303-1823 Product view definition reference - EXPRESS MIM*)
(*  Interfaces:                 5 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA product_view_definition_reference_mim;
USE FROM support_resource_mim;
USE FROM external_item_identification_assignment_mim;
USE FROM product_view_definition_mim;
USE FROM external_reference_schema
  (externally_defined_item,
   external_source);
USE FROM product_definition_schema
  (generic_product_definition_reference,
   product_definition_reference,
   product_definition_reference_with_local_representation);

TYPE pie_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
  (generic_product_definition_reference);
END_TYPE;
END_SCHEMA;


(*
  Id: mim.exp,v 1.6 2012/09/22 18:15:05 thomasrthurman Exp
  ISO TC184/SC4/WG12 N1142 - ISO/TS 10303-1041 Product view definition relationship - EXPRESS MIM
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA product_view_definition_relationship_mim;
USE FROM product_view_definition_mim;
USE FROM product_view_definition_reference_mim;
USE FROM product_definition_schema
  (product_definition_relationship);
USE FROM product_structure_schema
  (product_definition_usage);
END_SCHEMA;


(*
  Id: mim.exp,v 1.15 2012/10/11 05:49:17 liutkuviene Exp
  ISO TC184/SC4/WG12 N8042 - ISO/TS 10303-1030 Property assignment - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7458
  *)
(*  Interfaces:                 5 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA property_assignment_mim;
USE FROM basic_attribute_schema
  (id_attribute,
   id_attribute_select);
USE FROM foundation_representation_mim;
USE FROM independent_property_mim;
USE FROM product_property_definition_schema
  (general_property_association,
   property_definition);
USE FROM product_property_representation_schema
  (property_definition_representation);
END_SCHEMA;


(*
  Id: qualifications_schema.exp,v 1.16 2014/03/04 00:30:40 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Qualifications schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Qualifications schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   4 *)
(*  Functions:                  2 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA qualifications_schema '{iso standard 10303 part(41) version(6) object(1) qualifications_schema(20)}';
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text,
   bag_to_set);

ENTITY qualification;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_relationship;
  id                     : identifier;
  name                   : label;
  description            : OPTIONAL text;
  relating_qualification : qualification;
  related_qualification  : qualification;
END_ENTITY;

ENTITY qualification_type;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY qualification_type_relationship;
  id                          : identifier;
  name                        : label;
  description                 : OPTIONAL text;
  relating_qualification_type : qualification_type;
  related_qualification_type  : qualification_type;
END_ENTITY;

FUNCTION acyclic_qualification_relationship(relation : qualification_relationship;
                                            relatives : SET OF qualification;
                                            specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF qualification_relationship;
END_LOCAL;
  IF relation.relating_qualification IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(qual <* bag_to_set(
                     USEDIN(relation.relating_qualification,
                     'QUALIFICATIONS_SCHEMA.QUALIFICATION_RELATIONSHIP.RELATED_QUALIFICATION')) | specific_relation IN
                                                                                                  TYPEOF(qual));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_qualification_type_relationship(relation : qualification_type_relationship;
                                                 relatives : SET OF qualification_type;
                                                 specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF qualification_type_relationship;
END_LOCAL;
  IF relation.relating_qualification_type IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(qultyp <* bag_to_set(
                       USEDIN(relation.relating_qualification_type,
                       'QUALIFICATIONS_SCHEMA.QUALIFICATION_TYPE_RELATIONSHIP.RELATED_QUALIFICATION_TYPE')) | specific_relation IN
                                                                                                              TYPEOF(
                                                                                                              qultyp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type,
           specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.10 2012/10/08 00:36:34 thomasrthurman Exp
  ISO TC184/SC4/WG12 N7724 - ISO/TS 10303-1782 Qualified measure - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N6559
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      1 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA qualified_measure_mim;
USE FROM measure_representation_mim;
USE FROM qualified_measure_schema
  (expanded_uncertainty,
   measure_qualification,
   measure_representation_item,
   qualified_representation_item,
   qualitative_uncertainty,
   precision_qualifier,
   standard_uncertainty,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier);
USE FROM representation_schema
  (uncertainty_assigned_representation);

RULE consistent_uncertainty FOR (global_uncertainty_assigned_context,
                                 qualified_representation_item,
                                 uncertainty_assigned_representation);
WHERE
  WR1: SIZEOF(
       QUERY(guac <* global_uncertainty_assigned_context | SIZEOF(
                                                           QUERY(u1 <* guac.uncertainty | SIZEOF(
                                                                                          QUERY(u2 <* guac
                                                                                                          .uncertainty | u2
                                                                                                                           .name =
                                                                                                                         u1
                                                                                                                           .name)) >
                                                                                          1)) >
                                                           0)) =
       0;
  WR2: SIZEOF(
       QUERY(uar <* uncertainty_assigned_representation | SIZEOF(
                                                          QUERY(u1 <* uar.uncertainty | SIZEOF(
                                                                                        QUERY(u2 <* uar.uncertainty | u2
                                                                                                                        .name = 
                                                                                                                      u1
                                                                                                                        .name)) >
                                                                                        1)) >
                                                          0)) =
       0;
  WR3: SIZEOF(
       QUERY(qri <* qualified_representation_item | SIZEOF(
                                                    QUERY(u1 <* qri
                                                                   .qualifiers | ('QUALIFIED_MEASURE_SCHEMA.UNCERTAINTY_QUALIFIER' IN
                                                                                  TYPEOF(u1)) AND
                                                                                 (SIZEOF(
                                                                                  QUERY(u2 <* qri
                                                                                                 .qualifiers | ('QUALIFIED_MEASURE_SCHEMA.UNCERTAINTY_QUALIFIER' IN
                                                                                                                TYPEOF(
                                                                                                                u2)) AND
                                                                                                               (u2
                                                                                                                  \uncertainty_qualifier
                                                                                                                  .measure_name =
                                                                                                                u1
                                                                                                                  \uncertainty_qualifier
                                                                                                                  .measure_name))) >
                                                                                  1))) >
                                                    0)) =
       0;
END_RULE;
END_SCHEMA;


(*
  Id: qualified_measure_schema.exp,v 1.9 2014/03/04 00:30:40 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N6751

  EXPRESS Source:
  ISO 10303-45 ed3 Material and other engineering properties - Qualified measure schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-45 ed3 Material and other engineering properties - Qualified measure schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                  14 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      2 *)

SCHEMA qualified_measure_schema '{iso standard 10303 part(45) version(3) object(1) qualified_measure_schema(3)}';
REFERENCE FROM mathematical_functions_schema
  (maths_value);
REFERENCE FROM measure_schema
  (measure_with_unit,
   unit);
REFERENCE FROM representation_schema
  (representation_item);
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text,
   bag_to_set);

TYPE value_format_type = identifier;
WHERE
  WR1: LENGTH(SELF) <= 80;
END_TYPE;

TYPE value_qualifier = SELECT 
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier,
   value_format_type_qualifier);
END_TYPE;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY maths_value_qualification;
  name                  : label;
  description           : text;
  qualified_maths_value : maths_value_with_unit;
  qualifiers            : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers | 'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN
            TYPEOF(SELF\maths_value_qualification.qualified_maths_value));
END_ENTITY;

ENTITY maths_value_representation_item
  SUBTYPE OF (representation_item, maths_value_with_unit);
END_ENTITY;

ENTITY maths_value_with_unit;
  value_component : maths_value;
  unit_component  : unit;
END_ENTITY;

ENTITY measure_qualification;
  name              : label;
  description       : text;
  qualified_measure : measure_with_unit;
  qualifiers        : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers | 'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(SELF\measure_qualification.qualified_measure));
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers | 'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER' IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY uncertainty_qualifier
  SUPERTYPE OF (ONEOF(standard_uncertainty, qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

ENTITY value_format_type_qualifier;
  format_type : value_format_type;
END_ENTITY;
END_SCHEMA;


(*
  Id: representation_schema.exp,v 1.15 2015/12/01 11:14:38 kevletu Exp
  ISO 10303 TC184/SC4/WG12 N8596

  EXPRESS Source:
  ISO 10303-43 ed3 Representation structures - Representation schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-43 ed3 Representation structures - Representation schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  0 *)
(*  Entities:                  22 *)
(*  Functions:                  6 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      9 *)

SCHEMA representation_schema '{iso standard 10303 part(43) version(6) object(1) representation_schema(1)}';
REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_id_value,
   id_attribute,
   id_attribute_select);
REFERENCE FROM measure_schema
  (measure_value,
   measure_with_unit);
REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);

TYPE compound_item_definition = SELECT 
  (list_representation_item,
   set_representation_item);
END_TYPE;

TYPE founded_item_select = SELECT 
  (founded_item,
   representation_item);
END_TYPE;

TYPE list_item_defined_transformation = LIST [2:?] OF item_defined_transformation;
END_TYPE;

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE;

TYPE rs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH 
  (representation);
END_TYPE;

TYPE rs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (representation);
END_TYPE;

TYPE set_item_defined_transformation = SET [2:?] OF item_defined_transformation;
END_TYPE;

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;

TYPE transformation = SELECT 
  (item_defined_transformation,
   functionally_defined_transformation,
   list_item_defined_transformation,
   set_item_defined_transformation);
END_TYPE;

ENTITY binary_representation_item
  SUBTYPE OF (representation_item);
  binary_value : BINARY;
END_ENTITY;

ENTITY bytes_representation_item
  SUBTYPE OF (binary_representation_item);
DERIVE
  no_of_bytes : INTEGER := BLENGTH(SELF\binary_representation_item.binary_value) DIV 8;
WHERE
  WR1: BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0;
END_ENTITY;

ENTITY compound_representation_item
  SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;

ENTITY definitional_representation
  SUBTYPE OF (representation);
WHERE
  WR1: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
END_ENTITY;

ENTITY definitional_representation_relationship
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: acyclic_representation_relationship(SELF, [SELF\representation_relationship.rep_2],
       'REPRESENTATION_SCHEMA.REPRESENTATION');
END_ENTITY;

ENTITY definitional_representation_relationship_with_same_context
  SUBTYPE OF (definitional_representation_relationship);
WHERE
  WR1: SELF\representation_relationship.rep_1.context_of_items :=:
       SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;

ENTITY founded_item;
DERIVE
  users : SET [0:?] OF founded_item_select := using_items(SELF, []);
WHERE
  WR1: SIZEOF(users) > 0;
  WR2: NOT (SELF IN users);
END_ENTITY;

ENTITY functionally_defined_transformation;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY global_uncertainty_assigned_context
  SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY item_defined_transformation;
  name             : label;
  description      : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;

ENTITY mapped_item
  SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  WR1: acyclic_mapped_representation(SELF);
END_ENTITY;

ENTITY parametric_representation_context
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY representation;
  name             : label;
  items            : SET [1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id          : identifier := get_id_value(SELF);
  description : text       := get_description_value(SELF);
WHERE
  WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY representation_context;
  context_identifier : identifier;
  context_type       : text;
INVERSE
  representations_in_context : SET [1:?]OF representation FOR context_of_items;
END_ENTITY;

ENTITY representation_item
  SUPERTYPE OF (ONEOF(binary_representation_item, compound_representation_item, mapped_item,
                      value_representation_item));
  name : label;
WHERE
  WR1: SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;

ENTITY representation_item_relationship;
  name                         : label;
  description                  : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item  : representation_item;
END_ENTITY;

ENTITY representation_map;
  mapping_origin        : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET [1:?]OF mapped_item FOR mapping_source;
WHERE
  WR1: item_in_context(SELF.mapping_origin, SELF.mapped_representation.context_of_items);
END_ENTITY;

ENTITY representation_relationship;
  name        : label;
  description : OPTIONAL text;
  rep_1       : representation;
  rep_2       : representation;
END_ENTITY;

ENTITY representation_relationship_with_transformation
  SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  WR1: SELF\representation_relationship.rep_1.context_of_items :<>:
       SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY;

ENTITY uncertainty_assigned_representation
  SUBTYPE OF (representation);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;

ENTITY uncertainty_measure_with_unit
  SUBTYPE OF (measure_with_unit);
  name        : label;
  description : OPTIONAL text;
WHERE
  WR1: valid_measure_value(SELF\measure_with_unit.value_component);
END_ENTITY;

ENTITY value_representation_item
  SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  WR1: SIZEOF(
       QUERY(rep <* using_representations(SELF) | NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN
                                                       TYPEOF(rep.context_of_items)))) =
       0;
END_ENTITY;

FUNCTION acyclic_mapped_representation(mi : mapped_item) : BOOLEAN;
LOCAL
  rms : SET OF representation_map;
  mis : SET OF mapped_item;
  rs1 : SET OF representation;
  rs2 : SET OF representation;
END_LOCAL;
  rs1 := using_representations(mi);
  rs2 := [];
  REPEAT WHILE SIZEOF(rs1) > 0;
    REPEAT i := 1 TO HIINDEX(rs1);
      rms := bag_to_set(USEDIN(rs1[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
      IF SIZEOF(rms) > 0
      THEN
        REPEAT j := 1 TO HIINDEX(rms);
          mis := bag_to_set(USEDIN(rms[i], 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
          IF SIZEOF(mis) > 0
          THEN
            REPEAT j := 1 TO HIINDEX(mis);
              IF mis[i] :=: mi
              THEN
                RETURN(false);
              END_IF;
              rs2 := rs2 + using_representations(mis[i]);
            END_REPEAT;
          END_IF;
        END_REPEAT;
      END_IF;
    END_REPEAT;
    rs1 := rs2;
    rs2 := [];
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION acyclic_representation_relationship(relation : representation_relationship;
                                             relatives : SET [1:?] OF representation;
                                             specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF representation_relationship;
END_LOCAL;
  IF relation.rep_1 IN relatives
  THEN
    RETURN(false);
  END_IF;
  x := QUERY(r <* bag_to_set(
                  USEDIN(relation.rep_1,
                  'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_2')) | specific_relation IN TYPEOF(r));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation)
    THEN
      RETURN(false);
    END_IF;
  END_REPEAT;
  RETURN(true);
END_FUNCTION;

FUNCTION item_in_context(item : representation_item;
                         cntxt : representation_context) : BOOLEAN;
LOCAL
  y : BAG OF representation_item;
END_LOCAL;
  IF SIZEOF(USEDIN(item, 'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS') * cntxt.representations_in_context) > 0
  THEN
    RETURN(true);
  ELSE
    y := QUERY(z <* USEDIN(item, '') | 'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
    IF SIZEOF(y) > 0
    THEN
      REPEAT i := 1 TO HIINDEX(y);
        IF item_in_context(y[i], cntxt)
        THEN
          RETURN(true);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(false);
END_FUNCTION;

FUNCTION using_items(item : founded_item_select;
                     checked_items : SET OF founded_item_select) : SET OF founded_item_select;
LOCAL
  new_check_items : SET OF founded_item_select;
  result_items    : SET OF founded_item_select;
  next_items      : SET OF founded_item_select;
END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  next_items := QUERY(z <* bag_to_set(USEDIN(item, '')) | ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
                                                          ('REPRESENTATION_SCHEMA.FOUNDED_ITEM' IN TYPEOF(z)));
  IF SIZEOF(next_items) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(next_items);
      IF NOT (next_items[i] IN new_check_items)
      THEN
        result_items := result_items + next_items[i] + using_items(next_items[i], new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(result_items);
END_FUNCTION;

FUNCTION using_representations(item : founded_item_select) : SET OF representation;
LOCAL
  results            : SET OF representation;
  result_bag         : BAG OF representation;
  intermediate_items : SET OF founded_item_select;
END_LOCAL;
  results := [];
  result_bag := USEDIN(item, 'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  intermediate_items := using_items(item, []);
  IF SIZEOF(intermediate_items) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i], 'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0
      THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(results);
END_FUNCTION;

FUNCTION valid_measure_value(m : measure_value) : BOOLEAN;
  IF ('REAL' IN TYPEOF(m))
  THEN
    RETURN(m > 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF(m))
    THEN
      RETURN(m > 0);
    ELSE
      RETURN(true);
    END_IF;
  END_IF;
END_FUNCTION;
END_SCHEMA;


(*
  Id: scan_data_3d_shape_model_schema.exp,v 1.7 2016/06/02 16:04:20 lothartklein Exp
  ISO 10303 TC184/SC4/WG12 N9204

  EXPRESS Source:
  ISO 10303-42 ed5 Geometric and topological representation - Scan data 3d shape model schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-42 ed5 Geometric and topological representation - Scan data 3d shape model schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 5 *)
(*  Constants:                  0 *)
(*  Entities:                  11 *)
(*  Functions:                  1 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      1 *)

SCHEMA scan_data_3d_shape_model_schema;
REFERENCE FROM measure_schema
  (global_unit_assigned_context,
   positive_length_measure);
REFERENCE FROM representation_schema
  (representation,
   representation_item,
   using_representations);
REFERENCE FROM product_property_representation_schema
  (shape_representation);
REFERENCE FROM support_resource_schema
  (label);
REFERENCE FROM geometry_schema
  (axis2_placement_3d,
   geometric_representation_item,
   geometric_representation_context);

TYPE point_cloud_set_or_superset = SELECT 
  (point_cloud_dataset,
   point_cloud_superdataset);
END_TYPE;

ENTITY point_cloud_dataset
  SUBTYPE OF (scanned_data_item);
  point_coordinates : LIST [1:?] OF LIST [3:3] OF REAL;
END_ENTITY;

ENTITY point_cloud_dataset_with_colours
  SUBTYPE OF (point_cloud_dataset);
  colour_indices : LIST [1:?] OF LIST [3:3] OF INTEGER;
WHERE
  WR1: SIZEOF(colour_indices) = SIZEOF(SELF\point_cloud_dataset.point_coordinates);
END_ENTITY;

ENTITY point_cloud_dataset_with_intensities
  SUBTYPE OF (point_cloud_dataset);
  intensities : LIST [1:?] OF REAL;
WHERE
  WR1: SIZEOF(intensities) = SIZEOF(SELF\point_cloud_dataset.point_coordinates);
END_ENTITY;

ENTITY point_cloud_dataset_with_normals
  SUBTYPE OF (point_cloud_dataset);
  normals : LIST [1:?] OF LIST [3:3] OF REAL;
WHERE
  WR1: SIZEOF(normals) = SIZEOF(SELF\point_cloud_dataset.point_coordinates);
END_ENTITY;

ENTITY point_cloud_superdataset
  SUBTYPE OF (scanned_data_item);
  pts_per_sublist : INTEGER;
  sublists        : LIST [2:?] OF point_cloud_dataset;
WHERE
  WR1: consistent_sizes(SELF.pts_per_sublist, SELF.sublists);
END_ENTITY;

ENTITY scanned_data_item
  SUPERTYPE OF (ONEOF(point_cloud_dataset, point_cloud_superdataset, triangulated_point_cloud_dataset, scan_3d_model))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SIZEOF(
       QUERY(using_rep <* using_representations(
                          SELF) | NOT ('SCAN_DATA_3D_SHAPE_MODEL_SCHEMA.SCAN_DATA_SHAPE_REPRESENTATION' IN
                                       TYPEOF(using_rep)))) =
       0;
END_ENTITY;

ENTITY scanner_basic_properties
  SUBTYPE OF (scanner_property);
  scanner_identification : label;
  scanner_location       : axis2_placement_3d;
  scanner_uncertainty    : OPTIONAL positive_length_measure;
END_ENTITY;

ENTITY scanner_property
  ABSTRACT SUPERTYPE
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY scan_3d_model
  SUBTYPE OF (scanned_data_item);
  scanner_info   : SET [1:?] OF scanner_property;
  scanned_points : SET [1:?] OF scanned_data_item;
WHERE
  WR1: SIZEOF(QUERY(tmp <* scanned_points | 'SCAN_DATA_3D_SHAPE_MODEL_SCHEMA.SCAN_3D_MODEL' IN TYPEOF(tmp))) = 0;
END_ENTITY;

ENTITY scan_data_shape_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1:?] OF scanned_data_item;
WHERE
  WR1: 'REPRESENTATION_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
END_ENTITY;

ENTITY triangulated_point_cloud_dataset
  SUBTYPE OF (scanned_data_item);
  points    : point_cloud_set_or_superset;
  triangles : LIST [1:?] OF LIST [3:3] OF INTEGER;
END_ENTITY;

FUNCTION consistent_sizes(max : INTEGER;
                          point_lists : LIST OF point_cloud_dataset) : BOOLEAN;
LOCAL
  ndatasets : INTEGER := SIZEOF(point_lists);
  result    : BOOLEAN := true;
END_LOCAL;
  REPEAT i := 1 TO (ndatasets - 1);
    IF (SIZEOF(point_lists[i].point_coordinates) <> max)
    THEN
      result := false;
      RETURN(result);
    END_IF;
  END_REPEAT;
  IF (SIZEOF(point_lists[ndatasets].point_coordinates) > max)
  THEN
    result := false;
    RETURN(result);
  END_IF;
  RETURN(result);
END_FUNCTION;
END_SCHEMA;


(*
  Id: security_classification_schema.exp,v 1.11 2014/03/04 00:30:41 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Security classification schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Security classification schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA security_classification_schema '{iso standard 10303 part(41) version(3) object(1) security_classification_schema(21)}';
REFERENCE FROM support_resource_schema
  (label,
   text);

ENTITY security_classification;
  name           : label;
  purpose        : text;
  security_level : security_classification_level;
END_ENTITY;

ENTITY security_classification_level;
  name : label;
END_ENTITY;
END_SCHEMA;


(*
  Id: shape_dimension_schema.exp,v 1.23 2015/04/28 10:42:19 lothartklein Exp
  ISO 10303 TC184/SC4/WG12 N7297

  EXPRESS Source:
  ISO 10303-47 ed2 Shape variation tolerances - Shape dimension schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-47 ed2 Shape variation tolerances - Shape dimension schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 8 *)
(*  Constants:                  0 *)
(*  Entities:                   9 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      6 *)

SCHEMA shape_dimension_schema '{iso standard 10303 part(47) version(2) object(1) shape_dimension_schema(2)}';
REFERENCE FROM basic_attribute_schema
  (get_id_value,
   id_attribute,
   id_attribute_select);
REFERENCE FROM measure_schema
  (measure_with_unit);
REFERENCE FROM representation_schema
  (representation,
   compound_representation_item);
REFERENCE FROM qualified_measure_schema
  (descriptive_representation_item,
   measure_representation_item,
   qualified_representation_item);
REFERENCE FROM product_property_representation_schema
  (denoted_object_select,
   item_identified_representation_usage_definition,
   shape_representation);
REFERENCE FROM product_property_definition_schema
  (shape_aspect,
   shape_aspect_relationship);
REFERENCE FROM support_resource_schema
  (identifier,
   label,
   text);
REFERENCE FROM geometry_schema
  (placement);

TYPE angle_relator = ENUMERATION OF
  (equal,
   large,
   small);
END_TYPE;

TYPE dimensional_characteristic = SELECT 
  (dimensional_location,
   dimensional_size);
END_TYPE;

TYPE sds_denoted_object_select = SELECT BASED_ON denoted_object_select WITH 
  (dimensional_size,
   dimensional_location);
END_TYPE;

TYPE sds_item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON item_identified_representation_usage_definition WITH 
  (dimensional_size);
END_TYPE;

TYPE sd_id_attribute_select = SELECT BASED_ON id_attribute_select WITH 
  (dimensional_size);
END_TYPE;

TYPE shape_dimension_representation_item = SELECT 
  (compound_representation_item,
   descriptive_representation_item,
   measure_representation_item,
   placement);
END_TYPE;

ENTITY angular_location
  SUBTYPE OF (dimensional_location);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY angular_size
  SUBTYPE OF (dimensional_size);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY dimensional_characteristic_representation;
  dimension      : dimensional_characteristic;
  representation : shape_dimension_representation;
END_ENTITY;

ENTITY dimensional_location
  SUPERTYPE OF (ONEOF(angular_location, dimensional_location_with_path))
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
  WR2: SELF\shape_aspect_relationship.relating_shape_aspect.of_shape :=:
       SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
END_ENTITY;

ENTITY dimensional_location_with_path
  SUBTYPE OF (dimensional_location);
  path : shape_aspect;
END_ENTITY;

ENTITY dimensional_size
  SUPERTYPE OF (ONEOF(angular_size, dimensional_size_with_path));
  applies_to : shape_aspect;
  name       : label;
DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, applies_to;
WHERE
  WR1: applies_to.product_definitional = true;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY dimensional_size_with_path
  SUBTYPE OF (dimensional_size);
  path : shape_aspect;
END_ENTITY;

ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY;

ENTITY shape_dimension_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET [1:?] OF shape_dimension_representation_item;
END_ENTITY;
END_SCHEMA;


(*
  	$Id: mim.exp,v 1.33 2015/09/07 15:24:09 sophieherail Exp
  	ISO TC184/SC4/WG12 N8831 - ISO/TS 10303-1032 Shape property assignment - EXPRESS MIM
  	Supersedes ISO TC184/SC4/WG12 N8051
  *)
(*  Interfaces:                 8 *)
(*  Constants:                  0 *)
(*  Entities:                   2 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      3 *)

SCHEMA shape_property_assignment_mim;
USE FROM property_assignment_mim;
USE FROM assembly_structure_mim;
USE FROM external_model_mim;
USE FROM geometric_model_relationship_mim;
USE FROM product_view_definition_relationship_mim;
USE FROM basic_attribute_schema
  (id_attribute);
USE FROM product_property_definition_schema
  (characterized_product_definition,
   product_definition_shape,
   shape_aspect,
   shape_aspect_relationship);
USE FROM product_property_representation_schema
  (item_identified_representation_usage,
   chain_based_item_identified_representation_usage,
   shape_definition_representation);

TYPE geometric_item_specific_usage_select = SELECT 
  (shape_aspect,
   shape_aspect_relationship);
END_TYPE;

TYPE geometric_model_item = EXTENSIBLE GENERIC_ENTITY SELECT 
  (geometric_representation_item);
END_TYPE;

TYPE shape_model = EXTENSIBLE GENERIC_ENTITY SELECT 
  (shape_representation);
END_TYPE;

ENTITY chain_based_geometric_item_specific_usage
  SUBTYPE OF (geometric_item_specific_usage, chain_based_item_identified_representation_usage);
END_ENTITY;

ENTITY geometric_item_specific_usage
  SUBTYPE OF (item_identified_representation_usage);
  SELF\item_identified_representation_usage.definition                 : geometric_item_specific_usage_select;
  SELF\item_identified_representation_usage.used_representation        : shape_model;
  SELF\item_identified_representation_usage.identified_item            : geometric_model_item;
UNIQUE
  UR1: definition;
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.10 2009/04/23 08:59:14 liutkuviene Exp
  ISO TC184/SC4/WG12 N6262 - ISO/TS 10303-1746 Software - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4186
  *)
(*  Interfaces:                 4 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA software_mim;
USE FROM document_definition_mim;
USE FROM product_identification_mim;
USE FROM information_product_mim;
USE FROM product_definition_schema
  (product_related_product_category);
END_SCHEMA;


(*
  Id: mim.exp,v 1.4 2012/10/11 05:49:06 liutkuviene Exp
  ISO TC184/SC4/WG12 N8060 - ISO/TS 10303-1800 Support resource - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7473
  *)
(*  Interfaces:                 1 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA support_resource_mim;
USE FROM support_resource_schema;
END_SCHEMA;


(*
  Id: support_resource_schema.exp,v 1.17 2014/03/04 00:30:42 thomasrthurman Exp
  ISO 10303 TC184/SC4/WG12 N8369

  EXPRESS Source:
  ISO 10303-41 ed4 Fundamentals of product description and support - Support resource schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-41 ed4 Fundamentals of product description and support - Support resource schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 0 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  2 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      3 *)

SCHEMA support_resource_schema '{iso standard 10303 part(41) version(7) object(1) support_resource_schema(22)}';


TYPE identifier = STRING;
END_TYPE;

TYPE label = STRING;
END_TYPE;

TYPE text = STRING;
END_TYPE;

FUNCTION bag_to_set(the_bag : BAG OF GENERIC:intype) : SET OF GENERIC:intype;
LOCAL
  the_set : SET OF GENERIC:intype := [];
END_LOCAL;
  IF SIZEOF(the_bag) > 0
  THEN
    REPEAT i := 1 TO HIINDEX(the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN(the_set);
END_FUNCTION;

FUNCTION type_check_function(the_type : GENERIC;
                             sub_names : SET OF STRING;
                             criterion : INTEGER) : LOGICAL;
  IF ((NOT EXISTS(the_type)) OR (SIZEOF(sub_names) = 0))
  THEN
    RETURN(unknown);
  ELSE
    CASE criterion OF
      0 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) > 0);
      1 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 0);
      2 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) = 1);
      3 : RETURN(SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
      OTHERWISE: RETURN(unknown);
    END_CASE;
  END_IF;
END_FUNCTION;
END_SCHEMA;


(*
  Id: topology_schema.exp,v 1.14 2016/04/18 08:42:58 kevletu Exp
  ISO 10303 TC184/SC4/WG12 N9204

  EXPRESS Source:
  ISO 10303-42 ed5 Geometric and topological representation - Topology schema

  The following permission notice and disclaimer shall be included in all copies of this EXPRESS schema ("the Schema"),
  and derivations of the Schema:

  Copyright ISO 2014  All rights reserved
  Permission is hereby granted, free of charge in perpetuity, to any person obtaining a copy of the Schema,
  to use, copy, modify, merge and distribute free of charge, copies of the Schema for the purposes of developing,
  implementing, installing and using software based on the Schema, and to permit persons to whom the Schema is furnished to do so,
  subject to the following conditions:

  THE SCHEMA IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SCHEMA OR THE
  USE OR OTHER DEALINGS IN THE SCHEMA.

  In addition, any modified copy of the Schema shall include the following notice:

  THIS SCHEMA HAS BEEN MODIFIED FROM THE SCHEMA DEFINED IN
  ISO 10303-42 ed5 Geometric and topological representation - Topology schema
  AND SHOULD NOT BE INTERPRETED AS COMPLYING WITH THAT STANDARD
  *)
(*  Interfaces:                 3 *)
(*  Constants:                  1 *)
(*  Entities:                  37 *)
(*  Functions:                 22 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      5 *)

SCHEMA topology_schema '{iso standard 10303 part(42) version(10) object(1) topology_schema(2)}';
REFERENCE FROM geometry_schema;
REFERENCE FROM representation_schema
  (representation_item);
REFERENCE FROM measure_schema
  (positive_length_measure);
CONSTANT
  dummy_tri : topological_representation_item := representation_item('') || topological_representation_item();
END_CONSTANT;

TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
END_TYPE;

TYPE reversible_topology = SELECT 
  (reversible_topology_item,
   list_of_reversible_topology_item,
   set_of_reversible_topology_item);
END_TYPE;

TYPE reversible_topology_item = SELECT 
  (edge,
   path,
   face,
   face_bound,
   closed_shell,
   open_shell);
END_TYPE;

TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
END_TYPE;

TYPE shell = SELECT 
  (vertex_shell,
   wire_shell,
   open_shell,
   closed_shell);
END_TYPE;

ENTITY closed_shell
  SUBTYPE OF (connected_face_set);
END_ENTITY;

ENTITY connected_edge_set
  SUBTYPE OF (topological_representation_item);
  ces_edges : SET [1:?] OF edge;
END_ENTITY;

ENTITY connected_face_set
  SUPERTYPE OF (ONEOF(closed_shell, open_shell))
  SUBTYPE OF (topological_representation_item);
  cfs_faces : SET [1:?] OF face;
END_ENTITY;

ENTITY connected_face_sub_set
  SUBTYPE OF (connected_face_set);
  parent_face_set : connected_face_set;
END_ENTITY;

ENTITY connected_volume_set
  SUBTYPE OF (topological_representation_item);
  cvs_volumes : SET [1:?] OF volume_with_faces;
END_ENTITY;

ENTITY connected_volume_sub_set
  SUBTYPE OF (connected_volume_set);
  parent_volume_set : connected_volume_set;
END_ENTITY;

ENTITY edge
  SUPERTYPE OF (ONEOF(edge_curve, edge_with_length, oriented_edge, subedge))
  SUBTYPE OF (topological_representation_item);
  edge_start : vertex;
  edge_end   : vertex;
END_ENTITY;

ENTITY edge_curve
  SUBTYPE OF (edge, geometric_representation_item);
  edge_geometry : curve;
  same_sense    : BOOLEAN;
END_ENTITY;

ENTITY edge_loop
  SUBTYPE OF (loop, path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  WR1: (SELF\path.edge_list[1].edge_start) :=: (SELF\path.edge_list[ne].edge_end);
END_ENTITY;

ENTITY edge_with_length
  SUBTYPE OF (edge);
  edge_length : positive_length_measure;
END_ENTITY;

ENTITY face
  SUPERTYPE OF (ONEOF(face_surface, subface, oriented_face))
  SUBTYPE OF (topological_representation_item);
  bounds : SET [1:?] OF face_bound;
WHERE
  WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
  WR2: SIZEOF(QUERY(temp <* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(temp))) <= 1;
END_ENTITY;

ENTITY face_bound
  SUBTYPE OF (topological_representation_item);
  bound       : loop;
  orientation : BOOLEAN;
END_ENTITY;

ENTITY face_outer_bound
  SUBTYPE OF (face_bound);
END_ENTITY;

ENTITY face_surface
  SUBTYPE OF (face, geometric_representation_item);
  face_geometry : surface;
  same_sense    : BOOLEAN;
WHERE
  WR1: NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
END_ENTITY;

ENTITY loop
  SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
  SUBTYPE OF (topological_representation_item);
END_ENTITY;

ENTITY open_path
  SUBTYPE OF (path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  WR1: (SELF\path.edge_list[1].edge_element.edge_start) :<>: (SELF\path.edge_list[ne].edge_element.edge_end);
END_ENTITY;

ENTITY open_shell
  SUBTYPE OF (connected_face_set);
END_ENTITY;

ENTITY oriented_closed_shell
  SUBTYPE OF (closed_shell);
  closed_shell_element : closed_shell;
  orientation          : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                                           SELF.closed_shell_element.cfs_faces);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element));
END_ENTITY;

ENTITY oriented_edge
  SUBTYPE OF (edge);
  edge_element : edge;
  orientation  : BOOLEAN;
DERIVE
  SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation, SELF.edge_element.edge_start,
                                   SELF.edge_element.edge_end);
  SELF\edge.edge_end : vertex := boolean_choose(SELF.orientation, SELF.edge_element.edge_end,
                                 SELF.edge_element.edge_start);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
END_ENTITY;

ENTITY oriented_face
  SUBTYPE OF (face);
  face_element : face;
  orientation  : BOOLEAN;
DERIVE
  SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.orientation, SELF.face_element.bounds);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
END_ENTITY;

ENTITY oriented_open_shell
  SUBTYPE OF (open_shell);
  open_shell_element : open_shell;
  orientation        : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                                           SELF.open_shell_element.cfs_faces);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF.open_shell_element));
END_ENTITY;

ENTITY oriented_path
  SUBTYPE OF (path);
  path_element : path;
  orientation  : BOOLEAN;
DERIVE
  SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge := conditional_reverse(SELF.orientation,
                                                              SELF.path_element.edge_list);
WHERE
  WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
END_ENTITY;

ENTITY path
  SUPERTYPE OF (ONEOF(open_path, edge_loop, oriented_path))
  SUBTYPE OF (topological_representation_item);
  edge_list : LIST [1:?] OF UNIQUE oriented_edge;
WHERE
  WR1: path_head_to_tail(SELF);
END_ENTITY;

ENTITY poly_loop
  SUBTYPE OF (loop, geometric_representation_item);
  polygon : LIST [3:?] OF UNIQUE cartesian_point;
END_ENTITY;

ENTITY seam_edge
  SUBTYPE OF (oriented_edge);
  pcurve_reference : pcurve;
WHERE
  WR1: ('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(edge_element)) AND
       ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF(edge_element\edge_curve.edge_geometry));
  WR2: pcurve_reference IN edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry;
END_ENTITY;

ENTITY subedge
  SUBTYPE OF (edge);
  parent_edge : edge;
END_ENTITY;

ENTITY subface
  SUBTYPE OF (face);
  parent_face : face;
WHERE
  WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + list_to_set(list_face_loops(parent_face))));
END_ENTITY;

ENTITY topological_representation_item
  SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set,
                      connected_volume_set, volume_with_faces, (loop ANDOR path)))
  SUBTYPE OF (representation_item);
END_ENTITY;

ENTITY vertex
  SUBTYPE OF (topological_representation_item);
END_ENTITY;

ENTITY vertex_loop
  SUBTYPE OF (loop);
  loop_vertex : vertex;
END_ENTITY;

ENTITY vertex_on_edge
  SUBTYPE OF (vertex);
  parent_edge         : edge_with_length;
  distance_from_start : positive_length_measure;
WHERE
  WR1: distance_from_start < parent_edge.edge_length;
END_ENTITY;

ENTITY vertex_point
  SUBTYPE OF (vertex, geometric_representation_item);
  vertex_geometry : point;
END_ENTITY;

ENTITY vertex_shell
  SUBTYPE OF (topological_representation_item);
  vertex_shell_extent : vertex_loop;
END_ENTITY;

ENTITY volume_with_faces
  ABSTRACT SUPERTYPE OF (ONEOF(volume_with_shell, volume_with_parametric_boundary))
  SUBTYPE OF (geometric_representation_item, topological_representation_item);
  volume_geometry : volume;
END_ENTITY;

ENTITY volume_with_parametric_boundary
  SUBTYPE OF (volume_with_faces);
  outer_bound : LIST [6:6] OF face;
END_ENTITY;

ENTITY volume_with_shell
  SUBTYPE OF (volume_with_faces);
  outer_bound : closed_shell;
END_ENTITY;

ENTITY wire_shell
  SUBTYPE OF (topological_representation_item);
  wire_shell_extent : SET [1:?] OF loop;
WHERE
  WR1: NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY;

FUNCTION boolean_choose(b : BOOLEAN;
                        choice1 : GENERIC:item;
                        choice2 : GENERIC:item) : GENERIC:item;
  IF b
  THEN
    RETURN(choice1);
  ELSE
    RETURN(choice2);
  END_IF;
END_FUNCTION;

FUNCTION closed_shell_reversed(a_shell : closed_shell) : oriented_closed_shell;
LOCAL
  the_reverse : oriented_closed_shell;
END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell))
  THEN
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() ||
                   oriented_closed_shell(a_shell\oriented_closed_shell.closed_shell_element,
                                         NOT (a_shell\oriented_closed_shell.orientation));
  ELSE
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || closed_shell() ||
                   oriented_closed_shell(a_shell, false);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION conditional_reverse(p : BOOLEAN;
                             an_item : reversible_topology) : reversible_topology;
  IF p
  THEN
    RETURN(an_item);
  ELSE
    RETURN(topology_reversed(an_item));
  END_IF;
END_FUNCTION;

FUNCTION edge_curve_pcurves(an_edge : edge_curve;
                            the_surface_curves : SET OF surface_curve) : SET OF pcurve;
LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST [1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve)
  THEN
    result := result + a_curve;
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve)
    THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
        IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(the_geometry[k])
        THEN
          result := result + the_geometry[k];
        END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION edge_reversed(an_edge : edge) : oriented_edge;
LOCAL
  the_reverse : oriented_edge;
END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF(an_edge))
  THEN
    the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start) ||
                   oriented_edge(an_edge\oriented_edge.edge_element, NOT (an_edge\oriented_edge.orientation));
  ELSE
    the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start) || oriented_edge(an_edge, false);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION face_bound_reversed(a_face_bound : face_bound) : face_bound;
LOCAL
  the_reverse : face_bound;
END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound))
  THEN
    the_reverse := dummy_tri || face_bound(a_face_bound\face_bound.bound, NOT (a_face_bound\face_bound.orientation)) ||
                   face_outer_bound();
  ELSE
    the_reverse := dummy_tri || face_bound(a_face_bound.bound, NOT (a_face_bound.orientation));
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION face_reversed(a_face : face) : oriented_face;
LOCAL
  the_reverse : oriented_face;
END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF(a_face))
  THEN
    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) ||
                   oriented_face(a_face\oriented_face.face_element, NOT (a_face\oriented_face.orientation));
  ELSE
    the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds)) || oriented_face(a_face, false);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION list_face_loops(f : face) : LIST [0:?] OF loop;
LOCAL
  loops : LIST [0:?] OF loop := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(f.bounds);
    loops := loops + (f.bounds[i].bound);
  END_REPEAT;
  RETURN(loops);
END_FUNCTION;

FUNCTION list_loop_edges(l : loop) : LIST [0:?] OF edge;
LOCAL
  edges : LIST [0:?] OF edge := [];
END_LOCAL;
  IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l)
  THEN
    REPEAT i := 1 TO SIZEOF(l\path.edge_list);
      edges := edges + (l\path.edge_list[i].edge_element);
    END_REPEAT;
  END_IF;
  RETURN(edges);
END_FUNCTION;

FUNCTION list_of_topology_reversed(a_list : list_of_reversible_topology_item) : list_of_reversible_topology_item;
LOCAL
  the_reverse : list_of_reversible_topology_item;
END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_list);
    the_reverse := topology_reversed(a_list[i]) + the_reverse;
  END_REPEAT;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION list_shell_edges(s : shell) : LIST [0:?] OF edge;
LOCAL
  edges : LIST [0:?] OF edge := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
    edges := edges + list_loop_edges(list_shell_loops(s)[i]);
  END_REPEAT;
  RETURN(edges);
END_FUNCTION;

FUNCTION list_shell_faces(s : shell) : LIST [0:?] OF face;
LOCAL
  faces : LIST [0:?] OF face := [];
END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s))
  THEN
    REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
      faces := faces + s\connected_face_set.cfs_faces[i];
    END_REPEAT;
  END_IF;
  RETURN(faces);
END_FUNCTION;

FUNCTION list_shell_loops(s : shell) : LIST [0:?] OF loop;
LOCAL
  loops : LIST [0:?] OF loop := [];
END_LOCAL;
  IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s)
  THEN
    loops := loops + s.vertex_shell_extent;
  END_IF;
  IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s)
  THEN
    REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
      loops := loops + s.wire_shell_extent[i];
    END_REPEAT;
  END_IF;
  IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s))
  THEN
    REPEAT i := 1 TO SIZEOF(s.cfs_faces);
      loops := loops + list_face_loops(s.cfs_faces[i]);
    END_REPEAT;
  END_IF;
  RETURN(loops);
END_FUNCTION;

FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:t) : SET OF GENERIC:t;
LOCAL
  s : SET OF GENERIC:t := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(l);
    s := s + l[i];
  END_REPEAT;
  RETURN(s);
END_FUNCTION;

FUNCTION mixed_loop_type_set(l : SET [0:?] OF loop) : LOGICAL;
LOCAL
  poly_loop_type : LOGICAL;
END_LOCAL;
  IF (SIZEOF(l) <= 1)
  THEN
    RETURN(false);
  END_IF;
  poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
  REPEAT i := 2 TO SIZEOF(l);
    IF (('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
    THEN
      RETURN(true);
    END_IF;
  END_REPEAT;
  RETURN(false);
END_FUNCTION;

FUNCTION open_shell_reversed(a_shell : open_shell) : oriented_open_shell;
LOCAL
  the_reverse : oriented_open_shell;
END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell))
  THEN
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() ||
                   oriented_open_shell(a_shell\oriented_open_shell.open_shell_element,
                                       (NOT (a_shell\oriented_open_shell.orientation)));
  ELSE
    the_reverse := dummy_tri || connected_face_set(a_shell\connected_face_set.cfs_faces) || open_shell() ||
                   oriented_open_shell(a_shell, false);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
LOCAL
  n : INTEGER;
  p : LOGICAL := true;
END_LOCAL;
  n := SIZEOF(a_path.edge_list);
  REPEAT i := 2 TO n;
    p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i].edge_start);
  END_REPEAT;
  RETURN(p);
END_FUNCTION;

FUNCTION path_reversed(a_path : path) : oriented_path;
LOCAL
  the_reverse : oriented_path;
END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF(a_path))
  THEN
    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) ||
                   oriented_path(a_path\oriented_path.path_element, NOT (a_path\oriented_path.orientation));
  ELSE
    the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list)) || oriented_path(a_path, false);
  END_IF;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION set_of_topology_reversed(a_set : set_of_reversible_topology_item) : set_of_reversible_topology_item;
LOCAL
  the_reverse : set_of_reversible_topology_item;
END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_set);
    the_reverse := the_reverse + topology_reversed(a_set[i]);
  END_REPEAT;
  RETURN(the_reverse);
END_FUNCTION;

FUNCTION shell_reversed(a_shell : shell) : shell;
  IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(a_shell))
  THEN
    RETURN(open_shell_reversed(a_shell));
  ELSE
    IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(a_shell))
    THEN
      RETURN(closed_shell_reversed(a_shell));
    ELSE
      RETURN(?);
    END_IF;
  END_IF;
END_FUNCTION;

FUNCTION topology_reversed(an_item : reversible_topology) : reversible_topology;
  IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF(an_item))
  THEN
    RETURN(edge_reversed(an_item));
  END_IF;
  IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF(an_item))
  THEN
    RETURN(path_reversed(an_item));
  END_IF;
  IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF(an_item))
  THEN
    RETURN(face_bound_reversed(an_item));
  END_IF;
  IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF(an_item))
  THEN
    RETURN(face_reversed(an_item));
  END_IF;
  IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF(an_item))
  THEN
    RETURN(shell_reversed(an_item));
  END_IF;
  IF ('SET' IN TYPEOF(an_item))
  THEN
    RETURN(set_of_topology_reversed(an_item));
  END_IF;
  IF ('LIST' IN TYPEOF(an_item))
  THEN
    RETURN(list_of_topology_reversed(an_item));
  END_IF;
  RETURN(?);
END_FUNCTION;

FUNCTION vertex_point_pcurves(a_vertex : vertex_point;
                              the_degenerates : SET OF evaluated_degenerate_pcurve) : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point)
  THEN
    result := result + a_point;
  ELSE
    REPEAT j := 1 TO SIZEOF(the_degenerates);
      IF (the_degenerates[j].equivalent_point :=: a_point)
      THEN
        result := result + the_degenerates[j];
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(result);
END_FUNCTION;
END_SCHEMA;


(*
  Id: mim.exp,v 1.27 2013/02/20 00:35:48 thomasrthurman Exp
  ISO TC184/SC4/WG12 N8245 - ISO/TS 10303-1753 Value with unit extension - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N5534
  *)
(*  Interfaces:                 7 *)
(*  Constants:                  0 *)
(*  Entities:                   8 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA value_with_unit_extension_mim;
USE FROM value_with_unit_mim;
USE FROM iso13584_generic_expressions_schema
  (environment,
   variable_semantics);
USE FROM mathematical_functions_schema
  (complex_number_literal_polar);
USE FROM measure_schema
  (plane_angle_measure_with_unit,
   length_measure_with_unit);
USE FROM qualified_measure_schema
  (measure_representation_item);
USE FROM representation_schema
  (value_representation_item);
REFERENCE FROM measure_schema
  (derive_dimensional_exponents);

ENTITY angle_measure_representation_item
  SUBTYPE OF (measure_representation_item, plane_angle_measure_with_unit);
END_ENTITY;

ENTITY count_representation_item
  SUBTYPE OF (value_representation_item);
WHERE
  WR1: count_measure IN TYPEOF(SELF\value_representation_item.value_component);
END_ENTITY;

ENTITY dielectric_constant_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

ENTITY expression_conversion_based_unit
  SUBTYPE OF (context_dependent_unit, variable_semantics);
INVERSE
  associated_variable_environment : environment FOR semantics;
END_ENTITY;

ENTITY length_measure_representation_item
  SUBTYPE OF (measure_representation_item, length_measure_with_unit);
END_ENTITY;

ENTITY loss_tangent_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

ENTITY thermal_resistance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'VALUE_WITH_UNIT_EXTENSION_MIM.THERMAL_RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermal_resistance_unit
  SUBTYPE OF (derived_unit);
WHERE
  WR1: derive_dimensional_exponents(SELF) = dimensional_exponents(-1.0, -1.0, -3.0, 0.0, 1.0, 0.0, 0.0);
END_ENTITY;
END_SCHEMA;


(*
  Id: mim.exp,v 1.15 2012/10/11 05:49:06 liutkuviene Exp
  ISO TC184/SC4/WG12 N7844 - ISO/TS 10303-1054 Value with unit - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N7239
  *)
(*  Interfaces:                 2 *)
(*  Constants:                  0 *)
(*  Entities:                   0 *)
(*  Functions:                  0 *)
(*  Procedures:                 0 *)
(*  Rules:                      0 *)
(*  Subtype_Constraints:        0 *)
(*  Types:                      0 *)

SCHEMA value_with_unit_mim;
USE FROM measure_schema;
USE FROM representation_schema
  (uncertainty_measure_with_unit);
END_SCHEMA;


