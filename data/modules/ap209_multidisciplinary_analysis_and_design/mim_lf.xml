<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express description.file="descriptions.xml" language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" reference="">
   <application name="JSDAI" owner="LKSoft" source="ap209_multidisciplinary_analysis_and_design_mim_lf schema_instance" url="www.lksoft.com" version="4.0 beta"/>
   <schema name="Ap209_multidisciplinary_analysis_and_design_mim_LF">
      <constant expression="make_extended_tuple_space(&#10;    the_zero_tuple_space, the_integers)" name="the_integer_tuples">
         <typename name="extended_tuple_space"/>
      </constant>
      <constant expression="[]" name="the_empty_maths_tuple">
         <typename name="maths_tuple"/>
      </constant>
      <constant expression="make_elementary_space(es_generics)" name="the_generics">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_elementary_space(es_integers)" name="the_integers">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_elementary_space(es_reals)" name="the_reals">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_elementary_space(es_booleans)" name="the_booleans">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_elementary_space(es_strings)" name="the_strings">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_elementary_space(es_complex_numbers)" name="the_complex_numbers">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_elementary_space(es_numbers)" name="the_numbers">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_listed_product_space([])" name="the_zero_tuple_space">
         <typename name="listed_product_space"/>
      </constant>
      <constant expression="make_extended_tuple_space(&#10;    the_zero_tuple_space, the_generics)" name="the_tuples">
         <typename name="extended_tuple_space"/>
      </constant>
      <constant expression="make_finite_space([])" name="the_empty_space">
         <typename name="finite_space"/>
      </constant>
      <constant expression="make_elementary_space(es_logicals)" name="the_logicals">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'" name="schema_prefix">
         <builtintype type="STRING"/>
      </constant>
      <constant expression="make_extended_tuple_space(&#10;    the_zero_tuple_space, the_reals)" name="the_real_tuples">
         <typename name="extended_tuple_space"/>
      </constant>
      <constant expression="make_real_interval_from_min(0.0, closed)" name="the_nonnegative_reals">
         <typename name="real_interval_from_min"/>
      </constant>
      <constant expression="make_finite_real_interval(&#10;    -1.0, closed, 1.0, closed)" name="the_neg1_one_interval">
         <typename name="finite_real_interval"/>
      </constant>
      <constant expression="make_extended_tuple_space(&#10;    the_zero_tuple_space, the_complex_numbers)" name="the_complex_tuples">
         <typename name="extended_tuple_space"/>
      </constant>
      <constant expression="make_elementary_space(es_binarys)" name="the_binarys">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_elementary_space(es_maths_spaces)" name="the_maths_spaces">
         <typename name="elementary_space"/>
      </constant>
      <constant expression="make_finite_real_interval(&#10;    0.0, closed, pi, closed)" name="the_zero_pi_interval">
         <typename name="finite_real_interval"/>
      </constant>
      <constant expression="make_finite_real_interval(&#10;    -0.5*pi, closed, 0.5*pi, closed)" name="the_neghalfpi_halfpi_interval">
         <typename name="finite_real_interval"/>
      </constant>
      <constant expression="make_finite_real_interval(&#10;    -pi, open, pi, closed)" name="the_negpi_pi_interval">
         <typename name="finite_real_interval"/>
      </constant>
      <constant expression="[ 'JPEG', 'PNG', 'TIFF', 'BMP', 'GIF']" name="pre_defined_picture_representation_types">
         <aggregate lower="0" type="SET" upper="?"/>
         <builtintype type="STRING"/>
      </constant>
      <constant expression="representation_item('')||&#10;                                   geometric_representation_item()" name="dummy_gri">
         <typename name="geometric_representation_item"/>
      </constant>
      <constant expression="representation_item('')||&#10;                   topological_representation_item()" name="dummy_tri">
         <typename name="topological_representation_item"/>
      </constant>
      <type name="Riemann_1D_data_name">
         <enumeration items="characteristic_acoustic_minus characteristic_acoustic_plus characteristic_entropy characteristic_vorticity1 characteristic_vorticity2 Riemann_invariant_minus Riemann_invariant_plus"/>
      </type>
      <type name="absorbed_dose_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="acceleration_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="action_items">
         <select selectitems="action_directive certification_item characterized_object classification_item configuration_effectivity document_reference_item identification_item organization person_and_organization product_definition product_definition_formation product_definition_formation_relationship product_definition_relationship requirement_assigned_item"/>
      </type>
      <type name="action_method_items">
         <select selectitems="product product_definition_formation"/>
      </type>
      <type name="action_request_item">
         <select selectitems="product_definition product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition versioned_action_request"/>
      </type>
      <type name="action_type">
         <enumeration items="applied_loads residual_loads"/>
      </type>
      <type name="aggregated_angular_variable">
         <enumeration items="total_applied_moment application_defined_aggregated_angular_scalar_variable"/>
      </type>
      <type name="aggregated_scalar_variable">
         <enumeration items="total_strain_energy mass volume"/>
      </type>
      <type name="aggregated_tensor2_3d_variable">
         <enumeration items="rotational_inertia"/>
      </type>
      <type name="aggregated_vector_3d_variable">
         <enumeration items="total_applied_force centre_of_mass_offset"/>
      </type>
      <type name="ahead_or_behind">
         <enumeration items="ahead exact behind"/>
      </type>
      <type name="amount_of_substance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="analysed_item">
         <select selectitems="fea_model product_definition temporal_spatial_domain"/>
      </type>
      <type name="angle_direction_reference_select">
         <select selectitems="direction curve point_path"/>
      </type>
      <type name="angle_direction_reference_with_a2p3d_select">
         <select selectitems="angle_direction_reference_select axis2_placement_3d"/>
      </type>
      <type name="angle_relator">
         <enumeration items="equal large small"/>
      </type>
      <type name="angular_value">
         <typename name="context_dependent_measure"/>
      </type>
      <type name="anisotropic_symmetric_tensor2_2d">
         <aggregate lower="1" type="ARRAY" upper="3"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="anisotropic_symmetric_tensor2_3d">
         <aggregate lower="1" type="ARRAY" upper="6"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="anisotropic_symmetric_tensor4_2d">
         <aggregate lower="1" type="ARRAY" upper="6"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="anisotropic_symmetric_tensor4_3d">
         <aggregate lower="1" type="ARRAY" upper="21"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="annotation_plane_element">
         <select selectitems="draughting_callout styled_item"/>
      </type>
      <type name="annotation_symbol_occurrence_item">
         <select selectitems="annotation_symbol defined_symbol"/>
      </type>
      <type name="annotation_text_occurrence_item">
         <select selectitems="text_literal annotation_text annotation_text_character composite_text"/>
      </type>
      <type name="application_defined_degree_of_freedom">
         <builtintype type="STRING"/>
      </type>
      <type name="application_defined_element_purpose">
         <builtintype type="STRING"/>
      </type>
      <type name="application_defined_matrix_property_type">
         <builtintype type="STRING"/>
      </type>
      <type name="application_defined_scalar_variable">
         <builtintype type="STRING"/>
      </type>
      <type name="application_defined_tensor2_2d_variable">
         <builtintype type="STRING"/>
      </type>
      <type name="application_defined_tensor2_3d_variable">
         <builtintype type="STRING"/>
      </type>
      <type name="application_defined_vector_2d_variable">
         <builtintype type="STRING"/>
      </type>
      <type name="application_defined_vector_3d_variable">
         <builtintype type="STRING"/>
      </type>
      <type name="approval_item">
         <select selectitems="action action_directive alternate_product_relationship applied_action_assignment applied_usage_right assembly_component_usage_substitute certification configuration_effectivity configuration_item contract control date directed_action document document_file effectivity executed_action fea_model general_property_relationship group group_relationship information_usage_right product product_definition product_definition_formation product_definition_formation_relationship product_definition_relationship representation requirement_assignment result security_classification shape_aspect_relationship temporal_spatial_domain versioned_action_request"/>
      </type>
      <type name="approved_item">
         <select selectitems="certification change change_request configuration_effectivity configuration_item contract product security_classification start_request start_work"/>
      </type>
      <type name="area_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="area_or_view">
         <select selectitems="presentation_area presentation_view"/>
      </type>
      <type name="atom_based_tuple">
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="atom_based_value"/>
      </type>
      <type name="atom_based_value">
         <select selectitems="maths_atom atom_based_tuple"/>
      </type>
      <type name="attribute_classification_item">
         <select selectitems="action_directive action_method action_property action_property_representation action_relationship action_request_solution action_request_status alternate_product_relationship applied_action_assignment applied_action_request_assignment applied_approval_assignment applied_certification_assignment applied_document_reference applied_document_usage_constraint_assignment applied_effectivity_assignment applied_external_identification_assignment applied_identification_assignment applied_organization_assignment applied_organizational_project_assignment applied_person_and_organization_assignment approval approval_person_organization approval_relationship approval_status certification context_dependent_unit contract date_and_time_assignment date_assignment derived_unit descriptive_representation_item document_file document_relationship effectivity event_occurrence_relationship executed_action general_property general_property_relationship group group_relationship information_right information_usage_right language measure_representation_item measure_with_unit named_unit organization_relationship organizational_address organizational_project_relationship person_and_organization person_and_organization_address product product_category product_concept product_concept_context product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition property_definition_relationship property_definition_representation representation representation_context representation_item security_classification time_interval_relationship uncertainty_measure_with_unit usage_association versioned_action_request"/>
      </type>
      <type name="attribute_language_item">
         <select selectitems="alternate_product_relationship application_context applied_certification_assignment applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment applied_identification_assignment applied_organizational_project_assignment applied_security_classification_assignment approval approval_relationship approval_status assembly_component_usage_substitute attribute_value_assignment certification certification_type configuration_design configuration_item contract date_role date_time_role descriptive_representation_item document_relationship document_usage_role effectivity effectivity_relationship event_occurrence external_source general_property general_property_relationship geometric_representation_item geometric_tolerance identification_role information_right information_usage_right make_from_usage_option mapped_item multi_language_attribute_assignment object_role organization_relationship organization_role organizational_project organizational_project_relationship organizational_project_role person_and_organization person_and_organization_role product product_concept product_concept_relationship product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship product_definition_shape product_related_product_category property_definition representation security_classification security_classification_assignment shape_aspect shape_aspect_relationship shape_representation time_interval_role topological_representation_item uncertainty_measure_with_unit uncertainty_qualifier usage_association"/>
      </type>
      <type name="attribute_type">
         <select selectitems="label text"/>
      </type>
      <type name="axi_or_plane">
         <enumeration items="axisymmetric planar"/>
      </type>
      <type name="axis2_placement">
         <select selectitems="axis2_placement_2d axis2_placement_3d"/>
      </type>
      <type name="b_spline_curve_form">
         <enumeration items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified"/>
      </type>
      <type name="b_spline_surface_form">
         <enumeration items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified"/>
      </type>
      <type name="base_solid_select">
         <select selectitems="solid_model csg_primitive boolean_result"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRIMITIVE_2D' IN TYPEOF(SELF))" label="WR1"/>
      </type>
      <type name="blend_end_condition_select">
         <select selectitems="point_on_curve edge_curve vertex"/>
      </type>
      <type name="blend_radius_variation_type">
         <enumeration items="linear_blend cubic_blend unspecified_blend"/>
      </type>
      <type name="boolean_operand">
         <select selectitems="solid_model half_space_solid csg_primitive boolean_result"/>
      </type>
      <type name="boolean_operator">
         <enumeration items="union intersection difference"/>
      </type>
      <type name="boundary_aggregated_variable">
         <select selectitems="aggregated_vector_3d_variable application_defined_vector_3d_variable"/>
      </type>
      <type name="boundary_curve_scalar_variable">
         <enumeration items="normal_force_per_unit_length"/>
      </type>
      <type name="boundary_curve_vector_3d_variable">
         <enumeration items="applied_force_per_unit_length applied_moment_per_unit_length"/>
      </type>
      <type name="boundary_edge_variable">
         <select selectitems="boundary_curve_scalar_variable boundary_curve_vector_3d_variable application_defined_scalar_variable application_defined_vector_3d_variable"/>
      </type>
      <type name="boundary_surface_scalar_variable">
         <enumeration items="pressure"/>
      </type>
      <type name="boundary_surface_vector_3d_variable">
         <enumeration items="applied_force_per_unit_area applied_moment_per_unit_area"/>
      </type>
      <type name="boundary_variable">
         <select selectitems="boundary_surface_scalar_variable boundary_surface_vector_3d_variable application_defined_scalar_variable application_defined_vector_3d_variable"/>
      </type>
      <type name="box_characteristic_select">
         <select selectitems="box_height box_width box_slant_angle box_rotate_angle"/>
      </type>
      <type name="box_height">
         <typename name="positive_ratio_measure"/>
      </type>
      <type name="box_rotate_angle">
         <typename name="plane_angle_measure"/>
      </type>
      <type name="box_slant_angle">
         <typename name="plane_angle_measure"/>
      </type>
      <type name="box_width">
         <typename name="positive_ratio_measure"/>
      </type>
      <type name="camera_model_d3_multi_clipping_interection_select">
         <select selectitems="camera_model_d3_multi_clipping_union plane"/>
      </type>
      <type name="camera_model_d3_multi_clipping_union_select">
         <select selectitems="camera_model_d3_multi_clipping_intersection plane"/>
      </type>
      <type name="capacitance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="category_usage_item">
         <select selectitems="product_class"/>
      </type>
      <type name="cc_classified_item">
         <select selectitems="assembly_component_usage product_definition_formation"/>
      </type>
      <type name="cc_person_organization_item">
         <select selectitems="change change_request configuration_item contract product product_definition product_definition_formation security_classification start_request start_work"/>
      </type>
      <type name="cc_specified_item">
         <select selectitems="product_definition shape_aspect"/>
      </type>
      <type name="cell_shape">
         <select selectitems="cell_shape_0D cell_shape_1D cell_shape_2D cell_shape_3D"/>
      </type>
      <type name="cell_shape_0D">
         <enumeration items="single"/>
      </type>
      <type name="cell_shape_1D">
         <enumeration items="line"/>
      </type>
      <type name="cell_shape_2D">
         <enumeration items="polygon quadrilateral triangle"/>
      </type>
      <type name="cell_shape_3D">
         <enumeration items="hexahedron pyramid tetrahedron wedge"/>
      </type>
      <type name="celsius_temperature_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="central_or_parallel">
         <enumeration items="central parallel"/>
      </type>
      <type name="certification_item">
         <select selectitems="alternate_product_relationship make_from_usage_option product_definition_formation product_definition_formation_relationship"/>
      </type>
      <type name="certified_item">
         <select selectitems="supplied_part_relationship"/>
      </type>
      <type name="change_request_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="character_spacing_select">
         <select selectitems="length_measure ratio_measure measure_with_unit descriptive_measure"/>
      </type>
      <type name="character_style_select">
         <select selectitems="character_glyph_style_stroke character_glyph_style_outline text_style_for_defined_font"/>
      </type>
      <type name="characterized_action_definition">
         <select selectitems="action action_method action_method_relationship action_relationship"/>
      </type>
      <type name="characterized_definition">
         <select selectitems="characterized_object characterized_product_definition shape_definition"/>
      </type>
      <type name="characterized_material_property">
         <select selectitems="material_property_representation product_material_composition_relationship"/>
      </type>
      <type name="characterized_product_composition_value">
         <select selectitems="measure_with_unit"/>
      </type>
      <type name="characterized_product_definition">
         <select selectitems="product_definition product_definition_relationship"/>
      </type>
      <type name="characterized_resource_definition">
         <select selectitems="action_resource action_resource_relationship action_resource_requirement action_resource_requirement_relationship"/>
      </type>
      <type name="choose_general_property_identifier">
         <select selectitems="defined_data_name externally_defined_item"/>
      </type>
      <type name="choose_geometry_location">
         <select selectitems="externally_defined_item shape_representation"/>
      </type>
      <type name="choose_representation_context_identifier">
         <select selectitems="defined_data_class externally_defined_item"/>
      </type>
      <type name="class_usage_effectivity_context_item">
         <select selectitems="product_definition"/>
      </type>
      <type name="classification_item">
         <select selectitems="action action_directive action_method action_property action_relationship action_request_solution action_request_status address alternate_product_relationship applied_action_assignment applied_action_request_assignment applied_approval_assignment applied_certification_assignment applied_contract_assignment applied_date_and_time_assignment applied_date_assignment applied_document_reference applied_document_usage_constraint_assignment applied_effectivity_assignment applied_external_identification_assignment applied_identification_assignment applied_organization_assignment applied_organizational_project_assignment applied_person_and_organization_assignment applied_security_classification_assignment approval approval_person_organization approval_relationship approval_status assembly_component_usage_substitute calendar_date certification characterized_class characterized_object class classified_item configuration_item context_dependent_unit contract conversion_based_unit date_and_time date_and_time_assignment date_assignment derived_unit descriptive_representation_item directed_action document_file document_relationship effectivity event_occurrence executed_action general_property general_property_relationship group identification_assignment information_right information_usage_right language measure_representation_item measure_with_unit multi_language_attribute_assignment named_unit organization organization_relationship organizational_address organizational_project organizational_project_relationship person person_and_organization_address product product_concept product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition property_definition_representation representation representation_context representation_item security_classification state_type state_type_assignment state_type_relationship uncertainty_measure_with_unit usage_association versioned_action_request"/>
      </type>
      <type name="classified_item">
         <select selectitems="product product_definition product_definition_formation"/>
      </type>
      <type name="compound_item_definition">
         <select selectitems="list_representation_item set_representation_item"/>
      </type>
      <type name="conductance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="configuration_design_item">
         <select selectitems="product_definition product_definition_formation"/>
      </type>
      <type name="configured_effectivity_context_item">
         <select selectitems="product_concept_feature_association"/>
      </type>
      <type name="configured_effectivity_item">
         <select selectitems="product_definition"/>
      </type>
      <type name="constructive_geometry_representation_or_shape_represenation">
         <select selectitems="constructive_geometry_representation shape_representation"/>
      </type>
      <type name="context_dependent_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="contract_item">
         <select selectitems="action_directive alternate_product_relationship directed_action executed_action information_usage_right organization person_and_organization product product_definition_formation"/>
      </type>
      <type name="contracted_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="coordinate_data_name">
         <enumeration items="coordinate_eta coordinate_normal coordinate_phi coordinate_r coordinate_tangential coordinate_theta coordinate_transform coordinate_x coordinate_xi coordinate_y coordinate_z coordinate_zeta"/>
      </type>
      <type name="coordinate_system_type">
         <enumeration items="cartesian cylindrical spherical"/>
      </type>
      <type name="count_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="csg_primitive">
         <select selectitems="sphere block right_angular_wedge torus right_circular_cone right_circular_cylinder"/>
      </type>
      <type name="csg_select">
         <select selectitems="boolean_result csg_primitive"/>
      </type>
      <type name="curve_2d_element_descriptor">
         <select selectitems="axisymmetric_curve_2d_element_descriptor plane_curve_2d_element_descriptor"/>
      </type>
      <type name="curve_2d_element_output_reference">
         <select selectitems="curve_2d_element_representation curve_2d_element_descriptor curve_2d_element_group curve_2d_substructure_element_reference analysis_item_within_representation"/>
      </type>
      <type name="curve_2d_element_representation">
         <select selectitems="axisymmetric_curve_2d_element_representation plane_curve_2d_element_representation"/>
      </type>
      <type name="curve_2d_state_coordinate_system">
         <select selectitems="fea_axis2_placement_3d curve_2d_element_coordinate_system"/>
      </type>
      <type name="curve_3d_element_coordinate_system">
         <select selectitems="aligned_curve_3d_element_coordinate_system parametric_curve_3d_element_coordinate_system"/>
      </type>
      <type name="curve_3d_element_length_integration">
         <select selectitems="element_integration_algebraic curve_3d_element_length_integration_rule curve_3d_element_length_integration_explicit"/>
      </type>
      <type name="curve_3d_element_output_reference">
         <select selectitems="curve_3d_element_representation curve_3d_element_descriptor curve_3d_element_group curve_3d_substructure_element_reference analysis_item_within_representation"/>
      </type>
      <type name="curve_3d_state_coordinate_system">
         <select selectitems="fea_axis2_placement_3d curve_3d_element_coordinate_system"/>
      </type>
      <type name="curve_edge">
         <enumeration items="element_edge"/>
      </type>
      <type name="curve_element_end_coordinate_system">
         <select selectitems="fea_axis2_placement_3d curve_3d_element_coordinate_system"/>
      </type>
      <type name="curve_element_freedom">
         <select selectitems="enumerated_curve_element_freedom application_defined_degree_of_freedom"/>
      </type>
      <type name="curve_element_purpose">
         <select selectitems="enumerated_curve_element_purpose application_defined_element_purpose"/>
      </type>
      <type name="curve_element_variable">
         <select selectitems="volume_variable curve_scalar_variable curve_vector_2d_variable application_defined_vector_2d_variable curve_vector_3d_variable"/>
      </type>
      <type name="curve_font_or_scaled_curve_font_select">
         <select selectitems="curve_style_font_select curve_style_font_and_scaling"/>
      </type>
      <type name="curve_matrix_property_type">
         <select selectitems="enumerated_curve_matrix_property_type application_defined_matrix_property_type"/>
      </type>
      <type name="curve_on_surface">
         <select selectitems="pcurve surface_curve composite_curve_on_surface"/>
      </type>
      <type name="curve_or_annotation_curve_occurrence">
         <select selectitems="curve annotation_curve_occurrence"/>
      </type>
      <type name="curve_or_render">
         <select selectitems="curve_style curve_style_rendering"/>
      </type>
      <type name="curve_scalar_variable">
         <enumeration items="curve_axial_force curve_axial_strain torque curve_warping bi_moment twist"/>
      </type>
      <type name="curve_style_font_select">
         <select selectitems="curve_style_font pre_defined_curve_font externally_defined_curve_font"/>
      </type>
      <type name="curve_vector_2d_variable">
         <enumeration items="curve_shear_force curve_bending_moment curve_element_curvature curve_thermal_gradient reference_curve_thermal_gradient"/>
      </type>
      <type name="curve_vector_3d_variable">
         <enumeration items="applied_force_per_unit_length applied_moment_per_unit_length"/>
      </type>
      <type name="cylindrical_harmonic_number">
         <builtintype type="INTEGER"/>
         <where expression="SELF &gt;= 0" label="WR1"/>
      </type>
      <type name="date_and_time_item">
         <select selectitems="action action_directive applied_action_assignment applied_organization_assignment applied_person_and_organization_assignment applied_security_classification_assignment approval_person_organization certification contract directed_action document document_file event_occurrence executed_action information_usage_right organizational_project product_definition product_definition_formation product_definition_relationship rule_action security_classification versioned_action_request"/>
      </type>
      <type name="date_item">
         <select selectitems="action action_directive applied_action_assignment applied_organization_assignment applied_person_and_organization_assignment applied_security_classification_assignment approval_person_organization certification contract directed_action document document_file event_occurrence executed_action information_usage_right organizational_project product_definition product_definition_formation product_definition_relationship security_classification versioned_action_request"/>
      </type>
      <type name="date_time_item">
         <select selectitems="approval_person_organization certification change change_request contract product_definition security_classification start_request start_work"/>
      </type>
      <type name="date_time_or_event_occurrence">
         <select selectitems="date_time_select event_occurrence"/>
      </type>
      <type name="date_time_select">
         <select selectitems="date date_and_time local_time"/>
      </type>
      <type name="day_in_month_number">
         <builtintype type="INTEGER"/>
         <where expression="{1 &lt;= SELF &lt;= 31}" label="WR1"/>
      </type>
      <type name="day_in_week_number">
         <builtintype type="INTEGER"/>
         <where expression="{ 1 &lt;= SELF &lt;= 7 }" label="WR1"/>
      </type>
      <type name="day_in_year_number">
         <builtintype type="INTEGER"/>
         <where expression="{1 &lt;= SELF &lt;= 366}" label="WR1"/>
      </type>
      <type name="defined_data_class">
         <enumeration items="application_defined dimensional dimensionless_constant dimensionless_parameter normalise_by_unknown_dimensional normalised_by_dimensional unspecified"/>
      </type>
      <type name="defined_data_name">
         <select selectitems="coordinate_data_name fd_defined_data_name"/>
      </type>
      <type name="defined_symbol_select">
         <select selectitems="pre_defined_symbol externally_defined_symbol"/>
      </type>
      <type name="degree_of_freedom">
         <select selectitems="enumerated_degree_of_freedom application_defined_degree_of_freedom"/>
      </type>
      <type name="derived_property_select">
         <select selectitems="property_definition action_property resource_property"/>
      </type>
      <type name="description_attribute_select">
         <select selectitems="action_request_solution application_context approval_role configuration_design date_role date_time_role context_dependent_shape_representation effectivity external_source organization_role person_and_organization_role person_and_organization person_role property_definition_representation representation time_role"/>
      </type>
      <type name="descriptive_measure">
         <builtintype type="STRING"/>
      </type>
      <type name="dimension_count">
         <builtintype type="INTEGER"/>
         <where expression="SELF &gt; 0" label="WR1"/>
      </type>
      <type name="dimension_extent_usage">
         <enumeration items="origin target"/>
      </type>
      <type name="dimensional_characteristic">
         <select selectitems="dimensional_location dimensional_size"/>
      </type>
      <type name="direction_count_select">
         <select selectitems="u_direction_count v_direction_count"/>
      </type>
      <type name="directionally_explicit_element_coordinate_system">
         <select selectitems="directionally_explicit_element_coordinate_system_arbitrary directionally_explicit_element_coordinate_system_aligned"/>
      </type>
      <type name="discretised_action_model_select">
         <select selectitems="analysis_step model_action_domain"/>
      </type>
      <type name="discretised_distribution_model_select">
         <select selectitems="model_property_distribution state_definition"/>
      </type>
      <type name="discretised_product_model_select">
         <select selectitems="fea_model model_product_domain"/>
      </type>
      <type name="discretised_state_model_select">
         <select selectitems="model_state_domain state"/>
      </type>
      <type name="document_identifier_assigned_item">
         <select selectitems="document"/>
      </type>
      <type name="document_reference_item">
         <select selectitems="action_method applied_external_identification_assignment assembly_component_usage characterized_class characterized_object configuration_item descriptive_representation_item dimensional_size executed_action externally_defined_dimension_definition externally_defined_item group group_relationship information_right information_usage_right material_designation measure_representation_item product product_category product_definition product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition representation representation_item rule_set shape_aspect shape_aspect_relationship usage_association versioned_action_request"/>
      </type>
      <type name="dose_equivalent_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="draughting_callout_element">
         <select selectitems="annotation_text_occurrence annotation_symbol_occurrence annotation_curve_occurrence"/>
      </type>
      <type name="draughting_model_item_association_select">
         <select selectitems="annotation_occurrence draughting_callout"/>
      </type>
      <type name="draughting_model_item_select">
         <select selectitems="mapped_item styled_item axis2_placement camera_model draughting_callout"/>
      </type>
      <type name="draughting_titled_item">
         <select selectitems="drawing_revision drawing_sheet_revision"/>
      </type>
      <type name="effectivity_item">
         <select selectitems="assembly_component_usage_substitute product product_definition product_definition_formation product_definition_relationship product_definition_substitute"/>
      </type>
      <type name="electric_charge_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="electric_current_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="electric_potential_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="element_2d_shape">
         <enumeration items="quadrilateral triangle"/>
      </type>
      <type name="element_aspect">
         <select selectitems="element_volume volume_3d_face volume_2d_face volume_3d_edge volume_2d_edge surface_3d_face surface_2d_face surface_3d_edge surface_2d_edge curve_edge"/>
      </type>
      <type name="element_integration_algebraic">
         <enumeration items="algebraic"/>
      </type>
      <type name="element_or_element_group">
         <select selectitems="element_representation element_group"/>
      </type>
      <type name="element_order">
         <enumeration items="linear quadratic cubic"/>
      </type>
      <type name="element_volume">
         <enumeration items="volume"/>
      </type>
      <type name="elementary_function_enumerators">
         <enumeration items="ef_and ef_or ef_not ef_xor ef_negate_i ef_add_i ef_subtract_i ef_multiply_i ef_divide_i ef_mod_i ef_exponentiate_i ef_eq_i ef_ne_i ef_gt_i ef_lt_i ef_ge_i ef_le_i ef_abs_i ef_max_i ef_min_i ef_if_i ef_negate_r ef_reciprocal_r ef_add_r ef_subtract_r ef_multiply_r ef_divide_r ef_mod_r ef_exponentiate_r ef_exponentiate_ri ef_eq_r ef_ne_r ef_gt_r ef_lt_r ef_ge_r ef_le_r ef_abs_r ef_max_r ef_min_r ef_acos_r ef_asin_r ef_atan2_r ef_cos_r ef_exp_r ef_ln_r ef_log2_r ef_log10_r ef_sin_r ef_sqrt_r ef_tan_r ef_if_r ef_form_c ef_rpart_c ef_ipart_c ef_negate_c ef_reciprocal_c ef_add_c ef_subtract_c ef_multiply_c ef_divide_c ef_exponentiate_c ef_exponentiate_ci ef_eq_c ef_ne_c ef_conjugate_c ef_abs_c ef_arg_c ef_cos_c ef_exp_c ef_ln_c ef_sin_c ef_sqrt_c ef_tan_c ef_if_c ef_subscript_s ef_eq_s ef_ne_s ef_gt_s ef_lt_s ef_ge_s ef_le_s ef_subsequence_s ef_concat_s ef_size_s ef_format ef_value ef_like ef_if_s ef_subscript_b ef_eq_b ef_ne_b ef_gt_b ef_lt_b ef_ge_b ef_le_b ef_subsequence_b ef_concat_b ef_size_b ef_if_b ef_subscript_t ef_eq_t ef_ne_t ef_concat_t ef_size_t ef_entuple ef_detuple ef_insert ef_remove ef_if_t ef_sum_it ef_product_it ef_add_it ef_subtract_it ef_scalar_mult_it ef_dot_prod_it ef_sum_rt ef_product_rt ef_add_rt ef_subtract_rt ef_scalar_mult_rt ef_dot_prod_rt ef_norm_rt ef_sum_ct ef_product_ct ef_add_ct ef_subtract_ct ef_scalar_mult_ct ef_dot_prod_ct ef_norm_ct ef_if ef_ensemble ef_member_of"/>
      </type>
      <type name="elementary_space_enumerators">
         <enumeration items="es_numbers es_complex_numbers es_reals es_integers es_logicals es_booleans es_strings es_binarys es_maths_spaces es_maths_functions es_generics"/>
      </type>
      <type name="energy_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="enumerated_curve_element_freedom">
         <enumeration items="x_translation y_translation z_translation x_rotation y_rotation z_rotation warp none"/>
      </type>
      <type name="enumerated_curve_element_purpose">
         <enumeration items="axial y_y_bending z_z_bending torsion x_y_shear x_z_shear warping"/>
      </type>
      <type name="enumerated_curve_matrix_property_type">
         <enumeration items="axial y_y_bending z_z_bending torsion x_y_shear x_z_shear warping axial_mass y_y_bending_mass z_z_bending_mass torsion_mass x_y_shear_mass x_z_shear_mass warping_mass mass"/>
      </type>
      <type name="enumerated_degree_of_freedom">
         <enumeration items="x_translation y_translation z_translation x_rotation y_rotation z_rotation warp"/>
      </type>
      <type name="enumerated_matrix_property_type">
         <enumeration items="stiffness mass damping"/>
      </type>
      <type name="enumerated_plane_2d_element_purpose">
         <enumeration items="plane_stress plane_strain"/>
      </type>
      <type name="enumerated_surface_element_purpose">
         <enumeration items="membrane_direct membrane_shear bending_direct bending_torsion normal_to_plane_shear"/>
      </type>
      <type name="enumerated_surface_matrix_property_type">
         <enumeration items="membrane_direct membrane_shear bending_direct bending_torsion normal_to_plane_shear membrane_direct_mass membrane_shear_mass bending_direct_mass bending_torsion_mass normal_to_plane_shear_mass mass"/>
      </type>
      <type name="enumerated_volume_element_purpose">
         <enumeration items="stress_displacement"/>
      </type>
      <type name="event_occurrence_item">
         <select selectitems="organizational_project"/>
      </type>
      <type name="extension_options">
         <enumeration items="eo_none eo_cont eo_cont_right eo_cont_left"/>
      </type>
      <type name="external_identification_item">
         <select selectitems="action_relationship action_request_status applied_organization_assignment applied_person_and_organization_assignment approval approval_status date_and_time_assignment date_assignment document_file external_source externally_defined_class externally_defined_context_dependent_unit externally_defined_conversion_based_unit externally_defined_general_property externally_defined_picture_representation_item externally_defined_representation_item organizational_address product_definition security_classification trimmed_curve versioned_action_request"/>
      </type>
      <type name="fd_behaviour_models">
         <select selectitems="gas_model turbulence_closure turbulence_model viscosity_model"/>
      </type>
      <type name="fd_defined_data_name">
         <select selectitems="fd_nondimensional_parameter_name flow_solution_data_name force_moment_data_name gas_model_data_name Riemann_1D_data_name thermal_conductivity_model_data_name turbulence_closure_data_name turbulence_model_data_name viscosity_model_data_name"/>
      </type>
      <type name="fd_nondimensional_parameter_name">
         <enumeration items="coef_pressure coef_pressure_dynamic coef_pressure_reference coef_skin_friction_x coef_skin_friction_y coef_skin_friction_z length_reference Mach Mach_velocity Mach_velocity_sound Prandtl Prandtl_specific_heat_pressure Prandtl_thermal_conductivity Prandtl_viscosity_molecular Reynolds Reynolds_length Reynolds_velocity Reynolds_viscosity_kinematic specific_heat_ratio specific_heat_ratio_pressure specific_heat_ratio_volume"/>
      </type>
      <type name="fea_column_normalised_monoclinic_symmetric_tensor4_3d">
         <aggregate lower="1" type="ARRAY" upper="13"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="fea_column_normalised_orthotropic_symmetric_tensor4_3d">
         <aggregate lower="1" type="ARRAY" upper="9"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="fea_iso_orthotropic_symmetric_tensor4_3d">
         <aggregate lower="1" type="ARRAY" upper="3"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="fea_isotropic_symmetric_tensor4_3d">
         <aggregate lower="1" type="ARRAY" upper="2"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="fea_transverse_isotropic_symmetric_tensor4_3d">
         <aggregate lower="1" type="ARRAY" upper="5"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="field_value">
         <select selectitems="unspecified_value scalar tensor1_2d tensor1_3d anisotropic_symmetric_tensor2_2d isotropic_symmetric_tensor2_3d orthotropic_symmetric_tensor2_3d anisotropic_symmetric_tensor2_3d"/>
      </type>
      <type name="fill_area_style_tile_shape_select">
         <select selectitems="fill_area_style_tile_curve_with_style fill_area_style_tile_coloured_region fill_area_style_tile_symbol_with_style pre_defined_tile externally_defined_tile"/>
      </type>
      <type name="fill_style_select">
         <select selectitems="fill_area_style_colour externally_defined_tile_style fill_area_style_tiles externally_defined_hatch_style fill_area_style_hatching"/>
      </type>
      <type name="flow_solution_data_name">
         <enumeration items="density density_stagnation energy_internal energy_kinetic energy_stagnation energy_stagnation_density enthalpy enthalpy_stagnation entropy entropy_approx ideal_gas_constant mass_flow momentum_magnitude momentum_x momentum_y momentum_z potential pressure pressure_dynamic pressure_stagnation Reynolds_stress_xx Reynolds_stress_xy Reynolds_stress_xz Reynolds_stress_yy Reynolds_stress_yz Reynolds_stress_zz skin_friction_magnitude skin_friction_x skin_friction_y skin_friction_z specific_heat_pressure specific_heat_volume stream_function temperature temperature_stagnation thermal_conductivity velocity_angle_x velocity_angle_y velocity_angle_z velocity_magnitude velocity_normal velocity_phi velocity_r velocity_sound velocity_sound_stagnation velocity_tangential velocity_theta velocity_unit_vector_x velocity_unit_vector_y velocity_unit_vector_z velocity_x velocity_y velocity_z viscosity_eddy viscosity_kinematic viscosity_molecular vorticity_magnitude vorticity_x vorticity_y vorticity_z"/>
      </type>
      <type name="font_select">
         <select selectitems="pre_defined_text_font externally_defined_text_font text_font"/>
      </type>
      <type name="force_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="force_moment_data_name">
         <enumeration items="coef_drag coef_length coef_lift coef_moment_area coef_moment_eta coef_moment_phi coef_moment_pressure_dynamic coef_moment_r coef_moment_theta coef_moment_x coef_moment_xi coef_moment_y coef_moment_z coef_moment_zeta drag force_phi force_r force_theta force_x force_y force_z lift moment_center_x moment_center_y moment_center_z moment_eta moment_phi moment_r moment_theta moment_x moment_xi moment_y moment_z moment_zeta"/>
      </type>
      <type name="founded_item_select">
         <select selectitems="founded_item representation_item"/>
      </type>
      <type name="frequency_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="gas_model_data_name">
         <enumeration items="ideal_gas_constant specific_heat_pressure specific_heat_ratio specific_heat_volume"/>
      </type>
      <type name="gas_model_type">
         <enumeration items="application_defined ideal unspecified Van_der_Waals"/>
      </type>
      <type name="generalized_surface_select">
         <select selectitems="surface face_surface surfaced_open_shell"/>
      </type>
      <type name="geometric_item_specific_usage_select">
         <select selectitems="shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="geometric_set_select">
         <select selectitems="point curve surface"/>
      </type>
      <type name="groupable_item">
         <select selectitems="geometric_representation_item group_relationship mapped_item package_product_concept_feature product_concept_feature product_definition product_definition_formation property_definition_representation representation representation_item representation_relationship_with_transformation shape_aspect shape_aspect_relationship shape_representation_relationship styled_item topological_representation_item"/>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GROUP' IN TYPEOF(SELF))" label="WR1"/>
      </type>
      <type name="hour_in_day">
         <builtintype type="INTEGER"/>
         <where expression="{ 0 &lt;= SELF &lt; 24 }" label="WR1"/>
      </type>
      <type name="id_attribute_select">
         <select selectitems="action address product_category property_definition shape_aspect shape_aspect_relationship application_context group organizational_project representation"/>
      </type>
      <type name="idealised_action_select">
         <select selectitems="action physical_action_domain"/>
      </type>
      <type name="idealised_distribution_select">
         <select selectitems="domain_property property_definition"/>
      </type>
      <type name="idealised_product_select">
         <select selectitems="physical_product_domain product_definition"/>
      </type>
      <type name="idealised_state_select">
         <select selectitems="physical_state_domain state_type"/>
      </type>
      <type name="identification_item">
         <select selectitems="approval_status characterized_class class configuration_item contract dimensional_size document_file general_property group group_relationship information_right information_usage_right material_designation organization person_and_organization product product_category product_class product_concept product_concept_feature product_definition product_definition_formation product_identification representation rule_set security_classification security_classification_level shape_aspect_relationship shape_representation state_type state_type_relationship usage_association"/>
      </type>
      <type name="identifier">
         <builtintype type="STRING"/>
      </type>
      <type name="ijk_minmax">
         <enumeration items="i_min j_min k_min i_max j_max k_max"/>
      </type>
      <type name="illuminance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="indices_group">
         <select selectitems="indices_list indices_range"/>
      </type>
      <type name="inductance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="input_selector">
         <typename name="positive_integer"/>
      </type>
      <type name="instance_usage_context_select">
         <select selectitems="product_definition_relationship product_definition_usage"/>
      </type>
      <type name="integration_rule">
         <enumeration items="gaussian simpson"/>
      </type>
      <type name="invisibility_context">
         <select selectitems="draughting_model presentation_representation presentation_set"/>
      </type>
      <type name="invisible_item">
         <select selectitems="draughting_callout presentation_layer_assignment representation styled_item"/>
      </type>
      <type name="ir_usage_item">
         <typename name="action_items"/>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONFIGURATION_EFFECTIVITY' IN TYPEOF(SELF))" label="wr1"/>
      </type>
      <type name="isotropic_symmetric_tensor2_3d">
         <typename name="context_dependent_measure"/>
      </type>
      <type name="knot_type">
         <enumeration items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified"/>
      </type>
      <type name="label">
         <builtintype type="STRING"/>
      </type>
      <type name="layered_item">
         <select selectitems="presentation_representation representation_item"/>
      </type>
      <type name="length_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="limit_condition">
         <enumeration items="maximum_material_condition least_material_condition regardless_of_feature_size"/>
      </type>
      <type name="list_of_reversible_topology_item">
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="list_representation_item">
         <aggregate lower="1" type="LIST" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="lower_upper">
         <enumeration items="lower upper"/>
      </type>
      <type name="luminous_flux_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="luminous_intensity_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="magnetic_flux_density_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="magnetic_flux_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="marker_select">
         <select selectitems="marker_type pre_defined_marker"/>
      </type>
      <type name="marker_type">
         <enumeration items="dot x plus asterisk ring square triangle"/>
      </type>
      <type name="mass_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="maths_atom">
         <select selectitems="maths_simple_atom maths_enum_atom"/>
      </type>
      <type name="maths_binary">
         <builtintype type="BINARY"/>
      </type>
      <type name="maths_boolean">
         <builtintype type="BOOLEAN"/>
      </type>
      <type name="maths_enum_atom">
         <select selectitems="elementary_space_enumerators ordering_type lower_upper symmetry_type elementary_function_enumerators open_closed space_constraint_type repackage_options extension_options"/>
      </type>
      <type name="maths_expression">
         <select selectitems="atom_based_value maths_tuple generic_expression"/>
      </type>
      <type name="maths_function_select">
         <select selectitems="maths_function elementary_function_enumerators"/>
      </type>
      <type name="maths_integer">
         <builtintype type="INTEGER"/>
      </type>
      <type name="maths_logical">
         <builtintype type="LOGICAL"/>
      </type>
      <type name="maths_number">
         <builtintype type="NUMBER"/>
      </type>
      <type name="maths_real">
         <builtintype type="REAL"/>
      </type>
      <type name="maths_simple_atom">
         <select selectitems="maths_number maths_real maths_integer maths_logical maths_boolean maths_string maths_binary"/>
      </type>
      <type name="maths_space_or_function">
         <select selectitems="maths_space maths_function"/>
      </type>
      <type name="maths_string">
         <builtintype type="STRING"/>
      </type>
      <type name="maths_tuple">
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="maths_value"/>
      </type>
      <type name="maths_value">
         <select selectitems="atom_based_value maths_tuple generic_expression"/>
         <where expression="NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR&#10;             expression_is_constant(SELF)" label="constancy"/>
      </type>
      <type name="matrix_property_type">
         <select selectitems="enumerated_matrix_property_type application_defined_matrix_property_type"/>
      </type>
      <type name="matrix_symmetry">
         <enumeration items="symmetric diagonal"/>
      </type>
      <type name="mbna_bc_type">
         <select selectitems="mbna_bc_type_compound mbna_bc_type_simple"/>
      </type>
      <type name="mbna_bc_type_compound">
         <enumeration items="application_defined bc_farfield bc_inflow bc_outflow unspecified"/>
      </type>
      <type name="mbna_bc_type_simple">
         <enumeration items="application_defined bc_axissymmetric_wedge bc_degenerate_line bc_degenerate_point bc_Dirichlet bc_extrapolate bc_general bc_inflow_subsonic bc_inflow_supersonic bc_Neumann bc_outflow_subsonic bc_outflow_supersonic bc_symmetry_plane bc_symmetry_polar bc_tunnel_inflow bc_tunnel_outflow bc_wall bc_wall_inviscid bc_wall_viscous bc_wall_viscous_heat_flux bc_wall_viscous_isothermal unspecified"/>
      </type>
      <type name="mbna_behaviour_models">
         <select selectitems="thermal_conductivity_model"/>
      </type>
      <type name="mbna_governing_equation_type">
         <enumeration items="application_defined Euler full_potential NS_laminar NS_laminar_incompressible NS_turbulent NS_turbulent_incompressible unspecified"/>
      </type>
      <type name="measure_or_unspecified_value">
         <select selectitems="context_dependent_measure unspecified_value"/>
      </type>
      <type name="measure_value">
         <select selectitems="absorbed_dose_measure dose_equivalent_measure radioactivity_measure acceleration_measure amount_of_substance_measure area_measure celsius_temperature_measure context_dependent_measure count_measure descriptive_measure capacitance_measure electric_charge_measure conductance_measure electric_current_measure electric_potential_measure energy_measure magnetic_flux_density_measure force_measure frequency_measure illuminance_measure inductance_measure length_measure luminous_flux_measure luminous_intensity_measure magnetic_flux_measure mass_measure numeric_measure non_negative_length_measure parameter_value plane_angle_measure positive_length_measure positive_plane_angle_measure positive_ratio_measure power_measure pressure_measure ratio_measure resistance_measure solid_angle_measure thermodynamic_temperature_measure time_measure velocity_measure volume_measure"/>
      </type>
      <type name="mechanical_design_and_draughting_relationship_select">
         <select selectitems="draughting_model mechanical_design_geometric_presentation_representation mechanical_design_presentation_representation_with_draughting mechanical_design_shaded_presentation_representation shape_representation"/>
      </type>
      <type name="mechanical_design_geometric_presentation_area_items">
         <select selectitems="axis2_placement mapped_item"/>
      </type>
      <type name="mechanical_design_geometric_presentation_representation_items">
         <select selectitems="axis2_placement camera_model_d3 mapped_item styled_item"/>
      </type>
      <type name="mesh_location">
         <enumeration items="application_defined cell_centre edge_centre face_centre iface_centre jface_centre kface_centre unspecified vertices"/>
      </type>
      <type name="message">
         <builtintype type="STRING"/>
      </type>
      <type name="message_level">
         <enumeration items="error warning note"/>
      </type>
      <type name="minute_in_hour">
         <builtintype type="INTEGER"/>
         <where expression="{ 0 &lt;= SELF &lt;= 59 }" label="WR1"/>
      </type>
      <type name="mismatched_region_type">
         <enumeration items="abutting overset"/>
      </type>
      <type name="model_or_control_element">
         <select selectitems="element_representation constraint_element"/>
      </type>
      <type name="month_in_year_number">
         <builtintype type="INTEGER"/>
         <where expression="{ 1 &lt;= SELF &lt;= 12 }" label="WR1"/>
      </type>
      <type name="multi_language_attribute_item">
         <select selectitems="alternate_product_relationship application_context applied_certification_assignment applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment applied_identification_assignment applied_organizational_project_assignment approval approval_relationship approval_status assembly_component_usage_substitute attribute_value_assignment certification certification_type colour configuration_design configuration_item contract date_role date_time_role descriptive_representation_item document_relationship document_usage_role effectivity effectivity_relationship event_occurrence external_source general_property general_property_relationship geometric_representation_item geometric_tolerance identification_role information_right information_usage_right make_from_usage_option mapped_item object_role organization_relationship organization_role organizational_project organizational_project_relationship organizational_project_role person_and_organization person_and_organization_role product product_concept product_concept_relationship product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship product_definition_shape product_related_product_category property_definition representation representation_relationship security_classification security_classification_assignment shape_aspect shape_aspect_relationship shape_representation time_interval_role topological_representation_item uncertainty_measure_with_unit usage_association"/>
      </type>
      <type name="name_attribute_select">
         <select selectitems="action_request_solution address configuration_design context_dependent_shape_representation derived_unit effectivity person_and_organization product_definition product_definition_substitute property_definition_representation"/>
      </type>
      <type name="name_item">
         <select selectitems="assembly_component_usage external_class_library group group_relationship product product_definition"/>
      </type>
      <type name="node_or_node_group">
         <select selectitems="node_representation node_group"/>
      </type>
      <type name="node_output_reference">
         <select selectitems="node_representation node_group substructure_node_reference analysis_item_within_representation"/>
      </type>
      <type name="non_negative_length_measure">
         <typename name="length_measure"/>
         <where expression="SELF &gt;= 0.0" label="WR1"/>
      </type>
      <type name="nonnegative_integer">
         <builtintype type="INTEGER"/>
         <where expression="SELF &gt;= 0" label="nonnegativity"/>
      </type>
      <type name="null_style">
         <enumeration items="null"/>
      </type>
      <type name="numeric_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="one_or_two">
         <typename name="positive_integer"/>
         <where expression="(SELF = 1) OR (SELF = 2)" label="in_range"/>
      </type>
      <type name="open_closed">
         <enumeration items="open closed"/>
      </type>
      <type name="ordering_type">
         <enumeration items="by_rows by_columns"/>
      </type>
      <type name="organization_item">
         <select selectitems="action action_directive alternate_product_relationship applied_action_assignment applied_classification_assignment applied_identification_assignment applied_security_classification_assignment approval assembly_component_usage_substitute certification class configuration_item contract document_file executed_action general_property information_usage_right organizational_project product product_definition product_definition_formation product_definition_formation_relationship property_definition rule_action security_classification shape_representation versioned_action_request"/>
      </type>
      <type name="orientation_basis_select">
         <select selectitems="axis2_placement_3d min_and_major_ply_orientation_basis"/>
      </type>
      <type name="orthotropic_symmetric_tensor2_3d">
         <aggregate lower="1" type="ARRAY" upper="3"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="parameter_value">
         <builtintype type="REAL"/>
      </type>
      <type name="pcurve_or_surface">
         <select selectitems="pcurve surface"/>
      </type>
      <type name="person_and_organization_item">
         <select selectitems="action action_directive alternate_product_relationship applied_action_assignment applied_classification_assignment applied_identification_assignment applied_security_classification_assignment approval assembly_component_usage_substitute certification configuration_item contract document_file executed_action general_property information_usage_right organizational_project person_and_organization product product_definition product_definition_formation product_definition_formation_relationship property_definition rule_action security_classification shape_representation versioned_action_request"/>
      </type>
      <type name="person_organization_select">
         <select selectitems="person organization person_and_organization"/>
      </type>
      <type name="picture_representation_item_select">
         <select selectitems="styled_item planar_box axis2_placement_2d"/>
      </type>
      <type name="plane_2d_element_purpose">
         <select selectitems="enumerated_plane_2d_element_purpose application_defined_element_purpose"/>
      </type>
      <type name="plane_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="plane_or_planar_box">
         <select selectitems="plane planar_box"/>
      </type>
      <type name="point_and_vector_member">
         <select selectitems="point direction"/>
      </type>
      <type name="point_and_vector_members">
         <aggregate lower="2" type="LIST" upper="3"/>
         <typename name="point_and_vector_member"/>
      </type>
      <type name="point_path_members">
         <aggregate lower="1" type="LIST" upper="?"/>
         <typename name="point_and_vector"/>
      </type>
      <type name="positive_integer">
         <typename name="nonnegative_integer"/>
         <where expression="SELF &gt; 0" label="positivity"/>
      </type>
      <type name="positive_length_measure">
         <typename name="non_negative_length_measure"/>
         <where expression="SELF &gt; 0.0" label="WR1"/>
      </type>
      <type name="positive_plane_angle_measure">
         <typename name="plane_angle_measure"/>
         <where expression="SELF &gt; 0.0" label="WR1"/>
      </type>
      <type name="positive_ratio_measure">
         <typename name="ratio_measure"/>
         <where expression="SELF &gt; 0.0" label="WR1"/>
      </type>
      <type name="power_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="preferred_surface_curve_representation">
         <enumeration items="curve_3d pcurve_s1 pcurve_s2"/>
      </type>
      <type name="presentable_text">
         <builtintype type="STRING"/>
         <where expression="control_characters_free(SELF)" label="WR1"/>
      </type>
      <type name="presentation_representation_select">
         <select selectitems="presentation_representation presentation_set"/>
      </type>
      <type name="presentation_size_assignment_select">
         <select selectitems="presentation_view presentation_area area_in_set"/>
      </type>
      <type name="presentation_style_select">
         <select selectitems="point_style curve_style surface_style_usage symbol_style fill_area_style text_style null_style"/>
      </type>
      <type name="presented_item_select">
         <select selectitems="action action_method action_relationship product_concept product_concept_feature product_concept_feature_category product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="pressure_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="product_definition_or_assembly_relationship">
         <select selectitems="assembly_component_usage product_definition"/>
      </type>
      <type name="product_definition_or_breakdown_element_usage">
         <select selectitems="product_definition product_definition_usage"/>
      </type>
      <type name="product_definition_or_product_definition_relationship">
         <select selectitems="product_definition product_definition_usage"/>
      </type>
      <type name="product_or_formation_or_definition">
         <select selectitems="product product_definition_formation product_definition"/>
      </type>
      <type name="product_space">
         <select selectitems="uniform_product_space listed_product_space"/>
      </type>
      <type name="project_item">
         <select selectitems="executed_action product_concept"/>
      </type>
      <type name="property_distribution_select">
         <select selectitems="action_property general_property_relationship model_property_distribution property_definition resource_property"/>
      </type>
      <type name="radioactivity_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="ratio_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="real_interval">
         <select selectitems="real_interval_from_min real_interval_to_max finite_real_interval elementary_space"/>
         <where expression="NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR&#10;    (SELF\elementary_space.space_id = es_reals)" label="WR1"/>
      </type>
      <type name="rendering_properties_select">
         <select selectitems="surface_style_reflectance_ambient surface_style_transparent"/>
      </type>
      <type name="repackage_options">
         <enumeration items="ro_nochange ro_wrap_as_tuple ro_unwrap_tuple"/>
      </type>
      <type name="represented_definition">
         <select selectitems="general_property property_definition property_definition_relationship shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="requirement_assigned_item">
         <select selectitems="configuration_item descriptive_representation_item product product_class product_definition product_definition_formation product_definition_relationship representation shape_aspect"/>
      </type>
      <type name="requirement_satisfaction_item">
         <select selectitems="requirement_assigned_item"/>
      </type>
      <type name="requirement_source_item">
         <select selectitems="characterized_object group group_relationship product product_definition product_definition_formation product_definition_relationship shape_aspect"/>
      </type>
      <type name="resistance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="reversible_topology">
         <select selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item"/>
      </type>
      <type name="reversible_topology_item">
         <select selectitems="edge path face face_bound closed_shell open_shell"/>
      </type>
      <type name="role_select">
         <select selectitems="action_assignment action_request_assignment approval_assignment approval_date_time certification_assignment contract_assignment document_reference effectivity_assignment group_assignment name_assignment security_classification_assignment"/>
      </type>
      <type name="rule_superseded_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="scalar">
         <typename name="context_dependent_measure"/>
      </type>
      <type name="second_in_minute">
         <builtintype type="REAL"/>
         <where expression="{ 0 &lt;= SELF &lt;= 60.0 }" label="WR1"/>
      </type>
      <type name="security_classification_item">
         <select selectitems="assembly_component_usage document document_file make_from_usage_option product product_definition product_definition_formation product_definition_usage"/>
      </type>
      <type name="set_of_reversible_topology_item">
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="set_representation_item">
         <aggregate lower="1" type="SET" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="shading_curve_method">
         <enumeration items="constant_colour linear_colour"/>
      </type>
      <type name="shading_surface_method">
         <enumeration items="constant_shading colour_shading dot_shading normal_shading"/>
      </type>
      <type name="shape_definition">
         <select selectitems="product_definition_shape shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="shape_function">
         <enumeration items="lagrangian_function serendipity_function hermitian_function unspecified_function"/>
      </type>
      <type name="shell">
         <select selectitems="vertex_shell wire_shell open_shell closed_shell"/>
      </type>
      <type name="si_prefix">
         <enumeration items="exa peta tera giga mega kilo hecto deca deci centi milli micro nano pico femto atto"/>
      </type>
      <type name="si_unit_name">
         <enumeration items="metre gram second ampere kelvin mole candela radian steradian hertz newton pascal joule watt coulomb volt farad ohm siemens weber tesla henry degree_Celsius lumen lux becquerel gray sievert"/>
      </type>
      <type name="size_select">
         <select selectitems="positive_length_measure measure_with_unit descriptive_measure"/>
      </type>
      <type name="sketch_basis_select">
         <select selectitems="curve_bounded_surface face_surface"/>
      </type>
      <type name="solid_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="source">
         <enumeration items="made bought not_known"/>
      </type>
      <type name="source_item">
         <select selectitems="identifier message"/>
      </type>
      <type name="space_constraint_type">
         <enumeration items="sc_equal sc_subspace sc_member"/>
      </type>
      <type name="space_context_select">
         <select selectitems="action action_method general_property product_definition representation_item shape_aspect"/>
      </type>
      <type name="start_request_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="string_representation_item_select">
         <select selectitems="descriptive_representation_item included_text_block structured_text_composition"/>
      </type>
      <type name="structured_mesh_type">
         <enumeration items="pentahedral pyramidal rectangular tetrahedral"/>
      </type>
      <type name="style_context_select">
         <select selectitems="group presentation_layer_assignment presentation_set representation representation_item representation_relationship"/>
      </type>
      <type name="supported_item">
         <select selectitems="action_directive action action_method"/>
      </type>
      <type name="surface_2d_edge">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 2)" label="WR1"/>
      </type>
      <type name="surface_2d_element_coordinate_system">
         <select selectitems="aligned_surface_2d_element_coordinate_system parametric_surface_2d_element_coordinate_system"/>
      </type>
      <type name="surface_2d_element_descriptor">
         <select selectitems="axisymmetric_surface_2d_element_descriptor plane_surface_2d_element_descriptor"/>
      </type>
      <type name="surface_2d_element_length_integration">
         <select selectitems="element_integration_algebraic surface_2d_element_length_integration_rule surface_2d_element_length_integration_explicit"/>
      </type>
      <type name="surface_2d_element_output_reference">
         <select selectitems="surface_2d_element_representation surface_2d_element_descriptor surface_2d_element_group surface_2d_substructure_element_reference analysis_item_within_representation"/>
      </type>
      <type name="surface_2d_element_representation">
         <select selectitems="axisymmetric_surface_2d_element_representation plane_surface_2d_element_representation"/>
      </type>
      <type name="surface_2d_face">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 2)" label="WR1"/>
      </type>
      <type name="surface_2d_state_coordinate_system">
         <select selectitems="fea_axis2_placement_3d surface_2d_element_coordinate_system"/>
      </type>
      <type name="surface_3d_edge">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 4)" label="WR1"/>
      </type>
      <type name="surface_3d_element_coordinate_system">
         <select selectitems="aligned_surface_3d_element_coordinate_system parametric_surface_3d_element_coordinate_system constant_surface_3d_element_coordinate_system"/>
      </type>
      <type name="surface_3d_element_field_integration">
         <select selectitems="element_integration_algebraic surface_3d_element_field_integration_rule surface_3d_element_field_integration_explicit"/>
      </type>
      <type name="surface_3d_element_output_reference">
         <select selectitems="surface_3d_element_representation surface_3d_element_descriptor surface_3d_element_group surface_3d_substructure_element_reference analysis_item_within_representation"/>
      </type>
      <type name="surface_3d_face">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 2)" label="WR1"/>
      </type>
      <type name="surface_3d_state_coordinate_system">
         <select selectitems="fea_axis2_placement_3d surface_3d_element_coordinate_system"/>
      </type>
      <type name="surface_element_purpose">
         <select selectitems="enumerated_surface_element_purpose application_defined_element_purpose"/>
      </type>
      <type name="surface_element_variable">
         <select selectitems="volume_variable surface_scalar_variable surface_vector_2d_variable surface_vector_3d_variable surface_tensor2_2d_variable application_defined_tensor2_2d_variable"/>
      </type>
      <type name="surface_matrix_property_type">
         <select selectitems="enumerated_surface_matrix_property_type application_defined_matrix_property_type"/>
      </type>
      <type name="surface_scalar_variable">
         <enumeration items="thickness surface_thermal_gradient reference_surface_thermal_gradient"/>
      </type>
      <type name="surface_section_integration">
         <select selectitems="element_integration_algebraic surface_section_integration_rule surface_section_integration_explicit"/>
      </type>
      <type name="surface_side">
         <enumeration items="positive negative both"/>
      </type>
      <type name="surface_side_style_select">
         <select selectitems="surface_side_style pre_defined_surface_side_style"/>
      </type>
      <type name="surface_style_element_select">
         <select selectitems="surface_style_fill_area surface_style_boundary surface_style_silhouette surface_style_segmentation_curve surface_style_control_grid surface_style_parameter_line surface_style_rendering"/>
      </type>
      <type name="surface_tensor2_2d_variable">
         <enumeration items="surface_membrane_force surface_membrane_strain surface_bending_moment surface_curvature"/>
      </type>
      <type name="surface_vector_2d_variable">
         <enumeration items="surface_out_of_plane_shear_force surface_out_of_plane_shear_strain"/>
      </type>
      <type name="surface_vector_3d_variable">
         <enumeration items="applied_force_per_unit_area applied_moment_per_unit_area"/>
      </type>
      <type name="symbol_style_select">
         <select selectitems="symbol_colour"/>
      </type>
      <type name="symmetric_tensor2_2d">
         <select selectitems="anisotropic_symmetric_tensor2_2d"/>
      </type>
      <type name="symmetric_tensor2_3d">
         <select selectitems="isotropic_symmetric_tensor2_3d orthotropic_symmetric_tensor2_3d anisotropic_symmetric_tensor2_3d"/>
      </type>
      <type name="symmetric_tensor4_2d">
         <select selectitems="anisotropic_symmetric_tensor4_2d"/>
      </type>
      <type name="symmetric_tensor4_3d">
         <select selectitems="anisotropic_symmetric_tensor4_3d fea_isotropic_symmetric_tensor4_3d fea_iso_orthotropic_symmetric_tensor4_3d fea_transverse_isotropic_symmetric_tensor4_3d fea_column_normalised_orthotropic_symmetric_tensor4_3d fea_column_normalised_monoclinic_symmetric_tensor4_3d"/>
      </type>
      <type name="symmetry_type">
         <enumeration items="identity skew hermitian skew_hermitian"/>
      </type>
      <type name="tensor1_2d">
         <aggregate lower="1" type="ARRAY" upper="2"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="tensor1_3d">
         <aggregate lower="1" type="ARRAY" upper="3"/>
         <typename name="context_dependent_measure"/>
      </type>
      <type name="tensor_type">
         <select selectitems="scalar angular_value tensor1_2d tensor1_3d anisotropic_symmetric_tensor2_2d isotropic_symmetric_tensor2_3d orthotropic_symmetric_tensor2_3d anisotropic_symmetric_tensor2_3d anisotropic_symmetric_tensor4_2d anisotropic_symmetric_tensor4_3d fea_isotropic_symmetric_tensor4_3d fea_iso_orthotropic_symmetric_tensor4_3d fea_transverse_isotropic_symmetric_tensor4_3d fea_column_normalised_orthotropic_symmetric_tensor4_3d fea_column_normalised_monoclinic_symmetric_tensor4_3d"/>
      </type>
      <type name="text">
         <builtintype type="STRING"/>
      </type>
      <type name="text_alignment">
         <typename name="label"/>
      </type>
      <type name="text_delineation">
         <typename name="label"/>
      </type>
      <type name="text_or_character">
         <select selectitems="annotation_text annotation_text_character composite_text text_literal"/>
      </type>
      <type name="text_path">
         <enumeration items="left right up down"/>
      </type>
      <type name="text_string_representation_item">
         <select selectitems="text_literal annotation_text annotation_text_character composite_text axis2_placement"/>
      </type>
      <type name="thermal_conductivity_model_data_name">
         <enumeration items="constant_Prandtl power_law_exponent Sutherland_constant_conductivity temperature_reference thermal_conductivity_reference"/>
      </type>
      <type name="thermal_conductivity_model_type">
         <enumeration items="application_defined constant_Prandtl independent power_law Sutherland_law unspecified"/>
      </type>
      <type name="thermodynamic_temperature_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="time_interval_item">
         <select selectitems="action time_interval_based_effectivity"/>
      </type>
      <type name="time_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="tolerance_method_definition">
         <select selectitems="tolerance_value limits_and_fits"/>
      </type>
      <type name="transformation">
         <select selectitems="item_defined_transformation functionally_defined_transformation"/>
      </type>
      <type name="transition_code">
         <enumeration items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature"/>
      </type>
      <type name="trim_condition_select">
         <select selectitems="length_measure plane_angle_measure generalized_surface_select solid_model"/>
      </type>
      <type name="trim_intent">
         <enumeration items="blind offset through_all unspecified up_to_next"/>
      </type>
      <type name="trimming_preference">
         <enumeration items="cartesian parameter unspecified"/>
      </type>
      <type name="trimming_select">
         <select selectitems="cartesian_point parameter_value"/>
      </type>
      <type name="tuple_space">
         <select selectitems="product_space extended_tuple_space"/>
      </type>
      <type name="turbulence_closure_data_name">
         <enumeration items="eddy_viscosity Prandtl_turbulent"/>
      </type>
      <type name="turbulence_closure_type">
         <enumeration items="application_defined eddy_viscosity Reynolds_stress Reynolds_stress_algebraic unspecified"/>
      </type>
      <type name="turbulence_model_data_name">
         <enumeration items="turbulent_BB_Reynolds turbulent_dissipation turbulent_dissipation_rate turbulent_distance turbulent_energy_kinetic turbulent_SA_cb1 turbulent_SA_cb2 turbulent_SA_chi turbulent_SA_ct1 turbulent_SA_ct2 turbulent_SA_ct3 turbulent_SA_ct4 turbulent_SA_cv1 turbulent_SA_cw1 turbulent_SA_cw2 turbulent_SA_cw3 turbulent_SA_kappa turbulent_SA_nu_tilde turbulent_SA_sigma"/>
      </type>
      <type name="turbulence_model_type">
         <enumeration items="algebraic_Baldwin_Lomax algebraic_Cebeci_Smith application_defined half_equation_Johnson_King one_equation_Baldwin_Barth one_equation_Spalart_Allmaras two_equation_Jones_Launder two_equation_Menter_SST two_equation_Wilcox unspecified"/>
      </type>
      <type name="u_direction_count">
         <builtintype type="INTEGER"/>
         <where expression="SELF &gt; 1" label="WR1"/>
      </type>
      <type name="unit">
         <select selectitems="derived_unit named_unit"/>
      </type>
      <type name="unspecified_value">
         <enumeration items="unspecified"/>
      </type>
      <type name="v_direction_count">
         <builtintype type="INTEGER"/>
         <where expression="SELF &gt; 1" label="WR1"/>
      </type>
      <type name="value_context_select">
         <select selectitems="action action_method choose_representation_context_identifier general_property product_definition representation_item shape_aspect"/>
      </type>
      <type name="value_qualifier">
         <select selectitems="precision_qualifier type_qualifier uncertainty_qualifier"/>
      </type>
      <type name="vector_or_direction">
         <select selectitems="vector direction"/>
      </type>
      <type name="velocity_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="viscosity_model_data_name">
         <enumeration items="Sutherland_constant_viscosity viscosity_molecular_reference"/>
      </type>
      <type name="viscosity_model_type">
         <enumeration items="application_defined constant_viscosity power_law Sutherland_law unspecified"/>
      </type>
      <type name="volume_2d_edge">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 4)" label="WR1"/>
      </type>
      <type name="volume_2d_element_coordinate_system">
         <select selectitems="arbitrary_volume_2d_element_coordinate_system parametric_volume_2d_element_coordinate_system"/>
      </type>
      <type name="volume_2d_element_descriptor">
         <select selectitems="axisymmetric_volume_2d_element_descriptor plane_volume_2d_element_descriptor"/>
      </type>
      <type name="volume_2d_element_field_integration">
         <select selectitems="element_integration_algebraic volume_2d_element_field_integration_rule volume_2d_element_field_integration_explicit"/>
      </type>
      <type name="volume_2d_element_output_reference">
         <select selectitems="volume_2d_element_representation volume_2d_element_descriptor volume_2d_element_group volume_2d_substructure_element_reference analysis_item_within_representation"/>
      </type>
      <type name="volume_2d_element_representation">
         <select selectitems="axisymmetric_volume_2d_element_representation plane_volume_2d_element_representation"/>
      </type>
      <type name="volume_2d_face">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 4)" label="WR1"/>
      </type>
      <type name="volume_3d_edge">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 12)" label="WR1"/>
      </type>
      <type name="volume_3d_element_coordinate_system">
         <select selectitems="arbitrary_volume_3d_element_coordinate_system parametric_volume_3d_element_coordinate_system"/>
      </type>
      <type name="volume_3d_element_field_integration">
         <select selectitems="element_integration_algebraic volume_3d_element_field_integration_rule volume_3d_element_field_integration_explicit"/>
      </type>
      <type name="volume_3d_element_output_reference">
         <select selectitems="volume_3d_element_representation volume_3d_element_descriptor volume_3d_element_group volume_3d_substructure_element_reference analysis_item_within_representation"/>
      </type>
      <type name="volume_3d_element_shape">
         <enumeration items="hexahedron wedge tetrahedron pyramid"/>
      </type>
      <type name="volume_3d_face">
         <builtintype type="INTEGER"/>
         <where expression="(SELF &gt;= 1) AND (SELF &lt;= 6)" label="WR1"/>
      </type>
      <type name="volume_aggregated_variable">
         <select selectitems="aggregated_scalar_variable aggregated_angular_variable aggregated_vector_3d_variable aggregated_tensor2_3d_variable application_defined_scalar_variable application_defined_vector_3d_variable application_defined_tensor2_3d_variable"/>
      </type>
      <type name="volume_angular_variable">
         <enumeration items="constant_angular_acceleration application_defined_angular_scalar_variable"/>
      </type>
      <type name="volume_element_purpose">
         <select selectitems="enumerated_volume_element_purpose application_defined_element_purpose"/>
      </type>
      <type name="volume_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="volume_scalar_variable">
         <enumeration items="temperature moisture reference_temperature strain_energy_per_unit_volume"/>
      </type>
      <type name="volume_tensor2_3d_variable">
         <enumeration items="total_strain stress"/>
      </type>
      <type name="volume_variable">
         <select selectitems="volume_scalar_variable volume_angular_variable volume_vector_3d_variable volume_tensor2_3d_variable application_defined_scalar_variable application_defined_vector_3d_variable application_defined_tensor2_3d_variable"/>
      </type>
      <type name="volume_vector_3d_variable">
         <enumeration items="position applied_force_per_unit_volume applied_moment_per_unit_volume displacement infinitesimal_rotation acceleration"/>
      </type>
      <type name="week_in_year_number">
         <builtintype type="INTEGER"/>
         <where expression="{ 1 &lt;= SELF &lt;= 53 }" label="WR1"/>
      </type>
      <type name="work_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="year_number">
         <builtintype type="INTEGER"/>
      </type>
      <type name="zero_or_one">
         <typename name="nonnegative_integer"/>
         <where expression="(SELF = 0) OR (SELF = 1)" label="in_range"/>
      </type>
      <entity abstract.supertype="YES" name="SQL_mappable_defined_function" supertypes="defined_function"/>
      <entity name="abs_function" supertypes="unary_function_call"/>
      <entity name="absorbed_dose_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="absorbed_dose_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.gray)" label="WR1"/>
      </entity>
      <entity name="abstract_variable" supertypes="property_definition property_definition_representation representation representation_item"/>
      <entity name="abstracted_expression_function" supertypes="maths_function quantifier_expression">
         <derived expression="remove_first(SELF\multiple_arity_generic_expression.operands)" name="variables">
            <aggregate lower="1" type="LIST" unique="YES" upper="?"/>
            <typename name="generic_variable"/>
            <redeclaration entity-ref="quantifier_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[1]" name="expr">
            <typename name="generic_expression"/>
         </derived>
         <where expression="SIZEOF (QUERY ( operand &lt;*&#10;       SELF\multiple_arity_generic_expression.operands | NOT (&#10;       has_values_space( operand)))) = 0" label="WR1"/>
      </entity>
      <entity name="acceleration_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACCELERATION_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="acceleration_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = &#10;       dimensional_exponents ( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 )" label="WR1"/>
      </entity>
      <entity name="acos_function" supertypes="unary_function_call"/>
      <entity name="action">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="chosen_method">
            <typename name="action_method"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="action_assignment">
         <explicit name="assigned_action">
            <typename name="action"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="action_directive">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="analysis">
            <typename name="text"/>
         </explicit>
         <explicit name="comment">
            <typename name="text"/>
         </explicit>
         <explicit name="requests">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_method">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="consequence">
            <typename name="text"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="action_method_assignment">
         <explicit name="assigned_action_method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="role">
            <typename name="action_method_role"/>
         </explicit>
      </entity>
      <entity name="action_method_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="related_method">
            <typename name="action_method"/>
         </explicit>
      </entity>
      <entity name="action_method_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="action_property">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_action_definition"/>
         </explicit>
      </entity>
      <entity name="action_property_representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="property">
            <typename name="action_property"/>
         </explicit>
         <explicit name="representation">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="action_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_action">
            <typename name="action"/>
         </explicit>
         <explicit name="related_action">
            <typename name="action"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="action_request_assignment">
         <explicit name="assigned_action_request">
            <typename name="versioned_action_request"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="action_request_solution">
         <explicit name="method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="request">
            <typename name="versioned_action_request"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="action_request_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_resource">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="usage">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="supported_item"/>
         </explicit>
         <explicit name="kind">
            <typename name="action_resource_type"/>
         </explicit>
      </entity>
      <entity name="action_resource_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_resource">
            <typename name="action_resource"/>
         </explicit>
         <explicit name="related_resource">
            <typename name="action_resource"/>
         </explicit>
      </entity>
      <entity name="action_resource_requirement">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="resource_requirement_type"/>
         </explicit>
         <explicit name="operations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="characterized_action_definition"/>
         </explicit>
      </entity>
      <entity name="action_resource_requirement_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_action_resource_requirement">
            <typename name="action_resource_requirement"/>
         </explicit>
         <explicit name="related_action_resource_requirement">
            <typename name="action_resource_requirement"/>
         </explicit>
         <where expression="relating_action_resource_requirement :&lt;&gt;: &#10;       related_action_resource_requirement" label="WR1"/>
      </entity>
      <entity name="action_resource_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="action_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_action">
            <typename name="executed_action"/>
         </explicit>
      </entity>
      <entity name="action_view_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="discretised_model">
            <typename name="discretised_action_model_select"/>
         </explicit>
         <explicit name="idealised_action">
            <typename name="idealised_action_select"/>
         </explicit>
      </entity>
      <entity name="address">
         <explicit name="internal_location" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_box" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="town" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="region" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_code" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="country" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="facsimile_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telephone_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="electronic_mail_address" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telex_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <derived expression="get_id_value(SELF)" name="url">
            <typename name="identifier"/>
         </derived>
         <where expression="EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number)" label="WR1"/>
      </entity>
      <entity name="advanced_brep_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) &gt; 0" label="WR2"/>
         <where expression="SIZEOF ( &#10;QUERY ( msb &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( csh &lt;* msb_shells(msb)| NOT ( SIZEOF ( &#10;QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fcs)) )) = 0) )) = 0) )) = 0" label="WR3"/>
         <where expression="SIZEOF ( &#10;QUERY ( msb &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0" label="WR4"/>
         <where expression="SIZEOF ( &#10;QUERY ( brv &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( csh &lt;* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0" label="WR5"/>
         <where expression="SIZEOF ( &#10;QUERY ( mi &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0" label="WR6"/>
      </entity>
      <entity name="advanced_face" supertypes="face_surface">
         <where expression="SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0" label="WR2"/>
         <where expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0" label="WR3"/>
         <where expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| NOT ((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0" label="WR4"/>
         <where expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0" label="WR5"/>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1)" label="WR6"/>
         <where expression="SIZEOF ( &#10;QUERY ( vlp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0" label="WR7"/>
         <where expression="SIZEOF ( &#10;QUERY ( bnd &lt;* bounds| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0" label="WR8"/>
         <where expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( &#10;QUERY ( sc_ag &lt;* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0" label="WR9"/>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) &gt;= 3))) AND ( SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) &gt;= 3) )) = 0) )) = 0)" label="WR10"/>
      </entity>
      <entity name="aligned_axis_tolerance">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="tolerance">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="aligned_curve_3d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="aligned_surface_2d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <where expression="SELF\geometric_representation_item.dim=2" label="WR1"/>
      </entity>
      <entity name="aligned_surface_3d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="alternate_product_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="alternate">
            <typename name="product"/>
         </explicit>
         <explicit name="base">
            <typename name="product"/>
         </explicit>
         <explicit name="basis">
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="alternate"/>
            <unique.attribute attribute="base"/>
         </unique>
         <where expression="alternate :&lt;&gt;: base" label="WR1"/>
      </entity>
      <entity name="amount_of_substance_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="amount_of_substance_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="analysis_assignment" supertypes="group"/>
      <entity name="analysis_item" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="analysis_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="analysed_item"/>
         </explicit>
      </entity>
      <entity name="analysis_item_within_representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="item">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="rep">
            <typename name="representation"/>
         </explicit>
         <where expression="SIZEOF (QUERY (tmp &lt;* using_representations(item) | &#10;                      tmp :=: rep)) = 1" label="WR1"/>
      </entity>
      <entity name="analysis_message" super.expression="ONEOF (whole_model_analysis_message, element_analysis_message, node_analysis_message, element_group_analysis_message)" supertypes="state_definition">
         <explicit name="level">
            <typename name="message_level"/>
         </explicit>
         <explicit name="message_text">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="analysis_model" supertypes="representation">
         <explicit name="context_of_items">
            <typename name="analysis_representation_context"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="analysis_representation_context" supertypes="representation_context"/>
      <entity name="analysis_step" super.expression="ONEOF (control_analysis_step, result_analysis_step)">
         <explicit name="analysis_control">
            <typename name="control"/>
         </explicit>
      </entity>
      <entity name="and_expression" supertypes="multiple_arity_boolean_expression"/>
      <entity name="angle_direction_reference" supertypes="representation_item_relationship geometric_representation_item">
         <explicit name="relating_representation_item">
            <typename name="orientation_basis_select"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <explicit name="related_representation_item">
            <typename name="angle_direction_reference_select"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <where expression="((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_PATH' IN TYPEOF(related_representation_item)) AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MIN_AND_MAJOR_PLY_ORIENTATION_BASIS' IN TYPEOF(relating_representation_item))) &#10;        OR&#10;&#9;&#9;(NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_PATH' IN TYPEOF(related_representation_item)) AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF(relating_representation_item))))" label="WR1"/>
      </entity>
      <entity name="angular_dimension" supertypes="dimension_curve_directed_callout"/>
      <entity name="angular_location" supertypes="dimensional_location">
         <explicit name="angle_selection">
            <typename name="angle_relator"/>
         </explicit>
      </entity>
      <entity name="angular_size" supertypes="dimensional_size">
         <explicit name="angle_selection">
            <typename name="angle_relator"/>
         </explicit>
      </entity>
      <entity name="angularity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt; 3" label="WR1"/>
      </entity>
      <entity name="annotation_curve_occurrence" supertypes="annotation_occurrence">
         <explicit name="item">
            <typename name="curve"/>
            <redeclaration entity-ref="styled_item"/>
         </explicit>
      </entity>
      <entity name="annotation_fill_area" supertypes="geometric_representation_item">
         <explicit name="boundaries">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve"/>
         </explicit>
         <where expression="(SELF\geometric_representation_item.dim = 3) OR (SIZEOF (QUERY (curve &lt;* SELF.boundaries |&#10;          NOT (&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE' IN TYPEOF (curve)) OR &#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE' IN TYPEOF (curve)) OR &#10;              ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (curve)) &#10;                   AND (curve\b_spline_curve.closed_curve = TRUE) ) OR &#10;              ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF (curve)) &#10;                   AND (curve\composite_curve.closed_curve = TRUE) ) OR &#10;              ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (curve)) &#10;                   AND (curve\polyline.points[LOINDEX(curve\polyline.points)] = &#10;                        curve\polyline.points[HIINDEX(curve\polyline.points)]) )&#10;              ) )) = 0)" label="WR1"/>
      </entity>
      <entity name="annotation_fill_area_occurrence" supertypes="annotation_occurrence">
         <explicit name="fill_style_target">
            <typename name="point"/>
         </explicit>
         <explicit name="item">
            <typename name="annotation_fill_area"/>
            <redeclaration entity-ref="styled_item"/>
         </explicit>
      </entity>
      <entity name="annotation_occurrence" super.expression="ONEOF (annotation_curve_occurrence, annotation_fill_area_occurrence, annotation_text_occurrence, annotation_symbol_occurrence)" supertypes="styled_item">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN&#10;             TYPEOF (SELF)" label="WR1"/>
         <where expression="SIZEOF (QUERY (reps &lt;* using_representations(SELF) | &#10;        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_REPRESENTATION_SELECT' IN TYPEOF(reps)))) = 0" label="WR2"/>
      </entity>
      <entity name="annotation_occurrence_associativity" supertypes="annotation_occurrence_relationship">
         <where expression="SIZEOF (TYPEOF (SELF.related_annotation_occurrence) *&#10;          ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE',&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE',&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE']) = 1" label="WR1"/>
      </entity>
      <entity name="annotation_occurrence_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_annotation_occurrence">
            <typename name="annotation_occurrence"/>
         </explicit>
         <explicit name="related_annotation_occurrence">
            <typename name="annotation_occurrence"/>
         </explicit>
      </entity>
      <entity name="annotation_plane" supertypes="annotation_occurrence geometric_representation_item">
         <explicit name="elements" optional="YES">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="annotation_plane_element"/>
         </explicit>
         <explicit name="item">
            <typename name="plane_or_planar_box"/>
            <redeclaration entity-ref="styled_item"/>
         </explicit>
         <where expression="SELF\geometric_representation_item.dim = 3" label="WR1"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'AXIS2_PLACEMENT_3D' IN TYPEOF(SELF\styled_item.item\planar_box.placement))" label="WR2"/>
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'CURVE_STYLE' IN TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1]))) OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PLANE' IN TYPEOF(SELF\styled_item.item)) AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'FILL_AREA_STYLE' IN TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1])))" label="WR3"/>
         <where expression="(SIZEOF(SELF\styled_item.styles) = 1) AND&#10;        (SIZEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles) = 1)" label="WR4"/>
      </entity>
      <entity name="annotation_subfigure_occurrence" supertypes="annotation_symbol_occurrence">
         <where expression="SIZEOF (QUERY (sty &lt;* SELF.styles |&#10;         NOT (SIZEOF (sty.styles) = 1)&#10;       )) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (sty &lt;* SELF.styles |&#10;         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NULL_STYLE'&#10;               IN TYPEOF (sty.styles[1]))       ))=0" label="WR2"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL'&#10;           IN TYPEOF (SELF.item))" label="WR3"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_SUBFIGURE_REPRESENTATION'&#10;           IN TYPEOF&#10;           (SELF.item\mapped_item.mapping_source.mapped_representation))" label="WR4"/>
      </entity>
      <entity name="annotation_symbol" supertypes="mapped_item">
         <explicit name="mapping_source">
            <typename name="symbol_representation_map"/>
            <redeclaration entity-ref="mapped_item"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="symbol_target"/>
            <redeclaration entity-ref="mapped_item"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN&#10;          TYPEOF (SELF)" label="WR1"/>
      </entity>
      <entity name="annotation_symbol_occurrence" supertypes="annotation_occurrence">
         <explicit name="item">
            <typename name="annotation_symbol_occurrence_item"/>
            <redeclaration entity-ref="styled_item"/>
         </explicit>
      </entity>
      <entity name="annotation_text" supertypes="mapped_item">
         <explicit name="mapping_target">
            <typename name="axis2_placement"/>
            <redeclaration entity-ref="mapped_item"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STRING_REPRESENTATION' IN&#10;        TYPEOF( SELF\mapped_item.mapping_source.mapped_representation)" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN&#10;        TYPEOF( SELF)" label="WR2"/>
      </entity>
      <entity name="annotation_text_character" supertypes="mapped_item">
         <explicit name="alignment">
            <typename name="text_alignment"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="axis2_placement"/>
            <redeclaration entity-ref="mapped_item"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTER_GLYPH_SYMBOL' IN&#10;         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation)" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN&#10;         TYPEOF (SELF)" label="WR2"/>
      </entity>
      <entity name="annotation_text_occurrence" supertypes="annotation_occurrence">
         <explicit name="item">
            <typename name="annotation_text_occurrence_item"/>
            <redeclaration entity-ref="styled_item"/>
         </explicit>
      </entity>
      <entity name="apex" supertypes="derived_shape_aspect"/>
      <entity name="application_context">
         <explicit name="application">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <inverse attribute="frame_of_reference" entity="application_context_element" name="context_elements">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="application_context_element" super.expression="ONEOF (library_context, product_concept_context, product_context, product_definition_context)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="application_defined_function" supertypes="maths_function">
         <explicit name="explicit_domain">
            <typename name="tuple_space"/>
         </explicit>
         <explicit name="explicit_range">
            <typename name="tuple_space"/>
         </explicit>
         <explicit name="parameters">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </explicit>
         <where expression="expression_is_constant(explicit_domain)" label="WR1"/>
         <where expression="expression_is_constant(explicit_range)" label="WR2"/>
      </entity>
      <entity name="application_protocol_definition">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="application_interpreted_model_schema_name">
            <typename name="label"/>
         </explicit>
         <explicit name="application_protocol_year">
            <typename name="year_number"/>
         </explicit>
         <explicit name="application">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="applied_action_assignment" supertypes="action_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="action_items"/>
         </explicit>
      </entity>
      <entity name="applied_action_method_assignment" supertypes="action_method_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="action_method_items"/>
         </explicit>
      </entity>
      <entity name="applied_action_request_assignment" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="action_request_item"/>
         </explicit>
      </entity>
      <entity name="applied_approval_assignment" supertypes="approval_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="approval_item"/>
         </explicit>
      </entity>
      <entity name="applied_attribute_classification_assignment" supertypes="attribute_classification_assignment">
         <explicit name="assigned_class">
            <typename name="class"/>
            <redeclaration entity-ref="attribute_classification_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="attribute_classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_certification_assignment" supertypes="certification_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="certification_item"/>
         </explicit>
      </entity>
      <entity name="applied_classification_assignment" supertypes="classification_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_contract_assignment" supertypes="contract_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="contract_item"/>
         </explicit>
      </entity>
      <entity name="applied_date_and_time_assignment" supertypes="date_and_time_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="date_and_time_item"/>
         </explicit>
      </entity>
      <entity name="applied_date_assignment" supertypes="date_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="date_item"/>
         </explicit>
      </entity>
      <entity name="applied_document_reference" supertypes="document_reference">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="document_reference_item"/>
         </explicit>
      </entity>
      <entity name="applied_document_usage_constraint_assignment" supertypes="document_usage_constraint_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="document_reference_item"/>
         </explicit>
      </entity>
      <entity name="applied_effectivity_assignment" supertypes="effectivity_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="effectivity_item"/>
         </explicit>
      </entity>
      <entity name="applied_external_identification_assignment" supertypes="external_identification_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="external_identification_item"/>
         </explicit>
      </entity>
      <entity name="applied_group_assignment" supertypes="group_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="groupable_item"/>
         </explicit>
      </entity>
      <entity name="applied_identification_assignment" supertypes="identification_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="identification_item"/>
         </explicit>
      </entity>
      <entity name="applied_name_assignment" supertypes="name_assignment">
         <explicit name="item">
            <typename name="name_item"/>
         </explicit>
      </entity>
      <entity name="applied_organization_assignment" supertypes="organization_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="organization_item"/>
         </explicit>
      </entity>
      <entity name="applied_organizational_project_assignment" supertypes="organizational_project_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="project_item"/>
         </explicit>
      </entity>
      <entity name="applied_person_and_organization_assignment" supertypes="person_and_organization_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="person_and_organization_item"/>
         </explicit>
      </entity>
      <entity name="applied_presented_item" supertypes="presented_item">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="presented_item_select"/>
         </explicit>
      </entity>
      <entity name="applied_security_classification_assignment" supertypes="security_classification_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="security_classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_usage_right" supertypes="applied_action_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="ir_usage_item"/>
            <redeclaration entity-ref="applied_action_assignment"/>
         </explicit>
      </entity>
      <entity name="approval">
         <explicit name="status">
            <typename name="approval_status"/>
         </explicit>
         <explicit name="level">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="approval_assignment">
         <explicit name="assigned_approval">
            <typename name="approval"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="approval_date_time">
         <explicit name="date_time">
            <typename name="date_time_select"/>
         </explicit>
         <explicit name="dated_approval">
            <typename name="approval"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="approval_person_organization">
         <explicit name="person_organization">
            <typename name="person_organization_select"/>
         </explicit>
         <explicit name="authorized_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="role">
            <typename name="approval_role"/>
         </explicit>
      </entity>
      <entity name="approval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="related_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_role">
         <explicit name="role">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="approval_status">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="arbitrary_volume_2d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <where expression="SELF\geometric_representation_item.dim=2" label="WR1"/>
      </entity>
      <entity name="arbitrary_volume_3d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="area_in_set">
         <explicit name="area">
            <typename name="presentation_area"/>
         </explicit>
         <explicit name="in_set">
            <typename name="presentation_set"/>
         </explicit>
      </entity>
      <entity name="area_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="area_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = &#10;      dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 )" label="WR1"/>
      </entity>
      <entity name="array_based_unstructured_mesh" supertypes="unstructured_mesh">
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <typename name="vertex_defined_cell"/>
         </explicit>
         <where expression="SELF\mesh.index_count = 1" label="wr1"/>
      </entity>
      <entity name="asin_function" supertypes="unary_function_call"/>
      <entity name="assembly_component_usage" super.expression="ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence)" supertypes="product_definition_usage">
         <explicit name="reference_designator" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="assembly_component_usage_substitute">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="base">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="substitute">
            <typename name="assembly_component_usage"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="base"/>
            <unique.attribute attribute="substitute"/>
         </unique>
         <where expression="base.relating_product_definition :=:&#10;       substitute.relating_product_definition" label="WR1"/>
         <where expression="base :&lt;&gt;: substitute" label="WR2"/>
      </entity>
      <entity name="assigned_analysis" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="analysis_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="product_definition_formation"/>
         </explicit>
      </entity>
      <entity name="assigned_requirement" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="atan_function" supertypes="binary_function_call"/>
      <entity name="atom_based_literal" supertypes="generic_literal">
         <explicit name="lit_value">
            <typename name="atom_based_value"/>
         </explicit>
      </entity>
      <entity name="atomic_formula" supertypes="compound_representation_item"/>
      <entity name="attribute_assertion" supertypes="fact_type property_definition_representation representation"/>
      <entity abstract.supertype="YES" name="attribute_classification_assignment">
         <explicit name="assigned_class">
            <typename name="group"/>
         </explicit>
         <explicit name="attribute_name">
            <typename name="label"/>
         </explicit>
         <explicit name="role">
            <typename name="classification_role"/>
         </explicit>
      </entity>
      <entity name="attribute_language_assignment" supertypes="attribute_classification_assignment">
         <explicit name="assigned_class">
            <typename name="language"/>
            <redeclaration entity-ref="attribute_classification_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="attribute_language_item"/>
         </explicit>
         <where expression="SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']" label="WR1"/>
         <where expression="SELF\attribute_classification_assignment.attribute_name&lt;&gt; ''" label="WR2"/>
      </entity>
      <entity abstract.supertype="YES" name="attribute_value_assignment">
         <explicit name="attribute_name">
            <typename name="label"/>
         </explicit>
         <explicit name="attribute_value">
            <typename name="attribute_type"/>
         </explicit>
         <explicit name="role">
            <typename name="attribute_value_role"/>
         </explicit>
      </entity>
      <entity name="attribute_value_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="auxiliary_geometric_representation_item" supertypes="geometric_representation_item variational_representation_item"/>
      <entity name="axis1_placement" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived expression="NVL(normalise(axis), dummy_gri ||&#10;                                 direction([0.0,0.0,1.0]))" name="z">
            <typename name="direction"/>
         </derived>
         <where expression="SELF\geometric_representation_item.dim  = 3" label="WR1"/>
      </entity>
      <entity name="axis2_placement_2d" supertypes="placement">
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived expression="build_2axes(ref_direction)" name="p">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where expression="SELF\geometric_representation_item.dim = 2" label="WR1"/>
      </entity>
      <entity name="axis2_placement_3d" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived expression="build_axes(axis,ref_direction)" name="p">
            <aggregate lower="3" type="LIST" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where expression="SELF\placement.location.dim = 3" label="WR1"/>
         <where expression="(NOT (EXISTS (axis))) OR (axis.dim = 3)" label="WR2"/>
         <where expression="(NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3)" label="WR3"/>
         <where expression="(NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR&#10;          (cross_product(axis,ref_direction).magnitude &gt; 0.0)" label="WR4"/>
      </entity>
      <entity name="axisymmetric_2d_element_property">
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="axisymmetric_curve_2d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_element_purpose"/>
         </explicit>
      </entity>
      <entity name="axisymmetric_curve_2d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_2d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="axisymmetric_curve_2d_element_descriptor"/>
         </explicit>
         <explicit name="property">
            <typename name="curve_2d_element_property"/>
         </explicit>
         <explicit name="angle_property">
            <typename name="axisymmetric_2d_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="model_ref.type_of_2d_analysis = axisymmetric" label="WR1"/>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) = 1" label="WR2"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR3"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR4"/>
         <where expression="required_0d_nodes (&#10;        SELF\element_representation.node_list)" label="FU1"/>
      </entity>
      <entity name="axisymmetric_surface_2d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_element_purpose"/>
         </explicit>
      </entity>
      <entity name="axisymmetric_surface_2d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_2d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="axisymmetric_surface_2d_element_descriptor"/>
         </explicit>
         <explicit name="property">
            <typename name="surface_element_property"/>
         </explicit>
         <explicit name="angle_property">
            <typename name="axisymmetric_2d_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="model_ref.type_of_2d_analysis = axisymmetric" label="WR1"/>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'&#10;               IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' &#10;               IN TYPEOF (item))) = 1" label="WR2"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_BENDING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR3"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR4"/>
         <where expression="required_1d_nodes (&#10;        SELF\element_representation.node_list,&#10;        element_descriptor\element_descriptor.topology_order)" label="FU1"/>
      </entity>
      <entity name="axisymmetric_volume_2d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_element_purpose"/>
         </explicit>
         <explicit name="shape">
            <typename name="element_2d_shape"/>
         </explicit>
      </entity>
      <entity name="axisymmetric_volume_2d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_2d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="axisymmetric_volume_2d_element_descriptor"/>
         </explicit>
         <explicit name="angle_property">
            <typename name="axisymmetric_2d_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="model_ref.type_of_2d_analysis = axisymmetric" label="WR1"/>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) = 1" label="WR2"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR3"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR4"/>
         <where expression="required_2d_nodes (&#10;        SELF\element_representation.node_list,&#10;        element_descriptor.shape,&#10;        element_descriptor\element_descriptor.topology_order)" label="FU1"/>
      </entity>
      <entity name="b_spline_basis" supertypes="maths_function generic_literal">
         <explicit name="degree">
            <typename name="nonnegative_integer"/>
         </explicit>
         <explicit name="repeated_knots">
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived expression="degree + 1" name="order">
            <typename name="positive_integer"/>
         </derived>
         <derived expression="SIZEOF (repeated_knots) - order" name="num_basis">
            <typename name="positive_integer"/>
         </derived>
         <where expression="num_basis &gt;= order" label="WR1"/>
         <where expression="nondecreasing(repeated_knots)" label="WR2"/>
         <where expression="repeated_knots[order] &lt; repeated_knots[num_basis+1]" label="WR3"/>
      </entity>
      <entity name="b_spline_curve" super.expression="ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve" supertypes="bounded_curve">
         <explicit name="degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="curve_form">
            <typename name="b_spline_curve_form"/>
         </explicit>
         <explicit name="closed_curve">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived expression="(SIZEOF(control_points_list) - 1)" name="upper_index_on_control_points">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="list_to_array(control_points_list,0,&#10;                                             upper_index_on_control_points)" name="control_points">
            <aggregate lower="0" type="ARRAY" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEZIER_CURVE' IN TYPEOF(self)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))" label="WR1"/>
      </entity>
      <entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
         <explicit name="knot_multiplicities">
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="knots">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived expression="SIZEOF(knots)" name="upper_index_on_knots">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="constraints_param_b_spline(degree, upper_index_on_knots,&#10;                               upper_index_on_control_points,&#10;                               knot_multiplicities, knots)" label="WR1"/>
         <where expression="SIZEOF(knot_multiplicities) = upper_index_on_knots" label="WR2"/>
      </entity>
      <entity name="b_spline_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="basis">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="b_spline_basis"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="coef">
            <typename name="maths_function"/>
         </derived>
         <where expression="function_is_table(coef)" label="WR1"/>
         <where expression="(space_dimension(coef.range) = 1) AND&#10;       (number_superspace_of(factor1(coef.range)) = the_reals)" label="WR2"/>
         <where expression="SIZEOF (basis) &lt;=&#10;       SIZEOF (shape_of_array(coef))" label="WR3"/>
         <where expression="compare_basis_and_coef(basis, coef)" label="WR4"/>
      </entity>
      <entity name="b_spline_surface" super.expression="ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface" supertypes="bounded_surface">
         <explicit name="u_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate lower="2" type="LIST" upper="?"/>
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="surface_form">
            <typename name="b_spline_surface_form"/>
         </explicit>
         <explicit name="u_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="v_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived expression="SIZEOF(control_points_list) - 1" name="u_upper">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="SIZEOF(control_points_list[1]) - 1" name="v_upper">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="make_array_of_array(control_points_list,&#10;                                              0,u_upper,0,v_upper)" name="control_points">
            <aggregate lower="0" type="ARRAY" upper="0"/>
            <aggregate lower="0" type="ARRAY" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEZIER_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))" label="WR1"/>
      </entity>
      <entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
         <explicit name="u_multiplicities">
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_multiplicities">
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="u_knots">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v_knots">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived expression="SIZEOF(u_knots)" name="knot_u_upper">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="SIZEOF(v_knots)" name="knot_v_upper">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,&#10;                   knot_u_upper, SELF\b_spline_surface.u_upper,&#10;                               u_multiplicities, u_knots)" label="WR1"/>
         <where expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,&#10;                   knot_v_upper, SELF\b_spline_surface.v_upper,&#10;                               v_multiplicities, v_knots)" label="WR2"/>
         <where expression="SIZEOF(u_multiplicities) = knot_u_upper" label="WR3"/>
         <where expression="SIZEOF(v_multiplicities) = knot_v_upper" label="WR4"/>
      </entity>
      <entity name="back_chaining_rule" supertypes="rule_definition"/>
      <entity name="back_chaining_rule_body" supertypes="property_definition property_definition_representation representation"/>
      <entity name="background_colour" supertypes="colour">
         <explicit name="presentation">
            <typename name="area_or_view"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="presentation"/>
         </unique>
      </entity>
      <entity name="banded_matrix" supertypes="linearized_table_function">
         <explicit name="default_entry">
            <typename name="maths_value"/>
         </explicit>
         <explicit name="below">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="above">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="order">
            <typename name="ordering_type"/>
         </explicit>
         <where expression="SIZEOF (self\explicit_table_function.shape) = 2" label="WR1"/>
         <where expression="-below &lt;= above" label="WR2"/>
         <where expression="member_of(default_entry,&#10;       factor1(SELF\linearized_table_function.source.range))" label="WR3"/>
      </entity>
      <entity name="basic_sparse_matrix" supertypes="explicit_table_function multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="3" type="LIST" upper="3"/>
            <typename name="maths_function"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
         <explicit name="default_entry">
            <typename name="maths_value"/>
         </explicit>
         <explicit name="order">
            <typename name="ordering_type"/>
         </explicit>
         <derived expression="SELF\multiple_arity_generic_expression.operands[1]" name="index">
            <typename name="maths_function"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[2]" name="loc">
            <typename name="maths_function"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[3]" name="val">
            <typename name="maths_function"/>
         </derived>
         <where expression="function_is_1d_table(index)" label="WR1"/>
         <where expression="function_is_1d_table(loc)" label="WR2"/>
         <where expression="function_is_1d_table(val)" label="WR3"/>
         <where expression="check_sparse_index_domain(index.domain, index_base, shape, order)" label="WR4"/>
         <where expression="check_sparse_index_to_loc(index.range, loc.domain)" label="WR5"/>
         <where expression="loc.domain = val.domain" label="WR6"/>
         <where expression="check_sparse_loc_range(loc.range, index_base, shape, order)" label="WR7"/>
         <where expression="member_of(default_entry, val.range)" label="WR8"/>
      </entity>
      <entity name="behavioural_decomposition_of_numerical_model">
         <explicit name="parts">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="numerical_model"/>
         </explicit>
         <explicit name="whole">
            <typename name="numerical_model"/>
         </explicit>
      </entity>
      <entity name="behavioural_decomposition_of_temporal_spatial_domain">
         <explicit name="parts">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="temporal_spatial_domain"/>
         </explicit>
         <explicit name="whole">
            <typename name="temporal_spatial_domain"/>
         </explicit>
      </entity>
      <entity name="beveled_sheet_representation" supertypes="shape_representation"/>
      <entity name="bezier_curve" supertypes="b_spline_curve"/>
      <entity name="bezier_surface" supertypes="b_spline_surface"/>
      <entity abstract.supertype="YES" name="binary_boolean_expression" super.expression="ONEOF (xor_expression, equals_expression)" supertypes="boolean_expression binary_generic_expression"/>
      <entity abstract.supertype="YES" name="binary_function_call" supertypes="binary_numeric_expression"/>
      <entity abstract.supertype="YES" name="binary_generic_expression" supertypes="generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity name="binary_literal" supertypes="generic_literal">
         <explicit name="lit_value">
            <builtintype type="BINARY"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="binary_numeric_expression" super.expression="ONEOF (minus_expression, div_expression, mod_expression, slash_expression, power_expression, binary_function_call)" supertypes="numeric_expression binary_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="binary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="binary_representation_item" supertypes="representation_item">
         <explicit name="binary_value">
            <builtintype type="BINARY"/>
         </explicit>
      </entity>
      <entity name="block" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="x">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="y">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="boolean_defined_function" supertypes="defined_function boolean_expression"/>
      <entity abstract.supertype="YES" name="boolean_expression" super.expression="ONEOF (simple_boolean_expression, unary_boolean_expression, binary_boolean_expression, multiple_arity_boolean_expression, comparison_expression, interval_expression, boolean_defined_function)" supertypes="expression"/>
      <entity name="boolean_literal" supertypes="simple_boolean_expression generic_literal">
         <explicit name="the_value">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="boolean_representation_item" supertypes="representation_item boolean_literal"/>
      <entity name="boolean_result" supertypes="geometric_representation_item">
         <explicit name="operator">
            <typename name="boolean_operator"/>
         </explicit>
         <explicit name="first_operand">
            <typename name="boolean_operand"/>
         </explicit>
         <explicit name="second_operand">
            <typename name="boolean_operand"/>
         </explicit>
      </entity>
      <entity name="boolean_variable" supertypes="simple_boolean_expression variable"/>
      <entity name="bound_variable_semantics" supertypes="variable_semantics"/>
      <entity name="boundary_curve" supertypes="composite_curve_on_surface">
         <where expression="SELF\composite_curve.closed_curve" label="WR1"/>
      </entity>
      <entity name="bounded_curve" super.expression="ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve)" supertypes="curve"/>
      <entity name="bounded_pcurve" supertypes="pcurve bounded_curve">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE' IN&#10;                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]))" label="WR1"/>
      </entity>
      <entity name="bounded_surface" super.expression="ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface)" supertypes="surface"/>
      <entity name="bounded_surface_curve" supertypes="surface_curve bounded_curve">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE' IN&#10;             TYPEOF(SELF\surface_curve.curve_3d))" label="WR1"/>
      </entity>
      <entity name="box_domain" supertypes="founded_item">
         <explicit name="corner">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="xlength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ylength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="zlength">
            <typename name="positive_length_measure"/>
         </explicit>
         <where expression="SIZEOF(QUERY(item &lt;* USEDIN(SELF,'')|&#10;             NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOXED_HALF_SPACE'&#10;                    IN TYPEOF(item)))) = 0" label="WR1"/>
      </entity>
      <entity name="boxed_half_space" supertypes="half_space_solid">
         <explicit name="enclosure">
            <typename name="box_domain"/>
         </explicit>
      </entity>
      <entity name="breakdown_context" supertypes="product_definition_relationship"/>
      <entity name="breakdown_element_group_assignment" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="product_definition_element_relationship"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="product_definition_or_breakdown_element_usage"/>
         </explicit>
      </entity>
      <entity name="breakdown_element_realization" supertypes="characterized_object product_definition_element_relationship"/>
      <entity name="breakdown_element_usage" supertypes="product_definition_relationship"/>
      <entity name="breakdown_of" supertypes="product_definition_relationship"/>
      <entity name="brep_with_voids" supertypes="manifold_solid_brep">
         <explicit name="voids">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="oriented_closed_shell"/>
         </explicit>
      </entity>
      <entity name="bytes_representation_item" supertypes="binary_representation_item">
         <derived expression="BLENGTH(SELF\binary_representation_item.binary_value) DIV 8" name="no_of_bytes">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0" label="WR1"/>
      </entity>
      <entity name="calculated_state" supertypes="state"/>
      <entity name="calendar_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_month_number"/>
         </explicit>
         <explicit name="month_component">
            <typename name="month_in_year_number"/>
         </explicit>
         <where expression="valid_calendar_date (SELF)" label="WR1"/>
      </entity>
      <entity name="camera_image" supertypes="mapped_item">
         <explicit name="mapping_source">
            <typename name="camera_usage"/>
            <redeclaration entity-ref="mapped_item"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="planar_box"/>
            <redeclaration entity-ref="mapped_item"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM'&#10;        IN TYPEOF (SELF)" label="WR1"/>
      </entity>
      <entity name="camera_image_3d_with_scale" supertypes="camera_image">
         <derived expression="((SELF\mapped_item.mapping_target\&#10;           planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.&#10;           mapping_origin\camera_model_d3.perspective_of_volume.view_window.&#10;           size_in_x))" name="scale">
            <typename name="positive_ratio_measure"/>
         </derived>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAMERA_MODEL_D3'&#10;         IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin))" label="WR1"/>
         <where expression="aspect_ratio(SELF\mapped_item.mapping_target) =&#10;           aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\&#10;           camera_model_d3.perspective_of_volume.view_window)" label="WR2"/>
         <where expression="SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.&#10;           perspective_of_volume.front_plane_clipping&#10;           AND&#10;           SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.&#10;           perspective_of_volume.view_volume_sides_clipping" label="WR3"/>
         <where expression="(SELF\mapped_item.mapping_target\planar_extent.size_in_x &gt; 0)&#10;           AND&#10;           (SELF\mapped_item.mapping_target\planar_extent.size_in_y &gt; 0)" label="WR4"/>
         <where expression="(SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.&#10;           perspective_of_volume.view_window.size_in_x &gt; 0)&#10;           AND&#10;           (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.&#10;           perspective_of_volume.view_window.size_in_y &gt; 0)" label="WR5"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;            'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.&#10;           mapping_target\planar_box.placement))&#10;           AND NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;           'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.&#10;           mapping_target\planar_box.placement))" label="WR6"/>
      </entity>
      <entity abstract.supertype="YES" name="camera_model" supertypes="geometric_representation_item">
         <where expression="(SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                  'ITEM_DEFINED_TRANSFORMATION.' +&#10;                                  'TRANSFORM_ITEM_1')) +&#10;            SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                  'REPRESENTATION_MAP.MAPPING_ORIGIN'))&#10;            ) &gt; 0" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                              'STYLED_ITEM.ITEM')) = 0" label="WR2"/>
      </entity>
      <entity name="camera_model_d3" supertypes="camera_model">
         <explicit name="view_reference_system">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="perspective_of_volume">
            <typename name="view_volume"/>
         </explicit>
         <where expression="(dot_product (SELF.view_reference_system.p[3],&#10;           SELF.perspective_of_volume.view_window.placement.p[3]) = 1.0)&#10;           AND&#10;           (SELF.view_reference_system.location.coordinates[3] =&#10;           SELF.perspective_of_volume.view_window.&#10;             placement.location.coordinates[3])" label="WR1"/>
         <where expression="SELF\geometric_representation_item.dim = 3" label="WR2"/>
      </entity>
      <entity name="camera_model_d3_multi_clipping" supertypes="camera_model_d3">
         <explicit name="shape_clipping">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="camera_model_d3_multi_clipping_interection_select"/>
         </explicit>
      </entity>
      <entity name="camera_model_d3_multi_clipping_intersection" supertypes="geometric_representation_item">
         <explicit name="shape_clipping">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="camera_model_d3_multi_clipping_interection_select"/>
         </explicit>
      </entity>
      <entity name="camera_model_d3_multi_clipping_union" supertypes="geometric_representation_item">
         <explicit name="shape_clipping">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="camera_model_d3_multi_clipping_union_select"/>
         </explicit>
      </entity>
      <entity name="camera_model_d3_with_hlhsr" supertypes="camera_model_d3">
         <explicit name="hidden_line_surface_removal">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="camera_model_with_light_sources" supertypes="camera_model_d3">
         <explicit name="sources">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="light_source"/>
         </explicit>
      </entity>
      <entity name="camera_usage" supertypes="representation_map">
         <explicit name="mapping_origin">
            <typename name="camera_model"/>
            <redeclaration entity-ref="representation_map"/>
         </explicit>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION'&#10;          IN TYPEOF(SELF\representation_map.mapped_representation))" label="WR1"/>
      </entity>
      <entity name="capacitance_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="capacitance_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.farad)" label="WR1"/>
      </entity>
      <entity name="cartesian_complex_number_region" supertypes="maths_space generic_literal">
         <explicit name="real_constraint">
            <typename name="real_interval"/>
         </explicit>
         <explicit name="imag_constraint">
            <typename name="real_interval"/>
         </explicit>
         <where expression="min_exists(real_constraint) OR max_exists(real_constraint) OR&#10;       min_exists(imag_constraint) OR max_exists(imag_constraint)" label="WR1"/>
      </entity>
      <entity name="cartesian_point" super.expression="ONEOF (cylindrical_point, polar_point, spherical_point)" supertypes="point">
         <explicit name="coordinates">
            <aggregate lower="1" type="LIST" upper="3"/>
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="cartesian_transformation_operator" super.expression="ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d)" supertypes="geometric_representation_item functionally_defined_transformation">
         <explicit name="axis1" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="axis2" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="local_origin">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="scale" optional="YES">
            <builtintype type="REAL"/>
         </explicit>
         <derived expression="NVL(scale, 1.0)" name="scl">
            <builtintype type="REAL"/>
         </derived>
         <where expression="scl &gt; 0.0" label="WR1"/>
      </entity>
      <entity name="cartesian_transformation_operator_2d" supertypes="cartesian_transformation_operator">
         <derived expression="base_axis(2,SELF\cartesian_transformation_operator.axis1,&#10;                   SELF\cartesian_transformation_operator.axis2,?)" name="u">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where expression="SELF\geometric_representation_item.dim = 2" label="WR1"/>
      </entity>
      <entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
         <explicit name="axis3" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived expression="base_axis(3,SELF\cartesian_transformation_operator.axis1,&#10;                        SELF\cartesian_transformation_operator.axis2,axis3)" name="u">
            <aggregate lower="3" type="LIST" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where expression="SELF\geometric_representation_item.dim = 3" label="WR1"/>
      </entity>
      <entity name="cc_design_approval" supertypes="approval_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="approved_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_certification" supertypes="certification_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="certified_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_contract" supertypes="contract_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="contracted_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_date_and_time_assignment" supertypes="date_and_time_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="date_time_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_person_and_organization_assignment" supertypes="person_and_organization_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="cc_person_organization_item"/>
         </explicit>
         <where expression="cc_design_person_and_organization_correlation(SELF)" label="WR1"/>
      </entity>
      <entity name="cc_design_security_classification" supertypes="security_classification_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="cc_classified_item"/>
         </explicit>
      </entity>
      <entity name="cc_design_specification_reference" supertypes="document_reference">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="cc_specified_item"/>
         </explicit>
      </entity>
      <entity name="cell" super.expression="ONEOF (cell_of_structured_mesh, vertex_defined_cell)" supertypes="topological_representation_item">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="dimension">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="cell_of_structured_mesh" supertypes="cell">
         <explicit name="the_mesh">
            <typename name="structured_mesh"/>
         </explicit>
         <explicit name="cell_identifier">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="the_mesh\mesh.index_count" name="index_count">
            <builtintype type="INTEGER"/>
         </derived>
      </entity>
      <entity name="celsius_temperature_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="centre_of_symmetry" supertypes="derived_shape_aspect">
         <where expression="SIZEOF&#10;        (QUERY(sadr&lt;*SELF\derived_shape_aspect.deriving_relationships|&#10;    NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRIC_SHAPE_ASPECT'&#10;     IN TYPEOF&#10;     (sadr\shape_aspect_relationship.related_shape_aspect))))=0" label="WR1"/>
      </entity>
      <entity name="certification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="certification_type"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="certification_assignment">
         <explicit name="assigned_certification">
            <typename name="certification"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="certification_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="change" supertypes="action_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="work_item"/>
         </explicit>
      </entity>
      <entity name="change_request" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="change_request_item"/>
         </explicit>
      </entity>
      <entity name="character_glyph_font_usage">
         <explicit name="character">
            <typename name="generic_character_glyph_symbol"/>
         </explicit>
         <explicit name="font">
            <typename name="text_font"/>
         </explicit>
      </entity>
      <entity name="character_glyph_style_outline" supertypes="founded_item">
         <explicit name="outline_style">
            <typename name="curve_style"/>
         </explicit>
      </entity>
      <entity name="character_glyph_style_stroke" supertypes="founded_item">
         <explicit name="stroke_style">
            <typename name="curve_style"/>
         </explicit>
      </entity>
      <entity name="character_glyph_symbol" supertypes="generic_character_glyph_symbol">
         <explicit name="character_box">
            <typename name="planar_extent"/>
         </explicit>
         <explicit name="baseline_ratio">
            <typename name="ratio_measure"/>
         </explicit>
         <derived expression="character_box.size_in_y" name="box_height">
            <typename name="length_measure"/>
         </derived>
         <where expression="{0.0 &lt;= baseline_ratio &lt;= 1.0}" label="WR1"/>
         <where expression="item_in_context(SELF.character_box, &#10;                       SELF\representation.context_of_items)" label="WR2"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE'&#10;        IN TYPEOF (SELF.box_height)" label="WR3"/>
      </entity>
      <entity name="character_glyph_symbol_outline" supertypes="character_glyph_symbol">
         <explicit name="outlines">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="annotation_fill_area"/>
         </explicit>
         <where expression="SELF.outlines &lt;= SELF\representation.items" label="WR1"/>
      </entity>
      <entity name="character_glyph_symbol_stroke" supertypes="character_glyph_symbol">
         <explicit name="strokes">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve"/>
         </explicit>
         <where expression="SELF.strokes &lt;= SELF\representation.items" label="WR1"/>
      </entity>
      <entity name="characteristic_data_column_header" supertypes="general_property"/>
      <entity name="characteristic_data_column_header_link" supertypes="general_property_relationship"/>
      <entity name="characteristic_data_table_header" supertypes="general_property"/>
      <entity name="characteristic_data_table_header_decomposition" supertypes="general_property_relationship"/>
      <entity name="characteristic_type" supertypes="group"/>
      <entity name="characterized_class" supertypes="characterized_object class"/>
      <entity name="characterized_object">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="circle" supertypes="conic">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="circular_runout_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 2" label="WR1"/>
      </entity>
      <entity name="class" supertypes="group"/>
      <entity name="class_by_extension" supertypes="class"/>
      <entity name="class_by_intension" supertypes="class"/>
      <entity name="class_system" supertypes="group"/>
      <entity name="class_usage_effectivity_context_assignment" supertypes="effectivity_context_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="class_usage_effectivity_context_item"/>
         </explicit>
         <where expression="SELF.role.name = 'class usage influence'" label="WR1"/>
         <where expression="SIZEOF( QUERY( i &lt;* SELF.items | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) )) = 0" label="WR2"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND &#10;        (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity) ) = 1) AND &#10;        (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND &#10;        (SIZEOF( QUERY( i &lt;* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | &#10;        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) = 0)" label="WR3"/>
      </entity>
      <entity abstract.supertype="YES" name="classification_assignment">
         <explicit name="assigned_class">
            <typename name="group"/>
         </explicit>
         <explicit name="role">
            <typename name="classification_role"/>
         </explicit>
      </entity>
      <entity name="classification_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="closed_shell" supertypes="connected_face_set"/>
      <entity name="coaxiality_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 2" label="WR1"/>
      </entity>
      <entity name="colour"/>
      <entity name="colour_rgb" supertypes="colour_specification">
         <explicit name="red">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="green">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="blue">
            <builtintype type="REAL"/>
         </explicit>
         <where expression="{0.0 &lt;= red &lt;= 1.0}" label="WR1"/>
         <where expression="{0.0 &lt;= green &lt;= 1.0}" label="WR2"/>
         <where expression="{0.0 &lt;= blue &lt;= 1.0}" label="WR3"/>
      </entity>
      <entity name="colour_specification" supertypes="colour">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="common_datum" supertypes="composite_shape_aspect datum">
         <where expression="SIZEOF (SELF\composite_shape_aspect.component_relationships) = 2" label="WR1"/>
         <where expression="SIZEOF (QUERY ( sar &lt;* SELF\composite_shape_aspect.component_relationships| &#10;                      NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM' IN TYPEOF (sar.related_shape_aspect)) AND &#10;                          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMMON_DATUM' IN TYPEOF (sar.related_shape_aspect))) )) = 0" label="WR2"/>
      </entity>
      <entity name="comparison_equal" supertypes="comparison_expression"/>
      <entity abstract.supertype="YES" name="comparison_expression" super.expression="ONEOF (comparison_equal, comparison_greater, comparison_greater_equal, comparison_less, comparison_less_equal, comparison_not_equal, like_expression)" supertypes="boolean_expression binary_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="expression"/>
            <redeclaration entity-ref="binary_generic_expression"/>
         </explicit>
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[1]))&#10;&#9;&#9;AND &#10;&#9;&#9; &#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[2]))) &#10;OR&#10; (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[1]))&#10;&#9;&#9;AND &#10;&#9;&#9; &#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_EXPRESSION' &#10;&#9;IN TYPEOF(SELF\binary_generic_expression.operands[2])))&#10;OR&#10;(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[1]))&#10;&#9;&#9;AND &#10;&#9;&#9; &#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;IN TYPEOF(SELF\binary_generic_expression.operands[2])))" label="WR1"/>
      </entity>
      <entity name="comparison_greater" supertypes="comparison_expression"/>
      <entity name="comparison_greater_equal" supertypes="comparison_expression"/>
      <entity name="comparison_less" supertypes="comparison_expression"/>
      <entity name="comparison_less_equal" supertypes="comparison_expression"/>
      <entity name="comparison_not_equal" supertypes="comparison_expression"/>
      <entity name="complex_clause" supertypes="compound_representation_item"/>
      <entity name="complex_conjunctive_clause" supertypes="complex_clause"/>
      <entity name="complex_disjunctive_clause" supertypes="complex_clause"/>
      <entity name="complex_number_literal" supertypes="generic_literal">
         <explicit name="real_part">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="imag_part">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="complex_shelled_solid" supertypes="shelled_solid">
         <explicit name="thickened_face_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face_surface"/>
         </explicit>
         <explicit name="thickness_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="length_measure"/>
         </explicit>
         <where expression="SIZEOF(thickened_face_list) = SIZEOF(thickness_list)" label="WR1"/>
         <where expression="SIZEOF(QUERY(q &lt;* thickness_list | (q = 0))) = 0" label="WR2"/>
      </entity>
      <entity name="composite_assembly_definition" supertypes="product_definition">
         <where expression="SIZEOF (QUERY (pdr &lt;* USEDIN (SELF, &#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;                             'RELATING_PRODUCT_DEFINITION') |&#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN&#10;                             TYPEOF (pdr))) = 1" label="WR1"/>
      </entity>
      <entity name="composite_assembly_sequence_definition" supertypes="product_definition">
         <where expression="SIZEOF (QUERY (pdr &lt;* USEDIN (SELF, &#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;                             'RELATING_PRODUCT_DEFINITION') |&#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN&#10;                             TYPEOF (pdr))) &gt; 0" label="WR1"/>
      </entity>
      <entity name="composite_assembly_table" supertypes="part_laminate_table"/>
      <entity name="composite_curve" supertypes="bounded_curve">
         <explicit name="segments">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="composite_curve_segment"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived expression="SIZEOF(segments)" name="n_segments">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="segments[n_segments].transition &lt;&gt; discontinuous" name="closed_curve">
            <builtintype type="LOGICAL"/>
         </derived>
         <where expression="((NOT closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments |&#10;                temp.transition = discontinuous)) = 1)) OR&#10;            ((closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | &#10;                temp.transition = discontinuous)) = 0))" label="WR1"/>
      </entity>
      <entity name="composite_curve_on_surface" super.expression="boundary_curve" supertypes="composite_curve">
         <derived expression="get_basis_surface(SELF)" name="basis_surface">
            <aggregate lower="0" type="SET" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where expression="SIZEOF(basis_surface) &gt; 0" label="WR1"/>
         <where expression="constraints_composite_curve_on_surface(SELF)" label="WR2"/>
      </entity>
      <entity name="composite_curve_segment" supertypes="founded_item">
         <explicit name="transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <inverse attribute="segments" entity="composite_curve" name="using_curves">
            <inverse.aggregate lower="1" type="BAG" upper="?"/>
         </inverse>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve))" label="WR1"/>
      </entity>
      <entity name="composite_material_designation" supertypes="material_designation"/>
      <entity name="composite_shape_aspect" supertypes="shape_aspect">
         <inverse attribute="relating_shape_aspect" entity="shape_aspect_relationship" name="component_relationships">
            <inverse.aggregate lower="2" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="composite_sheet_representation" supertypes="shape_representation">
         <where expression="SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'MANIFOLD_SURFACE_SHAPE_REPRESENTATION'] * TYPEOF (SELF)) = 1" label="WR1"/>
      </entity>
      <entity name="composite_text" supertypes="geometric_representation_item">
         <explicit name="collected_text">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="text_or_character"/>
         </explicit>
         <where expression="acyclic_composite_text( SELF, SELF.collected_text)" label="WR1"/>
      </entity>
      <entity name="composite_text_with_associated_curves" supertypes="composite_text">
         <explicit name="associated_curves">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve"/>
         </explicit>
      </entity>
      <entity name="composite_text_with_blanking_box" supertypes="composite_text">
         <explicit name="blanking">
            <typename name="planar_box"/>
         </explicit>
      </entity>
      <entity name="composite_text_with_delineation" supertypes="composite_text">
         <explicit name="delineation">
            <typename name="text_delineation"/>
         </explicit>
      </entity>
      <entity name="composite_text_with_extent" supertypes="composite_text">
         <explicit name="extent">
            <typename name="planar_extent"/>
         </explicit>
      </entity>
      <entity name="compound_maths_space_context" supertypes="maths_space_context">
         <explicit name="components">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="maths_space_context"/>
         </explicit>
      </entity>
      <entity name="compound_representation_item" super.expression="ONEOF (point_and_vector, point_path, row_representation_item, table_representation_item)" supertypes="representation_item">
         <explicit name="item_element">
            <typename name="compound_item_definition"/>
         </explicit>
      </entity>
      <entity name="compound_shape_representation" supertypes="shape_representation">
         <where expression="( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'GEOMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF ( SELF.context_of_items ) ) AND (&#10;        SELF.context_of_items\&#10;        geometric_representation_context.coordinate_space_dimension =3 )" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( cbsr_i &lt;* SELF.items | SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'EDGE_BASED_WIREFRAME_MODEL' ,&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'FACE_BASED_SURFACE_MODEL' ,&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MAPPED_ITEM' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;         'AXIS2_PLACEMENT_3D']* TYPEOF ( cbsr_i ) ) &lt;&gt;1 ) ) =0" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( cbsr_i &lt;* SELF.items | SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'EDGE_BASED_WIREFRAME_MODEL' ,&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'FACE_BASED_SURFACE_MODEL' ,&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MAPPED_ITEM']* TYPEOF ( cbsr_i ) ) =1 ) ) &gt;0" label="WR3"/>
         <where expression="SIZEOF ( QUERY ( cbsr_i &lt;* SELF.items | (&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MAPPED_ITEM' IN TYPEOF ( cbsr_i ) )&#10;         AND ( SIZEOF ( ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;         'COMPOUND_SHAPE_REPRESENTATION' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;         'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' ,&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;         'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION']* TYPEOF (&#10;         cbsr_i\ mapped_item.mapping_source ) ) &lt;&gt;1 ) ) ) =0" label="WR4"/>
      </entity>
      <entity name="concat_expression" supertypes="string_expression multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="string_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
      </entity>
      <entity name="concentricity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) = 1" label="WR1"/>
      </entity>
      <entity name="concept_feature_operator">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="concept_feature_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_concept_feature">
            <typename name="product_concept_feature"/>
         </explicit>
         <explicit name="related_product_concept_feature">
            <typename name="product_concept_feature"/>
         </explicit>
      </entity>
      <entity name="concept_feature_relationship_with_condition" supertypes="concept_feature_relationship">
         <explicit name="conditional_operator">
            <typename name="concept_feature_operator"/>
         </explicit>
      </entity>
      <entity name="conditional_concept_feature" supertypes="product_concept_feature">
         <explicit name="condition">
            <typename name="concept_feature_relationship_with_condition"/>
         </explicit>
      </entity>
      <entity name="conductance_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="conductance_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.siemens)" label="WR1"/>
      </entity>
      <entity name="configurable_item" supertypes="configuration_item">
         <explicit name="item_concept_feature">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="product_concept_feature_association"/>
         </explicit>
      </entity>
      <entity name="configuration_design">
         <explicit name="configuration">
            <typename name="configuration_item"/>
         </explicit>
         <explicit name="design">
            <typename name="configuration_design_item"/>
         </explicit>
         <derived expression="get_name_value (SELF)" name="name">
            <typename name="label"/>
         </derived>
         <derived expression="get_description_value (SELF)" name="description">
            <typename name="text"/>
         </derived>
         <unique label="UR1">
            <unique.attribute attribute="configuration"/>
            <unique.attribute attribute="design"/>
         </unique>
         <where expression="SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR1"/>
         <where expression="SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="configuration_effectivity" supertypes="product_definition_effectivity">
         <explicit name="configuration">
            <typename name="configuration_design"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="configuration"/>
            <unique.attribute attribute="usage" entity-ref="product_definition_effectivity"/>
            <unique.attribute attribute="id" entity-ref="effectivity"/>
         </unique>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_USAGE' IN&#10;        TYPEOF (SELF\product_definition_effectivity.usage)" label="WR1"/>
      </entity>
      <entity name="configuration_item">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="item_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="purpose" optional="YES">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="configuration_item_hierarchical_relationship" supertypes="configuration_item_relationship"/>
      <entity name="configuration_item_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_configuration_item">
            <typename name="configuration_item"/>
         </explicit>
         <explicit name="related_configuration_item">
            <typename name="configuration_item"/>
         </explicit>
      </entity>
      <entity name="configuration_item_revision_sequence" supertypes="configuration_item_relationship"/>
      <entity name="configured_effectivity_assignment" supertypes="effectivity_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="configured_effectivity_item"/>
         </explicit>
         <where expression="(SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity) ) = 1) &#10;&#9;AND (SELF.assigned_effectivity.id = 'configuration validity')" label="WR1"/>
         <where expression="SIZEOF(SELF.items) = 1" label="WR2"/>
         <where expression="SIZEOF( QUERY( i &lt;* SELF.items | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) &#10;&#9;OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']) )) = 0" label="WR3"/>
         <where expression="SELF.role.name IN ['design', 'usage']" label="WR4"/>
         <where expression="(SELF.role.name &lt;&gt; 'design') &#10;&#9;OR (SIZEOF( QUERY( i &lt;* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence') )) = 0)" label="WR5"/>
         <where expression="(SELF.role.name &lt;&gt; 'usage') OR (SIZEOF( QUERY( i &lt;* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition') )) = 0)" label="WR6"/>
         <where expression="SELF.role.description IN ['exception', 'inherited', 'local']" label="WR7"/>
         <where expression="SIZEOF( QUERY( x &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x) )) = 1" label="WR8"/>
      </entity>
      <entity name="configured_effectivity_context_assignment" supertypes="effectivity_context_assignment">
         <explicit name="assigned_effectivity_assignment">
            <typename name="configured_effectivity_assignment"/>
            <redeclaration entity-ref="effectivity_context_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="configured_effectivity_context_item"/>
         </explicit>
         <where expression="SIZEOF(SELF.items) = 1" label="WR1"/>
      </entity>
      <entity name="conic" super.expression="ONEOF (circle, ellipse, hyperbola, parabola)" supertypes="curve">
         <explicit name="position">
            <typename name="axis2_placement"/>
         </explicit>
      </entity>
      <entity name="conical_stepped_hole_transition" supertypes="geometric_representation_item">
         <explicit name="transition_number">
            <typename name="positive_integer"/>
         </explicit>
         <explicit name="cone_apex_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="cone_base_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="conical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="semi_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="radius &gt;= 0.0" label="WR1"/>
      </entity>
      <entity name="connected_edge_set" supertypes="topological_representation_item">
         <explicit name="ces_edges">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="edge"/>
         </explicit>
      </entity>
      <entity name="connected_face_set" super.expression="ONEOF (closed_shell, open_shell)" supertypes="topological_representation_item">
         <explicit name="cfs_faces">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face"/>
         </explicit>
      </entity>
      <entity name="connected_face_sub_set" supertypes="connected_face_set">
         <explicit name="parent_face_set">
            <typename name="connected_face_set"/>
         </explicit>
      </entity>
      <entity name="constant_function" supertypes="maths_function generic_literal">
         <explicit name="sole_output">
            <typename name="maths_value"/>
         </explicit>
         <explicit name="source_of_domain">
            <typename name="maths_space_or_function"/>
         </explicit>
         <where expression="no_cyclic_domain_reference(source_of_domain, [SELF])" label="WR1"/>
         <where expression="expression_is_constant(domain_from(source_of_domain))" label="WR2"/>
      </entity>
      <entity name="constant_surface_3d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="axis">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(axis &gt;= 1) AND (axis &lt;= 2)" label="WR1"/>
      </entity>
      <entity name="constraint_element" super.expression="ONEOF (single_point_constraint_element, linear_constraint_equation_element, nodal_dof_reduction, point_constraint, curve_constraint, surface_constraint, solid_constraint)">
         <explicit name="element_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="steps">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="control_analysis_step"/>
         </explicit>
      </entity>
      <entity name="constructive_geometry_representation" supertypes="representation">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 &lt;= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension &lt;= 3})" label="WR1"/>
         <where expression="SIZEOF( QUERY( cgr_i &lt;* SELF.items | SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLACEMENT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT'] * TYPEOF(cgr_i)) &lt;&gt; 1 )) = 0" label="WR2"/>
         <where expression="SIZEOF( USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) &gt; 0" label="WR3"/>
         <where expression="SIZEOF( USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0" label="WR4"/>
      </entity>
      <entity name="constructive_geometry_representation_relationship" supertypes="representation_relationship">
         <explicit name="rep_1">
            <typename name="constructive_geometry_representation_or_shape_represenation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="constructive_geometry_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <where expression="(SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items))" label="WR1"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF))" label="WR2"/>
      </entity>
      <entity name="contact_ratio_representation" supertypes="representation">
         <where expression="( SIZEOF ( SELF.items ) =1 ) AND ( SIZEOF ( QUERY ( i &lt;*&#10;        SELF.items | ( SIZEOF ( ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'MEASURE_REPRESENTATION_ITEM' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) AND ( i.name =&#10;        'ratio value' ) ) ) =1 )" label="WR1"/>
         <where expression="( SIZEOF ( QUERY ( pdr &lt;* USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) | pdr. name =&#10;        'contact ratio reference' ) ) =1 ) AND ( SIZEOF ( QUERY (&#10;        pdr &lt;* USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) | ( pdr. name =&#10;        'contact ratio reference' ) AND ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'PRODUCT_DEFINITION' IN TYPEOF ( pdr.&#10;        definition.definition ) ) ) ) =1 )" label="WR2"/>
         <where expression="( SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr&#10;        &lt;* USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa &lt;* USEDIN (&#10;        pdr. definition ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+&#10;        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND&#10;        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )&#10;        ) =1 )" label="WR3"/>
      </entity>
      <entity name="context_dependent_invisibility" supertypes="invisibility">
         <explicit name="presentation_context">
            <typename name="invisibility_context"/>
         </explicit>
      </entity>
      <entity name="context_dependent_over_riding_styled_item" supertypes="over_riding_styled_item">
         <explicit name="style_context">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="style_context_select"/>
         </explicit>
         <where expression="(SIZEOF(QUERY(sc &lt;* SELF.style_context | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(sc)))= 1) OR&#10;(SIZEOF(QUERY(sc &lt;* SELF.style_context |&#10;     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(sc))&#10;  OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_RELATIONSHIP' IN TYPEOF(sc)) ))&#10;  = SIZEOF(style_context))" label="WR1"/>
      </entity>
      <entity name="context_dependent_shape_representation">
         <explicit name="representation_relation">
            <typename name="shape_representation_relationship"/>
         </explicit>
         <explicit name="represented_product_relation">
            <typename name="product_definition_shape"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition)" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR2"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR3"/>
      </entity>
      <entity name="context_dependent_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="contract">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="contract_type"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="contract_assignment">
         <explicit name="assigned_contract">
            <typename name="contract"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="contract_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_contract">
            <typename name="contract"/>
         </explicit>
         <explicit name="related_contract">
            <typename name="contract"/>
         </explicit>
      </entity>
      <entity name="contract_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="control">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="control_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="creating_software">
            <typename name="text"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="user_defined_control">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="text"/>
         </explicit>
         <explicit name="intended_analysis_code">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="control_id"/>
         </unique>
      </entity>
      <entity name="control_analysis_step" super.expression="ONEOF (control_linear_static_analysis_step, control_linear_modes_and_frequencies_analysis_step)" supertypes="analysis_step">
         <explicit name="step_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="sequence">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="initial_state">
            <typename name="state"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="analysis_control" entity-ref="analysis_step"/>
            <unique.attribute attribute="sequence"/>
         </unique>
         <unique label="UR2">
            <unique.attribute attribute="analysis_control" entity-ref="analysis_step"/>
            <unique.attribute attribute="step_id"/>
         </unique>
      </entity>
      <entity name="control_linear_modes_and_frequencies_analysis_step" supertypes="control_analysis_step">
         <explicit name="process">
            <typename name="control_linear_modes_and_frequencies_process"/>
         </explicit>
         <explicit name="number_of_modes">
            <typename name="count_measure"/>
         </explicit>
         <explicit name="frequency_range">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="control_linear_modes_and_frequencies_process" supertypes="control_process">
         <explicit name="final_input_state">
            <typename name="state"/>
         </explicit>
      </entity>
      <entity name="control_linear_static_analysis_step" supertypes="control_analysis_step">
         <explicit name="process">
            <typename name="control_linear_static_load_increment_process"/>
         </explicit>
      </entity>
      <entity name="control_linear_static_analysis_step_with_harmonic" supertypes="control_linear_static_analysis_step">
         <explicit name="symmetry">
            <typename name="cylindrical_symmetry_control"/>
         </explicit>
      </entity>
      <entity name="control_linear_static_load_increment_process" supertypes="control_process">
         <explicit name="final_input_state">
            <typename name="state"/>
         </explicit>
      </entity>
      <entity name="control_process" super.expression="ONEOF (control_linear_static_load_increment_process, control_linear_modes_and_frequencies_process)">
         <explicit name="process_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="control_result_relationship">
         <explicit name="control">
            <typename name="control_analysis_step"/>
         </explicit>
         <explicit name="result">
            <typename name="result_analysis_step"/>
         </explicit>
      </entity>
      <entity name="conversion_based_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="conversion_factor">
            <typename name="measure_with_unit"/>
         </explicit>
         <where expression="SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="coordinated_universal_time_offset">
         <explicit name="hour_offset">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="minute_offset" optional="YES">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="sense">
            <typename name="ahead_or_behind"/>
         </explicit>
         <derived expression="NVL(minute_offset,0)" name="actual_minute_offset">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="{ 0 &lt;= hour_offset &lt; 24 }" label="WR1"/>
         <where expression="{ 0 &lt;= actual_minute_offset &lt;= 59 }" label="WR2"/>
         <where expression="NOT (((hour_offset &lt;&gt; 0) OR (actual_minute_offset &lt;&gt;0)) AND (sense = exact))" label="WR3"/>
      </entity>
      <entity name="cos_function" supertypes="unary_function_call"/>
      <entity name="csg_shape_representation" supertypes="shape_representation">
         <where expression="SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CSG_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_REPLICA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REVOLVED_FACE_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXTRUDED_FACE_SOLID' ] * TYPEOF (it)) &lt;&gt; 1) )) = 0" label="WR2"/>
         <where expression="SIZEOF ( &#10;QUERY ( mi &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CSG_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0" label="WR3"/>
         <where expression="SIZEOF ( &#10;QUERY ( sr &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_REPLICA' IN TYPEOF (it)) )| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CSG_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REVOLVED_FACE_SOLID', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXTRUDED_FACE_SOLID' ] * TYPEOF (sr\solid_replica.parent_solid)) = 0) )) = 0" label="WR4"/>
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF (it)) )) &gt; 0" label="WR5"/>
      </entity>
      <entity name="csg_solid" supertypes="solid_model">
         <explicit name="tree_root_expression">
            <typename name="csg_select"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="currency" super.expression="ONEOF (externally_defined_currency, iso4217_currency)" supertypes="context_dependent_unit">
         <where expression="((SELF\named_unit.dimensions.length_exponent = 0.0) AND&#10;           (SELF\named_unit.dimensions.mass_exponent = 0.0) AND&#10;           (SELF\named_unit.dimensions.time_exponent = 0.0) AND&#10;           (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND&#10;           (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND&#10;           (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND&#10;           (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0))" label="WR1"/>
      </entity>
      <entity name="currency_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="currency"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="curve" super.expression="ONEOF (line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica)" supertypes="geometric_representation_item"/>
      <entity name="curve_2d_element_basis">
         <explicit name="descriptor">
            <typename name="curve_2d_element_descriptor"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
      </entity>
      <entity name="curve_2d_element_constant_specified_variable_value" supertypes="curve_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_2d_element_constant_specified_volume_variable_value" supertypes="curve_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_2d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <where expression="SELF\geometric_representation_item.dim=2" label="WR1"/>
      </entity>
      <entity name="curve_2d_element_field_variable_definition" super.expression="ONEOF (curve_2d_element_location_point_volume_variable_values, curve_2d_element_location_point_variable_values, curve_2d_whole_element_variable_value, curve_2d_element_constant_specified_variable_value, curve_2d_element_constant_specified_volume_variable_value)" supertypes="field_variable_element_definition">
         <explicit name="element">
            <typename name="curve_2d_element_output_reference"/>
         </explicit>
      </entity>
      <entity name="curve_2d_element_group" supertypes="element_group">
         <where expression="SIZEOF(QUERY(item &lt;* elements |&#10;       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;             'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION'&#10;              IN TYPEOF(item)) AND&#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;             'PLANE_CURVE_2D_ELEMENT_REPRESENTATION'&#10;              IN TYPEOF(item)))))=0" label="WR1"/>
      </entity>
      <entity name="curve_2d_element_integrated_matrix">
         <explicit name="descriptor">
            <typename name="curve_2d_element_descriptor"/>
         </explicit>
         <explicit name="property_type">
            <typename name="curve_matrix_property_type"/>
         </explicit>
         <explicit name="integration_description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="curve_2d_element_integrated_matrix_with_definition" supertypes="curve_2d_element_integrated_matrix">
         <explicit name="integration_definition">
            <typename name="curve_2d_element_integration"/>
         </explicit>
      </entity>
      <entity name="curve_2d_element_integration">
         <explicit name="section">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="curve_section_element_location"/>
         </explicit>
      </entity>
      <entity name="curve_2d_element_location_point_variable_values" supertypes="curve_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_2d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="curve_2d_element_location_point_volume_variable_values" supertypes="curve_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_2d_element_value_and_volume_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="curve_2d_element_property">
         <explicit name="property_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="section">
            <typename name="curve_element_section_definition"/>
         </explicit>
      </entity>
      <entity name="curve_2d_element_value_and_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="curve_section_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="curve_2d_element_value_and_volume_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="curve_volume_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="curve_2d_node_field_aggregated_variable_values" supertypes="curve_2d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_2d_node_field_section_variable_values" supertypes="curve_2d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <explicit name="location">
            <typename name="curve_section_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_2d_node_field_variable_definition" super.expression="ONEOF (curve_2d_node_field_section_variable_values, curve_2d_node_field_aggregated_variable_values)" supertypes="field_variable_node_definition"/>
      <entity name="curve_2d_substructure_element_reference">
         <explicit name="substructure_element_ref">
            <typename name="substructure_element_representation"/>
         </explicit>
         <explicit name="element_ref">
            <typename name="curve_2d_element_representation"/>
         </explicit>
      </entity>
      <entity name="curve_2d_whole_element_variable_value" supertypes="curve_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_3d_element_basis">
         <explicit name="descriptor">
            <typename name="curve_3d_element_descriptor"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <explicit name="variable_order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="variable_shape_function">
            <typename name="shape_function"/>
         </explicit>
         <explicit name="evaluation_points">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="curve_element_location"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_constant_specified_variable_value" supertypes="curve_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_3d_element_constant_specified_volume_variable_value" supertypes="curve_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_3d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_element_purpose"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_field_variable_definition" super.expression="ONEOF (curve_3d_element_location_point_volume_variable_values, curve_3d_element_location_point_variable_values, curve_3d_whole_element_variable_value, curve_3d_element_constant_specified_variable_value, curve_3d_element_constant_specified_volume_variable_value, curve_3d_element_nodal_specified_variable_values)" supertypes="field_variable_element_definition">
         <explicit name="element">
            <typename name="curve_3d_element_output_reference"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_group" supertypes="element_group">
         <where expression="SIZEOF(query(item &lt;* elements |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;            'CURVE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0" label="WR1"/>
      </entity>
      <entity name="curve_3d_element_integrated_matrix">
         <explicit name="descriptor">
            <typename name="curve_3d_element_descriptor"/>
         </explicit>
         <explicit name="property_type">
            <typename name="curve_matrix_property_type"/>
         </explicit>
         <explicit name="integration_description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_integrated_matrix_with_definition" supertypes="curve_3d_element_integrated_matrix">
         <explicit name="integration_definition">
            <typename name="curve_3d_element_integration"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_integration">
         <explicit name="element_length">
            <typename name="curve_3d_element_length_integration"/>
         </explicit>
         <explicit name="section">
            <typename name="curve_section_integration_explicit"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_length_integration_explicit">
         <explicit name="integration_positions_and_weights">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_3d_element_position_weight"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_length_integration_rule">
         <explicit name="integration_method">
            <typename name="integration_rule"/>
         </explicit>
         <explicit name="integration_order">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_location_point_variable_values" supertypes="curve_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_3d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="curve_3d_element_location_point_volume_variable_values" supertypes="curve_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_3d_element_value_and_volume_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="curve_3d_element_nodal_specified_variable_values" supertypes="curve_3d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="curve_3d_element_position_weight">
         <explicit name="integration_position">
            <typename name="curve_volume_element_location"/>
         </explicit>
         <explicit name="integration_weight">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_property">
         <explicit name="property_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="interval_definitions">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="curve_element_interval"/>
         </explicit>
         <explicit name="end_offsets">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="curve_element_end_offset"/>
         </explicit>
         <explicit name="end_releases">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="curve_element_end_release"/>
         </explicit>
      </entity>
      <entity name="curve_3d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_3d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="curve_3d_element_descriptor"/>
         </explicit>
         <explicit name="property">
            <typename name="curve_3d_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'PARAMETRIC_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'ALIGNED_CURVE_3D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) = 1" label="WR1"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR2"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR3"/>
         <where expression="required_1d_nodes (&#10;        SELF\element_representation.node_list,&#10;        element_descriptor\element_descriptor.topology_order)" label="FU1"/>
      </entity>
      <entity name="curve_3d_element_value_and_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="curve_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="curve_3d_element_value_and_volume_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="curve_volume_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="curve_3d_node_field_aggregated_variable_values" supertypes="curve_3d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_3d_node_field_section_variable_values" supertypes="curve_3d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="curve_element_variable"/>
         </explicit>
         <explicit name="location">
            <typename name="curve_section_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_3d_node_field_variable_definition" super.expression="ONEOF (curve_3d_node_field_section_variable_values, curve_3d_node_field_aggregated_variable_values)" supertypes="field_variable_node_definition"/>
      <entity name="curve_3d_substructure_element_reference">
         <explicit name="substructure_element_ref">
            <typename name="substructure_element_representation"/>
         </explicit>
         <explicit name="element_ref">
            <typename name="curve_3d_element_representation"/>
         </explicit>
      </entity>
      <entity name="curve_3d_whole_element_variable_value" supertypes="curve_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="curve_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="curve_bounded_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="boundary_curve"/>
         </explicit>
         <explicit name="implicit_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where expression="(NOT implicit_outer) OR&#10;         (SIZEOF (QUERY (temp &lt;* boundaries |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0)" label="WR1"/>
         <where expression="(NOT(implicit_outer)) OR&#10;                ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface))" label="WR2"/>
         <where expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OUTER_BOUNDARY_CURVE' IN&#10;                                         TYPEOF(temp))) &lt;= 1" label="WR3"/>
         <where expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;            (temp\composite_curve_on_surface.basis_surface [1] &lt;&gt;&#10;                                         SELF.basis_surface))) = 0" label="WR4"/>
      </entity>
      <entity name="curve_constraint" supertypes="constraint_element">
         <explicit name="required_curve">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="freedoms_and_coefficients">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="freedom_and_coefficient"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (required_curve.item)) OR&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (required_curve.item))" label="WR1"/>
      </entity>
      <entity name="curve_dimension" supertypes="dimension_curve_directed_callout"/>
      <entity name="curve_element_end_offset">
         <explicit name="coordinate_system">
            <typename name="curve_element_end_coordinate_system"/>
         </explicit>
         <explicit name="offset_vector">
            <aggregate lower="1" type="ARRAY" upper="3"/>
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="curve_element_end_release">
         <explicit name="coordinate_system">
            <typename name="curve_element_end_coordinate_system"/>
         </explicit>
         <explicit name="releases">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="curve_element_end_release_packet"/>
         </explicit>
      </entity>
      <entity name="curve_element_end_release_packet">
         <explicit name="release_freedom">
            <typename name="curve_element_freedom"/>
         </explicit>
         <explicit name="release_stiffness">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="curve_element_interval" super.expression="ONEOF (curve_element_interval_constant, curve_element_interval_linearly_varying)">
         <explicit name="finish_position">
            <typename name="curve_element_location"/>
         </explicit>
         <explicit name="eu_angles">
            <typename name="euler_angles"/>
         </explicit>
      </entity>
      <entity name="curve_element_interval_constant" supertypes="curve_element_interval">
         <explicit name="section">
            <typename name="curve_element_section_definition"/>
         </explicit>
      </entity>
      <entity name="curve_element_interval_linearly_varying" supertypes="curve_element_interval">
         <explicit name="sections">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="curve_element_section_definition"/>
         </explicit>
      </entity>
      <entity name="curve_element_location">
         <explicit name="coordinate">
            <typename name="fea_parametric_point"/>
         </explicit>
      </entity>
      <entity name="curve_element_section_definition" super.expression="curve_element_section_derived_definitions">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="section_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="curve_element_section_derived_definitions" supertypes="curve_element_section_definition">
         <explicit name="cross_sectional_area">
            <typename name="context_dependent_measure"/>
         </explicit>
         <explicit name="shear_area">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="second_moment_of_area">
            <aggregate lower="1" type="ARRAY" upper="3"/>
            <typename name="context_dependent_measure"/>
         </explicit>
         <explicit name="torsional_constant">
            <typename name="context_dependent_measure"/>
         </explicit>
         <explicit name="warping_constant">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="location_of_centroid">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="location_of_shear_centre">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="location_of_non_structural_mass">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="non_structural_mass">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="polar_moment">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
      </entity>
      <entity name="curve_freedom_action_definition" supertypes="curve_freedom_and_value_definition">
         <explicit name="action">
            <typename name="action_type"/>
         </explicit>
      </entity>
      <entity name="curve_freedom_and_value_definition" super.expression="ONEOF (curve_freedom_values, curve_freedom_action_definition)" supertypes="state_definition">
         <explicit name="required_curve">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="degrees_of_freedom">
            <typename name="freedoms_list"/>
         </explicit>
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <where expression="SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values)" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (required_curve.item)) OR&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (required_curve.item))" label="WR2"/>
      </entity>
      <entity name="curve_freedom_values" supertypes="curve_freedom_and_value_definition"/>
      <entity name="curve_replica" supertypes="curve">
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where expression="transformation.dim = parent_curve.dim" label="WR1"/>
         <where expression="acyclic_curve_replica (SELF, parent_curve)" label="WR2"/>
      </entity>
      <entity name="curve_section_element_location">
         <explicit name="offsets">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="curve_section_integration_explicit">
         <explicit name="integration_positions">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_section_element_location"/>
         </explicit>
      </entity>
      <entity name="curve_style" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="curve_font">
            <typename name="curve_font_or_scaled_curve_font_select"/>
         </explicit>
         <explicit name="curve_width">
            <typename name="size_select"/>
         </explicit>
         <explicit name="curve_colour">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="curve_style_font" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="pattern_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="curve_style_font_pattern"/>
         </explicit>
      </entity>
      <entity name="curve_style_font_and_scaling" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="curve_font">
            <typename name="curve_style_font_select"/>
         </explicit>
         <explicit name="curve_font_scaling">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="curve_style_font_pattern" supertypes="founded_item">
         <explicit name="visible_segment_length">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="invisible_segment_length">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="curve_style_rendering">
         <explicit name="rendering_method">
            <typename name="shading_curve_method"/>
         </explicit>
         <explicit name="rendering_properties">
            <typename name="surface_rendering_properties"/>
         </explicit>
      </entity>
      <entity name="curve_swept_solid_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;          NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_AREA_SOLID',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_DISK_SOLID',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] *&#10;                   TYPEOF(it)) = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;         SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_AREA_SOLID',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_DISK_SOLID',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) =1 )) &gt; 0" label="WR2"/>
         <where expression="SIZEOF (QUERY (mi &lt;*  QUERY (it &lt;* items |&#10;                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) |&#10;   NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN&#10;             TYPEOF(mi\mapped_item.mapping_source.&#10;                           mapped_representation)))) = 0" label="WR3"/>
         <where expression="SIZEOF (QUERY (scsas &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE_SWEPT_AREA_SOLID' IN&#10;              TYPEOF(it)) |&#10;          NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN&#10;                 TYPEOF(scsas\surface_curve_swept_area_solid.directrix)) OR&#10;                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN&#10;                   TYPEOF(scsas\surface_curve_swept_area_solid.directrix))))) = 0" label="WR4"/>
      </entity>
      <entity name="curve_volume_element_location">
         <explicit name="field_location">
            <typename name="curve_element_location"/>
         </explicit>
         <explicit name="section_location">
            <typename name="curve_section_element_location"/>
         </explicit>
      </entity>
      <entity name="cylindrical_point" supertypes="cartesian_point">
         <explicit name="r">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="theta">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="length_measure"/>
         </explicit>
         <derived expression="[r*cos(theta), r*sin(theta), z]" name="coordinates">
            <aggregate lower="1" type="LIST" upper="3"/>
            <typename name="length_measure"/>
            <redeclaration entity-ref="cartesian_point"/>
         </derived>
         <where expression="r &gt;= 0.0" label="WR1"/>
      </entity>
      <entity name="cylindrical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="cylindrical_symmetry_control" supertypes="symmetry_control">
         <explicit name="harmonic">
            <typename name="cylindrical_harmonic_number"/>
         </explicit>
         <explicit name="phase">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
      </entity>
      <entity name="cylindricity_tolerance" supertypes="geometric_tolerance">
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))" label="WR1"/>
      </entity>
      <entity name="data_environment">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="elements">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="property_definition_representation"/>
         </explicit>
      </entity>
      <entity name="date" super.expression="ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date, year_month)">
         <explicit name="year_component">
            <typename name="year_number"/>
         </explicit>
      </entity>
      <entity name="date_and_time">
         <explicit name="date_component">
            <typename name="date"/>
         </explicit>
         <explicit name="time_component">
            <typename name="local_time"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="date_and_time_assignment">
         <explicit name="assigned_date_and_time">
            <typename name="date_and_time"/>
         </explicit>
         <explicit name="role">
            <typename name="date_time_role"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="date_assignment">
         <explicit name="assigned_date">
            <typename name="date"/>
         </explicit>
         <explicit name="role">
            <typename name="date_role"/>
         </explicit>
      </entity>
      <entity name="date_representation_item" supertypes="representation_item date"/>
      <entity name="date_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value (SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="date_time_representation_item" supertypes="representation_item date_and_time"/>
      <entity name="date_time_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value (SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="dated_effectivity" supertypes="effectivity">
         <explicit name="effectivity_end_date" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="effectivity_start_date">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
      </entity>
      <entity name="datum" supertypes="shape_aspect">
         <explicit name="identification">
            <typename name="identifier"/>
         </explicit>
         <inverse attribute="related_shape_aspect" entity="shape_aspect_relationship" name="established_by_relationships">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMMON_DATUM' IN TYPEOF(SELF)) XOR&#10;       ((SIZEOF(QUERY(x &lt;* SELF\datum.established_by_relationships |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_FEATURE' IN TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)))) = 1) XOR&#10;       (SIZEOF(QUERY(x &lt;* SELF\datum.established_by_relationships |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_TARGET' IN TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)))) &gt;= 1))" label="WR1"/>
      </entity>
      <entity name="datum_feature" supertypes="shape_aspect">
         <inverse attribute="relating_shape_aspect" entity="shape_aspect_relationship" name="feature_basis_relationship">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="SIZEOF(QUERY(sar &lt;* SELF\datum_feature.feature_basis_relationship &#10;       | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM' IN TYPEOF&#10;       (sar\shape_aspect_relationship.related_shape_aspect)))) = 1" label="WR1"/>
         <where expression="SELF\shape_aspect.product_definitional = TRUE" label="WR2"/>
      </entity>
      <entity name="datum_feature_callout" supertypes="draughting_callout"/>
      <entity name="datum_reference">
         <explicit name="precedence">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="referenced_datum">
            <typename name="datum"/>
         </explicit>
         <where expression="precedence &gt; 0" label="WR1"/>
      </entity>
      <entity name="datum_target" supertypes="shape_aspect">
         <explicit name="target_id">
            <typename name="identifier"/>
         </explicit>
         <inverse attribute="relating_shape_aspect" entity="shape_aspect_relationship" name="target_basis_relationship">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="SIZEOF(QUERY(sar &lt;* SELF\datum_target.target_basis_relationship &#10;       | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM' IN TYPEOF&#10;       (sar\shape_aspect_relationship.related_shape_aspect)))) = 1" label="WR1"/>
         <where expression="SELF\shape_aspect.product_definitional = TRUE" label="WR2"/>
      </entity>
      <entity name="datum_target_callout" supertypes="draughting_callout"/>
      <entity name="default_tolerance_table" supertypes="representation">
         <where expression="SIZEOF( QUERY( i &lt;* SELF.items | NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEFAULT_TOLERANCE_TABLE_CELL' IN TYPEOF(i)) )) = 0" label="WR1"/>
         <where expression="(SIZEOF( QUERY( rr &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | rr.name &lt; 'general tolerance definition' )) = 0) AND (SIZEOF( QUERY( rr &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name = 'general tolerance definition') AND (rr.rep_2.name &lt; 'default tolerance') )) = 0) AND (SIZEOF( USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) = 0)" label="WR2"/>
      </entity>
      <entity name="default_tolerance_table_cell" supertypes="compound_representation_item">
         <where expression="SIZEOF(QUERY( x &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS') | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DEFAULT_TOLERANCE_TABLE' IN TYPEOF(x)))=1" label="WR1"/>
         <where expression="default_tolerance_table_cell_wr2(SELF\compound_representation_item.item_element)" label="WR2"/>
         <where expression="default_tolerance_table_cell_wr3(SELF\compound_representation_item.item_element)" label="WR3"/>
         <where expression="default_tolerance_table_cell_wr4(SELF\compound_representation_item.item_element)" label="WR4"/>
         <where expression="default_tolerance_table_cell_wr5(SELF\compound_representation_item.item_element)" label="WR5"/>
      </entity>
      <entity abstract.supertype="YES" name="defined_function" super.expression="ONEOF (numeric_defined_function, string_defined_function, boolean_defined_function) ANDOR SQL_mappable_defined_function"/>
      <entity name="defined_maths_space_context" supertypes="maths_space_context"/>
      <entity name="defined_symbol" supertypes="geometric_representation_item">
         <explicit name="definition">
            <typename name="defined_symbol_select"/>
         </explicit>
         <explicit name="target">
            <typename name="symbol_target"/>
         </explicit>
      </entity>
      <entity name="definite_integral_expression" supertypes="quantifier_expression">
         <explicit name="lower_limit_neg_infinity">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="upper_limit_pos_infinity">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="SELF\multiple_arity_generic_expression.operands[1]" name="integrand">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[2]" name="variable_of_integration">
            <typename name="maths_variable"/>
         </derived>
         <derived expression="[variable_of_integration]" name="variables">
            <aggregate lower="1" type="LIST" unique="YES" upper="1"/>
            <typename name="generic_variable"/>
            <redeclaration entity-ref="quantifier_expression"/>
         </derived>
         <where expression="has_values_space (integrand)" label="WR1"/>
         <where expression="space_is_continuum (values_space_of (integrand))" label="WR2"/>
         <where expression="definite_integral_expr_check (SELF\multiple_arity_generic_expression.operands,&#10;    lower_limit_neg_infinity, upper_limit_pos_infinity)" label="WR3"/>
      </entity>
      <entity name="definite_integral_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="variable_of_integration">
            <typename name="input_selector"/>
         </explicit>
         <explicit name="lower_limit_neg_infinity">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="upper_limit_pos_infinity">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="integrand">
            <typename name="maths_function"/>
         </derived>
         <where expression="space_is_continuum (integrand.range)" label="WR1"/>
         <where expression="definite_integral_check (integrand.domain, variable_of_integration,&#10;    lower_limit_neg_infinity, upper_limit_pos_infinity)" label="WR2"/>
      </entity>
      <entity name="definitional_representation" supertypes="representation">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN&#10;          TYPEOF (SELF\representation.context_of_items )" label="WR1"/>
      </entity>
      <entity name="definitional_representation_relationship" supertypes="representation_relationship">
         <where expression="acyclic_representation_relationship(SELF,&#10;         [SELF\representation_relationship.rep_2],&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION')" label="WR1"/>
      </entity>
      <entity name="definitional_representation_relationship_with_same_context" supertypes="definitional_representation_relationship">
         <where expression="SELF\representation_relationship.rep_1.context_of_items :=: &#10;            SELF\representation_relationship.rep_2.context_of_items" label="WR1"/>
      </entity>
      <entity name="degenerate_pcurve" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where expression="SIZEOF(reference_to_curve\representation.items) = 1" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])" label="WR2"/>
         <where expression="reference_to_curve\representation.&#10;                   items[1]\geometric_representation_item.dim =2" label="WR3"/>
      </entity>
      <entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
         <explicit name="select_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where expression="major_radius &lt;   minor_radius" label="WR1"/>
      </entity>
      <entity name="dependent_variable_definition" supertypes="unary_generic_expression">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="derived_shape_aspect" super.expression="ONEOF (apex, centre_of_symmetry, geometric_alignment, geometric_intersection, parallel_offset, perpendicular_to, extension, tangent)" supertypes="shape_aspect">
         <inverse attribute="relating_shape_aspect" entity="shape_aspect_relationship" name="deriving_relationships">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="SIZEOF (QUERY (dr &lt;*&#10;          SELF\derived_shape_aspect.deriving_relationships |&#10;          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;               'SHAPE_ASPECT_DERIVING_RELATIONSHIP'&#10;          IN TYPEOF (dr)))) = 0" label="WR1"/>
      </entity>
      <entity name="derived_unit" super.expression="ONEOF (absorbed_dose_unit, acceleration_unit, radioactivity_unit, area_unit, capacitance_unit, dose_equivalent_unit, electric_charge_unit, conductance_unit, electric_potential_unit, energy_unit, magnetic_flux_density_unit, force_unit, frequency_unit, illuminance_unit, inductance_unit, magnetic_flux_unit, power_unit, pressure_unit, resistance_unit, velocity_unit, volume_unit)">
         <explicit name="elements">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="derived_unit_element"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="(SIZEOF(elements) &gt; 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent &lt;&gt; 1.0))" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="derived_unit_element">
         <explicit name="unit">
            <typename name="named_unit"/>
         </explicit>
         <explicit name="exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="description_attribute">
         <explicit name="attribute_value">
            <typename name="text"/>
         </explicit>
         <explicit name="described_item">
            <typename name="description_attribute_select"/>
         </explicit>
      </entity>
      <entity name="descriptive_representation_item" super.expression="ONEOF (tagged_text_item, uniform_resource_identifier)" supertypes="representation_item">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="design_context" supertypes="product_definition_context">
         <where expression="SELF.life_cycle_stage = 'design'" label="WR1"/>
      </entity>
      <entity name="design_make_from_relationship" supertypes="product_definition_relationship"/>
      <entity name="diameter_dimension" supertypes="dimension_curve_directed_callout"/>
      <entity name="dielectric_constant_measure_with_unit" supertypes="ratio_measure_with_unit"/>
      <entity name="dimension_callout" supertypes="draughting_callout">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT'&#10;        IN (TYPEOF (SELF))) XOR&#10;       (SIZEOF (QUERY(dce_1 &lt;* SELF\draughting_callout.contents |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE'&#10;        IN (TYPEOF(dce_1))))) = 0)" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT'&#10;        IN (TYPEOF (SELF))) XOR&#10;       (SIZEOF (QUERY(dce_1 &lt;* SELF\draughting_callout.contents |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE'&#10;        IN (TYPEOF(dce_1))))) = 0)" label="WR2"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'&#10;        IN (TYPEOF (SELF))) XOR&#10;       (SIZEOF (QUERY(dce_1 &lt;* SELF\draughting_callout.contents |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE'&#10;        IN (TYPEOF(dce_1))))) = 0)" label="WR3"/>
      </entity>
      <entity name="dimension_callout_component_relationship" supertypes="draughting_callout_relationship">
         <where expression="SELF.name IN ['prefix', 'suffix']" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_DIMENSION_CALLOUT'&#10;           IN TYPEOF (SELF.relating_draughting_callout)" label="WR2"/>
         <where expression="SIZEOF (TYPEOF (SELF.related_draughting_callout) *&#10;       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_DIMENSION_CALLOUT']) = 0" label="WR3"/>
         <where expression="SELF.related_draughting_callout.contents *&#10;       SELF.relating_draughting_callout.contents =&#10;       SELF.related_draughting_callout.contents" label="WR4"/>
         <where expression="((SELF.name = 'prefix') AND&#10;       (SIZEOF (QUERY (ato &lt;* QUERY (con &lt;*&#10;                 SELF.related_draughting_callout.contents |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF(con))) |&#10;         NOT (ato.name = 'prefix text')&#10;       )) = 0))" label="WR5"/>
         <where expression="((SELF.name = 'suffix') AND&#10;       (SIZEOF (QUERY (ato &lt;* QUERY (con &lt;*&#10;                 SELF.related_draughting_callout.contents |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF(con))) |&#10;         NOT (ato.name = 'suffix text')&#10;       )) = 0))" label="WR6"/>
      </entity>
      <entity name="dimension_callout_relationship" supertypes="draughting_callout_relationship">
         <where expression="SELF.name IN ['primary', 'secondary']" label="WR1"/>
         <where expression="SIZEOF (TYPEOF (SELF.relating_draughting_callout) * &#10;       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULAR_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIAMETER_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINEAR_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORDINATE_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIUS_DIMENSION'])&gt;=1" label="WR2"/>
         <where expression="SIZEOF (TYPEOF (SELF.related_draughting_callout) *&#10;       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT']) = 0" label="WR3"/>
         <where expression="SELF.related_draughting_callout.contents *&#10;       SELF.relating_draughting_callout.contents =&#10;       SELF.related_draughting_callout.contents" label="WR4"/>
      </entity>
      <entity name="dimension_curve" supertypes="annotation_curve_occurrence">
         <where expression="(SIZEOF(&#10;          QUERY(dct &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                'TERMINATOR_SYMBOL.ANNOTATED_CURVE')&#10;               | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct))&#10;                  ))&#10;          ) &lt;= 2)" label="WR1"/>
         <where expression="SIZEOF(&#10;            QUERY( dcdc &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                   'DRAUGHTING_CALLOUT.CONTENTS') |&#10;                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                    'DIMENSION_CURVE_DIRECTED_CALLOUT' IN TYPEOF(dcdc)))&#10;          )&gt;= 1" label="WR2"/>
         <where expression="(SIZEOF(&#10;            QUERY(dct1 &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                  'TERMINATOR_SYMBOL.ANNOTATED_CURVE') &#10;               | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct1)) &#10;                  AND (dct1\dimension_curve_terminator.role = dimension_extent_usage.origin)))&#10;          ) &lt;= 1)&#10;        AND &#10;        (SIZEOF(&#10;            QUERY (dct2 &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                   'TERMINATOR_SYMBOL.ANNOTATED_CURVE') &#10;                 | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                   'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct2))&#10;                   AND (dct2\dimension_curve_terminator.role = dimension_extent_usage.target)))&#10;         ) &lt;= 1)" label="WR3"/>
      </entity>
      <entity name="dimension_curve_directed_callout" supertypes="draughting_callout">
         <where expression="SIZEOF(QUERY(d_c&lt;*SELF\draughting_callout.contents | &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE' IN (TYPEOF(d_c))))=1" label="WR1"/>
         <where expression="SIZEOF(SELF\draughting_callout.contents) &gt;= 2" label="WR2"/>
      </entity>
      <entity name="dimension_curve_terminator" supertypes="terminator_symbol">
         <explicit name="role">
            <typename name="dimension_extent_usage"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE' IN TYPEOF&#10;        (SELF\terminator_symbol.annotated_curve)" label="WR1"/>
      </entity>
      <entity name="dimension_curve_terminator_to_projection_curve_associativity" supertypes="annotation_occurrence_associativity">
         <explicit name="relating_annotation_occurrence">
            <typename name="dimension_curve_terminator"/>
            <redeclaration entity-ref="annotation_occurrence_relationship"/>
         </explicit>
         <explicit name="related_annotation_occurrence">
            <typename name="projection_curve"/>
            <redeclaration entity-ref="annotation_occurrence_relationship"/>
         </explicit>
      </entity>
      <entity name="dimension_pair" supertypes="draughting_callout_relationship">
         <where expression="SELF.name IN ['chained', 'parallel']" label="WR1"/>
         <where expression="SIZEOF (TYPEOF (SELF.relating_draughting_callout) *&#10;       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULAR_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIAMETER_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINEAR_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORDINATE_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIUS_DIMENSION'])=1" label="WR2"/>
         <where expression="SIZEOF (TYPEOF (SELF.related_draughting_callout) *&#10;       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULAR_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIAMETER_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINEAR_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORDINATE_DIMENSION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIUS_DIMENSION'])=1" label="WR3"/>
      </entity>
      <entity name="dimension_related_tolerance_zone_element">
         <explicit name="related_dimension">
            <typename name="dimensional_location"/>
         </explicit>
         <explicit name="related_element">
            <typename name="tolerance_zone_definition"/>
         </explicit>
      </entity>
      <entity name="dimension_text_associativity" supertypes="text_literal mapped_item">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_DIMENSION_REPRESENTATION'&#10;          IN TYPEOF (SELF\mapped_item.&#10;                          mapping_source.mapped_representation))" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT'&#10;          IN TYPEOF (SELF\mapped_item.mapping_target))" label="WR2"/>
         <where expression="SIZEOF (QUERY (ato &lt;* QUERY (si &lt;* &#10;          USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM.ITEM') |&#10;            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;              IN TYPEOF(si))) |&#10;          NOT (SIZEOF( QUERY (dc &lt;*&#10;             USEDIN (ato, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                          'DRAUGHTING_CALLOUT.CONTENTS') |&#10;               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT'&#10;             IN TYPEOF (dc)))&#10;            * [SELF\mapped_item.mapping_target]) = 1)&#10;          )) = 0" label="WR3"/>
      </entity>
      <entity name="dimensional_characteristic_representation">
         <explicit name="dimension">
            <typename name="dimensional_characteristic"/>
         </explicit>
         <explicit name="representation">
            <typename name="shape_dimension_representation"/>
         </explicit>
      </entity>
      <entity name="dimensional_exponents">
         <explicit name="length_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="mass_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="time_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="electric_current_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="thermodynamic_temperature_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="amount_of_substance_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="luminous_intensity_exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="dimensional_location" super.expression="ONEOF (angular_location, dimensional_location_with_path)" supertypes="shape_aspect_relationship"/>
      <entity name="dimensional_location_with_path" supertypes="dimensional_location">
         <explicit name="path">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="dimensional_size" super.expression="ONEOF (angular_size, dimensional_size_with_path)">
         <explicit name="applies_to">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where expression="applies_to.product_definitional = TRUE" label="WR1"/>
      </entity>
      <entity name="dimensional_size_with_path" supertypes="dimensional_size">
         <explicit name="path">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="directed_action" supertypes="executed_action">
         <explicit name="directive">
            <typename name="action_directive"/>
         </explicit>
      </entity>
      <entity name="directed_dimensional_location" supertypes="dimensional_location"/>
      <entity name="direction" supertypes="geometric_representation_item">
         <explicit name="direction_ratios">
            <aggregate lower="2" type="LIST" upper="3"/>
            <builtintype type="REAL"/>
         </explicit>
         <where expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0)) &gt; 0" label="WR1"/>
      </entity>
      <entity name="direction_node" supertypes="direction">
         <explicit name="node_1">
            <typename name="node_representation"/>
         </explicit>
         <explicit name="node_2">
            <typename name="node_representation"/>
         </explicit>
         <derived expression="build_direction_node (node_1, node_2)" name="direction_ratios">
            <aggregate lower="2" type="LIST" upper="3"/>
            <builtintype type="REAL"/>
            <redeclaration entity-ref="direction"/>
         </derived>
         <where expression="SIZEOF (QUERY(item &lt;* node_1\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (item))) = 1" label="WR1"/>
         <where expression="SIZEOF (QUERY(item &lt;* node_2\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (item))) = 1" label="WR2"/>
         <where expression="NOT ((direction_ratios[1] = 0.0) AND&#10;            (direction_ratios[2] = 0.0) AND&#10;            (direction_ratios[3] = 0.0))" label="WR3"/>
      </entity>
      <entity name="directionally_explicit_element_coefficient">
         <explicit name="property_type">
            <typename name="matrix_property_type"/>
         </explicit>
         <explicit name="coefficient">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="directionally_explicit_element_coordinate_system_aligned" supertypes="fea_representation_item">
         <explicit name="aligned_system">
            <typename name="curve_3d_element_coordinate_system"/>
         </explicit>
      </entity>
      <entity name="directionally_explicit_element_coordinate_system_arbitrary" supertypes="fea_representation_item">
         <explicit name="arbitrary_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="directionally_explicit_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="systems_and_freedoms">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="system_and_freedom"/>
         </explicit>
         <explicit name="coefficient">
            <typename name="directionally_explicit_element_coefficient"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="required_1d_nodes (&#10;        SELF\element_representation.node_list,&#10;        linear)" label="FU1"/>
      </entity>
      <entity name="distribution_view_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="discretised_model">
            <typename name="discretised_distribution_model_select"/>
         </explicit>
         <explicit name="idealised_distribution">
            <typename name="idealised_distribution_select"/>
         </explicit>
      </entity>
      <entity name="div_expression" supertypes="binary_numeric_expression"/>
      <entity name="document">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="document_type"/>
         </explicit>
         <inverse attribute="represented_document" entity="document_representation_type" name="representation_types">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="document_file" supertypes="document characterized_object">
         <where expression="SELF\characterized_object.name = ''" label="WR1"/>
         <where expression="NOT EXISTS(SELF\characterized_object.description)" label="WR2"/>
         <where expression="SIZEOF( QUERY( drt &lt;* SELF\document.representation_types |&#10;               drt.name IN ['digital','physical'])) = 1" label="WR3"/>
      </entity>
      <entity name="document_identifier" supertypes="group">
         <unique label="UR1">
            <unique.attribute attribute="name" entity-ref="group"/>
            <unique.attribute attribute="description" entity-ref="group"/>
         </unique>
      </entity>
      <entity name="document_identifier_assignment" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="document_identifier"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="document_identifier_assigned_item"/>
         </explicit>
      </entity>
      <entity name="document_product_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_product">
            <typename name="product_or_formation_or_definition"/>
         </explicit>
      </entity>
      <entity name="document_product_equivalence" supertypes="document_product_association">
         <where expression="SELF\document_product_association.name = 'equivalence'" label="WR1"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc &lt;* USEDIN(SELF\document_product_association.related_product,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1))" label="WR2"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc &lt;* USEDIN(SELF.related_product\product_definition_formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1))" label="WR3"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc &lt;* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1))" label="WR4"/>
      </entity>
      <entity abstract.supertype="YES" name="document_reference">
         <explicit name="assigned_document">
            <typename name="document"/>
         </explicit>
         <explicit name="source">
            <typename name="label"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="document_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_representation_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="represented_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_type">
         <explicit name="product_data_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="document_usage_constraint">
         <explicit name="source">
            <typename name="document"/>
         </explicit>
         <explicit name="subject_element">
            <typename name="label"/>
         </explicit>
         <explicit name="subject_element_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="document_usage_constraint_assignment">
         <explicit name="assigned_document_usage">
            <typename name="document_usage_constraint"/>
         </explicit>
         <explicit name="role">
            <typename name="document_usage_role"/>
         </explicit>
      </entity>
      <entity name="document_usage_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="domain_property">
         <explicit name="domain">
            <typename name="temporal_spatial_domain"/>
         </explicit>
         <explicit name="property_type">
            <typename name="general_property"/>
         </explicit>
      </entity>
      <entity name="dose_equivalent_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="dose_equivalent_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.sievert)" label="WR1"/>
      </entity>
      <entity name="double_offset_shelled_solid" supertypes="shelled_solid">
         <explicit name="thickness2">
            <typename name="length_measure"/>
         </explicit>
         <where expression="thickness2 &lt;&gt; 0" label="WR1"/>
         <where expression="SELF\shelled_solid.thickness &lt;&gt; thickness2" label="WR2"/>
      </entity>
      <entity name="draped_defined_transformation" supertypes="transformation_with_derived_angle"/>
      <entity name="draughting_annotation_occurrence" supertypes="annotation_occurrence">
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'&#10;            IN TYPEOF (SELF))) OR&#10;    (SIZEOF (QUERY (sty &lt;* SELF.styles |&#10;       NOT ((SIZEOF (sty.styles) = 1)&#10;         AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;                 IN TYPEOF (sty.styles[1]))) )) = 0)" label="WR1"/>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'&#10;            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty &lt;* SELF.styles |&#10;      NOT ((SIZEOF (sty.styles) = 1)&#10;        AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE'&#10;                IN TYPEOF (sty.styles[1]))) )) = 0)" label="WR2"/>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE'&#10;            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (bound &lt;*&#10;                     SELF.item\annotation_fill_area.boundaries |&#10;       NOT (SIZEOF (QUERY (si &lt;*&#10;                   USEDIN (bound, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                  'STYLED_ITEM.ITEM') |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;             'ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF (si)))) &gt; 0))) = 0)" label="WR3"/>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'&#10;            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty &lt;* SELF.styles |&#10;       NOT ((SIZEOF (sty.styles) = 1)           AND&#10;            (SIZEOF (TYPEOF (sty.styles[1]) *&#10;                ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMBOL_STYLE',&#10;                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NULL_STYLE']) = 1)) )) = 0)" label="WR4"/>
         <where expression="(NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'&#10;             IN TYPEOF (SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL'&#10;             IN TYPEOF(SELF.item)))) OR&#10;         (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                   'DRAUGHTING_SYMBOL_REPRESENTATION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                  'DRAUGHTING_SUBFIGURE_REPRESENTATION'] *&#10;          TYPEOF (SELF.item\mapped_item.mapping_source.&#10;                  mapped_representation)) = 1)" label="WR5"/>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;            IN TYPEOF (SELF))) OR&#10;    (SIZEOF (QUERY (sty &lt;* SELF.styles |&#10;       NOT ((SIZEOF (sty.styles) = 1)&#10;        AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STYLE'&#10;                IN TYPEOF (sty.styles[1]))) )) = 0)" label="WR6"/>
         <where expression="(NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (SELF))) OR&#10;         (SIZEOF (TYPEOF(SELF.item) *&#10;             ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL']) = 1)" label="WR7"/>
         <where expression="(NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'&#10;             IN TYPEOF (SELF.item)))) OR    (SIZEOF (QUERY (tl &lt;*&#10;                   SELF.item\composite_text.collected_text |&#10;             NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL' &#10;             IN TYPEOF (tl)) )) = 0)" label="WR8"/>
         <where expression="(NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL'&#10;             IN TYPEOF (SELF.item)))) OR (SELF.item\text_literal.alignment &#10;             IN ['baseline left', 'baseline centre', 'baseline right'])" label="WR9"/>
         <where expression="(NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'&#10;             IN TYPEOF (SELF.item)))) OR&#10;         (SIZEOF (QUERY (tl &lt;* QUERY (text &lt;* SELF.&#10;                  item\composite_text.collected_text&#10;             |('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL' IN TYPEOF(text))) |&#10;          NOT (tl\text_literal.alignment IN&#10;         ['baseline left', 'baseline centre', 'baseline right']) )) = 0)" label="WR10"/>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF(SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'&#10;             IN TYPEOF (SELF.item))) OR check_text_alignment(SELF.item)" label="WR11"/>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF(SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'&#10;             IN TYPEOF (SELF.item))) OR check_text_font(SELF.item)" label="WR12"/>
         <where expression="(NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF(SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'&#10;               IN TYPEOF (SELF.item)))) OR&#10;         (SIZEOF (QUERY (tl &lt;* QUERY (text &lt;*&#10;            SELF.item\composite_text.collected_text |&#10;            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL' IN TYPEOF (text))) |&#10;             NOT (SIZEOF (TYPEOF(tl) *&#10;                  ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                   'TEXT_LITERAL_WITH_BLANKING_BOX',&#10;                   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                   'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0) )) = 0)" label="WR13"/>
         <where expression="(NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'&#10;             IN TYPEOF (SELF.item)))) OR&#10;    (SIZEOF (QUERY (crv &lt;*&#10;                   SELF.item\text_literal_with_associated_curves.&#10;                   associated_curves |&#10;      NOT (SIZEOF (QUERY (si &lt;*  USEDIN (crv, &#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM.ITEM') |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'&#10;            IN TYPEOF (si)) )) &gt; 0) )) = 0)" label="WR14"/>
         <where expression="(NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (SELF)) AND&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'&#10;             IN TYPEOF (SELF.item)))) OR&#10;          (SIZEOF (QUERY (crv &lt;*&#10;                SELF.item\composite_text_with_associated_curves.&#10;                associated_curves |&#10;           NOT (SIZEOF (QUERY (si &lt;*  USEDIN (crv,&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM.ITEM') |&#10;               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE'&#10;           IN TYPEOF (si)) )) &gt; 0) )) = 0)" label="WR15"/>
         <where expression="SIZEOF (QUERY (cs &lt;* QUERY (sty &lt;* SELF.styles |&#10;      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF (sty.styles[1])))&#10;      | NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT'&#10;        IN TYPEOF (cs.styles[1]\curve_style.curve_width)) AND&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE'&#10;        IN TYPEOF (cs.styles[1]\curve_style.&#10;        curve_width\measure_with_unit.value_component))))) = 0" label="WR16"/>
         <where expression="SIZEOF (QUERY (fas &lt;* QUERY (sty &lt;* SELF.styles |&#10;      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE'&#10;          IN TYPEOF (sty.styles[1]))) |&#10;      NOT ((SIZEOF (QUERY (fs &lt;* fas.styles[1]\fill_area_style.fill_styles&#10;                    | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE_TILES'&#10;                       IN TYPEOF (fs)))) &lt;= 1)&#10;       AND (SIZEOF (QUERY (fst &lt;* QUERY (fs &lt;*&#10;                           fas.styles[1]\fill_area_style.fill_styles |&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE_TILES'&#10;                  IN TYPEOF (fs))) |&#10;                 NOT (SIZEOF (fst\fill_area_style_tiles.tiles) = 1)&#10;           )) = 0))&#10;    )) = 0" label="WR17"/>
         <where expression="SIZEOF (QUERY (fas &lt;* QUERY (sty &lt;* SELF.styles |&#10;           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE' &#10;            IN TYPEOF (sty.styles[1]))) |&#10;             NOT (SIZEOF (QUERY (fsh &lt;* QUERY (fs &lt;*&#10;                          fas.styles[1]\fill_area_style.fill_styles |&#10;             ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FILL_AREA_STYLE_HATCHING'&#10;               IN TYPEOF (fs))) |&#10;        NOT (fsh\fill_area_style_hatching.point_of_reference_hatch_line :=:&#10;             fsh\fill_area_style_hatching.pattern_start)  )) = 0)  )) = 0" label="WR18"/>
         <where expression="SIZEOF (QUERY (ts &lt;* QUERY (sty &lt;* SELF.styles |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STYLE' &#10;         IN TYPEOF(sty.styles[1]))) |&#10;             NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                  'TEXT_STYLE_WITH_BOX_CHARACTERISTICS'&#10;             IN TYPEOF (ts.styles[1])))) = 0" label="WR19"/>
         <where expression="SIZEOF (QUERY (ts &lt;* QUERY (sty &lt;* SELF.styles |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_STYLE_WITH_BOX_CHARACTERISTICS'&#10;             IN TYPEOF (sty.styles[1]))) |&#10;           NOT (SIZEOF (ts.styles[1]\text_style_with_box_characteristics.&#10;                characteristics) = 4) )) = 0" label="WR20"/>
      </entity>
      <entity name="draughting_callout" super.expression="ONEOF (datum_feature_callout, datum_target_callout, dimension_curve_directed_callout, draughting_elements, geometrical_tolerance_callout, leader_directed_callout, projection_directed_callout, structured_dimension_callout) ANDOR surface_condition_callout" supertypes="geometric_representation_item">
         <explicit name="contents">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="draughting_callout_element"/>
         </explicit>
         <where expression="(SIZEOF (QUERY (l_1 &lt;* SELF\draughting_callout.contents |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN (TYPEOF(l_1)))) = 0) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND&#10;        (SIZEOF (QUERY (l_1 &lt;* SELF\draughting_callout.contents |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN (TYPEOF(l_1)))) = 0) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND  &#10;        (SIZEOF (QUERY (l_1 &lt;* SELF\draughting_callout.contents |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE' IN (TYPEOF(l_1)))) = 0) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT' IN (TYPEOF(SELF)))" label="WR1"/>
      </entity>
      <entity name="draughting_callout_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_draughting_callout">
            <typename name="draughting_callout"/>
         </explicit>
         <explicit name="related_draughting_callout">
            <typename name="draughting_callout"/>
         </explicit>
      </entity>
      <entity name="draughting_elements" supertypes="draughting_callout">
         <where expression="SIZEOF (QUERY (l_c &lt;* QUERY (con &lt;* SELF.contents |&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN TYPEOF(con))) |&#10;              NOT (SIZEOF (QUERY (ldc &lt;* USEDIN (l_c,&#10;               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DRAUGHTING_CALLOUT.CONTENTS') |&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT'&#10;              IN TYPEOF (ldc)))) &lt;= 1)))=0" label="WR1"/>
         <where expression="NOT    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT'&#10;              IN TYPEOF(SELF)) OR&#10;              (SIZEOF (QUERY (con &lt;* SELF.contents |&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN&#10;               TYPEOF (con)))) &lt;= 2)" label="WR2"/>
         <where expression="SIZEOF (QUERY (rc &lt;* USEDIN (SELF,&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +&#10;              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;               'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND&#10;              (rc.name = 'primary') )) &lt;= 1" label="WR3"/>
         <where expression="SIZEOF (QUERY (rc &lt;* USEDIN (SELF,&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +&#10;              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |&#10;               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND&#10;                (rc.name = 'secondary') )) &lt;= 1" label="WR4"/>
         <where expression="SIZEOF (QUERY (sec &lt;* QUERY (rc &lt;* USEDIN (SELF,&#10;               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +&#10;               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |&#10;               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND         &#10;                (rc.name = 'secondary') ) |&#10;         NOT (SIZEOF (QUERY (prim &lt;* USEDIN (SELF,&#10;               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT_' +&#10;               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |&#10;               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (prim)) AND         &#10;                (prim.name = 'primary') )) = 1))) = 0" label="WR5"/>
      </entity>
      <entity name="draughting_model" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="draughting_model_item_select"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* SELF.items |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it))) |&#10;         NOT (&#10;           SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION',&#10;                    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_MODEL'] *&#10;              TYPEOF (mi\mapped_item.mapping_source.&#10;                      mapped_representation)) = 1&#10;        ))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (smi &lt;* QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM' IN TYPEOF(it))) |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN&#10;            TYPEOF(si\styled_item.item))) |&#10;        (NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN&#10;                 TYPEOF(smi\styled_item.item\mapped_item.&#10;                        mapping_source.mapped_representation))&#10;            AND&#10;             (SIZEOF (QUERY (sty &lt;* smi\styled_item.styles |&#10;               (NOT (SIZEOF (QUERY (psa &lt;* sty.styles |&#10;                       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF(psa))))) = 1&#10;             )))) = 1)))&#10;        )) = 0" label="WR2"/>
      </entity>
      <entity name="draughting_model_item_association" supertypes="item_identified_representation_usage">
         <explicit name="definition">
            <typename name="shape_definition"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="draughting_model"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="draughting_model_item_association_select"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
      </entity>
      <entity name="draughting_pre_defined_colour" supertypes="pre_defined_colour">
         <where expression="SELF.name IN&#10;      ['red',&#10;       'green',&#10;       'blue',&#10;       'yellow',&#10;       'magenta',&#10;       'cyan',&#10;       'black',&#10;       'white']" label="WR1"/>
      </entity>
      <entity name="draughting_pre_defined_curve_font" supertypes="pre_defined_curve_font">
         <where expression="SELF.name IN&#10;        ['continuous',&#10;         'chain',&#10;         'chain double dash',&#10;         'dashed',&#10;         'dotted']" label="WR1"/>
      </entity>
      <entity name="draughting_pre_defined_text_font" supertypes="pre_defined_text_font">
         <where expression="SELF.name[1:8] = 'ISO 3098'" label="WR1"/>
      </entity>
      <entity name="draughting_subfigure_representation" supertypes="symbol_representation">
         <where expression="SIZEOF (QUERY (item &lt;* SELF\representation.items |&#10;         NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_OCCURRENCE',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT']&#10;               * TYPEOF (item)) = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (item &lt;* SELF\representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_OCCURRENCE',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT'] *&#10;           TYPEOF (item)) = 1)) &gt;= 1" label="WR2"/>
         <where expression="SIZEOF (QUERY (srm &lt;* QUERY (rm &lt;*&#10;          USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |&#10;          ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMBOL_REPRESENTATION_MAP'&#10;             IN TYPEOF(rm))) | &#10;            NOT (SIZEOF (QUERY (a_s &lt;* QUERY (mi &lt;* srm.map_usage |&#10;            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL' IN TYPEOF(mi)))&#10;          | NOT (SIZEOF (QUERY (aso &lt;*&#10;            USEDIN (a_s, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                         'STYLED_ITEM.ITEM') |&#10;          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE'&#10;            IN TYPEOF(aso)))) = 0))) = 0))) &gt; 0" label="WR3"/>
         <where expression="NOT (acyclic_mapped_item_usage (SELF))" label="WR4"/>
         <where expression="SIZEOF (SELF.context_of_items.representations_in_context) = 1" label="WR5"/>
      </entity>
      <entity name="draughting_symbol_representation" supertypes="symbol_representation">
         <unique label="UR1">
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="SIZEOF (QUERY (item &lt;* SELF\representation.items |&#10;         NOT (SIZEOF (TYPEOF (item) *&#10;            ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE',&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE',&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE',&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE',&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT']) = 1)&#10;       )) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (item &lt;* SELF\representation.items |&#10;         (SIZEOF (TYPEOF (item) *&#10;            ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_CURVE_OCCURRENCE',&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE',&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_FILL_AREA_OCCURRENCE',&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE']) = 1)&#10;       )) &gt;= 1" label="WR2"/>
         <where expression="SIZEOF (QUERY (item &lt;* SELF\representation.items |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SUBFIGURE_OCCURRENCE'&#10;          IN TYPEOF (item))) = 0" label="WR3"/>
         <where expression="SIZEOF (QUERY (srm &lt;* QUERY (rm &lt;*&#10;          USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |&#10;          ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMBOL_REPRESENTATION_MAP'&#10;             IN TYPEOF(rm))) |&#10;         (SIZEOF (QUERY (a_s &lt;* QUERY (mi &lt;* srm.map_usage |&#10;           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL' IN TYPEOF(mi))) |&#10;         NOT (SIZEOF (QUERY(aso &lt;*&#10;             USEDIN(a_s, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                         'STYLED_ITEM.ITEM') |&#10;             NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_SYMBOL_OCCURRENCE'&#10;                  IN TYPEOF(aso))&#10;          )) = 0) )) = 0) )) &gt; 0" label="WR4"/>
         <where expression="NOT (acyclic_mapped_item_usage (SELF))" label="WR5"/>
         <where expression="SIZEOF (SELF.context_of_items.representations_in_context) = 1" label="WR6"/>
      </entity>
      <entity name="draughting_text_literal_with_delineation" supertypes="text_literal_with_delineation">
         <where expression="SELF.delineation IN ['underline', 'overline']" label="WR1"/>
      </entity>
      <entity name="draughting_title">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="draughting_titled_item"/>
         </explicit>
         <explicit name="language">
            <typename name="label"/>
         </explicit>
         <explicit name="contents">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="drawing_definition">
         <explicit name="drawing_number">
            <typename name="identifier"/>
         </explicit>
         <explicit name="drawing_type" optional="YES">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="drawing_revision" supertypes="presentation_set">
         <explicit name="revision_identifier">
            <typename name="identifier"/>
         </explicit>
         <explicit name="drawing_identifier">
            <typename name="drawing_definition"/>
         </explicit>
         <explicit name="intended_scale" optional="YES">
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="revision_identifier"/>
            <unique.attribute attribute="drawing_identifier"/>
         </unique>
      </entity>
      <entity name="drawing_revision_sequence">
         <explicit name="predecessor">
            <typename name="drawing_revision"/>
         </explicit>
         <explicit name="successor">
            <typename name="drawing_revision"/>
         </explicit>
         <where expression="predecessor :&lt;&gt;: successor" label="WR1"/>
      </entity>
      <entity name="drawing_sheet_revision" supertypes="presentation_area">
         <explicit name="revision_identifier">
            <typename name="identifier"/>
         </explicit>
         <where expression="SIZEOF( QUERY(item &lt;* SELF\representation.items |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN (TYPEOF(item)))&#10;       AND&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION' IN&#10;       (TYPEOF(item\mapped_item.mapping_source.mapped_representation)))))=0" label="WR1"/>
      </entity>
      <entity name="drawing_sheet_revision_sequence" supertypes="representation_relationship">
         <where expression="SELF\representation_relationship.rep_1 :&lt;&gt;:                            &#10;       SELF\representation_relationship.rep_2" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION'&#10;       IN TYPEOF (SELF\representation_relationship.rep_1)" label="WR2"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION'&#10;       IN TYPEOF (SELF\representation_relationship.rep_2)" label="WR3"/>
      </entity>
      <entity name="drawing_sheet_revision_usage" supertypes="area_in_set">
         <explicit name="sheet_number">
            <typename name="identifier"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="sheet_number"/>
            <unique.attribute attribute="in_set" entity-ref="area_in_set"/>
         </unique>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_SHEET_REVISION' IN &#10;                  TYPEOF(SELF\area_in_set.area)) &#10;              AND&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAWING_REVISION' &#10;               IN TYPEOF (SELF\area_in_set.in_set))" label="WR1"/>
      </entity>
      <entity name="dummy_node" supertypes="node_representation"/>
      <entity name="edge" super.expression="ONEOF (edge_curve, oriented_edge, subedge)" supertypes="topological_representation_item">
         <explicit name="edge_start">
            <typename name="vertex"/>
         </explicit>
         <explicit name="edge_end">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="edge_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="ebwm_boundary">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="connected_edge_set"/>
         </explicit>
      </entity>
      <entity name="edge_based_wireframe_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) &gt;= 1" label="WR2"/>
         <where expression="SIZEOF ( &#10;QUERY ( ebwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( &#10;QUERY ( edges &lt;* eb.ces_edges| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (edges)) )) = 0) )) = 0) )) = 0" label="WR3"/>
         <where expression="SIZEOF ( &#10;QUERY ( ebwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( &#10;QUERY ( pline_edges &lt;* &#10;QUERY ( edges &lt;* eb.ces_edges| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (edges\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points) &gt; 2) )) = 0) )) = 0) )) = 0" label="WR4"/>
         <where expression="SIZEOF ( &#10;QUERY ( ebwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( &#10;QUERY ( edges &lt;* eb.ces_edges| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (edges.edge_start)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (edges.edge_end))) )) = 0) )) = 0) )) = 0" label="WR5"/>
         <where expression="SIZEOF ( &#10;QUERY ( ebwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( &#10;QUERY ( edges &lt;* eb.ces_edges| NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0" label="WR6"/>
         <where expression="SIZEOF ( &#10;QUERY ( ebwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( eb &lt;* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( &#10;QUERY ( edges &lt;* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0" label="WR7"/>
         <where expression="SIZEOF ( &#10;QUERY ( mi &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0" label="WR8"/>
         <where expression="SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3" label="WR9"/>
      </entity>
      <entity abstract.supertype="YES" name="edge_blended_solid" super.expression="track_blended_solid ANDOR ONEOF (solid_with_constant_radius_edge_blend, solid_with_variable_radius_edge_blend, solid_with_chamfered_edges)" supertypes="modified_solid">
         <explicit name="blended_edges">
            <aggregate lower="1" type="LIST" unique="YES" upper="?"/>
            <typename name="edge_curve"/>
         </explicit>
      </entity>
      <entity name="edge_curve" supertypes="edge geometric_representation_item">
         <explicit name="edge_geometry">
            <typename name="curve"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="edge_loop" supertypes="loop path">
         <derived expression="SIZEOF(SELF\path.edge_list)" name="ne">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="(SELF\path.edge_list[1].edge_start) :=:&#10;        (SELF\path.edge_list[ne].edge_end)" label="WR1"/>
      </entity>
      <entity name="effectivity" super.expression="ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity)">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity abstract.supertype="YES" name="effectivity_assignment">
         <explicit name="assigned_effectivity">
            <typename name="effectivity"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="effectivity_context_assignment">
         <explicit name="assigned_effectivity_assignment">
            <typename name="effectivity_assignment"/>
         </explicit>
         <explicit name="role">
            <typename name="effectivity_context_role"/>
         </explicit>
      </entity>
      <entity name="effectivity_context_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="effectivity_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="related_effectivity">
            <typename name="effectivity"/>
         </explicit>
         <explicit name="relating_effectivity">
            <typename name="effectivity"/>
         </explicit>
      </entity>
      <entity name="electric_charge_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="electric_charge_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.coulomb)" label="WR1"/>
      </entity>
      <entity name="electric_current_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="electric_current_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="electric_potential_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_POTENTIAL_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="electric_potential_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.volt)" label="WR1"/>
      </entity>
      <entity name="element_analysis_message" supertypes="analysis_message">
         <explicit name="element">
            <typename name="element_representation"/>
         </explicit>
      </entity>
      <entity name="element_definition" supertypes="shape_aspect"/>
      <entity name="element_descriptor" super.expression="ONEOF (volume_3d_element_descriptor, axisymmetric_volume_2d_element_descriptor, plane_volume_2d_element_descriptor, surface_3d_element_descriptor, axisymmetric_surface_2d_element_descriptor, plane_surface_2d_element_descriptor, curve_3d_element_descriptor, axisymmetric_curve_2d_element_descriptor, plane_curve_2d_element_descriptor)">
         <explicit name="topology_order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="element_geometric_relationship">
         <explicit name="element_ref">
            <typename name="element_or_element_group"/>
         </explicit>
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="aspect">
            <typename name="element_aspect"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item)" label="WR1"/>
         <where expression="consistent_geometric_reference (aspect, item.item)" label="WR2"/>
         <where expression="consistent_element_or_group_reference (aspect, element_ref)" label="WR3"/>
      </entity>
      <entity name="element_group" supertypes="fea_group">
         <explicit name="elements">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="element_representation"/>
         </explicit>
      </entity>
      <entity name="element_group_analysis_message" supertypes="analysis_message">
         <explicit name="group">
            <typename name="element_group"/>
         </explicit>
      </entity>
      <entity name="element_material">
         <explicit name="material_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="properties">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="material_property_representation"/>
         </explicit>
      </entity>
      <entity name="element_nodal_freedom_actions" supertypes="state_definition">
         <explicit name="element">
            <typename name="model_or_control_element"/>
         </explicit>
         <explicit name="nodal_action">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="element_nodal_freedom_terms"/>
         </explicit>
      </entity>
      <entity name="element_nodal_freedom_terms">
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="degrees_of_freedom">
            <typename name="freedoms_list"/>
         </explicit>
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <where expression="SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values)" label="WR1"/>
      </entity>
      <entity name="element_representation" super.expression="ONEOF (volume_3d_element_representation, axisymmetric_volume_2d_element_representation, plane_volume_2d_element_representation, surface_3d_element_representation, axisymmetric_surface_2d_element_representation, plane_surface_2d_element_representation, curve_3d_element_representation, axisymmetric_curve_2d_element_representation, plane_curve_2d_element_representation, point_element_representation, directionally_explicit_element_representation, explicit_element_representation, substructure_element_representation)" supertypes="representation">
         <explicit name="node_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="node_representation"/>
         </explicit>
         <where expression="SIZEOF (QUERY(item &lt;* node_list |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'GEOMETRIC_NODE' &#10;              IN TYPEOF (item))) = 0" label="WR1"/>
      </entity>
      <entity name="element_sequence">
         <explicit name="order_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="control_ref">
            <typename name="control"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="elements">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="model_or_control_element"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="order_id"/>
            <unique.attribute attribute="control_ref"/>
         </unique>
      </entity>
      <entity name="element_topological_relationship">
         <explicit name="aspect">
            <typename name="element_aspect"/>
         </explicit>
         <explicit name="element_ref">
            <typename name="element_representation"/>
         </explicit>
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOPOLOGICAL_REPRESENTATION_ITEM' IN TYPEOF (item.item)" label="WR1"/>
         <where expression="consistent_topological_reference (aspect, item.item)" label="WR2"/>
         <where expression="consistent_element_reference (aspect, element_ref)" label="WR3"/>
      </entity>
      <entity name="elementary_brep_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;          NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] *&#10;                   TYPEOF(it)) = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;         SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP',&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) =1 )) &gt; 0" label="WR2"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;           NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb) |&#10;            NOT (SIZEOF (QUERY(fcs &lt;* csh.cfs_faces |&#10;              NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF(fcs)))) = 0&#10;                 ))) = 0&#10;                   ))) = 0" label="WR3"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;           NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb) |&#10;            NOT (SIZEOF (QUERY(fcs &lt;* csh\connected_face_set.cfs_faces |&#10;              NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN&#10;                   TYPEOF(fcs\face_surface.face_geometry))&#10;             ))) = 0&#10;                 ))) = 0&#10;                   ))) = 0" label="WR4"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;           NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* csh\connected_face_set.cfs_faces |&#10;               NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;                  NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN&#10;            TYPEOF(oe.edge_element)))) = 0&#10;                   ))) = 0&#10;                 ))) = 0&#10;               ))) = 0&#10;             ))) = 0" label="WR5"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;           NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* csh\connected_face_set.cfs_faces |&#10;               NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                 NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;                   NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE'] *&#10;            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )&#10;               )) = 0&#10;               ))) = 0&#10;                 ))) = 0&#10;                   ))) = 0&#10;                    ))) = 0" label="WR6"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;           NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* csh\connected_face_set.cfs_faces |&#10;               NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                 NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;            NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF(oe.edge_start))&#10;                AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN&#10;                 TYPEOF(oe.edge_end))&#10;            ))) = 0&#10;              ))) = 0&#10;               ))) = 0&#10;                 ))) = 0&#10;                   ))) = 0" label="WR7"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;           NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* csh\connected_face_set.cfs_faces |&#10;               NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN&#10;            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND&#10;            (NOT (SIZEOF (oe\oriented_edge.edge_element\&#10;                  edge_curve.edge_geometry\polyline.points) &gt;= 3))&#10;               )) = 0&#10;               ))) = 0&#10;                 ))) = 0&#10;                   ))) = 0&#10;                    ))) = 0" label="WR8"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* items |&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF&#10;              (msb\manifold_solid_brep.outer)))&#10;             = 0" label="WR9"/>
         <where expression="SIZEOF (QUERY (brv &lt;* QUERY (it &lt;* items |&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF(it)) |&#10;          NOT (SIZEOF (QUERY (csh &lt;* brv\brep_with_voids.voids |&#10;           csh\oriented_closed_shell.orientation)) = 0))) = 0" label="WR10"/>
         <where expression="SIZEOF (QUERY (mi &lt;*  QUERY (it &lt;* items |&#10;                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) |&#10;          NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN&#10;             TYPEOF(mi\mapped_item.mapping_source.&#10;                           mapped_representation)))) = 0" label="WR11"/>
         <where expression="SIZEOF (QUERY (msb &lt;* QUERY (it &lt;* SELF.items |&#10;            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |&#10;            NOT (SIZEOF (QUERY (csh &lt;* msb_shells(msb) |&#10;              NOT (SIZEOF (QUERY(fcs &lt;* csh\connected_face_set.cfs_faces |&#10;               NOT (SIZEOF(QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF(bnds.bound)) |&#10;           NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN&#10;               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND&#10;                ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN&#10;                   TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.&#10;                     loop_vertex\vertex_point.vertex_geometry))&#10;            ))) = 0))) = 0))) = 0))) =0" label="WR12"/>
      </entity>
      <entity name="elementary_function" supertypes="maths_function generic_literal">
         <explicit name="func_id">
            <typename name="elementary_function_enumerators"/>
         </explicit>
      </entity>
      <entity name="elementary_space" supertypes="maths_space generic_literal">
         <explicit name="space_id">
            <typename name="elementary_space_enumerators"/>
         </explicit>
      </entity>
      <entity name="elementary_surface" super.expression="ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface)" supertypes="surface">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="elements_bc" supertypes="mbna_bc">
         <explicit name="elements">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="vertex_defined_cell"/>
         </explicit>
      </entity>
      <entity name="ellipse" supertypes="conic">
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="energy_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="energy_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.joule)" label="WR1"/>
      </entity>
      <entity name="entity_assertion" supertypes="fact_type"/>
      <entity name="enum_reference_prefix" supertypes="descriptive_representation_item"/>
      <entity name="environment">
         <explicit name="syntactic_representation">
            <typename name="generic_variable"/>
         </explicit>
         <explicit name="semantics">
            <typename name="variable_semantics"/>
         </explicit>
      </entity>
      <entity name="equals_expression" supertypes="binary_boolean_expression"/>
      <entity name="euler_angles">
         <explicit name="angles">
            <aggregate lower="1" type="ARRAY" upper="3"/>
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="evaluated_characteristic" supertypes="representation representation_relationship">
         <unique label="UR1">
            <unique.attribute attribute="rep_1" entity-ref="representation_relationship"/>
            <unique.attribute attribute="rep_2" entity-ref="representation_relationship"/>
         </unique>
         <where expression="SELF\representation_relationship.rep_1 &lt;&gt; &#10;       SELF\representation_relationship.rep_2" label="WR1"/>
      </entity>
      <entity name="evaluated_degenerate_pcurve" supertypes="degenerate_pcurve">
         <explicit name="equivalent_point">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="evaluation_product_definition" supertypes="product_definition"/>
      <entity name="event_occurrence">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_context_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_event">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="related_event">
            <typename name="event_occurrence"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="exclusive_product_concept_feature_category" supertypes="product_concept_feature_category"/>
      <entity name="executed_action" supertypes="action"/>
      <entity name="exp_function" supertypes="unary_function_call"/>
      <entity name="expanded_uncertainty" supertypes="standard_uncertainty">
         <explicit name="coverage_factor">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="experience">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="experience_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="explicit_element_matrix">
         <explicit name="property_type">
            <typename name="matrix_property_type"/>
         </explicit>
         <explicit name="symmetry">
            <typename name="matrix_symmetry"/>
         </explicit>
         <explicit name="node_dof_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="degree_of_freedom"/>
         </explicit>
         <explicit name="matrix_values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="context_dependent_measure"/>
         </explicit>
         <where expression="SIZEOF (matrix_values) = number_of_terms (node_dof_list, symmetry)" label="WR1"/>
      </entity>
      <entity name="explicit_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="matrix">
            <typename name="explicit_element_matrix"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'FEA_AXIS2_PLACEMENT_3D') &#10;              IN TYPEOF (item))) = 1" label="WR1"/>
         <where expression="SIZEOF (matrix.node_dof_list) = &#10;        SIZEOF (SELF\element_representation.node_list)" label="WR2"/>
      </entity>
      <entity name="explicit_procedural_geometric_representation_item_relationship" supertypes="explicit_procedural_representation_item_relationship">
         <explicit name="relating_representation_item">
            <typename name="procedural_shape_representation_sequence"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <explicit name="related_representation_item">
            <typename name="geometric_representation_item"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <where expression="NOT (&#10;    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROCEDURAL_SHAPE_REPRESENTATION_SEQUENCE'&#10;    IN TYPEOF(&#10;      SELF\representation_item_relationship.related_representation_item))" label="WR1"/>
      </entity>
      <entity name="explicit_procedural_representation_item_relationship" supertypes="representation_item_relationship">
         <explicit name="relating_representation_item">
            <typename name="procedural_representation_sequence"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROCEDURAL_REPRESENTATION_SEQUENCE'&#10;    IN TYPEOF(&#10;      SELF\representation_item_relationship.related_representation_item))" label="WR1"/>
         <where expression="SIZEOF(QUERY(q &lt;* using_representations(&#10;    SELF\representation_item_relationship.related_representation_item) |&#10;    item_in_context(&#10;      SELF\representation_item_relationship.relating_representation_item,&#10;      q.context_of_items))) &gt; 0" label="WR2"/>
      </entity>
      <entity name="explicit_procedural_representation_relationship" supertypes="representation_relationship">
         <explicit name="rep_1">
            <typename name="procedural_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROCEDURAL_REPRESENTATION' &#10;    IN TYPEOF(SELF\representation_relationship.rep_2))) AND &#10;    (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VARIATIONAL_REPRESENTATION'&#10;    IN TYPEOF(SELF\representation_relationship.rep_2)))" label="WR1"/>
         <where expression="SELF\representation_relationship.rep_1.context_of_items :=:&#10;    SELF\representation_relationship.rep_2.context_of_items" label="WR2"/>
      </entity>
      <entity name="explicit_procedural_shape_representation_relationship" supertypes="explicit_procedural_representation_relationship">
         <explicit name="rep_1">
            <typename name="procedural_shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="explicit_table_function" super.expression="ONEOF (listed_real_data, listed_integer_data, listed_logical_data, listed_string_data, listed_complex_number_data, listed_data, externally_listed_data, linearized_table_function, basic_sparse_matrix)" supertypes="maths_function">
         <explicit name="index_base">
            <typename name="zero_or_one"/>
         </explicit>
         <explicit name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
         </explicit>
      </entity>
      <entity name="explicit_unstructured_mesh" supertypes="unstructured_mesh">
         <explicit name="explicit_model">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="cells">
            <aggregate lower="1" type="ARRAY" unique="YES" upper="0"/>
            <typename name="element_representation"/>
         </explicit>
      </entity>
      <entity name="explicitly_enumerated_maths_space_context" supertypes="maths_space_context">
         <explicit name="members">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="maths_value_context"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="expression" super.expression="ONEOF (numeric_expression, boolean_expression, string_expression)" supertypes="generic_expression"/>
      <entity name="expression_conversion_based_unit" supertypes="context_dependent_unit variable_semantics">
         <inverse attribute="semantics" entity="environment" name="associated_variable_environment"/>
      </entity>
      <entity name="expression_denoted_function" supertypes="maths_function unary_generic_expression">
         <derived expression="SELF\unary_generic_expression.operand" name="expr">
            <typename name="generic_expression"/>
         </derived>
         <where expression="(schema_prefix + 'FUNCTION_SPACE') IN TYPEOF (values_space_of(expr))" label="WR1"/>
      </entity>
      <entity name="extended_tuple_space" supertypes="maths_space generic_literal">
         <explicit name="base">
            <typename name="product_space"/>
         </explicit>
         <explicit name="extender">
            <typename name="maths_space"/>
         </explicit>
         <where expression="expression_is_constant(base) AND&#10;       expression_is_constant(extender)" label="WR1"/>
         <where expression="no_cyclic_space_reference(SELF, [])" label="WR2"/>
         <where expression="extender &lt;&gt; the_empty_space" label="WR3"/>
      </entity>
      <entity name="extension" supertypes="derived_shape_aspect">
         <where expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1" label="WR1"/>
      </entity>
      <entity name="extent" supertypes="characterized_object"/>
      <entity name="external_class_library" supertypes="external_source"/>
      <entity abstract.supertype="YES" name="external_identification_assignment" supertypes="identification_assignment">
         <explicit name="source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="external_source">
         <explicit name="source_id">
            <typename name="source_item"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="external_source_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_source">
            <typename name="external_source"/>
         </explicit>
         <explicit name="related_source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="externally_defined_class" supertypes="class externally_defined_item"/>
      <entity name="externally_defined_colour" supertypes="colour_specification externally_defined_item"/>
      <entity name="externally_defined_context_dependent_unit" supertypes="context_dependent_unit externally_defined_item"/>
      <entity name="externally_defined_conversion_based_unit" supertypes="conversion_based_unit externally_defined_item"/>
      <entity name="externally_defined_currency" supertypes="currency externally_defined_context_dependent_unit"/>
      <entity name="externally_defined_curve_font" supertypes="externally_defined_item"/>
      <entity name="externally_defined_dimension_definition" supertypes="dimensional_size externally_defined_item">
         <where expression="(SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification')" label="WR1"/>
         <where expression="1 &gt;= SIZEOF(QUERY ( adr &lt;* USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ))" label="WR2"/>
      </entity>
      <entity name="externally_defined_general_property" supertypes="general_property externally_defined_item"/>
      <entity name="externally_defined_hatch_style" supertypes="externally_defined_item geometric_representation_item"/>
      <entity name="externally_defined_item">
         <explicit name="item_id">
            <typename name="source_item"/>
         </explicit>
         <explicit name="source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="externally_defined_item_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_item">
            <typename name="externally_defined_item"/>
         </explicit>
         <explicit name="related_item">
            <typename name="externally_defined_item"/>
         </explicit>
      </entity>
      <entity name="externally_defined_marker" supertypes="externally_defined_symbol pre_defined_marker"/>
      <entity name="externally_defined_picture_representation_item" supertypes="picture_representation_item">
         <inverse attribute="items" entity="applied_external_identification_assignment" name="source"/>
         <where expression="NOT (SELF\representation_item.name IN pre_defined_picture_representation_types)" label="WR1"/>
      </entity>
      <entity name="externally_defined_representation_item" supertypes="representation_item externally_defined_item"/>
      <entity name="externally_defined_string" supertypes="externally_defined_representation_item"/>
      <entity name="externally_defined_symbol" supertypes="externally_defined_item"/>
      <entity name="externally_defined_terminator_symbol" supertypes="externally_defined_symbol"/>
      <entity name="externally_defined_text_font" supertypes="externally_defined_item"/>
      <entity name="externally_defined_tile" supertypes="externally_defined_item"/>
      <entity name="externally_defined_tile_style" supertypes="externally_defined_item geometric_representation_item"/>
      <entity name="externally_listed_data" supertypes="explicit_table_function generic_literal externally_defined_item">
         <explicit name="value_range">
            <typename name="maths_space"/>
         </explicit>
         <where expression="expression_is_constant(value_range)" label="WR1"/>
      </entity>
      <entity name="extruded_area_solid" supertypes="swept_area_solid">
         <explicit name="extruded_direction">
            <typename name="direction"/>
         </explicit>
         <explicit name="depth">
            <typename name="positive_length_measure"/>
         </explicit>
         <where expression="dot_product(&#10;        (SELF\swept_area_solid.swept_area.basis_surface\&#10;        elementary_surface.position.p[3]), extruded_direction) &lt;&gt; 0.0" label="WR1"/>
      </entity>
      <entity name="extruded_face_solid" supertypes="swept_face_solid">
         <explicit name="extruded_direction">
            <typename name="direction"/>
         </explicit>
         <explicit name="depth">
            <typename name="positive_length_measure"/>
         </explicit>
         <where expression="dot_product(&#10;        (SELF\swept_face_solid.swept_face.face_geometry\&#10;        elementary_surface.position.p[3]), extruded_direction) &lt;&gt; 0.0" label="WR1"/>
      </entity>
      <entity name="extruded_face_solid_with_draft_angle" supertypes="extruded_face_solid_with_trim_conditions">
         <explicit name="draft_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="draft_angle &lt;&gt; 0" label="WR1"/>
      </entity>
      <entity name="extruded_face_solid_with_multiple_draft_angles" supertypes="extruded_face_solid_with_trim_conditions">
         <explicit name="drafted_edges">
            <aggregate lower="2" type="LIST" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="edge_curve"/>
         </explicit>
         <explicit name="draft_angles">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="SIZEOF(drafted_edges) = SIZEOF(draft_angles)" label="WR1"/>
         <where expression="SIZEOF(QUERY(q &lt;* draft_angles | q = 0)) = 0" label="WR2"/>
         <where expression="SIZEOF(QUERY(q &lt;* drafted_edges | (SIZEOF(QUERY(r &lt;* q | NOT &#10;         (SELF\swept_face_solid.swept_face IN &#10;          using_items(r,[])))) &gt; 0))) = 0" label="WR3"/>
      </entity>
      <entity name="extruded_face_solid_with_trim_conditions" super.expression="ONEOF (extruded_face_solid_with_draft_angle, extruded_face_solid_with_multiple_draft_angles)" supertypes="extruded_face_solid">
         <explicit name="first_trim_condition">
            <typename name="trim_condition_select"/>
         </explicit>
         <explicit name="second_trim_condition">
            <typename name="trim_condition_select"/>
         </explicit>
         <explicit name="first_trim_intent">
            <typename name="trim_intent"/>
         </explicit>
         <explicit name="second_trim_intent">
            <typename name="trim_intent"/>
         </explicit>
         <explicit name="first_offset">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <explicit name="second_offset">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <where expression="NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' &#10;         IN TYPEOF(first_trim_condition)) OR&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' &#10;         IN TYPEOF(second_trim_condition)))" label="WR1"/>
         <where expression="NOT ((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(first_trim_condition)) AND &#10;         ((first_trim_intent = trim_intent.offset) &#10;         OR (first_trim_intent = trim_intent.up_to_next))) OR  &#10;         (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(second_trim_condition)) AND &#10;         ((second_trim_intent = trim_intent.offset) &#10;         OR (second_trim_intent = trim_intent.up_to_next))))" label="WR2"/>
         <where expression="NOT (((NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(first_trim_condition))) AND &#10;         ((first_trim_intent = trim_intent.blind) &#10;         OR (first_trim_intent = trim_intent.through_all))) OR  &#10;         ((NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(second_trim_condition))) AND &#10;         ((second_trim_intent = trim_intent.blind) &#10;         OR (second_trim_intent = trim_intent.through_all))))" label="WR3"/>
         <where expression="(((first_trim_intent = trim_intent.offset) &#10;           AND (first_offset &gt; 0)) XOR&#10;         ((first_trim_intent &lt;&gt; trim_intent.offset) &#10;           AND (first_offset = 0))) AND &#10;         (((second_trim_intent = trim_intent.offset) &#10;           AND (second_offset &gt; 0)) XOR&#10;         ((second_trim_intent &lt;&gt; trim_intent.offset) &#10;            AND (second_offset = 0)))" label="WR4"/>
         <where expression="NOT((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(first_trim_condition)) AND&#10;            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(second_trim_condition))) AND&#10;         (first_trim_condition = second_trim_condition))" label="WR5"/>
      </entity>
      <entity name="face" super.expression="ONEOF (face_surface, subface, oriented_face)" supertypes="topological_representation_item">
         <explicit name="bounds">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face_bound"/>
         </explicit>
         <where expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))))" label="WR1"/>
         <where expression="SIZEOF(QUERY(temp &lt;* bounds | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN&#10;                                               TYPEOF(temp))) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="face_based_surface_model" supertypes="geometric_representation_item">
         <explicit name="fbsm_faces">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="connected_face_set"/>
         </explicit>
      </entity>
      <entity name="face_bound" supertypes="topological_representation_item">
         <explicit name="bound">
            <typename name="loop"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="face_outer_bound" supertypes="face_bound"/>
      <entity name="face_surface" supertypes="face geometric_representation_item">
         <explicit name="face_geometry">
            <typename name="surface"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_SURFACE' IN TYPEOF(face_geometry))" label="WR1"/>
      </entity>
      <entity name="faceted_brep" supertypes="manifold_solid_brep"/>
      <entity name="faceted_brep_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) &gt; 0" label="WR2"/>
         <where expression="SIZEOF ( &#10;QUERY ( fbrep &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( csh &lt;* msb_shells(fbrep)| NOT ( SIZEOF ( &#10;QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (fcs)) AND (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF (fcs\face_surface.face_geometry)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\elementary_surface.position.location)))) )) = 0) )) = 0) )) = 0" label="WR3"/>
         <where expression="SIZEOF ( &#10;QUERY ( fbrep &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( csh &lt;* msb_shells(fbrep)| NOT ( SIZEOF ( &#10;QUERY ( fcs &lt;* csh\connected_face_set.cfs_faces| NOT ( SIZEOF ( &#10;QUERY ( bnds &lt;* fcs.bounds| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF (bnds)) )) = 1) )) = 0) )) = 0) )) = 0" label="WR4"/>
         <where expression="SIZEOF ( &#10;QUERY ( msb &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0" label="WR5"/>
         <where expression="SIZEOF ( &#10;QUERY ( brv &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( csh &lt;* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0" label="WR6"/>
         <where expression="SIZEOF ( &#10;QUERY ( mi &lt;* &#10;QUERY ( it &lt;* items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0" label="WR7"/>
      </entity>
      <entity name="fact_type" supertypes="property_definition"/>
      <entity name="fd_bc" supertypes="mbna_bc">
         <explicit name="datasets">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="fd_bc_dataset"/>
            <redeclaration entity-ref="mbna_bc"/>
         </explicit>
      </entity>
      <entity name="fd_bc_dataset" supertypes="mbna_bc_dataset"/>
      <entity name="fd_diffusion_equation" supertypes="fd_governing_equation">
         <explicit name="diffusion_model">
            <typename name="fd_diffusion_model"/>
         </explicit>
      </entity>
      <entity name="fd_diffusion_model">
         <explicit name="terms">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="diff">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="fd_governing_equation" supertypes="mbna_governing_equation"/>
      <entity name="fd_step" supertypes="mbna_step">
         <explicit name="equations">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="flow_equation_set"/>
            <redeclaration entity-ref="mbna_step"/>
         </explicit>
         <explicit name="zones">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="fd_zone"/>
            <redeclaration entity-ref="mbna_step"/>
         </explicit>
      </entity>
      <entity name="fd_zone" supertypes="mbna_zone">
         <explicit name="conditions">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="fd_zone_bc"/>
            <redeclaration entity-ref="mbna_zone"/>
         </explicit>
         <explicit name="equations">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="flow_equation_set"/>
            <redeclaration entity-ref="mbna_zone"/>
         </explicit>
      </entity>
      <entity name="fd_zone_bc" supertypes="mbna_zone_bc">
         <explicit name="conditions">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="fd_bc"/>
            <redeclaration entity-ref="mbna_zone_bc"/>
         </explicit>
      </entity>
      <entity name="fea_area_density" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constant">
            <typename name="scalar"/>
         </explicit>
      </entity>
      <entity name="fea_axis2_placement_2d" supertypes="axis2_placement_2d">
         <explicit name="system_type">
            <typename name="coordinate_system_type"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="fea_axis2_placement_3d" supertypes="axis2_placement_3d">
         <explicit name="system_type">
            <typename name="coordinate_system_type"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="fea_beam_section_idealisation_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="idealised">
            <typename name="general_property"/>
         </explicit>
         <explicit name="idealising">
            <typename name="curve_element_section_definition"/>
         </explicit>
      </entity>
      <entity name="fea_curve_section_geometric_relationship">
         <explicit name="section_ref">
            <typename name="curve_element_section_definition"/>
         </explicit>
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item)" label="WR1"/>
      </entity>
      <entity name="fea_group" super.expression="ONEOF (element_group, node_group)" supertypes="group">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
      </entity>
      <entity name="fea_group_relation" supertypes="group_relationship">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_GROUP'&#10;        IN TYPEOF (SELF\group_relationship.relating_group)" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_GROUP'&#10;        IN TYPEOF (SELF\group_relationship.related_group)" label="WR2"/>
      </entity>
      <entity name="fea_linear_elasticity" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor4_3d"/>
         </explicit>
      </entity>
      <entity name="fea_mass_density" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constant">
            <typename name="scalar"/>
         </explicit>
      </entity>
      <entity name="fea_material_property_geometric_relationship">
         <explicit name="material_ref">
            <typename name="fea_material_property_representation"/>
         </explicit>
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item)" label="WR1"/>
      </entity>
      <entity name="fea_material_property_representation" supertypes="material_property_representation">
         <where expression="SIZEOF (QUERY (item &lt;* &#10;       SELF\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_BENDING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item)&#10;                  ) = 1&#10;       )) = 1" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MATERIAL_PROPERTY' IN &#10;       TYPEOF (SELF\property_definition_representation.definition)" label="WR2"/>
      </entity>
      <entity name="fea_material_property_representation_item" super.expression="ONEOF (fea_linear_elasticity, fea_mass_density, fea_area_density, fea_tangential_coefficient_of_linear_thermal_expansion, fea_secant_coefficient_of_linear_thermal_expansion, fea_moisture_absorption, fea_shell_membrane_stiffness, fea_shell_bending_stiffness, fea_shell_membrane_bending_coupling_stiffness, fea_shell_shear_stiffness)" supertypes="representation_item"/>
      <entity name="fea_model" super.expression="ONEOF (fea_model_2d, fea_model_3d)" supertypes="representation">
         <explicit name="creating_software">
            <typename name="text"/>
         </explicit>
         <explicit name="intended_analysis_code">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="text"/>
         </explicit>
         <explicit name="analysis_type">
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
      </entity>
      <entity name="fea_model_2d" supertypes="fea_model">
         <explicit name="type_of_2d_analysis">
            <typename name="axi_or_plane"/>
         </explicit>
         <where expression="SELF\representation.context_of_items\&#10;       geometric_representation_context.coordinate_space_dimension = 2" label="WR1"/>
      </entity>
      <entity name="fea_model_3d" supertypes="fea_model">
         <where expression="SELF\representation.context_of_items\&#10;       geometric_representation_context.coordinate_space_dimension = 3" label="WR1"/>
      </entity>
      <entity name="fea_model_definition" supertypes="shape_aspect"/>
      <entity name="fea_model_topological_relationship">
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <where expression="'TOPOLOGICAL_DEFINITION_AND_MESH_SCHEMA.MESH' IN TYPEOF (item.item)" label="WR1"/>
      </entity>
      <entity name="fea_moisture_absorption" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor2_3d"/>
         </explicit>
      </entity>
      <entity name="fea_parametric_point" supertypes="point">
         <explicit name="coordinates">
            <aggregate lower="1" type="LIST" upper="3"/>
            <typename name="parameter_value"/>
         </explicit>
         <where expression="valid_parametric_coordinate (coordinates)" label="WR1"/>
         <where expression="SIZEOF (TYPEOF (SELF) *&#10;         ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPHERICAL_POINT',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CYLINDRICAL_POINT'])&#10;         = 0" label="WR2"/>
      </entity>
      <entity name="fea_representation_item" super.expression="ONEOF (arbitrary_volume_3d_element_coordinate_system, parametric_volume_3d_element_coordinate_system, arbitrary_volume_2d_element_coordinate_system, parametric_volume_2d_element_coordinate_system, aligned_surface_3d_element_coordinate_system, parametric_surface_3d_element_coordinate_system, constant_surface_3d_element_coordinate_system, aligned_surface_2d_element_coordinate_system, parametric_surface_2d_element_coordinate_system, aligned_curve_3d_element_coordinate_system, parametric_curve_3d_element_coordinate_system, parametric_curve_3d_element_coordinate_direction, curve_2d_element_coordinate_system, directionally_explicit_element_coordinate_system_arbitrary, directionally_explicit_element_coordinate_system_aligned)" supertypes="representation_item"/>
      <entity name="fea_secant_coefficient_of_linear_thermal_expansion" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor2_3d"/>
         </explicit>
         <explicit name="reference_temperature">
            <typename name="thermodynamic_temperature_measure"/>
         </explicit>
      </entity>
      <entity name="fea_shell_bending_stiffness" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor4_2d"/>
         </explicit>
      </entity>
      <entity name="fea_shell_membrane_bending_coupling_stiffness" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor4_2d"/>
         </explicit>
      </entity>
      <entity name="fea_shell_membrane_stiffness" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor4_2d"/>
         </explicit>
      </entity>
      <entity name="fea_shell_section_distribution_idealisation_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="idealised">
            <typename name="property_definition"/>
         </explicit>
         <explicit name="idealising">
            <typename name="surface_section_field"/>
         </explicit>
      </entity>
      <entity name="fea_shell_section_idealisation_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="idealised">
            <typename name="general_property"/>
         </explicit>
         <explicit name="idealising">
            <typename name="surface_section"/>
         </explicit>
      </entity>
      <entity name="fea_shell_shear_stiffness" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor2_2d"/>
         </explicit>
      </entity>
      <entity name="fea_surface_section_geometric_relationship">
         <explicit name="section_ref">
            <typename name="surface_section"/>
         </explicit>
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item)" label="WR1"/>
      </entity>
      <entity name="fea_tangential_coefficient_of_linear_thermal_expansion" supertypes="fea_material_property_representation_item">
         <explicit name="fea_constants">
            <typename name="symmetric_tensor2_3d"/>
         </explicit>
      </entity>
      <entity name="field_variable_definition" super.expression="ONEOF (field_variable_element_definition, field_variable_element_group_value, field_variable_whole_model_value, field_variable_node_definition)" supertypes="state_definition"/>
      <entity name="field_variable_element_definition" super.expression="ONEOF (volume_3d_element_field_variable_definition, volume_2d_element_field_variable_definition, surface_3d_element_field_variable_definition, surface_2d_element_field_variable_definition, curve_3d_element_field_variable_definition, curve_2d_element_field_variable_definition)" supertypes="field_variable_definition"/>
      <entity name="field_variable_element_group_value" supertypes="field_variable_definition">
         <explicit name="group">
            <typename name="element_group"/>
         </explicit>
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="field_variable_node_definition" super.expression="ONEOF (volume_3d_node_field_variable_definition, volume_2d_node_field_variable_definition, surface_3d_node_field_variable_definition, surface_2d_node_field_variable_definition, curve_3d_node_field_variable_definition, curve_2d_node_field_variable_definition)" supertypes="field_variable_definition">
         <explicit name="node">
            <typename name="node_output_reference"/>
         </explicit>
         <explicit name="group" optional="YES">
            <typename name="element_group"/>
         </explicit>
      </entity>
      <entity name="field_variable_whole_model_value" supertypes="field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="fill_area_style" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="fill_styles">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="fill_style_select"/>
         </explicit>
         <where expression="SIZEOF(QUERY(fill_style &lt;* SELF.fill_styles |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;         'FILL_AREA_STYLE_COLOUR' IN&#10;         TYPEOF(fill_style)&#10;         )) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="fill_area_style_colour">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="fill_colour">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="fill_area_style_hatching" supertypes="geometric_representation_item">
         <explicit name="hatch_line_appearance">
            <typename name="curve_style"/>
         </explicit>
         <explicit name="start_of_next_hatch_line">
            <typename name="one_direction_repeat_factor"/>
         </explicit>
         <explicit name="point_of_reference_hatch_line">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="pattern_start">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="hatch_line_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="fill_area_style_tile_coloured_region" supertypes="geometric_representation_item">
         <explicit name="closed_curve">
            <typename name="curve_or_annotation_curve_occurrence"/>
         </explicit>
         <explicit name="region_colour">
            <typename name="colour"/>
         </explicit>
         <where expression="(NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (closed_curve))) OR &#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE' IN TYPEOF (closed_curve)) OR &#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE' IN TYPEOF (closed_curve)) OR &#10;        ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (closed_curve)) &#10;             AND (closed_curve\b_spline_curve.closed_curve = TRUE) ) OR &#10;        ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF (closed_curve)) &#10;             AND (closed_curve\composite_curve.closed_curve = TRUE) ) OR &#10;        ( ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (closed_curve)) &#10;             AND (closed_curve\polyline.points[LOINDEX(closed_curve\polyline.points)] = &#10;                  closed_curve\polyline.points[HIINDEX(closed_curve\polyline.points)]) )" label="WR1"/>
      </entity>
      <entity name="fill_area_style_tile_curve_with_style" supertypes="geometric_representation_item">
         <explicit name="styled_curve">
            <typename name="annotation_curve_occurrence"/>
         </explicit>
      </entity>
      <entity name="fill_area_style_tile_symbol_with_style" supertypes="geometric_representation_item">
         <explicit name="symbol">
            <typename name="annotation_symbol_occurrence"/>
         </explicit>
      </entity>
      <entity name="fill_area_style_tiles" supertypes="geometric_representation_item">
         <explicit name="tiling_pattern">
            <typename name="two_direction_repeat_factor"/>
         </explicit>
         <explicit name="tiles">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="fill_area_style_tile_shape_select"/>
         </explicit>
         <explicit name="tiling_scale">
            <typename name="positive_ratio_measure"/>
         </explicit>
      </entity>
      <entity name="finite_function" supertypes="maths_function generic_literal">
         <explicit name="pairs">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="maths_value"/>
         </explicit>
         <where expression="VALUE_UNIQUE(list_selected_components(pairs, 1))" label="WR1"/>
      </entity>
      <entity name="finite_integer_interval" supertypes="maths_space generic_literal">
         <explicit name="min">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="max">
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="max - min + 1" name="size">
            <typename name="positive_integer"/>
         </derived>
         <where expression="min &lt;= max" label="WR1"/>
      </entity>
      <entity name="finite_real_interval" supertypes="maths_space generic_literal">
         <explicit name="min">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="min_closure">
            <typename name="open_closed"/>
         </explicit>
         <explicit name="max">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="max_closure">
            <typename name="open_closed"/>
         </explicit>
         <where expression="min &lt; max" label="WR1"/>
      </entity>
      <entity name="finite_space" supertypes="maths_space generic_literal">
         <explicit name="members">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="maths_value"/>
         </explicit>
         <where expression="VALUE_UNIQUE(members)" label="WR1"/>
         <where expression="SIZEOF (QUERY (expr &lt;* QUERY (member &lt;* members |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GENERIC_EXPRESSION' IN TYPEOF (member))&#10;       | NOT expression_is_constant(expr))) = 0" label="WR2"/>
         <where expression="no_cyclic_space_reference(SELF, [])" label="WR3"/>
      </entity>
      <entity name="flat_pattern_ply_representation_relationship" supertypes="shape_representation_relationship">
         <where expression="'STRUCTURAL_ANALYSIS_DESIGN.SHAPE_REPRESENTATION' IN&#10;        (TYPEOF (SELF\representation_relationship.rep_1) *&#10;         TYPEOF (SELF\representation_relationship.rep_2))" label="WR1"/>
         <where expression="SELF\representation_relationship.rep_1.&#10;        context_of_items\geometric_representation_context.&#10;        coordinate_space_dimension = 3" label="WR2"/>
      </entity>
      <entity name="flatness_tolerance" supertypes="geometric_tolerance">
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))" label="WR1"/>
      </entity>
      <entity name="flow_equation_set" supertypes="mbna_equation_set">
         <explicit name="equations">
            <typename name="fd_governing_equation"/>
            <redeclaration entity-ref="mbna_equation_set"/>
         </explicit>
         <explicit name="fd_models">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="fd_behaviour_models"/>
         </explicit>
      </entity>
      <entity name="force_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="force_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.newton)" label="WR1"/>
      </entity>
      <entity name="format_function" supertypes="string_expression binary_generic_expression">
         <derived expression="SELF\binary_generic_expression.operands[1]" name="value_to_format">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\binary_generic_expression.operands[2]" name="format_string">
            <typename name="generic_expression"/>
         </derived>
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION') &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(value_to_format)) &#10;&#9;&#9;&#9;AND (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION') &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(format_string))" label="WR1"/>
      </entity>
      <entity name="forward_chaining_rule" supertypes="rule_definition"/>
      <entity name="forward_chaining_rule_premise" supertypes="property_definition property_definition_representation representation"/>
      <entity name="founded_item" super.expression="ONEOF (character_glyph_style_outline, character_glyph_style_stroke, curve_style, curve_style_font, curve_style_font_and_scaling, curve_style_font_pattern, fill_area_style, point_style, presentation_style_assignment, surface_side_style, surface_style_boundary, surface_style_control_grid, surface_style_fill_area, surface_style_parameter_line, surface_style_segmentation_curve, surface_style_silhouette, surface_style_usage, symbol_style, text_style)">
         <derived expression="using_items(SELF,[])" name="users">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="founded_item_select"/>
         </derived>
         <where expression="SIZEOF(users) &gt; 0" label="WR1"/>
         <where expression="NOT(SELF IN users)" label="WR2"/>
      </entity>
      <entity name="free_variable_semantics" supertypes="variable_semantics"/>
      <entity name="freedom_and_coefficient">
         <explicit name="freedom">
            <typename name="degree_of_freedom"/>
         </explicit>
         <explicit name="a">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
      </entity>
      <entity name="freedoms_list">
         <explicit name="freedoms">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="degree_of_freedom"/>
         </explicit>
      </entity>
      <entity name="frequency_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="frequency_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.hertz)" label="WR1"/>
      </entity>
      <entity name="func" supertypes="compound_representation_item"/>
      <entity name="function_application" supertypes="multiple_arity_generic_expression">
         <explicit name="func">
            <typename name="maths_function_select"/>
         </explicit>
         <explicit name="arguments">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="maths_expression"/>
         </explicit>
         <derived expression="[convert_to_maths_function(func)] + convert_to_operands(arguments)" name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="generic_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </derived>
         <where expression="function_applicability(func, arguments)" label="WR1"/>
      </entity>
      <entity name="function_space" supertypes="maths_space generic_literal">
         <explicit name="domain_constraint">
            <typename name="space_constraint_type"/>
         </explicit>
         <explicit name="domain_argument">
            <typename name="maths_space"/>
         </explicit>
         <explicit name="range_constraint">
            <typename name="space_constraint_type"/>
         </explicit>
         <explicit name="range_argument">
            <typename name="maths_space"/>
         </explicit>
         <where expression="expression_is_constant(domain_argument) AND&#10;       expression_is_constant(range_argument)" label="WR1"/>
         <where expression="(domain_argument &lt;&gt; the_empty_space) AND&#10;       (range_argument &lt;&gt; the_empty_space)" label="WR2"/>
         <where expression="(domain_constraint &lt;&gt; sc_member) OR NOT&#10;       member_of(the_empty_space,domain_argument)" label="WR3"/>
         <where expression="(range_constraint &lt;&gt; sc_member) OR NOT&#10;       member_of(the_empty_space,range_argument)" label="WR4"/>
         <where expression="NOT (any_space_satisfies(domain_constraint,domain_argument) AND&#10;       any_space_satisfies(range_constraint,range_argument))" label="WR5"/>
      </entity>
      <entity name="functional_breakdown_context" supertypes="breakdown_context"/>
      <entity name="functional_element_usage" supertypes="breakdown_element_usage"/>
      <entity name="functionally_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="gas_model" supertypes="mbna_behaviour_model">
         <explicit name="model_type">
            <typename name="gas_model_type"/>
         </explicit>
      </entity>
      <entity name="general_linear_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="sum_index">
            <typename name="one_or_two"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="mat">
            <typename name="maths_function"/>
         </derived>
         <where expression="function_is_2d_table(mat)" label="WR1"/>
         <where expression="(space_dimension(mat.range) = 1) AND&#10;       subspace_of_es(factor1(mat.range),es_numbers)" label="WR2"/>
      </entity>
      <entity name="general_material_property" supertypes="general_property">
         <where expression="SIZEOF( QUERY( gpa &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | &#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition)) )) = 0" label="WR1"/>
      </entity>
      <entity name="general_property">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="general_property_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="base_definition">
            <typename name="general_property"/>
         </explicit>
         <explicit name="derived_definition">
            <typename name="derived_property_select"/>
         </explicit>
         <where expression="SIZEOF(USEDIN(derived_definition, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1" label="WR1"/>
         <where expression="derived_definition.name = base_definition.name" label="WR2"/>
      </entity>
      <entity name="general_property_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_property">
            <typename name="general_property"/>
         </explicit>
         <explicit name="related_property">
            <typename name="general_property"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="generic_character_glyph_symbol" supertypes="symbol_representation"/>
      <entity abstract.supertype="YES" name="generic_expression" super.expression="ONEOF (simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression)">
         <where expression="is_acyclic(SELF)" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="generic_literal" supertypes="simple_generic_expression"/>
      <entity abstract.supertype="YES" name="generic_variable" supertypes="simple_generic_expression">
         <inverse attribute="syntactic_representation" entity="environment" name="interpretation"/>
      </entity>
      <entity name="geometric_alignment" supertypes="derived_shape_aspect">
         <where expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)&gt; 1" label="WR1"/>
      </entity>
      <entity name="geometric_curve_set" supertypes="geometric_set">
         <where expression="SIZEOF(QUERY(temp &lt;* SELF\geometric_set.elements |&#10;                            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(temp))) = 0" label="WR1"/>
      </entity>
      <entity name="geometric_intersection" supertypes="derived_shape_aspect">
         <where expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)&gt; 1" label="WR1"/>
      </entity>
      <entity name="geometric_item_specific_usage" supertypes="item_identified_representation_usage">
         <explicit name="definition">
            <typename name="geometric_item_specific_usage_select"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="geometric_representation_item"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
      </entity>
      <entity name="geometric_model_element_relationship" supertypes="geometric_representation_item representation_item_relationship">
         <explicit name="relating_representation_item">
            <typename name="geometric_representation_item"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <explicit name="related_representation_item">
            <typename name="geometric_representation_item"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="relating_representation_item"/>
            <unique.attribute attribute="related_representation_item"/>
         </unique>
         <where expression="SELF\representation_item_relationship.relating_representation_item :&lt;&gt;: &#10;        SELF\representation_item_relationship.related_representation_item" label="WR1"/>
      </entity>
      <entity name="geometric_node" supertypes="node_representation">
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' &#10;              IN TYPEOF (item))) = 1" label="WR1"/>
      </entity>
      <entity name="geometric_representation_context" supertypes="representation_context">
         <explicit name="coordinate_space_dimension">
            <typename name="dimension_count"/>
         </explicit>
      </entity>
      <entity name="geometric_representation_item" super.expression="ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, right_angular_wedge, volume, half_space_solid, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set)" supertypes="representation_item">
         <derived expression="dimension_of(SELF)" name="dim">
            <typename name="dimension_count"/>
         </derived>
         <where expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) |&#10;      NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;      TYPEOF (using_rep.context_of_items)))) = 0" label="WR1"/>
      </entity>
      <entity name="geometric_set" supertypes="geometric_representation_item">
         <explicit name="elements">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="geometric_set_select"/>
         </explicit>
      </entity>
      <entity name="geometric_tolerance">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="toleranced_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <where expression="('NUMBER' IN TYPEOF&#10;       (magnitude\measure_with_unit.value_component)) AND&#10;       (magnitude\measure_with_unit.value_component &gt;= 0.0)" label="WR1"/>
      </entity>
      <entity name="geometric_tolerance_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_geometric_tolerance">
            <typename name="geometric_tolerance"/>
         </explicit>
         <explicit name="related_geometric_tolerance">
            <typename name="geometric_tolerance"/>
         </explicit>
      </entity>
      <entity name="geometric_tolerance_with_datum_reference" supertypes="geometric_tolerance">
         <explicit name="datum_system">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="datum_reference"/>
         </explicit>
      </entity>
      <entity name="geometric_tolerance_with_defined_unit" supertypes="geometric_tolerance">
         <explicit name="unit_size">
            <typename name="measure_with_unit"/>
         </explicit>
         <where expression="('NUMBER' IN TYPEOF&#10;       (unit_size\measure_with_unit.value_component)) AND&#10;       (unit_size\measure_with_unit.value_component &gt; 0.0)" label="WR1"/>
      </entity>
      <entity name="geometrical_tolerance_callout" supertypes="draughting_callout"/>
      <entity name="geometrically_bounded_2d_wireframe_representation" supertypes="shape_representation">
         <where expression="SELF.context_of_items\geometric_representation_context.&#10;            coordinate_space_dimension = 2" label="WR1"/>
         <where expression="SIZEOF (QUERY (item &lt;* SELF.items |&#10;         NOT (SIZEOF (TYPEOF (item) *&#10;['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET',          &#10;'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_2D',&#10;            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM']) = 1)&#10;       )) = 0" label="WR2"/>
         <where expression="SIZEOF (QUERY (item &lt;* SELF.items |&#10;         SIZEOF (TYPEOF (item) *          &#10;['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET',&#10;            'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM']) = 1&#10;       )) &gt;= 1" label="WR3"/>
         <where expression="SIZEOF (QUERY (mi &lt;* QUERY (item &lt;* SELF.items |&#10;     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;           IN TYPEOF (item))) |&#10;         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'&#10;           IN TYPEOF&#10;              (mi\mapped_item.mapping_source.mapped_representation))&#10;       )) = 0" label="WR4"/>
         <where expression="SIZEOF (QUERY (gcs &lt;* QUERY (item &lt;* SELF.items |&#10;     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET'&#10;                IN TYPEOF (item))) |&#10;         NOT (SIZEOF (QUERY (elem &lt;* gcs\geometric_set.elements |&#10;           NOT (SIZEOF (TYPEOF (elem) *&#10;             ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_2D',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE']) =&#10;               1)&#10;         )) = 0)&#10;       )) = 0" label="WR5"/>
         <where expression="SIZEOF (QUERY (gcs &lt;* QUERY (item &lt;* SELF.items |&#10;     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET'&#10;                IN TYPEOF (item))) |&#10;         NOT (SIZEOF (QUERY (crv &lt;* &#10;           QUERY (elem &lt;* gcs\geometric_set.elements |&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE'&#10;                   IN TYPEOF (elem))) |&#10;           NOT (valid_basis_curve_in_2d_wireframe&#10;              (crv))&#10;         )) = 0)&#10;       )) = 0" label="WR6"/>
         <where expression="SIZEOF (QUERY (gcs &lt;* QUERY (item &lt;* SELF.items |         &#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET'&#10;                IN TYPEOF (item))) |&#10;         NOT (SIZEOF (QUERY (pnt &lt;*&#10;           QUERY (elem &lt;* gcs\geometric_set.elements |&#10;             ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT'&#10;                  IN TYPEOF(elem))) |&#10;             NOT (SIZEOF (TYPEOF (pnt) *&#10;               ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE'])&#10;          = 1)&#10;         )) = 0)&#10;       )) = 0" label="WR7"/>
      </entity>
      <entity name="geometrically_bounded_surface_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF(QUERY(it &lt;* SELF.items | NOT (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(it &lt;* SELF.items | SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) = 1)) &gt; 0" label="WR2"/>
         <where expression="SIZEOF(QUERY(mi &lt;* QUERY(it &lt;* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) | NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY(mr_it &lt;* mi\mapped_item.mapping_source.mapped_representation.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(mr_it)))) &gt; 0)))) = 0" label="WR3"/>
         <where expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(pnt &lt;* QUERY(gsel &lt;* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF(gsel)) | NOT (gbsf_check_point(pnt)))) = 0))) = 0" label="WR4"/>
         <where expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(cv &lt;* QUERY(gsel &lt;* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF(gsel)) | NOT (gbsf_check_curve(cv)))) = 0))) = 0" label="WR5"/>
         <where expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(sf &lt;* QUERY(gsel &lt;* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(gsel)) | NOT (gbsf_check_surface(sf)))) = 0))) = 0" label="WR6"/>
         <where expression="SIZEOF(QUERY(gs &lt;* QUERY(it &lt;* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(it)) | SIZEOF(QUERY(gsel &lt;* gs\geometric_set.elements | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(gsel))) &gt; 0)) &gt; 0" label="WR7"/>
      </entity>
      <entity name="geometrically_bounded_wireframe_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| NOT ( SIZEOF ( TYPEOF (it) * [ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ]) = 1) )) = 0" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| ( SIZEOF ( TYPEOF (it) * [ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ]) = 1) )) &gt;= 1" label="WR2"/>
         <where expression="SIZEOF ( &#10;QUERY ( gcs &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( crv &lt;* &#10;QUERY ( elem &lt;* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_curve(crv) )) = 0) )) = 0" label="WR3"/>
         <where expression="SIZEOF ( &#10;QUERY ( gcs &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( pnts &lt;* &#10;QUERY ( elem &lt;* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_point(pnts) )) = 0) )) = 0" label="WR4"/>
         <where expression="SIZEOF ( &#10;QUERY ( gcs &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( cnc &lt;* &#10;QUERY ( elem &lt;* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC' IN TYPEOF (elem)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' IN TYPEOF (cnc\conic.position)) )) = 0) )) = 0" label="WR5"/>
         <where expression="SIZEOF ( &#10;QUERY ( gcs &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( pline &lt;* &#10;QUERY ( elem &lt;* gcs\geometric_set.elements| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (elem)) )| NOT ( SIZEOF (pline\polyline.points) &gt; 2) )) = 0) )) = 0" label="WR6"/>
         <where expression="SIZEOF ( &#10;QUERY ( mi &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0" label="WR7"/>
      </entity>
      <entity name="geometry_reference">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="data">
            <typename name="choose_geometry_location"/>
         </explicit>
      </entity>
      <entity name="global_assignment" supertypes="representation_item_relationship"/>
      <entity name="global_uncertainty_assigned_context" supertypes="representation_context">
         <explicit name="uncertainty">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="global_unit_assigned_context" supertypes="representation_context">
         <explicit name="units">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="unit"/>
         </explicit>
      </entity>
      <entity name="grid_coordinates" supertypes="model_property_distribution">
         <explicit name="domain">
            <typename name="model_product_domain_with_mesh"/>
            <redeclaration entity-ref="model_property_distribution"/>
         </explicit>
         <explicit name="range">
            <typename name="specified_general_property"/>
            <redeclaration entity-ref="model_property_distribution"/>
         </explicit>
         <inverse attribute="physical_function" entity="property_distribution_description" name="data">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <where expression="is_coordinate_property(range)" label="wr1"/>
      </entity>
      <entity name="grid_coordinates_with_rind" supertypes="grid_coordinates">
         <explicit name="rind_planes">
            <typename name="rind"/>
         </explicit>
      </entity>
      <entity name="ground_fact" supertypes="atomic_formula"/>
      <entity name="grounded_damper" supertypes="point_element_matrix">
         <explicit name="damping_coefficients">
            <aggregate lower="1" type="ARRAY" upper="6"/>
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="grounded_spring" supertypes="point_element_matrix">
         <explicit name="stiffness_coefficients">
            <aggregate lower="1" type="ARRAY" upper="6"/>
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="group">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="group_assignment">
         <explicit name="assigned_group">
            <typename name="group"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="group_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_group">
            <typename name="group"/>
         </explicit>
         <explicit name="related_group">
            <typename name="group"/>
         </explicit>
      </entity>
      <entity name="half_space_solid" supertypes="geometric_representation_item">
         <explicit name="base_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="agreement_flag">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="hardness_representation" supertypes="representation">
         <where expression="( {2&lt;= SIZEOF ( SELF.items ) &lt;=4} ) AND ( SIZEOF ( QUERY (&#10;        i &lt;* items | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (&#10;        i.name IN [ 'measuring method' , 'measuring position' ] ) )&#10;        ) + SIZEOF ( QUERY ( i &lt;* items | ( SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )&#10;        AND ( i.name IN ['depth' , 'hardness'] ) ) ) = SIZEOF (&#10;        SELF.items ) )" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name =&#10;        'measuring method' ) ) =1" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='hardness' ) )&#10;        =1" label="WR3"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name =&#10;        'measuring position' ) ) &lt;=1" label="WR4"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='depth' ) )&#10;        &lt;=1" label="WR5"/>
         <where expression="( SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr&#10;        &lt;* USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa &lt;* USEDIN (&#10;        pdr. definition ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+&#10;        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND&#10;        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )&#10;        ) =1 )" label="WR6"/>
      </entity>
      <entity name="hidden_element_over_riding_styled_item" supertypes="context_dependent_over_riding_styled_item">
         <explicit name="style_context">
            <aggregate lower="1" type="LIST" upper="1"/>
            <typename name="presentation_view"/>
            <redeclaration entity-ref="context_dependent_over_riding_styled_item"/>
         </explicit>
         <explicit name="item">
            <typename name="camera_image"/>
            <redeclaration entity-ref="styled_item"/>
         </explicit>
         <inverse attribute="items" entity="presentation_view" name="container">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAMERA_MODEL_D3_WITH_HLHSR' IN TYPEOF&#10;                (SELF.item\mapped_item.mapping_source.mapping_origin)" label="WR1"/>
      </entity>
      <entity name="homogeneous_linear_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="sum_index">
            <typename name="one_or_two"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="mat">
            <typename name="maths_function"/>
         </derived>
         <where expression="function_is_2d_table(mat)" label="WR1"/>
         <where expression="(space_dimension(mat.range) = 1) AND&#10;       subspace_of_es(factor1(mat.range),es_numbers)" label="WR2"/>
      </entity>
      <entity name="hyperbola" supertypes="conic">
         <explicit name="semi_axis">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_imag_axis">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="id_attribute">
         <explicit name="attribute_value">
            <typename name="identifier"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="id_attribute_select"/>
         </explicit>
      </entity>
      <entity name="idealisation_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="idealised">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="idealisation">
            <typename name="temporal_spatial_domain"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="identification_assignment">
         <explicit name="assigned_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="role">
            <typename name="identification_role"/>
         </explicit>
      </entity>
      <entity name="identification_assignment_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_identification_assignment">
            <typename name="identification_assignment"/>
         </explicit>
         <explicit name="related_identification_assignment">
            <typename name="identification_assignment"/>
         </explicit>
      </entity>
      <entity name="identification_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="illuminance_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="illuminance_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lux)" label="WR1"/>
      </entity>
      <entity name="imported_curve_function" supertypes="maths_function generic_literal">
         <explicit name="geometry">
            <typename name="curve"/>
         </explicit>
         <explicit name="parametric_domain">
            <typename name="tuple_space"/>
         </explicit>
         <where expression="expression_is_constant(parametric_domain)" label="WR1"/>
      </entity>
      <entity name="imported_point_function" supertypes="maths_function generic_literal">
         <explicit name="geometry">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="imported_surface_function" supertypes="maths_function generic_literal">
         <explicit name="geometry">
            <typename name="surface"/>
         </explicit>
         <explicit name="parametric_domain">
            <typename name="tuple_space"/>
         </explicit>
         <where expression="expression_is_constant(parametric_domain)" label="WR1"/>
      </entity>
      <entity name="imported_volume_function" supertypes="maths_function generic_literal">
         <explicit name="geometry">
            <typename name="volume"/>
         </explicit>
         <explicit name="parametric_domain">
            <typename name="tuple_space"/>
         </explicit>
         <where expression="expression_is_constant(parametric_domain)" label="WR1"/>
      </entity>
      <entity name="included_text_block" supertypes="mapped_item">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRUCTURED_TEXT_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)" label="WR1"/>
      </entity>
      <entity name="inclusion_product_concept_feature" supertypes="conditional_concept_feature">
         <where expression="NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) )" label="WR1"/>
         <where expression="SIZEOF (QUERY&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( cfr &lt;* USEDIN &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( SELF ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;| &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;) + &#10;&#9;&#9;&#9;&#9; SIZEOF(QUERY&#10;&#9;&#9;&#9;&#9; &#9;&#9;&#9;&#9;&#9;( cfr &lt;* USEDIN &#10;&#9;&#9;&#9;&#9; &#9;&#9;&#9;&#9;&#9;&#9;&#9;(SELF , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) &#10;&#9;&#9;&#9;&#9; &#9;&#9;&#9;&#9;&#9;&#9;&#9;| &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)= 0" label="WR2"/>
         <where expression="SELF.condition.conditional_operator.name = 'implication'" label="WR3"/>
      </entity>
      <entity name="index_expression" supertypes="string_expression binary_generic_expression">
         <derived expression="SELF\binary_generic_expression.operands[1]" name="operand">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\binary_generic_expression.operands[2]" name="index">
            <typename name="generic_expression"/>
         </derived>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;&#9;&#9;&#9;IN TYPEOF(operand))&#10;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;IN TYPEOF(index))" label="WR1"/>
         <where expression="is_int_expr (index)" label="WR2"/>
      </entity>
      <entity name="indexed_elements_bc" supertypes="mbna_bc">
         <explicit name="element_indices">
            <typename name="indices_group"/>
         </explicit>
      </entity>
      <entity name="indexed_points_bc" supertypes="mbna_bc">
         <explicit name="point_indices">
            <typename name="indices_group"/>
         </explicit>
      </entity>
      <entity name="indices_list">
         <explicit name="nindices">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="indices">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="indices_range">
         <explicit name="nindices">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="start">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="finish">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="indirectly_selected_elements" supertypes="user_selected_elements">
         <explicit name="indirectly_picked_items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="indirectly_selected_shape_elements" supertypes="indirectly_selected_elements user_selected_shape_elements">
         <where expression="SIZEOF(QUERY(q &lt;*&#10;    SELF\indirectly_selected_elements.indirectly_picked_items&#10;    | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_ITEM'&#10;    IN TYPEOF(q)))) = 0" label="WR1"/>
      </entity>
      <entity name="inductance_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="inductance_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.henry)" label="WR1"/>
      </entity>
      <entity name="information_right" supertypes="action_method"/>
      <entity name="information_usage_right" supertypes="action_method"/>
      <entity name="instance_usage_context_assignment" supertypes="product_definition_context">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="instance_usage_context_select"/>
         </explicit>
      </entity>
      <entity name="instanced_feature" supertypes="shape_aspect shape_feature_definition">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN&#10;         TYPEOF(SELF\shape_aspect.of_shape.definition)" label="WR1"/>
         <where expression="SELF\shape_aspect.product_definitional" label="WR2"/>
      </entity>
      <entity name="int_literal" supertypes="literal_number">
         <explicit name="the_value">
            <builtintype type="INTEGER"/>
            <redeclaration entity-ref="literal_number"/>
         </explicit>
      </entity>
      <entity name="int_numeric_variable" supertypes="numeric_variable"/>
      <entity name="int_value_function" supertypes="value_function"/>
      <entity abstract.supertype="YES" name="integer_defined_function" supertypes="numeric_defined_function"/>
      <entity name="integer_interval_from_min" supertypes="maths_space generic_literal">
         <explicit name="min">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="integer_interval_to_max" supertypes="maths_space generic_literal">
         <explicit name="max">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="integer_representation_item" supertypes="representation_item int_literal"/>
      <entity name="integer_tuple_literal" supertypes="generic_literal">
         <explicit name="lit_value">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="intersection_curve" supertypes="surface_curve">
         <where expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2" label="WR1"/>
         <where expression="associated_surface(SELF\surface_curve.associated_geometry[1]) &lt;&gt;&#10;             associated_surface(SELF\surface_curve.associated_geometry[2])" label="WR2"/>
      </entity>
      <entity name="interval_expression" supertypes="boolean_expression multiple_arity_generic_expression">
         <derived expression="SELF\multiple_arity_generic_expression.operands[1]" name="interval_low">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[2]" name="interval_item">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[3]" name="interval_high">
            <typename name="generic_expression"/>
         </derived>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(interval_low))&#10;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(interval_item) )&#10;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(interval_high))" label="WR1"/>
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF (SELF.interval_low)) &#10;&#9;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION'  &#10;&#9;&#9;&#9;&#9;IN TYPEOF (SELF.interval_high)) &#10;&#9;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF (SELF.interval_item))) &#10;&#9;&#9;OR&#10;&#9;&#9;(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(SELF.interval_low)) &#10;&#9;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(SELF.interval_item)) &#10;&#9;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;IN TYPEOF(SELF.interval_high)))" label="WR2"/>
      </entity>
      <entity name="invisibility">
         <explicit name="invisible_items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="invisible_item"/>
         </explicit>
      </entity>
      <entity name="iso4217_currency" supertypes="currency"/>
      <entity name="item_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="transform_item_1">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="item_identified_representation_usage">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="represented_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="representation_item"/>
         </explicit>
         <where expression="SELF.used_representation IN using_representations(SELF.identified_item)" label="WR1"/>
      </entity>
      <entity name="known_source" supertypes="external_source pre_defined_item"/>
      <entity name="laid_defined_transformation" supertypes="transformation_with_derived_angle"/>
      <entity name="laminate_table" super.expression="ONEOF (part_laminate_table, zone_structural_makeup)" supertypes="product_definition"/>
      <entity name="language" supertypes="group">
         <where expression="SELF\group.name &lt;&gt; ''" label="WR1"/>
      </entity>
      <entity name="leader_curve" supertypes="annotation_curve_occurrence">
         <where expression="SIZEOF( &#10;          QUERY(ldc &lt;* USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                       'DRAUGHTING_CALLOUT.CONTENTS')&#10;                   |   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                       'LEADER_DIRECTED_CALLOUT'  IN TYPEOF(ldc))) &gt;= 1" label="WR1"/>
      </entity>
      <entity name="leader_directed_callout" supertypes="draughting_callout">
         <where expression="SIZEOF (QUERY (l_1 &lt;* SELF\draughting_callout.contents |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN (TYPEOF(l_1)))) &gt;= 1" label="WR1"/>
         <where expression="SIZEOF(SELF\draughting_callout.contents) &gt;=2" label="WR2"/>
      </entity>
      <entity name="leader_directed_dimension" supertypes="leader_directed_callout">
         <where expression="SIZEOF (QUERY (con &lt;* SELF.contents |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN TYPEOF (con)))=1" label="WR1"/>
      </entity>
      <entity name="leader_terminator" supertypes="terminator_symbol">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_CURVE' IN TYPEOF&#10;        (SELF\terminator_symbol.annotated_curve)" label="WR1"/>
      </entity>
      <entity name="length_function" supertypes="numeric_expression unary_generic_expression">
         <explicit name="operand">
            <typename name="string_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="length_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="length_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 1.0) AND &#10;    (SELF\named_unit.dimensions.mass_exponent = 0.0) AND &#10;    (SELF\named_unit.dimensions.time_exponent = 0.0) AND &#10;    (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND &#10;    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND &#10;    (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND &#10;    (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="library_context" supertypes="application_context_element">
         <explicit name="library_reference">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="light_source" super.expression="ONEOF (light_source_ambient, light_source_directional, light_source_positional, light_source_spot)" supertypes="geometric_representation_item">
         <explicit name="light_colour">
            <typename name="colour"/>
         </explicit>
         <where expression="SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                              'STYLED_ITEM.ITEM')) = 0" label="WR1"/>
      </entity>
      <entity name="light_source_ambient" supertypes="light_source"/>
      <entity name="light_source_directional" supertypes="light_source">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
      </entity>
      <entity name="light_source_positional" supertypes="light_source">
         <explicit name="position">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="constant_attenuation">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="distance_attenuation">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="light_source_spot" supertypes="light_source">
         <explicit name="position">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <explicit name="concentration_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="constant_attenuation">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="distance_attenuation">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="spread_angle">
            <typename name="positive_plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="like_expression" supertypes="comparison_expression">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;&#9;&#9;IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND &#10;&#9;&#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;&#9;&#9;IN TYPEOF(SELF\binary_generic_expression.operands[2]))" label="WR1"/>
      </entity>
      <entity name="limits_and_fits">
         <explicit name="form_variance">
            <typename name="label"/>
         </explicit>
         <explicit name="zone_variance">
            <typename name="label"/>
         </explicit>
         <explicit name="grade">
            <typename name="label"/>
         </explicit>
         <explicit name="source">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="line" supertypes="curve">
         <explicit name="pnt">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="dir">
            <typename name="vector"/>
         </explicit>
         <where expression="dir.dim  = pnt.dim" label="WR1"/>
      </entity>
      <entity name="line_profile_tolerance" supertypes="geometric_tolerance">
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3)" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( sar &lt;* USEDIN (SELF\geometric_tolerance.toleranced_shape_aspect, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.name IN [ 'affected plane association', 'resulting intersection curve association' ]) )) = 1" label="WR2"/>
      </entity>
      <entity name="linear_constraint_equation_element" supertypes="constraint_element">
         <explicit name="freedoms_and_coefficients">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="linear_constraint_equation_nodal_term"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="linear_constraint_equation_element_value" supertypes="state_definition">
         <explicit name="element">
            <typename name="linear_constraint_equation_element"/>
         </explicit>
         <explicit name="b">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
      </entity>
      <entity name="linear_constraint_equation_nodal_term">
         <explicit name="node">
            <typename name="node_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="freedom_and_coefficient_term">
            <typename name="freedom_and_coefficient"/>
         </explicit>
         <explicit name="dependent">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="linear_dimension" supertypes="dimension_curve_directed_callout"/>
      <entity name="linearized_table_function" super.expression="ONEOF (standard_table_function, regular_table_function, triangular_matrix, symmetric_matrix, banded_matrix)" supertypes="explicit_table_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="first">
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="source">
            <typename name="maths_function"/>
         </derived>
         <where expression="function_is_1d_array(source)" label="WR1"/>
         <where expression="member_of(first, source.domain)" label="WR2"/>
      </entity>
      <entity name="linearly_superimposed_state" supertypes="state">
         <inverse attribute="state" entity="state_component" name="components">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="listed_complex_number_data" supertypes="explicit_table_function generic_literal">
         <explicit name="values">
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived expression="[ SIZEOF(values) DIV 2 ]" name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
            <redeclaration entity-ref="explicit_table_function"/>
         </derived>
         <where expression="NOT ODD(SIZEOF(values))" label="WR1"/>
      </entity>
      <entity name="listed_data" supertypes="explicit_table_function generic_literal">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </explicit>
         <explicit name="value_range">
            <typename name="maths_space"/>
         </explicit>
         <derived expression="[SIZEOF (values)]" name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
            <redeclaration entity-ref="explicit_table_function"/>
         </derived>
         <where expression="expression_is_constant(value_range)" label="WR1"/>
         <where expression="SIZEOF (QUERY (val &lt;* values | NOT (member_of( val, value_range)))) = 0" label="WR2"/>
      </entity>
      <entity name="listed_integer_data" supertypes="explicit_table_function generic_literal">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="[SIZEOF (values)]" name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
            <redeclaration entity-ref="explicit_table_function"/>
         </derived>
      </entity>
      <entity name="listed_logical_data" supertypes="explicit_table_function generic_literal">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived expression="[SIZEOF (values)]" name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
            <redeclaration entity-ref="explicit_table_function"/>
         </derived>
      </entity>
      <entity name="listed_product_space" supertypes="maths_space generic_literal">
         <explicit name="factors">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_space"/>
         </explicit>
         <where expression="SIZEOF (QUERY (space &lt;* factors |&#10;       NOT (expression_is_constant(space)))) = 0" label="WR1"/>
         <where expression="no_cyclic_space_reference(SELF, [])" label="WR2"/>
         <where expression="NOT (the_empty_space IN factors)" label="WR3"/>
      </entity>
      <entity name="listed_real_data" supertypes="explicit_table_function generic_literal">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived expression="[SIZEOF (values)]" name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
            <redeclaration entity-ref="explicit_table_function"/>
         </derived>
      </entity>
      <entity name="listed_string_data" supertypes="explicit_table_function generic_literal">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="STRING"/>
         </explicit>
         <derived expression="[SIZEOF (values)]" name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
            <redeclaration entity-ref="explicit_table_function"/>
         </derived>
      </entity>
      <entity name="literal_conjunction" supertypes="simple_clause"/>
      <entity name="literal_disjunction" supertypes="simple_clause"/>
      <entity abstract.supertype="YES" name="literal_number" super.expression="ONEOF (int_literal, real_literal)" supertypes="simple_numeric_expression generic_literal">
         <explicit name="the_value">
            <builtintype type="NUMBER"/>
         </explicit>
      </entity>
      <entity name="local_time">
         <explicit name="hour_component">
            <typename name="hour_in_day"/>
         </explicit>
         <explicit name="minute_component" optional="YES">
            <typename name="minute_in_hour"/>
         </explicit>
         <explicit name="second_component" optional="YES">
            <typename name="second_in_minute"/>
         </explicit>
         <explicit name="zone">
            <typename name="coordinated_universal_time_offset"/>
         </explicit>
         <where expression="valid_time (SELF)" label="WR1"/>
      </entity>
      <entity name="location">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="log10_function" supertypes="unary_function_call"/>
      <entity name="log2_function" supertypes="unary_function_call"/>
      <entity name="log_function" supertypes="unary_function_call"/>
      <entity name="logical_literal" supertypes="generic_literal">
         <explicit name="lit_value">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="logical_representation_item" supertypes="representation_item logical_literal"/>
      <entity name="loop" super.expression="ONEOF (vertex_loop, edge_loop, poly_loop)" supertypes="topological_representation_item"/>
      <entity name="loss_tangent_measure_with_unit" supertypes="ratio_measure_with_unit"/>
      <entity name="lot_effectivity" supertypes="effectivity">
         <explicit name="effectivity_lot_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_lot_size">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="luminous_flux_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="luminous_flux_unit" supertypes="named_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lumen)" label="WR1"/>
      </entity>
      <entity name="luminous_intensity_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="luminous_intensity_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0)" label="WR1"/>
      </entity>
      <entity name="magnetic_flux_density_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_DENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="magnetic_flux_density_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.tesla)" label="WR1"/>
      </entity>
      <entity name="magnetic_flux_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="magnetic_flux_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.weber)" label="WR1"/>
      </entity>
      <entity name="make_from_usage_option" supertypes="product_definition_usage">
         <explicit name="ranking">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="ranking_rationale">
            <typename name="text"/>
         </explicit>
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
         <where expression="(NOT ('NUMBER' IN TYPEOF(quantity.value_component)))&#10;       OR (quantity.value_component &gt; 0)" label="WR1"/>
      </entity>
      <entity name="manifold_solid_brep" supertypes="solid_model">
         <explicit name="outer">
            <typename name="closed_shell"/>
         </explicit>
      </entity>
      <entity name="manifold_subsurface_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;          NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] *&#10;                   TYPEOF(it)) = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;         SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET',&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) =1 )) &gt; 0" label="WR2"/>
         <where expression="SIZEOF (QUERY (mi &lt;*  QUERY (it &lt;* items |&#10;                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF(it)) |&#10;   NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN&#10;             TYPEOF(mi\mapped_item.mapping_source.&#10;                           mapped_representation)))) = 0" label="WR3"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;          NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL' IN TYPEOF(cfss)))) = 0" label="WR4"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;          NOT( (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN&#10;                   TYPEOF(cfss\connected_face_sub_set.parent_face_set))AND&#10;           (SIZEOF(QUERY(fac &lt;* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT&#10;                 advanced_face_properties(fac))) = 0)) OR&#10;            (SIZEOF(QUERY(fac &lt;* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT&#10;              ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(fac)))) = 0)&#10;                    ))) = 0" label="WR5"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;          ( SIZEOF (QUERY (fac &lt;* cfss\connected_face_set.cfs_faces  | NOT&#10;              advanced_face_properties(fac))) = 0))) = 0" label="WR6"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* cfss\connected_face_set.cfs_faces |&#10;               ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND&#10;            NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;                  NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN&#10;            TYPEOF(oe.edge_element)) OR&#10;           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBEDGE' IN&#10;            TYPEOF(oe.edge_element)) ))) = 0&#10;                   ))) = 0&#10;                 ))) = 0&#10;             ))) = 0" label="WR7"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* cfss\connected_face_set.cfs_faces |&#10;           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND&#10;               NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                 NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;          NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF(oe.edge_start))&#10;                AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN&#10;                 TYPEOF(oe.edge_end))&#10;            ))) = 0&#10;              ))) = 0&#10;               ))) = 0&#10;                   ))) = 0" label="WR8"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* cfss\connected_face_set.cfs_faces |&#10;              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND&#10;              ( NOT (SIZEOF(QUERY  (bnds &lt;* fcs.bounds |&#10;         NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP',&#10;                'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP'] *&#10;                   TYPEOF(bnds.bound)) = 1 )&#10;                   )) = 0)&#10;                 ))) = 0&#10;             ))) = 0" label="WR9"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* cfss\connected_face_set.cfs_faces |&#10;              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND&#10;              ( NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                 NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;                   NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' ] *&#10;            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )&#10;               )) = 0&#10;               ))) = 0&#10;                 )))) = 0&#10;                    ))) = 0" label="WR10"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* cfss\connected_face_set.cfs_faces |&#10;              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND&#10;               (NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN&#10;            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND&#10;            (NOT ((SIZEOF (QUERY (sc_ag &lt;*&#10;            oe.edge_element\edge_curve.edge_geometry\&#10;            surface_curve.associated_geometry |&#10;            NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN&#10;            TYPEOF(sc_ag)))) = 0)))&#10;               )) = 0&#10;               ))) = 0&#10;                   )))) = 0&#10;                    ))) = 0" label="WR11"/>
         <where expression="SIZEOF (QUERY (cfss &lt;* QUERY (it &lt;* SELF.items |&#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |&#10;             NOT (SIZEOF (QUERY(fcs &lt;* cfss\connected_face_set.cfs_faces |&#10;              ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs)) AND&#10;               (NOT (SIZEOF(QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fcs.bounds |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)) |&#10;                NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds.bound\path.edge_list |&#10;                   ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN&#10;            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND&#10;            (NOT (SIZEOF (oe\oriented_edge.edge_element\&#10;                  edge_curve.edge_geometry\polyline.points) &gt;= 3))&#10;               )) = 0&#10;               ))) = 0&#10;                   )))) = 0&#10;                    ))) = 0" label="WR12"/>
      </entity>
      <entity name="manifold_surface_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;       SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt; 0" label="WR2"/>
         <where expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'&#10;       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))&#10;       AND&#10;       (SIZEOF(QUERY (mr_it &lt;*&#10;       mi\mapped_item.mapping_source.mapped_representation.items |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL'&#10;       IN TYPEOF (mr_it)))) &gt; 0 )))) = 0" label="WR3"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (sh &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL']&#10;       * TYPEOF (sh)) = 1))) = 0))) = 0" label="WR4"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (fa)) )) = 0)))&#10;       = 0))) = 0" label="WR5"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (msf_surface_check(fa\face_surface.face_geometry))))) = 0))) &#10;       = 0))) = 0" label="WR6"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (bnds &lt;* fa.bounds |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP']&#10;       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0" label="WR7"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items|&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF &#10;       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0" label="WR8"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe_cv &lt;* QUERY (oe &lt;* &#10;       elp_fbnds\path.edge_list |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE'] * &#10;       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) &#10;       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0" label="WR9"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list |&#10;       NOT (msf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) &#10;       = 0))) = 0)))) = 0))) = 0))) = 0" label="WR10"/>
         <where expression="SIZEOF (QUERY(sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list|&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF&#10;       (oe.edge_element.edge_start))&#10;       AND&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN&#10;       TYPEOF (oe.edge_element.edge_end))))) &#10;       = 0))) = 0)))) = 0))) = 0))) = 0" label="WR11"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list |&#10;       NOT ((SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF&#10;       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)&#10;       AND&#10;       (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF&#10;       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1&#10;       )))) = 0))) = 0)))) = 0))) = 0))) = 0" label="WR12"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;* &#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF&#10;       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) &#10;       = 0))) = 0" label="WR13"/>
         <where expression="SIZEOF (QUERY (sbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;* &#10;       sbsm\shell_based_surface_model.sbsm_boundary |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs\connected_face_set.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF&#10;       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) &#10;       = 1))) = 0)))) = 0))) = 0))) = 0" label="WR14"/>
      </entity>
      <entity name="mapped_item" supertypes="representation_item">
         <explicit name="mapping_source">
            <typename name="representation_map"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="representation_item"/>
         </explicit>
         <where expression="acyclic_mapped_representation(SELF)" label="WR1"/>
      </entity>
      <entity name="mass_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="mass_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="matched_mesh_connection" supertypes="mesh_connectivity">
         <explicit name="current">
            <typename name="structured_mesh"/>
            <redeclaration entity-ref="mesh_connectivity"/>
         </explicit>
         <explicit name="range">
            <typename name="indices_range"/>
         </explicit>
         <explicit name="donor">
            <typename name="structured_mesh"/>
         </explicit>
         <explicit name="donor_range">
            <typename name="indices_range"/>
         </explicit>
         <explicit name="transform">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <where expression="current :&lt;&gt;: donor" label="wr1"/>
         <where expression="donor.index_count = index_count" label="wr2"/>
         <where expression="range.nindices = index_count" label="wr3"/>
         <where expression="donor_range.nindices = index_count" label="wr4"/>
      </entity>
      <entity name="material_designation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definitions">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="characterized_definition"/>
         </explicit>
      </entity>
      <entity name="material_designation_characterization">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="designation">
            <typename name="material_designation"/>
         </explicit>
         <explicit name="property">
            <typename name="characterized_material_property"/>
         </explicit>
      </entity>
      <entity name="material_property" supertypes="property_definition">
         <unique label="UR1">
            <unique.attribute attribute="name" entity-ref="property_definition"/>
            <unique.attribute attribute="definition" entity-ref="property_definition"/>
         </unique>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTERIZED_OBJECT' IN&#10;          TYPEOF(SELF\property_definition.definition)) OR&#10;       (SIZEOF(bag_to_set(USEDIN(SELF ,&#10;                     'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -&#10;              QUERY(temp &lt;* bag_to_set(USEDIN(SELF ,&#10;                       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |&#10;                       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                      'MATERIAL_PROPERTY_REPRESENTATION' IN&#10;                      TYPEOF(temp)))) = 0)" label="WR1"/>
      </entity>
      <entity name="material_property_representation" supertypes="property_definition_representation">
         <explicit name="dependent_environment">
            <typename name="data_environment"/>
         </explicit>
      </entity>
      <entity name="mathematical_description">
         <explicit name="described">
            <typename name="maths_expression"/>
         </explicit>
         <explicit name="describing">
            <builtintype type="STRING"/>
         </explicit>
         <explicit name="encoding">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="maths_boolean_variable" supertypes="maths_variable boolean_variable">
         <where expression="subspace_of_es(SELF\maths_variable.values_space,es_booleans)" label="WR1"/>
      </entity>
      <entity name="maths_enum_literal" supertypes="generic_literal">
         <explicit name="lit_value">
            <typename name="maths_enum_atom"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="maths_function" super.expression="ONEOF (finite_function, constant_function, selector_function, elementary_function, restriction_function, repackaging_function, reindexed_array_function, series_composed_function, parallel_composed_function, explicit_table_function, homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function, rationalize_function, partial_derivative_function, definite_integral_function, abstracted_expression_function, expression_denoted_function, imported_point_function, imported_curve_function, imported_surface_function, imported_volume_function, application_defined_function)" supertypes="generic_expression">
         <derived expression="derive_function_domain(SELF)" name="domain">
            <typename name="tuple_space"/>
         </derived>
         <derived expression="derive_function_range(SELF)" name="range">
            <typename name="tuple_space"/>
         </derived>
      </entity>
      <entity name="maths_integer_variable" supertypes="maths_variable int_numeric_variable">
         <where expression="subspace_of_es(SELF\maths_variable.values_space,es_integers)" label="WR1"/>
      </entity>
      <entity name="maths_real_variable" supertypes="maths_variable real_numeric_variable">
         <where expression="subspace_of_es(SELF\maths_variable.values_space,es_reals)" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="maths_space" super.expression="ONEOF (elementary_space, finite_integer_interval, integer_interval_from_min, integer_interval_to_max, finite_real_interval, real_interval_from_min, real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region, finite_space, uniform_product_space, listed_product_space, extended_tuple_space, function_space)" supertypes="generic_expression"/>
      <entity name="maths_space_context" super.expression="ONEOF (compound_maths_space_context, defined_maths_space_context, explicitly_enumerated_maths_space_context)">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="abstract_space">
            <typename name="maths_space"/>
         </explicit>
         <explicit name="physical_space">
            <typename name="space_context_select"/>
         </explicit>
      </entity>
      <entity name="maths_string_variable" supertypes="maths_variable string_variable">
         <where expression="subspace_of_es(SELF\maths_variable.values_space,es_strings)" label="WR1"/>
      </entity>
      <entity name="maths_tuple_literal" supertypes="generic_literal">
         <explicit name="lit_value">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </explicit>
      </entity>
      <entity name="maths_value_context">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="abstract_value">
            <typename name="maths_value"/>
         </explicit>
         <explicit name="physical_value">
            <typename name="value_context_select"/>
         </explicit>
      </entity>
      <entity name="maths_variable" supertypes="generic_variable">
         <explicit name="values_space">
            <typename name="maths_space"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where expression="expression_is_constant(values_space)" label="WR1"/>
      </entity>
      <entity name="maximum_function" supertypes="multiple_arity_function_call"/>
      <entity name="mbna_Dirichlet_bc_dataset" supertypes="mbna_bc_dataset">
         <explicit name="data">
            <typename name="mbna_bc_data"/>
         </explicit>
      </entity>
      <entity name="mbna_Neumann_bc_dataset" supertypes="mbna_bc_dataset">
         <explicit name="data">
            <typename name="mbna_bc_data"/>
         </explicit>
      </entity>
      <entity name="mbna_bc" super.expression="ONEOF (elements_bc, indexed_elements_bc, indexed_points_bc)" supertypes="mbna_condition">
         <explicit name="datasets">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_bc_dataset"/>
         </explicit>
         <explicit name="gridloc">
            <typename name="mesh_location"/>
         </explicit>
         <explicit name="inward_normal_index" optional="YES">
            <typename name="ijk_minmax"/>
         </explicit>
         <explicit name="inward_normal_list" optional="YES">
            <typename name="indices_list"/>
         </explicit>
         <explicit name="rstate">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_reference_state"/>
         </explicit>
         <explicit name="the_type">
            <typename name="mbna_bc_type"/>
         </explicit>
      </entity>
      <entity name="mbna_bc_data" supertypes="mbna_condition"/>
      <entity name="mbna_bc_data_global" supertypes="mbna_bc_data">
         <inverse attribute="domain" entity="model_property_distribution" name="data_global">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_bc_data_local" supertypes="mbna_bc_data">
         <inverse attribute="domain" entity="model_property_distribution" name="data_local">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_bc_dataset" super.expression="ONEOF (mbna_Dirichlet_bc_dataset, mbna_Neumann_bc_dataset)" supertypes="mbna_condition">
         <explicit name="gridloc">
            <typename name="mesh_location"/>
         </explicit>
         <explicit name="rstate">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_reference_state"/>
         </explicit>
         <explicit name="the_type">
            <typename name="mbna_bc_type_simple"/>
         </explicit>
      </entity>
      <entity name="mbna_behaviour_model" super.expression="ONEOF (thermal_conductivity_model, gas_model, turbulence_closure, turbulence_model, viscosity_model)" supertypes="mbna_equation">
         <inverse attribute="domain" entity="model_property_distribution" name="data">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity abstract.supertype="YES" name="mbna_condition" super.expression="ONEOF (mbna_zone_bc, mbna_bc, mbna_bc_dataset, mbna_bc_data, mbna_reference_state)" supertypes="model_state_domain"/>
      <entity name="mbna_discrete_data" supertypes="mbna_result">
         <explicit name="gridloc">
            <typename name="mesh_location"/>
         </explicit>
         <inverse attribute="physical_function" entity="property_distribution_description" name="data">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_discrete_data_with_rind" supertypes="mbna_discrete_data">
         <explicit name="rind_planes">
            <typename name="rind"/>
         </explicit>
      </entity>
      <entity name="mbna_equation" super.expression="ONEOF (mbna_equation_set, mbna_governing_equation, mbna_behaviour_model)" supertypes="model_product_domain"/>
      <entity name="mbna_equation_set" supertypes="mbna_equation">
         <explicit name="dimension">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="equations">
            <typename name="mbna_governing_equation"/>
         </explicit>
         <explicit name="mbna_models">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_behaviour_models"/>
         </explicit>
      </entity>
      <entity name="mbna_governing_equation" supertypes="mbna_equation">
         <explicit name="equation_type">
            <typename name="mbna_governing_equation_type"/>
         </explicit>
      </entity>
      <entity name="mbna_history" supertypes="mbna_result">
         <explicit name="notes">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="text"/>
         </explicit>
         <inverse attribute="physical_function" entity="property_distribution_description" name="data">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_model" supertypes="model_product_domain">
         <explicit name="temporal_parts">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="mbna_step"/>
            <redeclaration entity-ref="model_product_domain"/>
         </explicit>
         <explicit name="equations">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_equation_set"/>
         </explicit>
         <inverse attribute="domain" entity="mbna_history" name="history">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_reference_state" supertypes="mbna_condition">
         <inverse attribute="domain" entity="model_property_distribution" name="data">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_result" super.expression="ONEOF (mbna_solution, mbna_history, mbna_discrete_data)" supertypes="model_property_distribution"/>
      <entity name="mbna_solution" supertypes="mbna_result">
         <explicit name="gridloc">
            <typename name="mesh_location"/>
         </explicit>
         <inverse attribute="physical_function" entity="property_distribution_description" name="solution">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_solution_with_rind" supertypes="mbna_solution">
         <explicit name="rind_planes">
            <typename name="rind"/>
         </explicit>
      </entity>
      <entity name="mbna_state" supertypes="model_state_domain"/>
      <entity name="mbna_step" supertypes="model_action_domain">
         <explicit name="final">
            <typename name="mbna_state"/>
            <redeclaration entity-ref="model_action_domain"/>
         </explicit>
         <explicit name="equations">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_equation_set"/>
         </explicit>
         <explicit name="refstate">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_reference_state"/>
         </explicit>
         <explicit name="zones">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="mbna_zone"/>
         </explicit>
         <inverse attribute="domain" entity="mbna_history" name="history">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_zone" supertypes="model_product_domain_with_mesh">
         <explicit name="conditions">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_zone_bc"/>
         </explicit>
         <explicit name="equations">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_equation_set"/>
         </explicit>
         <explicit name="grid_connectivity" optional="YES">
            <typename name="multiple_mesh_block"/>
         </explicit>
         <explicit name="rstate">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_reference_state"/>
         </explicit>
         <inverse attribute="domain" entity="grid_coordinates" name="coordinates">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <inverse attribute="domain" entity="mbna_discrete_data" name="field_data">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <inverse attribute="domain" entity="mbna_history" name="history">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
         <inverse attribute="domain" entity="mbna_solution" name="solution">
            <inverse.aggregate lower="0" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="mbna_zone_bc" supertypes="mbna_condition">
         <explicit name="conditions">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_bc"/>
         </explicit>
         <explicit name="rstate">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="mbna_reference_state"/>
         </explicit>
      </entity>
      <entity name="measure_qualification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="qualified_measure">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="qualifiers">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="value_qualifier"/>
         </explicit>
         <where expression="SIZEOF(QUERY(temp &lt;* qualifiers |&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRECISION_QUALIFIER'&#10;             IN TYPEOF(temp))) &lt; 2" label="WR1"/>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM'&#10;           IN TYPEOF(SELF\measure_qualification.qualified_measure))" label="WR2"/>
      </entity>
      <entity name="measure_representation_item" supertypes="representation_item measure_with_unit"/>
      <entity name="measure_with_unit" super.expression="ONEOF (length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit, acceleration_measure_with_unit, capacitance_measure_with_unit, electric_charge_measure_with_unit, conductance_measure_with_unit, electric_potential_measure_with_unit, energy_measure_with_unit, magnetic_flux_density_measure_with_unit, force_measure_with_unit, frequency_measure_with_unit, illuminance_measure_with_unit, inductance_measure_with_unit, luminous_flux_measure_with_unit, magnetic_flux_measure_with_unit, power_measure_with_unit, pressure_measure_with_unit, resistance_measure_with_unit, velocity_measure_with_unit, absorbed_dose_measure_with_unit, radioactivity_measure_with_unit, dose_equivalent_measure_with_unit)">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <explicit name="unit_component">
            <typename name="unit"/>
         </explicit>
         <where expression="valid_units(SELF)" label="WR1"/>
      </entity>
      <entity name="mechanical_context" supertypes="product_context">
         <where expression="SELF.discipline_type = 'mechanical'" label="WR1"/>
      </entity>
      <entity name="mechanical_design_and_draughting_relationship" supertypes="definitional_representation_relationship_with_same_context">
         <explicit name="rep_1">
            <typename name="mechanical_design_and_draughting_relationship_select"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="mechanical_design_and_draughting_relationship_select"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'DRAUGHTING_MODEL' IN TYPEOF(rep_2)) OR &#10;       (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'DRAUGHTING_MODEL' IN TYPEOF(rep_1)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)))" label="WR1"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_2)) OR &#10;       (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_1)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)))" label="WR2"/>
         <where expression="NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_2)) OR &#10;       (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_1)) OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)))" label="WR3"/>
      </entity>
      <entity name="mechanical_design_geometric_presentation_area" supertypes="presentation_area">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="mechanical_design_geometric_presentation_area_items"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <where expression="SIZEOF(QUERY(it1 &lt;* SELF.items |&#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(it1))&#10;        OR&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'&#10;        IN TYPEOF&#10;        (it1\mapped_item.mapping_source.mapped_representation)))) = 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(pv &lt;* QUERY(mi1 &lt;* QUERY(it1 &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(it1)) |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'&#10;        IN TYPEOF&#10;        (mi1\mapped_item.mapping_source.mapped_representation)) |&#10;        -- search in all presentation_views for axis2_placements and&#10;        -- mapped_items and for the subtype of mapped_item&#10;        -- camera_image_3d_with_scale; the latter shall reference&#10;        -- a mechanical_design_geometric_presentation_representation;&#10;        -- the supertype mapped_item shall reference presentation_view.&#10;        NOT (SIZEOF(QUERY(it2 &lt;* pv\mapped_item.mapping_source.&#10;        mapped_representation\representation.items |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT'&#10;        IN TYPEOF(it2))&#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(it2)) AND NOT&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'&#10;        IN TYPEOF&#10;        (it2\mapped_item.mapping_source.mapped_representation)))&#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))&#10;        AND NOT (&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION'&#10;        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))&#10;        ))) = 0))) = 0" label="WR2"/>
         <where expression="(SIZEOF(QUERY(ps &lt;* USEDIN (SELF,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SIZE.UNIT') | ((ps.size\planar_extent.size_in_x &lt;= 0)&#10;        OR&#10;        (ps.size\planar_extent.size_in_y &lt;= 0)))) = 0)&#10;        AND&#10;        (SIZEOF(QUERY(ais &lt;* USEDIN (SELF,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AREA_IN_SET.AREA') |&#10;        (SIZEOF(QUERY(ps &lt;* USEDIN (ais, &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SIZE.UNIT') |&#10;        ((ps.size\planar_extent.size_in_x &lt;= 0)&#10;        OR&#10;        (ps.size\planar_extent.size_in_y &lt;= 0)))) &gt; 0))) = 0)" label="WR3"/>
         <where expression="(SIZEOF(QUERY(ps &lt;* USEDIN (SELF,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SIZE.UNIT') | &#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1)&#10;        AND&#10;        (SIZEOF(QUERY(ps &lt;* USEDIN (SELF,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SIZE.UNIT') | &#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0)&#10;        OR&#10;        ((SIZEOF(QUERY(ais &lt;* USEDIN (SELF,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AREA_IN_SET.AREA') |&#10;        (SIZEOF(QUERY(ps &lt;* USEDIN (ais, &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SIZE.UNIT') |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1))) = 1)&#10;        AND&#10;        (SIZEOF(QUERY(ais &lt;* USEDIN (SELF,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AREA_IN_SET.AREA') |&#10;        (SIZEOF(QUERY(ps &lt;* USEDIN (ais, &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SIZE.UNIT') |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0))) = 1))" label="WR4"/>
      </entity>
      <entity name="mechanical_design_geometric_presentation_representation" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="mechanical_design_geometric_presentation_representation_items"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <where expression="SIZEOF(QUERY(mi &lt;* QUERY(it &lt;* SELF.items |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(it))) | NOT (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SHAPE_REPRESENTATION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION']&#10;        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))&#10;        = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(smi &lt;* QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it))) |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(si\styled_item.item))) | NOT (&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.&#10;        item\mapped_item.mapping_source.mapped_representation))) )) = 0" label="WR2"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(pss &lt;* psa.styles | NOT (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE']&#10;        * TYPEOF(pss)) = 1))) = 0))) = 0))) = 0" label="WR3"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) |&#10;        NOT (SIZEOF(QUERY(psbc &lt;* QUERY(psa &lt;* si\styled_item.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(psa)) | NOT (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'REPRESENTATION_ITEM',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION']&#10;        * TYPEOF(psbc\presentation_style_by_context.style_context))&#10;        = 1))) = 0))) = 0" label="WR4"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ps &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE'&#10;        IN TYPEOF(pss)) | NOT&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ps\point_style.marker_size))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR']&#10;        * TYPEOF(ps\point_style.marker_colour))&#10;        = 1)))) = 0))) = 0))) = 0" label="WR5"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(cs &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF(pss)) | NOT((SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR']&#10;        * TYPEOF(cs\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (cs\curve_style.curve_width))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']&#10;        * TYPEOF(cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0" label="WR6"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ssu &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF(pss)) |&#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_SIDE_STYLE' IN TYPEOF&#10;        (ssu\surface_style_usage.style)))) = 0))) = 0))) = 0" label="WR7"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ssu &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        NOT (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_PARAMETER_LINE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_CONTROL_GRID',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_SILHOUETTE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_SEGMENTATION_CURVE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_FILL_AREA',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_BOUNDARY']&#10;        * TYPEOF(sses)) = 1))) = 0))) = 0))) = 0))) = 0" label="WR8"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ssu &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sspl &lt;* QUERY(sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF(sses)) |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF&#10;        (sspl\surface_style_parameter_line.style_of_parameter_lines))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR']&#10;        * TYPEOF(sspl\surface_style_parameter_line.&#10;        style_of_parameter_lines\curve_style.curve_colour)) = 1)&#10;        AND (&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (sspl\surface_style_parameter_line.&#10;        style_of_parameter_lines\curve_style.curve_width))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']&#10;        * TYPEOF(sspl\surface_style_parameter_line.&#10;        style_of_parameter_lines\curve_style.curve_font)) = 1))))&#10;        = 0))) = 0))) = 0))) = 0" label="WR9"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ssu &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sscg &lt;* QUERY(sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF(sses)) |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR']&#10;        * TYPEOF(sscg\surface_style_control_grid.&#10;        style_of_control_grid\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'POSITIVE_LENGTH_MEASURE' IN TYPEOF &#10;        (sscg\surface_style_control_grid.&#10;        style_of_control_grid\curve_style.curve_width))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']&#10;        * TYPEOF(sscg\surface_style_control_grid.&#10;        style_of_control_grid\curve_style.curve_font)) = 1))))&#10;        = 0))) = 0))) = 0))) = 0" label="WR10"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) |&#10;        NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ssu &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssh &lt;* QUERY(sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF(sses)) |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR']&#10;        * TYPEOF(sssh\surface_style_silhouette.&#10;        style_of_silhouette\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (sssh\surface_style_silhouette.style_of_silhouette\curve_style.&#10;        curve_width))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']&#10;        * TYPEOF(sssh\surface_style_silhouette.&#10;        style_of_silhouette\curve_style.curve_font)) = 1))))&#10;        = 0))) = 0))) = 0))) = 0" label="WR11"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ssu &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssc &lt;* QUERY(sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF(sses)) |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF&#10;        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR']&#10;        * TYPEOF(sssc\surface_style_segmentation_curve.&#10;        style_of_segmentation_curve\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (sssc\surface_style_segmentation_curve.&#10;        style_of_segmentation_curve\curve_style.curve_width))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']&#10;        * TYPEOF(sssc\surface_style_segmentation_curve.&#10;        style_of_segmentation_curve\curve_style.curve_font)) = 1))))&#10;        = 0))) = 0))) = 0))) = 0" label="WR12"/>
         <where expression="SIZEOF(QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF(QUERY(ssu &lt;* QUERY(pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(ssbd &lt;* QUERY(sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)) |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR']&#10;        * TYPEOF(ssbd\surface_style_boundary.&#10;        style_of_boundary\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ssbd\surface_style_boundary.&#10;        style_of_boundary\curve_style.curve_width))&#10;        AND (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_FONT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']&#10;        * TYPEOF(ssbd\surface_style_boundary.&#10;        style_of_boundary\curve_style.curve_font)) = 1)))) = 0)))&#10;        = 0))) = 0))) = 0" label="WR13"/>
      </entity>
      <entity name="mechanical_design_presentation_representation_with_draughting" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="camera_model_d3"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="mechanical_design_shaded_presentation_area" supertypes="presentation_area">
         <where expression="SIZEOF (QUERY (it1 &lt;* SELF.items |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT'&#10;        IN TYPEOF (it1))&#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF (it1)) AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'&#10;        IN TYPEOF&#10;        (it1\mapped_item.mapping_source.mapped_representation)))))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (pv &lt;* QUERY (mi1 &lt;* QUERY (it1 &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF (it1)) |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'&#10;        IN TYPEOF&#10;        (mi1\mapped_item.mapping_source.mapped_representation)) |&#10;        (* search in all presentation_views for axis2_placements and&#10;           mapped_items and for the subtype of mapped_item,&#10;           camera_image_3d_with_scale; the latter shall reference&#10;           a mechanical_design_geometric_presentation_representation;&#10;           the supertype mapped_item shall reference presentation_view. *)&#10;        NOT (SIZEOF(QUERY(it2 &lt;* pv\mapped_item.mapping_source.&#10;        mapped_representation\representation.items |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT'&#10;        IN TYPEOF(it2))&#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(it2)) AND NOT&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW'&#10;        IN TYPEOF&#10;        (it2\mapped_item.mapping_source.mapped_representation)))&#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))&#10;        AND NOT (&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION'&#10;        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))&#10;        ))) = 0))) = 0" label="WR2"/>
         <where expression="(SIZEOF (QUERY(ps &lt;* USEDIN (SELF, &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;        'PRESENTATION_SIZE.UNIT') |&#10;        NOT ((ps.size\planar_extent.size_in_x &gt; 0) &#10;        AND (ps.size\planar_extent.size_in_y &gt; 0)) )) = 0)&#10;        AND&#10;        (* check secondly for presentation_set, via area_in_set *)&#10;        (SIZEOF (QUERY(pset &lt;* QUERY(ais &lt;* &#10;        USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;        'AREA_IN_SET.AREA') &#10;        | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |&#10;        (* after having collected all presentation_set, check their sizes *)&#10;        SIZEOF (QUERY(psize &lt;* USEDIN(pset, &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;        'PRESENTATION_SIZE.UNIT')&#10;        | NOT ((psize.size\planar_extent.size_in_x &gt; 0) &#10;        AND (psize.size\planar_extent.size_in_y &gt; 0)) )) = 0)) = 0)" label="WR3"/>
         <where expression="(SIZEOF(QUERY( psize &lt;* USEDIN (SELF, &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;        'PRESENTATION_SIZE.UNIT') &#10;        | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AXIS2_PLACEMENT_2D' &#10;        IN TYPEOF (psize.size.placement))) = 1)&#10;        AND&#10;        (* check secondly for presentation_set, via area_in_set *)&#10;        (SIZEOF (QUERY(pset &lt;* QUERY(ais &lt;* &#10;        USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'AREA_IN_SET.AREA')&#10;        | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |&#10;        (* after having collected all presentation_set, check their &#10;           dimension *)&#10;        SIZEOF (QUERY(psize &lt;* USEDIN(pset, &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;        'PRESENTATION_SIZE.UNIT')&#10;        | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;        'AXIS2_PLACEMENT_2D' &#10;        IN TYPEOF (psize.size.placement)) )) = 0)) = 0)" label="WR4"/>
         <where expression="SIZEOF (QUERY (pv &lt;* QUERY (mi1 &lt;* QUERY (it1 &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' &#10;        IN TYPEOF (it1)) |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_VIEW' &#10;        IN TYPEOF &#10;        (mi1\mapped_item.mapping_source.mapped_representation)) |&#10;        (* search in all presentation_views for &#10;           mapped_items and for the subtype of mapped_item,&#10;           camera_image_3d_with_scale; the latter shall reference&#10;           a camera_usage that shall have as its mapping_origin either&#10;           camera_model_d3, camera_model_d3_with_hlhsr, or&#10;           camera_model_with_light_sources. *)&#10;        NOT (SIZEOF(QUERY(ci &lt;* pv\mapped_item.mapping_source.&#10;        mapped_representation\representation.items |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;         'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(ci))&#10;        AND&#10;        (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CAMERA_MODEL_D3',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CAMERA_MODEL_D3_WITH_HLHSR',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CAMERA_MODEL_WITH_LIGHT_SOURCES'] * TYPEOF&#10;        (ci\mapped_item.mapping_source.mapping_origin))&#10;        = 1))) = 0))) = 0" label="WR5"/>
      </entity>
      <entity name="mechanical_design_shaded_presentation_representation" supertypes="representation">
         <where expression="SIZEOF(QUERY(it &lt;* SELF.items |&#10;        NOT (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAMERA_MODEL_D3']&#10;        * TYPEOF(it)) = 1))) = 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(mi &lt;* QUERY(it &lt;* SELF.items |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(it))) | NOT (SIZEOF(&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SHAPE_REPRESENTATION',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION']&#10;        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))&#10;        = 1))) = 0" label="WR2"/>
         <where expression="SIZEOF(QUERY(smi &lt;* QUERY(si &lt;* QUERY(it &lt;* SELF.items |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF(it))) |&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'&#10;        IN TYPEOF(si\styled_item.item))) | NOT (&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.&#10;        item\mapped_item.mapping_source.mapped_representation))) )) = 0" label="WR3"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (pss &lt;* psa.styles |&#10;        NOT (SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE']&#10;        *  TYPEOF (pss)) = 1))) = 0))) = 0))) = 0" label="WR4"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psbc &lt;* QUERY (psa &lt;* si\styled_item.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF (psa))  |&#10;        NOT (SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION']&#10;        * TYPEOF (psbc\presentation_style_by_context.style_context)) = 1)))&#10;        = 0))) = 0" label="WR5"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ps &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_STYLE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MARKER_TYPE'&#10;        IN TYPEOF (ps\point_style.marker))&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (ps\point_style.marker_size))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (ps\point_style.marker_colour)) = 1)))) = 0))) = 0))) = 0" label="WR6"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (cs &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (cs\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (cs\curve_style.curve_width))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF&#10;        (cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0" label="WR7"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_SIDE_STYLE'&#10;        IN TYPEOF (ssu\surface_style_usage.style)) )) = 0))) = 0 ))) = 0" label="WR8"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        NOT (SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_PARAMETER_LINE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_CONTROL_GRID',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_SILHOUETTE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_SEGMENTATION_CURVE',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_BOUNDARY',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_FILL_AREA',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_RENDERING'] * TYPEOF (sses)) = 1))) = 0))) = 0)))&#10;        = 0))) = 0" label="WR9"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (ssfa &lt;* QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_FILL_AREA'&#10;        IN TYPEOF (sses)) |&#10;        NOT (SIZEOF (QUERY (fss &lt;*&#10;        ssfa\surface_style_fill_area.fill_area.fill_styles |&#10;        NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'FILL_AREA_STYLE_COLOUR' IN TYPEOF (fss))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (fss\fill_area_style_colour.fill_colour)) = 1)))) = 0))) = 0)))&#10;        = 0))) = 0))) = 0" label="WR10"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (sspl &lt;* QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF (sses)) |&#10;        NOT ((&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF&#10;        (sspl\surface_style_parameter_line.style_of_parameter_lines))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sspl\surface_style_parameter_line.&#10;        style_of_parameter_lines\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (sspl\surface_style_parameter_line.&#10;        style_of_parameter_lines\curve_style.curve_width))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF&#10;        (sspl\surface_style_parameter_line.&#10;        style_of_parameter_lines\curve_style.curve_font)) = 1))&#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'&#10;        IN TYPEOF&#10;        (sspl\surface_style_parameter_line.style_of_parameter_lines))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sspl\surface_style_parameter_line.style_of_parameter_lines\&#10;        curve_style_rendering.rendering_properties.rendered_colour))&#10;        = 1))) )) = 0))) = 0))) = 0))) = 0" label="WR11"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (sscg &lt;* QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF (sses)) |&#10;        NOT ((&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sscg\surface_style_control_grid.&#10;        style_of_control_grid\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (sscg\surface_style_control_grid.&#10;        style_of_control_grid\curve_style.curve_width))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF&#10;        (sscg\surface_style_control_grid.&#10;        style_of_control_grid\curve_style.curve_font)) = 1))&#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'&#10;        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sscg\surface_style_control_grid.style_of_control_grid\&#10;        curve_style_rendering.rendering_properties.rendered_colour))&#10;        = 1))) )) = 0))) = 0))) = 0))) = 0" label="WR12"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (sssh &lt;* QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF (sses)) |&#10;        NOT ((&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sssh\surface_style_silhouette.&#10;        style_of_silhouette\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (sssh\surface_style_silhouette.&#10;        style_of_silhouette\curve_style.curve_width))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF&#10;        (sssh\surface_style_silhouette.&#10;        style_of_silhouette\curve_style.curve_font)) = 1)) &#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'&#10;        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sssh\surface_style_silhouette.style_of_silhouette\&#10;        curve_style_rendering.rendering_properties.rendered_colour))&#10;        = 1))) )) = 0))) = 0))) = 0))) = 0" label="WR13"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (sssc &lt;* QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF (sses)) |&#10;        NOT ((&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF&#10;        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sssc\surface_style_segmentation_curve.&#10;        style_of_segmentation_curve\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (sssc\surface_style_segmentation_curve.&#10;        style_of_segmentation_curve\curve_style.curve_width))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF&#10;        (sssc\surface_style_segmentation_curve.&#10;        style_of_segmentation_curve\curve_style.curve_font)) = 1)) &#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'&#10;        IN TYPEOF (sssc\surface_style_segmentation_curve.&#10;        style_of_segmentation_curve))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve\&#10;        curve_style_rendering.rendering_properties.rendered_colour))&#10;        = 1))) )) = 0))) = 0))) = 0))) = 0" label="WR14"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (ssbd &lt;* QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_BOUNDARY' IN TYPEOF (sses)) |&#10;        NOT ((&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE'&#10;        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (ssbd\surface_style_boundary.&#10;        style_of_boundary\curve_style.curve_colour)) = 1)&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF&#10;        (ssbd\surface_style_boundary.&#10;        style_of_boundary\curve_style.curve_width))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'CURVE_STYLE_FONT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF&#10;        (ssbd\surface_style_boundary.&#10;        style_of_boundary\curve_style.curve_font)) = 1)) &#10;        OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE_RENDERING'&#10;        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))&#10;        AND&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (ssbd\surface_style_boundary.style_of_boundary\&#10;        curve_style_rendering.rendering_properties.rendered_colour))&#10;        = 1))) )) = 0))) = 0))) = 0))) = 0" label="WR15"/>
         <where expression="SIZEOF (QUERY (si &lt;* QUERY (it &lt;* SELF.items |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STYLED_ITEM'&#10;        IN TYPEOF (it)) |&#10;        NOT (SIZEOF (QUERY (psa &lt;* si\styled_item.styles |&#10;        NOT (SIZEOF (QUERY (ssu &lt;* QUERY (pss &lt;* psa.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE'&#10;        IN TYPEOF (pss)) |&#10;        NOT (SIZEOF (QUERY (ssre &lt;* QUERY (sses &lt;*&#10;        ssu\surface_style_usage.style\surface_side_style.styles |&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'SURFACE_STYLE_RENDERING' IN TYPEOF (sses)) |&#10;        NOT&#10;        (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COLOUR_RGB',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF&#10;        (ssre\surface_style_rendering.surface_colour)) = 1)))&#10;        = 0))) = 0))) = 0))) = 0" label="WR16"/>
      </entity>
      <entity abstract.supertype="YES" name="mesh" super.expression="ONEOF (structured_mesh, unstructured_mesh) ANDOR submesh" supertypes="topological_representation_item">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="index_count">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="mesh_connectivity" super.expression="ONEOF (matched_mesh_connection, mismatched_mesh_connection)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="current">
            <typename name="mesh"/>
         </explicit>
         <derived expression="current.index_count" name="index_count">
            <builtintype type="INTEGER"/>
         </derived>
      </entity>
      <entity name="mesh_function" supertypes="application_defined_function unary_generic_expression">
         <explicit name="mesh">
            <typename name="mesh"/>
         </explicit>
         <explicit name="basis">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="mesh_function_basis"/>
         </explicit>
         <explicit name="uniform">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="vertex_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="control_values">
            <typename name="maths_function"/>
         </derived>
         <where expression="function_is_table(control_values)" label="wr1"/>
         <where expression="(uniform AND (SIZEOF(basis) = 1)) XOR&#10;        (NOT uniform)" label="wr2"/>
      </entity>
      <entity name="mesh_function_basis" supertypes="application_defined_function unary_generic_expression">
         <explicit name="cell_topological_dimension">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="value_array_dimension">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="value_array_order">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="value_positions">
            <typename name="maths_function"/>
         </derived>
         <where expression="function_is_table(value_positions)" label="value_positions_as_table"/>
      </entity>
      <entity name="mesh_overset_hole" supertypes="mismatched_mesh_connection"/>
      <entity name="min_and_major_ply_orientation_basis" supertypes="representation_item_relationship geometric_representation_item">
         <explicit name="relating_representation_item">
            <typename name="axis2_placement_3d"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <explicit name="related_representation_item">
            <typename name="axis2_placement_3d"/>
            <redeclaration entity-ref="representation_item_relationship"/>
         </explicit>
         <derived expression="SELF\representation_item_relationship.related_representation_item" name="major_orientation_basis">
            <typename name="axis2_placement_3d"/>
         </derived>
         <derived expression="SELF\representation_item_relationship.relating_representation_item" name="minor_orientation_basis">
            <typename name="axis2_placement_3d"/>
         </derived>
      </entity>
      <entity name="minimum_function" supertypes="multiple_arity_function_call"/>
      <entity name="minus_expression" supertypes="binary_numeric_expression"/>
      <entity name="minus_function" supertypes="unary_function_call"/>
      <entity abstract.supertype="YES" name="mismatched_donor_mesh" super.expression="ONEOF (structured_donor_mesh, unstructured_donor_mesh)">
         <explicit name="donor">
            <typename name="mesh"/>
         </explicit>
         <inverse attribute="donor" entity="mismatched_mesh_region" name="connect"/>
      </entity>
      <entity abstract.supertype="YES" name="mismatched_mesh_connection" super.expression="ONEOF (mismatched_mesh_region, mesh_overset_hole)" supertypes="mesh_connectivity">
         <explicit name="points">
            <typename name="indices_group"/>
         </explicit>
         <explicit name="gridloc">
            <typename name="mesh_location"/>
         </explicit>
      </entity>
      <entity name="mismatched_mesh_region" supertypes="mismatched_mesh_connection">
         <explicit name="donor">
            <typename name="mismatched_donor_mesh"/>
         </explicit>
         <explicit name="kind">
            <typename name="mismatched_region_type"/>
         </explicit>
         <where expression="donor.donor :&lt;&gt;: SELF\mesh_connectivity.current" label="wr1"/>
      </entity>
      <entity name="mod_expression" supertypes="binary_numeric_expression"/>
      <entity name="model_action_domain" supertypes="numerical_model">
         <explicit name="initial">
            <typename name="model_state_domain"/>
         </explicit>
         <explicit name="final">
            <typename name="model_state_domain"/>
         </explicit>
      </entity>
      <entity name="model_product_domain" supertypes="numerical_model">
         <explicit name="temporal_parts">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="model_action_domain"/>
         </explicit>
      </entity>
      <entity name="model_product_domain_with_mesh" supertypes="model_product_domain">
         <explicit name="model_mesh">
            <typename name="mesh"/>
         </explicit>
      </entity>
      <entity name="model_property_distribution">
         <explicit name="creating_software">
            <typename name="text"/>
         </explicit>
         <explicit name="domain">
            <typename name="numerical_model"/>
         </explicit>
         <explicit name="range">
            <typename name="general_property"/>
         </explicit>
      </entity>
      <entity name="model_state_domain" supertypes="numerical_model"/>
      <entity name="modified_geometric_tolerance" supertypes="geometric_tolerance">
         <explicit name="modifier">
            <typename name="limit_condition"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="modified_solid" super.expression="ONEOF (edge_blended_solid, sculptured_solid, shelled_solid, modified_solid_with_placed_configuration)" supertypes="solid_model">
         <explicit name="rationale">
            <typename name="text"/>
         </explicit>
         <explicit name="base_solid">
            <typename name="base_solid_select"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="modified_solid_with_placed_configuration" super.expression="ONEOF (solid_with_depression, solid_with_protrusion, solid_with_shape_element_pattern)" supertypes="modified_solid">
         <explicit name="placing">
            <typename name="axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="moments_of_inertia_representation" supertypes="representation">
         <where expression="(SIZEOF(SELF.items) = 1) AND &#10; (SIZEOF( QUERY( i &lt;* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND &#10;  (i.name = 'moments of inertia matrix') )) = 1)" label="WR1"/>
         <where expression="SIZEOF( QUERY( i &lt;* SELF.items | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND &#10;  ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'LIST_REPRESENTATION_ITEM' IN TYPEOF(i\compound_representation_item.item_element)) AND &#10;  value_range_aggregate_rep_item (i\compound_representation_item.item_element) )) = 1" label="WR2"/>
      </entity>
      <entity name="mult_expression" supertypes="multiple_arity_numeric_expression"/>
      <entity name="multi_language_attribute_assignment" supertypes="attribute_value_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="multi_language_attribute_item"/>
         </explicit>
         <derived expression="language_indication[1]\attribute_classification_assignment.assigned_class" name="translation_language">
            <typename name="language"/>
         </derived>
         <inverse attribute="items" entity="attribute_language_assignment" name="language_indication">
            <inverse.aggregate lower="1" type="SET" upper="1"/>
         </inverse>
         <where expression="(SELF\attribute_value_assignment.role.name = 'alternate language')" label="WR1"/>
         <where expression="SIZEOF( QUERY( ala &lt;* language_indication |  &#10;   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND &#10;   (ala\attribute_classification_assignment.role.name='translated') )) = 1" label="WR2"/>
         <where expression="SELF\attribute_value_assignment.attribute_name &lt;&gt; ''" label="WR3"/>
         <where expression="SIZEOF(QUERY(ci &lt;* items |&#10;SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |&#10;(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND &#10;(ata.translation_language :=: translation_language) ))&gt;1 )) =0" label="WR4"/>
         <where expression="SIZEOF(QUERY(ci &lt;* items |&#10;SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |&#10; (ata\attribute_classification_assignment.role.name='primary') AND&#10; (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND &#10; (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))&gt;0 )) =0" label="WR5"/>
      </entity>
      <entity abstract.supertype="YES" name="multiple_arity_boolean_expression" super.expression="ONEOF (and_expression, or_expression)" supertypes="boolean_expression multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="boolean_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="multiple_arity_function_call" super.expression="ONEOF (maximum_function, minimum_function)" supertypes="multiple_arity_numeric_expression"/>
      <entity abstract.supertype="YES" name="multiple_arity_generic_expression" supertypes="generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="multiple_arity_numeric_expression" super.expression="ONEOF (plus_expression, mult_expression, multiple_arity_function_call)" supertypes="numeric_expression multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
      </entity>
      <entity name="multiple_mesh_block">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="connectivities">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="mesh_connectivity"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="name_assignment">
         <explicit name="assigned_name">
            <typename name="label"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="name_attribute">
         <explicit name="attribute_value">
            <typename name="label"/>
         </explicit>
         <explicit name="named_item">
            <typename name="name_attribute_select"/>
         </explicit>
      </entity>
      <entity name="named_unit" super.expression="ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, ratio_unit)">
         <explicit name="dimensions">
            <typename name="dimensional_exponents"/>
         </explicit>
      </entity>
      <entity name="next_assembly_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="no_symmetry_control" supertypes="symmetry_control"/>
      <entity name="nodal_dof_reduction" supertypes="constraint_element">
         <explicit name="required_node">
            <typename name="node_output_reference"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="freedoms">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="degree_of_freedom"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="nodal_freedom_action_definition" supertypes="nodal_freedom_and_value_definition">
         <explicit name="action">
            <typename name="action_type"/>
         </explicit>
      </entity>
      <entity name="nodal_freedom_and_value_definition" super.expression="ONEOF (nodal_freedom_values, nodal_freedom_action_definition)" supertypes="state_definition">
         <explicit name="node">
            <typename name="node_output_reference"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="degrees_of_freedom">
            <typename name="freedoms_list"/>
         </explicit>
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <where expression="SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values)" label="WR1"/>
      </entity>
      <entity name="nodal_freedom_values" supertypes="nodal_freedom_and_value_definition"/>
      <entity name="node" super.expression="node_with_vector ANDOR node_with_solution_coordinate_system" supertypes="node_representation">
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' &#10;              IN TYPEOF (item))) = 1" label="WR1"/>
      </entity>
      <entity name="node_analysis_message" supertypes="analysis_message">
         <explicit name="node">
            <typename name="node_output_reference"/>
         </explicit>
      </entity>
      <entity name="node_definition" supertypes="shape_aspect"/>
      <entity name="node_geometric_relationship">
         <explicit name="node_ref">
            <typename name="node_or_node_group"/>
         </explicit>
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item.item)" label="WR1"/>
      </entity>
      <entity name="node_group" supertypes="fea_group">
         <explicit name="nodes">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="node_representation"/>
         </explicit>
      </entity>
      <entity name="node_representation" super.expression="ONEOF (node, dummy_node, geometric_node)" supertypes="representation">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
      </entity>
      <entity name="node_sequence">
         <explicit name="order_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="control_ref">
            <typename name="control"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="nodes">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="node_representation"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="order_id"/>
            <unique.attribute attribute="control_ref"/>
         </unique>
      </entity>
      <entity name="node_set" supertypes="geometric_representation_item">
         <explicit name="nodes">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="node_representation"/>
         </explicit>
         <where expression="SIZEOF (QUERY (tmp &lt;* nodes | &#10;               tmp\representation.context_of_items :&lt;&gt;:&#10;               nodes[1]\representation.context_of_items)) = 0" label="WR1"/>
      </entity>
      <entity name="node_topological_relationship">
         <explicit name="item">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="node_ref">
            <typename name="node_representation"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF (item.item)" label="WR1"/>
      </entity>
      <entity name="node_with_solution_coordinate_system" supertypes="node">
         <where expression="( (SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'FEA_AXIS2_PLACEMENT_3D' &#10;              IN TYPEOF (item))) = 1)&#10;          AND&#10;          (SELF\representation.context_of_items\&#10;       geometric_representation_context.coordinate_space_dimension = 3) )&#10;     OR&#10;       ( (SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'FEA_AXIS2_PLACEMENT_2D' &#10;              IN TYPEOF (item))) = 1)&#10;          AND&#10;          (SELF\representation.context_of_items\&#10;       geometric_representation_context.coordinate_space_dimension = 2) )" label="WR1"/>
      </entity>
      <entity name="node_with_vector" supertypes="node">
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIRECTION' &#10;              IN TYPEOF (item))) = 1" label="WR1"/>
      </entity>
      <entity name="non_manifold_surface_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1)))&#10;       = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (it &lt;* SELF.items |&#10;       SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF (it)) = 1)) &gt; 0" label="WR2"/>
         <where expression="SIZEOF (QUERY (mi &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;       'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION'&#10;       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))&#10;       AND&#10;       (SIZEOF(QUERY (mr_it &lt;*&#10;       mi\mapped_item.mapping_source.mapped_representation.items |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL'&#10;       IN TYPEOF (mr_it)))) &gt; 0 )))) = 0" label="WR3"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE'] * TYPEOF (fa)) = 1)))&#10;       = 0))) = 0))) = 0" label="WR4"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (f_sf &lt;* QUERY (fa &lt;* cfs.cfs_faces |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (fa))) |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (f_sf))&#10;       OR&#10;       (nmsf_surface_check(f_sf\face_surface.face_geometry))))) = 0))) &#10;       = 0))) = 0" label="WR5"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (o_fa &lt;* QUERY (fa &lt;* cfs.cfs_faces |&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF (fa))) |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF &#10;       (o_fa\oriented_face.face_element))&#10;       OR&#10;       (nmsf_surface_check&#10;       (o_fa\oriented_face.face_element\face_surface.face_geometry)))))&#10;       = 0))) = 0))) = 0" label="WR6"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (bnds &lt;* fa.bounds |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP']&#10;       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0" label="WR7"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items|&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF &#10;       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0" label="WR8"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe_cv &lt;* QUERY (oe &lt;* &#10;       elp_fbnds\path.edge_list |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE'] * &#10;       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) &#10;       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0" label="WR9"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list |&#10;       NOT (nmsf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) &#10;       = 0))) = 0)))) = 0))) = 0))) = 0" label="WR10"/>
         <where expression="SIZEOF (QUERY(fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list|&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF&#10;       (oe.edge_element.edge_start))&#10;       AND&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN&#10;       TYPEOF (oe.edge_element.edge_end))))) &#10;       = 0))) = 0)))) = 0))) = 0))) = 0" label="WR11"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;*&#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (elp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (QUERY (oe &lt;* elp_fbnds\path.edge_list |&#10;       NOT ((SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF&#10;       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)&#10;       AND&#10;       (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF&#10;       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1&#10;       )))) = 0))) = 0)))) = 0))) = 0))) = 0" label="WR12"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;* &#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF&#10;       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) &#10;       = 0))) = 0" label="WR13"/>
         <where expression="SIZEOF (QUERY (fbsm &lt;* QUERY (it &lt;* SELF.items |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |&#10;       NOT (SIZEOF (QUERY (cfs &lt;* &#10;       fbsm\face_based_surface_model.fbsm_faces |&#10;       NOT (SIZEOF (QUERY (fa &lt;* cfs.cfs_faces |&#10;       NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF (fa))&#10;       OR&#10;       (SIZEOF (QUERY (vlp_fbnds &lt;* QUERY (bnds &lt;* fa.bounds |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |&#10;       NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE'] * TYPEOF&#10;       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) &#10;       = 1))) = 0)))) = 0))) = 0))) = 0" label="WR14"/>
      </entity>
      <entity name="not_expression" supertypes="unary_boolean_expression">
         <explicit name="operand">
            <typename name="boolean_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="null_representation_item" supertypes="representation_item"/>
      <entity abstract.supertype="YES" name="numeric_defined_function" super.expression="ONEOF (integer_defined_function, real_defined_function)" supertypes="numeric_expression defined_function"/>
      <entity abstract.supertype="YES" name="numeric_expression" super.expression="ONEOF (simple_numeric_expression, unary_numeric_expression, binary_numeric_expression, multiple_arity_numeric_expression, length_function, value_function, numeric_defined_function)" supertypes="expression">
         <derived expression="is_int_expr (SELF)" name="is_int">
            <builtintype type="LOGICAL"/>
         </derived>
         <derived expression="is_SQL_mappable (SELF)" name="sql_mappable">
            <builtintype type="LOGICAL"/>
         </derived>
      </entity>
      <entity name="numeric_variable" super.expression="ONEOF (int_numeric_variable, real_numeric_variable)" supertypes="simple_numeric_expression variable">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_NUMERIC_VARIABLE' &#10;&#9;&#9;&#9;IN TYPEOF(SELF) ) OR&#10;&#9;&#9;&#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_NUMERIC_VARIABLE' &#10;&#9;&#9;&#9;IN TYPEOF(SELF) )" label="WR1"/>
      </entity>
      <entity name="numerical_model">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="creating_software">
            <typename name="text"/>
         </explicit>
         <explicit name="intended_analysis_code">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="text"/>
         </explicit>
         <explicit name="analysis_type">
            <typename name="text"/>
         </explicit>
         <where expression="temporal_spatial_domain_for_model(SELF)" label="wr1"/>
      </entity>
      <entity name="object_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="odd_function" supertypes="unary_boolean_expression">
         <explicit name="operand">
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <where expression="is_int_expr(operand)" label="WR1"/>
      </entity>
      <entity name="offset_curve_2d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <where expression="basis_curve.dim = 2" label="WR1"/>
      </entity>
      <entity name="offset_curve_3d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="ref_direction">
            <typename name="direction"/>
         </explicit>
         <where expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)" label="WR1"/>
      </entity>
      <entity name="offset_surface" supertypes="surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="one_direction_repeat_factor" supertypes="geometric_representation_item">
         <explicit name="repeat_factor">
            <typename name="vector"/>
         </explicit>
      </entity>
      <entity name="open_shell" supertypes="connected_face_set"/>
      <entity name="or_expression" supertypes="multiple_arity_boolean_expression"/>
      <entity name="ordinal_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_year_number"/>
         </explicit>
         <where expression="(NOT leap_year(SELF.year_component) AND { 1 &lt;= day_component &lt;= 365 }) OR (leap_year(SELF.year_component) AND { 1 &lt;= day_component &lt;= 366 })" label="WR1"/>
      </entity>
      <entity name="ordinate_dimension" supertypes="projection_directed_callout"/>
      <entity name="organization">
         <explicit name="id" optional="YES">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="organization_assignment">
         <explicit name="assigned_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="role">
            <typename name="organization_role"/>
         </explicit>
      </entity>
      <entity name="organization_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="related_organization">
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="organization_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organizational_address" supertypes="address">
         <explicit name="organizations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organizational_project">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="responsible_organizations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="organizational_project_assignment">
         <explicit name="assigned_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
         <explicit name="role">
            <typename name="organizational_project_role"/>
         </explicit>
      </entity>
      <entity name="organizational_project_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
         <explicit name="related_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
      </entity>
      <entity name="organizational_project_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="oriented_closed_shell" supertypes="closed_shell">
         <explicit name="closed_shell_element">
            <typename name="closed_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="conditional_reverse(SELF.orientation,&#10;                                   SELF.closed_shell_element.cfs_faces)" name="cfs_faces">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' &#10;                IN TYPEOF (SELF.closed_shell_element))" label="WR1"/>
      </entity>
      <entity name="oriented_edge" supertypes="edge">
         <explicit name="edge_element">
            <typename name="edge"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="boolean_choose (SELF.orientation,&#10;                                            SELF.edge_element.edge_start,&#10;                                            SELF.edge_element.edge_end)" name="edge_start">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <derived expression="boolean_choose (SELF.orientation,&#10;                                            SELF.edge_element.edge_end,&#10;                                            SELF.edge_element.edge_start)" name="edge_end">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element))" label="WR1"/>
      </entity>
      <entity name="oriented_face" supertypes="face">
         <explicit name="face_element">
            <typename name="face"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="conditional_reverse(SELF.orientation,SELF.face_element.bounds)" name="bounds">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face_bound"/>
            <redeclaration entity-ref="face"/>
         </derived>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF (SELF.face_element))" label="WR1"/>
      </entity>
      <entity name="oriented_open_shell" supertypes="open_shell">
         <explicit name="open_shell_element">
            <typename name="open_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="conditional_reverse(SELF.orientation,&#10;                                      SELF.open_shell_element.cfs_faces)" name="cfs_faces">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_OPEN_SHELL' &#10;                IN TYPEOF (SELF.open_shell_element))" label="WR1"/>
      </entity>
      <entity name="oriented_path" supertypes="path">
         <explicit name="path_element">
            <typename name="path"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived expression="conditional_reverse(SELF.orientation,&#10;                                         SELF.path_element.edge_list)" name="edge_list">
            <aggregate lower="1" type="LIST" unique="YES" upper="?"/>
            <typename name="oriented_edge"/>
            <redeclaration entity-ref="path"/>
         </derived>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF (SELF.path_element))" label="WR1"/>
      </entity>
      <entity name="oriented_surface" supertypes="surface">
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="outer_boundary_curve" supertypes="boundary_curve"/>
      <entity name="output_request_state" supertypes="state">
         <explicit name="steps">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="control_analysis_step"/>
         </explicit>
      </entity>
      <entity name="over_riding_styled_item" supertypes="styled_item">
         <explicit name="over_ridden_style">
            <typename name="styled_item"/>
         </explicit>
      </entity>
      <entity name="package_product_concept_feature" supertypes="product_concept_feature">
         <where expression="NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) )" label="WR1"/>
         <where expression="SIZEOF ( QUERY &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;cfr &lt;* USEDIN ( SELF , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;| &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AND &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( SIZEOF ( QUERY &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;ipcf &lt;* USEDIN ( cfr , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.' +&#9;'CONDITION' ) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;| &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)= 1 &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)&gt;0" label="WR2"/>
      </entity>
      <entity name="parabola" supertypes="conic">
         <explicit name="focal_dist">
            <typename name="length_measure"/>
         </explicit>
         <where expression="focal_dist &lt;&gt; 0.0" label="WR1"/>
      </entity>
      <entity name="parallel_composed_function" supertypes="maths_function multiple_arity_generic_expression">
         <explicit name="source_of_domain">
            <typename name="maths_space_or_function"/>
         </explicit>
         <explicit name="prep_functions">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="maths_function"/>
         </explicit>
         <explicit name="final_function">
            <typename name="maths_function_select"/>
         </explicit>
         <derived expression="convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function)" name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="generic_expression"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </derived>
         <where expression="no_cyclic_domain_reference(source_of_domain, [SELF])" label="WR1"/>
         <where expression="expression_is_constant(domain_from(source_of_domain))" label="WR2"/>
         <where expression="parallel_composed_function_domain_check(domain_from(source_of_domain),&#10;       prep_functions)" label="WR3"/>
         <where expression="parallel_composed_function_composability_check(prep_functions, final_function)" label="WR4"/>
      </entity>
      <entity name="parallel_offset" supertypes="derived_shape_aspect">
         <explicit name="offset">
            <typename name="measure_with_unit"/>
         </explicit>
         <where expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1" label="WR1"/>
      </entity>
      <entity name="parallelism_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt; 3" label="WR1"/>
      </entity>
      <entity name="parametric_curve_3d_element_coordinate_direction" supertypes="fea_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <where expression="SELF\geometric_representation_item.dim=3" label="WR1"/>
      </entity>
      <entity name="parametric_curve_3d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="direction">
            <typename name="parametric_curve_3d_element_coordinate_direction"/>
         </explicit>
      </entity>
      <entity name="parametric_representation_context" supertypes="representation_context"/>
      <entity name="parametric_surface_2d_element_coordinate_system" supertypes="fea_representation_item"/>
      <entity name="parametric_surface_3d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="axis">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(axis &gt;= 1) AND (axis &lt;= 2)" label="WR1"/>
      </entity>
      <entity name="parametric_volume_2d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="axis">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="(axis &gt;= 1) AND (axis &lt;= 2)" label="WR1"/>
      </entity>
      <entity name="parametric_volume_3d_element_coordinate_system" supertypes="fea_representation_item">
         <explicit name="axis_1">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="axis_2">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="eu_angles">
            <typename name="euler_angles"/>
         </explicit>
         <where expression="(axis_1 &gt;= 1) AND (axis_1 &lt;= 3) AND&#10;        (axis_2 &gt;= 1) AND (axis_2 &lt;= 3) AND&#10;        NOT (axis_1 = axis_2)" label="WR1"/>
      </entity>
      <entity name="part_laminate_table" super.expression="ONEOF (composite_assembly_table, ply_laminate_table)" supertypes="laminate_table"/>
      <entity name="partial_derivative_expression" supertypes="unary_generic_expression">
         <explicit name="d_variables">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="maths_variable"/>
         </explicit>
         <explicit name="extension">
            <typename name="extension_options"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="derivand">
            <typename name="generic_expression"/>
         </derived>
         <where expression="has_values_space (derivand)" label="WR1"/>
         <where expression="space_is_continuum (values_space_of (derivand))" label="WR2"/>
         <where expression="SIZEOF (QUERY (vbl &lt;* d_variables | (NOT subspace_of (values_space_of (vbl),&#10;    the_reals)) AND (NOT subspace_of (values_space_of (vbl), the_complex_numbers))&#10;    )) = 0" label="WR3"/>
      </entity>
      <entity name="partial_derivative_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="d_variables">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="input_selector"/>
         </explicit>
         <explicit name="extension">
            <typename name="extension_options"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="derivand">
            <typename name="maths_function"/>
         </derived>
         <where expression="space_is_continuum (derivand.range)" label="WR1"/>
         <where expression="partial_derivative_check (derivand.domain, d_variables)" label="WR2"/>
      </entity>
      <entity name="partial_document_with_structured_text_representation_assignment" supertypes="applied_document_usage_constraint_assignment characterized_object"/>
      <entity name="path" super.expression="ONEOF (edge_loop, oriented_path)" supertypes="topological_representation_item">
         <explicit name="edge_list">
            <aggregate lower="1" type="LIST" unique="YES" upper="?"/>
            <typename name="oriented_edge"/>
         </explicit>
         <where expression="path_head_to_tail(SELF)" label="WR1"/>
      </entity>
      <entity name="pcurve" supertypes="curve">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where expression="SIZEOF(reference_to_curve\representation.items) = 1" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])" label="WR2"/>
         <where expression="reference_to_curve\representation.items[1]\&#10;                               geometric_representation_item.dim =2" label="WR3"/>
      </entity>
      <entity name="percentage_laminate_definition" supertypes="product_definition">
         <where expression="SIZEOF (QUERY (pdr &lt;* USEDIN (SELF, &#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;                             'RELATING_PRODUCT_DEFINITION') |&#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN&#10;                             TYPEOF (pdr))) &gt; 0" label="WR1"/>
      </entity>
      <entity name="percentage_laminate_table" supertypes="zone_structural_makeup"/>
      <entity name="percentage_ply_definition" supertypes="product_definition">
         <where expression="SIZEOF (QUERY (pdr &lt;* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;        'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |&#10;        ('STRUCTURAL_ANALYSIS_DESIGN.PERCENTAGE_LAMINATE_DEFINITION' &#10;        IN TYPEOF (pdr.related_product_definition)) AND&#10;        (pdr.name = 'makeup and properties'))) = 0" label="WR1"/>
      </entity>
      <entity name="perpendicular_to" supertypes="derived_shape_aspect">
         <where expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1" label="WR1"/>
      </entity>
      <entity name="perpendicularity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3" label="WR1"/>
      </entity>
      <entity name="person">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="last_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="first_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="middle_names" optional="YES">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="prefix_titles" optional="YES">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="suffix_titles" optional="YES">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="label"/>
         </explicit>
         <where expression="EXISTS(last_name) OR EXISTS(first_name)" label="WR1"/>
      </entity>
      <entity name="person_and_organization">
         <explicit name="the_person">
            <typename name="person"/>
         </explicit>
         <explicit name="the_organization">
            <typename name="organization"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="person_and_organization_address" supertypes="organizational_address personal_address">
         <explicit name="organizations">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="organization"/>
            <redeclaration entity-ref="organizational_address"/>
         </explicit>
         <explicit name="people">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="person"/>
            <redeclaration entity-ref="personal_address"/>
         </explicit>
         <where expression="SIZEOF(QUERY(pao &lt;* USEDIN (SELF\personal_address.people[1], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="person_and_organization_assignment">
         <explicit name="assigned_person_and_organization">
            <typename name="person_and_organization"/>
         </explicit>
         <explicit name="role">
            <typename name="person_and_organization_role"/>
         </explicit>
      </entity>
      <entity name="person_and_organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="person_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="person_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="person_type_definition">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="formation">
            <typename name="person_type_definition_formation"/>
         </explicit>
      </entity>
      <entity name="person_type_definition_formation">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_person_type">
            <typename name="person_type"/>
         </explicit>
      </entity>
      <entity name="personal_address" supertypes="address">
         <explicit name="people">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="person"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="physical_action_domain" supertypes="temporal_spatial_domain">
         <explicit name="initial">
            <typename name="physical_state_domain"/>
         </explicit>
         <explicit name="final">
            <typename name="physical_state_domain"/>
         </explicit>
      </entity>
      <entity name="physical_breakdown_context" supertypes="breakdown_context"/>
      <entity name="physical_element_usage" supertypes="breakdown_element_usage"/>
      <entity name="physical_product_domain" supertypes="temporal_spatial_domain">
         <explicit name="temporal_parts">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="physical_action_domain"/>
         </explicit>
      </entity>
      <entity name="physical_state_domain" supertypes="temporal_spatial_domain"/>
      <entity name="picture_representation" supertypes="presentation_view">
         <explicit name="items">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="picture_representation_item_select"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <inverse attribute="unit" entity="presentation_size" name="size"/>
         <where expression="SIZEOF(QUERY(item &lt;* items | &#10;        'PICTURE_REPRESENTATION_MIM.STYLED_ITEM' IN TYPEOF(item))) = 1" label="WR1"/>
         <where expression="SIZEOF (QUERY (se &lt;* QUERY (item &lt;* SELF.items &#10;                   | ('PICTURE_REPRESENTATION_MIM.STYLED_ITEM' IN TYPEOF (item))) &#10;         | NOT ('PICTURE_REPRESENTATION_MIM.PICTURE_REPRESENTATION_ITEM' &#10;                IN TYPEOF (se\styled_item.item)) )) = 0" label="WR2"/>
      </entity>
      <entity abstract.supertype="YES" name="picture_representation_item" super.expression="ONEOF (externally_defined_picture_representation_item, predefined_picture_representation_item)" supertypes="bytes_representation_item"/>
      <entity name="placed_datum_target_feature" supertypes="datum_target">
         <derived expression="get_shape_aspect_property_definition_representations(SELF)" name="representation_associations">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="property_definition_representation"/>
         </derived>
         <where expression="SELF.description IN ['point','line','rectangle','circle', 'circular line']" label="WR1"/>
         <where expression="SIZEOF (QUERY (pdr &lt;* representation_associations | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF (pdr.used_representation) )) = 1" label="WR2"/>
         <where expression="valid_datum_target_parameters(SELF)" label="WR3"/>
      </entity>
      <entity name="placed_feature" supertypes="shape_aspect"/>
      <entity name="placement" super.expression="ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d)" supertypes="geometric_representation_item">
         <explicit name="location">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="planar_box" supertypes="planar_extent">
         <explicit name="placement">
            <typename name="axis2_placement"/>
         </explicit>
      </entity>
      <entity name="planar_extent" supertypes="geometric_representation_item">
         <explicit name="size_in_x">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="size_in_y">
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="plane" supertypes="elementary_surface"/>
      <entity name="plane_2d_element_property" super.expression="simple_plane_2d_element_property">
         <explicit name="depth">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="plane_angle_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="plane_angle_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="plane_curve_2d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve_element_purpose"/>
         </explicit>
         <explicit name="assumption">
            <typename name="plane_2d_element_purpose"/>
         </explicit>
      </entity>
      <entity name="plane_curve_2d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_2d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="plane_curve_2d_element_descriptor"/>
         </explicit>
         <explicit name="property">
            <typename name="curve_2d_element_property"/>
         </explicit>
         <explicit name="depth_property">
            <typename name="plane_2d_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="model_ref.type_of_2d_analysis = planar" label="WR1"/>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'CURVE_2D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) = 1" label="WR2"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR3"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR4"/>
         <where expression="required_0d_nodes (&#10;        SELF\element_representation.node_list)" label="FU1"/>
      </entity>
      <entity name="plane_surface_2d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_element_purpose"/>
         </explicit>
         <explicit name="assumption">
            <typename name="plane_2d_element_purpose"/>
         </explicit>
      </entity>
      <entity name="plane_surface_2d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_2d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="plane_surface_2d_element_descriptor"/>
         </explicit>
         <explicit name="property">
            <typename name="surface_element_property"/>
         </explicit>
         <explicit name="depth_property">
            <typename name="plane_2d_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="model_ref.type_of_2d_analysis = planar" label="WR1"/>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'PARAMETRIC_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'ALIGNED_SURFACE_2D_ELEMENT_COORDINATE_SYSTEM' &#10;              IN TYPEOF (item))) = 1" label="WR2"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_BENDING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR3"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR4"/>
         <where expression="required_1d_nodes (&#10;        SELF\element_representation.node_list,&#10;        element_descriptor\element_descriptor.topology_order)" label="FU1"/>
      </entity>
      <entity name="plane_volume_2d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_element_purpose"/>
         </explicit>
         <explicit name="shape">
            <typename name="element_2d_shape"/>
         </explicit>
         <explicit name="assumption">
            <typename name="plane_2d_element_purpose"/>
         </explicit>
      </entity>
      <entity name="plane_volume_2d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_2d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="plane_volume_2d_element_descriptor"/>
         </explicit>
         <explicit name="depth_property">
            <typename name="plane_2d_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="model_ref.type_of_2d_analysis = planar" label="WR1"/>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'PARAMETRIC_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'ARBITRARY_VOLUME_2D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) = 1" label="WR2"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR3"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR4"/>
         <where expression="required_2d_nodes (&#10;        SELF\element_representation.node_list,&#10;        element_descriptor.shape,&#10;        element_descriptor\element_descriptor.topology_order)" label="FU1"/>
      </entity>
      <entity name="plus_expression" supertypes="multiple_arity_numeric_expression"/>
      <entity name="plus_minus_tolerance">
         <explicit name="range">
            <typename name="tolerance_method_definition"/>
         </explicit>
         <explicit name="toleranced_dimension">
            <typename name="dimensional_characteristic"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="toleranced_dimension"/>
         </unique>
      </entity>
      <entity name="ply_laminate_definition" supertypes="product_definition">
         <where expression="SIZEOF (QUERY (pdr &lt;* USEDIN (SELF, &#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;                             'RELATING_PRODUCT_DEFINITION') |&#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN&#10;                             TYPEOF (pdr))) = 1" label="WR1"/>
      </entity>
      <entity name="ply_laminate_sequence_definition" supertypes="product_definition">
         <where expression="SIZEOF (QUERY (pdr &lt;* USEDIN (SELF, &#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;                             'RELATING_PRODUCT_DEFINITION') |&#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN&#10;                             TYPEOF (pdr))) &gt; 0" label="WR1"/>
      </entity>
      <entity name="ply_laminate_table" supertypes="part_laminate_table"/>
      <entity name="point" super.expression="ONEOF (cartesian_point, point_on_curve, point_on_surface, point_replica, degenerate_pcurve)" supertypes="geometric_representation_item"/>
      <entity name="point_and_vector" supertypes="compound_representation_item geometric_representation_item">
         <explicit name="item_element">
            <typename name="point_and_vector_members"/>
            <redeclaration entity-ref="compound_representation_item"/>
         </explicit>
      </entity>
      <entity name="point_constraint" supertypes="constraint_element">
         <explicit name="required_point">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="freedoms_and_coefficients">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="freedom_and_coefficient"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF (required_point.item)) OR&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (required_point.item))" label="WR1"/>
      </entity>
      <entity name="point_element_matrix" super.expression="ONEOF (stationary_mass, grounded_spring, grounded_damper)"/>
      <entity name="point_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="matrix_set">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="point_element_matrix"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'FEA_AXIS2_PLACEMENT_3D'&#10;              IN TYPEOF (item))) = 1" label="WR1"/>
         <where expression="required_0d_nodes (&#10;        SELF\element_representation.node_list)" label="FU1"/>
      </entity>
      <entity name="point_freedom_action_definition" supertypes="point_freedom_and_value_definition">
         <explicit name="action">
            <typename name="action_type"/>
         </explicit>
      </entity>
      <entity name="point_freedom_and_value_definition" super.expression="ONEOF (point_freedom_values, point_freedom_action_definition)" supertypes="state_definition">
         <explicit name="required_point">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="degrees_of_freedom">
            <typename name="freedoms_list"/>
         </explicit>
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <where expression="SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values)" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT' IN TYPEOF (required_point.item)) OR&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (required_point.item))" label="WR2"/>
      </entity>
      <entity name="point_freedom_values" supertypes="point_freedom_and_value_definition"/>
      <entity name="point_on_curve" supertypes="point">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="point_parameter">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_on_surface" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="point_parameter_u">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="point_parameter_v">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_path" supertypes="compound_representation_item geometric_representation_item">
         <explicit name="item_element">
            <typename name="point_path_members"/>
            <redeclaration entity-ref="compound_representation_item"/>
         </explicit>
      </entity>
      <entity name="point_replica" supertypes="point">
         <explicit name="parent_pt">
            <typename name="point"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where expression="transformation.dim = parent_pt.dim" label="WR1"/>
         <where expression="acyclic_point_replica (SELF,parent_pt)" label="WR2"/>
      </entity>
      <entity name="point_representation" supertypes="shape_representation">
         <where expression="SIZEOF(QUERY(it &lt;* SELF\representation.items | ( NOT (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'FEA_AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1)))) = 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(it &lt;* SELF\representation.items | (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_SET', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM'] * TYPEOF(it)) = 1))) &gt;= 1" label="WR2"/>
      </entity>
      <entity name="point_style" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="marker">
            <typename name="marker_select"/>
         </explicit>
         <explicit name="marker_size">
            <typename name="size_select"/>
         </explicit>
         <explicit name="marker_colour">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="polar_complex_number_literal" supertypes="generic_literal">
         <explicit name="radius">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="angle">
            <builtintype type="REAL"/>
         </explicit>
         <where expression="radius &gt;= 0" label="WR1"/>
         <where expression="{ 0 &lt;= angle &lt; 2*PI }" label="WR2"/>
      </entity>
      <entity name="polar_complex_number_region" supertypes="maths_space generic_literal">
         <explicit name="centre">
            <typename name="complex_number_literal"/>
         </explicit>
         <explicit name="distance_constraint">
            <typename name="real_interval"/>
         </explicit>
         <explicit name="direction_constraint">
            <typename name="finite_real_interval"/>
         </explicit>
         <where expression="min_exists(distance_constraint) AND (real_min(distance_constraint) &gt;= 0.0)" label="WR1"/>
         <where expression="{-PI &lt;= direction_constraint.min &lt; PI}" label="WR2"/>
         <where expression="direction_constraint.max - direction_constraint.min &lt;= 2.0*PI" label="WR3"/>
         <where expression="(direction_constraint.max - direction_constraint.min &lt; 2.0*PI) OR&#10;       (direction_constraint.min_closure = open)" label="WR4"/>
         <where expression="(direction_constraint.max - direction_constraint.min &lt; 2.0*PI) OR&#10;       (direction_constraint.max_closure = open) OR&#10;       (direction_constraint.min = -PI)" label="WR5"/>
         <where expression="(real_min(distance_constraint) &gt; 0.0) OR max_exists(distance_constraint) OR&#10;       (direction_constraint.max - direction_constraint.min &lt; 2.0*PI) OR&#10;       (direction_constraint.max_closure = open)" label="WR6"/>
      </entity>
      <entity name="polar_point" supertypes="cartesian_point">
         <explicit name="r">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="theta">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived expression="[r*cos(theta), r*sin(theta)]" name="coordinates">
            <aggregate lower="1" type="LIST" upper="3"/>
            <typename name="length_measure"/>
            <redeclaration entity-ref="cartesian_point"/>
         </derived>
         <where expression="r &gt;= 0.0" label="WR1"/>
      </entity>
      <entity name="poly_loop" supertypes="loop geometric_representation_item">
         <explicit name="polygon">
            <aggregate lower="3" type="LIST" unique="YES" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="polyline" supertypes="bounded_curve">
         <explicit name="points">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="position_in_organization">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="position_in_organization_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="position_tolerance" supertypes="geometric_tolerance">
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3)" label="WR1"/>
      </entity>
      <entity name="positioned_sketch" supertypes="geometric_representation_item">
         <explicit name="sketch_basis">
            <typename name="sketch_basis_select"/>
         </explicit>
         <explicit name="auxiliary_elements">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="auxiliary_geometric_representation_item"/>
         </explicit>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE' IN &#10;    TYPEOF(sketch_basis)) AND NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN&#10;    TYPEOF(sketch_basis\curve_bounded_surface.basis_surface)))" label="WR1"/>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF(sketch_basis)) AND&#10;    NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(sketch_basis\face_surface.face_geometry)))" label="WR2"/>
         <where expression="SIZEOF(QUERY(q &lt;* auxiliary_elements | (SIZEOF(TYPEOF(q) * &#10;    ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT','AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE']) = 0))) = 0" label="WR3"/>
         <where expression="SIZEOF(QUERY(q &lt;* auxiliary_elements | &#10;    q\geometric_representation_item.dim &lt;&gt; 3)) = 0" label="WR4"/>
      </entity>
      <entity name="power_expression" supertypes="binary_numeric_expression"/>
      <entity name="power_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="power_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.watt)" label="WR1"/>
      </entity>
      <entity name="pre_defined_colour" supertypes="pre_defined_item colour"/>
      <entity name="pre_defined_curve_font" supertypes="pre_defined_item"/>
      <entity name="pre_defined_dimension_symbol" supertypes="pre_defined_symbol">
         <where expression="SELF.name IN [ 'arc length' , 'conical taper' , 'counterbore' , 'countersink' , 'depth' , 'diameter' , 'plus minus' , 'radius' , 'slope' , 'spherical diameter' , 'spherical radius' , 'square']" label="WR1"/>
      </entity>
      <entity name="pre_defined_geometrical_tolerance_symbol" supertypes="pre_defined_symbol">
         <where expression="SELF.name IN ['angularity' , 'basic dimension' , 'blanked datum reference' , 'circular runout' , 'circularity' , 'concentricity' , 'cylindricity' , 'datum target identification' , 'diameter' , 'filled datum reference' , 'flatness' , 'least material condition' , 'maximum material condition' , 'parallelism' , 'perpendicularity' , 'position' , 'profile of a line' , 'profile of a surface' , 'projected tolerance zone' , 'regardless of feature size' , 'straightness' , 'symmetry' , 'total runout' ]" label="WR1"/>
      </entity>
      <entity name="pre_defined_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="pre_defined_marker" supertypes="pre_defined_item"/>
      <entity name="pre_defined_point_marker_symbol" supertypes="pre_defined_marker pre_defined_symbol">
         <where expression="SELF.name IN ['asterisk','circle','dot','plus','square','triangle','x']" label="WR1"/>
      </entity>
      <entity name="pre_defined_surface_condition_symbol" supertypes="pre_defined_symbol">
         <where expression="SELF.name IN ['000' , '010' , '020' , '030' , '040' , '050' , '060' , '070' , '001' , '011' , '021' , '031' , '041' , '051' , '061' , '071' , '100' , '110' , '120' , '130' , '140' , '150' , '160' , '170' , '101' , '111' , '121' , '131' , '141' , '151' , '161' , '171' , '200' , '210' , '220' , '230' , '240' , '250' , '260' , '270' , '201' , '211' , '221' , '231' , '241' , '251' , '261' , '271']" label="WR1"/>
      </entity>
      <entity name="pre_defined_surface_side_style" supertypes="pre_defined_item"/>
      <entity name="pre_defined_symbol" supertypes="pre_defined_item"/>
      <entity name="pre_defined_terminator_symbol" supertypes="pre_defined_symbol">
         <where expression="SELF.name IN ['blanked arrow', 'blanked box', 'blanked dot', 'blanked triangle', 'dimension origin', 'filled arrow', 'filled box', 'filled dot', 'integral symbol', 'open arrow', 'slash', 'unfilled arrow', 'unfilled triangle', 'filled triangle']" label="WR1"/>
      </entity>
      <entity name="pre_defined_text_font" supertypes="pre_defined_item"/>
      <entity name="pre_defined_tile" supertypes="pre_defined_item"/>
      <entity name="precision_qualifier">
         <explicit name="precision_value">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="predefined_picture_representation_item" supertypes="picture_representation_item">
         <where expression="SELF\representation_item.name IN pre_defined_picture_representation_types" label="WR1"/>
      </entity>
      <entity name="presentation_area" supertypes="presentation_representation">
         <where expression="((SIZEOF (QUERY (ais &lt;* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                                 'AREA_IN_SET.AREA') | &#10;             SIZEOF (USEDIN (ais, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                  'PRESENTATION_SIZE.UNIT')) =1)) &gt; 0) OR&#10;            (SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                   'PRESENTATION_SIZE.UNIT')) =1))" label="WR1"/>
      </entity>
      <entity name="presentation_layer_assignment">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="layered_item"/>
         </explicit>
      </entity>
      <entity name="presentation_representation" super.expression="ONEOF (presentation_area, presentation_view)" supertypes="representation">
         <explicit name="context_of_items">
            <typename name="geometric_representation_context"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <where expression="SELF\representation.&#10;           context_of_items\geometric_representation_context.&#10;           coordinate_space_dimension = 2" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_AREA' IN TYPEOF (SELF))&#10;           OR&#10;           (SIZEOF (QUERY (prr &lt;* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                                'REPRESENTATION_RELATIONSHIP.REP_2') | &#10;           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION' IN&#10;           TYPEOF (prr\representation_relationship.rep_1))) &gt; 0)&#10;           OR &#10;           (SIZEOF(QUERY( rm &lt;* USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ &#10;                                             'REPRESENTATION_MAP.'+ &#10;                                             'MAPPED_REPRESENTATION') | &#10;           SIZEOF(QUERY( mi &lt;* USEDIN(rm, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                                          'MAPPED_ITEM.'+&#10;                                          'MAPPING_SOURCE') |   &#10;           SIZEOF(QUERY( rep &lt;* using_representations (mi) |                              &#10;                                        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                                        'PRESENTATION_REPRESENTATION' IN &#10;                                        TYPEOF (rep))) &gt; 0&#10;           )) &gt; 0))  &#10;           &gt; 0)" label="WR2"/>
      </entity>
      <entity name="presentation_set">
         <inverse attribute="in_set" entity="area_in_set" name="areas">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="presentation_size">
         <explicit name="unit">
            <typename name="presentation_size_assignment_select"/>
         </explicit>
         <explicit name="size">
            <typename name="planar_box"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="unit"/>
         </unique>
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION'&#10;           IN TYPEOF (SELF.unit)) AND&#10;           item_in_context (SELF.size, &#10;                            SELF.unit\representation.context_of_items)&#10;           )&#10;           OR&#10;           (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AREA_IN_SET'&#10;           IN TYPEOF (SELF.unit)) AND&#10;           (SIZEOF (QUERY ( ais &lt;* SELF.unit\area_in_set.in_set.areas |&#10;                NOT item_in_context (SELF.size, ais.area\representation.&#10;                                                context_of_items) )) = 0))" label="WR1"/>
      </entity>
      <entity name="presentation_style_assignment" supertypes="founded_item">
         <explicit name="styles">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="presentation_style_select"/>
         </explicit>
         <where expression="SIZEOF (QUERY (style1 &lt;* SELF.styles |&#10;           NOT (SIZEOF (QUERY (style2 &lt;* (SELF.styles - style1) |&#10;           NOT ((TYPEOF (style1) &lt;&gt; TYPEOF (style2)) OR&#10;             (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                       'SURFACE_STYLE_USAGE',&#10;                       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;                       'EXTERNALLY_DEFINED_STYLE'] *&#10;                     TYPEOF (style1)) = 1)&#10;           ))) = 0&#10;         ))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (style1 &lt;* SELF.styles |&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE' IN&#10;         TYPEOF(style1)&#10;         )) &lt;= 2" label="WR2"/>
         <where expression="SIZEOF (QUERY (style1 &lt;* SELF.styles |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE' IN TYPEOF (style1)) AND &#10;         (SIZEOF (QUERY (style2 &lt;* (SELF.styles - style1) |&#10;           ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_STYLE_USAGE' IN TYPEOF (style2)) AND &#10;           ((style1\surface_style_usage.side = both) OR &#10;           (style2\surface_style_usage.side = both) OR &#10;           (style1\surface_style_usage.side = style2\surface_style_usage.side)) )) &gt; 0))) = 0" label="WR3"/>
      </entity>
      <entity name="presentation_style_by_context" supertypes="presentation_style_assignment">
         <explicit name="style_context">
            <typename name="style_context_select"/>
         </explicit>
      </entity>
      <entity name="presentation_view" supertypes="presentation_representation"/>
      <entity abstract.supertype="YES" name="presented_item"/>
      <entity name="presented_item_representation">
         <explicit name="presentation">
            <typename name="presentation_representation_select"/>
         </explicit>
         <explicit name="item">
            <typename name="presented_item"/>
         </explicit>
      </entity>
      <entity name="pressure_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="pressure_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.pascal)" label="WR1"/>
      </entity>
      <entity name="procedural_representation" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="procedural_representation_sequence"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="procedural_representation_sequence" supertypes="representation_item">
         <explicit name="elements">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="suppressed_items">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="rationale">
            <typename name="text"/>
         </explicit>
         <where expression="SIZEOF(QUERY(q &lt;* suppressed_items | NOT (q IN elements))) = 0" label="WR1"/>
      </entity>
      <entity name="procedural_shape_representation" supertypes="procedural_representation shape_representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="procedural_shape_representation_sequence"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="procedural_shape_representation_sequence" supertypes="geometric_representation_item procedural_representation_sequence">
         <where expression="SIZEOF(QUERY(q &lt;* SELF\procedural_representation_sequence.elements&#10;    | NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_ITEM'&#10;    IN TYPEOF(q)))) = 0" label="WR1"/>
      </entity>
      <entity name="product">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="frame_of_reference">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="product_context"/>
         </explicit>
      </entity>
      <entity name="product_category">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="product_class" supertypes="product_concept characterized_object"/>
      <entity name="product_concept">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="market_context">
            <typename name="product_concept_context"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="id"/>
         </unique>
      </entity>
      <entity name="product_concept_context" supertypes="application_context_element">
         <explicit name="market_segment_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="feature">
            <typename name="product_concept_feature"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature_category" supertypes="group">
         <where expression="SIZEOF(QUERY&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;aga &lt;* USEDIN( SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) &#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;|&#10;     &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) &#10;     &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AND&#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;(&#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( aga.role.name &lt;&gt; 'specification category member' ) &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;OR &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( SIZEOF(QUERY &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;( &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;i &lt;* aga.items &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;| &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;AND &#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i))&#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)&#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;) &lt;&gt; SIZEOF (aga.items)&#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;)&#10;    &#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;) &#10;       &#9;&#9;&#9;&#9;&#9;&#9;) &#10;       &#9;&#9;&#9;&#9;) =0" label="WR1"/>
      </entity>
      <entity name="product_concept_feature_category_usage" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="product_concept_feature_category"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="category_usage_item"/>
         </explicit>
         <where expression="SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ]" label="WR1"/>
      </entity>
      <entity name="product_concept_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="related_product_concept">
            <typename name="product_concept"/>
         </explicit>
      </entity>
      <entity name="product_context" supertypes="application_context_element">
         <explicit name="discipline_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition" super.expression="ONEOF (composite_assembly_definition, composite_assembly_sequence_definition, laminate_table, percentage_laminate_definition, percentage_ply_definition, ply_laminate_definition, ply_laminate_sequence_definition, thickness_laminate_definition)">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="product_definition_context" supertypes="application_context_element">
         <explicit name="life_cycle_stage">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition_context_association">
         <explicit name="definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
         <explicit name="role">
            <typename name="product_definition_context_role"/>
         </explicit>
      </entity>
      <entity name="product_definition_context_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_definition_effectivity" supertypes="effectivity">
         <explicit name="usage">
            <typename name="product_definition_relationship"/>
         </explicit>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0" label="WR1"/>
      </entity>
      <entity name="product_definition_element_relationship" supertypes="group"/>
      <entity name="product_definition_formation">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_product">
            <typename name="product"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="id"/>
            <unique.attribute attribute="of_product"/>
         </unique>
      </entity>
      <entity name="product_definition_formation_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition_formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="related_product_definition_formation">
            <typename name="product_definition_formation"/>
         </explicit>
      </entity>
      <entity name="product_definition_formation_with_specified_source" supertypes="product_definition_formation">
         <explicit name="make_or_buy">
            <typename name="source"/>
         </explicit>
      </entity>
      <entity name="product_definition_group_assignment" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="product_definition_element_relationship"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="product_definition_or_product_definition_relationship"/>
         </explicit>
      </entity>
      <entity name="product_definition_occurrence_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="occurrence">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="occurrence_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <where expression="occurrence_usage.relating_product_definition :&lt;&gt;: &#10;       occurrence" label="WR1"/>
         <where expression="occurrence_usage.related_product_definition :&lt;&gt;: &#10;       occurrence" label="WR2"/>
         <where expression="occurrence.formation :=:&#10;       occurrence_usage.related_product_definition.formation" label="WR3"/>
      </entity>
      <entity name="product_definition_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="related_product_definition">
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="product_definition_shape" supertypes="property_definition">
         <unique label="UR1">
            <unique.attribute attribute="definition" entity-ref="property_definition"/>
         </unique>
         <where expression="SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) &gt; 0" label="WR1"/>
      </entity>
      <entity name="product_definition_substitute">
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="context_relationship">
            <typename name="product_definition_relationship"/>
         </explicit>
         <explicit name="substitute_definition">
            <typename name="product_definition"/>
         </explicit>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="context_relationship.related_product_definition :&lt;&gt;: substitute_definition" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="product_definition_usage" super.expression="ONEOF (make_from_usage_option, assembly_component_usage)" supertypes="product_definition_relationship">
         <unique label="UR1">
            <unique.attribute attribute="id" entity-ref="product_definition_relationship"/>
            <unique.attribute attribute="relating_product_definition" entity-ref="product_definition_relationship"/>
            <unique.attribute attribute="related_product_definition" entity-ref="product_definition_relationship"/>
         </unique>
         <where expression="acyclic_product_definition_relationship&#10;         (SELF,&#10;         [SELF\product_definition_relationship.related_product_definition],&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_USAGE')" label="WR1"/>
      </entity>
      <entity name="product_definition_with_associated_documents" supertypes="product_definition">
         <explicit name="documentation_ids">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="product_identification" supertypes="configuration_item characterized_object">
         <explicit name="item_concept">
            <typename name="product_class"/>
            <redeclaration entity-ref="configuration_item"/>
         </explicit>
         <where expression="SIZEOF(QUERY &#10;&#9;&#9;( cd &lt;* USEDIN ( SELF ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION' ) &#10;&#9;&#9;|&#10;     &#9;( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) &#10;     &#9;AND &#10;    &#9;( SIZEOF ( QUERY &#10;    &#9;( &#10;    &#9;prpc &lt;* USEDIN ( cd. design\product_definition_formation.of_product , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') &#10;    &#9;| &#10;        prpc. name IN ['part' , 'raw material' , 'tool'] ) ) &gt;0&#10;     &#9;) &#10;     &#9;) &#10;     &#9;) &lt;=1" label="WR1"/>
         <where expression="NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) &#10;&#9;&#9;&#9;XOR ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) )" label="WR2"/>
      </entity>
      <entity name="product_material_composition_relationship" supertypes="product_definition_relationship">
         <explicit name="class">
            <typename name="label"/>
         </explicit>
         <explicit name="constituent_amount">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="characterized_product_composition_value"/>
         </explicit>
         <explicit name="composition_basis">
            <typename name="label"/>
         </explicit>
         <explicit name="determination_method">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_related_product_category" supertypes="product_category">
         <explicit name="products">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="product"/>
         </explicit>
      </entity>
      <entity name="product_specification" supertypes="product_identification configurable_item"/>
      <entity name="product_view_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="discretised_model">
            <typename name="discretised_product_model_select"/>
         </explicit>
         <explicit name="idealised_product">
            <typename name="idealised_product_select"/>
         </explicit>
      </entity>
      <entity name="projected_zone_definition" supertypes="tolerance_zone_definition">
         <explicit name="projection_end">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="projected_length">
            <typename name="measure_with_unit"/>
         </explicit>
         <where expression="('NUMBER' IN TYPEOF&#10;       (projected_length\measure_with_unit.value_component)) AND&#10;       (projected_length\measure_with_unit.value_component &gt; 0.0)" label="WR1"/>
         <where expression="(derive_dimensional_exponents&#10;       (projected_length\measure_with_unit.unit_component)=&#10;        dimensional_exponents(1,0,0,0,0,0,0))" label="WR2"/>
      </entity>
      <entity name="projection_curve" supertypes="annotation_curve_occurrence"/>
      <entity name="projection_directed_callout" supertypes="draughting_callout">
         <where expression="SIZEOF(QUERY(p_1&lt;*SELF\draughting_callout.contents | &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN (TYPEOF(p_1))))=1" label="WR1"/>
         <where expression="SIZEOF(SELF\draughting_callout.contents) &gt;=2" label="WR2"/>
      </entity>
      <entity name="promissory_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="property_definition">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_definition"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="property_definition_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_property_definition">
            <typename name="property_definition"/>
         </explicit>
         <explicit name="related_property_definition">
            <typename name="property_definition"/>
         </explicit>
      </entity>
      <entity name="property_definition_representation">
         <explicit name="definition">
            <typename name="represented_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
         <derived expression="get_description_value(SELF)" name="description">
            <typename name="text"/>
         </derived>
         <derived expression="get_name_value(SELF)" name="name">
            <typename name="label"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1" label="WR2"/>
      </entity>
      <entity name="property_distribution_description">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="abstract_function">
            <typename name="maths_function"/>
         </explicit>
         <explicit name="domain_context">
            <typename name="maths_space_context"/>
         </explicit>
         <explicit name="physical_function">
            <typename name="property_distribution_select"/>
         </explicit>
         <explicit name="range_context">
            <typename name="maths_space_context"/>
         </explicit>
      </entity>
      <entity name="qualification">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="qualification_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="qualified_representation_item" supertypes="representation_item">
         <explicit name="qualifiers">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="value_qualifier"/>
         </explicit>
         <where expression="SIZEOF(QUERY(temp &lt;* qualifiers |&#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRECISION_QUALIFIER'&#10;             IN TYPEOF(temp))) &lt; 2" label="WR1"/>
      </entity>
      <entity name="qualitative_uncertainty" supertypes="uncertainty_qualifier">
         <explicit name="uncertainty_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="quantified_assembly_component_usage" supertypes="assembly_component_usage">
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
         <where expression="(NOT ('NUMBER' IN TYPEOF(quantity.value_component)))&#10;       OR (quantity.value_component &gt; 0)" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="quantifier_expression" supertypes="multiple_arity_generic_expression">
         <explicit name="variables">
            <aggregate lower="1" type="LIST" unique="YES" upper="?"/>
            <typename name="generic_variable"/>
         </explicit>
         <where expression="SIZEOF (QUERY (vrbl &lt;* variables | NOT (vrbl IN&#10;       SELF\multiple_arity_generic_expression.operands))) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (vrbl &lt;* variables | NOT ((schema_prefix +&#10;       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0" label="WR2"/>
      </entity>
      <entity name="quasi_uniform_curve" supertypes="b_spline_curve"/>
      <entity name="quasi_uniform_surface" supertypes="b_spline_surface"/>
      <entity name="radioactivity_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="radioactivity_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.becquerel)" label="WR1"/>
      </entity>
      <entity name="radius_dimension" supertypes="dimension_curve_directed_callout">
         <where expression="SIZEOF (QUERY (con &lt;* SELF.contents |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_CURVE' IN TYPEOF (con)))&lt;=1" label="WR1"/>
      </entity>
      <entity name="range_characteristic" supertypes="representation descriptive_representation_item">
         <where expression="NOT(SELF\representation.name IN ['tolerance', 'minimum tolerance', 'maximum tolerance', &#10;        'nominal tolerance', 'plus minus tolerance', 'symmetrical tolerance', 'statistical tolerance'])" label="WR1"/>
      </entity>
      <entity name="ratio_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="ratio_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="rational_b_spline_curve" supertypes="b_spline_curve">
         <explicit name="weights_data">
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived expression="list_to_array(weights_data,0,&#10;                                      upper_index_on_control_points)" name="weights">
            <aggregate lower="0" type="ARRAY" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where expression="SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.&#10;                                           control_points_list)" label="WR1"/>
         <where expression="curve_weights_positive(SELF)" label="WR2"/>
      </entity>
      <entity name="rational_b_spline_surface" supertypes="b_spline_surface">
         <explicit name="weights_data">
            <aggregate lower="2" type="LIST" upper="?"/>
            <aggregate lower="2" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)" name="weights">
            <aggregate lower="0" type="ARRAY" upper="0"/>
            <aggregate lower="0" type="ARRAY" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where expression="(SIZEOF(weights_data) =&#10;                     SIZEOF(SELF\b_spline_surface.control_points_list))&#10;           AND (SIZEOF(weights_data[1]) =&#10;                  SIZEOF(SELF\b_spline_surface.control_points_list[1]))" label="WR1"/>
         <where expression="surface_weights_positive(SELF)" label="WR2"/>
      </entity>
      <entity name="rational_representation_item" supertypes="representation_item slash_expression">
         <where expression="SIZEOF( QUERY( operand &lt;* SELF\binary_generic_expression.operands | &#10;        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_LITERAL' IN TYPEOF(operand)))) = 0" label="WR1"/>
      </entity>
      <entity name="rationalize_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <derived expression="SELF\unary_generic_expression.operand" name="fun">
            <typename name="maths_function"/>
         </derived>
         <where expression="(space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1)" label="WR1"/>
         <where expression="number_tuple_subspace_check(factor1(fun.range))" label="WR2"/>
         <where expression="space_dimension(factor1(fun.range)) &gt; 1" label="WR3"/>
      </entity>
      <entity abstract.supertype="YES" name="real_defined_function" supertypes="numeric_defined_function"/>
      <entity name="real_interval_from_min" supertypes="maths_space generic_literal">
         <explicit name="min">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="min_closure">
            <typename name="open_closed"/>
         </explicit>
      </entity>
      <entity name="real_interval_to_max" supertypes="maths_space generic_literal">
         <explicit name="max">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="max_closure">
            <typename name="open_closed"/>
         </explicit>
      </entity>
      <entity name="real_literal" supertypes="literal_number">
         <explicit name="the_value">
            <builtintype type="REAL"/>
            <redeclaration entity-ref="literal_number"/>
         </explicit>
      </entity>
      <entity name="real_numeric_variable" supertypes="numeric_variable"/>
      <entity name="real_representation_item" supertypes="representation_item real_literal"/>
      <entity name="real_tuple_literal" supertypes="generic_literal">
         <explicit name="lit_value">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="rectangular_composite_surface" supertypes="bounded_surface">
         <explicit name="segments">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="surface_patch"/>
         </explicit>
         <derived expression="SIZEOF(segments)" name="n_u">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="SIZEOF(segments[1])" name="n_v">
            <builtintype type="INTEGER"/>
         </derived>
         <where expression="SIZEOF(QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF (s))) = 0" label="WR1"/>
         <where expression="constraints_rectangular_composite_surface(SELF)" label="WR2"/>
      </entity>
      <entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="u1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="u2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="usense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="vsense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where expression="u1 &lt;&gt; u2" label="WR1"/>
         <where expression="v1 &lt;&gt; v2" label="WR2"/>
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))&#10;       AND  (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(basis_surface)))) OR&#10;      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))&#10;          OR (usense = (u2 &gt; u1))" label="WR3"/>
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))&#10;          OR&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))&#10;          OR (vsense = (v2 &gt; v1))" label="WR4"/>
      </entity>
      <entity name="referenced_modified_datum" supertypes="datum_reference">
         <explicit name="modifier">
            <typename name="limit_condition"/>
         </explicit>
      </entity>
      <entity name="regular_table_function" supertypes="linearized_table_function">
         <explicit name="increments">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <where expression="SIZEOF (increments) = SIZEOF (self\explicit_table_function.shape)" label="WR1"/>
         <where expression="extremal_position_check(self)" label="WR2"/>
      </entity>
      <entity name="reindexed_array_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="starting_indices">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <where expression="function_is_array(SELF\unary_generic_expression.operand)" label="WR1"/>
         <where expression="SIZEOF(starting_indices) = SIZEOF(shape_of_array(&#10;       SELF\unary_generic_expression.operand))" label="WR2"/>
      </entity>
      <entity name="relative_event_occurrence" supertypes="event_occurrence">
         <explicit name="base_event">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="offset">
            <typename name="time_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="rep_item_group" supertypes="group representation_item">
         <where expression="SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) &gt; 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(r &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION.' + 'ITEMS') | r.name = 'group representation')) &gt; 0" label="WR2"/>
         <where expression="SIZEOF(QUERY(ga &lt;* USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.' + 'ASSIGNED_GROUP') | ga.role.name &lt;&gt; 'group membership')) = 0" label="WR3"/>
         <where expression="SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_REPRESENTATION_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'TOPOLOGICAL_REPRESENTATION_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'MAPPED_ITEM','AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'STYLED_ITEM'] * TYPEOF(SELF)) = 1" label="WR4"/>
      </entity>
      <entity name="repackaging_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_function"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
         <explicit name="input_repack">
            <typename name="repackage_options"/>
         </explicit>
         <explicit name="output_repack">
            <typename name="repackage_options"/>
         </explicit>
         <explicit name="selected_output">
            <typename name="nonnegative_integer"/>
         </explicit>
         <where expression="(input_repack &lt;&gt; ro_wrap_as_tuple) OR&#10;       ((space_dimension(operand.domain) = 1) AND&#10;         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.domain))))" label="WR1"/>
         <where expression="(output_repack &lt;&gt; ro_unwrap_tuple) OR&#10;       ((space_dimension(operand.range) = 1) AND&#10;         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.range))))" label="WR2"/>
         <where expression="selected_output &lt;= space_dimension( repackage(&#10;       operand.range, output_repack))" label="WR3"/>
      </entity>
      <entity name="reparametrised_composite_curve_segment" supertypes="composite_curve_segment">
         <explicit name="param_length">
            <typename name="parameter_value"/>
         </explicit>
         <where expression="param_length &gt; 0.0" label="WR1"/>
      </entity>
      <entity name="representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="context_of_items">
            <typename name="representation_context"/>
         </explicit>
         <derived expression="get_id_value (SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <derived expression="get_description_value (SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&#10;         &lt;= 1" label="WR1"/>
         <where expression="SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&#10;         &lt;= 1" label="WR2"/>
      </entity>
      <entity name="representation_context">
         <explicit name="context_identifier">
            <typename name="identifier"/>
         </explicit>
         <explicit name="context_type">
            <typename name="text"/>
         </explicit>
         <inverse attribute="context_of_items" entity="representation" name="representations_in_context">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="representation_item" super.expression="ONEOF (binary_representation_item, compound_representation_item, mapped_item, value_representation_item, mapped_item, styled_item, boolean_representation_item, date_representation_item, date_time_representation_item, integer_representation_item, logical_representation_item, rational_representation_item, real_representation_item)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where expression="SIZEOF(using_representations(SELF)) &gt; 0" label="WR1"/>
      </entity>
      <entity name="representation_item_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_representation_item">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="related_representation_item">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="representation_map">
         <explicit name="mapping_origin">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="mapped_representation">
            <typename name="representation"/>
         </explicit>
         <inverse attribute="mapping_source" entity="mapped_item" name="map_usage">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="item_in_context(SELF.mapping_origin,&#10;        SELF.mapped_representation.context_of_items)" label="WR1"/>
      </entity>
      <entity name="representation_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="rep_1">
            <typename name="representation"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="representation_relationship_with_transformation" supertypes="representation_relationship">
         <explicit name="transformation_operator">
            <typename name="transformation"/>
         </explicit>
         <where expression="SELF\representation_relationship.rep_1.context_of_items&#10;           :&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items" label="WR1"/>
      </entity>
      <entity name="requirement_assigned_object" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="requirement_assigned_item"/>
         </explicit>
      </entity>
      <entity name="requirement_assignment" supertypes="characterized_object group"/>
      <entity name="requirement_source" supertypes="group"/>
      <entity name="requirement_view_definition_relationship" supertypes="product_definition_relationship"/>
      <entity name="resistance_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="resistance_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.ohm)" label="WR1"/>
      </entity>
      <entity name="resource_property">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="resource">
            <typename name="characterized_resource_definition"/>
         </explicit>
      </entity>
      <entity name="resource_property_representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="property">
            <typename name="resource_property"/>
         </explicit>
         <explicit name="representation">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="resource_requirement_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="restriction_function" supertypes="maths_function unary_generic_expression">
         <explicit name="operand">
            <typename name="maths_space"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="result">
         <explicit name="result_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="creating_software">
            <typename name="text"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="result_analysis_step" super.expression="ONEOF (result_linear_static_analysis_sub_step, result_linear_modes_and_frequencies_analysis_sub_step)" supertypes="analysis_step">
         <explicit name="analysis_result">
            <typename name="result"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="analysis_control" entity-ref="analysis_step"/>
            <unique.attribute attribute="analysis_result"/>
         </unique>
      </entity>
      <entity name="result_linear_modes_and_frequencies_analysis_sub_step" supertypes="result_analysis_step">
         <explicit name="states">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="calculated_state"/>
         </explicit>
      </entity>
      <entity name="result_linear_static_analysis_sub_step" supertypes="result_analysis_step">
         <explicit name="state">
            <typename name="calculated_state"/>
         </explicit>
      </entity>
      <entity name="revolved_area_solid" supertypes="swept_area_solid">
         <explicit name="axis">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived expression="representation_item('')||&#10;                    geometric_representation_item()|| curve()||&#10;                    line(axis.location, representation_item('')||&#10;                    geometric_representation_item()||&#10;                    vector(axis.z, 1.0))" name="axis_line">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="revolved_face_solid" supertypes="swept_face_solid">
         <explicit name="axis">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived expression="representation_item('')||&#10;                    geometric_representation_item()|| curve()||&#10;                    line(axis.location, representation_item('')||&#10;                    geometric_representation_item()||&#10;                    vector(axis.z, 1.0))" name="axis_line">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="revolved_face_solid_with_trim_conditions" supertypes="revolved_face_solid">
         <explicit name="first_trim_condition">
            <typename name="trim_condition_select"/>
         </explicit>
         <explicit name="second_trim_condition">
            <typename name="trim_condition_select"/>
         </explicit>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(first_trim_condition)) &#10;         OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' &#10;         IN TYPEOF(second_trim_condition)))" label="WR1"/>
         <where expression="NOT((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' &#10;         IN TYPEOF(first_trim_condition)) AND&#10;            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' &#10;         IN TYPEOF(second_trim_condition))) AND&#10;         (first_trim_condition = second_trim_condition))" label="WR2"/>
      </entity>
      <entity name="right_angular_wedge" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="x">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="y">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ltx">
            <typename name="length_measure"/>
         </explicit>
         <where expression="((0.0 &lt;= ltx) AND (ltx &lt; x))" label="WR1"/>
      </entity>
      <entity name="right_circular_cone" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="radius">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="semi_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where expression="radius &gt;= 0.0" label="WR1"/>
      </entity>
      <entity name="right_circular_cylinder" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="right_to_usage_association" supertypes="action_method_relationship">
         <explicit name="relating_method">
            <typename name="information_usage_right"/>
            <redeclaration entity-ref="action_method_relationship"/>
         </explicit>
         <explicit name="related_method">
            <typename name="information_right"/>
            <redeclaration entity-ref="action_method_relationship"/>
         </explicit>
         <derived expression="SELF\action_method_relationship.related_method" name="right_applied">
            <typename name="information_right"/>
         </derived>
         <derived expression="SELF\action_method_relationship.relating_method" name="right_usage">
            <typename name="information_usage_right"/>
         </derived>
      </entity>
      <entity name="rind">
         <explicit name="index_count">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="planes">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="role_association">
         <explicit name="role">
            <typename name="object_role"/>
         </explicit>
         <explicit name="item_with_role">
            <typename name="role_select"/>
         </explicit>
      </entity>
      <entity name="roundness_tolerance" supertypes="geometric_tolerance">
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))" label="WR1"/>
      </entity>
      <entity name="row_representation_item" supertypes="compound_representation_item">
         <explicit name="item_element">
            <typename name="list_representation_item"/>
            <redeclaration entity-ref="compound_representation_item"/>
         </explicit>
      </entity>
      <entity name="row_value" supertypes="compound_representation_item"/>
      <entity name="row_variable" supertypes="abstract_variable"/>
      <entity name="rule_action" supertypes="action"/>
      <entity name="rule_condition" supertypes="atomic_formula"/>
      <entity name="rule_definition" supertypes="rule_software_definition"/>
      <entity name="rule_set" supertypes="rule_software_definition"/>
      <entity name="rule_set_group" supertypes="rule_software_definition"/>
      <entity name="rule_software_definition" supertypes="product_definition"/>
      <entity name="rule_superseded_assignment" supertypes="action_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="rule_superseded_item"/>
         </explicit>
      </entity>
      <entity name="rule_supersedence" supertypes="rule_action"/>
      <entity name="ruled_surface_swept_area_solid" supertypes="surface_curve_swept_area_solid">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface)) AND&#10;         (SELF.reference_surface\b_spline_surface.u_degree = 1)" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(SELF.directrix)) OR&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(SELF.directrix\surface_curve.curve_3d))&#10;         AND&#10;         (SELF.directrix\surface_curve.curve_3d\b_spline_curve.degree =&#10;         SELF.reference_surface\b_spline_surface.v_degree))" label="WR2"/>
      </entity>
      <entity name="runout_zone_definition" supertypes="tolerance_zone_definition">
         <explicit name="orientation">
            <typename name="runout_zone_orientation"/>
         </explicit>
      </entity>
      <entity name="runout_zone_orientation">
         <explicit name="angle">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="runout_zone_orientation_reference_direction" supertypes="runout_zone_orientation">
         <explicit name="orientation_defining_relationship">
            <typename name="shape_aspect_relationship"/>
         </explicit>
      </entity>
      <entity name="same_discretised_action_model">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="equivalent_records">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="discretised_action_model_select"/>
         </explicit>
      </entity>
      <entity name="same_discretised_distribution_model">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="equivalent_records">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="discretised_distribution_model_select"/>
         </explicit>
      </entity>
      <entity name="same_discretised_state_model">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="equivalent_records">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="discretised_state_model_select"/>
         </explicit>
      </entity>
      <entity name="same_idealised_action">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="equivalent_records">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="idealised_action_select"/>
         </explicit>
      </entity>
      <entity name="same_idealised_distribution">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="equivalent_records">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="idealised_distribution_select"/>
         </explicit>
      </entity>
      <entity name="same_idealised_state">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="equivalent_records">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="idealised_state_select"/>
         </explicit>
      </entity>
      <entity name="satisfied_requirement" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="satisfies_requirement"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="satisfies_requirement" supertypes="group"/>
      <entity name="satisfying_item" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="satisfies_requirement"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="requirement_satisfaction_item"/>
         </explicit>
      </entity>
      <entity name="scalar_variable" supertypes="abstract_variable"/>
      <entity name="scattering_parameter" supertypes="polar_complex_number_literal">
         <where expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\polar_complex_number_literal ||&#10;       SELF\scattering_parameter))) = 0" label="WR1"/>
      </entity>
      <entity name="sculptured_solid" supertypes="modified_solid">
         <explicit name="sculpturing_element">
            <typename name="generalized_surface_select"/>
         </explicit>
         <explicit name="positive_side">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="seam_curve" supertypes="surface_curve">
         <where expression="SIZEOF(SELF\surface_curve.associated_geometry) = 2" label="WR1"/>
         <where expression="associated_surface(SELF\surface_curve.associated_geometry[1]) =&#10;           associated_surface(SELF\surface_curve.associated_geometry[2])" label="WR2"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN&#10;           TYPEOF(SELF\surface_curve.associated_geometry[1])" label="WR3"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN&#10;            TYPEOF(SELF\surface_curve.associated_geometry[2])" label="WR4"/>
      </entity>
      <entity name="security_classification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="security_level">
            <typename name="security_classification_level"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="security_classification_assignment">
         <explicit name="assigned_security_classification">
            <typename name="security_classification"/>
         </explicit>
         <derived expression="get_role(SELF)" name="role">
            <typename name="object_role"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="security_classification_level">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="selector_function" supertypes="maths_function generic_literal">
         <explicit name="selector">
            <typename name="input_selector"/>
         </explicit>
         <explicit name="source_of_domain">
            <typename name="maths_space_or_function"/>
         </explicit>
         <where expression="no_cyclic_domain_reference(source_of_domain, [SELF])" label="WR1"/>
         <where expression="expression_is_constant(domain_from(source_of_domain))" label="WR2"/>
      </entity>
      <entity name="serial_numbered_effectivity" supertypes="effectivity">
         <explicit name="effectivity_start_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_end_id" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="series_composed_function" supertypes="maths_function multiple_arity_generic_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="maths_function"/>
            <redeclaration entity-ref="multiple_arity_generic_expression"/>
         </explicit>
         <where expression="composable_sequence(SELF\multiple_arity_generic_expression.operands)" label="WR1"/>
      </entity>
      <entity name="shape_aspect">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_shape">
            <typename name="product_definition_shape"/>
         </explicit>
         <explicit name="product_definitional">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="shape_aspect_associativity" supertypes="shape_aspect_relationship">
         <where expression="SELF.relating_shape_aspect.product_definitional" label="WR1"/>
         <where expression="NOT (SELF.related_shape_aspect.product_definitional)" label="WR2"/>
      </entity>
      <entity name="shape_aspect_deriving_relationship" supertypes="shape_aspect_relationship">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DERIVED_SHAPE_ASPECT' IN&#10;TYPEOF&#10;            (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT)" label="WR1"/>
      </entity>
      <entity name="shape_aspect_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="related_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <derived expression="get_id_value(SELF)" name="id">
            <typename name="identifier"/>
         </derived>
         <where expression="SIZEOF(USEDIN(SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="shape_definition_representation" supertypes="property_definition_representation">
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(SELF.definition)) OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition))" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation)" label="WR2"/>
      </entity>
      <entity name="shape_dimension_representation" supertypes="shape_representation">
         <where expression="SIZEOF (QUERY (temp &lt;* SELF\representation.items | &#10;    NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' &#10;        IN TYPEOF (temp)))) = 0" label="WR1"/>
         <where expression="SIZEOF (SELF\representation.items) &lt;= 3" label="WR2"/>
         <where expression="SIZEOF (QUERY (pos_mri &lt;* QUERY (real_mri &lt;*&#10;        SELF\representation.items | 'REAL' IN TYPEOF&#10;        (real_mri\measure_with_unit.value_component) ) |        &#10;     NOT  (pos_mri\measure_with_unit.value_component &gt; 0.0 ))) = 0" label="WR3"/>
      </entity>
      <entity name="shape_feature_definition" supertypes="characterized_object"/>
      <entity name="shape_representation" supertypes="representation"/>
      <entity name="shape_representation_relationship" supertypes="representation_relationship">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2))" label="WR1"/>
      </entity>
      <entity name="shape_representation_with_parameters" supertypes="shape_representation">
         <where expression="SIZEOF( QUERY( i &lt;* SELF.items | SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLACEMENT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(i)) = 1 )) = SIZEOF(SELF.items)" label="WR1"/>
      </entity>
      <entity name="shell_based_surface_model" supertypes="geometric_representation_item">
         <explicit name="sbsm_boundary">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where expression="constraints_geometry_shell_based_surface_model(SELF)" label="WR1"/>
      </entity>
      <entity name="shell_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="sbwm_boundary">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where expression="constraints_geometry_shell_based_wireframe_model(SELF)" label="WR1"/>
      </entity>
      <entity name="shell_based_wireframe_shape_representation" supertypes="shape_representation">
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| NOT ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0" label="WR1"/>
         <where expression="SIZEOF ( &#10;QUERY ( it &lt;* SELF.items| ( SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) &gt;= 1" label="WR2"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( ws &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( &#10;QUERY ( eloop &lt;* &#10;QUERY ( wsb &lt;* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( &#10;QUERY ( el &lt;* eloop\path.edge_list| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF (el.edge_element)) )) = 0) )) = 0) )) = 0) )) = 0" label="WR3"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( ws &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( &#10;QUERY ( eloop &lt;* &#10;QUERY ( wsb &lt;* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( &#10;QUERY ( pline_el &lt;* &#10;QUERY ( el &lt;* eloop\path.edge_list| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF (el.edge_element\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_el.edge_element\edge_curve.edge_geometry\polyline.points) &gt; 2) )) = 0) )) = 0) )) = 0) )) = 0" label="WR4"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( ws &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( &#10;QUERY ( eloop &lt;* &#10;QUERY ( wsb &lt;* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( &#10;QUERY ( el &lt;* eloop\path.edge_list| NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0) )) = 0" label="WR5"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( ws &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( &#10;QUERY ( eloop &lt;* &#10;QUERY ( wsb &lt;* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( &#10;QUERY ( el &lt;* eloop\path.edge_list| NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_start)) AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_end))) )) = 0) )) = 0) )) = 0) )) = 0" label="WR6"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( ws &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( &#10;QUERY ( eloop &lt;* &#10;QUERY ( wsb &lt;* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( &#10;QUERY ( el &lt;* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0) )) = 0" label="WR7"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( ws &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( &#10;QUERY ( vloop &lt;* &#10;QUERY ( wsb &lt;* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (vloop\vertex_loop.loop_vertex)) )) = 0) )) = 0) )) = 0" label="WR8"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( ws &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( &#10;QUERY ( vloop &lt;* &#10;QUERY ( wsb &lt;* ws\wire_shell.wire_shell_extent| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0) )) = 0" label="WR9"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( vs &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex)) )) = 0) )) = 0" label="WR10"/>
         <where expression="SIZEOF ( &#10;QUERY ( sbwm &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( &#10;QUERY ( vs &lt;* &#10;QUERY ( sb &lt;* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0" label="WR11"/>
         <where expression="SIZEOF ( &#10;QUERY ( mi &lt;* &#10;QUERY ( it &lt;* SELF.items| ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0" label="WR12"/>
         <where expression="SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3" label="WR13"/>
      </entity>
      <entity name="shelled_solid" super.expression="ONEOF (double_offset_shelled_solid, complex_shelled_solid)" supertypes="modified_solid">
         <explicit name="deleted_face_set">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face_surface"/>
         </explicit>
         <explicit name="thickness">
            <typename name="length_measure"/>
         </explicit>
         <where expression="thickness &lt;&gt; 0" label="WR1"/>
      </entity>
      <entity name="si_absorbed_dose_unit" supertypes="absorbed_dose_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.gray" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_capacitance_unit" supertypes="capacitance_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.farad" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_conductance_unit" supertypes="conductance_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.siemens" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_dose_equivalent_unit" supertypes="dose_equivalent_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.sievert" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_electric_charge_unit" supertypes="electric_charge_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.coulomb" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_electric_potential_unit" supertypes="electric_potential_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.volt" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_energy_unit" supertypes="energy_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.joule" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_force_unit" supertypes="force_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.newton" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_frequency_unit" supertypes="frequency_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.hertz" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_illuminance_unit" supertypes="illuminance_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.lux" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_inductance_unit" supertypes="inductance_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.henry" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_magnetic_flux_density_unit" supertypes="magnetic_flux_density_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.tesla" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_magnetic_flux_unit" supertypes="magnetic_flux_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.weber" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_power_unit" supertypes="power_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.watt" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_pressure_unit" supertypes="pressure_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.pascal" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_radioactivity_unit" supertypes="radioactivity_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.becquerel" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_resistance_unit" supertypes="resistance_unit si_unit">
         <where expression="SELF\si_unit.name = si_unit_name.ohm" label="WR1"/>
         <where expression="NOT EXISTS(SELF\derived_unit.name)" label="WR2"/>
      </entity>
      <entity name="si_unit" supertypes="named_unit">
         <explicit name="prefix" optional="YES">
            <typename name="si_prefix"/>
         </explicit>
         <explicit name="name">
            <typename name="si_unit_name"/>
         </explicit>
         <derived expression="dimensions_for_si_unit(name)" name="dimensions">
            <typename name="dimensional_exponents"/>
            <redeclaration entity-ref="named_unit"/>
         </derived>
         <where expression="NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MASS_UNIT' IN TYPEOF(SELF)) AND&#10;             (SIZEOF(USEDIN(SELF,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DERIVED_UNIT_ELEMENT.UNIT')) &gt; 0)) OR&#10;            (prefix = si_prefix.kilo)" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="simple_boolean_expression" super.expression="ONEOF (boolean_literal, boolean_variable)" supertypes="boolean_expression simple_generic_expression"/>
      <entity name="simple_clause" supertypes="compound_representation_item"/>
      <entity abstract.supertype="YES" name="simple_generic_expression" super.expression="ONEOF (generic_literal, generic_variable)" supertypes="generic_expression"/>
      <entity abstract.supertype="YES" name="simple_numeric_expression" super.expression="ONEOF (literal_number, numeric_variable)" supertypes="numeric_expression simple_generic_expression"/>
      <entity name="simple_plane_2d_element_property" supertypes="plane_2d_element_property"/>
      <entity abstract.supertype="YES" name="simple_string_expression" super.expression="ONEOF (string_literal, string_variable)" supertypes="string_expression simple_generic_expression"/>
      <entity name="simulation_run">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="simulated">
            <typename name="numerical_model"/>
         </explicit>
         <explicit name="results">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="model_property_distribution"/>
         </explicit>
      </entity>
      <entity name="sin_function" supertypes="unary_function_call"/>
      <entity name="single_point_constraint_element" supertypes="constraint_element">
         <explicit name="required_node">
            <typename name="node_output_reference"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="freedoms_and_values">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="freedom_and_coefficient"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="single_point_constraint_element_values" supertypes="state_definition">
         <explicit name="element">
            <typename name="single_point_constraint_element"/>
         </explicit>
         <explicit name="degrees_of_freedom">
            <typename name="freedoms_list"/>
         </explicit>
         <explicit name="b">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <where expression="SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (b)" label="WR1"/>
      </entity>
      <entity name="slash_expression" supertypes="binary_numeric_expression"/>
      <entity name="smeared_material_definition" supertypes="zone_structural_makeup"/>
      <entity name="solid_angle_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="solid_angle_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="solid_constraint" supertypes="constraint_element">
         <explicit name="required_solid">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="freedoms_and_coefficients">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="freedom_and_coefficient"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_MODEL' IN TYPEOF (required_solid.item)" label="WR1"/>
      </entity>
      <entity name="solid_curve_font" supertypes="pre_defined_curve_font"/>
      <entity name="solid_freedom_action_definition" supertypes="solid_freedom_and_value_definition">
         <explicit name="action">
            <typename name="action_type"/>
         </explicit>
      </entity>
      <entity name="solid_freedom_and_value_definition" super.expression="ONEOF (solid_freedom_values, solid_freedom_action_definition)" supertypes="state_definition">
         <explicit name="required_solid">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="degrees_of_freedom">
            <typename name="freedoms_list"/>
         </explicit>
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <where expression="SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values)" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_MODEL' IN TYPEOF (required_solid.item)" label="WR2"/>
      </entity>
      <entity name="solid_freedom_values" supertypes="solid_freedom_and_value_definition"/>
      <entity name="solid_model" super.expression="ONEOF (csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid, solid_replica)" supertypes="geometric_representation_item"/>
      <entity name="solid_replica" supertypes="solid_model">
         <explicit name="parent_solid">
            <typename name="solid_model"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator_3d"/>
         </explicit>
         <where expression="acyclic_solid_replica(SELF, parent_solid)" label="WR1"/>
         <where expression="parent_solid\geometric_representation_item.dim = 3" label="WR2"/>
      </entity>
      <entity name="solid_with_angle_based_chamfer" supertypes="solid_with_chamfered_edges">
         <explicit name="offset_distance">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="left_offset">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="offset_angle">
            <typename name="positive_plane_angle_measure"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="solid_with_chamfered_edges" super.expression="ONEOF (solid_with_single_offset_chamfer, solid_with_double_offset_chamfer, solid_with_angle_based_chamfer)" supertypes="edge_blended_solid"/>
      <entity name="solid_with_circular_pattern" super.expression="solid_with_incomplete_circular_pattern" supertypes="solid_with_shape_element_pattern">
         <explicit name="replicate_count">
            <typename name="positive_integer"/>
         </explicit>
         <explicit name="angular_spacing">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="radial_alignment">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="reference_point">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="solid_with_circular_pocket" supertypes="solid_with_pocket">
         <explicit name="pocket_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <where expression="SELF\solid_with_pocket.floor_blend_radius &lt;= pocket_radius" label="WR1"/>
      </entity>
      <entity name="solid_with_circular_protrusion" supertypes="solid_with_protrusion">
         <explicit name="protrusion_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="solid_with_conical_bottom_round_hole" supertypes="solid_with_stepped_round_hole">
         <explicit name="semi_apex_angle">
            <typename name="positive_plane_angle_measure"/>
         </explicit>
         <explicit name="tip_radius">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <where expression="tip_radius &lt; &#10;          SELF\solid_with_stepped_round_hole.segment_radii[segments]" label="WR1"/>
      </entity>
      <entity name="solid_with_constant_radius_edge_blend" supertypes="edge_blended_solid">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="solid_with_curved_slot" supertypes="solid_with_slot">
         <explicit name="slot_centreline">
            <typename name="bounded_curve"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="solid_with_depression" super.expression="solid_with_through_depression ANDOR ONEOF (solid_with_hole, solid_with_pocket, solid_with_slot, solid_with_groove)" supertypes="modified_solid_with_placed_configuration">
         <explicit name="depth">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="solid_with_double_offset_chamfer" supertypes="solid_with_chamfered_edges">
         <explicit name="left_offset_distance">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="right_offset_distance">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="solid_with_flat_bottom_round_hole" supertypes="solid_with_stepped_round_hole">
         <explicit name="fillet_radius">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <where expression="fillet_radius &lt; &#10;          SELF\solid_with_stepped_round_hole.segment_radii[segments]" label="WR1"/>
      </entity>
      <entity name="solid_with_general_pocket" supertypes="solid_with_pocket">
         <explicit name="profile">
            <typename name="positioned_sketch"/>
         </explicit>
         <explicit name="reference_point">
            <typename name="point"/>
         </explicit>
         <where expression="SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE',&#10;    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE'] * TYPEOF(profile.sketch_basis)) = 1" label="WR1"/>
         <where expression="profile IN using_items(reference_point,[])" label="WR2"/>
      </entity>
      <entity name="solid_with_general_protrusion" supertypes="solid_with_protrusion">
         <explicit name="profile">
            <typename name="positioned_sketch"/>
         </explicit>
         <explicit name="reference_point">
            <typename name="point"/>
         </explicit>
         <where expression="SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE',&#10;    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE'] * TYPEOF(profile.sketch_basis)) = 1" label="WR1"/>
         <where expression="profile IN using_items(reference_point,[])" label="WR2"/>
      </entity>
      <entity name="solid_with_groove" supertypes="solid_with_depression">
         <explicit name="groove_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="groove_width">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="draft_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="floor_fillet_radius">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <explicit name="external_groove">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'&#10;         IN TYPEOF(SELF))" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="solid_with_hole" super.expression="solid_with_stepped_round_hole" supertypes="solid_with_depression"/>
      <entity name="solid_with_incomplete_circular_pattern" supertypes="solid_with_circular_pattern">
         <explicit name="omitted_instances">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="positive_integer"/>
         </explicit>
         <where expression="SIZEOF(omitted_instances) &lt;&#10;         SELF\solid_with_circular_pattern.replicate_count" label="WR1"/>
         <where expression="SIZEOF(QUERY(q &lt;* omitted_instances | q &gt; &#10;         SELF\solid_with_circular_pattern.replicate_count)) = 0" label="WR2"/>
      </entity>
      <entity name="solid_with_incomplete_rectangular_pattern" supertypes="solid_with_rectangular_pattern">
         <explicit name="omitted_instances">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="positive_integer"/>
         </explicit>
         <where expression="NOT([1,1] IN omitted_instances)" label="WR1"/>
         <where expression="SIZEOF(omitted_instances) &lt;&#10;         ((SELF\solid_with_rectangular_pattern.row_count *&#10;           SELF\solid_with_rectangular_pattern.column_count) - 1)" label="WR2"/>
         <where expression="SIZEOF(QUERY(q &lt;* omitted_instances |&#10;         ((q[1] &gt; SELF\solid_with_rectangular_pattern.row_count) OR&#10;          (q[2] &gt; SELF\solid_with_rectangular_pattern.column_count)))) = 0" label="WR3"/>
      </entity>
      <entity abstract.supertype="YES" name="solid_with_pocket" super.expression="ONEOF (solid_with_rectangular_pocket, solid_with_circular_pocket, solid_with_general_pocket)" supertypes="solid_with_depression">
         <explicit name="floor_blend_radius">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <explicit name="draft_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="solid_with_protrusion" super.expression="ONEOF (solid_with_circular_protrusion, solid_with_rectangular_protrusion, solid_with_general_protrusion)" supertypes="modified_solid_with_placed_configuration">
         <explicit name="protrusion_height">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="protrusion_draft_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="solid_with_rectangular_pattern" super.expression="solid_with_incomplete_rectangular_pattern" supertypes="solid_with_shape_element_pattern">
         <explicit name="row_count">
            <typename name="positive_integer"/>
         </explicit>
         <explicit name="column_count">
            <typename name="positive_integer"/>
         </explicit>
         <explicit name="row_spacing">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="column_spacing">
            <typename name="length_measure"/>
         </explicit>
         <where expression="(row_count * column_count) &gt; 1" label="WR1"/>
      </entity>
      <entity name="solid_with_rectangular_pocket" supertypes="solid_with_pocket">
         <explicit name="pocket_length">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="pocket_width">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="corner_radius">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <where expression="(corner_radius &lt; pocket_width/2) &#10;         AND (corner_radius &lt; pocket_length/2)" label="WR1"/>
      </entity>
      <entity name="solid_with_rectangular_protrusion" supertypes="solid_with_protrusion">
         <explicit name="protrusion_length">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="protrusion_width">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="protrusion_corner_radius">
            <typename name="non_negative_length_measure"/>
         </explicit>
         <where expression="(protrusion_corner_radius &lt;= protrusion_width/2) &#10;         AND (protrusion_corner_radius &lt;= protrusion_length/2)" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="solid_with_shape_element_pattern" super.expression="ONEOF (solid_with_circular_pattern, solid_with_rectangular_pattern)" supertypes="modified_solid_with_placed_configuration">
         <explicit name="replicated_element">
            <typename name="modified_solid_with_placed_configuration"/>
         </explicit>
      </entity>
      <entity name="solid_with_single_offset_chamfer" supertypes="solid_with_chamfered_edges">
         <explicit name="offset_distance">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="solid_with_slot" super.expression="ONEOF (solid_with_trapezoidal_section_slot, solid_with_tee_section_slot) AND ONEOF (solid_with_straight_slot, solid_with_curved_slot)" supertypes="solid_with_depression">
         <explicit name="slot_width">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="closed_ends">
            <aggregate lower="2" type="LIST" upper="2"/>
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="end_exit_faces">
            <aggregate lower="2" type="LIST" upper="2"/>
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="face_surface"/>
         </explicit>
         <where expression="NOT(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION' IN&#10;         TYPEOF(SELF)) AND (closed_ends = [FALSE,FALSE]))" label="WR1"/>
         <where expression="NOT(((closed_ends[1] = TRUE) AND (SIZEOF(end_exit_faces[1]) &lt;&gt; 0))&#10;         OR ((closed_ends[2] = TRUE) AND (SIZEOF(end_exit_faces[2]) &lt;&gt; 0)))" label="WR2"/>
      </entity>
      <entity name="solid_with_spherical_bottom_round_hole" supertypes="solid_with_stepped_round_hole">
         <explicit name="sphere_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <where expression="sphere_radius &gt;= &#10;          SELF\solid_with_stepped_round_hole.segment_radii[segments]" label="WR1"/>
      </entity>
      <entity name="solid_with_stepped_round_hole" super.expression="solid_with_stepped_round_hole_and_conical_transitions ANDOR ONEOF (solid_with_flat_bottom_round_hole, solid_with_conical_bottom_round_hole, solid_with_spherical_bottom_round_hole)" supertypes="solid_with_hole">
         <explicit name="segments">
            <typename name="positive_integer"/>
         </explicit>
         <explicit name="segment_radii">
            <aggregate lower="1" type="LIST" upper="0"/>
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="segment_depths">
            <aggregate lower="1" type="LIST" upper="0"/>
            <typename name="positive_length_measure"/>
         </explicit>
         <derived expression="compute_total_depth(SELF)" name="depth">
            <typename name="positive_length_measure"/>
            <redeclaration entity-ref="solid_with_depression"/>
         </derived>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'&#10;       IN TYPEOF(SELF)) AND (SIZEOF(TYPEOF(SELF) *&#10;       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_SPHERICAL_BOTTOM_ROUND_HOLE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE']) &#10;       &lt;&gt; 0))" label="WR1"/>
      </entity>
      <entity name="solid_with_stepped_round_hole_and_conical_transitions" supertypes="solid_with_stepped_round_hole">
         <explicit name="conical_transitions">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="conical_stepped_hole_transition"/>
         </explicit>
         <where expression="SIZEOF (conical_transitions) &lt;= &#10;         (SELF\solid_with_stepped_round_hole.segments + 1)" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_THROUGH_DEPRESSION'&#10;         IN TYPEOF(SELF)) XOR (SIZEOF(conical_transitions) &lt;= &#10;         SELF\solid_with_stepped_round_hole.segments)" label="WR2"/>
         <where expression="validate_countersink_radii(SELF)" label="WR3"/>
      </entity>
      <entity name="solid_with_straight_slot" supertypes="solid_with_slot">
         <explicit name="slot_length">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="solid_with_tee_section_slot" supertypes="solid_with_slot">
         <explicit name="tee_section_width">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="collar_depth">
            <typename name="positive_length_measure"/>
         </explicit>
         <where expression="collar_depth &lt; SELF\solid_with_depression.depth" label="WR1"/>
         <where expression="tee_section_width &gt; SELF\solid_with_slot.slot_width" label="WR2"/>
      </entity>
      <entity name="solid_with_through_depression" supertypes="solid_with_depression">
         <explicit name="exit_faces">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="face_surface"/>
         </explicit>
         <where expression="SIZEOF(TYPEOF(SELF) *&#10;         ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_HOLE',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_POCKET',&#10;          'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_SLOT']) = 1" label="WR1"/>
      </entity>
      <entity name="solid_with_trapezoidal_section_slot" supertypes="solid_with_slot">
         <explicit name="draft_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="floor_fillet_radius">
            <typename name="non_negative_length_measure"/>
         </explicit>
      </entity>
      <entity name="solid_with_variable_radius_edge_blend" supertypes="edge_blended_solid track_blended_solid">
         <explicit name="point_list">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="point"/>
         </explicit>
         <explicit name="radius_list">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="edge_function_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="blend_radius_variation_type"/>
         </explicit>
         <where expression="SIZEOF(point_list) = SIZEOF(radius_list)" label="WR1"/>
         <where expression="SIZEOF(edge_function_list) = SIZEOF(radius_list) - 1" label="WR2"/>
         <where expression="NOT((point_list[1] = point_list[HIINDEX(point_list)]) AND NOT &#10;         (radius_list[1] = radius_list[HIINDEX(radius_list)]))" label="WR3"/>
      </entity>
      <entity name="source_for_requirement" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_source"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="requirement_source_item"/>
         </explicit>
      </entity>
      <entity name="sourced_requirement" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_source"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="1"/>
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="spatial_decomposition_of_numerical_model">
         <explicit name="parts">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="numerical_model"/>
         </explicit>
         <explicit name="whole">
            <typename name="numerical_model"/>
         </explicit>
      </entity>
      <entity name="spatial_decomposition_of_temporal_spatial_domain">
         <explicit name="parts">
            <aggregate lower="2" type="SET" upper="?"/>
            <typename name="temporal_spatial_domain"/>
         </explicit>
         <explicit name="whole">
            <typename name="temporal_spatial_domain"/>
         </explicit>
      </entity>
      <entity name="specification_definition" supertypes="product_definition"/>
      <entity name="specified_general_property" supertypes="general_property">
         <explicit name="name_specifier">
            <typename name="choose_general_property_identifier"/>
         </explicit>
      </entity>
      <entity name="specified_higher_usage_occurrence" supertypes="assembly_component_usage">
         <explicit name="upper_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="next_usage">
            <typename name="next_assembly_usage_occurrence"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="upper_usage"/>
            <unique.attribute attribute="next_usage"/>
         </unique>
         <where expression="SELF :&lt;&gt;: upper_usage" label="WR1"/>
         <where expression="SELF\product_definition_relationship.relating_product_definition&#10;       :=: upper_usage.relating_product_definition" label="WR2"/>
         <where expression="SELF\product_definition_relationship.related_product_definition&#10;       :=: next_usage.related_product_definition" label="WR3"/>
         <where expression="(upper_usage.related_product_definition :=:&#10;       next_usage.relating_product_definition) OR&#10;       (SIZEOF (QUERY (pdr &lt;* USEDIN (upper_usage.related_product_definition,&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;       'RELATED_PRODUCT_DEFINITION') |&#10;        pdr.relating_product_definition :=: &#10;        next_usage.relating_product_definition)) = 1)" label="WR4"/>
         <where expression="SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']&#10;       * TYPEOF(upper_usage)) = 1" label="WR5"/>
      </entity>
      <entity name="specified_representation_context" supertypes="representation_context">
         <explicit name="class_specifier">
            <typename name="choose_representation_context_identifier"/>
         </explicit>
      </entity>
      <entity name="specified_state" supertypes="state"/>
      <entity name="sphere" supertypes="geometric_representation_item">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="centre">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="spherical_point" supertypes="cartesian_point">
         <explicit name="r">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="theta">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="phi">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived expression="[r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)]" name="coordinates">
            <aggregate lower="1" type="LIST" upper="3"/>
            <typename name="length_measure"/>
            <redeclaration entity-ref="cartesian_point"/>
         </derived>
         <where expression="r &gt;= 0.0" label="WR1"/>
      </entity>
      <entity name="spherical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="square_root_function" supertypes="unary_function_call"/>
      <entity name="standard_table_function" supertypes="linearized_table_function">
         <explicit name="order">
            <typename name="ordering_type"/>
         </explicit>
         <where expression="extremal_position_check(SELF)" label="WR1"/>
      </entity>
      <entity name="standard_uncertainty" super.expression="expanded_uncertainty" supertypes="uncertainty_qualifier">
         <explicit name="uncertainty_value">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="start_request" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="start_request_item"/>
         </explicit>
      </entity>
      <entity name="start_work" supertypes="action_assignment">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="work_item"/>
         </explicit>
      </entity>
      <entity name="state" super.expression="ONEOF (specified_state, calculated_state, linearly_superimposed_state, output_request_state)">
         <explicit name="state_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="state_component" supertypes="state">
         <explicit name="state">
            <typename name="linearly_superimposed_state"/>
         </explicit>
         <explicit name="factor">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="state_definition" super.expression="ONEOF (field_variable_definition, nodal_freedom_and_value_definition, element_nodal_freedom_actions, point_freedom_and_value_definition, curve_freedom_and_value_definition, surface_freedom_and_value_definition, solid_freedom_and_value_definition, linear_constraint_equation_element_value, single_point_constraint_element_values, analysis_message)">
         <explicit name="defined_state">
            <typename name="state"/>
         </explicit>
      </entity>
      <entity name="state_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_state">
            <typename name="state"/>
         </explicit>
         <explicit name="related_state">
            <typename name="state"/>
         </explicit>
      </entity>
      <entity name="state_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="state_type_assignment">
         <explicit name="assigned_state_type">
            <typename name="state_type"/>
         </explicit>
         <explicit name="role">
            <typename name="state_type_role"/>
         </explicit>
      </entity>
      <entity name="state_type_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_state_type">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="state_type"/>
         </explicit>
         <explicit name="related_state_type">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="state_type"/>
         </explicit>
      </entity>
      <entity name="state_type_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="state_view_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="discretised_model">
            <typename name="discretised_state_model_select"/>
         </explicit>
         <explicit name="idealised_state">
            <typename name="idealised_state_select"/>
         </explicit>
      </entity>
      <entity name="state_with_harmonic" supertypes="state">
         <explicit name="symmetry">
            <typename name="cylindrical_symmetry_control"/>
         </explicit>
      </entity>
      <entity name="stationary_mass" supertypes="point_element_matrix">
         <explicit name="mass">
            <aggregate lower="1" type="ARRAY" upper="3"/>
            <typename name="context_dependent_measure"/>
         </explicit>
         <explicit name="moments_of_inertia">
            <typename name="symmetric_tensor2_3d"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="offset_vector">
            <aggregate lower="1" type="ARRAY" upper="3"/>
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="straightness_tolerance" supertypes="geometric_tolerance">
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))" label="WR1"/>
      </entity>
      <entity name="strict_triangular_matrix" supertypes="triangular_matrix">
         <explicit name="main_diagonal_value">
            <typename name="maths_value"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="string_defined_function" supertypes="defined_function string_expression"/>
      <entity abstract.supertype="YES" name="string_expression" super.expression="ONEOF (simple_string_expression, index_expression, substring_expression, concat_expression, format_function, string_defined_function)" supertypes="expression"/>
      <entity name="string_literal" supertypes="simple_string_expression generic_literal">
         <explicit name="the_value">
            <builtintype type="STRING"/>
         </explicit>
      </entity>
      <entity name="string_variable" supertypes="simple_string_expression variable"/>
      <entity name="structural_response_property" supertypes="property_definition"/>
      <entity name="structural_response_property_definition_representation" supertypes="property_definition_representation">
         <where expression="(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;         'STRUCTURAL_RESPONSE_PROPERTY') IN TYPEOF &#10;         (SELF\property_definition_representation.definition))" label="WR1"/>
         <where expression="((('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_MODEL'&#10;        IN TYPEOF &#10;        (SELF\property_definition_representation.used_representation))&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FEA_MODEL_DEFINITION'&#10;        IN TYPEOF &#10;        (SELF\property_definition_representation.definition.definition)))&#10;       OR&#10;      (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENT_REPRESENTATION'&#10;        IN TYPEOF &#10;        (SELF\property_definition_representation.used_representation))&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENT_DEFINITION'&#10;        IN TYPEOF &#10;        (SELF\property_definition_representation.definition.definition)))&#10;       OR&#10;      (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_REPRESENTATION'&#10;        IN TYPEOF &#10;        (SELF\property_definition_representation.used_representation))&#10;        AND&#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_DEFINITION'&#10;        IN TYPEOF &#10;        (SELF\property_definition_representation.definition.definition))))" label="WR2"/>
      </entity>
      <entity name="structured_dimension_callout" supertypes="draughting_callout">
         <where expression="SIZEOF (TYPEOF (SELF) *&#10;       ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_FEATURE_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DATUM_TARGET_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GEOMETRICAL_TOLERANCE_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LEADER_DIRECTED_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROJECTION_DIRECTED_CALLOUT',&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIMENSION_CURVE_DIRECTED_CALLOUT']) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (ato &lt;* QUERY (con &lt;* SELF.contents |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (con))) |&#10;         NOT (ato.name IN&#10;             ['dimension value', 'tolerance value', 'unit text',&#10;              'prefix text', 'suffix text']))) = 0" label="WR2"/>
         <where expression="SIZEOF (QUERY (ato &lt;* QUERY (con &lt;* SELF.contents |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF (con))) |&#10;         (ato.name = 'dimension value')&#10;       )) &gt;= 1" label="WR3"/>
         <where expression="SIZEOF (QUERY (dcr &lt;* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +&#10;         'RELATING_DRAUGHTING_CALLOUT') |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND &#10;         (dcr.name = 'prefix') )) &lt;= 1" label="WR4"/>
         <where expression="SIZEOF (QUERY (dcr &lt;* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +&#10;         'RELATING_DRAUGHTING_CALLOUT') |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND &#10;         (dcr.name = 'suffix') )) &lt;= 1" label="WR5"/>
         <where expression="NOT((SIZEOF (QUERY (ato &lt;* QUERY (con &lt;* SELF.contents |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF(con)) ) |&#10;         (ato.name = 'prefix text')&#10;       )) &gt; 0)) OR&#10;       (SIZEOF (QUERY (dcr &lt;* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +&#10;                               'RELATING_DRAUGHTING_CALLOUT') |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND  &#10;         (dcr.name = 'prefix') )) = 1)" label="WR6"/>
         <where expression="NOT(SIZEOF (QUERY (ato &lt;* QUERY (con &lt;* SELF.contents |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE'&#10;             IN TYPEOF(con))) |&#10;         (ato.name = 'suffix text')&#10;       )) &gt; 0) OR&#10;       (SIZEOF (QUERY (dcr &lt;* USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +&#10;                               'RELATING_DRAUGHTING_CALLOUT') |&#10;         ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND    &#10;            (dcr.name = 'suffix') )) = 1)" label="WR7"/>
      </entity>
      <entity name="structured_donor_mesh" supertypes="mismatched_donor_mesh">
         <explicit name="donor">
            <typename name="structured_mesh"/>
            <redeclaration entity-ref="mismatched_donor_mesh"/>
         </explicit>
         <explicit name="points">
            <typename name="listed_real_data"/>
         </explicit>
         <explicit name="vsize">
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="donor.index_count" name="index_count">
            <builtintype type="INTEGER"/>
         </derived>
      </entity>
      <entity name="structured_mesh" supertypes="mesh">
         <explicit name="vertex_counts">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="cell_counts">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="kind">
            <typename name="structured_mesh_type"/>
         </explicit>
      </entity>
      <entity name="structured_text_composition" supertypes="compound_representation_item"/>
      <entity name="structured_text_representation" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="string_representation_item_select"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="styled_item" supertypes="representation_item">
         <explicit name="styles">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="presentation_style_assignment"/>
         </explicit>
         <explicit name="item">
            <typename name="representation_item"/>
         </explicit>
         <where expression="(SIZEOF(SELF.styles) = 1)&#10;               XOR&#10;         (SIZEOF(QUERY(pres_style &lt;* SELF.styles |&#10;         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'PRESENTATION_STYLE_BY_CONTEXT' IN&#10;         TYPEOF(pres_style))&#10;         )) = 0)" label="WR1"/>
      </entity>
      <entity name="subedge" supertypes="edge">
         <explicit name="parent_edge">
            <typename name="edge"/>
         </explicit>
      </entity>
      <entity name="subface" supertypes="face">
         <explicit name="parent_face">
            <typename name="face"/>
         </explicit>
         <where expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +&#10;              list_to_set(list_face_loops(parent_face))))" label="WR1"/>
      </entity>
      <entity name="submesh" supertypes="mesh"/>
      <entity name="substring_expression" supertypes="string_expression multiple_arity_generic_expression">
         <derived expression="SELF\multiple_arity_generic_expression.operands[1]" name="operand">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[2]" name="index1">
            <typename name="generic_expression"/>
         </derived>
         <derived expression="SELF\multiple_arity_generic_expression.operands[3]" name="index2">
            <typename name="generic_expression"/>
         </derived>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_EXPRESSION' &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(operand))&#10;&#9;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(index1))&#10;&#9;&#9;&#9;AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_EXPRESSION' &#10;&#9;&#9;&#9;&#9;&#9;IN TYPEOF(index2))" label="WR1"/>
         <where expression="SIZEOF(SELF\multiple_arity_generic_expression.operands)=3" label="WR2"/>
         <where expression="is_int_expr (index1)" label="WR3"/>
         <where expression="is_int_expr (index2)" label="WR4"/>
      </entity>
      <entity name="substructure_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model"/>
         </explicit>
         <explicit name="substructure_model_ref">
            <typename name="fea_model"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
      </entity>
      <entity name="substructure_node_reference">
         <explicit name="substructure_element_ref">
            <typename name="substructure_element_representation"/>
         </explicit>
         <explicit name="node_ref">
            <typename name="node_representation"/>
         </explicit>
      </entity>
      <entity name="substructure_node_relationship" supertypes="representation_relationship">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_REPRESENTATION' &#10;        IN TYPEOF (SELF\representation_relationship.rep_1)" label="WR1"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NODE_REPRESENTATION' &#10;        IN TYPEOF (SELF\representation_relationship.rep_2)" label="WR2"/>
      </entity>
      <entity name="supplied_part_relationship" supertypes="product_definition_relationship"/>
      <entity name="surface" super.expression="ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica)" supertypes="geometric_representation_item"/>
      <entity name="surface_2d_element_basis">
         <explicit name="descriptor">
            <typename name="surface_2d_element_descriptor"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <explicit name="variable_order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="variable_shape_function">
            <typename name="shape_function"/>
         </explicit>
         <explicit name="evaluation_points">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="surface_element_location"/>
         </explicit>
      </entity>
      <entity name="surface_2d_element_boundary_constant_specified_surface_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_2d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_boundary_constant_specified_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_2d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_boundary_edge_constant_specified_surface_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_2d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_boundary_edge_constant_specified_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_2d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_boundary_edge_location_point_surface_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_2d_element_value_and_volume_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_2d_edge"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_boundary_edge_location_point_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_2d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_2d_edge"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_boundary_edge_nodal_specified_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_2d_edge"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_boundary_edge_whole_edge_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_2d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_boundary_location_point_surface_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_2d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_2d_face"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_boundary_nodal_specified_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_2d_face"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_boundary_whole_face_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_2d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_constant_specified_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_constant_specified_volume_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_element_field_variable_definition" super.expression="ONEOF (surface_2d_element_location_point_volume_variable_values, surface_2d_element_location_point_variable_values, surface_2d_whole_element_variable_value, surface_2d_element_constant_specified_variable_value, surface_2d_element_constant_specified_volume_variable_value, surface_2d_element_nodal_specified_variable_values, surface_2d_element_boundary_location_point_surface_variable_values, surface_2d_element_boundary_whole_face_variable_value, surface_2d_element_boundary_constant_specified_variable_value, surface_2d_element_boundary_constant_specified_surface_variable_value, surface_2d_element_boundary_nodal_specified_variable_values, surface_2d_element_boundary_edge_location_point_surface_variable_values, surface_2d_element_boundary_edge_location_point_variable_values, surface_2d_element_boundary_edge_whole_edge_variable_value, surface_2d_element_boundary_edge_constant_specified_variable_value, surface_2d_element_boundary_edge_constant_specified_surface_variable_value, surface_2d_element_boundary_edge_nodal_specified_variable_values)" supertypes="field_variable_element_definition">
         <explicit name="element">
            <typename name="surface_2d_element_output_reference"/>
         </explicit>
      </entity>
      <entity name="surface_2d_element_group" supertypes="element_group">
         <where expression="SIZEOF(QUERY(item &lt;* elements |&#10;       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;             'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION'&#10;              IN TYPEOF(item)) AND&#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;             'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION'&#10;              IN TYPEOF(item)))))=0" label="WR1"/>
      </entity>
      <entity name="surface_2d_element_integrated_matrix">
         <explicit name="descriptor">
            <typename name="surface_2d_element_descriptor"/>
         </explicit>
         <explicit name="property_type">
            <typename name="surface_matrix_property_type"/>
         </explicit>
         <explicit name="integration_description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="surface_2d_element_integrated_matrix_with_definition" supertypes="surface_2d_element_integrated_matrix">
         <explicit name="integration_definition">
            <typename name="surface_2d_element_integration"/>
         </explicit>
      </entity>
      <entity name="surface_2d_element_integration">
         <explicit name="element_length">
            <typename name="surface_2d_element_length_integration"/>
         </explicit>
         <explicit name="section">
            <typename name="surface_section_integration"/>
         </explicit>
      </entity>
      <entity name="surface_2d_element_length_integration_explicit">
         <explicit name="integration_positions_and_weights">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_position_weight"/>
         </explicit>
      </entity>
      <entity name="surface_2d_element_length_integration_rule">
         <explicit name="integration_method">
            <typename name="integration_rule"/>
         </explicit>
         <explicit name="integration_order">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="surface_2d_element_location_point_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_2d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_location_point_volume_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_2d_element_value_and_volume_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_nodal_specified_variable_values" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_2d_element_value_and_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="surface_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="surface_2d_element_value_and_volume_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="surface_volume_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="surface_2d_node_field_aggregated_variable_values" supertypes="surface_2d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_node_field_section_variable_values" supertypes="surface_2d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <explicit name="location">
            <typename name="surface_section_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_2d_node_field_variable_definition" super.expression="ONEOF (surface_2d_node_field_section_variable_values, surface_2d_node_field_aggregated_variable_values)" supertypes="field_variable_node_definition"/>
      <entity name="surface_2d_substructure_element_reference">
         <explicit name="substructure_element_ref">
            <typename name="substructure_element_representation"/>
         </explicit>
         <explicit name="element_ref">
            <typename name="surface_2d_element_representation"/>
         </explicit>
      </entity>
      <entity name="surface_2d_whole_element_variable_value" supertypes="surface_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_basis">
         <explicit name="descriptor">
            <typename name="surface_3d_element_descriptor"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <explicit name="variable_order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="variable_shape_function">
            <typename name="shape_function"/>
         </explicit>
         <explicit name="evaluation_points">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="surface_element_location"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_boundary_constant_specified_surface_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_3d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_boundary_constant_specified_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_3d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_boundary_edge_constant_specified_surface_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_3d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_boundary_edge_constant_specified_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_3d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_boundary_edge_location_point_surface_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_3d_element_value_and_volume_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_3d_edge"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_boundary_edge_location_point_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_3d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_3d_edge"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_boundary_edge_nodal_specified_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_3d_edge"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_boundary_edge_whole_edge_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="surface_3d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_boundary_location_point_surface_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_3d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_3d_face"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_boundary_nodal_specified_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_3d_face"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_boundary_whole_face_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="surface_3d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_constant_specified_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_constant_specified_volume_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_element_purpose"/>
         </explicit>
         <explicit name="shape">
            <typename name="element_2d_shape"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_field_integration_explicit">
         <explicit name="integration_positions_and_weights">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_position_weight"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_field_integration_rule">
         <explicit name="integration_method">
            <typename name="integration_rule"/>
         </explicit>
         <explicit name="integration_order">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_field_variable_definition" super.expression="ONEOF (surface_3d_element_location_point_volume_variable_values, surface_3d_element_location_point_variable_values, surface_3d_whole_element_variable_value, surface_3d_element_constant_specified_variable_value, surface_3d_element_constant_specified_volume_variable_value, surface_3d_element_nodal_specified_variable_values, surface_3d_element_boundary_location_point_surface_variable_values, surface_3d_element_boundary_whole_face_variable_value, surface_3d_element_boundary_constant_specified_variable_value, surface_3d_element_boundary_constant_specified_surface_variable_value, surface_3d_element_boundary_nodal_specified_variable_values, surface_3d_element_boundary_edge_location_point_surface_variable_values, surface_3d_element_boundary_edge_location_point_variable_values, surface_3d_element_boundary_edge_whole_edge_variable_value, surface_3d_element_boundary_edge_constant_specified_variable_value, surface_3d_element_boundary_edge_constant_specified_surface_variable_value, surface_3d_element_boundary_edge_nodal_specified_variable_values)" supertypes="field_variable_element_definition">
         <explicit name="element">
            <typename name="surface_3d_element_output_reference"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_group" supertypes="element_group">
         <where expression="SIZEOF(query(item &lt;* elements |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;            'SURFACE_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0" label="WR1"/>
      </entity>
      <entity name="surface_3d_element_integrated_matrix">
         <explicit name="descriptor">
            <typename name="surface_3d_element_descriptor"/>
         </explicit>
         <explicit name="property_type">
            <typename name="surface_matrix_property_type"/>
         </explicit>
         <explicit name="integration_description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_integrated_matrix_with_definition" supertypes="surface_3d_element_integrated_matrix">
         <explicit name="integration_definition">
            <typename name="surface_3d_element_integration"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_integration">
         <explicit name="field">
            <typename name="surface_3d_element_field_integration"/>
         </explicit>
         <explicit name="section">
            <typename name="surface_section_integration"/>
         </explicit>
      </entity>
      <entity name="surface_3d_element_location_point_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_3d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_location_point_volume_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_3d_element_value_and_volume_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_nodal_specified_variable_values" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="surface_3d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_3d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="surface_3d_element_descriptor"/>
         </explicit>
         <explicit name="property">
            <typename name="surface_element_property"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'PARAMETRIC_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'CONSTANT_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;              'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;              'ALIGNED_SURFACE_3D_ELEMENT_COORDINATE_SYSTEM'&#10;              IN TYPEOF (item))) = 1" label="WR1"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_AREA_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_BENDING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_MEMBRANE_BENDING_COUPLING_STIFFNESS',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SHELL_SHEAR_STIFFNESS'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR2"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR3"/>
         <where expression="required_2d_nodes (&#10;        SELF\element_representation.node_list,&#10;        element_descriptor.shape,&#10;        element_descriptor\element_descriptor.topology_order)" label="FU1"/>
      </entity>
      <entity name="surface_3d_element_value_and_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="surface_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="surface_3d_element_value_and_volume_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="surface_volume_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="surface_3d_node_field_aggregated_variable_values" supertypes="surface_3d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_node_field_section_variable_values" supertypes="surface_3d_node_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="surface_element_variable"/>
         </explicit>
         <explicit name="location">
            <typename name="surface_section_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_state_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_3d_node_field_variable_definition" super.expression="ONEOF (surface_3d_node_field_section_variable_values, surface_3d_node_field_aggregated_variable_values)" supertypes="field_variable_node_definition"/>
      <entity name="surface_3d_substructure_element_reference">
         <explicit name="substructure_element_ref">
            <typename name="substructure_element_representation"/>
         </explicit>
         <explicit name="element_ref">
            <typename name="surface_3d_element_representation"/>
         </explicit>
      </entity>
      <entity name="surface_3d_whole_element_variable_value" supertypes="surface_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="surface_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="surface_condition_callout" supertypes="draughting_callout">
         <where expression="SIZEOF ( QUERY ( c &lt;* SELF.contents | SIZEOF (&#10;         ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'ANNOTATION_CURVE_OCCURRENCE' ,&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'ANNOTATION_SYMBOL_OCCURRENCE' ,&#10;         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'ANNOTATION_TEXT_OCCURRENCE']* TYPEOF&#10;         ( c ) ) &lt;&gt;1 ) ) =0" label="WR1"/>
      </entity>
      <entity name="surface_constraint" supertypes="constraint_element">
         <explicit name="required_surface">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="freedoms_and_coefficients">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="freedom_and_coefficient"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF (required_surface.item)) OR&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (required_surface.item))" label="WR1"/>
      </entity>
      <entity name="surface_curve" super.expression="ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve" supertypes="curve">
         <explicit name="curve_3d">
            <typename name="curve"/>
         </explicit>
         <explicit name="associated_geometry">
            <aggregate lower="1" type="LIST" upper="2"/>
            <typename name="pcurve_or_surface"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="preferred_surface_curve_representation"/>
         </explicit>
         <derived expression="get_basis_surface(SELF)" name="basis_surface">
            <aggregate lower="1" type="SET" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where expression="curve_3d.dim = 3" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1])) OR&#10;                        (master_representation &lt;&gt; pcurve_s1)" label="WR2"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2])) OR&#10;                        (master_representation &lt;&gt; pcurve_s2)" label="WR3"/>
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(curve_3d))" label="WR4"/>
      </entity>
      <entity name="surface_curve_swept_area_solid" supertypes="swept_area_solid">
         <explicit name="directrix">
            <typename name="curve"/>
         </explicit>
         <explicit name="start_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="end_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="reference_surface">
            <typename name="surface"/>
         </explicit>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(directrix))) OR&#10;          (reference_surface IN (directrix\surface_curve.basis_surface))" label="WR1"/>
      </entity>
      <entity name="surface_element_location">
         <explicit name="coordinates">
            <typename name="fea_parametric_point"/>
         </explicit>
      </entity>
      <entity name="surface_element_property">
         <explicit name="property_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="section">
            <typename name="surface_section_field"/>
         </explicit>
      </entity>
      <entity name="surface_freedom_action_definition" supertypes="surface_freedom_and_value_definition">
         <explicit name="action">
            <typename name="action_type"/>
         </explicit>
      </entity>
      <entity name="surface_freedom_and_value_definition" super.expression="ONEOF (surface_freedom_values, surface_freedom_action_definition)" supertypes="state_definition">
         <explicit name="required_surface">
            <typename name="analysis_item_within_representation"/>
         </explicit>
         <explicit name="coordinate_system">
            <typename name="fea_axis2_placement_3d"/>
         </explicit>
         <explicit name="degrees_of_freedom">
            <typename name="freedoms_list"/>
         </explicit>
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <where expression="SIZEOF(degrees_of_freedom.freedoms) = SIZEOF (values)" label="WR1"/>
         <where expression="('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF (required_surface.item)) OR&#10;       ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF (required_surface.item))" label="WR2"/>
      </entity>
      <entity name="surface_freedom_values" supertypes="surface_freedom_and_value_definition"/>
      <entity name="surface_of_linear_extrusion" supertypes="swept_surface">
         <explicit name="extrusion_axis">
            <typename name="vector"/>
         </explicit>
      </entity>
      <entity name="surface_of_revolution" supertypes="swept_surface">
         <explicit name="axis_position">
            <typename name="axis1_placement"/>
         </explicit>
         <derived expression="representation_item('')||&#10;                     geometric_representation_item()|| curve()||&#10;                     line(axis_position.location, representation_item('')||&#10;                     geometric_representation_item()||&#10;                     vector(axis_position.z, 1.0))" name="axis_line">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="surface_patch" supertypes="founded_item">
         <explicit name="parent_surface">
            <typename name="bounded_surface"/>
         </explicit>
         <explicit name="u_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="v_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="u_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="v_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <inverse attribute="segments" entity="rectangular_composite_surface" name="using_surfaces">
            <inverse.aggregate lower="1" type="BAG" upper="?"/>
         </inverse>
         <where expression="(NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE' &#10;                 IN TYPEOF(parent_surface)))" label="WR1"/>
      </entity>
      <entity name="surface_position_weight">
         <explicit name="integration_position">
            <typename name="surface_element_location"/>
         </explicit>
         <explicit name="integration_weight">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="surface_profile_tolerance" supertypes="geometric_tolerance">
         <where expression="NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3)" label="WR1"/>
      </entity>
      <entity name="surface_rendering_properties">
         <explicit name="rendered_colour">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="surface_replica" supertypes="surface">
         <explicit name="parent_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator_3d"/>
         </explicit>
         <where expression="acyclic_surface_replica(SELF, parent_surface)" label="WR1"/>
      </entity>
      <entity name="surface_section" super.expression="ONEOF (uniform_surface_section, uniform_surface_section_layered)">
         <explicit name="offset">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="non_structural_mass">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="non_structural_mass_offset">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
      </entity>
      <entity name="surface_section_element_location" super.expression="ONEOF (surface_section_element_location_absolute, surface_section_element_location_dimensionless)">
         <explicit name="above_material_discontinuity">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="surface_section_element_location_absolute" supertypes="surface_section_element_location">
         <explicit name="offset">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="surface_section_element_location_dimensionless" supertypes="surface_section_element_location">
         <explicit name="coordinate">
            <aggregate lower="1" type="LIST" upper="1"/>
            <typename name="parameter_value"/>
         </explicit>
         <where expression="valid_parametric_coordinate (coordinate)" label="WR1"/>
      </entity>
      <entity name="surface_section_field" super.expression="ONEOF (surface_section_field_constant, surface_section_field_varying)"/>
      <entity name="surface_section_field_constant" supertypes="surface_section_field">
         <explicit name="definition">
            <typename name="surface_section"/>
         </explicit>
      </entity>
      <entity name="surface_section_field_varying" supertypes="surface_section_field">
         <explicit name="definitions">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="surface_section"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="surface_section_integration_explicit">
         <explicit name="integration_positions_and_weights">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="surface_section_position_weight"/>
         </explicit>
      </entity>
      <entity name="surface_section_integration_rule">
         <explicit name="integration_method">
            <typename name="integration_rule"/>
         </explicit>
         <explicit name="integration_order">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="surface_section_position_weight">
         <explicit name="integration_position">
            <typename name="surface_section_element_location"/>
         </explicit>
         <explicit name="integration_weight">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="surface_side_style" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="styles">
            <aggregate lower="1" type="SET" upper="7"/>
            <typename name="surface_style_element_select"/>
         </explicit>
         <where expression="SIZEOF(QUERY( style1 &lt;* SELF.styles |&#10;           SIZEOF(QUERY( style2 &lt;* SELF.styles - style1 |&#10;           TYPEOF(style1) = TYPEOF(style2)&#10;           )) &gt; 0&#10;           )) = 0" label="WR1"/>
      </entity>
      <entity name="surface_style_boundary" supertypes="founded_item">
         <explicit name="style_of_boundary">
            <typename name="curve_or_render"/>
         </explicit>
      </entity>
      <entity name="surface_style_control_grid" supertypes="founded_item">
         <explicit name="style_of_control_grid">
            <typename name="curve_or_render"/>
         </explicit>
      </entity>
      <entity name="surface_style_fill_area" supertypes="founded_item">
         <explicit name="fill_area">
            <typename name="fill_area_style"/>
         </explicit>
      </entity>
      <entity name="surface_style_parameter_line" supertypes="founded_item">
         <explicit name="style_of_parameter_lines">
            <typename name="curve_or_render"/>
         </explicit>
         <explicit name="direction_counts">
            <aggregate lower="1" type="SET" upper="2"/>
            <typename name="direction_count_select"/>
         </explicit>
         <where expression="(HIINDEX(SELF.direction_counts) = 1)&#10;                        XOR&#10;         (TYPEOF(SELF.direction_counts[1]) &lt;&gt;&#10;          TYPEOF(SELF.direction_counts[2]))" label="WR1"/>
      </entity>
      <entity name="surface_style_reflectance_ambient">
         <explicit name="ambient_reflectance">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="surface_style_reflectance_ambient_diffuse" supertypes="surface_style_reflectance_ambient">
         <explicit name="diffuse_reflectance">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="surface_style_reflectance_ambient_diffuse_specular" supertypes="surface_style_reflectance_ambient_diffuse">
         <explicit name="specular_reflectance">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="specular_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="specular_colour">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="surface_style_rendering">
         <explicit name="rendering_method">
            <typename name="shading_surface_method"/>
         </explicit>
         <explicit name="surface_colour">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="surface_style_rendering_with_properties" supertypes="surface_style_rendering">
         <explicit name="properties">
            <aggregate lower="1" type="SET" upper="2"/>
            <typename name="rendering_properties_select"/>
         </explicit>
         <where expression="(HIINDEX(SELF.properties) = 1)&#10;                   XOR&#10;         (TYPEOF(SELF.properties[1]) &lt;&gt; TYPEOF(SELF.properties[2]))" label="WR1"/>
      </entity>
      <entity name="surface_style_segmentation_curve" supertypes="founded_item">
         <explicit name="style_of_segmentation_curve">
            <typename name="curve_or_render"/>
         </explicit>
      </entity>
      <entity name="surface_style_silhouette" supertypes="founded_item">
         <explicit name="style_of_silhouette">
            <typename name="curve_or_render"/>
         </explicit>
      </entity>
      <entity name="surface_style_transparent">
         <explicit name="transparency">
            <builtintype type="REAL"/>
         </explicit>
         <where expression="{0.0 &lt;= transparency &lt;= 1.0}" label="WR1"/>
      </entity>
      <entity name="surface_style_usage" supertypes="founded_item">
         <explicit name="side">
            <typename name="surface_side"/>
         </explicit>
         <explicit name="style">
            <typename name="surface_side_style_select"/>
         </explicit>
      </entity>
      <entity name="surface_texture_representation" supertypes="representation">
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE' , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DESCRIPTIVE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) &lt;&gt;1 ) )&#10;        =0" label="WR1"/>
         <where expression="( SIZEOF ( QUERY ( i &lt;* SELF.items | 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) =1 )&#10;        AND ( SIZEOF ( QUERY ( i &lt;* SELF.items | (&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN&#10;        TYPEOF ( i ) ) AND ( i.name = 'measuring method' ) ) ) =1 )" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) )&#10;        &gt;0" label="WR3"/>
         <where expression="( SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+&#10;        'REP_1' ) ) &lt;=1 ) AND ( SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+&#10;        'REP_2' ) ) =0 ) AND ( SIZEOF ( QUERY ( rr &lt;* USEDIN ( SELF&#10;        , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+&#10;        'REP_1' ) | rr. rep_2.name = 'measuring direction' ) ) =&#10;        SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'REPRESENTATION_RELATIONSHIP.'+&#10;        'REP_1' ) ) )" label="WR4"/>
         <where expression="( SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr&#10;        &lt;* USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa &lt;* USEDIN (&#10;        pdr. definition ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+&#10;        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND&#10;        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )&#10;        ) =1 )" label="WR5"/>
      </entity>
      <entity name="surface_volume_element_location">
         <explicit name="field_location">
            <typename name="surface_element_location"/>
         </explicit>
         <explicit name="section_location">
            <typename name="surface_section_element_location"/>
         </explicit>
      </entity>
      <entity name="surfaced_open_shell" supertypes="open_shell">
         <where expression="SIZEOF(QUERY(q &lt;* SELF\connected_face_set.cfs_faces |&#10;         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF(q)))) = 0" label="WR1"/>
      </entity>
      <entity name="swept_area_solid" super.expression="ONEOF (revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid)" supertypes="solid_model">
         <explicit name="swept_area">
            <typename name="curve_bounded_surface"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(swept_area.basis_surface)" label="WR1"/>
      </entity>
      <entity name="swept_disk_solid" supertypes="solid_model">
         <explicit name="directrix">
            <typename name="curve"/>
         </explicit>
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="inner_radius" optional="YES">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="start_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="end_param">
            <builtintype type="REAL"/>
         </explicit>
         <where expression="directrix.dim = 3" label="WR1"/>
         <where expression="(NOT EXISTS(inner_radius)) OR (radius &gt; inner_radius)" label="WR2"/>
      </entity>
      <entity name="swept_face_solid" super.expression="ONEOF (extruded_face_solid, revolved_face_solid)" supertypes="solid_model">
         <explicit name="swept_face">
            <typename name="face_surface"/>
         </explicit>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE' IN TYPEOF(swept_face.face_geometry)" label="WR1"/>
      </entity>
      <entity name="swept_surface" super.expression="ONEOF (surface_of_linear_extrusion, surface_of_revolution)" supertypes="surface">
         <explicit name="swept_curve">
            <typename name="curve"/>
         </explicit>
      </entity>
      <entity name="symbol" supertypes="representation_item"/>
      <entity name="symbol_colour">
         <explicit name="colour_of_symbol">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="symbol_representation" supertypes="representation"/>
      <entity name="symbol_representation_map" supertypes="representation_map">
         <explicit name="mapped_representation">
            <typename name="symbol_representation"/>
            <redeclaration entity-ref="representation_map"/>
         </explicit>
         <explicit name="mapping_origin">
            <typename name="axis2_placement"/>
            <redeclaration entity-ref="representation_map"/>
         </explicit>
      </entity>
      <entity name="symbol_style" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="style_of_symbol">
            <typename name="symbol_style_select"/>
         </explicit>
      </entity>
      <entity name="symbol_target" supertypes="geometric_representation_item">
         <explicit name="placement">
            <typename name="axis2_placement"/>
         </explicit>
         <explicit name="x_scale">
            <typename name="positive_ratio_measure"/>
         </explicit>
         <explicit name="y_scale">
            <typename name="positive_ratio_measure"/>
         </explicit>
      </entity>
      <entity name="symmetric_banded_matrix" supertypes="symmetric_matrix">
         <explicit name="default_entry">
            <typename name="maths_value"/>
         </explicit>
         <explicit name="above">
            <typename name="nonnegative_integer"/>
         </explicit>
         <where expression="member_of(default_entry,&#10;       factor1(SELF\linearized_table_function.source.range))" label="WR1"/>
      </entity>
      <entity name="symmetric_matrix" supertypes="linearized_table_function">
         <explicit name="symmetry">
            <typename name="symmetry_type"/>
         </explicit>
         <explicit name="triangle">
            <typename name="lower_upper"/>
         </explicit>
         <explicit name="order">
            <typename name="ordering_type"/>
         </explicit>
         <where expression="SIZEOF (SELF\explicit_table_function.shape) = 2" label="WR1"/>
         <where expression="SELF\explicit_table_function.shape[1] =&#10;       SELF\explicit_table_function.shape[2]" label="WR2"/>
         <where expression="NOT (symmetry = skew) OR (&#10;       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND&#10;        subspace_of_es(factor1(SELF\linearized_table_function.source.range),&#10;        es_numbers))" label="WR3"/>
         <where expression="NOT ((symmetry = hermitian) OR (symmetry = skew_hermitian)) OR (&#10;       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND&#10;        subspace_of_es(factor1(SELF\linearized_table_function.source.range),&#10;        es_complex_numbers))" label="WR4"/>
      </entity>
      <entity name="symmetric_shape_aspect" supertypes="shape_aspect">
         <inverse attribute="relating_shape_aspect" entity="shape_aspect_relationship" name="basis_relationships">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
         <where expression="SIZEOF (QUERY (x&lt;*SELF\symmetric_shape_aspect.basis_relationships |&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF &#10;       (x\shape_aspect_relationship.related_shape_aspect)))&gt;=1" label="WR1"/>
      </entity>
      <entity name="symmetry_control" super.expression="ONEOF (no_symmetry_control, cylindrical_symmetry_control)"/>
      <entity name="symmetry_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3" label="WR1"/>
      </entity>
      <entity name="system_and_freedom">
         <explicit name="matrix_coordinate_system">
            <typename name="directionally_explicit_element_coordinate_system"/>
         </explicit>
         <explicit name="freedom">
            <typename name="degree_of_freedom"/>
         </explicit>
      </entity>
      <entity name="table_representation_item" supertypes="compound_representation_item">
         <where expression="SIZEOF(QUERY(itet &lt;* SELF\compound_representation_item.item_element |&#10;        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ROW_REPRESENTATION_ITEM' IN TYPEOF(itet))&#10;            )) = 0" label="WR1"/>
      </entity>
      <entity name="tactile_appearance_representation" supertypes="representation">
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) &lt;&gt;1 )) =0" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | name ='depth' ) ) &lt;=1" label="WR2"/>
         <where expression="( SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr&#10;        &lt;* USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa &lt;* USEDIN (&#10;        pdr. definition ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+&#10;        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND&#10;        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )) =1 )" label="WR3"/>
      </entity>
      <entity name="tagged_text_format" supertypes="representation_context"/>
      <entity name="tagged_text_item" supertypes="descriptive_representation_item"/>
      <entity name="tan_function" supertypes="unary_function_call"/>
      <entity name="tangent" supertypes="derived_shape_aspect">
         <where expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1" label="WR1"/>
      </entity>
      <entity name="temporal_decomposition_of_action_domain">
         <explicit name="whole">
            <typename name="physical_action_domain"/>
         </explicit>
         <explicit name="parts">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="physical_action_domain"/>
         </explicit>
      </entity>
      <entity name="temporal_decomposition_of_model_action">
         <explicit name="parts">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="model_action_domain"/>
         </explicit>
         <explicit name="whole">
            <typename name="model_action_domain"/>
         </explicit>
      </entity>
      <entity name="temporal_spatial_domain">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <where expression="definition_for_temporal_spatial_domain(SELF)" label="wr1"/>
      </entity>
      <entity name="tensor_representation_item" supertypes="representation_item">
         <explicit name="tensor_value">
            <typename name="tensor_type"/>
         </explicit>
      </entity>
      <entity name="terminator_symbol" supertypes="annotation_symbol_occurrence">
         <explicit name="annotated_curve">
            <typename name="annotation_curve_occurrence"/>
         </explicit>
      </entity>
      <entity name="text_font">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <inverse attribute="font" entity="character_glyph_font_usage" name="glyphs">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="text_font_family">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <inverse attribute="family" entity="text_font_in_family" name="fonts">
            <inverse.aggregate lower="1" type="SET" upper="?"/>
         </inverse>
      </entity>
      <entity name="text_font_in_family">
         <explicit name="font">
            <typename name="text_font"/>
         </explicit>
         <explicit name="family">
            <typename name="text_font_family"/>
         </explicit>
      </entity>
      <entity name="text_literal" supertypes="geometric_representation_item">
         <explicit name="literal">
            <typename name="presentable_text"/>
         </explicit>
         <explicit name="placement">
            <typename name="axis2_placement"/>
         </explicit>
         <explicit name="alignment">
            <typename name="text_alignment"/>
         </explicit>
         <explicit name="path">
            <typename name="text_path"/>
         </explicit>
         <explicit name="font">
            <typename name="font_select"/>
         </explicit>
      </entity>
      <entity name="text_literal_with_associated_curves" supertypes="text_literal">
         <explicit name="associated_curves">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="curve"/>
         </explicit>
      </entity>
      <entity name="text_literal_with_blanking_box" supertypes="text_literal">
         <explicit name="blanking">
            <typename name="planar_box"/>
         </explicit>
      </entity>
      <entity name="text_literal_with_delineation" supertypes="text_literal">
         <explicit name="delineation">
            <typename name="text_delineation"/>
         </explicit>
      </entity>
      <entity name="text_literal_with_extent" supertypes="text_literal">
         <explicit name="extent">
            <typename name="planar_extent"/>
         </explicit>
      </entity>
      <entity name="text_string_representation" supertypes="representation">
         <explicit name="items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="text_string_representation_item"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
         <where expression="SIZEOF (&#10;         QUERY (item &lt;* SELF\representation.items |&#10;           NOT (SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT_CHARACTER',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEFINED_CHARACTER_GLYPH',&#10;                         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'] *&#10;                 TYPEOF (item)) = 0)&#10;         )) &gt;= 1" label="WR1"/>
         <where expression="SIZEOF (&#10;         QUERY (a2p &lt;* &#10;           QUERY (item &lt;* SELF\representation.items | &#10;             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AXIS2_PLACEMENT' IN TYPEOF (item)) |&#10;           NOT ((SIZEOF (&#10;             QUERY (at &lt;* &#10;               QUERY (item &lt;* SELF\representation.items | &#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'ANNOTATION_TEXT' IN TYPEOF (item)) | &#10;               (at\mapped_item.mapping_target :=: a2p))) &gt;= 1) OR&#10;           (SIZEOF (&#10;             QUERY (atc &lt;* &#10;               QUERY (item &lt;* SELF\representation.items |&#10;                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF (item)) | &#10;               (atc\mapped_item.mapping_target :=: a2p))) &gt;= 1)&#10;          ))) = 0" label="WR2"/>
      </entity>
      <entity name="text_style" supertypes="founded_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="character_appearance">
            <typename name="character_style_select"/>
         </explicit>
      </entity>
      <entity name="text_style_for_defined_font">
         <explicit name="text_colour">
            <typename name="colour"/>
         </explicit>
      </entity>
      <entity name="text_style_with_box_characteristics" supertypes="text_style">
         <explicit name="characteristics">
            <aggregate lower="1" type="SET" upper="4"/>
            <typename name="box_characteristic_select"/>
         </explicit>
         <where expression="SIZEOF( QUERY( c1 &lt;* SELF.characteristics |&#10;           SIZEOF( QUERY( c2 &lt;* SELF.characteristics - c1 |&#10;           TYPEOF (c1) = TYPEOF (c2)&#10;           )) &gt; 0&#10;           )) = 0" label="WR1"/>
      </entity>
      <entity name="text_style_with_mirror" supertypes="text_style">
         <explicit name="mirror_placement">
            <typename name="axis2_placement"/>
         </explicit>
      </entity>
      <entity name="text_style_with_spacing" supertypes="text_style">
         <explicit name="character_spacing">
            <typename name="character_spacing_select"/>
         </explicit>
      </entity>
      <entity name="thermal_conductivity_model" supertypes="mbna_behaviour_model">
         <explicit name="model_type">
            <typename name="thermal_conductivity_model_type"/>
         </explicit>
      </entity>
      <entity name="thermal_resistance_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMAL_RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="thermal_resistance_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = &#10;        dimensional_exponents ( -1.0, -1.0, -3.0, 0.0, 1.0, 0.0, 0.0 )" label="WR1"/>
      </entity>
      <entity name="thermodynamic_temperature_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="thermodynamic_temperature_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="thickened_face_solid" supertypes="solid_model">
         <explicit name="base_element">
            <typename name="generalized_surface_select"/>
         </explicit>
         <explicit name="offset1">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="offset2">
            <typename name="length_measure"/>
         </explicit>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(base_element)) AND&#10;    (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(base_element))))" label="WR1"/>
         <where expression="offset1 &lt;&gt; offset2" label="WR2"/>
      </entity>
      <entity name="thickness_laminate_definition" supertypes="product_definition">
         <where expression="SIZEOF (QUERY (pdr &lt;* USEDIN (SELF, &#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;                             'RELATING_PRODUCT_DEFINITION') |&#10;                             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN&#10;                             TYPEOF (pdr))) = 1" label="WR1"/>
      </entity>
      <entity name="thickness_laminate_table" supertypes="zone_structural_makeup"/>
      <entity name="time_interval">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="time_interval_based_effectivity" supertypes="effectivity">
         <explicit name="effectivity_period">
            <typename name="time_interval"/>
         </explicit>
      </entity>
      <entity name="time_interval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_time_interval">
            <typename name="time_interval"/>
         </explicit>
         <explicit name="related_time_interval">
            <typename name="time_interval"/>
         </explicit>
      </entity>
      <entity name="time_interval_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="time_interval_with_bounds" supertypes="time_interval">
         <explicit name="primary_bound" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="secondary_bound" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="duration" optional="YES">
            <typename name="time_measure_with_unit"/>
         </explicit>
         <where expression="NOT (EXISTS(secondary_bound) AND EXISTS(duration))" label="WR1"/>
         <where expression="EXISTS(primary_bound) OR EXISTS(secondary_bound)" label="WR2"/>
      </entity>
      <entity name="time_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="time_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived expression="get_description_value (SELF)" name="description">
            <typename name="text"/>
         </derived>
         <where expression="SIZEOF (USEDIN (SELF, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1" label="WR1"/>
      </entity>
      <entity name="time_unit" supertypes="named_unit">
         <where expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)" label="WR1"/>
      </entity>
      <entity name="tolerance_value">
         <explicit name="lower_bound">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="upper_bound">
            <typename name="measure_with_unit"/>
         </explicit>
         <derived expression="upper_bound\measure_with_unit.value_component" name="ubvc">
            <builtintype type="REAL"/>
         </derived>
         <derived expression="lower_bound\measure_with_unit.value_component" name="lbvc">
            <builtintype type="REAL"/>
         </derived>
         <where expression="ubvc &gt; lbvc" label="WR1"/>
         <where expression="upper_bound\measure_with_unit.unit_component =&#10;        lower_bound\measure_with_unit.unit_component" label="WR2"/>
      </entity>
      <entity name="tolerance_zone" supertypes="shape_aspect">
         <explicit name="defining_tolerance">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="geometric_tolerance"/>
         </explicit>
         <explicit name="form">
            <typename name="tolerance_zone_form"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_definition" super.expression="ONEOF (projected_zone_definition, runout_zone_definition)">
         <explicit name="zone">
            <typename name="tolerance_zone"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_form">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="topological_representation_item" super.expression="ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set, (loop ANDOR path))" supertypes="representation_item"/>
      <entity name="toroidal_surface" supertypes="elementary_surface">
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="torus" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <where expression="major_radius &gt; minor_radius" label="WR1"/>
      </entity>
      <entity name="total_runout_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 2" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="track_blended_solid" super.expression="track_blended_solid_with_end_conditions" supertypes="edge_blended_solid">
         <where expression="check_continuous_edges(SELF\edge_blended_solid.blended_edges)" label="WR1"/>
      </entity>
      <entity name="track_blended_solid_with_end_conditions" supertypes="track_blended_solid">
         <explicit name="end_conditions">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="blend_end_condition_select"/>
         </explicit>
         <where expression="SIZEOF(TYPEOF(SELF) *&#10;    ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_CONSTANT_RADIUS_EDGE_BLEND',&#10;     'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_VARIABLE_RADIUS_EDGE_BLEND',&#10;     'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_WITH_CHAMFERED_EDGES']) = 1" label="WR1"/>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[1]))&#10;       AND ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[2])))" label="WR2"/>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[1]))&#10;       AND (NOT ((end_conditions[1] &#10;            :=: SELF\edge_blended_solid.blended_edges[1].edge_start)&#10;            XOR (end_conditions[1] &#10;            :=: SELF\edge_blended_solid.blended_edges[1].edge_end))))" label="WR3"/>
         <where expression="NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(end_conditions[2]))&#10;       AND (NOT ((end_conditions[2] &#10;            :=: SELF\edge_blended_solid.blended_edges[HIINDEX(&#10;                SELF\edge_blended_solid.blended_edges)].edge_start)&#10;            XOR (end_conditions[2] &#10;            :=: SELF\edge_blended_solid.blended_edges[HIINDEX(&#10;                SELF\edge_blended_solid.blended_edges)].edge_end))))" label="WR4"/>
      </entity>
      <entity name="transformation_with_derived_angle" super.expression="ONEOF (draped_defined_transformation, laid_defined_transformation)" supertypes="item_defined_transformation">
         <explicit name="transform_item_1">
            <typename name="angle_direction_reference_with_a2p3d_select"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="axis2_placement_3d"/>
            <redeclaration entity-ref="item_defined_transformation"/>
         </explicit>
         <derived expression="derive_angle (&#10;        SELF\item_defined_transformation.transform_item_1,&#10;        SELF\item_defined_transformation.transform_item_2)" name="orientation_angle">
            <typename name="plane_angle_measure"/>
         </derived>
         <where expression="(SELF\item_defined_transformation.transform_item_1\&#10;            axis2_placement_3d.p[3].direction_ratios[1] =&#10;            SELF\item_defined_transformation.transform_item_2\&#10;            axis2_placement_3d.p[3].direction_ratios[1])&#10;          AND&#10;           (SELF\item_defined_transformation.transform_item_1\&#10;            axis2_placement_3d.p[3].direction_ratios[2] =&#10;            SELF\item_defined_transformation.transform_item_2\&#10;            axis2_placement_3d.p[3].direction_ratios[2])&#10;          AND&#10;           (SELF\item_defined_transformation.transform_item_1\&#10;            axis2_placement_3d.p[3].direction_ratios[3] =&#10;            SELF\item_defined_transformation.transform_item_2\&#10;            axis2_placement_3d.p[3].direction_ratios[3])" label="WR1"/>
      </entity>
      <entity name="triangular_matrix" supertypes="linearized_table_function">
         <explicit name="default_entry">
            <typename name="maths_value"/>
         </explicit>
         <explicit name="lo_up">
            <typename name="lower_upper"/>
         </explicit>
         <explicit name="order">
            <typename name="ordering_type"/>
         </explicit>
         <where expression="SIZEOF (SELF\explicit_table_function.shape) = 2" label="WR1"/>
         <where expression="member_of(default_entry, SELF\maths_function.range)" label="WR2"/>
      </entity>
      <entity name="trimmed_curve" supertypes="bounded_curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="trim_1">
            <aggregate lower="1" type="SET" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="trim_2">
            <aggregate lower="1" type="SET" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="sense_agreement">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="trimming_preference"/>
         </explicit>
         <where expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))" label="WR1"/>
         <where expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))" label="WR2"/>
      </entity>
      <entity name="turbulence_closure" supertypes="mbna_behaviour_model">
         <explicit name="closure_type">
            <typename name="turbulence_closure_type"/>
         </explicit>
      </entity>
      <entity name="turbulence_model" supertypes="mbna_behaviour_model">
         <explicit name="model_type">
            <typename name="turbulence_model_type"/>
         </explicit>
         <explicit name="diffusion_model" optional="YES">
            <typename name="fd_diffusion_model"/>
         </explicit>
      </entity>
      <entity name="two_direction_repeat_factor" supertypes="one_direction_repeat_factor">
         <explicit name="second_repeat_factor">
            <typename name="vector"/>
         </explicit>
      </entity>
      <entity name="type_qualifier">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="unary_boolean_expression" super.expression="ONEOF (not_expression, odd_function)" supertypes="boolean_expression unary_generic_expression"/>
      <entity abstract.supertype="YES" name="unary_function_call" super.expression="ONEOF (abs_function, minus_function, sin_function, cos_function, tan_function, asin_function, acos_function, exp_function, log_function, log2_function, log10_function, square_root_function)" supertypes="unary_numeric_expression"/>
      <entity abstract.supertype="YES" name="unary_generic_expression" supertypes="generic_expression">
         <explicit name="operand">
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity abstract.supertype="YES" name="unary_numeric_expression" supertypes="numeric_expression unary_generic_expression">
         <explicit name="operand">
            <typename name="numeric_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="uncertainty_assigned_representation" supertypes="representation">
         <explicit name="uncertainty">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <where expression="valid_measure_value (SELF\measure_with_unit.value_component)" label="WR1"/>
      </entity>
      <entity name="uncertainty_qualifier" super.expression="ONEOF (standard_uncertainty, qualitative_uncertainty)">
         <explicit name="measure_name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="uniform_curve" supertypes="b_spline_curve"/>
      <entity name="uniform_product_space" supertypes="maths_space generic_literal">
         <explicit name="base">
            <typename name="maths_space"/>
         </explicit>
         <explicit name="exponent">
            <typename name="positive_integer"/>
         </explicit>
         <where expression="expression_is_constant(base)" label="WR1"/>
         <where expression="no_cyclic_space_reference(SELF, [])" label="WR2"/>
         <where expression="base &lt;&gt; the_empty_space" label="WR3"/>
      </entity>
      <entity name="uniform_resource_identifier" supertypes="descriptive_representation_item"/>
      <entity name="uniform_surface" supertypes="b_spline_surface"/>
      <entity name="uniform_surface_section" supertypes="surface_section">
         <explicit name="thickness">
            <typename name="context_dependent_measure"/>
         </explicit>
         <explicit name="bending_thickness">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
         <explicit name="shear_thickness">
            <typename name="measure_or_unspecified_value"/>
         </explicit>
      </entity>
      <entity name="uniform_surface_section_layered" supertypes="surface_section"/>
      <entity name="unstructured_donor_mesh" supertypes="mismatched_donor_mesh">
         <explicit name="donor">
            <typename name="unstructured_mesh"/>
            <redeclaration entity-ref="mismatched_donor_mesh"/>
         </explicit>
         <explicit name="cells">
            <typename name="indices_group"/>
         </explicit>
         <explicit name="interpolant">
            <typename name="property_distribution_description"/>
         </explicit>
         <explicit name="vsize">
            <builtintype type="INTEGER"/>
         </explicit>
         <derived expression="donor.index_count" name="index_count">
            <builtintype type="INTEGER"/>
         </derived>
      </entity>
      <entity abstract.supertype="YES" name="unstructured_mesh" super.expression="ONEOF (array_based_unstructured_mesh, explicit_unstructured_mesh)" supertypes="mesh">
         <explicit name="cell_count">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="usage_association" supertypes="action_method_relationship">
         <explicit name="relating_method">
            <typename name="information_usage_right"/>
            <redeclaration entity-ref="action_method_relationship"/>
         </explicit>
         <explicit name="related_method">
            <typename name="information_usage_right"/>
            <redeclaration entity-ref="action_method_relationship"/>
         </explicit>
         <derived expression="SELF\action_method_relationship.related_method" name="related">
            <typename name="information_usage_right"/>
         </derived>
         <derived expression="SELF\action_method_relationship.relating_method" name="relating">
            <typename name="information_usage_right"/>
         </derived>
      </entity>
      <entity name="user_defined_curve_font" supertypes="curve_style_font mapped_item"/>
      <entity name="user_defined_marker" supertypes="mapped_item pre_defined_marker"/>
      <entity name="user_defined_terminator_symbol" supertypes="mapped_item pre_defined_symbol"/>
      <entity name="user_selected_elements" supertypes="representation_item">
         <explicit name="picked_items">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="user_selected_shape_elements" supertypes="user_selected_elements">
         <where expression="SIZEOF(QUERY(q &lt;* &#10;    SELF\user_selected_elements.picked_items | NOT&#10;    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_ITEM'&#10;    IN TYPEOF(q)))) = 0" label="WR1"/>
      </entity>
      <entity name="value_function" super.expression="int_value_function" supertypes="numeric_expression unary_generic_expression">
         <explicit name="operand">
            <typename name="string_expression"/>
            <redeclaration entity-ref="unary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="value_range" supertypes="compound_representation_item">
         <where expression="( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element )" label="WR1"/>
         <where expression="value_range_wr2 ( item_element )" label="WR2"/>
         <where expression="value_range_wr3 ( item_element )" label="WR3"/>
      </entity>
      <entity name="value_representation_item" supertypes="representation_item">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <where expression="SIZEOF (QUERY (rep &lt;* using_representations (SELF) |&#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT'&#10;        IN TYPEOF (rep.context_of_items)&#10;        ))) = 0" label="WR1"/>
      </entity>
      <entity abstract.supertype="YES" name="variable" super.expression="ONEOF (numeric_variable, boolean_variable, string_variable)" supertypes="generic_variable"/>
      <entity abstract.supertype="YES" name="variable_semantics"/>
      <entity abstract.supertype="YES" name="variational_representation_item" super.expression="auxiliary_geometric_representation_item" supertypes="representation_item">
         <where expression="SIZEOF(QUERY(q &lt;* using_representations(SELF) |&#10;    NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VARIATIONAL_REPRESENTATION'  &#10;    IN TYPEOF(q)))) = 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(q &lt;* using_representations(SELF) |&#10;    NOT (SELF IN q.items))) = 0" label="WR2"/>
      </entity>
      <entity name="vector" supertypes="geometric_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="length_measure"/>
         </explicit>
         <where expression="magnitude &gt;= 0.0" label="WR1"/>
      </entity>
      <entity name="vector_style" supertypes="curve_style pre_defined_terminator_symbol"/>
      <entity name="velocity_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VELOCITY_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="velocity_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = &#10;       dimensional_exponents ( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 )" label="WR1"/>
      </entity>
      <entity name="versioned_action_request">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="version">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="vertex" supertypes="topological_representation_item"/>
      <entity name="vertex_defined_cell" supertypes="cell">
         <explicit name="shape">
            <typename name="cell_shape"/>
         </explicit>
         <explicit name="order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="vertices">
            <aggregate lower="1" optional="YES" type="ARRAY" upper="0"/>
            <typename name="vertex"/>
         </explicit>
         <derived expression="cell_counts(SELF)[1]" name="bound_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="cell_counts(SELF)[2]" name="edge_node_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="cell_counts(SELF)[3]" name="opt_node_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="bound_count + edge_node_count" name="required_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="required_count + opt_node_count" name="vn_count">
            <builtintype type="INTEGER"/>
         </derived>
         <derived expression="shorten_array(vertices, vn_count, required_count)" name="required_vertices">
            <aggregate lower="1" type="ARRAY" upper="0"/>
            <typename name="vertex"/>
         </derived>
      </entity>
      <entity name="vertex_loop" supertypes="loop">
         <explicit name="loop_vertex">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="vertex_point" supertypes="vertex geometric_representation_item">
         <explicit name="vertex_geometry">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="vertex_shell" supertypes="topological_representation_item">
         <explicit name="vertex_shell_extent">
            <typename name="vertex_loop"/>
         </explicit>
      </entity>
      <entity name="view_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="viewed">
            <typename name="temporal_spatial_domain"/>
         </explicit>
         <explicit name="view">
            <typename name="numerical_model"/>
         </explicit>
      </entity>
      <entity name="view_volume" supertypes="founded_item">
         <explicit name="projection_type">
            <typename name="central_or_parallel"/>
         </explicit>
         <explicit name="projection_point">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="view_plane_distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="front_plane_distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="front_plane_clipping">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="back_plane_distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="back_plane_clipping">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="view_volume_sides_clipping">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="view_window">
            <typename name="planar_box"/>
         </explicit>
      </entity>
      <entity name="viscosity_model" supertypes="mbna_behaviour_model">
         <explicit name="model_type">
            <typename name="viscosity_model_type"/>
         </explicit>
      </entity>
      <entity name="visual_appearance_representation" supertypes="representation">
         <where expression="( {3&lt;= SIZEOF ( SELF.items ) &lt;=9} ) AND ( SIZEOF ( QUERY (&#10;        i &lt;* items | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (&#10;        i.name IN [ 'colour id' , 'colour name' , 'lustre' , 'pattern' , 'transparency', 'orientation'] ) ) &#10;        ) + SIZEOF ( QUERY ( i &lt;* items | ( SIZEOF (&#10;        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'MEASURE_REPRESENTATION_ITEM' ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#10;        AND ( i.name IN ['refraction index' , 'opacity'] ) ) &#10;        ) + SIZEOF ( QUERY ( i &lt;* items | ( &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'DOCUMENT_FILE' IN TYPEOF ( i ) ) &#10;        AND ( i.name IN [ 'texture map' ] ) )&#9;)&#10;        = SIZEOF ( SELF.items ) )" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name = 'colour id' )) =1" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='lustre' ) )=1" label="WR3"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name = 'colour name') ) &lt;=1" label="WR4"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='pattern' ) )&lt;=1" label="WR5"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='transparency') ) &lt;=1" label="WR6"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name = 'texture map') ) &lt;=1" label="WR7"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='refraction index' ) )&lt;=1" label="WR8"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='opacity') ) &lt;=1" label="WR9"/>
         <where expression="SIZEOF ( QUERY ( i &lt;* SELF.items | i.name ='orientation') ) &lt;=1" label="WR10"/>
         <where expression="( SIZEOF ( USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr&#10;        &lt;* USEDIN ( SELF ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'PROPERTY_DEFINITION_REPRESENTATION.'+&#10;        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa &lt;* USEDIN (&#10;        pdr. definition ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+'GENERAL_PROPERTY_ASSOCIATION.'+&#10;        'DERIVED_DEFINITION' ) | ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;        'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND&#10;        ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )) =1 )" label="WR11"/>
      </entity>
      <entity name="volume" supertypes="geometric_representation_item">
         <where expression="SELF\geometric_representation_item.dim = 3" label="WR1"/>
      </entity>
      <entity name="volume_2d_element_basis">
         <explicit name="descriptor">
            <typename name="volume_2d_element_descriptor"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="variable_order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="variable_shape_function">
            <typename name="shape_function"/>
         </explicit>
         <explicit name="evaluation_points">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="volume_element_location"/>
         </explicit>
      </entity>
      <entity name="volume_2d_element_boundary_constant_specified_variable_value" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_2d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_2d_element_boundary_edge_constant_specified_volume_variable_value" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_2d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_2d_element_boundary_edge_location_point_volume_variable_values" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_2d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_2d_edge"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_2d_element_boundary_edge_nodal_specified_variable_values" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_2d_edge"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_2d_element_boundary_edge_whole_edge_variable_value" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_2d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_2d_element_boundary_location_point_variable_values" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_2d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_2d_face"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_2d_element_boundary_nodal_specified_variable_values" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_2d_face"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_2d_element_boundary_whole_face_variable_value" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_2d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_2d_element_constant_specified_variable_value" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_2d_element_field_integration_explicit">
         <explicit name="integration_positions_and_weights">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_position_weight"/>
         </explicit>
      </entity>
      <entity name="volume_2d_element_field_integration_rule">
         <explicit name="integration_method">
            <typename name="integration_rule"/>
         </explicit>
         <explicit name="integration_order">
            <aggregate lower="1" type="ARRAY" upper="2"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="volume_2d_element_field_variable_definition" super.expression="ONEOF (volume_2d_element_location_point_variable_values, volume_2d_whole_element_variable_value, volume_2d_element_constant_specified_variable_value, volume_2d_element_nodal_specified_variable_values, volume_2d_element_boundary_location_point_variable_values, volume_2d_element_boundary_whole_face_variable_value, volume_2d_element_boundary_constant_specified_variable_value, volume_2d_element_boundary_nodal_specified_variable_values, volume_2d_element_boundary_edge_location_point_volume_variable_values, volume_2d_element_boundary_edge_whole_edge_variable_value, volume_2d_element_boundary_edge_constant_specified_volume_variable_value, volume_2d_element_boundary_edge_nodal_specified_variable_values)" supertypes="field_variable_element_definition">
         <explicit name="element">
            <typename name="volume_2d_element_output_reference"/>
         </explicit>
      </entity>
      <entity name="volume_2d_element_group" supertypes="element_group">
         <where expression="SIZEOF(QUERY(item &lt;* elements |&#10;       (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;             'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION'&#10;              IN TYPEOF(item)) AND&#10;        NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;             'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION'&#10;              IN TYPEOF(item)))))=0" label="WR1"/>
      </entity>
      <entity name="volume_2d_element_integrated_matrix">
         <explicit name="descriptor">
            <typename name="volume_2d_element_descriptor"/>
         </explicit>
         <explicit name="property_type">
            <typename name="matrix_property_type"/>
         </explicit>
         <explicit name="integration_description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="volume_2d_element_integrated_matrix_with_definition" supertypes="volume_2d_element_integrated_matrix">
         <explicit name="integration_definition">
            <typename name="volume_2d_element_field_integration"/>
         </explicit>
      </entity>
      <entity name="volume_2d_element_location_point_variable_values" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_2d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_2d_element_nodal_specified_variable_values" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_2d_element_value_and_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="volume_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="volume_2d_node_field_variable_definition" supertypes="field_variable_node_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_2d_substructure_element_reference">
         <explicit name="substructure_element_ref">
            <typename name="substructure_element_representation"/>
         </explicit>
         <explicit name="element_ref">
            <typename name="volume_2d_element_representation"/>
         </explicit>
      </entity>
      <entity name="volume_2d_whole_element_variable_value" supertypes="volume_2d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_2d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_3d_element_basis">
         <explicit name="descriptor">
            <typename name="volume_3d_element_descriptor"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="variable_order">
            <typename name="element_order"/>
         </explicit>
         <explicit name="variable_shape_function">
            <typename name="shape_function"/>
         </explicit>
         <explicit name="evaluation_points">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="volume_element_location"/>
         </explicit>
      </entity>
      <entity name="volume_3d_element_boundary_constant_specified_variable_value" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_3d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_3d_element_boundary_edge_constant_specified_volume_variable_value" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_3d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_3d_element_boundary_edge_location_point_volume_variable_values" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_3d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_3d_edge"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_3d_element_boundary_edge_nodal_specified_variable_values" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_edge_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_3d_edge"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_3d_element_boundary_edge_whole_edge_variable_value" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_edge">
            <typename name="volume_3d_edge"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_3d_element_boundary_location_point_variable_values" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_3d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_3d_face"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_3d_element_boundary_nodal_specified_variable_values" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_3d_face"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_3d_element_boundary_whole_face_variable_value" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="boundary_aggregated_variable"/>
         </explicit>
         <explicit name="element_face">
            <typename name="volume_3d_face"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_3d_element_constant_specified_variable_value" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_3d_element_descriptor" supertypes="element_descriptor">
         <explicit name="purpose">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_element_purpose"/>
         </explicit>
         <explicit name="shape">
            <typename name="volume_3d_element_shape"/>
         </explicit>
      </entity>
      <entity name="volume_3d_element_field_integration_explicit">
         <explicit name="integration_positions_and_weights">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_position_weight"/>
         </explicit>
      </entity>
      <entity name="volume_3d_element_field_integration_rule">
         <explicit name="integration_method">
            <typename name="integration_rule"/>
         </explicit>
         <explicit name="integration_order">
            <aggregate lower="1" type="ARRAY" upper="3"/>
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="volume_3d_element_field_variable_definition" super.expression="ONEOF (volume_3d_element_location_point_variable_values, volume_3d_whole_element_variable_value, volume_3d_element_constant_specified_variable_value, volume_3d_element_nodal_specified_variable_values, volume_3d_element_boundary_location_point_variable_values, volume_3d_element_boundary_whole_face_variable_value, volume_3d_element_boundary_constant_specified_variable_value, volume_3d_element_boundary_nodal_specified_variable_values, volume_3d_element_boundary_edge_location_point_volume_variable_values, volume_3d_element_boundary_edge_whole_edge_variable_value, volume_3d_element_boundary_edge_constant_specified_volume_variable_value, volume_3d_element_boundary_edge_nodal_specified_variable_values)" supertypes="field_variable_element_definition">
         <explicit name="element">
            <typename name="volume_3d_element_output_reference"/>
         </explicit>
      </entity>
      <entity name="volume_3d_element_group" supertypes="element_group">
         <where expression="SIZEOF(query(item &lt;* elements |&#10;       NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+&#10;            'VOLUME_3D_ELEMENT_REPRESENTATION' IN TYPEOF (item))))=0" label="WR1"/>
      </entity>
      <entity name="volume_3d_element_integrated_matrix">
         <explicit name="descriptor">
            <typename name="volume_3d_element_descriptor"/>
         </explicit>
         <explicit name="property_type">
            <typename name="matrix_property_type"/>
         </explicit>
         <explicit name="integration_description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="volume_3d_element_integrated_matrix_with_definition" supertypes="volume_3d_element_integrated_matrix">
         <explicit name="integration_definition">
            <typename name="volume_3d_element_field_integration"/>
         </explicit>
      </entity>
      <entity name="volume_3d_element_location_point_variable_values" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="basis">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="volume_3d_element_value_and_location"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <where expression="consistent_set_values (values_and_locations, variable)" label="WR1"/>
         <where expression="appropriate_set_value_existence (values_and_locations, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_3d_element_nodal_specified_variable_values" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </explicit>
         <explicit name="additional_node_values">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <where expression="consistent_list_values (values, variable)" label="WR1"/>
         <where expression="appropriate_list_value_existence (values, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR2"/>
      </entity>
      <entity name="volume_3d_element_representation" supertypes="element_representation">
         <explicit name="model_ref">
            <typename name="fea_model_3d"/>
         </explicit>
         <explicit name="element_descriptor">
            <typename name="volume_3d_element_descriptor"/>
         </explicit>
         <explicit name="material">
            <typename name="element_material"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="model_ref"/>
            <unique.attribute attribute="name" entity-ref="representation"/>
         </unique>
         <where expression="SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;               'PARAMETRIC_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'&#10;               IN TYPEOF (item))) +&#10;       SIZEOF (QUERY(item &lt;* SELF\representation.items |&#10;               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +&#10;               'ARBITRARY_VOLUME_3D_ELEMENT_COORDINATE_SYSTEM'&#10;               IN TYPEOF (item))) = 1" label="WR1"/>
         <where expression="SIZEOF (QUERY(item1 &lt;* material.properties |&#10;        (SIZEOF (QUERY (item2 &lt;* &#10;        item1\property_definition_representation.used_representation.items |&#10;         SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_LINEAR_ELASTICITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MASS_DENSITY',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_TANGENTIAL_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_SECANT_COEFFICIENT_OF_LINEAR_THERMAL_EXPANSION',&#10;                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + &#10;                  'FEA_MOISTURE_ABSORPTION'] * TYPEOF (item2)&#10;                  ) = 1&#10;        )) = 1&#10;       ))) &gt;= 1" label="WR2"/>
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'&#10;        IN TYPEOF (SELF\representation.context_of_items)" label="WR3"/>
         <where expression="required_3d_nodes (&#10;        SELF\element_representation.node_list,&#10;        element_descriptor.shape,&#10;        element_descriptor\element_descriptor.topology_order)" label="FU1"/>
      </entity>
      <entity name="volume_3d_element_value_and_location">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="location">
            <typename name="volume_element_location"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
      </entity>
      <entity name="volume_3d_node_field_variable_definition" supertypes="field_variable_node_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_3d_substructure_element_reference">
         <explicit name="substructure_element_ref">
            <typename name="substructure_element_representation"/>
         </explicit>
         <explicit name="element_ref">
            <typename name="volume_3d_element_representation"/>
         </explicit>
      </entity>
      <entity name="volume_3d_whole_element_variable_value" supertypes="volume_3d_element_field_variable_definition">
         <explicit name="simple_value">
            <typename name="field_value"/>
         </explicit>
         <explicit name="variable">
            <typename name="volume_aggregated_variable"/>
         </explicit>
         <explicit name="coordinate_system" optional="YES">
            <typename name="volume_3d_element_coordinate_system"/>
         </explicit>
         <where expression="necessary_value_coordinate_system (simple_value, coordinate_system)" label="WR1"/>
         <where expression="consistent_value (simple_value, variable)" label="WR2"/>
         <where expression="appropriate_value_existence (simple_value, &#10;       TYPEOF (SELF\state_definition.defined_state))" label="WR3"/>
      </entity>
      <entity name="volume_element_location">
         <explicit name="coordinates">
            <typename name="fea_parametric_point"/>
         </explicit>
      </entity>
      <entity name="volume_measure_with_unit" supertypes="measure_with_unit">
         <where expression="'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)" label="WR1"/>
      </entity>
      <entity name="volume_position_weight">
         <explicit name="integration_position">
            <typename name="volume_element_location"/>
         </explicit>
         <explicit name="integration_weight">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="volume_unit" supertypes="derived_unit">
         <where expression="derive_dimensional_exponents(SELF) = &#10;          dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 )" label="WR1"/>
      </entity>
      <entity name="week_of_year_and_day_date" supertypes="date">
         <explicit name="week_component">
            <typename name="week_in_year_number"/>
         </explicit>
         <explicit name="day_component" optional="YES">
            <typename name="day_in_week_number"/>
         </explicit>
      </entity>
      <entity name="whole_model_analysis_message" super.expression="whole_model_modes_and_frequencies_analysis_message" supertypes="analysis_message"/>
      <entity name="whole_model_modes_and_frequencies_analysis_message" supertypes="whole_model_analysis_message">
         <explicit name="mode">
            <typename name="count_measure"/>
         </explicit>
         <explicit name="frequency">
            <typename name="context_dependent_measure"/>
         </explicit>
      </entity>
      <entity name="wire_shell" supertypes="topological_representation_item">
         <explicit name="wire_shell_extent">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="loop"/>
         </explicit>
         <where expression="NOT mixed_loop_type_set(wire_shell_extent)" label="WR1"/>
      </entity>
      <entity name="xor_expression" supertypes="binary_boolean_expression">
         <explicit name="operands">
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="boolean_expression"/>
            <redeclaration entity-ref="binary_generic_expression"/>
         </explicit>
      </entity>
      <entity name="year_month" supertypes="date">
         <explicit name="month_component">
            <typename name="month_in_year_number"/>
         </explicit>
      </entity>
      <entity name="zone_structural_makeup" super.expression="ONEOF ((smeared_material_definition AND thickness_laminate_table), (smeared_material_definition AND percentage_laminate_table), thickness_laminate_table, percentage_laminate_table, smeared_material_definition)" supertypes="laminate_table"/>
      <rule appliesto="product_definition_formation" name="alternative_solution_requires_solution_definition">
         <algorithm>LOCAL
      solution_versions: SET OF product_definition_formation := [];
    END_LOCAL;
    solution_versions :=  QUERY( pdf &lt;* product_definition_formation |
	  SIZEOF( QUERY( prpc &lt;* USEDIN(pdf.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
      prpc.name = 'alternative solution')) = 1);</algorithm>
         <where expression="SIZEOF( QUERY( pdf &lt;* solution_versions |&#10;        SIZEOF( QUERY( pd &lt;* USEDIN(pdf, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION.FORMATION') | &#10;        pd.frame_of_reference.name = 'alternative definition')) &lt;&gt; 1))= 0" label="WR1"/>
      </rule>
      <rule appliesto="application_context" name="application_protocol_definition_required">
         <where expression="SIZEOF( QUERY( ac &lt;* application_context | &#10;              (SIZEOF (QUERY (apd &lt;* USEDIN(ac,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLICATION_PROTOCOL_DEFINITION.APPLICATION') | &#10;                apd.application_interpreted_model_schema_name = 'ap203_configuration_controlled_3d_design_of_mechanical_parts_and_assemblies' &#10;                )) &gt; 0) &#10;              )) &gt; 0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_formation" name="breakdown_element_requires_product_definition">
         <where expression="SIZEOF ( QUERY ( pdf &lt;* product_definition_formation | &#10;        ( SIZEOF ( QUERY ( prpc &lt;* USEDIN ( pdf.of_product ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | &#10;&#9;    prpc.name =  'functionality' ) ) =  1 ) AND &#10;&#9;    ( SIZEOF ( QUERY ( pd &lt;* USEDIN ( pdf ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION.FORMATION') | &#10;&#9;    pd.frame_of_reference.name =  'functional definition' ) ) &lt;1 ) ) ) =  0" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( pdf &lt;* product_definition_formation | &#10;        ( SIZEOF ( QUERY ( prpc &lt;* USEDIN ( pdf.of_product , &#10;&#9;    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | &#10;        prpc.name =  'conceptual design' ) ) =  1 ) AND &#10;        ( SIZEOF (QUERY ( pd &lt;* USEDIN ( pdf , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION.FORMATION' ) | &#10;        pd.frame_of_reference.name =  'conceptual definition' ) ) &lt;1) ) ) =  0" label="WR2"/>
      </rule>
      <rule appliesto="cartesian_point direction representation_context geometric_representation_context" name="compatible_dimension">
         <where expression="SIZEOF(QUERY(x &lt;* cartesian_point| SIZEOF(QUERY&#10;       (y &lt;* geometric_representation_context | item_in_context(x,y) AND&#10;       (HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0 )) =0" label="WR1"/>
         <where expression="SIZEOF(QUERY(x &lt;* direction | SIZEOF( QUERY&#10;       (y &lt;* geometric_representation_context | item_in_context(x,y) AND&#10;       (HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension)))&#10;       &gt; 0 )) = 0" label="WR2"/>
      </rule>
      <rule appliesto="composite_assembly_sequence_definition next_assembly_usage_occurrence product_related_product_category" name="component_class_for_assembly_select">
         <algorithm>LOCAL
      i,j,k :  INTEGER :=0;
      dkuhr :  LOGICAL :=TRUE;
      nnauo :  INTEGER :=0;
      nprpc :  INTEGER :=0;
      rp    :  product;
    END_LOCAL;
    REPEAT i:= LOINDEX (composite_assembly_sequence_definition) TO
               HIINDEX (composite_assembly_sequence_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO
                 HIINDEX (next_assembly_usage_occurrence);
        IF (composite_assembly_sequence_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN ['ply',
                 'ply laminate', 'filament laminate', 'processed core',
                 'composite assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nnauo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;</algorithm>
         <where expression="dkuhr" label="WR1"/>
      </rule>
      <rule appliesto="global_uncertainty_assigned_context qualified_representation_item uncertainty_assigned_representation" name="consistent_uncertainty">
         <where expression="SIZEOF ( QUERY ( guac &lt;* global_uncertainty_assigned_context | &#10;    SIZEOF ( QUERY ( u1 &lt;* guac.uncertainty | &#10;&#9;SIZEOF ( QUERY ( u2 &lt;* guac.uncertainty | u2.name =  u1.name ) ) &gt;1 ) ) &gt;0 ) ) =  0" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( uar &lt;* uncertainty_assigned_representation | &#10;&#9;SIZEOF ( QUERY ( u1&lt;* uar.uncertainty | &#10;&#9;SIZEOF ( QUERY ( u2 &lt;* uar.uncertainty | u2.name =  u1.name ) ) &gt;1 ) ) &gt;0 ) ) =  0" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( qri &lt;* qualified_representation_item |&#10;     SIZEOF ( QUERY ( u1 &lt;* qri.qualifiers |&#10;     ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.UNCERTAINTY_QUALIFIER' IN TYPEOF ( u1 ) ) AND &#10;&#9;( SIZEOF ( QUERY ( u2 &lt;* qri.qualifiers |&#10;     ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.UNCERTAINTY_QUALIFIER' IN TYPEOF ( u2 ) ) AND &#10;&#9;( u2\uncertainty_qualifier.measure_name =  u1\uncertainty_qualifier.measure_name ) )&#10;     ) &gt;1 ) ) ) &gt;0 ) ) =  0" label="WR3"/>
      </rule>
      <rule appliesto="product_definition" name="constraint_definition_requires_constraint_category">
         <algorithm>LOCAL
      constraint_definitions: SET OF product_definition := [];
    END_LOCAL;
      constraint_definitions :=  QUERY( pd &lt;* product_definition |
      (pd.frame_of_reference.name = 'design constraint definition'));</algorithm>
         <where expression="SIZEOF ( QUERY ( pd &lt;* constraint_definitions | &#10;&#9;    ( SIZEOF ( QUERY ( prpc &lt;* USEDIN ( pd.formation.of_product ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | &#10;&#9;    prpc. name ='requirement' ) ) =0 ) ) ) =0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_formation" name="design_constraint_requires_product_definition">
         <where expression="SIZEOF ( QUERY ( pdf &lt;* product_definition_formation | (&#10;        SIZEOF ( QUERY ( prpc &lt;* USEDIN ( pdf.of_product ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | &#10;&#9;    prpc.name =  'requirement' ) ) &gt;0 ) AND &#10;        ( SIZEOF ( QUERY ( pd &lt;* USEDIN ( pdf , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION.FORMATION') | &#10;&#9;    pd.frame_of_reference.name = 'design constraint definition' ) ) &lt;1 ) ) ) =  0" label="WR1"/>
      </rule>
      <rule appliesto="draughting_model" name="draughting_model_items_constraint">
         <where expression="SIZEOF(QUERY(dm &lt;* draughting_model |&#10;        NOT(SIZEOF(QUERY(it1 &lt;* dm\representation.items |&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_OCCURRENCE' IN TYPEOF(it1))&#10;        AND&#10;        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DRAUGHTING_ANNOTATION_OCCURRENCE' IN TYPEOF(it1)))&#10;          )) = 0)&#10;        )) = 0" label="WR1"/>
         <where expression="SIZEOF(QUERY(dm &lt;* draughting_model |&#10;        NOT(SIZEOF(QUERY(it1 &lt;* dm\representation.items |&#10;        (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_CALLOUT' IN TYPEOF(it1))&#10;        AND&#10;        NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DRAUGHTING_ELEMENTS' IN TYPEOF(it1)))&#10;          )) = 0)&#10;        )) = 0" label="WR2"/>
      </rule>
      <rule appliesto="applied_external_identification_assignment" name="external_version_assignments_are_valid">
         <where expression="SIZEOF(QUERY(aia &lt;* applied_external_identification_assignment | &#10;        NOT external_version_assignment_is_valid(aia)))=0" label="WR1"/>
      </rule>
      <rule appliesto="shape_aspect" name="material_for_coating_layer">
         <algorithm>LOCAL
      coating_layers: SET OF shape_aspect := [];
    END_LOCAL;
    coating_layers:= QUERY( r &lt;* shape_aspect | 
	  (r.name = 'coating layer') );</algorithm>
         <where expression="SIZEOF( QUERY( r &lt;* coating_layers |&#10;&#9;    SIZEOF(USEDIN(r , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MATERIAL_DESIGNATION.DEFINITIONS'))&lt;&gt;1&#10;        )) = 0" label="WR1"/>
      </rule>
      <rule appliesto="externally_defined_general_property" name="plib_property_reference_requires_name_scope">
         <algorithm>LOCAL
      known_sourced_properties : SET OF externally_defined_general_property;
    END_LOCAL;
      known_sourced_properties := QUERY( edc &lt;* externally_defined_general_property | 
	    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' IN TYPEOF(edc.source) );</algorithm>
         <where expression="SIZEOF ( QUERY ( edgp &lt;* known_sourced_properties | &#10;        ( SIZEOF ( QUERY ( edir &lt;* USEDIN ( edgp, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM' )| &#10;        ( edir.name =  'name scope' ) AND &#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_CLASS' IN  TYPEOF ( edir.related_item ) ) AND &#10;        ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) &lt;&gt;1 ) ) ) =  0" label="WR1"/>
      </rule>
      <rule appliesto="externally_defined_general_property" name="plib_property_reference_requires_version">
         <algorithm>LOCAL
	  plib_properties : SET OF externally_defined_general_property := [];
	END_LOCAL;
	  plib_properties := QUERY ( edgp &lt;* externally_defined_general_property | 
		( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' IN TYPEOF ( edgp.source ) ) AND
		( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'KNOWN_SOURCE' + '.NAME' = 'ISO 13584 library' ) );</algorithm>
         <where expression="SIZEOF( QUERY( edgp &lt;* plib_properties | &#10;&#9;&#9;(SIZEOF( QUERY( edir &lt;* USEDIN(edgp, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | &#10;&#9;&#9;(edir.role.name = 'version') )) &lt;&gt; 1) )) = 0" label="WR1"/>
      </rule>
      <rule appliesto="ply_laminate_sequence_definition next_assembly_usage_occurrence product_related_product_category" name="ply_reference">
         <algorithm>LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL := TRUE;
      nnauo :  INTEGER;
      nprpc :  INTEGER := 0;
      rp    :  product;
    END_LOCAL;
    REPEAT i:= LOINDEX (ply_laminate_sequence_definition) TO
               HIINDEX (ply_laminate_sequence_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO 
                 HIINDEX (next_assembly_usage_occurrence);
        IF (ply_laminate_sequence_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((product_related_product_category[k].name = 'ply') AND
                (rp IN product_related_product_category[k].products)) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nnauo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;</algorithm>
         <where expression="dkuhr" label="WR1"/>
      </rule>
      <rule appliesto="product_related_product_category make_from_usage_option" name="ply_stock_material_select">
         <algorithm>LOCAL
    i,j,k,kp :  INTEGER;
    dkuhr    :  LOGICAL;
    nmfuo    :  INTEGER;
    nprpc    :  INTEGER := 0;
    rp       :  product;
  END_LOCAL;

  dkuhr := TRUE;
  REPEAT kp:= LOINDEX (product_related_product_category) TO
              HIINDEX (product_related_product_category);
 
    IF (product_related_product_category[kp].name = 'ply') THEN
    REPEAT i:= LOINDEX (product_related_product_category[kp].products) TO
               HIINDEX (product_related_product_category[kp].products);

      nmfuo := 0;  
      REPEAT j:= LOINDEX (make_from_usage_option) TO 
                 HIINDEX (make_from_usage_option);

          rp := make_from_usage_option[j].related_product_definition.
                formation.of_product;

        IF (product_related_product_category[kp].products[i] = rp) THEN

          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);

            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                 ['isotropic material', 'filament assembly', 
                  'discontinuous fiber assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;

          END_REPEAT;

          IF (nprpc = 1) THEN
            nmfuo := nmfuo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;

        END_IF;

      END_REPEAT;

      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nmfuo &lt;&gt; 1) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;

    END_REPEAT;
    END_IF;

  END_REPEAT;</algorithm>
         <where expression="dkuhr" label="WR1"/>
      </rule>
      <rule appliesto="product_concept_feature" name="product_concept_feature_requires_category">
         <where expression="SIZEOF ( QUERY ( pcf &lt;* product_concept_feature |&#10;(SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',&#10;'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf)) = 0) AND &#10;(SIZEOF ( QUERY ( aga &lt;* USEDIN ( pcf , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS' ) | &#10;( aga.role.name = 'specification category member' ) AND &#10;('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF ( aga.assigned_group )))) &lt;&gt;1 ) ) ) = 0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_relationship" name="product_definition_replacement_requires_effectivity_assignment">
         <where expression="SIZEOF( QUERY( pdr &lt;* product_definition_relationship | &#10;        (pdr.name = 'definition replacement') AND &#10;        (SIZEOF( USEDIN(pdr,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))&#10;        = 0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition" name="restrict_alternative_definition">
         <algorithm>LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd &lt;* product_definition |
	 (pd.frame_of_reference.name = 'alternative definition'));</algorithm>
         <where expression="SIZEOF ( QUERY ( pd &lt;* solution_definitions | &#10;&#9;    ( SIZEOF ( QUERY ( pdr &lt;* USEDIN ( pd ,&#10;&#9;    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | &#10;&#9;    pdr.name = 'solution alternative definition' ) ) &lt;&gt;1 ) ) ) = 0" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( pd &lt;* solution_definitions | &#10;&#9;    NOT ( pd.name IN ['technical' , 'supplier' , 'technical supplier' , ''] ) ) ) = 0" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( pd &lt;* solution_definitions | &#10;&#9;    ( pd.name IN ['supplier' , 'technical supplier'] ) AND (&#10;&#9;    SIZEOF ( QUERY ( aoa &lt;* USEDIN ( pd.formation ,&#10;&#9;    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | &#10;&#9;    aoa.role.name = 'supplier' )) &lt;&gt;1 ) )) = 0" label="WR3"/>
      </rule>
      <rule appliesto="product_definition" name="restrict_assembly_category">
         <algorithm>LOCAL
      assembly_definitions: SET OF product_definition := [];
    END_LOCAL;
      assembly_definitions :=  QUERY( pd &lt;* product_definition | 
        SIZEOF( QUERY( pdca &lt;* USEDIN( pd, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'assembly definition')) &gt; 0 );</algorithm>
         <where expression="SIZEOF( QUERY( pd &lt;* assembly_definitions | &#10;          NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0" label="WR1"/>
      </rule>
      <rule appliesto="representation" name="restrict_centre_of_mass_representation">
         <where expression="SIZEOF ( QUERY ( r &lt;* representation | &#10;&#9;( r.name ='centre of mass' ) AND &#10;&#9;( ( SIZEOF ( r.items ) &lt;&gt;1 ) OR &#10;&#9;(SIZEOF ( QUERY ( i &lt;* r.items | &#10;&#9;( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'POINT' IN TYPEOF ( i ) ) AND &#10;&#9;( i.name = 'centre point' ) )) &lt;&gt;1 ) ) ) ) &#10;&#9;=0" label="WR1"/>
      </rule>
      <rule appliesto="applied_classification_assignment" name="restrict_classification_assignments">
         <where expression="SIZEOF(QUERY(aia &lt;* applied_classification_assignment | &#10;&#9;&#9;NOT class_assignment_is_valid(aia)))=0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition" name="restrict_collection_category">
         <algorithm>LOCAL
      collection_definitions: SET OF product_definition := [];
    END_LOCAL;
      collection_definitions :=  QUERY( pd &lt;* product_definition | 
        SIZEOF( QUERY( pdca &lt;* USEDIN( pd, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'collection definition')) &gt; 0 );</algorithm>
         <where expression="SIZEOF( QUERY( pd &lt;* collection_definitions | &#10;&#9;    NOT ('collection' IN categories_of_product(pd.formation.of_product)) ))= 0" label="WR1"/>
      </rule>
      <rule appliesto="concept_feature_operator" name="restrict_concept_feature_operator">
         <where expression="SIZEOF ( QUERY ( cfo &lt;* concept_feature_operator | NOT&#10;&#9;&#9;( cfo.name IN ['and' , 'or' , 'oneof' , 'not' , 'implication'] ) ) ) = 0" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( cfo &lt;* concept_feature_operator | (cfo.name = 'implication' ) AND&#10;&#9; ( SIZEOF ( QUERY (cfrwc &lt;* USEDIN ( cfo , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +&#10;&#9;'CONDITIONAL_OPERATOR' ) | &#10;&#9;&#9;SIZEOF ( QUERY ( ccf &lt;* USEDIN( cfrwc , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION' ) | &#10;&#9;&#9;NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ccf )))) &gt;0 )) &gt;0 ))) = 0" label="WR2"/>
         <where expression="SIZEOF( QUERY (cfo &lt;* concept_feature_operator | (cfo.name = 'not')&#10;&#9;AND (SIZEOF(QUERY(cfrwc &lt;* USEDIN(cfo, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR') | &#10;&#9;&#9;cfrwc.related_product_concept_feature :&lt;&gt;: cfrwc.relating_product_concept_feature)) &gt;0 ))) = 0" label="WR3"/>
      </rule>
      <rule appliesto="configuration_design" name="restrict_configuration_design_for_class_breakdown_association">
         <where expression="SIZEOF ( QUERY ( cd &lt;* configuration_design | &#10;&#9;    ( cd.name ='functionality' ) AND &#10;        ( NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd. design ) ) OR &#10;        ( cd.design\product_definition.frame_of_reference.name&lt;&gt; 'functional definition' ) ) &#10;        ) ) =0" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( cd &lt;* configuration_design | &#10;        ( cd.name='realization' ) AND &#10;        ( NOT ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR &#10;        ( cd.design\product_definition.frame_of_reference.name&lt;&gt; 'conceptual definition' ) ) &#10;        ) ) =0" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( cd &lt;* configuration_design | &#10;        ( cd.name IN ['functionality' , 'realization'] ) AND &#10;        ( NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CLASS' IN TYPEOF ( cd.configuration.item_concept ) ) ) &#10;        ) ) =0" label="WR3"/>
      </rule>
      <rule appliesto="configuration_design" name="restrict_configuration_design_for_design_constraint">
         <where expression="SIZEOF ( QUERY (cd &lt;* configuration_design | &#10;&#9;    (cd.name = 'design constraint usage') AND &#10;        (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR &#10;        (cd.design\product_definition.frame_of_reference.name &lt;&gt; 'design constraint definition')))) = 0" label="WR1"/>
      </rule>
      <rule appliesto="group_relationship" name="restrict_group_relationship_for_classification_hierarchy">
         <where expression="SIZEOF( QUERY( gr &lt;* group_relationship | &#10;  (gr\group_relationship.name = 'class hierarchy') AND &#10;  (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLASS' IN TYPEOF(gr\group_relationship.related_group)) OR &#10;  NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLASS' IN TYPEOF(gr\group_relationship.relating_group))) )) = 0" label="WR1"/>
      </rule>
      <rule appliesto="group_relationship" name="restrict_group_relationship_for_specification_category">
         <where expression="SIZEOF( QUERY( gr &lt;* group_relationship | &#10;  (gr.name = 'specification category hierarchy') AND &#10;  (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.related_group)) &#10;  OR NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group))) )) = 0" label="WR1"/>
      </rule>
      <rule appliesto="attribute_language_assignment" name="restrict_language_assignment_per_attribute">
         <where expression="SIZEOF ( QUERY ( ala1 &lt;* attribute_language_assignment |&#10;&#9;SIZEOF(QUERY( it &lt;* ala1.items |&#10;&#9;   SIZEOF ( QUERY ( ala2 &lt;* USEDIN ( it ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | &#10;&#9;&#9;( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND &#10;&#9;&#9;( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )&#10;&#9;&#9; )) &gt;1 &#10;&#9;   )) &gt;0 &#10;&#9;)) =0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition" name="restrict_part_occurrence">
         <algorithm>LOCAL
      part_occurrences: SET OF product_definition := QUERY(pd &lt;* product_definition | 
	    ( pd.frame_of_reference.name = 'part occurrence' ));
    END_LOCAL;</algorithm>
         <where expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10;&#9;    ( NOT( pd.name IN &#10;        ['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0" label="WR1"/>
         <where expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10; &#9;    (SIZEOF ( QUERY ( pdr &lt;* USEDIN ( pd ,&#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | &#10;&#9;    pdr.name = 'definition usage' ) ) &lt;&gt;1 ) AND &#10;        ( SIZEOF ( QUERY ( cd &lt;* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN' ) | &#10;        ( cd.name = 'occurrence usage definition' ) AND &#10;        ( NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) &lt;&gt;1 ) ) ) = 0" label="WR2"/>
         <where expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences |  &#10;        (SIZEOF ( QUERY ( cd &lt;* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |&#10;        ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND&#10;        ( SIZEOF ( USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0" label="WR3"/>
         <where expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10;        ( pd.name = 'selected instance' ) AND &#10;        NOT valid_selected_instance_representation(pd) ))=0" label="WR4"/>
         <where expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10;        ( pd.name = 'quantified instance' ) AND &#10;        ( SIZEOF ( QUERY (ppd &lt;* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PROPERTY_DEFINITION.DEFINITION' ) |&#10;        ( ppd.name ='occurrence quantity' ) AND &#10;        ( SIZEOF ( QUERY ( pdr &lt;*USEDIN ( ppd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (&#10;        pdr.used_representation.name = 'quantity' ) AND &#10;        (SIZEOF ( pdr.used_representation.items ) = 1 ) AND &#10;        (SIZEOF ( QUERY ( i &lt;* pdr.used_representation.items | &#10;        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND&#10;        ( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0" label="WR5"/>
         <where expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10;        ( pd.name = 'specified instance' ) AND &#10;        ( SIZEOF ( QUERY (&#10;        pdor &lt;* USEDIN ( pd , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | &#10;        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0" label="WR6"/>
      </rule>
      <rule appliesto="product_definition" name="restrict_part_occurrence_category">
         <algorithm>LOCAL
      part_occurrences: SET OF product_definition := QUERY( pd &lt;* product_definition |(
        pd.frame_of_reference.name = 'part occurrence'));
    END_LOCAL;</algorithm>
         <where expression="SIZEOF( QUERY( pd &lt;* part_occurrences | &#10;        (SIZEOF( QUERY( prpc &lt;* USEDIN(pd.formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | &#10;        prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_relationship" name="restrict_product_definitions_for_base_element">
         <where expression="SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship |&#10;       ( pdr. name = 'solution alternative definition' ) AND &#10;       ( NOT( pdr. relating_product_definition.frame_of_reference.name&#10;        IN [ 'alternative definition' , 'functional definition' , 'conceptual definition' ] ) OR &#10;       ( pdr.related_product_definition.frame_of_reference.name&lt;&gt;'alternative definition' ) ) ) ) =0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_relationship" name="restrict_product_definitions_for_collection">
         <where expression="SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship |&#10;       ( pdr. name = 'collection membership' ) AND &#10;       ( ( pdr.relating_product_definition.frame_of_reference.name&lt;&gt;'part definition' ) OR &#10;       ( pdr.related_product_definition.frame_of_reference.name&lt;&gt;'part occurrence' ) OR &#10;       ( SIZEOF ( QUERY ( pdca &lt;* USEDIN (pdr.relating_product_definition ,&#10;       'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') | &#10;       ( pdca.role.name = 'part definition type' ) AND &#10;       ( pdca.frame_of_reference.name = 'collection definition' ) )) =0 ) ) ) ) =0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_relationship" name="restrict_product_definitions_for_definition_usage">
         <where expression="SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship |&#10;        ( pdr.name = 'definition usage' ) AND &#10;        ( ( pdr.relating_product_definition.frame_of_reference.name&lt;&gt; 'part definition' ) OR &#10;        ( pdr.related_product_definition.frame_of_reference.name&lt;&gt;'part occurrence' )))) =0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_relationship" name="restrict_product_definitions_for_design_constraint_association">
         <where expression="SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship |&#10;        ( pdr. name = 'design constraint association' ) AND &#10;&#9;    ( (pdr. relating_product_definition.frame_of_reference.name&lt;&gt;'design constraint definition' ) OR &#10;&#9;    NOT ( pdr.related_product_definition.frame_of_reference.name IN &#10;&#9;    ['alternative definition' , 'functional definition' ,'conceptual definition' ] ) ) ) ) =0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition_relationship" name="restrict_product_definitions_for_part_definition_relationship">
         <where expression="SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship |&#10;        ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND &#10;&#9;    ( ( pdr.relating_product_definition.frame_of_reference.name &lt;&gt;'part definition' ) OR &#10;        ( pdr.related_product_definition.frame_of_reference.name &lt;&gt;'part definition' ) ) ) ) =0" label="WR1"/>
      </rule>
      <rule appliesto="property_definition_representation" name="restrict_representation_for_surface_condition">
         <where expression="SIZEOF(QUERY(pdr &lt;* property_definition_representation | &#10;        NOT surface_condition_correlation(pdr.definition, pdr.used_representation) ))=0" label="WR1"/>
      </rule>
      <rule appliesto="representation" name="restrict_treatment_result">
         <algorithm>LOCAL
      treatment_results: SET OF representation := [];
    END_LOCAL;
    treatment_results:= QUERY( r &lt;* representation | 
	  (r.name = 'treatment result') );</algorithm>
         <where expression="(SIZEOF( QUERY( r &lt;* treatment_results | (SIZEOF(r.items) &gt; 2) )) = 0) AND&#10;        (SIZEOF( QUERY( r &lt;* treatment_results |&#10;        (SIZEOF( QUERY( i &lt;* r.items | &#10;         NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) &gt; 0) )) = 0)" label="WR1"/>
         <where expression="SIZEOF( QUERY( r &lt;* treatment_results | &#10;        (SIZEOF( QUERY( i &lt;* r.items | i.name = 'result' )) = 0) )) = 0" label="WR2"/>
         <where expression="SIZEOF( QUERY( r &lt;* treatment_results | &#10;        (SIZEOF( QUERY( i &lt;* r.items | i.name = 'purpose' )) &gt; 1) )) = 0" label="WR3"/>
      </rule>
      <rule appliesto="assembly_component_usage" name="selected_instance_usage_requires_representation">
         <algorithm>LOCAL
      selected_instance_usages: SET OF assembly_component_usage := QUERY( acr &lt;* assembly_component_usage|
        (acr.name = 'selected instance usage'));
    END_LOCAL;</algorithm>
         <where expression="SIZEOF ( QUERY ( acr &lt;* selected_instance_usages | &#10;        NOT valid_selected_instance_representation(acr) ))=0" label="WR1"/>
      </rule>
      <rule appliesto="product_definition" name="solution_definition_requires_solution_category">
         <algorithm>LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd &lt;* product_definition |
        (pd.frame_of_reference.name = 'alternative definition'));</algorithm>
         <where expression="SIZEOF( QUERY( pd &lt;* solution_definitions | &#10;        (SIZEOF( QUERY( prpc &lt;* USEDIN(pd.formation.of_product, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | &#10;&#9;     prpc.name = 'alternative solution')) = 0 ) )) = 0" label="WR1"/>
      </rule>
      <rule appliesto="percentage_ply_definition make_from_usage_option product_related_product_category" name="stock_material_reference">
         <algorithm>LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL;
      nmfuo :  INTEGER;
      nprpc :  INTEGER;
      rp     :  product;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i:= LOINDEX (percentage_ply_definition) TO
               HIINDEX (percentage_ply_definition);
      nmfuo := 0;  
      REPEAT j:= LOINDEX (make_from_usage_option) TO 
                 HIINDEX (make_from_usage_option);
        IF (percentage_ply_definition[i] = 
          make_from_usage_option[j].relating_product_definition) THEN
          rp := make_from_usage_option[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                ['anisotropic material', 'isotropic material', 'stock core',
                 'filament assembly', 'discontinuous fiber assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nmfuo := nmfuo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nmfuo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;</algorithm>
         <where expression="dkuhr" label="WR1"/>
      </rule>
      <rule appliesto="styled_item" name="styled_curve">
         <where expression="SIZEOF( QUERY( si &lt;* styled_item | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN TYPEOF (si.item)) AND (SIZEOF (QUERY (psa &lt;* si.styles | (SIZEOF (QUERY (cs &lt;* psa.styles | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_STYLE' IN TYPEOF (cs)) )) &gt; 0) )) &lt;&gt; 1) )) = 0" label="WR1"/>
      </rule>
      <rule appliesto="geometric_tolerance" name="subtype_exclusiveness_geometric_tolerance">
         <where expression="SIZEOF(QUERY (gt &lt;* geometric_tolerance | NOT (type_check_function(gt, ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COAXIALITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FLATNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARALLELISM_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITION_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ROUNDNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 3)))) = 0" label="WR1"/>
      </rule>
      <rule appliesto="representation_item" name="subtype_exclusiveness_representation_item">
         <where expression="SIZEOF(QUERY (cri &lt;* representation_item | &#10;      NOT (type_check_function(cri,['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',&#10;                                    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_REPRESENTATION_ITEM',&#10;                                    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0" label="WR1"/>
      </rule>
      <rule appliesto="geometric_tolerance" name="subtype_mandatory_geometric_tolerance">
         <where expression="SIZEOF(QUERY (gt &lt;* geometric_tolerance | NOT (type_check_function(gt, ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANGULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COAXIALITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FLATNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARALLELISM_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITION_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ROUNDNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRY_TOLERANCE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 0)))) = 0" label="WR1"/>
      </rule>
      <rule appliesto="externally_defined_text_font pre_defined_text_font" name="text_font_usage">
         <where expression="SIZEOF (QUERY (pdtf &lt;* pre_defined_text_font | SIZEOF (USEDIN (pdtf, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL.FONT')) = 0 )) = 0" label="WR1"/>
         <where expression="SIZEOF (QUERY (edtf &lt;* externally_defined_text_font | SIZEOF (USEDIN (edtf, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TEXT_LITERAL.FONT')) = 0 )) = 0" label="WR2"/>
      </rule>
      <rule appliesto="thickness_laminate_definition next_assembly_usage_occurrence product_related_product_category" name="thickness_laminate_table_component_select">
         <algorithm>LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL;
      nnauo :  INTEGER;
      nprpc :  INTEGER;
      rp    :  product;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i:= LOINDEX (thickness_laminate_definition) TO
               HIINDEX (thickness_laminate_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO 
                 HIINDEX (next_assembly_usage_occurrence);
        IF (thickness_laminate_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                 ['ply', 'filament laminate', 'processed core'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE;
      END_IF;
      IF (nnauo &lt;&gt; 1) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;</algorithm>
         <where expression="dkuhr" label="WR1"/>
      </rule>
      <rule appliesto="action_resource_type annotation_text auxiliary_geometric_representation_item bounded_curve bounded_surface cartesian_transformation_operator cell concept_feature_relationship concept_feature_relationship_with_condition connected_edge_set document_usage_constraint edge_blended_solid event_occurrence_context_role event_occurrence_role experience experience_type explicit_procedural_representation_item_relationship indices_list indices_range indirectly_selected_elements library_context local_time location loop maths_space_context maths_value_context mesh modified_solid_with_placed_configuration one_direction_repeat_factor organization_type oriented_open_shell oriented_path person_role person_type person_type_definition person_type_definition_formation position_in_organization position_in_organization_type positioned_sketch procedural_representation procedural_representation_sequence product_definition_context_role product_definition_effectivity property_distribution_description qualification qualification_type resource_requirement_type rind runout_zone_orientation solid_with_depression solid_with_hole solid_with_pocket solid_with_protrusion solid_with_shape_element_pattern solid_with_slot state_type_role structured_mesh swept_area_solid symbol_target time_role tolerance_zone_form two_direction_repeat_factor unstructured_mesh user_selected_elements variational_representation_item view_volume volume" name="validate_dependently_instantiable_entity_data_types">
         <algorithm>LOCAL
  number_of_input_instances : INTEGER;
  previous_in_chain : LIST OF GENERIC := [];
  set_of_input_types : SET OF STRING := [];
  all_instances : SET OF GENERIC := [];
END_LOCAL;

  all_instances := all_instances + action_resource_type + annotation_text + auxiliary_geometric_representation_item + bounded_curve + bounded_surface + cartesian_transformation_operator + cell + concept_feature_relationship + concept_feature_relationship_with_condition + connected_edge_set + document_usage_constraint + edge_blended_solid + event_occurrence_context_role + event_occurrence_role + experience + experience_type + explicit_procedural_representation_item_relationship + indices_list + indices_range + indirectly_selected_elements + library_context + local_time + location + loop + maths_space_context + maths_value_context + mesh + modified_solid_with_placed_configuration + one_direction_repeat_factor + organization_type + oriented_open_shell + oriented_path + person_role + person_type + person_type_definition + person_type_definition_formation + position_in_organization + position_in_organization_type + positioned_sketch + procedural_representation + procedural_representation_sequence + product_definition_context_role + product_definition_effectivity + property_distribution_description + qualification + qualification_type + resource_requirement_type + rind + runout_zone_orientation + solid_with_depression + solid_with_hole + solid_with_pocket + solid_with_protrusion + solid_with_shape_element_pattern + solid_with_slot + state_type_role + structured_mesh + swept_area_solid + symbol_target + time_role + tolerance_zone_form + two_direction_repeat_factor + unstructured_mesh + user_selected_elements + variational_representation_item + view_volume + volume;--&lt;make a union of all implicit populations of the FOR-clause&gt;
number_of_input_instances := SIZEOF(all_instances);
(* Collect all type strings of all FOR instances into one set. *)
REPEAT i:=1 TO number_of_input_instances;
  set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
END_REPEAT;</algorithm>
         <where expression="dependently_instantiated(all_instances, set_of_input_types,&#10;                                previous_in_chain)" label="WR1"/>
      </rule>
      <function name="acyclic">
         <parameter name="arg1">
            <typename name="generic_expression"/>
         </parameter>
         <parameter name="arg2">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;
	RETURN (result);</algorithm>
      </function>
      <function name="acyclic_composite_text">
         <parameter name="start_composite">
            <typename name="composite_text"/>
         </parameter>
         <parameter name="child_text">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="text_or_character"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      i : INTEGER;
      local_composite_text : SET [0:?] OF composite_text;
      local_annotation_text : SET [0:?] OF annotation_text;
      local_children : SET [0:?] OF text_or_character;
    END_LOCAL;

    local_composite_text := QUERY (child &lt;* child_text |
                          ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

    IF (SIZEOF (local_composite_text) &gt; 0) 
      THEN
        REPEAT i := 1 TO HIINDEX (local_composite_text);
          IF (start_composite :=: local_composite_text[i]) 
            THEN
              RETURN (FALSE);
          END_IF;
        END_REPEAT;
    END_IF;

    local_children := child_text;

    IF (SIZEOF (local_composite_text)) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX (local_composite_text);
        local_children := local_children +
                          local_composite_text[i].collected_text;
      END_REPEAT;
    END_IF;

    local_annotation_text := QUERY (child &lt;* child_text |
                            ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT'
                             IN TYPEOF (child)));

    IF (SIZEOF (local_annotation_text) &gt; 0) THEN
      REPEAT i := 1 TO HIINDEX (local_annotation_text);
        local_children := local_children +
        QUERY (item &lt;* local_annotation_text[i]\mapped_item.
                       mapping_source.mapped_representation.items |
          SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ANNOTATION_TEXT',
                  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_TEXT'] *
                  TYPEOF(item)) &gt; 0);
      END_REPEAT;
    END_IF;

    IF (local_children :&lt;&gt;: child_text) THEN
      RETURN (acyclic_composite_text (start_composite, local_children));
    ELSE
      RETURN (TRUE);
    END_IF;</algorithm>
      </function>
      <function name="acyclic_curve_replica">
         <parameter name="rep">
            <typename name="curve_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_mapped_item_usage">
         <parameter name="rep">
            <typename name="representation"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    items : SET OF representation_item;
  END_LOCAL;

  items := QUERY (item &lt;* rep.items |
           'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM' IN TYPEOF (item));
  IF SIZEOF (items) = 0
  THEN 
    RETURN (FALSE);
  ELSE 
    REPEAT i := 1 TO HIINDEX (items);
      IF items[i]\mapped_item.mapping_source.mapped_representation :=: rep
      THEN 
        RETURN (TRUE);
      ELSE 
        RETURN (acyclic_mapped_item_usage(items[i]\
                  mapped_item.mapping_source.mapped_representation));
      END_IF;
    END_REPEAT;
  RETURN (FALSE);
  END_IF;</algorithm>
      </function>
      <function name="acyclic_mapped_representation">
         <parameter name="mi">
            <typename name="mapped_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      rms : SET OF representation_map;
      mis : SET OF mapped_item;
      rs1, rs2 : SET OF representation;
    END_LOCAL;
 
    rs1 := using_representations(mi);
    rs2 := [];
    -- loop as long as there are elements in rs1
    REPEAT WHILE SIZEOF(rs1) &gt; 0; 
      REPEAT i := 1 TO HIINDEX(rs1);
        -- Determine the set of representation_map that reference the parent_set
        rms := bag_to_set(USEDIN(rs1[i], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
        IF SIZEOF(rms) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(rms);
            mis := bag_to_set(USEDIN(rms[i], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAPPED_ITEM.MAPPING_SOURCE'));
            IF SIZEOF(mis) &gt; 0 THEN
              REPEAT j := 1 TO HIINDEX(mis);
                -- check mis members for instance equal with mi. If so then there is a cycle
                IF mis[i] :=: mi THEN
                  RETURN (FALSE);
                END_IF;
                rs2 := rs2 + using_representations(mis[i]);
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
      rs1 := rs2;
      rs2 := [];
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_point_replica">
         <parameter name="rep">
            <typename name="point_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_product_definition_relationship">
         <parameter name="relation">
            <typename name="product_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.relating_product_definition, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_representation_relationship">
         <parameter name="relation">
            <typename name="representation_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate lower="1" type="SET" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r &lt;* bag_to_set(USEDIN(relation.rep_1, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_solid_replica">
         <parameter name="rep">
            <typename name="solid_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="solid_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_surface_replica">
         <parameter name="rep">
            <typename name="surface_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;</algorithm>
      </function>
      <function name="advanced_face_properties">
         <parameter name="testface">
            <typename name="face"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(testface) THEN
    RETURN (TRUE);
END_IF;
(* if testface is a subface recursively test the parent_face,
return FALSE for all other types of face *)
IF  ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(testface)) THEN
     RETURN(advanced_face_properties(testface\subface.parent_face));
   ELSE RETURN (FALSE);
END_IF;</algorithm>
      </function>
      <function name="all_members_of_es">
         <parameter name="sv">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="maths_value"/>
         </parameter>
         <parameter name="es">
            <typename name="elementary_space_enumerators"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>CONSTANT
    base_types : SET OF STRING := ['NUMBER','COMPLEX_NUMBER_LITERAL','REAL',
      'INTEGER','LOGICAL','BOOLEAN','STRING','BINARY','MATHS_SPACE',
      'MATHS_FUNCTION','LIST','ELEMENTARY_SPACE_ENUMERATORS','ORDERING_TYPE',
      'LOWER_UPPER','SYMMETRY_TYPE','ELEMENTARY_FUNCTION_ENUMERATORS',
      'OPEN_CLOSED','SPACE_CONSTRAINT_TYPE','REPACKAGE_OPTIONS',
      'EXTENSION_OPTIONS'];
  END_CONSTANT;
  LOCAL
    v : maths_value;
    key_type : STRING := '';
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;
  IF NOT EXISTS (sv) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  CASE es OF
  es_numbers :         key_type := 'NUMBER';
  es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
  es_reals :           key_type := 'REAL';
  es_integers :        key_type := 'INTEGER';
  es_logicals :        key_type := 'LOGICAL';
  es_booleans :        key_type := 'BOOLEAN';
  es_strings :         key_type := 'STRING';
  es_binarys :         key_type := 'BINARY';
  es_maths_spaces :    key_type := 'MATHS_SPACE';
  es_maths_functions : key_type := 'MATHS_FUNCTION';
  es_generics :        RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF (sv);
    IF NOT EXISTS (sv[i]) THEN  RETURN (FALSE);  END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN  SKIP;  END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN  SKIP;  END_IF;
    IF SIZEOF (base_types * types) &gt; 0 THEN  RETURN (FALSE);  END_IF;
    -- Must be a generic_expression which doesn't simplify and which is not a
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc,es) THEN
        IF NOT compatible_spaces(vspc,make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (cum);</algorithm>
      </function>
      <function name="any_space_satisfies">
         <parameter name="sc">
            <typename name="space_constraint_type"/>
         </parameter>
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN (?);</algorithm>
      </function>
      <function name="appropriate_list_value_existence">
         <parameter name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="type_self">
            <aggregate lower="1" type="SET" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values);
       IF NOT (appropriate_value_existence (values[i], type_self)) THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="appropriate_set_value_existence">
         <parameter name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="type_self">
            <aggregate lower="1" type="SET" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     i                      : INTEGER;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX (values_and_locations);
       IF NOT (appropriate_value_existence
                (values_and_locations[i].simple_value, type_self)) 
          THEN
          RETURN (FALSE);
       END_IF;
    END_REPEAT;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="appropriate_value_existence">
         <parameter name="a_value_e">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="type_self">
            <aggregate lower="1" type="SET" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     feacr                  : STRING;
     value_typeof           : SET [1:?] OF STRING;
    END_LOCAL;
        
    feacr := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    value_typeof := TYPEOF(a_value_e);

    IF (((feacr + 'OUTPUT_REQUEST_STATE') IN type_self) AND
       NOT ((feacr + 'UNSPECIFIED_VALUE') IN value_typeof)) THEN
       RETURN (FALSE);
    END_IF;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="aspect_ratio">
         <parameter name="p">
            <typename name="planar_box"/>
         </parameter>
         <typename name="positive_ratio_measure"/>
         <algorithm>IF (p.size_in_x &gt; 0.) AND (p.size_in_y &gt; 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
    ELSE
      RETURN (?);
    END_IF;</algorithm>
      </function>
      <function name="assoc_product_space">
         <parameter name="ts1">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="ts2">
            <typename name="tuple_space"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>LOCAL
    types1 : SET OF STRING := stripped_typeof (ts1);
    types2 : SET OF STRING := stripped_typeof (ts2);
    up1, up2 : uniform_product_space := make_uniform_product_space(the_reals,1);
    lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
    et1, et2, ets : extended_tuple_space := the_tuples;
    use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    up1 := ts1;  use_up1 := true;  use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      lp1 := ts1;  use_up1 := false;  use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et1 := ts1;  use_up1 := false;  use_lp1 := false;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
    up2 := ts2;  use_up2 := true;  use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      lp2 := ts2;  use_up2 := false;  use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et2 := ts2;  use_up2 := false;  use_lp2 := false;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base : up1.exponent, up2.base : up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up1.base : up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up2.base : up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          -- No subtype is available to represent this cartesian product.
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF (factors);
            IF et1.extender &lt;&gt; factors[i] THEN
              -- No subtype available to represent this cartesian product.
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            -- Next line may assign indeterminate (?) to tspace.
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            -- No subtype available to represent this cartesian product.
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);</algorithm>
      </function>
      <function name="associated_surface">
         <parameter name="arg">
            <typename name="pcurve_or_surface"/>
         </parameter>
         <typename name="surface"/>
         <algorithm>LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(arg) THEN
     surf := arg\pcurve.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);</algorithm>
      </function>
      <function name="atan2">
         <parameter name="y">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="x">
            <builtintype type="REAL"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
    r : REAL;
  END_LOCAL;
  IF (y = 0.0) AND (x = 0.0) THEN  RETURN (?);  END_IF;
  r := atan(y,x);
  IF x &lt; 0.0 THEN
    IF y &lt; 0.0 THEN  r := r - PI;
    ELSE             r := r + PI;  END_IF;
  END_IF;
  RETURN (r);</algorithm>
      </function>
      <function name="bag_to_set">
         <parameter name="the_bag">
            <aggregate lower="0" type="BAG" upper="?"/>
            <builtintype type="GENERIC" typelabel="intype"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <builtintype type="GENERIC" typelabel="intype"/>
         <algorithm>LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);</algorithm>
      </function>
      <function name="base_axis">
         <parameter name="dim">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="axis1">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis2">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis3">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor &lt; 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);</algorithm>
      </function>
      <function name="bool">
         <parameter name="lgcl">
            <builtintype type="LOGICAL"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl &lt;&gt; TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="boolean_choose">
         <parameter name="b">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="choice1">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <parameter name="choice2">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <builtintype type="GENERIC" typelabel="item"/>
         <algorithm>IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;</algorithm>
      </function>
      <function name="build_2axes">
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="2"/>
         <typename name="direction"/>
         <algorithm>LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);</algorithm>
      </function>
      <function name="build_axes">
         <parameter name="axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate lower="3" type="LIST" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2))\vector.orientation, d1]);</algorithm>
      </function>
      <function name="build_direction_node">
         <parameter name="node_1">
            <typename name="node_representation"/>
         </parameter>
         <parameter name="node_2">
            <typename name="node_representation"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="3"/>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
  nodal_direction_ratios    : LIST [2:3] OF REAL;
  u                         : direction;
  i                         : INTEGER;
  ndim                      : INTEGER;
  rep_items                 : SET [1:?] of representation_item;
  node_1_point              : cartesian_point;
  node_2_point              : cartesian_point;
END_LOCAL;

rep_items := node_1.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_1_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

rep_items := node_2.items;
REPEAT i := 1 TO SIZEOF(rep_items);
  IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(rep_items[i])) THEN
    node_2_point := rep_items[i];
    ESCAPE;
  END_IF; 
END_REPEAT;

ndim := HIINDEX(node_2_point.coordinates);
REPEAT i := 1 TO ndim;
  u.direction_ratios[i] := node_2_point.coordinates[i] - 
                           node_1_point.coordinates[i];
END_REPEAT;

u := normalise (u);
REPEAT i := 1 TO ndim;
  nodal_direction_ratios[i] := u.direction_ratios[i];
END_REPEAT;

RETURN (nodal_direction_ratios);</algorithm>
      </function>
      <function name="categories_of_product">
         <parameter name="obj">
            <typename name="product"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <builtintype type="STRING"/>
         <algorithm>LOCAL
  category_assignments: BAG OF product_category;
  categories: SET OF STRING:=[];
END_LOCAL;
category_assignments := USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
  categories := categories + category_assignments[i].name;
END_REPEAT;
RETURN(categories);</algorithm>
      </function>
      <function name="cc_design_person_and_organization_correlation">
         <parameter name="e">
            <typename name="cc_design_person_and_organization_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      po_role : STRING;
    END_LOCAL;
      po_role := e\person_and_organization_assignment.role.name;
    CASE po_role OF
      'request_recipient'      : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CHANGE_REQUEST',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'START_REQUEST'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
      'initiator'              : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CHANGE_REQUEST',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'START_REQUEST',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'START_WORK',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CHANGE'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
      'creator'                : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION_FORMATION',
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN (FALSE);
                               END_IF;
      'part_supplier'          : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'design_supplier'        : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'design_owner'           : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'configuration_manager'  : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'CONFIGURATION_ITEM'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'contractor'             : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONTRACT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'classification_officer' : IF SIZEOF (e.items) &lt;&gt;
                                 SIZEOF (QUERY (x &lt;* e.items |
                                 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
                                 'SECURITY_CLASSIFICATION'
                                 IN TYPEOF (x))) THEN
                                 RETURN(FALSE);
                               END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="cell_counts">
         <parameter name="arg">
            <typename name="vertex_defined_cell"/>
         </parameter>
         <aggregate lower="1" type="ARRAY" upper="3"/>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
  om1    : INTEGER := 0;      -- (order - 1)
  om1sq  : INTEGER := om1**2; -- (order - 1) squared
  vts    : INTEGER;           -- number of bounding vertices
  eds    : INTEGER;           -- number of edges
  qf     : INTEGER := 0;      -- number of quadrilateral faces
  tf     : INTEGER := 0;      -- number of triangular faces
  result : ARRAY [1:3] OF INTEGER := [0,0,0];
END_LOCAL;
  CASE arg.order OF
    linear    : om1 := 0;
    quadratic : om1 := 1;
    cubic     : om1 := 2;
    OTHERWISE : RETURN(result);
  END_CASE;
  om1sq := om1**2;
  CASE arg.shape OF
    arg.shape.single : 
        BEGIN
          vts := 1; eds := 0; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 0, 0
          result[3] := 0;                         -- 0, 0, 0
        END;
    arg.shape.line :
        BEGIN
          vts := 2; eds := 1; qf := 0; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 1, 2
          result[3] := 0;                         -- 0, 0, 0
        END;
    arg.shape.quadrilateral : 
        BEGIN
          vts := 4; eds := 4; qf := 1; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 4, 8
          result[3] := om1sq*qf;                  -- 0, 1, 4
        END;
    arg.shape.triangle : 
        BEGIN
          vts := 3; eds := 3; qf := 0; tf := 1;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 3, 6
          result[3] := (om1-1)*tf;                --    0, 1
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    arg.shape.polygon :
        BEGIN
          vts := arg.vn_count; eds := arg.vn_count; 
          result[1] := vts;
          result[2] := 0;
          result[3] := 0;
        END;
    arg.shape.hexahedron :
        BEGIN
          vts := 8; eds := 12; qf := 6; tf := 0;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 12, 24
          result[3] := om1sq*(qf+om1);            -- 0, 7, 32
        END;
    arg.shape.wedge :
        BEGIN
          vts := 6; eds := 9; qf := 3; tf := 2;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 9,  18
          result[3] := om1sq*qf + om1*tf;         -- 0, 3, 16
        END;
    arg.shape.tetrahedron : 
        BEGIN
          vts := 4; eds := 6; qf := 0; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 6, 12
          result[3] := (om1-1)*tf;                --    0, 4
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
    arg.shape.pyramid : 
        BEGIN
          vts := 5; eds := 8; qf := 1; tf := 4;
          result[1] := vts;
          result[2] := om1*eds;                   -- 0, 8, 16
          result[3] := om1sq*qf + (om1-1)*tf;     --    1, 9
          CASE arg.order OF
            linear : result[3] := 0;              -- 0
          END_CASE;
        END;
  END_CASE;
RETURN(result);</algorithm>
      </function>
      <function name="check_continuous_edges">
         <parameter name="edges">
            <aggregate lower="0" type="LIST" unique="YES" upper="?"/>
            <typename name="edge_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    i           : INTEGER;
    next_vertex : vertex;
  END_LOCAL;

  -- first check whether there is only one edge in the list: in this
  -- case there is no connectivity to be checked.

  IF (SIZEOF(edges) = 1)
  THEN RETURN(TRUE);
  END_IF;

  -- otherwise, establish the matching vertices of edges 1 and 2 in 
  -- the list, and determine the vertex of edge 2 to which edge 3, 
  -- must be connected, if there are more than two edges in the list.

  IF ((edges[2].edge_start :=: edges[1].edge_end)
    XOR (edges[2].edge_start :=: edges[1].edge_start))
  THEN next_vertex := edges[2].edge_end;
  ELSE 
    IF ((edges[2].edge_end :=: edges[1].edge_end)
      XOR (edges[2].edge_end :=: edges[1].edge_start))
    THEN next_vertex := edges[2].edge_start;
    ELSE RETURN(FALSE); -- no match between any vertices of edges 1 and 2 
    END_IF;
  END_IF;

  -- exit if there are only two edges and they are connected

  IF (SIZEOF(edges) = 2)
  THEN RETURN(TRUE);
  END_IF;

  -- otherwise, check that any remaining edges are connected in list order.

  REPEAT i := 3 TO HIINDEX(edges);
    IF (edges[i].edge_start :=: next_vertex)
    THEN next_vertex := edges[i].edge_end;
    ELSE
      IF (edges[i].edge_end :=: next_vertex)
      THEN next_vertex := edges[i].edge_start;
      ELSE RETURN(FALSE); -- no match is found.
      END_IF;
    END_IF; 
  END_REPEAT;
  RETURN(TRUE);</algorithm>
      </function>
      <function name="check_sparse_index_domain">
         <parameter name="idxdom">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="base">
            <typename name="zero_or_one"/>
         </parameter>
         <parameter name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
         </parameter>
         <parameter name="order">
            <typename name="ordering_type"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows THEN  i := 1;  ELSE  i := 2;  END_IF;
  RETURN (bool((interval.min &lt;= base) AND (interval.max &gt;= base + shape[i])));</algorithm>
      </function>
      <function name="check_sparse_index_to_loc">
         <parameter name="index_range">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="loc_domain">
            <typename name="tuple_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    temp : maths_space;
    idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;
  temp := factor1 (index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1 (loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min &lt;= idx_rng_itvl.min) AND
    (idx_rng_itvl.max &lt;= loc_dmn_itvl.max+1)));</algorithm>
      </function>
      <function name="check_sparse_loc_range">
         <parameter name="locrng">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="base">
            <typename name="zero_or_one"/>
         </parameter>
         <parameter name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
         </parameter>
         <parameter name="order">
            <typename name="ordering_type"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  IF space_dimension(locrng) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN  i := 2;  ELSE  i := 1;  END_IF;
  RETURN (bool((interval.min &gt;= base) AND (interval.max &lt;= base + shape[i] - 1)));</algorithm>
      </function>
      <function name="check_text_alignment">
         <parameter name="ct">
            <typename name="composite_text"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    a : SET OF text_alignment := [];
  END_LOCAL;

  -- create a set of all the alignments
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    a := a + [ct.collected_text[i]\text_literal.alignment];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all alignments were the same
  RETURN (SIZEOF(a) = 1);</algorithm>
      </function>
      <function name="check_text_font">
         <parameter name="ct">
            <typename name="composite_text"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    f : SET OF font_select := [];
  END_LOCAL;

  -- build a set of all the fonts
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    f := f + [ct.collected_text[i]\text_literal.font];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all fonts were the same
  RETURN (SIZEOF(f) &lt;= 1);</algorithm>
      </function>
      <function name="class_assignment_is_valid">
         <parameter name="aia">
            <typename name="applied_classification_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  item: classification_item;
  role: classification_role;
END_LOCAL;

role:= aia\classification_assignment.role;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'CLASS_SYSTEM' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
  IF(role\classification_role.name &lt;&gt; 'class system membership') THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i:=LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
    item:= aia\applied_classification_assignment.items[i];

    IF (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CLASS_SYSTEM_ITEM'] * TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a class_system
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
  IF	NOT(role\classification_role.name IN ['definitional','non-definitional','']) THEN
    RETURN(FALSE); 
  END_IF;


  REPEAT i:=LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
    item:= aia\applied_classification_assignment.items[i];

    IF (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'CLASSIFIED_ITEM'] * TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a characterized_class
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

  IF
   (role\classification_role.name = 'definitional')
   THEN
     IF NOT
      (SIZEOF(QUERY(it &lt;* aia\applied_classification_assignment.items | NOT
             (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION_FORMATION', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRODUCT_DEFINITION'] * TYPEOF(it)) = 1)
      )) = 0 )
      THEN
      RETURN(FALSE); 
     END_IF;
  END_IF;

RETURN(TRUE);</algorithm>
      </function>
      <function name="closed_shell_reversed">
         <parameter name="a_shell">
            <typename name="closed_shell"/>
         </parameter>
         <typename name="oriented_closed_shell"/>
         <algorithm>LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="compare_basis_and_coef">
         <parameter name="basis">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="b_spline_basis"/>
         </parameter>
         <parameter name="coef">
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;
  IF NOT EXISTS (basis) OR NOT EXISTS (coef) THEN  RETURN (FALSE);  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS (shape) THEN  RETURN (FALSE);  END_IF;
  IF SIZEOF (shape) &lt; SIZEOF (basis) THEN  RETURN (FALSE);  END_IF;
  REPEAT i := 1 TO SIZEOF (basis);
    IF (basis[i].num_basis = shape[i]) &lt;&gt; TRUE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="compatible_complex_number_regions">
         <parameter name="sp1">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="sp2">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    typenames : SET OF string := stripped_typeof (sp1);
    crgn1, crgn2 : cartesian_complex_number_region;
    prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
    sp1_is_crgn, sp2_is_crgn : BOOLEAN;
  END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof (sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    -- two cartesian regions
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)
      AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND
    (prgn1.centre.real_part = prgn2.centre.real_part) AND
    (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    -- two polar regions with common centre
    IF NOT compatible_intervals(prgn1.distance_constraint,
      prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint,
      prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    -- Deal with direction ambiguity by 2 pi.
    IF (prgn1.direction_constraint.max &gt; PI) AND (prgn2.direction_constraint.max &lt; PI)
      THEN
      RETURN (compatible_intervals(prgn2.direction_constraint,
        make_finite_real_interval(-PI,open,prgn1.direction_constraint.max-2.0*PI,
        prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max &gt; PI) AND (prgn1.direction_constraint.max &lt; PI)
      THEN
      RETURN (compatible_intervals(prgn1.direction_constraint,
        make_finite_real_interval(-PI,open,prgn2.direction_constraint.max-2.0*PI,
        prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1,prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2,prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1,prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2,prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1,prgn2c1)
    AND compatible_complex_number_regions(prgn1c2,prgn2));</algorithm>
      </function>
      <function name="compatible_es_values">
         <parameter name="esval1">
            <typename name="elementary_space_enumerators"/>
         </parameter>
         <parameter name="esval2">
            <typename name="elementary_space_enumerators"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    esval1_is_numeric, esval2_is_numeric : LOGICAL;
  END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 &gt;= es_numbers) AND (esval1 &lt;= es_integers);
  esval2_is_numeric := (esval2 &gt;= es_numbers) AND (esval2 &lt;= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR
    (esval2_is_numeric AND (esval1 = es_numbers)) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR
    ((esval1 = es_booleans) AND (esval2 = es_logicals)) THEN
    RETURN (TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN (FALSE);</algorithm>
      </function>
      <function name="compatible_intervals">
         <parameter name="sp1">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="sp2">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    amin, amax : REAL;
  END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);  amax := real_max(sp2);
    IF amin &gt; amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);  amax := real_max(sp1);
    IF amin &gt; amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="compatible_spaces">
         <parameter name="sp1">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="sp2">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    types1 : SET OF STRING := stripped_typeof (sp1);
    types2 : SET OF STRING := stripped_typeof (sp2);
    lgcl : LOGICAL := UNKNOWN;
    m, n : INTEGER;
    s1, s2 : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN types1 THEN
    REPEAT i := 1 TO SIZEOF (sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl &lt;&gt; FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2 THEN
    REPEAT i := 1 TO SIZEOF (sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl &lt;&gt; FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id,
        sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR
      ('REAL_INTERVAL_FROM_MIN' IN types1) OR
      ('REAL_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1,es_integers) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_integers) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_reals) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_reals) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_complex_numbers) THEN  -- Note sp1 finite already handled.
    IF subspace_of_es(sp2,es_complex_numbers) THEN  -- Note sp2 finite already handled.
      RETURN (compatible_complex_number_regions(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF sp1\uniform_product_space.exponent &lt;&gt; sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base,
        sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      n := SIZEOF (sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent &lt;&gt; n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base,
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m &lt; n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
    n := SIZEOF (sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF n &lt;&gt; sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base,
          sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      IF n &lt;&gt; SIZEOF (sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i],
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n &lt; m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR
      ('LISTED_PRODUCT_SPACE' IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender,
        sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n &lt; m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
          make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
          sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          sp2\extended_tuple_space.base));
      END_IF;
      IF n &gt; m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          assoc_product_space(sp2\extended_tuple_space.base,
          make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'FUNCTION_SPACE' IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN (TRUE);</algorithm>
      </function>
      <function name="composable_sequence">
         <parameter name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO SIZEOF (operands) - 1;
    IF NOT compatible_spaces (operands[i].range, operands[i+1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="compute_total_depth">
         <parameter name="swsrh">
            <typename name="solid_with_stepped_round_hole"/>
         </parameter>
         <typename name="positive_length_measure"/>
         <algorithm>LOCAL
i  : positive_integer;
n  : positive_integer := swsrh.segments;
td : positive_length_measure := swsrh.segment_depths[1];
END_LOCAL;

IF n = 1 
THEN RETURN(td);
ELSE
  REPEAT i := 2 TO n;
    td := td + swsrh.segment_depths[i];
  END_REPEAT;
END_IF;
RETURN(td);</algorithm>
      </function>
      <function name="conditional_reverse">
         <parameter name="p">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;</algorithm>
      </function>
      <function name="consistent_element_or_group_reference">
         <parameter name="aspect">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="element">
            <builtintype type="GENERIC"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  srrs                      : STRING;
  i                         : INTEGER;
END_LOCAL;

srrs := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';

IF ((srrs + 'ELEMENT_REPRESENTATION') IN TYPEOF(element)) THEN
  RETURN (consistent_element_reference (aspect, element));
END_IF;

IF ((srrs + 'ELEMENT_GROUP') IN TYPEOF(element)) THEN
  REPEAT i := 1 TO HIINDEX (element.elements);
    IF NOT (consistent_element_reference (aspect, element.elements[i])) 
     THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_IF;

RETURN (FALSE);</algorithm>
      </function>
      <function name="consistent_element_reference">
         <parameter name="aspect">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="element">
            <typename name="element_representation"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  element_type              : SET [1:?] OF STRING;
END_LOCAL;

srrs         := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
feacr        := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
aspect_type  := TYPEOF (aspect);
element_type := TYPEOF (element);

IF ((srrs + 'ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'VOLUME_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'VOLUME_3D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_VOLUME_2D_ELEMENT_REPRESENTATION')
     IN element_type) OR
    ((srrs + 'PLANE_VOLUME_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF (((feacr + 'VOLUME_2D_FACE') IN aspect_type) OR
      ((feacr + 'VOLUME_2D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF ((srrs + 'SURFACE_3D_ELEMENT_REPRESENTATION')
    IN element_type) THEN
  IF (((feacr + 'SURFACE_3D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_3D_EDGE') IN aspect_type)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'AXISYMMETRIC_SURFACE_2D_ELEMENT_REPRESENTATION')
    IN element_type) OR
    ((srrs + 'PLANE_SURFACE_2D_ELEMENT_REPRESENTATION')
     IN element_type)) THEN
  IF (((feacr + 'SURFACE_2D_FACE') IN aspect_type) OR
      ((feacr + 'SURFACE_2D_EDGE') IN aspect_type)) THEN
  RETURN (TRUE);
  END_IF;
END_IF;

IF (((srrs + 'CURVE_3D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'AXISYMMETRIC_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type) OR
    ((srrs + 'PLANE_CURVE_2D_ELEMENT_REPRESENTATION') 
     IN element_type)) THEN
  IF ((srrs + 'CURVE_EDGE') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);</algorithm>
      </function>
      <function name="consistent_geometric_reference">
         <parameter name="aspect">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  srrs                      : STRING;
  feacr                     : STRING;
  aspect_type               : SET [1:?] OF STRING;
  item_type                 : SET [1:?] OF STRING;
END_LOCAL;

srrs        := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
feacr       := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
aspect_type := TYPEOF (aspect);
item_type   := TYPEOF (item);

IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_MODEL' IN item_type) THEN
  IF ((srrs + 'ELEMENT_VOLUME') IN aspect_type) THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN item_type) OR
    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_SURFACE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_FACE'),
              (feacr + 'VOLUME_2D_FACE'),
              (feacr + 'SURFACE_3D_FACE'),
              (feacr + 'SURFACE_2D_FACE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE' IN item_type) OR
    ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE_CURVE' IN item_type)) THEN
  IF SIZEOF ([(feacr + 'VOLUME_3D_EDGE'),
              (feacr + 'VOLUME_2D_EDGE'),
              (feacr + 'SURFACE_3D_EDGE'), 
              (feacr + 'SURFACE_2D_EDGE'),
              (srrs  + 'CURVE_EDGE')] *
               aspect_type ) = 1 THEN
    RETURN (TRUE);
  END_IF;
END_IF;

RETURN (FALSE);</algorithm>
      </function>
      <function name="consistent_list_values">
         <parameter name="values">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="field_value"/>
         </parameter>
         <parameter name="variable">
            <builtintype type="GENERIC"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values);

       fv_type := TYPEOF (values[i]);

       IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="consistent_set_values">
         <parameter name="values_and_locations">
            <aggregate lower="1" type="SET" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="variable">
            <builtintype type="GENERIC"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
     i                      : INTEGER;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    REPEAT i := 1 TO HIINDEX (values_and_locations);

       fv_type := TYPEOF (values_and_locations[i].simple_value);

       IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
           'UNSPECIFIED_VALUE') IN fv_type) THEN

          IF NOT (vv_type IN fv_type) THEN
             RETURN (FALSE);
          END_IF;

       END_IF;

    END_REPEAT;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="consistent_topological_reference">
         <parameter name="aspect">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="item">
            <typename name="topological_representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      status : BOOLEAN;
      srrs   : STRING;
    END_LOCAL;

    status := FALSE;
    srrs := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';

    IF (srrs + 'ELEMENT_VOLUME') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_3D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_2D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'SURFACE_3D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'SURFACE_2D_FACE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_3D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'VOLUME_2D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'SURFACE_3D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;



    IF (srrs + 'SURFACE_2D_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX' IN TYPEOF(item) THEN
        status := TRUE;
      END_IF;
    END_IF;

    IF (srrs + 'CURVE_EDGE') IN TYPEOF(aspect) THEN
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF(item) THEN
        status := TRUE;

      END_IF;
    END_IF;

    IF 'TOPOLOGICAL_DEFINITION_AND_MESH_SCHEMA.TOPOLOGICAL_REGION' IN TYPEOF(item) THEN
      status := TRUE;
    END_IF;

  RETURN(status);</algorithm>
      </function>
      <function name="consistent_value">
         <parameter name="c_value">
            <typename name="field_value"/>
         </parameter>
         <parameter name="variable">
            <builtintype type="GENERIC"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     vv_type                : STRING;
     fv_type                : SET [1:?] OF STRING;
    END_LOCAL;

    vv_type := variable_value_type (variable);

    fv_type := TYPEOF (c_value);

    IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' +
       'UNSPECIFIED_VALUE') IN fv_type) THEN

       IF NOT (vv_type IN fv_type) THEN
          RETURN (FALSE);
       END_IF;

    END_IF;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="constraints_composite_curve_on_surface">
         <parameter name="c">
            <typename name="composite_curve_on_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_surface_model">
         <parameter name="m">
            <typename name="shell_based_surface_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_wireframe_model">
         <parameter name="m">
            <typename name="shell_based_wireframe_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="constraints_param_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knot_mult">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR
         (sum &lt;&gt; (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k &lt; 1) OR (k &gt; degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i &lt; up_knots) AND (k &gt; degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k &gt; degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="constraints_rectangular_composite_surface">
         <parameter name="s">
            <typename name="rectangular_composite_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="control_characters_free">
         <parameter name="s">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      ch : STRING;
    END_LOCAL;

    REPEAT i:=1 TO LENGTH(s);
      ch := s[i];
      IF (ch = '\x9') OR (ch = '\xA') OR (ch = '\xD') THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="convert_to_literal">
         <parameter name="val">
            <typename name="maths_atom"/>
         </parameter>
         <typename name="generic_literal"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (val);
  END_LOCAL;
  IF 'INTEGER' IN types THEN  RETURN (make_int_literal (val));      END_IF;
  IF 'REAL'    IN types THEN  RETURN (make_real_literal (val));     END_IF;
  IF 'BOOLEAN' IN types THEN  RETURN (make_boolean_literal (val));  END_IF;
  IF 'STRING'  IN types THEN  RETURN (make_string_literal (val));   END_IF;
  IF 'LOGICAL' IN types THEN  RETURN (make_logical_literal (val));  END_IF;
  IF 'BINARY'  IN types THEN  RETURN (make_binary_literal (val));   END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types THEN
    RETURN (make_maths_enum_literal (val));
  END_IF;
  -- Should be unreachable
  RETURN (?);</algorithm>
      </function>
      <function name="convert_to_maths_function">
         <parameter name="func">
            <typename name="maths_function_select"/>
         </parameter>
         <typename name="maths_function"/>
         <algorithm>LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF (func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function (efenum);
  END_IF;
  RETURN (mthfun);</algorithm>
      </function>
      <function name="convert_to_maths_value">
         <parameter name="val">
            <builtintype type="GENERIC" typelabel="G"/>
         </parameter>
         <typename name="maths_value"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (val);
    ival  : maths_integer;
    rval  : maths_real;
    nval  : maths_number;
    tfval : maths_boolean;
    lval  : maths_logical;
    sval  : maths_string;
    bval  : maths_binary;
    tval  : maths_tuple := the_empty_maths_tuple;
    mval  : maths_value;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types THEN  RETURN (val);  END_IF;
  IF 'INTEGER' IN types THEN  ival := val;   RETURN (ival);   END_IF;
  IF 'REAL'    IN types THEN  rval := val;   RETURN (rval);   END_IF;
  IF 'NUMBER'  IN types THEN  nval := val;   RETURN (nval);   END_IF;
  IF 'BOOLEAN' IN types THEN  tfval := val;  RETURN (tfval);  END_IF;
  IF 'LOGICAL' IN types THEN  lval := val;   RETURN (lval);   END_IF;
  IF 'STRING'  IN types THEN  sval := val;   RETURN (sval);   END_IF;
  IF 'BINARY'  IN types THEN  bval := val;   RETURN (bval);   END_IF;
  IF 'LIST' IN types THEN
    REPEAT i := 1 TO SIZEOF (val);
      mval := convert_to_maths_value (val[i]);
      IF NOT EXISTS (mval) THEN  RETURN (?);  END_IF;
      INSERT (tval, mval, i-1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);</algorithm>
      </function>
      <function name="convert_to_operand">
         <parameter name="val">
            <typename name="maths_value"/>
         </parameter>
         <typename name="generic_expression"/>
         <algorithm>LOCAL
    types  : SET OF STRING := stripped_typeof (val);
  END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types THEN  RETURN (val);  END_IF;
  IF 'MATHS_ATOM' IN types THEN  RETURN (convert_to_literal (val));  END_IF;
  IF 'ATOM_BASED_VALUE' IN types THEN  RETURN (make_atom_based_literal(val));  END_IF;
  IF 'MATHS_TUPLE' IN types THEN  RETURN (make_maths_tuple_literal(val));  END_IF;
  -- Should be unreachable
  RETURN (?);</algorithm>
      </function>
      <function name="convert_to_operands">
         <parameter name="values">
            <aggregate type="AGGREGATE"/>
            <typename name="maths_value"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="generic_expression"/>
         <algorithm>LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;
  IF NOT EXISTS (values) THEN  RETURN (?);  END_IF;
  REPEAT i := LOINDEX (values) TO HIINDEX (values);
    INSERT (operands, convert_to_operand (values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);</algorithm>
      </function>
      <function name="convert_to_operands_prcmfn">
         <parameter name="srcdom">
            <typename name="maths_space_or_function"/>
         </parameter>
         <parameter name="prepfun">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_function"/>
         </parameter>
         <parameter name="finfun">
            <typename name="maths_function_select"/>
         </parameter>
         <aggregate lower="2" type="LIST" upper="?"/>
         <typename name="generic_expression"/>
         <algorithm>LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;
  INSERT (operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF (prepfun);
    INSERT (operands, prepfun[i], i);
  END_REPEAT;
  INSERT (operands, convert_to_maths_function (finfun), SIZEOF (prepfun)+1);
  RETURN (operands);</algorithm>
      </function>
      <function name="cross_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag &gt; 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;</algorithm>
      </function>
      <function name="curve_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] &lt;= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr2">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF SIZEOF(agg) &lt;= 5 THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr3">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF (SIZEOF(QUERY ( i &lt;* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) 
  AND (i\representation_item.name = 'significant number of digits')) )) = 1) OR 
((SIZEOF(QUERY ( i &lt;* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'lower limit')) )) = 1) AND 
(SIZEOF( QUERY ( i &lt;* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'upper limit')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr4">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF (SIZEOF(QUERY ( i &lt;* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'plus minus tolerance value')) )) = 1) OR 
((SIZEOF(QUERY ( i &lt;* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'lower tolerance value')) )) = 1) AND 
(SIZEOF( QUERY ( i &lt;* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'upper tolerance value')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr5">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF (SIZEOF(QUERY ( i &lt;* agg | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) &lt;= 1) AND 
(SIZEOF(QUERY ( i &lt;* agg | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) = 
  SIZEOF(QUERY ( i &lt;* agg | (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'cell description'))) )) 
THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="definite_integral_check">
         <parameter name="domain">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="vrblint">
            <typename name="input_selector"/>
         </parameter>
         <parameter name="lowerinf">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="upperinf">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  k := vrblint;
  IF k &gt; dim THEN  RETURN (FALSE);  END_IF;
  fspc := factor_space (domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF (fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  IF upperinf AND max_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="definite_integral_expr_check">
         <parameter name="operands">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="generic_expression"/>
         </parameter>
         <parameter name="lowerinf">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="upperinf">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;
  IF NOT lowerinf THEN  nops := nops + 1;  END_IF;
  IF NOT upperinf THEN  nops := nops + 1;  END_IF;
  IF SIZEOF (operands) &lt;&gt; nops THEN  RETURN (FALSE);  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space (operands[2]) THEN  RETURN (FALSE);  END_IF;
  vspc := values_space_of (operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN  RETURN (FALSE);  END_IF;
  IF lowerinf THEN
    IF min_exists (vspc) THEN  RETURN (FALSE);  END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space (operands[3]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[3]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists (vspc) THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF NOT has_values_space (operands[k]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[k]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="definition_for_temporal_spatial_domain">
         <parameter name="domain">
            <typename name="temporal_spatial_domain"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      spatial_set : SET OF spatial_decomposition_of_temporal_spatial_domain;
      behavioural_set : SET OF behavioural_decomposition_of_temporal_spatial_domain;
      domains : SET OF temporal_spatial_domain := [];
      idealising : BAG OF idealisation_relationship;
      spatial_bag : BAG OF spatial_decomposition_of_temporal_spatial_domain;
      behavioural_bag : BAG OF behavioural_decomposition_of_temporal_spatial_domain;
    END_LOCAL;

    idealising := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.IDEALISATION_RELATIONSHIP.IDEALISATION');
    IF SIZEOF(idealising) &gt; 0 THEN
      RETURN (TRUE);
    END_IF;
    spatial_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPATIAL_DECOMPOSITION_OF_TEMPORAL_SPATIAL_DOMAIN.PARTS');
    IF SIZEOF(spatial_bag) &gt; 0 THEN
      spatial_set := bag_to_set(spatial_bag);
      REPEAT i := 1 TO HIINDEX(spatial_set);
        domains := domains + spatial_set[i].whole;
      END_REPEAT;
    END_IF;
    behavioural_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEHAVIOURAL_DECOMPOSITION_OF_TEMPORAL_SPATIAL_DOMAIN.PARTS');
    IF SIZEOF(behavioural_bag) &gt; 0 THEN
      behavioural_set := bag_to_set(behavioural_bag);
      REPEAT i := 1 TO HIINDEX(behavioural_set);
        domains := domains + behavioural_set[i].whole;
      END_REPEAT;
    END_IF;
    IF SIZEOF(domains) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(domains);
        IF definition_for_temporal_spatial_domain(domains[i]) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (FALSE);</algorithm>
      </function>
      <function name="dependently_instantiated">
         <parameter name="set_of_input_instances">
            <aggregate lower="0" type="SET" upper="?"/>
            <builtintype type="GENERIC" typelabel="igen"/>
         </parameter>
         <parameter name="set_of_input_types">
            <aggregate lower="0" type="SET" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <parameter name="previous_in_chain">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="cgen"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  number_of_input_instances     : INTEGER;
  number_of_referring_instances : INTEGER;
  bag_of_referring_instances    : BAG OF GENERIC:igen := [];
  dependently_instantiated_flag : BOOLEAN;
  previous_in_chain_plus        : LIST OF GENERIC:cgen := [];
  result                        : BOOLEAN := true;
  set_of_types                  : SET OF STRING := [];
END_LOCAL;

IF EXISTS(set_of_input_instances) THEN
  number_of_input_instances := SIZEOF(set_of_input_instances);
  (* Add the declared type of bag_of_referring_instances to the set of
     types of the REFERENCEd instances for the subset comparison later.
   *)
  set_of_input_types := set_of_input_types + 'GENERIC';
  REPEAT i:=1 TO number_of_input_instances;
    (* Determine all references to the current input instance. *)
    bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
    IF EXISTS(bag_of_referring_instances) THEN
      number_of_referring_instances := SIZEOF(bag_of_referring_instances);
      dependently_instantiated_flag := false;
      REPEAT j:=1 TO number_of_referring_instances;
        (* Determine the type strings of the current referencing instance.
         *)
        set_of_types := TYPEOF(bag_of_referring_instances[j]);
        (* If the referencing instance is of one of the types of the
           only dependently instantiable select items, the current input
           instance may still be invalidly instantiated.
           Otherwise it is OK, and the next input instance is tested.
         *)
        IF set_of_types &lt;= set_of_input_types THEN -- subset operator
          (* The referring instance is of one of the restricted types.
             However, it may itself be referred to by a valid instance;
             then also the current instance would be valid.
             Thus, call this function recursively with the referring
             instance as input.
             To avoid an infinite loop in case a set of instances
             reference each other in a closed loop, test first whether
             the current referencing instance is in the list of
             previously processed chain members.
           *)
          IF NOT (bag_of_referring_instances[j] IN previous_in_chain) THEN
            previous_in_chain_plus := previous_in_chain +
            set_of_input_instances[i];
            IF dependently_instantiated([bag_of_referring_instances[j]],
              set_of_input_types,
              previous_in_chain_plus) THEN
              dependently_instantiated_flag := true;
              ESCAPE; -- dependently instantiated; next input instance
            ELSE
              (* Not dependently instantiated: go to next referring
              instance. *)
              SKIP;
            END_IF;
          END_IF;
        ELSE
          dependently_instantiated_flag := true;
          ESCAPE; -- dependently instantiated; take next input instance
        END_IF;
      END_REPEAT;
      IF NOT dependently_instantiated_flag THEN
        RETURN(false);
      END_IF;
    ELSE
      RETURN(false); -- not referenced at all =&gt; invalidly instantiated
    END_IF;
  END_REPEAT;
ELSE
  RETURN(false); -- no input
END_IF;

RETURN(true);</algorithm>
      </function>
      <function name="derive_angle">
         <parameter name="placement_1">
            <typename name="axis2_placement_3d"/>
         </parameter>
         <parameter name="placement_2">
            <typename name="axis2_placement_3d"/>
         </parameter>
         <typename name="plane_angle_measure"/>
         <algorithm>LOCAL
      v1     : direction;
      v2     : direction;
      mag_v1 : REAL;
      mag_v2 : REAL;
      theta  : plane_angle_measure;
    END_LOCAL;
    v1 := placement_1.p[1];
    v2 := placement_2.p[1];
    mag_v1 := SQRT (v1.direction_ratios[1]*v1.direction_ratios[1] +
                    v1.direction_ratios[2]*v1.direction_ratios[2]);
    mag_v2 := SQRT (v2.direction_ratios[1]*v2.direction_ratios[1] +
                    v2.direction_ratios[2]*v2.direction_ratios[2]);
    IF ((mag_v1 = 0.0) OR (mag_v2 = 0.0)) THEN
      theta := 0.0;
      RETURN (theta);
    END_IF;
    theta := ACOS ((v1.direction_ratios[1]*v2.direction_ratios[1] +
                    v1.direction_ratios[2]*v2.direction_ratios[2]) /
                   (mag_v1*mag_v2));
    RETURN (theta);</algorithm>
      </function>
      <function name="derive_definite_integral_domain">
         <parameter name="igrl">
            <typename name="definite_integral_function"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>FUNCTION process_product_space(spc         : product_space;
                                 idx, prefix : INTEGER;
                                 vdomn       : maths_space) : product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;
    IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF (spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx &lt;= uspc.exponent THEN  expnt := expnt - 1;  END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base,expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx &lt;= SIZEOF (factors) THEN  REMOVE (factors, idx);  END_IF;
      IF prefix &gt; 0 THEN
        INSERT (factors, vdomn, 0);
        IF prefix &gt; 1 THEN  INSERT (factors, vdomn, 0);  END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
  END_FUNCTION;  -- process_product_space

  -- Resume body of derive_definite_integral_domain function
  LOCAL
    idomn : tuple_space := igrl.integrand.domain;
    types : SET OF STRING := TYPEOF (idomn);
    idx : INTEGER := igrl.variable_of_integration;
    tupled : BOOLEAN := bool(((space_dimension(idomn) = 1) AND
                             ((schema_prefix + 'TUPLE_SPACE') IN types)));
    prefix : INTEGER := 0;
    espc : extended_tuple_space;
    vdomn : maths_space;
  END_LOCAL;
  IF tupled THEN
    idomn := factor1(idomn);
    types := TYPEOF (idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;  END_IF;
  IF igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;  END_IF;
  vdomn := factor_space(idomn,idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base,idx,
      prefix,vdomn),espc.extender);
  ELSE
    idomn := process_product_space(idomn,idx,prefix,vdomn);
  END_IF;
  IF tupled THEN  RETURN (one_tuples_of(idomn));
  ELSE            RETURN (idomn);                 END_IF;</algorithm>
      </function>
      <function name="derive_dimensional_exponents">
         <parameter name="x">
            <typename name="unit"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>LOCAL
      result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    END_LOCAL;

    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
        result.length_exponent := result.length_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
        result.electric_current_exponent := result.electric_current_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.amount_of_substance_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.luminous_intensity_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x\named_unit.dimensions;
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="derive_elementary_function_domain">
         <parameter name="ef_val">
            <typename name="elementary_function_enumerators"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_or : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (the_integer_tuples);
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_multiply_i : RETURN (the_integer_tuples);
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_eq_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ne_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_gt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_lt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ge_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_le_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_listed_product_space ([the_logicals, the_integers,
    the_integers]));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (the_real_tuples);
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_multiply_r : RETURN (the_real_tuples);
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_exponentiate_r : RETURN (make_listed_product_space ([the_nonnegative_reals,
    the_reals]));
  ef_exponentiate_ri : RETURN (make_listed_product_space ([the_reals, the_integers]));
  ef_eq_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ne_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_gt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_lt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ge_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_le_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_abs_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_cos_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_listed_product_space ([the_logicals, the_reals, the_reals]));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (the_complex_tuples);
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_multiply_c : RETURN (the_complex_tuples);
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_ci : RETURN (make_listed_product_space ([the_complex_numbers,
    the_integers]));
  ef_eq_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_ne_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_listed_product_space ([the_logicals, the_complex_numbers,
    the_complex_numbers]));
  ef_subscript_s : RETURN (make_listed_product_space ([the_strings, the_integers]));
  ef_eq_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ne_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_gt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_lt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ge_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_le_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_subsequence_s : RETURN (make_listed_product_space ([the_strings, the_integers,
    the_integers]));
  ef_concat_s : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_strings));
  ef_size_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_format : RETURN (make_listed_product_space ([the_numbers, the_strings]));
  ef_value : RETURN (make_uniform_product_space (the_strings, 1));
  ef_like : RETURN (make_uniform_product_space (the_strings, 2));
  ef_if_s : RETURN (make_listed_product_space ([the_logicals, the_strings,
    the_strings]));
  ef_subscript_b : RETURN (make_listed_product_space ([the_binarys, the_integers]));
  ef_eq_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ne_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_gt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_lt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ge_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_le_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_subsequence_b : RETURN (make_listed_product_space ([the_binarys, the_integers,
    the_integers]));
  ef_concat_b : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_binarys));
  ef_size_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_if_b : RETURN (make_listed_product_space ([the_logicals, the_binarys,
    the_binarys]));
  ef_subscript_t : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_eq_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_ne_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_concat_t : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_tuples));
  ef_size_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_entuple : RETURN (the_tuples);
  ef_detuple : RETURN (make_uniform_product_space (the_generics, 1));
  ef_insert : RETURN (make_listed_product_space ([the_tuples, the_generics,
    the_integers]));
  ef_remove : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_if_t : RETURN (make_listed_product_space ([the_logicals, the_tuples,
    the_tuples]));
  ef_sum_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_add_it : RETURN (make_extended_tuple_space (the_integer_tuples,
    the_integer_tuples));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_scalar_mult_it : RETURN (make_listed_product_space ([the_integers,
    the_integer_tuples]));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_sum_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_add_rt : RETURN (make_extended_tuple_space (the_real_tuples, the_real_tuples));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_scalar_mult_rt : RETURN (make_listed_product_space ([the_reals,
    the_real_tuples]));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_norm_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_add_ct : RETURN (make_extended_tuple_space (the_complex_tuples,
    the_complex_tuples));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_scalar_mult_ct : RETURN (make_listed_product_space ([the_complex_numbers,
    the_complex_tuples]));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_norm_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_if : RETURN (make_listed_product_space ([the_logicals, the_generics,
    the_generics]));
  ef_ensemble : RETURN (the_tuples);
  ef_member_of : RETURN (make_listed_product_space ([the_generics, the_maths_spaces]));
  OTHERWISE : RETURN (?);
  END_CASE;</algorithm>
      </function>
      <function name="derive_elementary_function_range">
         <parameter name="ef_val">
            <typename name="elementary_function_enumerators"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_or : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_multiply_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_eq_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_multiply_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_ri : RETURN (make_uniform_product_space (the_reals, 1));
  ef_eq_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_zero_pi_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neghalfpi_halfpi_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_multiply_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_ci : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_eq_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subscript_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_eq_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_concat_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_size_s : RETURN (make_uniform_product_space (the_integers, 1));
  ef_format : RETURN (make_uniform_product_space (the_strings, 1));
  ef_value : RETURN (make_uniform_product_space (the_reals, 1));
  ef_like : RETURN (make_uniform_product_space (the_booleans, 1));
  ef_if_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_subscript_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_eq_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_concat_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_size_b : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_subscript_t : RETURN (make_uniform_product_space (the_generics, 1));
  ef_eq_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_concat_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_size_t : RETURN (make_uniform_product_space (the_integers, 1));
  ef_entuple : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_detuple : RETURN (the_tuples);
  ef_insert : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_remove : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_if_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_sum_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_scalar_mult_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_sum_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_scalar_mult_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_norm_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_scalar_mult_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_norm_ct : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_if : RETURN (make_uniform_product_space (the_generics, 1));
  ef_ensemble : RETURN (make_uniform_product_space (the_maths_spaces, 1));
  ef_member_of : RETURN (make_uniform_product_space (the_logicals, 1));
  OTHERWISE : RETURN (?);
  END_CASE;</algorithm>
      </function>
      <function name="derive_finite_function_domain">
         <parameter name="pairs">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="maths_value"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][1];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 1);
  RETURN (one_tuples_of (make_finite_space (result)));</algorithm>
      </function>
      <function name="derive_finite_function_range">
         <parameter name="pairs">
            <aggregate lower="1" type="SET" upper="?"/>
            <aggregate lower="2" type="LIST" upper="2"/>
            <typename name="maths_value"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][2];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 2);
  RETURN (one_tuples_of (make_finite_space (result)));</algorithm>
      </function>
      <function name="derive_function_domain">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    shape : LIST OF positive_integer;
    sidxs  : LIST OF INTEGER := [0];
    itvl   : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_domain (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_domain (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1 (func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of (func\repackaging_function.operand.domain));
    END_IF;
    -- Unreachable, as there is no other possible value for input_repack.
    RETURN (?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[i], sidxs[i]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] &lt;&gt; shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[1], sidxs[1]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] &lt;&gt; shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_finite_real_interval
      (func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
      func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis+1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\b_spline_function.basis);
      tspace := assoc_product_space (tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of (tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\abstracted_expression_function.variables);
      tspace := assoc_product_space (tspace, one_tuples_of (values_space_of
        (func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_listed_product_space ([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);</algorithm>
      </function>
      <function name="derive_function_range">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    m, n : nonnegative_integer := 0;
    temp : INTEGER := 0;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_range (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_finite_space ([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
      TYPEOF (tspace)) THEN
      tspace := factor1 (tspace);
    END_IF;
    RETURN (one_tuples_of (factor_space (tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_range (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of (tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1 (tspace);
    END_IF;
    IF func\repackaging_function.selected_output &gt; 0 THEN
      tspace := one_tuples_of (factor_space (tspace,
        func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF
      (func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    IF 'LISTED_REAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    -- Unreachable, as no other subtypes of explicit_table_function are permissible
    -- without first modifying this function to account for them.
    RETURN (?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\b_spline_function.coef.domain);
    m := SIZEOF (func\b_spline_function.basis);
    n := space_dimension (tspace);
    IF m = n THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of (make_uniform_product_space (the_reals,
        factor_space (tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors (tspace, m+1, n);
    RETURN (one_tuples_of (make_function_space (sc_equal, tspace, sc_subspace,
      number_superspace_of (func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\rationalize_function.fun.range);
    n := space_dimension (tspace);
    RETURN (one_tuples_of (make_uniform_product_space (number_superspace_of (
      factor1 (tspace)), n-1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_point_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_curve_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_surface_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_volume_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);</algorithm>
      </function>
      <function name="dimension_of">
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <typename name="dimension_count"/>
         <algorithm>LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);</algorithm>
      </function>
      <function name="dimensions_for_si_unit">
         <parameter name="n">
            <typename name="si_unit_name"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>CASE n OF 
      metre:
        RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      gram:
        RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      second:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
      ampere:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
      kelvin:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      mole:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
      candela:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      radian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      steradian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      hertz:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      newton:
        RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      pascal:
        RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      joule:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      watt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
      coulomb:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
      volt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
      farad:
        RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
      ohm:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
      siemens:
        RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
      weber:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      tesla:
        RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      henry:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
      degree_Celsius:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      lumen:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      lux:
        RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      becquerel:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      gray:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      sievert:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      OTHERWISE:
        RETURN (?);
    END_CASE;</algorithm>
      </function>
      <function name="domain_from">
         <parameter name="ref">
            <typename name="maths_space_or_function"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func      : maths_function;
  END_LOCAL;
  IF NOT EXISTS (ref) THEN  RETURN (?);  END_IF;
  IF 'TUPLE_SPACE' IN typenames THEN  RETURN (ref);                  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN  RETURN (one_tuples_of (ref));  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);</algorithm>
      </function>
      <function name="dot_count">
         <parameter name="str">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
    n : INTEGER := 0;
  END_LOCAL;
  REPEAT i := 1 TO LENGTH (str);
    IF str[i] = '.' THEN  n := n + 1;  END_IF;
  END_REPEAT;
  RETURN (n);</algorithm>
      </function>
      <function name="dot_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim &lt;&gt; arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);</algorithm>
      </function>
      <function name="dotted_identifiers_syntax">
         <parameter name="str">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    k : positive_integer;
    m : positive_integer;
  END_LOCAL;
  IF NOT EXISTS (str) THEN  RETURN (FALSE);  END_IF;
  k := parse_express_identifier (str, 1);
  IF k = 1 THEN  RETURN (FALSE);  END_IF;
  REPEAT WHILE k &lt;= LENGTH (str);
    IF (str[k] &lt;&gt; '.') OR (k = LENGTH (str)) THEN  RETURN (FALSE);  END_IF;
    m := parse_express_identifier (str, k+1);
    IF m = k + 1 THEN  RETURN (FALSE);  END_IF;
    k := m;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="drop_numeric_constraints">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <typename name="maths_space"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
    RETURN (make_uniform_product_space (drop_numeric_constraints (
      spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF (tspc.factors);
      INSERT (factors, drop_numeric_constraints (tspc.factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space (drop_numeric_constraints (xspc.base),
      drop_numeric_constraints (xspc.extender)));
  END_IF;
  IF subspace_of_es (spc, es_numbers) THEN
    RETURN (number_superspace_of (spc));
  END_IF;
  RETURN (spc);</algorithm>
      </function>
      <function name="edge_reversed">
         <parameter name="an_edge">
            <typename name="edge"/>
         </parameter>
         <typename name="oriented_edge"/>
         <algorithm>LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="enclose_cregion_in_pregion">
         <parameter name="crgn">
            <typename name="cartesian_complex_number_region"/>
         </parameter>
         <parameter name="centre">
            <typename name="complex_number_literal"/>
         </parameter>
         <typename name="polar_complex_number_region"/>
         <algorithm>FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a &gt; PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a &lt;= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Determine whether a real is strictly within a real interval
  FUNCTION strictly_in(z    : REAL;
                       zitv : real_interval) : LOGICAL;
    RETURN ((NOT min_exists(zitv) OR (z &gt; real_min(zitv))) AND
      (NOT max_exists(zitv) OR (z &lt; real_max(zitv))));
  END_FUNCTION;
  -- Include direction in minmax collection
  PROCEDURE angle_minmax(    ab, a            : REAL;
                             a_in             : BOOLEAN;
                         VAR amin, amax       : REAL;
                         VAR amin_in, amax_in : BOOLEAN);
    a := angle(a - ab);
    IF amin = a THEN  amin_in := amin_in OR a_in;  END_IF;
    IF amin &gt; a THEN  amin := a;  amin_in := a_in;  END_IF;
    IF amax = a THEN  amax_in := amax_in OR a_in;  END_IF;
    IF amax &lt; a THEN  amax := a;  amax_in := a_in;  END_IF;
  END_PROCEDURE;
  -- Include distance in max collection
  PROCEDURE range_max(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmax    : REAL;
                      VAR rmax_in : BOOLEAN);
    IF rmax = r THEN  rmax_in := rmax_in OR incl;   END_IF;
    IF rmax &lt; r THEN  rmax := r;  rmax_in := incl;  END_IF;
  END_PROCEDURE;
  -- Include distance in min collection
  PROCEDURE range_min(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmin    : REAL;
                      VAR rmin_in : BOOLEAN);
    IF rmin = r THEN  rmin_in := rmin_in OR incl;  END_IF;
    IF (rmin &lt; 0.0) OR (rmin &gt; r) THEN  rmin := r;  rmin_in := incl;  END_IF;
  END_PROCEDURE;
  LOCAL
    xitv, yitv : real_interval;
    is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN;
    xmin, xmax, ymin, ymax, xc, yc : REAL := 0.0;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    rmin, rmax : REAL := -1.0;
    amin : REAL := 4.0;
    amax : REAL := -4.0;
    rmax_exists, outside : BOOLEAN := TRUE;
    rmin_in, rmax_in, amin_in, amax_in : BOOLEAN := FALSE;
    ab, a, r : REAL := 0.0;
    incl : BOOLEAN;
    ritv : real_interval;
    aitv : finite_real_interval;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin THEN  xmin := real_min(xitv);  xmin_in := min_included(xitv);  END_IF;
  IF is_xmax THEN  xmax := real_max(xitv);  xmax_in := max_included(xitv);  END_IF;
  IF is_ymin THEN  ymin := real_min(yitv);  ymin_in := min_included(yitv);  END_IF;
  IF is_ymax THEN  ymax := real_max(yitv);  ymax_in := max_included(yitv);  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF       is_xmin AND (xc &lt;= xmin)  THEN  ab := 0.0;
  ELSE IF  is_ymin AND (yc &lt;= ymin)  THEN  ab := 0.5*PI;
  ELSE IF  is_ymax AND (yc &gt;= ymax)  THEN  ab := -0.5*PI;
  ELSE IF  is_xmax AND (xc &gt;= xmax)  THEN  ab := PI;
  ELSE                                     outside := FALSE;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF NOT outside AND NOT rmax_exists THEN
    RETURN (?);  -- No enclosing polar region exists (requires whole plane)
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF       is_xmin AND (xc &lt;= xmin) AND strictly_in(yc,yitv) THEN
    rmin := xmin - xc;  rmin_in := xmin_in;
  ELSE IF  is_ymin AND (yc &lt;= ymin) AND strictly_in(xc,xitv) THEN
    rmin := ymin - yc;  rmin_in := ymin_in;
  ELSE IF  is_ymax AND (yc &gt;= ymax) AND strictly_in(xc,xitv) THEN
    rmin := yc - ymax;  rmin_in := ymax_in;
  ELSE IF  is_xmax AND (xc &gt;= xmax) AND strictly_in(yc,yitv) THEN
    rmin := xc - xmax;  rmin_in := xmax_in;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF is_xmin THEN
    IF is_ymin THEN  -- Consider lower left corner
      r := SQRT((xmin-xc)**2 + (ymin-yc)**2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r &gt; 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0-ab);      amin_in := ymin_in;
          amax := angle(0.5*PI-ab);   amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF xc &lt;= xmin THEN  -- Consider points near (xmin, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymax AND (xc &lt;= xmin) THEN  -- Consider points near (xmin, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymin THEN
    IF is_xmax THEN  -- Consider lower right corner
      r := SQRT((xmax-xc)**2 + (ymin-yc)**2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r &gt; 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5*PI-ab);   amin_in := ymin_in;
          amax := angle(PI-ab);       amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF yc &lt;= ymin THEN  -- Consider points near (+infinity, ymin)
      angle_minmax(ab,0.0,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmin AND (yc &lt;= ymin) THEN  -- Consider points near (-infinity, ymin)
      angle_minmax(ab,PI,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_xmax THEN
    IF is_ymax THEN  -- Consider upper right corner
      r := SQRT((xmax-xc)**2 + (ymax-yc)**2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r &gt; 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI-ab);      amin_in := ymax_in;
          amax := angle(-0.5*PI-ab);  amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF xc &gt;= xmax THEN  -- Consider points near (xmax, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymin AND (xc &gt;= xmax) THEN  -- Consider points near (xmax, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymax THEN
    IF is_xmin THEN  -- Consider upper left corner
      r := SQRT((xmin-xc)**2 + (ymax-yc)**2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r &gt; 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5*PI-ab);   amin_in := ymax_in;
          amax := angle(PI-ab);       amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF yc &gt;= ymax THEN  -- Consider points near (-infinity, ymax)
      angle_minmax(ab,PI,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmax AND (yc &gt;= ymax) THEN  -- Consider points near (+infinity, ymax)
      angle_minmax(ab,0.0,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF outside THEN  -- Change direction origin from ab back to zero
    amin := angle(amin+ab);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax+ab);
    IF amax &lt;= amin THEN  amax := amax + 2.0*PI;  END_IF;
  ELSE
    amin := -PI;  amin_in := FALSE;
    amax := PI;   amax_in := FALSE;
  END_IF;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  minclo := open;
  IF rmin_in THEN  minclo := closed;  END_IF;
  IF rmax_exists THEN
    maxclo := open;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));</algorithm>
      </function>
      <function name="enclose_pregion_in_cregion">
         <parameter name="prgn">
            <typename name="polar_complex_number_region"/>
         </parameter>
         <typename name="cartesian_complex_number_region"/>
         <algorithm>PROCEDURE nearest_good_direction(acart    : REAL;
                                   aitv     : finite_real_interval;
                                   VAR a    : REAL;
                                   VAR a_in : BOOLEAN);
    a := acart;                    a_in := TRUE;
    IF      a &lt; aitv.min THEN
      -- a+2.0*PI &gt; aitv.min automatically!
      IF a+2.0*PI &lt; aitv.max THEN                               RETURN;  END_IF;
      IF a+2.0*PI = aitv.max THEN  a_in := max_included(aitv);  RETURN;  END_IF;
    ELSE IF a = aitv.min THEN      a_in := min_included(aitv);  RETURN;
    ELSE IF a &lt; aitv.max THEN                                   RETURN;
    ELSE IF a = aitv.max THEN      a_in := max_included(aitv);  RETURN;
    END_IF;  END_IF;  END_IF;  END_IF;
    IF COS(acart - aitv.max) &gt;= COS(acart - aitv.min) THEN
      a := aitv.max;               a_in := max_included(aitv);
    ELSE
      a := aitv.min;               a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;
  LOCAL
    xc, yc, xmin, xmax, ymin, ymax : REAL := 0.0;
    ritv, xitv, yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    a, r : REAL := 0.0;
    a_in : BOOLEAN := FALSE;
    min_clo, max_clo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (prgn) THEN  RETURN (?);  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI,aitv,a,a_in);
  IF COS(a) &gt;= 0.0 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv)*COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv)*COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0,aitv,a,a_in);
  IF COS(a) &lt;= 0.0 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv)*COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv)*COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5*PI,aitv,a,a_in);
  IF SIN(a) &gt;= 0.0 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv)*SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv)*SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5*PI,aitv,a,a_in);
  IF SIN(a) &lt;= 0.0 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv)*SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv)*SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);  -- No finite boundaries exist
  END_IF;
  -- Construct real_constraint
  IF xmin_exists THEN
    IF xmin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_finite_real_interval(xmin,min_clo,xmax,max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin,min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_real_interval_to_max(xmax,max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists THEN
    IF ymin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_finite_real_interval(ymin,min_clo,ymax,max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin,min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_real_interval_to_max(ymax,max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN (make_cartesian_complex_number_region(xitv,yitv));</algorithm>
      </function>
      <function name="enclose_pregion_in_pregion">
         <parameter name="prgn">
            <typename name="polar_complex_number_region"/>
         </parameter>
         <parameter name="centre">
            <typename name="complex_number_literal"/>
         </parameter>
         <typename name="polar_complex_number_region"/>
         <algorithm>FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a &gt; PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a &lt;= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Find proper limits for direction interval
  PROCEDURE angle_range(VAR amin, amax : REAL);
    amin := angle(amin);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax);
    IF amax &lt;= amin THEN  amax := amax + 2.0*PI;  END_IF;
  END_PROCEDURE;
  -- Determine whether a direction is strictly within a direction interval
  FUNCTION strictly_in(a    : REAL;
                       aitv : finite_real_interval) : LOGICAL;
    a := angle(a);
    RETURN ({aitv.min &lt; a &lt; aitv.max} OR {aitv.min &lt; a+2.0*PI &lt; aitv.max});
  END_FUNCTION;
  -- Find min and max and related inclusion booleans among four candidates,
  -- using a base direction chosen to ensure the algebraic comparisons are valid.
  PROCEDURE find_aminmax(    ab,a0,a1,a2,a3  : REAL;
                             in0,in1,in2,in3 : BOOLEAN;
                         VAR amin,amax       : REAL;
                         VAR amin_in,amax_in : BOOLEAN);
    LOCAL
      a : REAL;
    END_LOCAL;
    amin := angle(a0-ab);                  amin_in := in0;
    amax := amin;                          amax_in := in0;
    a := angle(a1-ab);
    IF a = amin THEN                       amin_in := amin_in OR in1;  END_IF;
    IF a &lt; amin THEN  amin := a;           amin_in := in1;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in1;  END_IF;
    IF a &gt; amax THEN  amax := a;           amax_in := in1;             END_IF;
    a := angle(a2-ab);
    IF a = amin THEN                       amin_in := amin_in OR in2;  END_IF;
    IF a &lt; amin THEN  amin := a;           amin_in := in2;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in2;  END_IF;
    IF a &gt; amax THEN  amax := a;           amax_in := in2;             END_IF;
    a := angle(a3-ab);
    IF a = amin THEN                       amin_in := amin_in OR in3;  END_IF;
    IF a &lt; amin THEN  amin := a;           amin_in := in3;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in3;  END_IF;
    IF a &gt; amax THEN  amax := a;           amax_in := in3;             END_IF;
    amin := amin+ab;
    amax := amax+ab;
    angle_range(amin,amax);
  END_PROCEDURE;

  LOCAL
    ritp, ritv : real_interval;
    aitp, aitv : finite_real_interval;
    xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL := 0.0;
    rmax_in, rmin_in, amin_in, amax_in : BOOLEAN := FALSE;
    rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
    in0, in1, in2, in3, inn : BOOLEAN := FALSE;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS (prgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp) THEN  RETURN (prgn);  END_IF;
  rc := SQRT((xp-xc)**2 + (yp-yc)**2);
  acp := atan2(yp-yc,xp-xc);
  apc := atan2(yc-yp,xc-xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp) THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- annulus or disk, with or without slot or puncture
      inn := NOT max_included(aitp);  -- slot exists;
      a := angle(aitp.min);  -- slot direction
      rmax := rc+rmxp;                    rmax_in := max_included(ritp);
      IF inn AND (acp = a) THEN  rmax_in := FALSE;  END_IF;
      IF rc &gt; rmxp THEN
        a0 := ASIN(rmxp/rc);
        amin := angle(acp-a0);            amin_in := max_included(ritp);
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+a0);            amax_in := amin_in;
        IF amax &lt; amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := rc-rmxp;                  rmin_in := amin_in;
        IF inn THEN
          -- slotted case
          IF apc = a THEN  rmin_in := FALSE;  END_IF;
          IF angle(amin+0.5*PI) = a THEN  amin_in := FALSE;  END_IF;
          IF angle(amax-0.5*PI) = a THEN  amax_in := FALSE;  END_IF;
        END_IF;
      ELSE IF rc = rmxp THEN
        amin := angle(acp-0.5*PI);        amin_in := FALSE;
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+0.5*PI);        amax_in := FALSE;
        IF amax &lt; amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := 0.0;                      rmin_in := max_included(ritp);
        IF inn AND (apc = a) THEN  rmin_in := FALSE;  END_IF;
      ELSE IF rc &gt; rmnp THEN
        IF inn AND (apc = a) THEN  -- in the slot
          rmin := 0.0;                    rmin_in := FALSE;
          amin := aitp.min;               amin_in := FALSE;
          amax := aitp.max;               amax_in := FALSE;
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        END_IF;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF inn THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;  END_IF;  END_IF;
    ELSE  -- direction range &lt; 2*PI
      -- Compute data for corners with respect to xc,yc
      x := xp + rmxp*cos(aitp.min) - xc;
      y := yp + rmxp*sin(aitp.min) - yc;
      r0 := SQRT(x**2 + y**2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 &lt;&gt; 0.0 THEN  a0 := atan2(y,x);  END_IF;
      x := xp + rmxp*cos(aitp.max) - xc;
      y := yp + rmxp*sin(aitp.max) - yc;
      r1 := SQRT(x**2 + y**2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 &lt;&gt; 0.0 THEN  a1 := atan2(y,x);  END_IF;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 &lt;&gt; 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      IF r1 = 0.0 THEN  a1 := a2;  in1 := in2;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 &lt;&gt; 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF r0 = 0.0 THEN  a0 := a3;  in0 := in3;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmax
      IF strictly_in(acp,aitp) THEN
        rmax := rc+rmxp;                  rmax_in := max_included(ritp);
      ELSE
        rmax := r0;                       rmax_in := in0;
        IF rmax = r1 THEN                 rmax_in := rmax_in OR in1;  END_IF;
        IF rmax &lt; r1 THEN  rmax := r1;    rmax_in := in1;             END_IF;
        IF rmax = r2 THEN                 rmax_in := rmax_in OR in2;  END_IF;
        IF rmax &lt; r2 THEN  rmax := r2;    rmax_in := in2;             END_IF;
        IF rmax = r3 THEN                 rmax_in := rmax_in OR in3;  END_IF;
        IF rmax &lt; r3 THEN  rmax := r3;    rmax_in := in3;             END_IF;
      END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        IF rc &gt;= rmxp THEN
          rmin := rc-rmxp;                rmin_in := max_included(ritp);
        ELSE IF rc &lt;= rmnp THEN
          rmin := rmnp-rc;                rmin_in := min_included(ritp);
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
        END_IF;  END_IF;
      ELSE
        rmin := r0;                       rmin_in := in0;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF {rmnp &lt; r &lt; rmxp} THEN  -- use nearest point on line segment
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF {rmnp &lt; r &lt; rmxp} THEN  -- try nearest point on line segment
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r &lt; rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r1 = rmin THEN                 rmin_in := rmin_in OR in1;  END_IF;
        IF r1 &lt; rmin THEN  rmin := r1;    rmin_in := in1;             END_IF;
        IF r2 = rmin THEN                 rmin_in := rmin_in OR in2;  END_IF;
        IF r2 &lt; rmin THEN  rmin := r2;    rmin_in := in2;             END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 &lt; rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax, initially with respect to base direction ab.
      IF rc &gt;= rmxp THEN  -- outside outer circle
        ab := acp;
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
        a := ACOS(rmxp/rc);
        IF strictly_in(apc-a,aitp) THEN
          amin := ab-ASIN(rmxp/rc);       amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc+a,aitp) THEN
          amax := ab+ASIN(rmxp/rc);       amax_in := max_included(ritp);
        END_IF;
        angle_range(amin,amax);
      ELSE IF rc &gt; rmnp THEN
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 &lt; a2 and a0 &lt; a1 algebraically.
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 &gt; a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 &gt; a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 &lt; a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 &gt; a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin &gt; 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;  END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE  -- Not max_exists(ritp)
    IF (rc &gt; rmnp) AND strictly_in(apc,aitp) THEN
      RETURN (?);  -- No pregion exists.  (Would require whole plane.)
    END_IF;
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- complement of disk, with or without slot
      a := angle(aitp.min);  -- slot direction
      IF rc &gt; rmnp THEN  -- already excluded if not aligned with slot
        IF max_included(aitp) THEN
          RETURN (?);  -- No pregion exists.  (Would require whole plane.)
        END_IF;
        rmin := 0.0;                      rmin_in := FALSE;
        amin := aitp.min;                 amin_in := FALSE;
        amax := aitp.max;                 amax_in := FALSE;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF NOT max_included(aitp) THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;
    ELSE  -- direction range &lt; 2*PI
      -- Compute data for corners with respect to xc,yc (two at infinity)
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 &lt;&gt; 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 &lt;&gt; 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
      ELSE
        rmin := r2;                       rmin_in := in2;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF rmnp &lt; r THEN  -- use nearest point on aitp.min ray
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF rmnp &lt; r THEN  -- try nearest point on aitp.max ray
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r &lt; rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 &lt; rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax
      ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
      IF rc &gt; rmnp THEN
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 &lt; a2 and a0 &lt; a1 algebraically.
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 &gt; a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 &gt; a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 &lt; a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 &gt; a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin &gt; 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in THEN
            RETURN (?);  -- No pregion exists.  (Would require whole plane.)
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  minclo := open;  maxclo := open;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  -- Construct polar region
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));</algorithm>
      </function>
      <function name="equal_cregion_pregion">
         <parameter name="crgn">
            <typename name="cartesian_complex_number_region"/>
         </parameter>
         <parameter name="prgn">
            <typename name="polar_complex_number_region"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    arng, amin, xc, yc : REAL;
    aitv, xitv, yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (prgn) THEN  RETURN (FALSE);  END_IF;
  IF max_exists(prgn.distance_constraint) THEN  RETURN (FALSE);  END_IF;
  IF real_min(prgn.distance_constraint) &lt;&gt; 0.0 THEN  RETURN (FALSE);  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5*PI THEN
    IF amin = 0.0 THEN  -- quadrant to upper right
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- quadrant to upper left
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI THEN  -- quadrant to lower left
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- quadrant to lower right
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.0 THEN  -- upper half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- left half space
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI THEN  -- lower half space
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- right half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="equal_maths_functions">
         <parameter name="fun1">
            <typename name="maths_function"/>
         </parameter>
         <parameter name="fun2">
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    cum : LOGICAL;
  END_LOCAL;
  IF fun1 = fun2 THEN  RETURN (TRUE);   END_IF;
  cum := equal_maths_spaces(fun1.domain,fun2.domain);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range,fun2.range);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN (UNKNOWN);</algorithm>
      </function>
      <function name="equal_maths_spaces">
         <parameter name="spc1">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="spc2">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1, set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1, fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;
  IF spc1 = spc2 THEN  RETURN (TRUE);  END_IF;
  -- Consider cases where it is not yet certain that spc1 &lt;&gt; spc2.
  IF 'FINITE_SPACE' IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types THEN
      -- Members may have different but equivalent representations and in
      -- different orders.  May also have disguised repeats in same set of members.
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF (set1);
        cum := cum AND member_of (set1[i], spc2);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF (set2);
          cum := cum AND member_of (set2[i], spc1);
          IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1,make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1),spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc1,spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc2,spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF expnt &lt;&gt; spc2\uniform_product_space.exponent THEN  RETURN (FALSE);  END_IF;
      RETURN (equal_maths_spaces(base,spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt &lt;&gt; SIZEOF (factors) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF spc2\uniform_product_space.exponent &lt;&gt; SIZEOF (factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF (factors) &lt;&gt; SIZEOF (factors2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(factors[i],factors2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND
    ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,
      spc2\extended_tuple_space.extender) AND equal_maths_spaces(
      spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND
    ('FUNCTION_SPACE' IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint &lt;&gt; fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.domain_constraint &lt;&gt; sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint &lt;&gt; sc_subspace) OR
        (fs2.domain_constraint &lt;&gt; sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint,fs1.domain_argument) &lt;&gt;
        any_space_satisfies(fs2.domain_constraint,fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument,fs2.domain_argument);
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
    IF fs1.range_constraint &lt;&gt; fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.range_constraint &lt;&gt; sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint &lt;&gt; sc_subspace) OR
        (fs2.range_constraint &lt;&gt; sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint,fs1.range_argument) &lt;&gt;
        any_space_satisfies(fs2.range_constraint,fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument,fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="equal_maths_values">
         <parameter name="val1">
            <typename name="maths_value"/>
         </parameter>
         <parameter name="val2">
            <typename name="maths_value"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>FUNCTION mem_of_vs(val1, val2 : maths_value) : LOGICAL;
    IF NOT has_values_space(val2) THEN RETURN (UNKNOWN);  END_IF;
    IF NOT member_of(val1,values_space_of(val2)) THEN  RETURN (FALSE);  END_IF;
    RETURN (UNKNOWN);
  END_FUNCTION;  -- mem_of_vs
  LOCAL
    types1, types2 : SET OF STRING;
    list1, list2 : LIST OF maths_value;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF NOT EXISTS (val1) OR NOT EXISTS (val2) THEN  RETURN (FALSE);  END_IF;
  IF val1 = val2 THEN  RETURN (TRUE);  END_IF;
  types1 := stripped_typeof (val1);
  types2 := stripped_typeof (val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1) THEN
    IF 'MATHS_ATOM'             IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'LIST'                   IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2) THEN
    RETURN (equal_maths_values(val2,val1));
  END_IF;
  IF 'LIST' IN types1 THEN
    IF 'LIST' IN types2 THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF (list1) &lt;&gt; SIZEOF (list2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (list1);
        cum := cum AND equal_maths_values (list1[i], list2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'LIST' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_SPACE' IN types1 THEN
    IF 'MATHS_SPACE' IN types2 THEN
      RETURN (equal_maths_spaces(val1,val2));
    END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_FUNCTION' IN types1 THEN
    IF 'MATHS_FUNCTION' IN types2 THEN
      RETURN (equal_maths_functions(val1,val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2) THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1),values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (UNKNOWN);</algorithm>
      </function>
      <function name="es_subspace_of_es">
         <parameter name="es1">
            <typename name="elementary_space_enumerators"/>
         </parameter>
         <parameter name="es2">
            <typename name="elementary_space_enumerators"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT EXISTS (es1) OR NOT EXISTS (es2) THEN  RETURN (FALSE);  END_IF;
  IF es1 = es2 THEN  RETURN (TRUE);  END_IF;
  IF es2 = es_generics THEN  RETURN (TRUE);  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN  RETURN (TRUE);  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR
    (es1 = es_integers)) THEN  RETURN (TRUE);  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="expression_is_constant">
         <parameter name="expr">
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));</algorithm>
      </function>
      <function name="external_version_assignment_is_valid">
         <parameter name="aia">
            <typename name="applied_external_identification_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      item: identification_item;
      role: identification_role;
    END_LOCAL;
      role:= aia.role;
      IF role.name='version' THEN
        REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
          item:= aia.items[i];
          IF (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'EXTERNALLY_VERSIONED_ITEM']*TYPEOF(item))=0) THEN
            -- item invalid if item does not belong to versionable types
	        RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(TRUE);
      ELSE		-- case where aia does not convey a version id
        RETURN(TRUE);
      END_IF;</algorithm>
      </function>
      <function name="extract_factors">
         <parameter name="tspace">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="m">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="n">
            <builtintype type="INTEGER"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space (tsp, factor_space (tspace, i));
  END_REPEAT;
  RETURN (tsp);</algorithm>
      </function>
      <function name="extremal_position_check">
         <parameter name="fun">
            <typename name="linearized_table_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    source_domain : maths_space;
    source_interval : finite_integer_interval;
    index : INTEGER := 1;
    base : INTEGER;
    shape : LIST OF positive_integer;
    ndim : positive_integer;
    slo, shi : INTEGER;
    sublo : LIST OF INTEGER := [];
    subhi : LIST OF INTEGER := [];
  END_LOCAL;
  IF NOT EXISTS (fun) THEN  RETURN (FALSE);  END_IF;
  source_domain := factor1 (fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (source_domain) THEN
    source_domain := factor1 (source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (source_domain)) THEN
    RETURN (FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    REPEAT j := 1 TO SIZEOF (shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN (bool({source_interval.min &lt;= index &lt;= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    ndim := SIZEOF (fun\explicit_table_function.shape);
    REPEAT j:= 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] &gt;= 0 THEN
        INSERT (sublo, slo, j-1);
        INSERT (subhi, shi, j-1);
      ELSE
        INSERT (sublo, shi, j-1);
        INSERT (subhi, slo, j-1);
      END_IF;
    END_REPEAT;
    index := regular_indexing (sublo, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min &lt;= index &lt;= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    index := regular_indexing (subhi, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min &lt;= index &lt;= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="face_bound_reversed">
         <parameter name="a_face_bound">
            <typename name="face_bound"/>
         </parameter>
         <typename name="face_bound"/>
         <algorithm>LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);</algorithm>
      </function>
      <function name="face_reversed">
         <parameter name="a_face">
            <typename name="face"/>
         </parameter>
         <typename name="oriented_face"/>
         <algorithm>LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);</algorithm>
      </function>
      <function name="factor1">
         <parameter name="tspace">
            <typename name="tuple_space"/>
         </parameter>
         <typename name="maths_space"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
    -- This path could return the indeterminate value if the list is empty.
    -- This is the correct result for this case.
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    RETURN (factor1 (tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN (?);</algorithm>
      </function>
      <function name="factor_space">
         <parameter name="tspace">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="idx">
            <typename name="positive_integer"/>
         </parameter>
         <typename name="maths_space"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    IF idx &lt;= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    IF idx &lt;= SIZEOF (tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    IF idx &lt;= space_dimension (tspace\extended_tuple_space.base) THEN
      RETURN (factor_space (tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN (?);</algorithm>
      </function>
      <function name="first_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios &lt;&gt; [1.0,0.0,0.0]) AND
          (z.direction_ratios &lt;&gt; [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim &lt;&gt; 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);</algorithm>
      </function>
      <function name="free_variables_of">
         <parameter name="expr">
            <typename name="generic_expression"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="generic_variable"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge &lt;* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);</algorithm>
      </function>
      <function name="function_applicability">
         <parameter name="func">
            <typename name="maths_function_select"/>
         </parameter>
         <parameter name="arguments">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF (domain);
    narg : positive_integer := SIZEOF (arguments);
    arg : generic_expression;
  END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types THEN
    IF space_dimension (domain) &lt;&gt; narg THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types THEN
      IF space_dimension (domain) &gt; narg THEN  RETURN (FALSE);  END_IF;
    ELSE
      RETURN (FALSE);  -- Should be unreachable
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand (arguments[i]);
    IF NOT has_values_space (arg) THEN  RETURN (FALSE);  END_IF;
    IF NOT compatible_spaces (factor_space (domain, i), values_space_of (arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="function_is_1d_array">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="function_is_1d_table">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="function_is_2d_table">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1, itvl2 : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) &lt;&gt; 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN  RETURN (FALSE);  END_IF;
  pspace := temp;
  IF space_dimension (pspace) &lt;&gt; 2 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space (pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));</algorithm>
      </function>
      <function name="function_is_array">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="function_is_table">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1 (tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base &lt;&gt; 0) AND (base &lt;&gt; 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min &lt;&gt; base THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="gbsf_check_curve">
         <parameter name="cv">
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) &gt; 1 THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE'] * TYPEOF(cv)) = 1 THEN
    RETURN (TRUE);
  ELSE
    IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
      RETURN (TRUE);
    ELSE
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) OR (cv\composite_curve.self_intersect = UNKNOWN)) THEN
        RETURN (SIZEOF(QUERY(seg &lt;* cv\composite_curve.segments | NOT (gbsf_check_curve(seg.parent_curve)))) = 0);
      ELSE
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
        ELSE
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)))) THEN
            RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv) THEN
              RETURN ((gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(cv\pcurve.basis_surface)));
            ELSE
              IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF(cv\polyline.points) &gt;= 3) THEN
                  RETURN (TRUE);
                END_IF;
              ELSE
                IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN
                  IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                        IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                          RETURN (FALSE);
                        END_IF;
                      ELSE
                        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                            RETURN (FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN (TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="gbsf_check_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN (TRUE);
  ELSE
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
      RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
        RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
          RETURN ((gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(pnt\degenerate_pcurve.basis_surface)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="gbsf_check_surface">
         <parameter name="sf">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) OR (sf\b_spline_surface.self_intersect = UNKNOWN)) THEN
    RETURN (TRUE);
  ELSE
    IF SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPHERICAL_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TOROIDAL_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RECTANGULAR_TRIMMED_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN (TRUE);
    ELSE
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) OR (sf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
      ELSE
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
          REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
            REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
              IF NOT (gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface)) THEN
                RETURN (FALSE);
              END_IF;
            END_REPEAT;
          END_REPEAT;
          RETURN (TRUE);
        ELSE
          IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA' IN TYPEOF(sf) THEN
            RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
          ELSE
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(sf) THEN
              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="get_basis_surface">
         <parameter name="c">
            <typename name="curve_on_surface"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="2"/>
         <typename name="surface"/>
         <algorithm>LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n &gt; 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);</algorithm>
      </function>
      <function name="get_description_value">
         <parameter name="obj">
            <typename name="description_attribute_select"/>
         </parameter>
         <typename name="text"/>
         <algorithm>LOCAL
      description_bag : BAG OF description_attribute := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
    END_LOCAL;

    IF SIZEOF(description_bag) = 1 THEN
      RETURN (description_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;</algorithm>
      </function>
      <function name="get_id_value">
         <parameter name="obj">
            <typename name="id_attribute_select"/>
         </parameter>
         <typename name="identifier"/>
         <algorithm>LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
    END_LOCAL;

    IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;</algorithm>
      </function>
      <function name="get_name_value">
         <parameter name="obj">
            <typename name="name_attribute_select"/>
         </parameter>
         <typename name="label"/>
         <algorithm>LOCAL
      name_bag : BAG OF name_attribute := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
    END_LOCAL;

    IF SIZEOF(name_bag) = 1 THEN
      RETURN (name_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;</algorithm>
      </function>
      <function name="get_role">
         <parameter name="obj">
            <typename name="role_select"/>
         </parameter>
         <typename name="object_role"/>
         <algorithm>LOCAL
      role_bag : BAG OF role_association := (USEDIN(obj, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
    END_LOCAL;

    IF SIZEOF(role_bag) = 1 THEN
      RETURN (role_bag[1].role);
    ELSE
      RETURN (?);
    END_IF;</algorithm>
      </function>
      <function name="get_shape_aspect_property_definition_representations">
         <parameter name="s_a_instance">
            <typename name="shape_aspect"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="property_definition_representation"/>
         <algorithm>LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [] ;
END_LOCAL;
pd_set := bag_to_set(USEDIN(s_a_instance, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) &lt; 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + (QUERY(pdr &lt;* USEDIN(pd_set[i], 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION') |
'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
END_REPEAT;
RETURN (pdr_set);</algorithm>
      </function>
      <function name="has_values_space">
         <parameter name="expr">
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := stripped_typeof (expr);
  END_LOCAL;
  IF 'EXPRESSION' IN typenames THEN
    RETURN (bool(('NUMERIC_EXPRESSION' IN typenames) OR
      ('STRING_EXPRESSION' IN typenames) OR
      ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
    RETURN (has_values_space (expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="is_SQL_mappable">
         <parameter name="arg">
            <typename name="expression"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
	i: INTEGER;
END_LOCAL;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);</algorithm>
      </function>
      <function name="is_acyclic">
         <parameter name="arg">
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>RETURN (acyclic (arg, []));</algorithm>
      </function>
      <function name="is_coordinate_property">
         <parameter name="arg">
            <typename name="specified_general_property"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXTERNALLY_DEFINED_ITEM' IN
      TYPEOF(arg) ) THEN
    RETURN(TRUE);
  END_IF;
  RETURN ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COORDINATE_DATA_NAME' IN TYPEOF(arg));</algorithm>
      </function>
      <function name="is_int_expr">
         <parameter name="arg">
            <typename name="numeric_expression"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
	i: INTEGER := 0;
END_LOCAL;

IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COS_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);</algorithm>
      </function>
      <function name="item_in_context">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <parameter name="cntxt">
            <typename name="representation_context"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) &gt; 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z &lt;* USEDIN (item , '') |
             'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) &gt; 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);</algorithm>
      </function>
      <function name="leap_year">
         <parameter name="year">
            <typename name="year_number"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ((((year MOD 4) = 0) AND ((year MOD 100) &lt;&gt; 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;</algorithm>
      </function>
      <function name="list_face_loops">
         <parameter name="f">
            <typename name="face"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);</algorithm>
      </function>
      <function name="list_of_topology_reversed">
         <parameter name="a_list">
            <typename name="list_of_reversible_topology_item"/>
         </parameter>
         <typename name="list_of_reversible_topology_item"/>
         <algorithm>LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="list_selected_components">
         <parameter name="aggr">
            <aggregate type="AGGREGATE"/>
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </parameter>
         <parameter name="k">
            <typename name="positive_integer"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="maths_value"/>
         <algorithm>LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;
  REPEAT i := LOINDEX (aggr) TO HIINDEX (aggr);
    IF k &lt;= SIZEOF (aggr[i]) THEN
      INSERT (result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);</algorithm>
      </function>
      <function name="list_to_array">
         <parameter name="lis">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY" upper="0"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n &lt;&gt; (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;</algorithm>
      </function>
      <function name="list_to_set">
         <parameter name="l">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);</algorithm>
      </function>
      <function name="make_array_of_array">
         <parameter name="lis">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY" upper="0"/>
         <aggregate lower="0" type="ARRAY" upper="0"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);</algorithm>
      </function>
      <function name="make_atom_based_literal">
         <parameter name="lit_value">
            <typename name="atom_based_value"/>
         </parameter>
         <typename name="atom_based_literal"/>
         <algorithm>RETURN (atom_based_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );</algorithm>
      </function>
      <function name="make_binary_literal">
         <parameter name="lit_value">
            <builtintype type="BINARY"/>
         </parameter>
         <typename name="binary_literal"/>
         <algorithm>RETURN (binary_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );</algorithm>
      </function>
      <function name="make_boolean_literal">
         <parameter name="lit_value">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <typename name="boolean_literal"/>
         <algorithm>RETURN (boolean_literal (lit_value)
    || simple_boolean_expression()
      || boolean_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );</algorithm>
      </function>
      <function name="make_cartesian_complex_number_region">
         <parameter name="real_constraint">
            <typename name="real_interval"/>
         </parameter>
         <parameter name="imag_constraint">
            <typename name="real_interval"/>
         </parameter>
         <typename name="cartesian_complex_number_region"/>
         <algorithm>RETURN (cartesian_complex_number_region (real_constraint, imag_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_complex_number_literal">
         <parameter name="rpart">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="ipart">
            <builtintype type="REAL"/>
         </parameter>
         <typename name="complex_number_literal"/>
         <algorithm>RETURN (complex_number_literal (rpart, ipart)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );</algorithm>
      </function>
      <function name="make_elementary_function">
         <parameter name="func_id">
            <typename name="elementary_function_enumerators"/>
         </parameter>
         <typename name="elementary_function"/>
         <algorithm>RETURN (elementary_function (func_id)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_elementary_space">
         <parameter name="space_id">
            <typename name="elementary_space_enumerators"/>
         </parameter>
         <typename name="elementary_space"/>
         <algorithm>RETURN (elementary_space (space_id)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_extended_tuple_space">
         <parameter name="base">
            <typename name="product_space"/>
         </parameter>
         <parameter name="extender">
            <typename name="maths_space"/>
         </parameter>
         <typename name="extended_tuple_space"/>
         <algorithm>RETURN (extended_tuple_space (base, extender)
    || maths_space ()
      || generic_expression()
    || generic_literal ()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_finite_integer_interval">
         <parameter name="min">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="max">
            <builtintype type="INTEGER"/>
         </parameter>
         <typename name="finite_integer_interval"/>
         <algorithm>RETURN (finite_integer_interval (min, max)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_finite_real_interval">
         <parameter name="min">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="minclo">
            <typename name="open_closed"/>
         </parameter>
         <parameter name="max">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="maxclo">
            <typename name="open_closed"/>
         </parameter>
         <typename name="finite_real_interval"/>
         <algorithm>RETURN (finite_real_interval (min, minclo, max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_finite_space">
         <parameter name="members">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="maths_value"/>
         </parameter>
         <typename name="finite_space"/>
         <algorithm>RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_function_application">
         <parameter name="afunction">
            <typename name="maths_function_select"/>
         </parameter>
         <parameter name="arguments">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </parameter>
         <typename name="function_application"/>
         <algorithm>RETURN (function_application (afunction, arguments)
    || multiple_arity_generic_expression (convert_to_maths_function (afunction) +
      convert_to_operands (arguments))  -- derived
      || generic_expression() );</algorithm>
      </function>
      <function name="make_function_space">
         <parameter name="domain_constraint">
            <typename name="space_constraint_type"/>
         </parameter>
         <parameter name="domain_argument">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="range_constraint">
            <typename name="space_constraint_type"/>
         </parameter>
         <parameter name="range_argument">
            <typename name="maths_space"/>
         </parameter>
         <typename name="function_space"/>
         <algorithm>RETURN (function_space (domain_constraint, domain_argument, range_constraint,
    range_argument)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_int_literal">
         <parameter name="lit_value">
            <builtintype type="INTEGER"/>
         </parameter>
         <typename name="int_literal"/>
         <algorithm>RETURN (int_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );</algorithm>
      </function>
      <function name="make_listed_product_space">
         <parameter name="factors">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_space"/>
         </parameter>
         <typename name="listed_product_space"/>
         <algorithm>RETURN (listed_product_space (factors)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_logical_literal">
         <parameter name="lit_value">
            <builtintype type="LOGICAL"/>
         </parameter>
         <typename name="logical_literal"/>
         <algorithm>RETURN (logical_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );</algorithm>
      </function>
      <function name="make_maths_enum_literal">
         <parameter name="lit_value">
            <typename name="maths_enum_atom"/>
         </parameter>
         <typename name="maths_enum_literal"/>
         <algorithm>RETURN (maths_enum_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );</algorithm>
      </function>
      <function name="make_maths_tuple_literal">
         <parameter name="lit_value">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </parameter>
         <typename name="maths_tuple_literal"/>
         <algorithm>RETURN (maths_tuple_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );</algorithm>
      </function>
      <function name="make_parallel_composed_function">
         <parameter name="srcdom">
            <typename name="maths_space_or_function"/>
         </parameter>
         <parameter name="prepfuncs">
            <aggregate lower="2" type="LIST" upper="?"/>
            <typename name="maths_function"/>
         </parameter>
         <parameter name="finfunc">
            <typename name="maths_function_select"/>
         </parameter>
         <typename name="parallel_composed_function"/>
         <algorithm>RETURN (parallel_composed_function (srcdom, prepfuncs, finfunc)
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (convert_to_operands_prcmfn (
      srcdom, prepfuncs, finfunc)) );</algorithm>
      </function>
      <function name="make_polar_complex_number_region">
         <parameter name="centre">
            <typename name="complex_number_literal"/>
         </parameter>
         <parameter name="dis_constraint">
            <typename name="real_interval"/>
         </parameter>
         <parameter name="dir_constraint">
            <typename name="finite_real_interval"/>
         </parameter>
         <typename name="polar_complex_number_region"/>
         <algorithm>RETURN (polar_complex_number_region (centre, dis_constraint, dir_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_real_interval_from_min">
         <parameter name="min">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="minclo">
            <typename name="open_closed"/>
         </parameter>
         <typename name="real_interval_from_min"/>
         <algorithm>RETURN (real_interval_from_min (min, minclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_real_interval_to_max">
         <parameter name="max">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="maxclo">
            <typename name="open_closed"/>
         </parameter>
         <typename name="real_interval_to_max"/>
         <algorithm>RETURN (real_interval_to_max (max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="make_real_literal">
         <parameter name="lit_value">
            <builtintype type="REAL"/>
         </parameter>
         <typename name="real_literal"/>
         <algorithm>RETURN (real_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );</algorithm>
      </function>
      <function name="make_string_literal">
         <parameter name="lit_value">
            <builtintype type="STRING"/>
         </parameter>
         <typename name="string_literal"/>
         <algorithm>RETURN (string_literal (lit_value)
    || simple_string_expression()
      || string_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );</algorithm>
      </function>
      <function name="make_uniform_product_space">
         <parameter name="base">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="exponent">
            <typename name="positive_integer"/>
         </parameter>
         <typename name="uniform_product_space"/>
         <algorithm>RETURN (uniform_product_space (base, exponent)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );</algorithm>
      </function>
      <function name="max_exists">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));</algorithm>
      </function>
      <function name="max_included">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="member_of">
         <parameter name="val">
            <builtintype type="GENERIC" typelabel="G"/>
         </parameter>
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>FUNCTION fedex(val : AGGREGATE OF GENERIC:X;
                 i   : INTEGER) : GENERIC:X;
    RETURN (val[i]);
  END_FUNCTION;  -- fedex

  LOCAL
    v : maths_value := simplify_maths_value (convert_to_maths_value (val));
    vtypes : SET OF STRING := stripped_typeof (v);
    s : maths_space := simplify_maths_space (spc);
    stypes : SET OF STRING := stripped_typeof (s);
    tmp_int : INTEGER;
    tmp_real : REAL;
    tmp_cmplx : complex_number_literal;
    lgcl, cum : LOGICAL;
    vspc, sspc : maths_space;
    smem : SET OF maths_value;
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (s) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT EXISTS (v) THEN
    RETURN (s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
    NOT ('MATHS_SPACE' IN vtypes) AND
    NOT ('MATHS_FUNCTION' IN vtypes) AND
    NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes) THEN
    IF has_values_space (v) THEN
      vspc := values_space_of (v);
      IF subspace_of (vspc, s) THEN
        RETURN (TRUE);
      END_IF;
      IF NOT compatible_spaces (vspc, s) THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes THEN
    CASE s\elementary_space.space_id OF
    es_numbers :  RETURN (('NUMBER' IN vtypes) OR
                          ('COMPLEX_NUMBER_LITERAL' IN vtypes));
    es_complex_numbers :  RETURN ('COMPLEX_NUMBER_LITERAL' IN vtypes);
    es_reals :  RETURN (('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
    es_integers :  RETURN ('INTEGER' IN vtypes);
    es_logicals :  RETURN ('LOGICAL' IN vtypes);
    es_booleans :  RETURN ('BOOLEAN' IN vtypes);
    es_strings :  RETURN ('STRING' IN vtypes);
    es_binarys :  RETURN ('BINARY' IN vtypes);
    es_maths_spaces :  RETURN ('MATHS_SPACE' IN vtypes);
    es_maths_functions :  RETURN ('MATHS_FUNCTION' IN vtypes);
    es_generics :  RETURN (TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN ({s\finite_integer_interval.min &lt;= tmp_int &lt;=
        s\finite_integer_interval.max});
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (s\integer_interval_from_min.min &lt;= tmp_int);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (tmp_int &lt;= s\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed THEN
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min &lt;= tmp_real &lt;=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min &lt;= tmp_real &lt;
            s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min &lt; tmp_real &lt;=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min &lt; tmp_real &lt;
            s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed THEN
        RETURN (s\real_interval_from_min.min &lt;= tmp_real);
      ELSE
        RETURN (s\real_interval_from_min.min &lt; tmp_real);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed THEN
        RETURN (tmp_real &lt;= s\real_interval_to_max.max);
      ELSE
        RETURN (tmp_real &lt; s\real_interval_to_max.max);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      RETURN (member_of(v\complex_number_literal.real_part,
        s\cartesian_complex_number_region.real_constraint) AND
        member_of(v\complex_number_literal.imag_part,
        s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part -
        s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part -
        s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT (tmp_cmplx.real_part**2 + tmp_cmplx.imag_part**2);
      IF NOT member_of(tmp_real,
        s\polar_complex_number_region.distance_constraint) THEN
        RETURN (FALSE);
      END_IF;
      IF tmp_real = 0.0 THEN
        RETURN (TRUE);  -- The centre has no direction.
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part,tmp_cmplx.real_part);
      RETURN (member_of(tmp_real,
        s\polar_complex_number_region.direction_constraint) OR
        member_of(tmp_real + 2.0*PI,
        s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF (smem);
      cum := cum OR equal_maths_values(v,smem[i]);
      IF cum = TRUE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      IF SIZEOF (v) = s\uniform_product_space.exponent THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
--          cum := cum AND member_of (fedex (v, i), sspc);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF (v) = SIZEOF (factors) THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],factors[i]);
--          cum := cum AND member_of (fedex (v, i), factors[i]);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF (v) &gt;= tmp_int THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i],factor_space(sspc,i));
--          cum := cum AND member_of (fedex (v, i), factor_space (sspc, i));
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int+1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    IF 'MATHS_FUNCTION' IN vtypes THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
      sc_equal : cum := equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := subspace_of (vspc, sspc);
      sc_member : cum := member_of (vspc, sspc);
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
      sc_equal : cum := cum AND equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := cum AND subspace_of (vspc, sspc);
      sc_member : cum := cum AND member_of (vspc, sspc);
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);</algorithm>
      </function>
      <function name="min_exists">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));</algorithm>
      </function>
      <function name="min_included">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="mixed_loop_type_set">
         <parameter name="l">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="loop"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) &lt;= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt; poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="msb_shells">
         <parameter name="brep">
            <typename name="manifold_solid_brep"/>
         </parameter>
         <aggregate lower="1" type="SET" upper="?"/>
         <typename name="closed_shell"/>
         <algorithm>LOCAL   
      return_set: SET[1:?] OF closed_shell := [brep.outer];   
    END_LOCAL;   

    IF SIZEOF(QUERY(msbtype &lt;* TYPEOF(brep) |   
                 msbtype LIKE '*BREP_WITH_VOIDS'))  &gt;= 1    
          THEN   
       return_set := return_set + brep\brep_with_voids.voids;   
    END_IF;   
   RETURN(return_set);</algorithm>
      </function>
      <function name="msf_curve_check">
         <parameter name="cv">
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE',
  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
  'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) &gt; 1 THEN
  RETURN(FALSE);
END_IF;

(* b_spline_curves shall not self-intersect
 *)
IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
  (cv\b_spline_curve.self_intersect = FALSE)OR
  (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
  RETURN(TRUE);
ELSE

  (* conics and lines are valid curve types
   *)
  IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE'] 
    * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE

    (* a curve_replica shall reference a valid curve
     *)
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
      RETURN (msf_curve_check(cv\curve_replica.parent_curve)); 
    ELSE 
 
      (* an offset_curve_3d shall not self-intersect and
         shall reference a valid curve; a polyline is not a
         valid basis_curve
       *)
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (cv))
        AND
        ((cv\offset_curve_3d.self_intersect = FALSE) OR
        (cv\offset_curve_3d.self_intersect = UNKNOWN))
        AND
        (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF
        (cv\offset_curve_3d.basis_curve)))) THEN
        RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve)); 
      ELSE 
 
        (* a pcurve shall reference a valid curve and a valid
           basis_surface
         *)
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv) THEN 
          RETURN ((msf_curve_check
          (cv\pcurve.reference_to_curve\representation.items[1])) AND
          (msf_surface_check(cv\pcurve.basis_surface)));
        ELSE 
 
          (* a surface_curve references a curve_3d and one or
             two pcurves or one or two surfaces or one of
             each; all of these references shall be valid
           *)
          IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN 

            (* if the curve reference is correct, check also the rest
             *)
            IF msf_curve_check(cv\surface_curve.curve_3d) THEN
              REPEAT i := 1 TO SIZEOF
              (cv\surface_curve.associated_geometry);

                (* do for one or two associated_geometrys:
                 *)
                IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN 
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                  IF NOT msf_surface_check
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    RETURN(FALSE);  
                  END_IF;  
                ELSE  
                  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF 
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT msf_curve_check
                      (cv\surface_curve.associated_geometry[i]) THEN 
                      RETURN(FALSE);  
                    END_IF;  
                  END_IF;  
                END_IF; 
              END_REPEAT;  
              RETURN(TRUE);
            END_IF; 
          ELSE

            (* a polyline shall have at least 3 points
             *)
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
              IF (SIZEOF (cv\polyline.points) &gt;= 3) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
END_IF; 
(* FALSE is returned if the input parameter cv is not a valid curve.
 *)
RETURN (FALSE);</algorithm>
      </function>
      <function name="msf_surface_check">
         <parameter name="surf">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (msf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (msf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(msf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE);</algorithm>
      </function>
      <function name="necessary_value_coordinate_system">
         <parameter name="cs_value">
            <typename name="field_value"/>
         </parameter>
         <parameter name="coordinate_system">
            <builtintype type="GENERIC"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF (SIZEOF (
        ['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TENSOR1_2D',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TENSOR1_3D',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRIC_TENSOR2_2D',
         'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SYMMETRIC_TENSOR2_3D'] *
        TYPEOF (cs_value)) = 1) THEN
        IF (NOT EXISTS (coordinate_system) ) THEN
            RETURN (FALSE);
        END_IF;
    END_IF;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="nmsf_curve_check">
         <parameter name="cv">
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BOUNDED_CURVE',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D'] * TYPEOF(cv)) &gt; 1
 THEN RETURN(FALSE);
 ELSE

  (* b_spline_curves shall not self-intersect
   *)
  IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
    (cv\b_spline_curve.self_intersect = FALSE) OR
    (cv\b_spline_curve.self_intersect = UNKNOWN))
  THEN RETURN(TRUE);
  ELSE

    (* conics and lines are valid curve types
     *)
    IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC',
    'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE'] * TYPEOF (cv)) = 1 THEN
      RETURN(TRUE);
    ELSE

      (* a curve_replica shall reference a valid curve
       *)
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF(cv) THEN
        RETURN (nmsf_curve_check(cv\curve_replica.parent_curve)); 
      ELSE 
 
        (* an offset_curve_3d shall not self-intersect and
           shall reference a valid curve; a polyline is not a
           valid basis_curve
         *)
        IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (cv)) 
          AND
          ((cv\offset_curve_3d.self_intersect = FALSE) OR
          (cv\offset_curve_3d.self_intersect = UNKNOWN))
          AND
          (NOT ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF
          (cv\offset_curve_3d.basis_curve)))) THEN
          RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve)); 
        ELSE 
 
          (* a pcurve shall reference a valid curve and a valid
             basis_surface
           *)
          IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv) THEN 
            RETURN ((nmsf_curve_check
            (cv\pcurve.reference_to_curve\representation.items[1]))
            AND
            (nmsf_surface_check(cv\pcurve.basis_surface)));
          ELSE 
 
            (* a surface_curve references a curve_3d and one or
               two pcurves or one or two surfaces or one of
               each; all of these references shall be valid
             *)
            IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_CURVE' IN TYPEOF(cv) THEN 

              (* if the curve reference is correct, check also the rest
               *)
              IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                REPEAT i := 1 TO SIZEOF
                (cv\surface_curve.associated_geometry);

                  (* do for one or two associated_geometrys:
                   *)
                  IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE' IN 
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT nmsf_surface_check
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      RETURN(FALSE);  
                    END_IF;  
                  ELSE  
                    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PCURVE' IN TYPEOF 
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT nmsf_curve_check
                        (cv\surface_curve.associated_geometry[i]) THEN 
                        RETURN(FALSE);  
                      END_IF;  
                    END_IF;  
                  END_IF; 
                END_REPEAT;  
                RETURN(TRUE);
              END_IF; 
            ELSE

              (* a polyline shall have at least 3 points 
               *)
              IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF (cv\polyline.points) &gt;= 3) THEN RETURN (TRUE);
                END_IF;
              END_IF;
            END_IF; 
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
 END_IF; 
 (* FALSE is returned if the input parameter cv is not a valid curve.
  *)
 RETURN (FALSE);</algorithm>
      </function>
      <function name="nmsf_surface_check">
         <parameter name="surf">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(nmsf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(surf))
            AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE);</algorithm>
      </function>
      <function name="no_cyclic_domain_reference">
         <parameter name="ref">
            <typename name="maths_space_or_function"/>
         </parameter>
         <parameter name="used">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := TYPEOF (ref);
    func      : maths_function;
  END_LOCAL;
  IF (NOT EXISTS (ref)) OR (NOT EXISTS (used)) THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\constant_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\selector_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (
      func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="no_cyclic_space_reference">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="refs">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp &lt;* QUERY (mem &lt;* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac &lt;* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);</algorithm>
      </function>
      <function name="nondecreasing">
         <parameter name="lr">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="REAL"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT EXISTS (lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF (lr);
    IF lr[j] &lt; lr[j-1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="normalise">
         <parameter name="arg">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector_or_direction"/>
         <algorithm>LOCAL
      ndim   : INTEGER;
      v      : direction;
      result : vector_or_direction;
      vec    : vector;
      mag    : REAL;
    END_LOCAL;
    
    IF NOT EXISTS (arg) THEN
      result := ?;
  (* When function is called with invalid data a NULL result is returned *)
    ELSE
      ndim := arg.dim;
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
              v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
          IF arg.magnitude = 0.0 THEN
            RETURN(?);
          ELSE
           vec := dummy_gri || vector (v, 1.0);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction (arg.direction_ratios);
      END_IF;
      mag := 0.0;
      REPEAT  i := 1 TO ndim;
        mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
      END_REPEAT;
      IF mag &gt; 0.0 THEN
        mag := SQRT(mag);
        REPEAT  i := 1 TO ndim;
          v.direction_ratios[i] := v.direction_ratios[i]/mag;
        END_REPEAT;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="number_of_terms">
         <parameter name="node_dof_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="degree_of_freedom"/>
         </parameter>
         <parameter name="matrix_type">
            <typename name="matrix_symmetry"/>
         </parameter>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
    num_terms              : INTEGER;
    number_of_freedoms     : INTEGER;
  END_LOCAL;

  number_of_freedoms := 0; (* loop for each item in the outer list*)

  REPEAT i := 1 TO SIZEOF (node_dof_list); (* find size of inner list*)
    number_of_freedoms := number_of_freedoms + SIZEOF (node_dof_list[i]);
  END_REPEAT;

  IF (matrix_type = symmetric) THEN
    num_terms := (number_of_freedoms * (number_of_freedoms+1)) DIV 2;
  END_IF;

  IF (matrix_type = diagonal) THEN
    num_terms := number_of_freedoms;
  END_IF;

RETURN (num_terms);</algorithm>
      </function>
      <function name="number_superspace_of">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <typename name="elementary_space"/>
         <algorithm>IF subspace_of_es(spc,es_integers) THEN  RETURN (the_integers);  END_IF;
  IF subspace_of_es(spc,es_reals)    THEN  RETURN (the_reals);     END_IF;
  IF subspace_of_es(spc,es_complex_numbers) THEN  RETURN (the_complex_numbers); END_IF;
  IF subspace_of_es(spc,es_numbers)  THEN  RETURN (the_numbers);   END_IF;
  RETURN (?);</algorithm>
      </function>
      <function name="number_tuple_subspace_check">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base,es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      cum := cum AND subspace_of_es(factors[i],es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender,es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="one_tuples_of">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>RETURN (make_uniform_product_space (spc, 1));</algorithm>
      </function>
      <function name="open_shell_reversed">
         <parameter name="a_shell">
            <typename name="open_shell"/>
         </parameter>
         <typename name="oriented_open_shell"/>
         <algorithm>LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="orthogonal_complement">
         <parameter name="vec">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim &lt;&gt; 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;</algorithm>
      </function>
      <function name="parallel_composed_function_composability_check">
         <parameter name="funcs">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_function"/>
         </parameter>
         <parameter name="final">
            <typename name="maths_function_select"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function (final);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (funcs);
    tplsp := assoc_product_space (tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces (tplsp, finfun.domain));</algorithm>
      </function>
      <function name="parallel_composed_function_domain_check">
         <parameter name="comdom">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="funcs">
            <aggregate lower="0" type="LIST" upper="?"/>
            <typename name="maths_function"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO SIZEOF (funcs);
    IF NOT (compatible_spaces (comdom, funcs[i].domain)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="parse_express_identifier">
         <parameter name="s">
            <builtintype type="STRING"/>
         </parameter>
         <parameter name="i">
            <typename name="positive_integer"/>
         </parameter>
         <typename name="positive_integer"/>
         <algorithm>LOCAL
    k : positive_integer;
  END_LOCAL;
  k := i;
  IF i &lt;= LENGTH (s) THEN
    IF (s[i] LIKE '@') THEN
      REPEAT UNTIL (k &gt; LENGTH (s)) OR
        ((s[k] &lt;&gt; '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (k);</algorithm>
      </function>
      <function name="partial_derivative_check">
         <parameter name="domain">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="d_vars">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="input_selector"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  REPEAT i := 1 TO SIZEOF (d_vars);
    k := d_vars[i];
    IF k &gt; dim THEN
       RETURN (FALSE);
    END_IF;
    fspc := factor_space (domn, k);
    IF (NOT subspace_of_es (fspc,es_reals)) AND
      (NOT subspace_of_es (fspc,es_complex_numbers)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="path_head_to_tail">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);</algorithm>
      </function>
      <function name="path_reversed">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <typename name="oriented_path"/>
         <algorithm>LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);</algorithm>
      </function>
      <function name="real_max">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);</algorithm>
      </function>
      <function name="real_min">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);</algorithm>
      </function>
      <function name="regular_indexing">
         <parameter name="sub">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="base">
            <typename name="zero_or_one"/>
         </parameter>
         <parameter name="shape">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="positive_integer"/>
         </parameter>
         <parameter name="inc">
            <aggregate lower="1" type="LIST" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="first">
            <builtintype type="INTEGER"/>
         </parameter>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL
    k : INTEGER;
    index : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (sub) OR NOT EXISTS (base) OR NOT EXISTS (shape) OR
    NOT EXISTS (inc) OR NOT EXISTS (first) THEN
    RETURN (?);
  END_IF;
  IF (SIZEOF (sub) &lt;&gt; SIZEOF (inc)) OR (SIZEOF (sub) &lt;&gt; SIZEOF (shape)) THEN
    RETURN (?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF (sub);
    IF NOT EXISTS (sub[j]) OR NOT EXISTS (inc[j]) THEN
      RETURN (?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 &lt;= k &lt; shape[j]}) THEN
      RETURN (?);
    END_IF;
    index := index + k*inc[j];
  END_REPEAT;
  RETURN (index);</algorithm>
      </function>
      <function name="remove_first">
         <parameter name="alist">
            <aggregate lower="0" type="LIST" upper="?"/>
            <builtintype type="GENERIC" typelabel="GEN"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <builtintype type="GENERIC" typelabel="GEN"/>
         <algorithm>LOCAL
    blist : LIST OF GENERIC:GEN := alist;
  END_LOCAL;
  IF SIZEOF (blist) &gt; 0 THEN
    REMOVE (blist, 1);
  END_IF;
  RETURN (blist);</algorithm>
      </function>
      <function name="repackage">
         <parameter name="tspace">
            <typename name="tuple_space"/>
         </parameter>
         <parameter name="repckg">
            <typename name="repackage_options"/>
         </parameter>
         <typename name="tuple_space"/>
         <algorithm>CASE repckg OF
  ro_nochange : RETURN (tspace);
  ro_wrap_as_tuple : RETURN (one_tuples_of (tspace));
  ro_unwrap_tuple : RETURN (factor1 (tspace));
  OTHERWISE : RETURN (?);
  END_CASE;</algorithm>
      </function>
      <function name="required_0d_nodes">
         <parameter name="node_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="node_representation"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>RETURN (SIZEOF (node_list) = 1);</algorithm>
      </function>
      <function name="required_1d_nodes">
         <parameter name="node_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="node_representation"/>
         </parameter>
         <parameter name="order">
            <typename name="element_order"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
   end_nodes                : INTEGER;
   additional_nodes         : INTEGER;
  END_LOCAL;

  end_nodes := 2;

  IF (order = linear) THEN
    additional_nodes := 0;
  END_IF;
  IF (order = quadratic) THEN
    additional_nodes := 1;
  END_IF;
  IF (order = cubic) THEN
    additional_nodes := 2;
  END_IF;

  RETURN (SIZEOF (node_list) = end_nodes + additional_nodes);</algorithm>
      </function>
      <function name="required_2d_nodes">
         <parameter name="node_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="node_representation"/>
         </parameter>
         <parameter name="element_shape">
            <typename name="element_2d_shape"/>
         </parameter>
         <parameter name="order">
            <typename name="element_order"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = element_2d_shape.triangle) THEN
    vertex_nodes := 3;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 3;
      edge_face_body_nodes := 3;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 7;
    END_IF;
  END_IF;

  IF (element_shape = element_2d_shape.quadrilateral) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 4;
      edge_face_body_nodes := 5;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 12;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));</algorithm>
      </function>
      <function name="required_3d_nodes">
         <parameter name="node_list">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="node_representation"/>
         </parameter>
         <parameter name="element_shape">
            <typename name="volume_3d_element_shape"/>
         </parameter>
         <parameter name="order">
            <typename name="element_order"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    vertex_nodes            : INTEGER;
    edge_nodes              : INTEGER;
    edge_face_body_nodes    : INTEGER;
  END_LOCAL;

  IF (element_shape = volume_3d_element_shape.hexahedron) THEN
    vertex_nodes := 8;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 19;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 24;
      edge_face_body_nodes := 56;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.wedge) THEN
    vertex_nodes := 6;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 9;
      edge_face_body_nodes := 12;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 18;
      edge_face_body_nodes := 34;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.tetrahedron) THEN
    vertex_nodes := 4;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 6;
      edge_face_body_nodes := 6;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 12;
      edge_face_body_nodes := 16;
    END_IF;
  END_IF;

  IF (element_shape = volume_3d_element_shape.pyramid) THEN
    vertex_nodes := 5;
    IF (order = linear) THEN
      edge_nodes           := 0;
      edge_face_body_nodes := 0;
    END_IF;
    IF (order = quadratic) THEN
      edge_nodes           := 8;
      edge_face_body_nodes := 9;
    END_IF;
    IF (order = cubic) THEN
      edge_nodes           := 16;
      edge_face_body_nodes := 25;
    END_IF;
  END_IF;

  RETURN ((SIZEOF (node_list) = vertex_nodes + edge_nodes) OR 
          (SIZEOF (node_list) = vertex_nodes + edge_face_body_nodes));</algorithm>
      </function>
      <function name="scalar_times_vector">
         <parameter name="scalar">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="vec">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
 
    IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
      RETURN (?) ;
     ELSE
      IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF (vec) THEN
        v   := dummy_gri || direction(vec\vector.orientation.direction_ratios);
        mag := scalar * vec.magnitude;
      ELSE
        v   := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF (mag &lt; 0.0 ) THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios);
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v), mag);
    END_IF;
    RETURN (result);</algorithm>
      </function>
      <function name="second_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="x_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);</algorithm>
      </function>
      <function name="set_of_topology_reversed">
         <parameter name="a_set">
            <typename name="set_of_reversible_topology_item"/>
         </parameter>
         <typename name="set_of_reversible_topology_item"/>
         <algorithm>LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);</algorithm>
      </function>
      <function name="shape_of_array">
         <parameter name="func">
            <typename name="maths_function"/>
         </parameter>
         <aggregate lower="0" type="LIST" upper="?"/>
         <typename name="positive_integer"/>
         <algorithm>LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF (func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (?);
    END_IF;
    INSERT (result, temp\finite_integer_interval.size, i-1);
  END_REPEAT;
  RETURN (result);</algorithm>
      </function>
      <function name="shell_reversed">
         <parameter name="a_shell">
            <typename name="shell"/>
         </parameter>
         <typename name="shell"/>
         <algorithm>IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;</algorithm>
      </function>
      <function name="shorten_array">
         <parameter name="longa">
            <aggregate lower="0" type="ARRAY"/>
            <builtintype type="GENERIC" typelabel="T"/>
         </parameter>
         <parameter name="oldl">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="newl">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate lower="0" type="ARRAY"/>
         <builtintype type="GENERIC" typelabel="T"/>
         <algorithm>LOCAL
     shorta : ARRAY [1:newl] OF GENERIC : T;
   END_LOCAL;

   IF (newl &gt; oldl) THEN
     RETURN(?);
   ELSE
     REPEAT i := 1 TO newl;
       shorta[i] := longa[i];
     END_REPEAT;
     RETURN(shorta);
   END_IF;</algorithm>
      </function>
      <function name="simplify_function_application">
         <parameter name="expr">
            <typename name="function_application"/>
         </parameter>
         <typename name="maths_value"/>
         <algorithm>FUNCTION ctmv(x : GENERIC:G) : maths_value;
    RETURN (convert_to_maths_value(x));
  END_FUNCTION;  -- local abbreviation for convert_to_maths_value function
  PROCEDURE parts(       c : complex_number_literal;
                  VAR x, y : REAL);
    x := c.real_part;  y := c.imag_part;
  END_PROCEDURE;  -- parts
  FUNCTION makec(x, y : REAL) : complex_number_literal;
    RETURN (make_complex_number_literal(x,y));
  END_FUNCTION;  -- local abbreviation for make_complex_number_literal function
  FUNCTION good_t(v  : maths_value;
                  tn : STRING) : BOOLEAN;
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;
    IF 'LIST' IN TYPEOF (v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF (tpl);
        IF NOT (tn IN TYPEOF (tpl[i])) THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;  -- good_t
  CONSTANT
    cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
  END_CONSTANT;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr.func);
    ef_val : elementary_function_enumerators;
    is_elementary : BOOLEAN := FALSE;
    v, v1, v2, v3 : maths_value;
    vlist : LIST OF maths_value := [];
    gexpr : generic_expression;
    pairs : SET [1:?] OF LIST [2:2] OF maths_value;
    boo : BOOLEAN;
    lgc, cum : LOGICAL;
    j, k, n : INTEGER;
    p, q, r, s, t, u : REAL;
    str, st2 : STRING;
    bin, bi2 : BINARY;
    tpl, tp2 : LIST OF maths_value;
    mem :SET OF maths_value := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT (vlist, v, i-1);
  END_REPEAT;
  IF SIZEOF (vlist) &gt;= 1 THEN  v1 := vlist[1];  END_IF;
  IF SIZEOF (vlist) &gt;= 2 THEN  v2 := vlist[2];  END_IF;
  IF SIZEOF (vlist) &gt;= 3 THEN  v3 := vlist[3];  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary THEN
    CASE ef_val OF
    ef_and : BEGIN
      cum := TRUE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum AND lgc;
          IF lgc = FALSE THEN  RETURN (ctmv(FALSE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum &lt;&gt; TRUE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_or : BEGIN
      cum := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum OR lgc;
          IF lgc = TRUE THEN  RETURN (ctmv(TRUE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum &lt;&gt; FALSE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_not :
      IF 'LOGICAL' IN TYPEOF (v1) THEN  lgc := v1;  RETURN (ctmv(NOT lgc));  END_IF;
    ef_xor : BEGIN
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;
        IF 'LOGICAL' IN TYPEOF (v2) THEN  cum := v2;  RETURN (ctmv(lgc XOR cum));
        ELSE IF lgc = FALSE THEN  RETURN (ctmv(v2));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v2]));
        END_IF;  END_IF;  END_IF;
      ELSE IF 'LOGICAL' IN TYPEOF (v2) THEN
        lgc := v2;
        IF lgc = FALSE THEN  RETURN (ctmv(v1));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v1]));
        END_IF;  END_IF;
      END_IF;  END_IF;
      END;
    ef_negate_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(-j));  END_IF;
    ef_add_i : BEGIN
      j := 0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j + k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j &lt;&gt; 0 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j - k));
      END_IF;
    ef_multiply_i : BEGIN
      j := 1;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j * k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j &lt;&gt; 1 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j DIV k));
      END_IF;
    ef_mod_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j MOD k));
      END_IF;
    ef_exponentiate_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  n := 1;
        REPEAT i := 1 TO ABS(k);  n := n * j;  END_REPEAT;
        IF k &lt; 0 THEN  n := 1 DIV n;  END_IF;
        RETURN (ctmv(n));
      END_IF;
    ef_eq_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j = k));
      END_IF;
    ef_ne_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j &lt;&gt; k));
      END_IF;
    ef_gt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j &gt; k));
      END_IF;
    ef_lt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j &lt; k));
      END_IF;
    ef_ge_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j &gt;= k));
      END_IF;
    ef_le_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j &lt;= k));
      END_IF;
    ef_abs_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(ABS(j)));  END_IF;
    ef_max_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k &gt; j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k &lt; j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    -- ef_if_i : combined with ef_if
    ef_negate_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(-r));  END_IF;
    ef_reciprocal_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(1.0/r));  END_IF;
    ef_add_r : BEGIN
      r := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r &lt;&gt; 0.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r - s));
      END_IF;
    ef_multiply_r : BEGIN
      r := 1.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r * s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r &lt;&gt; 1.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r / s));
      END_IF;
    ef_mod_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  t := r/s;  j := t DIV 1;
        IF (t &lt; 0.0) AND (j &lt;&gt; t) THEN  j := j - 1;  END_IF;
        RETURN (ctmv(r - j * s));
      END_IF;
    ef_exponentiate_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r ** s));
      END_IF;
    ef_exponentiate_ri :
      IF ('REAL' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        r := v1;  k := v2;  t := 1.0;
        REPEAT i := 1 TO ABS(k);  t := t * r;  END_REPEAT;
        IF k &lt; 0 THEN  t := 1.0/t;  END_IF;
        RETURN (ctmv(t));
      END_IF;
    ef_eq_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r = s));
      END_IF;
    ef_ne_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r &lt;&gt; s));
      END_IF;
    ef_gt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r &gt; s));
      END_IF;
    ef_lt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r &lt; s));
      END_IF;
    ef_ge_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r &gt;= s));
      END_IF;
    ef_le_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r &lt;= s));
      END_IF;
    ef_abs_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ABS(r)));  END_IF;
    ef_max_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s &gt; r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s &lt; r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_acos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ACOS(r)));  END_IF;
    ef_asin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ASIN(r)));  END_IF;
    ef_atan2_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(atan2(r,s)));
      END_IF;
    ef_cos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(COS(r)));  END_IF;
    ef_exp_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(EXP(r)));  END_IF;
    ef_ln_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG(r)));  END_IF;
    ef_log2_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG2(r)));  END_IF;
    ef_log10_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG10(r)));  END_IF;
    ef_sin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SIN(r)));  END_IF;
    ef_sqrt_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SQRT(r)));  END_IF;
    ef_tan_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(TAN(r)));  END_IF;
    -- ef_if_r : combined with ef_if
    ef_form_c :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (makec(r,s));
      END_IF;
    ef_rpart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.real_part));
      END_IF;
    ef_ipart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.imag_part));
      END_IF;
    ef_negate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(-p,-q));  END_IF;
    ef_reciprocal_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := p*p + q*q;  RETURN (makec(p/t,-q/t));
      END_IF;
    ef_add_c : BEGIN
      p := 0.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p + r;  q := q + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF p*p+q*q &lt;&gt; 0.0 THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (makec(p-r,q-s));
      END_IF;
    ef_multiply_c : BEGIN
      p := 1.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF (p &lt;&gt; 1.0) OR (q &lt;&gt; 0.0) THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := r*r+s*s;
        RETURN (makec((p*r+q*s)/t,(q*r-p*s)/t));
      END_IF;
    ef_exponentiate_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := 0.5*LOG(p*p+q*q);  u := atan2(q,p);
        p := r*t-s*u;  q := r*u+s*t;  r := EXP(p);
        RETURN (makec(r*COS(q),r*SIN(q)));
      END_IF;
    ef_exponentiate_ci :
      IF (cnlit IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        parts(v1,p,q);  k := v2;  r := 1.0;  s := 0.0;
        REPEAT i := 1 TO ABS(k);  r := p*r-q*s;  s := p*s+q*r;  END_REPEAT;
        IF k &lt; 0 THEN  t := r*r+s*s;  r := r/t;  s := -s/t;  END_IF;
        RETURN (makec(r,s));
      END_IF;
    ef_eq_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p = r) AND (q = s)));
      END_IF;
    ef_ne_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p &lt;&gt; r) OR (q &lt;&gt; s)));
      END_IF;
    ef_conjugate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(p,-q));  END_IF;
    ef_abs_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(SQRT(p*p+q*q)));
      END_IF;
    ef_arg_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(atan2(q,p)));
      END_IF;
    ef_cos_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*COS(p),(t-u)*SIN(p)));
      END_IF;
    ef_exp_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(EXP(p)*COS(q),EXP(p)*SIN(q)));
      END_IF;
    ef_ln_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(0.5*LOG(p*p+q*q),atan2(q,p)));
      END_IF;
    ef_sin_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*SIN(p),(u-t)*COS(p)));
      END_IF;
    ef_sqrt_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := SQRT(SQRT(p*p+q*q));  u := 0.5*atan2(q,p);
        RETURN (makec(t*COS(u),t*SIN(u)));
      END_IF;
    ef_tan_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := EXP(2.0*q) + EXP(-2.0*q) + 2.0*COS(2.0*p);
        RETURN (makec(2.0*SIN(2.0*p)/t,(EXP(-2.0*q)-EXP(2.0*q))/t));
      END_IF;
    -- ef_if_c : combined with ef_if
    ef_subscript_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        str := v1;  k := v2;  RETURN (ctmv(str[k]));
      END_IF;
    ef_eq_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str = st2));
      END_IF;
    ef_ne_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str &lt;&gt; st2));
      END_IF;
    ef_gt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str &gt; st2));
      END_IF;
    ef_lt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str &lt; st2));
      END_IF;
    ef_ge_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str &gt;= st2));
      END_IF;
    ef_le_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str &lt;= st2));
      END_IF;
    ef_subsequence_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        str := v1;  j := v2;  k := v3;  RETURN (ctmv(str[j:k]));
      END_IF;
    ef_concat_s : BEGIN
      str := '';
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          st2 := vlist[i];  str := str + st2;
          REMOVE (vlist, i);
        ELSE IF str &lt;&gt; '' THEN
          INSERT (vlist, ctmv(str), i);
          str := '';
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(str));  END_IF;
      IF str &lt;&gt; '' THEN  INSERT (vlist, ctmv(str), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_s :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(LENGTH(str)));  END_IF;
    ef_format :
      IF ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(FORMAT(v1,v2)));
      END_IF;
    ef_value :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(VALUE(str)));  END_IF;
    ef_like :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(v1 LIKE v2));
      END_IF;
    -- ef_if_s : combined with ef_if
    ef_subscript_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        bin := v1;  k := v2;  RETURN (ctmv(bin[k]));
      END_IF;
    ef_eq_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin = bi2));
      END_IF;
    ef_ne_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin &lt;&gt; bi2));
      END_IF;
    ef_gt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin &gt; bi2));
      END_IF;
    ef_lt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin &lt; bi2));
      END_IF;
    ef_ge_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin &gt;= bi2));
      END_IF;
    ef_le_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin &lt;= bi2));
      END_IF;
    ef_subsequence_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        bin := v1;  j := v2;  k := v3;  RETURN (ctmv(bin[j:k]));
      END_IF;
    ef_concat_b : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'BINARY' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  bi2 := vlist[i];  bin := bin + bi2;
          ELSE         bin := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        ELSE IF boo THEN
          INSERT (vlist, ctmv(bin), i);
          boo := FALSE;
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(bin));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(bin), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_b :
      IF 'BINARY' IN TYPEOF (v1) THEN  bin:=v1;  RETURN (ctmv(BLENGTH(bin)));  END_IF;
    -- ef_if_b : combined with ef_if
    ef_subscript_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  RETURN (ctmv(tpl[k]));
      END_IF;
    ef_eq_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc &lt;&gt; UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    ef_ne_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc &lt;&gt; UNKNOWN THEN  RETURN (ctmv(NOT lgc));  END_IF;
      END_IF;
    ef_concat_t : BEGIN
      tpl := [];
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          tp2 := vlist[i];  tpl := tpl + tp2;
          REMOVE (vlist, i);
        ELSE IF SIZEOF (tpl) &lt;&gt; 0 THEN
          INSERT (vlist, ctmv(tpl), i);
          tpl := [];
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF SIZEOF (tpl) &lt;&gt; 0 THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_t :
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(SIZEOF(tpl)));  END_IF;
    ef_entuple :
      RETURN (ctmv(vlist));
    ef_detuple :  -- This can have multiple outputs, but the expression only
                  -- denotes the first.
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(tpl[1]));  END_IF;
    ef_insert :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v3)) THEN
        tpl := v1;  k := v3;  INSERT (tpl, v2, k);  RETURN (ctmv(tpl));
      END_IF;
    ef_remove :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  REMOVE (tpl, k);  RETURN (ctmv(tpl));
      END_IF;
    -- ef_if_t : combined with ef_if
    ef_sum_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 0;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_product_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 1;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_add_it : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'INTEGER') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_it :
      IF ('INTEGER' IN TYPEOF (v1)) AND good_t(v2,'INTEGER') THEN
        j := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;  j := 0;
        IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_sum_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_product_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 1.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_add_rt : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'REAL') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_rt :
      IF ('REAL' IN TYPEOF (v1)) AND good_t(v2,'REAL') THEN
        r := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;  r := 0;
        IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_norm_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i]*tpl[i];  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_sum_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 0.0;  q := 0.0;
        REPEAT i:=1 TO SIZEOF (tpl);  parts(tpl[i],r,s);  p:=p+r;  q:=q+s;  END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_product_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 1.0;  q := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
        END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_add_ct : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],cnlit) THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);
              parts(tpl[j],p,q); parts(tp2[j],r,s);  tpl[j] := makec(p+r,q+s);
            END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  tpl[i] := makec(p-r,q-s);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_ct :
      IF (cnlit IN TYPEOF (v1)) AND good_t(v2,cnlit) THEN
        parts(v1,p,q);  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  tpl[i] := makec(p*r-q*s,p*s+q*r);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;  t := 0.0;  u := 0.0;
        IF SIZEOF (tpl) &lt;&gt; SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  t := t + p*r+q*s;  u := u + q*r-p*s;
        END_REPEAT;
        RETURN (makec(t,u));
      END_IF;
    ef_norm_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  parts(tpl[i],p,q);  r:=r+p*p+q*q;  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t :
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;  IF lgc THEN  RETURN (v2);  ELSE  RETURN (v3);  END_IF;
      END_IF;
    ef_ensemble :   -- (mem + vlist) effectively converts list to set
      RETURN (make_finite_space(mem + vlist));
    ef_member_of :
      IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF (v2) THEN
        lgc := member_of(v1,v2);
        IF lgc &lt;&gt; UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    END_CASE;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr,
      expr.func\quantifier_expression.variables,vlist);
    RETURN (simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF (pairs);
      IF equal_maths_values(vlist[1],pairs[i][1]) THEN
        RETURN (simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  RETURN (expr);</algorithm>
      </function>
      <function name="simplify_generic_expression">
         <parameter name="expr">
            <typename name="generic_expression"/>
         </parameter>
         <typename name="maths_value"/>
         <algorithm>FUNCTION restore_unary(expr : unary_generic_expression;
                         opnd : generic_expression) : generic_expression;
    expr.operand := opnd;
    RETURN (expr);
  END_FUNCTION;  
  FUNCTION restore_binary(expr       : binary_generic_expression;
                          opd1, opd2 : generic_expression) : generic_expression;
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
  END_FUNCTION;  
  FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                          ops  : LIST OF generic_expression) : generic_expression;
    expr.operands := ops;
    RETURN (expr);
  END_FUNCTION;  
  FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
    IF 'INTEGER' IN TYPEOF (nmb) THEN  RETURN (make_int_literal(nmb));  END_IF;
    RETURN (make_real_literal(nmb));
  END_FUNCTION;  
  LOCAL
    types : SET OF STRING := stripped_typeof (expr);
    v1, v2 : maths_value;
    vlist : LIST OF maths_value := [];
    op1, op2 : generic_expression;
    oplist : LIST OF generic_expression := [];
    opnds : LIST [2:?] OF generic_expression;
    n, m : INTEGER;
    finfun : maths_function_select;
    boo : BOOLEAN;
    str : STRING;
    nmb : NUMBER;
  END_LOCAL;
  IF 'INT_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
    RETURN (expr);  
  END_IF;
  IF 'LOGICAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types THEN
    RETURN (expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types THEN
    RETURN (expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\maths_tuple_literal.lit_value));
  END_IF;
  IF 'MATHS_SPACE' IN types THEN
    RETURN (simplify_maths_space(expr));
  END_IF;
  IF 'FUNCTION_APPLICATION' IN types THEN
    RETURN (simplify_function_application(expr));
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT (vlist, v1, i-1);
      INSERT (oplist, convert_to_operand(v1), i-1);
    END_REPEAT;
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    v1 := vlist[1];
    n := SIZEOF (vlist);
    finfun := vlist[n];
    REMOVE (vlist, n);
    REMOVE (vlist, 1);
    RETURN (make_parallel_composed_function(v1,vlist,finfun));
  END_IF;
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF NOT boo THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (ATAN(v1,v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND (
    (('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2))) OR
    (('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2))) OR
    (('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2))) ) THEN
    IF      'COMPARISON_EQUAL'         IN types THEN  boo := bool(v1 = v2);
    ELSE IF 'COMPARISON_GREATER'       IN types THEN  boo := bool(v1 &gt; v2);
    ELSE IF 'COMPARISON_GREATER_EQUAL' IN types THEN  boo := bool(v1 &gt;= v2);
    ELSE IF 'COMPARISON_LESS'          IN types THEN  boo := bool(v1 &lt; v2);
    ELSE IF 'COMPARISON_LESS_EQUAL'    IN types THEN  boo := bool(v1 &lt;= v2);
    ELSE IF 'COMPARISON_NOT_EQUAL'     IN types THEN  boo := bool(v1 &lt;&gt; v2);
    ELSE IF 'LIKE_EXPRESSION'          IN types THEN  boo := bool(v1 LIKE v2);
    ELSE  RETURN (?);  -- Unreachable
    END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;
    RETURN (convert_to_maths_value (boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types THEN
    str := '';
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF (vlist[i]) THEN
        str := vlist[i] + str;
        REMOVE (oplist, i);
      ELSE IF LENGTH(str) &gt; 0 THEN
        INSERT (oplist, make_string_literal(str), i);
        str := '';
      END_IF;  END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(str));  END_IF;
    IF LENGTH(str) &gt; 0 THEN  INSERT (oplist, make_string_literal(str), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN (convert_to_maths_value (opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (FORMAT(v1,v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    str := v1;  n := v2;
    RETURN (convert_to_maths_value (str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types THEN
    str := '';
    IF 'NUMBER'  IN TYPEOF (vlist[1]) THEN str := 'NUMBER';   END_IF;
    IF 'STRING'  IN TYPEOF (vlist[1]) THEN str := 'STRING';   END_IF;
    IF 'BOOLEAN' IN TYPEOF (vlist[1]) THEN str := 'BOOLEAN';  END_IF;
    IF (LENGTH (str) &gt; 0) AND (str IN TYPEOF (vlist[2])) AND
      (str IN TYPEOF (vlist[3])) THEN
      RETURN (convert_to_maths_value ({vlist[1] &lt;= vlist[2] &lt;= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb &lt; vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb &gt; vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types THEN
    nmb := 1;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb * vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb &lt;&gt; 1 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF (v1)) THEN
    boo := v1;
    RETURN (convert_to_maths_value (NOT(boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF boo THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types THEN
    nmb := 0;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb + vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb &lt;&gt; 0 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (vlist[1])) AND ('NUMBER' IN TYPEOF (vlist[2])) AND
    ('NUMBER' IN TYPEOF (vlist[3])) THEN
    str := vlist[1];  n := vlist[2];  m := vlist[3];
    RETURN (convert_to_maths_value (str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    nmb := v1;
    RETURN (convert_to_maths_value (-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND
    ('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_unary(expr,op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_binary(expr,op1,op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_mulary(expr,oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN (expr);</algorithm>
      </function>
      <function name="simplify_maths_space">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <typename name="maths_space"/>
         <algorithm>LOCAL
    stypes : SET OF STRING := stripped_typeof (spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint, zmin, zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF (sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF (zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint &lt; zmin THEN
            zmin := zint;
          END_IF;
          IF zint &gt; zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax-zmin+1) THEN
      RETURN (make_finite_integer_interval(zmin,zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc,spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      INSERT (zfactors, simplify_maths_space(factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc,rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint,zspc,
      spc\function_space.range_constraint,rspc));
  END_IF;
  RETURN (spc);</algorithm>
      </function>
      <function name="simplify_maths_value">
         <parameter name="val">
            <typename name="maths_value"/>
         </parameter>
         <typename name="maths_value"/>
         <algorithm>LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF (vlist);
      INSERT (nlist, simplify_maths_value(vlist[i]), i-1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);</algorithm>
      </function>
      <function name="singleton_member_of">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <typename name="maths_value"/>
         <algorithm>LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    IF SIZEOF (spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);</algorithm>
      </function>
      <function name="space_dimension">
         <parameter name="tspace">
            <typename name="tuple_space"/>
         </parameter>
         <typename name="nonnegative_integer"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (SIZEOF (tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    -- In the case of an extended_tuple_space, the minimum dimension is returned.
    RETURN (space_dimension (tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN (?);</algorithm>
      </function>
      <function name="space_is_continuum">
         <parameter name="space">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    typenames : SET OF STRING := TYPEOF (space);
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space,es_reals) OR subspace_of_es(space,es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF (factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="space_is_singleton">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (bool(SIZEOF (spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="stripped_typeof">
         <parameter name="arg">
            <builtintype type="GENERIC" typelabel="G"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <builtintype type="STRING"/>
         <algorithm>LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + [types[i][n+1:LENGTH(types[i])]];
    ELSE
       stypes := stypes + [types[i]];
    END_IF;
  END_REPEAT;
  RETURN (stypes);</algorithm>
      </function>
      <function name="subspace_of">
         <parameter name="space1">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="space2">
            <typename name="maths_space"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof (spc1);
    types2 : SET OF STRING := stripped_typeof (spc2);
    lgcl, cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1, bnd2 : REAL;
    n : INTEGER;
    sp1, sp2 : maths_space;
    prgn1, prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;
  IF NOT EXISTS (spc1) OR NOT EXISTS (spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    -- Note that the cases (spc2=the_generics) and (spc1=spc2) have been handled.
    CASE spc1\elementary_space.space_id OF
    es_numbers :  RETURN (FALSE);
    es_complex_numbers :  RETURN (es_val = es_numbers);
    es_reals :  RETURN (es_val = es_numbers);
    es_integers :  RETURN (es_val = es_numbers);
    es_logicals :  RETURN (FALSE);
    es_booleans :  RETURN (es_val = es_logicals);
    es_strings :  RETURN (FALSE);
    es_binarys :  RETURN (FALSE);
    es_maths_spaces :  RETURN (FALSE);
    es_maths_functions :  RETURN (FALSE);
    es_generics :  RETURN (FALSE);
    END_CASE;
    -- Should be unreachable.
    RETURN (UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of (i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min&gt;=spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max &lt;= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      IF min_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min (spc2);
        IF (bnd1 &lt; bnd2) OR ((bnd1 = bnd2) AND min_included (spc1) AND NOT
          min_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max (spc2);
        IF (bnd1 &gt; bnd2) OR ((bnd1 = bnd2) AND max_included (spc1) AND NOT
          max_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 &lt; bnd1) OR ((bnd2 = bnd1) AND (min_included (spc2) OR
        NOT min_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 &gt; bnd1) OR ((bnd2 = bnd1) AND (max_included (spc2) OR
        NOT max_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,
        spc2\cartesian_complex_number_region.real_constraint) AND
        subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
        spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1,
        spc2\polar_complex_number_region.centre),spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1),spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max &gt; PI THEN
          aitv := make_finite_real_interval(-PI,open,prgn2.direction_constraint.max
            -2.0*PI,prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND (subspace_of(prgn1.direction_constraint,prgn2.direction_constraint)
              OR subspace_of(prgn1.direction_constraint,aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND subspace_of(prgn1.direction_constraint,prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,prgn2.centre),prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF (spc1\finite_space.members);
      cum := cum AND member_of (spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1 THEN
    IF 'PRODUCT_SPACE' IN types2 THEN
      IF space_dimension (spc1) = space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF space_dimension (spc1) &gt;= space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      n := space_dimension (spc1);
      IF n &lt; space_dimension (spc2) THEN
        n := space_dimension (spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n+1;
        cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND (subspace_of (sp1, sp2));
        END_CASE;
        END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND subspace_of (sp1, sp2);
        END_CASE;
        END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);</algorithm>
      </function>
      <function name="subspace_of_es">
         <parameter name="spc">
            <typename name="maths_space"/>
         </parameter>
         <parameter name="es">
            <typename name="elementary_space_enumerators"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;
  IF NOT EXISTS (spc) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  IF 'ELEMENTARY_SPACE' IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id,es));
  END_IF;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members,es));
  END_IF;
  CASE es OF
  es_numbers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) OR
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) OR
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_complex_numbers : RETURN (
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_reals : RETURN (
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) );
  es_integers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) );
  es_logicals : RETURN (FALSE);
  es_booleans : RETURN (FALSE);
  es_strings : RETURN (FALSE);
  es_binarys : RETURN (FALSE);
  es_maths_spaces : RETURN (FALSE);
  es_maths_functions : RETURN ('FUNCTION_SPACE' IN types);
  es_generics : RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);</algorithm>
      </function>
      <function name="substitute">
         <parameter name="expr">
            <typename name="generic_expression"/>
         </parameter>
         <parameter name="vars">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="generic_variable"/>
         </parameter>
         <parameter name="vals">
            <aggregate lower="1" type="LIST" upper="?"/>
            <typename name="maths_value"/>
         </parameter>
         <typename name="generic_expression"/>
         <algorithm>LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1, op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;
  IF SIZEOF (vars) &lt;&gt; SIZEOF (vals) THEN  RETURN (?);  END_IF;
  IF 'GENERIC_LITERAL' IN types THEN  RETURN (expr);  END_IF;
  IF 'GENERIC_VARIABLE' IN types THEN
    REPEAT i := 1 TO SIZEOF (vars);
      IF expr :=: vars[i] THEN  RETURN (vals[i]);  END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types THEN
    qvars := expr\quantifier_expression.variables;
    -- Variables subject to a quantifier do not participate in this kind of
    -- substitution process.
    REPEAT i := SIZEOF (vars) TO 1 BY -1;
      IF vars[i] IN qvars THEN
        REMOVE (vars, i);
        REMOVE (vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] :=
          substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of quantifier_expression
        -- which derive their operands from other attributes!
      END_IF;
    END_REPEAT;
    RETURN (expr);  -- operands modified!
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
    -- This technique will not work on subtypes of unary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
    -- This technique will not work on subtypes of binary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    -- Subtype of multiple_arity_generic_expression which derives its operands.
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom,vars,vals);
    REPEAT i := 1 TO SIZEOF (prpfun);
      prpfun[i] := substitute(prpfun[i],vars,vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun,vars,vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom,prpfun,finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      expr\multiple_arity_generic_expression.operands[i] :=
        substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of multiple_arity_generic_
        -- expression which derive their operands from other attributes!
    END_REPEAT;
  END_IF;
  RETURN (expr);</algorithm>
      </function>
      <function name="surface_condition_correlation">
         <parameter name="pd">
            <typename name="property_definition"/>
         </parameter>
         <parameter name="rep">
            <typename name="representation"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>CASE pd.name OF
      'visual appearance', 'tactile appearance', 'contact ratio', 'hardness', 'treatment result', 'surface texture' : 
	  RETURN(pd.name = rep.name);
      OTHERWISE : RETURN(UNKNOWN);
    END_CASE;</algorithm>
      </function>
      <function name="surface_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] &lt;= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="temporal_spatial_domain_for_model">
         <parameter name="domain">
            <typename name="numerical_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      spatial_set : SET OF spatial_decomposition_of_numerical_model;
      behavioural_set : SET OF behavioural_decomposition_of_numerical_model;
      domains : SET OF numerical_model := [];
      viewing : BAG OF view_relationship;
      spatial_bag : BAG OF spatial_decomposition_of_numerical_model;
      behavioural_bag : BAG OF behavioural_decomposition_of_numerical_model;
    END_LOCAL;

    viewing := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VIEW_RELATIONSHIP.VIEW');
    IF SIZEOF(viewing) &gt; 0 THEN
      RETURN (TRUE);
    END_IF;
    spatial_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SPATIAL_DECOMPOSITION_OF_NUMERICAL_MODEL.PARTS');
    IF SIZEOF(spatial_bag) &gt; 0 THEN
      spatial_set := bag_to_set(spatial_bag);
      REPEAT i := 1 TO HIINDEX(spatial_set);
        domains := domains + spatial_set[i].whole;
      END_REPEAT;
    END_IF;
    behavioural_bag := USEDIN(domain, 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.BEHAVIOURAL_DECOMPOSITION_OF_NUMERICAL_MODEL.PARTS');
    IF SIZEOF(behavioural_bag) &gt; 0 THEN
      behavioural_set := bag_to_set(behavioural_bag);
      REPEAT i := 1 TO HIINDEX(behavioural_set);
        domains := domains + behavioural_set[i].whole;
      END_REPEAT;
    END_IF;
    IF SIZEOF(domains) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(domains);
        IF temporal_spatial_domain_for_model(domains[i]) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (FALSE);</algorithm>
      </function>
      <function name="topology_reversed">
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);</algorithm>
      </function>
      <function name="type_check_function">
         <parameter name="the_type">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="sub_names">
            <aggregate lower="0" type="SET" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <parameter name="criterion">
            <builtintype type="INTEGER"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>IF ((NOT EXISTS(the_type)) OR (NOT ({0 &lt;= criterion &lt;= 3})) OR (SIZEOF(sub_names) = 0)) THEN
      RETURN (UNKNOWN);
    ELSE
      CASE criterion OF 
        0:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) &gt; 0);
        1:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 0);
        2:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 1);
        3:
          RETURN (SIZEOF(sub_names * TYPEOF(the_type)) &lt;= 1);
      END_CASE;
    END_IF;</algorithm>
      </function>
      <function name="using_items">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <parameter name="checked_items">
            <aggregate lower="0" type="SET" upper="?"/>
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="founded_item_select"/>
         <algorithm>LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z &lt;* bag_to_set( USEDIN(item , '')) |
      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) &gt; 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);</algorithm>
      </function>
      <function name="using_representations">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate lower="0" type="SET" upper="?"/>
         <typename name="representation"/>
         <algorithm>LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) &gt; 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) &gt; 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);</algorithm>
      </function>
      <function name="valid_basis_curve_in_2d_wireframe">
         <parameter name="crv">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE',
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE',
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE',
               'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE'] * 
               TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE') 
    IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE',
                   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARABOLA',
                   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);
      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_2D') 
      IN TYPEOF (crv))
        THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\offset_curve_2d.basis_curve));
      ELSE
        -- recursively check the curve_replica parent curve
        IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\curve_replica.parent_curve));
        ELSE
          -- recursively check the composite_curve segments
          IF (('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE') 
          IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs &lt;* crv\composite_curve.segments |
                      NOT (valid_basis_curve_in_2d_wireframe
                             (ccs.parent_curve)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_calendar_date">
         <parameter name="date">
            <typename name="calendar_date"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>CASE date.month_component OF
    1  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 &lt;= date.day_component &lt;= 29 });
           ELSE
             RETURN({ 1 &lt;= date.day_component &lt;= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    4  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    5  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    6  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    7  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    8  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    9  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    10 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    11 : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    12 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
  END_CASE;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_datum_target_parameters">
         <parameter name="pdf">
            <typename name="placed_datum_target_feature"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

rep_set : SET OF representation := [] ;

parameter_representations: SET OF representation;
END_LOCAL;


REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
rep_set := rep_set + pdf.representation_associations[i].used_representation;
END_REPEAT;
 
parameter_representations := QUERY(rep &lt;* rep_set |
('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
TYPEOF(rep)));


IF (SIZEOF( QUERY( srwp &lt;* parameter_representations |
          (SIZEOF( QUERY( i &lt;* srwp.items |
          (i.name='orientation') AND
          ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLACEMENT' IN TYPEOF(i)))) = 1))) &lt;&gt; 1) THEN
   RETURN(FALSE);
END_IF;

CASE pdf\shape_aspect.description OF
'point': RETURN(SIZEOF(QUERY( srwp &lt;* parameter_representations |
              (SIZEOF(srwp.items) = 1))) = 1);

'circle': RETURN((SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF(srwp.items) = 2))) = 1) AND
             (SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF( QUERY( i &lt;* srwp.items |
                (i.name='target diameter') AND
                (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		   'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1));

'line': RETURN(SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF( QUERY( i &lt;* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1);

'rectangle': RETURN((SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF(srwp.items)= 3))) = 1) AND
             (SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF( QUERY( i &lt;* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2))) = 1))) = 1) AND
              (SIZEOF( QUERY( srwp &lt;* parameter_representations |
               (SIZEOF( QUERY( i &lt;* srwp.items |
                 (i.name='target width') AND
                 (SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM',
 		'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                  ) = 2))) = 1) )) = 1));
OTHERWISE : RETURN(FALSE);
END_CASE;</algorithm>
      </function>
      <function name="valid_geometrically_bounded_wf_curve">
         <parameter name="crv">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELLIPSE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CIRCLE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TRIMMED_CURVE' IN TYPEOF (crv) THEN 
 IF SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PARABOLA', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.HYPERBOLA' ] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 RETURN (valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve));
 END_IF ;
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.COMPOSITE_CURVE' IN TYPEOF (crv) THEN 
 RETURN ( SIZEOF ( 
QUERY ( ccs &lt;* crv\composite_curve.segments| NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve) )) = 0);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_geometrically_bounded_wf_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_ON_CURVE' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_measure_value">
         <parameter name="m">
            <typename name="measure_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m &gt; 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m &gt; 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;</algorithm>
      </function>
      <function name="valid_parametric_coordinate">
         <parameter name="coordinates">
            <aggregate lower="1" type="LIST" upper="3"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      i                     : INTEGER;
    END_LOCAL; 

    REPEAT i:=1 TO HIINDEX(coordinates);
      IF ((1.0 &lt; coordinates[i]) OR (coordinates[i] &lt; -1.0)) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;

    RETURN (TRUE);</algorithm>
      </function>
      <function name="valid_selected_instance_representation">
         <parameter name="pd">
            <typename name="product_definition_or_assembly_relationship"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      properties: SET OF property_definition := bag_to_set(QUERY( prd&lt;* USEDIN ( pd ,'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROPERTY_DEFINITION.DEFINITION' ) | 
        (prd.name = 'occurrence selection' )));
      property_definition_representations: SET OF property_definition_representation := bag_to_set(QUERY ( pdr &lt;* USEDIN ( properties[1] , 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	    ( pdr.used_representation.name = 'selection criteria' )));
      selected_representation: representation;
    END_LOCAL;
    IF (SIZEOF( properties)&lt;&gt;1) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF(property_definition_representations)&lt;&gt;1) THEN
	  RETURN(FALSE);
    END_IF;
    selected_representation := property_definition_representations[1]\property_definition_representation.used_representation;
    IF (SIZEOF(selected_representation\representation.items) &lt;1) OR (SIZEOF(selected_representation\representation.items) &gt;2) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
	  ( SIZEOF (['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' ,
      'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
      ( i.name = 'selection quantity' ))) &lt;&gt; 1 ) THEN
      RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
	  ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	  ( i.name = 'selection control' )))&gt; 1) THEN
	  RETURN(FALSE);
    END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
    IF (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
      ( 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
      ( i.name = 'selection control' ) ))= 0) AND 
      (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.QUALIFIED_REPRESENTATION_ITEM' ,
      'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) &gt; 0 ) THEN
	  RETURN(FALSE);
    END_IF;
    RETURN(TRUE);</algorithm>
      </function>
      <function name="valid_time">
         <parameter name="time">
            <typename name="local_time"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;</algorithm>
      </function>
      <function name="valid_units">
         <parameter name="m">
            <typename name="measure_with_unit"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ACCELERATION_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( -2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
            dimensional_exponents( -2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
            dimensional_exponents( 2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;    
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ENERGY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FORCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.FREQUENCY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POWER_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.PRESSURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( -1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RESISTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VELOCITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) &lt;&gt; 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="valid_wireframe_edge_curve">
         <parameter name="crv">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF SIZEOF ([ 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.LINE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CONIC', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.B_SPLINE_CURVE', 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POLYLINE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_wireframe_vertex_point">
         <parameter name="pnt">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 RETURN (FALSE);</algorithm>
      </function>
      <function name="validate_countersink_radii">
         <parameter name="cskhole">
            <typename name="solid_with_stepped_round_hole_and_conical_transitions"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    i,j             : INTEGER;
    n               : INTEGER := 1 +
                        cskhole\solid_with_stepped_round_hole.segments;
    smaller, larger : positive_length_measure;
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(cskhole.conical_transitions);

  -- First check whether transition i applies to the entry of the hole or 
  -- the exit of a through hole - those cases only need to be checked for 
  -- the sign of the cone apex angle.

  IF (((cskhole.conical_transitions[i].transition_number = 1)
       AND (cskhole.conical_transitions[i].cone_apex_angle &lt; 0))
    XOR ((cskhole.conical_transitions[i].transition_number = n)
         AND (cskhole.conical_transitions[i].cone_apex_angle &gt; 0))) 
  THEN RETURN(FALSE); 
  ELSE
    IF ((cskhole.conical_transitions[i].transition_number &lt;&gt; 1)
      AND (cskhole.conical_transitions[i].transition_number &lt;&gt; n))
    THEN

  -- For all remaining transitions, check that the cone base radius 
  -- lies in the range of validity.


      BEGIN
        j := cskhole.conical_transitions[i].transition_number;
        IF cskhole\solid_with_stepped_round_hole.segment_radii[j] 
          &gt; cskhole\solid_with_stepped_round_hole.segment_radii[j-1]
        THEN 
          BEGIN
            IF (cskhole.conical_transitions[i].cone_apex_angle &gt; 0)
            THEN RETURN(FALSE);
            END_IF;
            larger 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j];
            smaller 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j-1];
          END;
        ELSE
          BEGIN
            IF (cskhole.conical_transitions[i].cone_apex_angle &lt; 0)
            THEN RETURN(FALSE);
            END_IF;
            larger  
              := cskhole\solid_with_stepped_round_hole.segment_radii[j-1];
            smaller 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j];
          END;
        END_IF; 
        IF ((cskhole.conical_transitions[i].cone_base_radius &gt; larger)
          OR (cskhole.conical_transitions[i].cone_base_radius &lt; smaller))
        THEN RETURN(FALSE);
        END_IF;
      END;
    END_IF;
  END_IF;
  END_REPEAT;
  RETURN(TRUE);</algorithm>
      </function>
      <function name="value_range_aggregate_rep_item">
         <parameter name="agg">
            <aggregate type="AGGREGATE"/>
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
  IF (SIZEOF(QUERY(i1 &lt;* agg | ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) )) = 6) THEN 
	  RETURN (TRUE); 
   ELSE 
	RETURN (FALSE); 
   END_IF; 
   END;</algorithm>
      </function>
      <function name="value_range_wr1">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
      IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 &lt;* agg | (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
        (i1)))) = 2) OR
        (SIZEOF(QUERY (i2 &lt;* agg | (
        'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF
        (i2)))) = 2)) 
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;</algorithm>
      </function>
      <function name="value_range_wr2">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
      IF ((SIZEOF(QUERY (i &lt;* agg | (i\representation_item.name = 'upper limit'))) = 1)
        AND (SIZEOF(QUERY (i &lt;* agg | (i\representation_item.name = 'lower limit'))) = 1))
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;</algorithm>
      </function>
      <function name="value_range_wr3">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
      IF (SIZEOF(QUERY(i1 &lt;* agg |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
        (SIZEOF (QUERY (i2 &lt;* agg |
        ('AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
        (i1 :&lt;&gt;: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
      THEN
        RETURN (TRUE);
      ELSE
        RETURN (FALSE);
      END_IF;
    END;</algorithm>
      </function>
      <function name="values_space_of">
         <parameter name="expr">
            <typename name="generic_expression"/>
         </parameter>
         <typename name="maths_space"/>
         <algorithm>LOCAL
    e_prefix : STRING := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    typenames : SET OF STRING := TYPEOF (expr);
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);  -- unknown subtype of expression
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      RETURN (make_function_space (sc_equal, expr\maths_function.domain,
        sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      -- This case cannot occur in this version of the schema.
      -- When it becomes possible, the subtypes should be analysed and
      -- more finely defined spaces returned.
      RETURN (make_elementary_space (es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames THEN
    RETURN (values_space_of (expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);</algorithm>
      </function>
      <function name="variable_value_type">
         <parameter name="variable">
            <builtintype type="GENERIC"/>
         </parameter>
         <builtintype type="STRING"/>
         <algorithm>LOCAL
     svt                    : STRING;
     feacr                  : STRING;
     variable_typeof        : SET [1:?] OF STRING;
    END_LOCAL;
        
    svt     := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    feacr   := 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.';
    variable_typeof := TYPEOF (variable);

    IF SIZEOF ([(feacr + 'CURVE_SCALAR_VARIABLE'),
                (feacr + 'SURFACE_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_SCALAR_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_SCALAR_VARIABLE'),
                (feacr + 'AGGREGATED_SCALAR_VARIABLE'),
                (feacr + 'VOLUME_ANGULAR_VARIABLE'),
                (feacr + 'AGGREGATED_ANGULAR_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_SCALAR_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SCALAR');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_2D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_2D');
    END_IF;

    IF SIZEOF ([(feacr + 'CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'VOLUME_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_CURVE_VECTOR_3D_VARIABLE'),
                (feacr + 'BOUNDARY_SURFACE_VECTOR_3D_VARIABLE'),
                (feacr + 'AGGREGATED_VECTOR_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_VECTOR_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'TENSOR1_3D');
    END_IF;

    IF SIZEOF ([(feacr + 'SURFACE_TENSOR2_2D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_2D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;

    IF SIZEOF ([(feacr + 'VOLUME_TENSOR2_3D_VARIABLE'),
                (feacr + 'AGGREGATED_TENSOR2_3D_VARIABLE'),
                (feacr + 'APPLICATION_DEFINED_TENSOR2_3D_VARIABLE')] *
               variable_typeof ) = 1 THEN
        RETURN (svt + 'SYMMETRIC_TENSOR2_3D');
    END_IF;

    RETURN ('NO_MATCH');</algorithm>
      </function>
      <function name="vector_difference">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
      result          : vector;
      res, vec1, vec2 : direction;
      mag, mag1, mag2 : REAL;
      ndim            : INTEGER;
    END_LOCAL;
 
    IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
        THEN
      RETURN (?) ;
     ELSE
      BEGIN
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1.magnitude;
          vec1 := arg1\vector.orientation;
        ELSE
          mag1 := 1.0;
          vec1 := arg1;
        END_IF;
        IF 'AP209_MULTIDISCIPLINARY_ANALYSIS_AND_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2.magnitude;
          vec2 := arg2\vector.orientation;
        ELSE
          mag2 := 1.0;
          vec2 := arg2;
        END_IF;
        vec1 := normalise (vec1);
        vec2 := normalise (vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0.0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim;
          res.direction_ratios[i] := mag1*vec1.direction_ratios[i] -
                                      mag2*vec2.direction_ratios[i];
          mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
        END_REPEAT;
        IF (mag &gt; 0.0 ) THEN
        result := dummy_gri || vector( res, SQRT(mag));
        ELSE
          result := dummy_gri || vector( vec1,  0.0);
        END_IF;
      END;
    END_IF;
    RETURN (result);</algorithm>
      </function>
   </schema>
</express>
