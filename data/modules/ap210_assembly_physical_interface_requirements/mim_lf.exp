SCHEMA ap210_assembly_physical_interface_requirements_mim_lf;

CONSTANT
	dummy_gri : geometric_representation_item :=  representation_item('')|| geometric_representation_item();


	base_types : SET [0:?] OF STRING :=  [ 'NUMBER', 'COMPLEX_NUMBER_LITERAL', 'REAL', 'INTEGER', 'LOGICAL', 'BOOLEAN', 'STRING', 'BINARY', 'MATHS_SPACE', 'MATHS_FUNCTION', 'LIST', 'ELEMENTARY_SPACE_ENUMERATORS', 'ORDERING_TYPE', 'LOWER_UPPER', 'SYMMETRY_TYPE', 'ELEMENTARY_FUNCTION_ENUMERATORS', 'OPEN_CLOSED', 'SPACE_CONSTRAINT_TYPE', 'REPACKAGE_OPTIONS', 'EXTENSION_OPTIONS' ] ;


	cnlit : STRING :=  schema_prefix + 'COMPLEX_NUMBER_LITERAL' ;


	schema_prefix : STRING :=  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' ;


	the_binarys : elementary_space :=  make_elementary_space(es_binarys);


	the_booleans : elementary_space :=  make_elementary_space(es_booleans);


	the_complex_numbers : elementary_space :=  make_elementary_space(es_complex_numbers);


	the_complex_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_complex_numbers);


	the_empty_atom_based_tuple : atom_based_tuple :=  [ ] ;


	the_empty_atom_based_value : atom_based_value :=  the_empty_atom_based_tuple ;


	the_empty_maths_tuple : maths_tuple :=  [ ] ;


	the_empty_maths_value : maths_value :=  the_empty_maths_tuple ;


	the_empty_space : finite_space :=  make_finite_space([ ]);


	the_generics : elementary_space :=  make_elementary_space(es_generics);


	the_integer_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_integers);


	the_integers : elementary_space :=  make_elementary_space(es_integers);


	the_logicals : elementary_space :=  make_elementary_space(es_logicals);


	the_maths_spaces : elementary_space :=  make_elementary_space(es_maths_spaces);


	the_neg1_one_interval : finite_real_interval :=  make_finite_real_interval(- 1.0, closed, 1.0, closed);


	the_neghalfpi_halfpi_interval : finite_real_interval :=  make_finite_real_interval(- 0.5 * PI , closed, 0.5 * PI, closed);


	the_negpi_pi_interval : finite_real_interval :=  make_finite_real_interval(- PI , open, PI, closed);


	the_nonnegative_reals : real_interval_from_min :=  make_real_interval_from_min(0.0, closed);


	the_numbers : elementary_space :=  make_elementary_space(es_numbers);


	the_real_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_reals);


	the_reals : elementary_space :=  make_elementary_space(es_reals);


	the_strings : elementary_space :=  make_elementary_space(es_strings);


	the_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_generics);


	the_zero_one_interval : finite_real_interval :=  make_finite_real_interval(0.0, closed, 1.0, closed);


	the_zero_pi_interval : finite_real_interval :=  make_finite_real_interval(0.0, closed, PI, closed);


	the_zero_tuple_space : listed_product_space :=  make_listed_product_space([ ]);


	dummy_tri : topological_representation_item :=  representation_item('')|| topological_representation_item();



END_CONSTANT;

TYPE supported_item = SELECT (
	action,
	action_directive,
	action_method);
END_TYPE; -- supported_item

TYPE action_items = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- action_items

TYPE aliasable_item = EXTENSIBLE SELECT ;
END_TYPE; -- aliasable_item

TYPE ap_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	package_terminal);
END_TYPE; -- ap_document_reference_item

TYPE pdm_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH (
	product_definition_formation);
END_TYPE; -- pdm_action_items

TYPE pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH (
	action,
	action_directive,
	certification,
	configuration_effectivity,
	configuration_item,
	contract,
	date,
	directed_action,
	document,
	general_property_relationship,
	product,
	product_definition,
	product_definition_relationship,
	product_definition_formation,
	representation,
	security_classification,
	shape_aspect_relationship,
	versioned_action_request);
END_TYPE; -- pdm_approval_item

TYPE pdm_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH (
	supplied_part_relationship,
	make_from_usage_option);
END_TYPE; -- pdm_certification_item

TYPE pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	material_designation);
END_TYPE; -- pdm_classification_item

TYPE pdm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH (
	alternate_product_relationship,
	directed_action,
	product,
	product_definition_formation);
END_TYPE; -- pdm_contract_item

TYPE pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	approval_person_organization,
	certification,
	contract,
	directed_action,
	document,
	product_definition,
	security_classification,
	versioned_action_request);
END_TYPE; -- pdm_date_and_time_item

TYPE pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	product_definition,
	versioned_action_request,
	directed_action,
	approval_person_organization,
	contract,
	document,
	security_classification,
	certification);
END_TYPE; -- pdm_date_item

TYPE pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	action_method,
	assembly_component_usage,
	characterized_object,
	coordinated_representation_item,
	configuration_item,
	descriptive_representation_item,
	externally_defined_item,
	material_designation,
	measure_representation_item,
	product,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	property_definition,
	representation,
	representation_item,
	shape_aspect);
END_TYPE; -- pdm_document_reference_item

TYPE pdm_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH (
	organizational_project);
END_TYPE; -- pdm_event_occurrence_item

TYPE pdm_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	product_definition,
	product_definition_formation,
	property_definition_representation,
	representation,
	representation_item,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- pdm_groupable_item

TYPE pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
	characterized_class,
	configuration_item,
	material_designation,
	person_and_organization,
	product,
	product_concept,
	product_definition_formation,
	organization);
END_TYPE; -- pdm_identification_item

TYPE pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH (
	applied_identification_assignment,
	configuration_item,
	contract,
	directed_action,
	document,
	versioned_action_request,
	product,
	product_definition,
	product_definition_formation,
	representation,
	security_classification);
END_TYPE; -- pdm_organization_item

TYPE pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH (
	configuration_item,
	contract,
	document,
	product,
	product_definition_formation,
	product_definition,
	directed_action,
	security_classification,
	versioned_action_request);
END_TYPE; -- pdm_person_and_organization_item

TYPE pdm_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH (
	descriptive_representation_item,
	configuration_item,
	product_definition,
	product_definition_formation,
	product,
	shape_aspect,
	representation);
END_TYPE; -- pdm_requirement_assigned_item

TYPE pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH (
	applied_promissory_usage_in_product_model_assignment,
	assembly_component_usage,
	document,
	make_from_usage_option,
	product_definition_formation,
	product_definition);
END_TYPE; -- pdm_security_classification_item

TYPE promissory_usage_in_product_model_assigned_item = SELECT (
	product_concept,
	product_definition);
END_TYPE; -- promissory_usage_in_product_model_assigned_item

TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- approval_item

TYPE date_and_time_item_approval = SELECT BASED_ON date_and_time_item WITH (
	approval_person_organization);
END_TYPE; -- date_and_time_item_approval

TYPE date_item_approval = SELECT BASED_ON date_item WITH (
	approval_person_organization);
END_TYPE; -- date_item_approval

TYPE description_attribute_select = SELECT (
	action_request_solution,
	application_context,
	approval_role,
	configuration_design,
	context_dependent_shape_representation,
	date_role,
	date_time_role,
	effectivity,
	external_source,
	organization_role,
	person_and_organization,
	person_and_organization_role,
	person_role,
	property_definition_representation,
	representation,
	time_role);
END_TYPE; -- description_attribute_select

TYPE id_attribute_select = SELECT (
	action,
	address,
	application_context,
	group,
	organizational_project,
	product_category,
	property_definition,
	representation,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- id_attribute_select

TYPE name_attribute_select = SELECT (
	action_request_solution,
	address,
	configuration_design,
	context_dependent_shape_representation,
	derived_unit,
	effectivity,
	person_and_organization,
	product_definition,
	product_definition_substitute,
	property_definition_representation);
END_TYPE; -- name_attribute_select

TYPE role_select = SELECT (
	action_assignment,
	action_request_assignment,
	approval_assignment,
	approval_date_time,
	certification_assignment,
	contract_assignment,
	document_reference,
	effectivity_assignment,
	external_referent_assignment,
	group_assignment,
	name_assignment,
	security_classification_assignment);
END_TYPE; -- role_select

TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- certification_item

TYPE c_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	coordinated_representation_item);
END_TYPE; -- c_document_reference_item

TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- classification_item

TYPE classification_select = EXTENSIBLE SELECT ;
END_TYPE; -- classification_select

TYPE complete_membership_select = EXTENSIBLE SELECT ;
END_TYPE; -- complete_membership_select

TYPE class_system_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	characterized_class);
END_TYPE; -- class_system_item

TYPE classification_classification_item = EXTENSIBLE SELECT BASED_ON classification_item WITH (
	class);
END_TYPE; -- classification_classification_item

TYPE classification_identification_item = EXTENSIBLE SELECT BASED_ON identification_item WITH (
	class);
END_TYPE; -- classification_identification_item

TYPE classification_item_extended = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	characterized_class,
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- classification_item_extended

TYPE classified_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- classified_item

TYPE id_for_class = SELECT BASED_ON identification_item WITH (
	characterized_class);
END_TYPE; -- id_for_class

TYPE version_for_class = SELECT BASED_ON versionable_item WITH (
	characterized_class);
END_TYPE; -- version_for_class

TYPE configuration_design_item = SELECT (
	product_definition,
	product_definition_formation);
END_TYPE; -- configuration_design_item

TYPE contract_item = EXTENSIBLE SELECT ;
END_TYPE; -- contract_item

TYPE date_and_time_item = EXTENSIBLE SELECT ;
END_TYPE; -- date_and_time_item

TYPE date_item = EXTENSIBLE SELECT ;
END_TYPE; -- date_item

TYPE ahead_or_behind = ENUMERATION OF (
	ahead,
	exact,
	behind );
END_TYPE; -- ahead_or_behind

TYPE date_time_or_event_occurrence = SELECT (
	date_time_select,
	event_occurrence);
END_TYPE; -- date_time_or_event_occurrence

TYPE date_time_select = SELECT (
	date,
	date_and_time,
	local_time);
END_TYPE; -- date_time_select

TYPE day_in_month_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 31 } ;
END_TYPE; -- day_in_month_number

TYPE day_in_week_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 7 } ;
END_TYPE; -- day_in_week_number

TYPE day_in_year_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 366 } ;
END_TYPE; -- day_in_year_number

TYPE hour_in_day = INTEGER;
WHERE
	WR1 :  { 0 <= SELF < 24 } ;
END_TYPE; -- hour_in_day

TYPE minute_in_hour = INTEGER;
WHERE
	WR1 :  { 0 <= SELF <= 59 } ;
END_TYPE; -- minute_in_hour

TYPE month_in_year_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 12 } ;
END_TYPE; -- month_in_year_number

TYPE second_in_minute = REAL;
WHERE
	WR1 :  { 0 <= SELF <= 60.0 } ;
END_TYPE; -- second_in_minute

TYPE week_in_year_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 53 } ;
END_TYPE; -- week_in_year_number

TYPE year_number = INTEGER;
END_TYPE; -- year_number

TYPE managed_design_object = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- managed_design_object

TYPE dimension_identification_item = SELECT BASED_ON identification_item WITH (
	dimensional_size);
END_TYPE; -- dimension_identification_item

TYPE dimension_tolerance_document_reference_item = SELECT BASED_ON document_reference_item WITH (
	dimensional_size,
	externally_defined_dimension_definition);
END_TYPE; -- dimension_tolerance_document_reference_item

TYPE document_reference_item = EXTENSIBLE SELECT ;
END_TYPE; -- document_reference_item

TYPE document_location_select = SELECT BASED_ON external_identification_item WITH (
	product_definition);
END_TYPE; -- document_location_select

TYPE product_or_formation_or_definition = SELECT (
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- product_or_formation_or_definition

TYPE effectivity_item = EXTENSIBLE SELECT ;
END_TYPE; -- effectivity_item

TYPE representation_identification_item = SELECT BASED_ON identification_item WITH (
	shape_representation);
END_TYPE; -- representation_identification_item

TYPE representation_version_item = SELECT BASED_ON versionable_item WITH (
	shape_representation);
END_TYPE; -- representation_version_item

TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- event_occurrence_item

TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	event_occurrence);
END_TYPE; -- event_occurrence_date_and_time_item

TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	event_occurrence);
END_TYPE; -- event_occurrence_date_item

TYPE external_class_name_item = SELECT BASED_ON name_item WITH (
	external_class_library);
END_TYPE; -- external_class_name_item

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- external_identification_item

TYPE message = STRING;
END_TYPE; -- message

TYPE source_item = SELECT (
	identifier,
	message);
END_TYPE; -- source_item

TYPE file_identification_item = SELECT BASED_ON identification_item WITH (
	document_file);
END_TYPE; -- file_identification_item

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH (
	document_file);
END_TYPE; -- file_location_select

TYPE file_version_item = SELECT BASED_ON versionable_item WITH (
	document_file);
END_TYPE; -- file_version_item

TYPE fde_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	physical_connectivity_definition,
	physical_connectivity_element);
END_TYPE; -- fde_document_reference_item

TYPE boolean_operand = SELECT (
	solid_model,
	half_space_solid,
	csg_primitive,
	boolean_result,
	half_space_2d);
END_TYPE; -- boolean_operand

TYPE boolean_operator = ENUMERATION OF (
	union,
	intersection,
	difference );
END_TYPE; -- boolean_operator

TYPE csg_primitive = SELECT (
	sphere,
	ellipsoid,
	block,
	right_angular_wedge,
	faceted_primitive,
	rectangular_pyramid,
	torus,
	right_circular_cone,
	eccentric_cone,
	right_circular_cylinder,
	cyclide_segment_solid,
	primitive_2d);
END_TYPE; -- csg_primitive

TYPE csg_select = SELECT (
	boolean_result,
	csg_primitive);
END_TYPE; -- csg_select

TYPE geometric_set_select = SELECT (
	point,
	curve,
	surface);
END_TYPE; -- geometric_set_select

TYPE surface_model = SELECT (
	shell_based_surface_model,
	face_based_surface_model);
END_TYPE; -- surface_model

TYPE wireframe_model = SELECT (
	shell_based_wireframe_model,
	edge_based_wireframe_model);
END_TYPE; -- wireframe_model

TYPE axis2_placement = SELECT (
	axis2_placement_2d,
	axis2_placement_3d);
END_TYPE; -- axis2_placement

TYPE b_spline_curve_form = ENUMERATION OF (
	polyline_form,
	circular_arc,
	elliptic_arc,
	parabolic_arc,
	hyperbolic_arc,
	unspecified );
END_TYPE; -- b_spline_curve_form

TYPE b_spline_surface_form = ENUMERATION OF (
	plane_surf,
	cylindrical_surf,
	conical_surf,
	spherical_surf,
	toroidal_surf,
	surf_of_revolution,
	ruled_surf,
	generalised_cone,
	quadric_surf,
	surf_of_linear_extrusion,
	unspecified );
END_TYPE; -- b_spline_surface_form

TYPE curve_on_surface = SELECT (
	pcurve,
	surface_curve,
	composite_curve_on_surface);
END_TYPE; -- curve_on_surface

TYPE dimension_count = INTEGER;
WHERE
	WR1 :  SELF > 0 ;
END_TYPE; -- dimension_count

TYPE extent_enumeration = ENUMERATION OF (
	invalid,
	zero,
	finite_non_zero,
	infinite );
END_TYPE; -- extent_enumeration

TYPE knot_type = ENUMERATION OF (
	uniform_knots,
	quasi_uniform_knots,
	piecewise_bezier_knots,
	unspecified );
END_TYPE; -- knot_type

TYPE pcurve_or_surface = SELECT (
	pcurve,
	surface);
END_TYPE; -- pcurve_or_surface

TYPE preferred_surface_curve_representation = ENUMERATION OF (
	curve_3d,
	pcurve_s1,
	pcurve_s2 );
END_TYPE; -- preferred_surface_curve_representation

TYPE surface_boundary = SELECT (
	boundary_curve,
	degenerate_pcurve);
END_TYPE; -- surface_boundary

TYPE transition_code = ENUMERATION OF (
	discontinuous,
	continuous,
	cont_same_gradient,
	cont_same_gradient_same_curvature );
END_TYPE; -- transition_code

TYPE trimming_preference = ENUMERATION OF (
	cartesian,
	parameter,
	unspecified );
END_TYPE; -- trimming_preference

TYPE trimming_select = SELECT (
	cartesian_point,
	parameter_value);
END_TYPE; -- trimming_select

TYPE vector_or_direction = SELECT (
	vector,
	direction);
END_TYPE; -- vector_or_direction

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE; -- groupable_item

TYPE identification_item = EXTENSIBLE SELECT ;
END_TYPE; -- identification_item

TYPE versionable_item = EXTENSIBLE SELECT ;
END_TYPE; -- versionable_item

TYPE effectivity_item_for_replacement = SELECT BASED_ON effectivity_item WITH (
	product_definition_relationship);
END_TYPE; -- effectivity_item_for_replacement

TYPE mri_aliasable_item = EXTENSIBLE SELECT BASED_ON aliasable_item WITH (
	approval_status,
	contract,
	organization,
	security_classification_level);
END_TYPE; -- mri_aliasable_item

TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH (
	certification,
	contract);
END_TYPE; -- mri_approval_item

TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH (
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	identification_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization);
END_TYPE; -- mri_attribute_language_item

TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	certification,
	contract,
	security_classification);
END_TYPE; -- mri_date_and_time_item

TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	certification,
	contract,
	security_classification);
END_TYPE; -- mri_date_item

TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
	approval_status,
	contract,
	organization,
	security_classification_level);
END_TYPE; -- mri_identification_item

TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH (
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	identification_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization);
END_TYPE; -- mri_multi_language_attribute_item

TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH (
	applied_identification_assignment,
	applied_security_classification_assignment,
	contract);
END_TYPE; -- mri_organization_item

TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH (
	applied_identification_assignment,
	applied_security_classification_assignment,
	contract);
END_TYPE; -- mri_person_and_organization_item

TYPE attribute_type = SELECT (
	label,
	text);
END_TYPE; -- attribute_type

TYPE characterized_material_property = SELECT (
	material_property_representation,
	product_material_composition_relationship);
END_TYPE; -- characterized_material_property

TYPE atom_based_tuple = LIST [0:?] OF atom_based_value;
END_TYPE; -- atom_based_tuple

TYPE atom_based_value = SELECT (
	maths_atom,
	atom_based_tuple);
END_TYPE; -- atom_based_value

TYPE dotted_express_identifier = STRING;
WHERE
	syntax :  dotted_identifiers_syntax(SELF);
END_TYPE; -- dotted_express_identifier

TYPE elementary_function_enumerators = ENUMERATION OF (
	ef_and,
	ef_or,
	ef_not,
	ef_xor,
	ef_negate_i,
	ef_add_i,
	ef_subtract_i,
	ef_multiply_i,
	ef_divide_i,
	ef_mod_i,
	ef_exponentiate_i,
	ef_eq_i,
	ef_ne_i,
	ef_gt_i,
	ef_lt_i,
	ef_ge_i,
	ef_le_i,
	ef_abs_i,
	ef_max_i,
	ef_min_i,
	ef_if_i,
	ef_negate_r,
	ef_reciprocal_r,
	ef_add_r,
	ef_subtract_r,
	ef_multiply_r,
	ef_divide_r,
	ef_mod_r,
	ef_exponentiate_r,
	ef_exponentiate_ri,
	ef_eq_r,
	ef_ne_r,
	ef_gt_r,
	ef_lt_r,
	ef_ge_r,
	ef_le_r,
	ef_abs_r,
	ef_max_r,
	ef_min_r,
	ef_acos_r,
	ef_asin_r,
	ef_atan2_r,
	ef_cos_r,
	ef_exp_r,
	ef_ln_r,
	ef_log2_r,
	ef_log10_r,
	ef_sin_r,
	ef_sqrt_r,
	ef_tan_r,
	ef_if_r,
	ef_form_c,
	ef_rpart_c,
	ef_ipart_c,
	ef_negate_c,
	ef_reciprocal_c,
	ef_add_c,
	ef_subtract_c,
	ef_multiply_c,
	ef_divide_c,
	ef_exponentiate_c,
	ef_exponentiate_ci,
	ef_eq_c,
	ef_ne_c,
	ef_conjugate_c,
	ef_abs_c,
	ef_arg_c,
	ef_cos_c,
	ef_exp_c,
	ef_ln_c,
	ef_sin_c,
	ef_sqrt_c,
	ef_tan_c,
	ef_if_c,
	ef_subscript_s,
	ef_eq_s,
	ef_ne_s,
	ef_gt_s,
	ef_lt_s,
	ef_ge_s,
	ef_le_s,
	ef_subsequence_s,
	ef_concat_s,
	ef_size_s,
	ef_format,
	ef_value,
	ef_like,
	ef_if_s,
	ef_subscript_b,
	ef_eq_b,
	ef_ne_b,
	ef_gt_b,
	ef_lt_b,
	ef_ge_b,
	ef_le_b,
	ef_subsequence_b,
	ef_concat_b,
	ef_size_b,
	ef_if_b,
	ef_subscript_t,
	ef_eq_t,
	ef_ne_t,
	ef_concat_t,
	ef_size_t,
	ef_entuple,
	ef_detuple,
	ef_insert,
	ef_remove,
	ef_if_t,
	ef_sum_it,
	ef_product_it,
	ef_add_it,
	ef_subtract_it,
	ef_scalar_mult_it,
	ef_dot_prod_it,
	ef_sum_rt,
	ef_product_rt,
	ef_add_rt,
	ef_subtract_rt,
	ef_scalar_mult_rt,
	ef_dot_prod_rt,
	ef_norm_rt,
	ef_sum_ct,
	ef_product_ct,
	ef_add_ct,
	ef_subtract_ct,
	ef_scalar_mult_ct,
	ef_dot_prod_ct,
	ef_norm_ct,
	ef_if,
	ef_ensemble,
	ef_member_of );
END_TYPE; -- elementary_function_enumerators

TYPE elementary_space_enumerators = ENUMERATION OF (
	es_numbers,
	es_complex_numbers,
	es_reals,
	es_integers,
	es_logicals,
	es_booleans,
	es_strings,
	es_binarys,
	es_maths_spaces,
	es_maths_functions,
	es_generics );
END_TYPE; -- elementary_space_enumerators

TYPE express_identifier = dotted_express_identifier;
WHERE
	syntax :  dot_count(SELF)= 0 ;
END_TYPE; -- express_identifier

TYPE extension_options = ENUMERATION OF (
	eo_none,
	eo_cont,
	eo_cont_right,
	eo_cont_left );
END_TYPE; -- extension_options

TYPE input_selector = positive_integer;
END_TYPE; -- input_selector

TYPE lower_upper = ENUMERATION OF (
	lower,
	upper );
END_TYPE; -- lower_upper

TYPE maths_atom = SELECT (
	maths_simple_atom,
	maths_enum_atom);
END_TYPE; -- maths_atom

TYPE maths_binary = BINARY;
END_TYPE; -- maths_binary

TYPE maths_boolean = BOOLEAN;
END_TYPE; -- maths_boolean

TYPE maths_enum_atom = SELECT (
	elementary_space_enumerators,
	ordering_type,
	lower_upper,
	symmetry_type,
	elementary_function_enumerators,
	open_closed,
	space_constraint_type,
	repackage_options,
	extension_options);
END_TYPE; -- maths_enum_atom

TYPE maths_expression = SELECT (
	atom_based_value,
	maths_tuple,
	generic_expression);
END_TYPE; -- maths_expression

TYPE maths_function_select = SELECT (
	maths_function,
	elementary_function_enumerators);
END_TYPE; -- maths_function_select

TYPE maths_integer = INTEGER;
END_TYPE; -- maths_integer

TYPE maths_logical = LOGICAL;
END_TYPE; -- maths_logical

TYPE maths_number = NUMBER;
END_TYPE; -- maths_number

TYPE maths_real = REAL;
END_TYPE; -- maths_real

TYPE maths_simple_atom = SELECT (
	maths_number,
	maths_real,
	maths_number,
	maths_logical,
	maths_boolean,
	maths_string,
	maths_binary);
END_TYPE; -- maths_simple_atom

TYPE maths_space_or_function = SELECT (
	maths_space,
	maths_function);
END_TYPE; -- maths_space_or_function

TYPE maths_string = STRING;
END_TYPE; -- maths_string

TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE; -- maths_tuple

TYPE maths_value = SELECT (
	atom_based_value,
	maths_tuple,
	generic_expression);
WHERE
	constancy :  NOT('GENERIC_EXPRESSION' IN stripped_typeof(SELF))OR expression_is_constant(SELF);
END_TYPE; -- maths_value

TYPE nonnegative_integer = INTEGER;
WHERE
	nonnegativity :  SELF >= 0 ;
END_TYPE; -- nonnegative_integer

TYPE one_or_two = positive_integer;
WHERE
	in_range : (SELF  = 1)OR(SELF = 2);
END_TYPE; -- one_or_two

TYPE open_closed = ENUMERATION OF (
	open,
	closed );
END_TYPE; -- open_closed

TYPE ordering_type = ENUMERATION OF (
	by_rows,
	by_columns );
END_TYPE; -- ordering_type

TYPE positive_integer = nonnegative_integer;
WHERE
	positivity :  SELF > 0 ;
END_TYPE; -- positive_integer

TYPE product_space = SELECT (
	uniform_product_space,
	listed_product_space);
END_TYPE; -- product_space

TYPE real_interval = SELECT (
	real_interval_from_min,
	real_interval_to_max,
	finite_real_interval,
	elementary_space);
WHERE
	WR1 :  NOT('ELEMENTARY_SPACE' IN stripped_typeof(SELF))OR(SELF \ elementary_space.space_id = es_reals);
END_TYPE; -- real_interval

TYPE repackage_options = ENUMERATION OF (
	ro_nochange,
	ro_wrap_as_tuple,
	ro_unwrap_tuple );
END_TYPE; -- repackage_options

TYPE space_constraint_type = ENUMERATION OF (
	sc_equal,
	sc_subspace,
	sc_member );
END_TYPE; -- space_constraint_type

TYPE symmetry_type = ENUMERATION OF (
	identity,
	skew,
	hermitian,
	skew_hermitian );
END_TYPE; -- symmetry_type

TYPE tuple_space = SELECT (
	product_space,
	extended_tuple_space);
END_TYPE; -- tuple_space

TYPE zero_or_one = nonnegative_integer;
WHERE
	in_range : (SELF  = 0)OR(SELF = 1);
END_TYPE; -- zero_or_one

TYPE amount_of_substance_measure = REAL;
END_TYPE; -- amount_of_substance_measure

TYPE area_measure = REAL;
END_TYPE; -- area_measure

TYPE celsius_temperature_measure = REAL;
END_TYPE; -- celsius_temperature_measure

TYPE context_dependent_measure = REAL;
END_TYPE; -- context_dependent_measure

TYPE count_measure = NUMBER;
END_TYPE; -- count_measure

TYPE descriptive_measure = STRING;
END_TYPE; -- descriptive_measure

TYPE electric_current_measure = REAL;
END_TYPE; -- electric_current_measure

TYPE length_measure = REAL;
END_TYPE; -- length_measure

TYPE luminous_intensity_measure = REAL;
END_TYPE; -- luminous_intensity_measure

TYPE mass_measure = REAL;
END_TYPE; -- mass_measure

TYPE measure_value = SELECT (
	amount_of_substance_measure,
	area_measure,
	celsius_temperature_measure,
	context_dependent_measure,
	count_measure,
	descriptive_measure,
	electric_current_measure,
	length_measure,
	luminous_intensity_measure,
	mass_measure,
	numeric_measure,
	parameter_value,
	plane_angle_measure,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	ratio_measure,
	solid_angle_measure,
	thermodynamic_temperature_measure,
	time_measure,
	volume_measure);
END_TYPE; -- measure_value

TYPE numeric_measure = NUMBER;
END_TYPE; -- numeric_measure

TYPE parameter_value = REAL;
END_TYPE; -- parameter_value

TYPE plane_angle_measure = REAL;
END_TYPE; -- plane_angle_measure

TYPE positive_length_measure = length_measure;
WHERE
	WR1 :  SELF > 0.0 ;
END_TYPE; -- positive_length_measure

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
	WR1 :  SELF > 0.0 ;
END_TYPE; -- positive_plane_angle_measure

TYPE positive_ratio_measure = ratio_measure;
WHERE
	WR1 :  SELF > 0.0 ;
END_TYPE; -- positive_ratio_measure

TYPE ratio_measure = REAL;
END_TYPE; -- ratio_measure

TYPE si_prefix = ENUMERATION OF (
	exa,
	peta,
	tera,
	giga,
	mega,
	kilo,
	hecto,
	deca,
	deci,
	centi,
	milli,
	micro,
	nano,
	pico,
	femto,
	atto );
END_TYPE; -- si_prefix

TYPE si_unit_name = ENUMERATION OF (
	metre,
	gram,
	second,
	ampere,
	kelvin,
	mole,
	candela,
	radian,
	steradian,
	hertz,
	newton,
	pascal,
	joule,
	watt,
	coulomb,
	volt,
	farad,
	ohm,
	siemens,
	weber,
	tesla,
	henry,
	degree_Celsius,
	lumen,
	lux,
	becquerel,
	gray,
	sievert );
END_TYPE; -- si_unit_name

TYPE solid_angle_measure = REAL;
END_TYPE; -- solid_angle_measure

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; -- thermodynamic_temperature_measure

TYPE time_measure = REAL;
END_TYPE; -- time_measure

TYPE unit = SELECT (
	derived_unit,
	named_unit);
END_TYPE; -- unit

TYPE volume_measure = REAL;
END_TYPE; -- volume_measure

TYPE model_parameter_assigned_item = SELECT (
	unit);
END_TYPE; -- model_parameter_assigned_item

TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	multi_language_attribute_assignment,
	attribute_value_assignment);
END_TYPE; -- attribute_language_item

TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- multi_language_attribute_item

TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- name_item

TYPE product_definition_or_assembly_relationship = SELECT (
	assembly_component_usage,
	product_definition);
END_TYPE; -- product_definition_or_assembly_relationship

TYPE organization_item = EXTENSIBLE SELECT ;
END_TYPE; -- organization_item

TYPE person_and_organization_item = EXTENSIBLE SELECT ;
END_TYPE; -- person_and_organization_item

TYPE person_organization_select = SELECT (
	organization,
	person,
	person_and_organization);
END_TYPE; -- person_organization_select

TYPE puuv_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	shape_aspect);
END_TYPE; -- puuv_document_reference_item

TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH (
	externally_defined_class);
END_TYPE; -- plib_class_identification_item

TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH (
	class);
END_TYPE; -- plib_class_organization_item

TYPE characterized_action_definition = SELECT (
	action,
	action_method,
	action_method_relationship,
	action_relationship);
END_TYPE; -- characterized_action_definition

TYPE characterized_resource_definition = SELECT (
	action_resource,
	action_resource_relationship,
	action_resource_requirement,
	action_resource_requirement_relationship);
END_TYPE; -- characterized_resource_definition

TYPE property_or_shape_select = SELECT (
	property_definition,
	shape_definition);
END_TYPE; -- property_or_shape_select

TYPE source = ENUMERATION OF (
	made,
	bought,
	not_known );
END_TYPE; -- source

TYPE characterized_definition = SELECT (
	characterized_object,
	characterized_product_definition,
	shape_definition);
END_TYPE; -- characterized_definition

TYPE characterized_product_definition = SELECT (
	product_definition,
	product_definition_relationship);
END_TYPE; -- characterized_product_definition

TYPE derived_property_select = SELECT (
	action_property,
	property_definition,
	resource_property);
END_TYPE; -- derived_property_select

TYPE shape_definition = SELECT (
	product_definition_shape,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- shape_definition

TYPE represented_definition = SELECT (
	general_property,
	property_definition,
	property_definition_relationship,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- represented_definition

TYPE pr_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	rule_action);
END_TYPE; -- pr_date_and_time_item

TYPE rule_superseded_item = SELECT (
	product_definition_formation);
END_TYPE; -- rule_superseded_item

TYPE project_as_date_and_time_item = SELECT BASED_ON date_and_time_item WITH (
	organizational_project);
END_TYPE; -- project_as_date_and_time_item

TYPE project_as_date_item = SELECT BASED_ON date_item WITH (
	organizational_project);
END_TYPE; -- project_as_date_item

TYPE project_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH (
	organizational_project);
END_TYPE; -- project_event_occurrence_item

TYPE project_item = EXTENSIBLE SELECT ;
END_TYPE; -- project_item

TYPE value_qualifier = SELECT (
	precision_qualifier,
	type_qualifier,
	uncertainty_qualifier);
END_TYPE; -- value_qualifier

TYPE compound_item_definition = SELECT (
	list_representation_item,
	set_representation_item);
END_TYPE; -- compound_item_definition

TYPE founded_item_select = SELECT (
	founded_item,
	representation_item);
END_TYPE; -- founded_item_select

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE; -- list_representation_item

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE; -- set_representation_item

TYPE transformation = SELECT (
	item_defined_transformation,
	functionally_defined_transformation);
END_TYPE; -- transformation

TYPE requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- requirement_assigned_item

TYPE requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- requirement_source_item

TYPE rd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	requirements_property);
END_TYPE; -- rd_document_reference_item

TYPE rd_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	requirements_property);
END_TYPE; -- rd_groupable_item

TYPE requirement_identification_and_version_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH (
	product,
	product_definition_formation);
END_TYPE; -- requirement_identification_and_version_mri_identification_item

TYPE security_classification_item = EXTENSIBLE SELECT ;
END_TYPE; -- security_classification_item

TYPE limit_condition = ENUMERATION OF (
	maximum_material_condition,
	least_material_condition,
	regardless_of_feature_size );
END_TYPE; -- limit_condition

TYPE angle_relator = ENUMERATION OF (
	equal,
	large,
	small );
END_TYPE; -- angle_relator

TYPE dimensional_characteristic = SELECT (
	dimensional_location,
	dimensional_size);
END_TYPE; -- dimensional_characteristic

TYPE shape_tolerance_select = SELECT (
	geometric_tolerance,
	plus_minus_tolerance);
END_TYPE; -- shape_tolerance_select

TYPE tolerance_method_definition = SELECT (
	tolerance_value,
	limits_and_fits);
END_TYPE; -- tolerance_method_definition

TYPE spr_document_reference_item = SELECT BASED_ON document_reference_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_document_reference_item

TYPE spr_organization_item = EXTENSIBLE SELECT BASED_ON organization_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_organization_item

TYPE spr_person_and_organization_item = EXTENSIBLE SELECT BASED_ON person_and_organization_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_person_and_organization_item

TYPE document_identifier_assigned_item = SELECT (
	document);
END_TYPE; -- document_identifier_assigned_item

TYPE sd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	configuration_item,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- sd_document_reference_item

TYPE identifier = STRING;
END_TYPE; -- identifier

TYPE label = STRING;
END_TYPE; -- label

TYPE text = STRING;
END_TYPE; -- text

TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
END_TYPE; -- list_of_reversible_topology_item

TYPE reversible_topology = SELECT (
	reversible_topology_item,
	list_of_reversible_topology_item,
	set_of_reversible_topology_item);
END_TYPE; -- reversible_topology

TYPE reversible_topology_item = SELECT (
	edge,
	path,
	face,
	face_bound,
	closed_shell,
	open_shell);
END_TYPE; -- reversible_topology_item

TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
END_TYPE; -- set_of_reversible_topology_item

TYPE shell = SELECT (
	vertex_shell,
	wire_shell,
	open_shell,
	closed_shell);
END_TYPE; -- shell

TYPE action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- action_request_item

ENTITY action;
	name : label;
	description : OPTIONAL text;
	chosen_method : action_method;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- action


ENTITY action_directive;
	name : label;
	description : OPTIONAL text;
	analysis : text;
	comment : text;
	requests : SET [1:?] OF versioned_action_request;
END_ENTITY; -- action_directive


ENTITY action_method;
	name : label;
	description : OPTIONAL text;
	consequence : text;
	purpose : text;
END_ENTITY; -- action_method


ENTITY action_method_relationship;
	name : label;
	description : OPTIONAL text;
	relating_method : action_method;
	related_method : action_method;
END_ENTITY; -- action_method_relationship


ENTITY action_relationship;
	name : label;
	description : OPTIONAL text;
	relating_action : action;
	related_action : action;
END_ENTITY; -- action_relationship


ENTITY action_request_solution;
	method : action_method;
	request : versioned_action_request;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- action_request_solution


ENTITY action_request_status;
	status : label;
	assigned_request : versioned_action_request;
END_ENTITY; -- action_request_status


ENTITY action_resource;
	name : label;
	description : OPTIONAL text;
	usage : SET [1:?] OF supported_item;
	kind : action_resource_type;
END_ENTITY; -- action_resource


ENTITY action_resource_relationship;
	name : label;
	description : OPTIONAL text;
	relating_resource : action_resource;
	related_resource : action_resource;
END_ENTITY; -- action_resource_relationship


ENTITY action_resource_type;
	name : label;
END_ENTITY; -- action_resource_type


ENTITY action_status;
	status : label;
	assigned_action : executed_action;
END_ENTITY; -- action_status


ENTITY directed_action
	SUBTYPE OF (executed_action);
	directive : action_directive;
END_ENTITY; -- directed_action


ENTITY executed_action
	SUBTYPE OF (action);
END_ENTITY; -- executed_action


ENTITY versioned_action_request;
	id : identifier;
	version : label;
	purpose : text;
	description : OPTIONAL text;
END_ENTITY; -- versioned_action_request


ENTITY versioned_action_request_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_versioned_action_request : versioned_action_request;
	related_versioned_action_request : versioned_action_request;
END_ENTITY; -- versioned_action_request_relationship


ENTITY applied_action_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF action_items;
END_ENTITY; -- applied_action_assignment


ENTITY advanced_brep_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MANIFOLD_SOLID_BREP', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FACETED_BREP', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MANIFOLD_SOLID_BREP', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1)))> 0 ;
	WR3 :  SIZEOF(QUERY(msb <* QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MANIFOLD_SOLID_BREP' IN  TYPEOF(it)))| NOT(SIZEOF(QUERY(csh <* msb_shells(msb)| NOT(SIZEOF(QUERY(fcs <* csh \ connected_face_set.cfs_faces | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ADVANCED_FACE' IN TYPEOF(fcs))))= 0)))= 0)))= 0 ;
	WR4 :  SIZEOF(QUERY(msb <* QUERY(it <* items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MANIFOLD_SOLID_BREP' IN  TYPEOF(it)))|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb \ manifold_solid_brep.outer))))= 0 ;
	WR5 :  SIZEOF(QUERY(brv <* QUERY(it <* items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF(it)))| NOT(SIZEOF(QUERY(csh <* brv \ brep_with_voids.voids | csh \ oriented_closed_shell.orientation))= 0)))= 0 ;
	WR6 :  SIZEOF(QUERY(mi <* QUERY(it <* items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it)))| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))))= 0 ;
END_ENTITY; -- advanced_brep_shape_representation


ENTITY curve_swept_solid_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SWEPT_AREA_SOLID', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SWEPT_DISK_SOLID', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SWEPT_AREA_SOLID', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SWEPT_DISK_SOLID', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1))> 0 ;
	WR3 :  SIZEOF(QUERY(mi <* QUERY(it <* items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it))| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))))= 0 ;
	WR4 :  SIZEOF(QUERY(scsas <* QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE_SWEPT_AREA_SOLID' IN  TYPEOF(it))| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF(scsas.directrix))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(scsas.directrix)))))= 0 ;
END_ENTITY; -- curve_swept_solid_shape_representation


ENTITY ruled_surface_swept_area_solid
	SUBTYPE OF (surface_curve_swept_area_solid);
WHERE
	WR1 :  'B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface)AND(SELF.reference_surface \ b_spline_surface.u_degree = 1);
	WR2 : ('PCURVE' IN  TYPEOF(SELF.directrix))OR(('B_SPLINE_CURVE' IN TYPEOF(SELF.directrix \ surface_curve.curve_3d))AND(SELF.directrix \ surface_curve.curve_3d \ b_spline_curve.degree = SELF.reference_surface \ b_spline_surface.v_degree));
END_ENTITY; -- ruled_surface_swept_area_solid


ENTITY angularity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)< 3 ;
END_ENTITY; -- angularity_tolerance


ENTITY circular_runout_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 2 ;
END_ENTITY; -- circular_runout_tolerance


ENTITY coaxiality_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 2 ;
END_ENTITY; -- coaxiality_tolerance


ENTITY common_datum
	SUBTYPE OF (composite_shape_aspect, datum);
WHERE
	WR1 :  SIZEOF(SELF.component_relationships)= 2 ;
	WR2 :  SIZEOF(QUERY(sar <* SELF.component_relationships | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DATUM' IN  TYPEOF(sar.related_shape_aspect))AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMMON_DATUM' IN TYPEOF(sar.related_shape_aspect)))))= 0 ;
END_ENTITY; -- common_datum


ENTITY concentricity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)= 1 ;
END_ENTITY; -- concentricity_tolerance


ENTITY cylindricity_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- cylindricity_tolerance


ENTITY flatness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- flatness_tolerance


ENTITY line_profile_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3);
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF \ geometric_tolerance.toleranced_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar.name IN [ 'affected plane association', 'resulting intersection curve association' ])))= 1 ;
END_ENTITY; -- line_profile_tolerance


ENTITY parallelism_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)< 3 ;
END_ENTITY; -- parallelism_tolerance


ENTITY perpendicularity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3 ;
END_ENTITY; -- perpendicularity_tolerance


ENTITY position_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3);
END_ENTITY; -- position_tolerance


ENTITY roundness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- roundness_tolerance


ENTITY straightness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- straightness_tolerance


ENTITY surface_profile_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3);
END_ENTITY; -- surface_profile_tolerance


ENTITY symmetry_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3 ;
END_ENTITY; -- symmetry_tolerance


ENTITY total_runout_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 2 ;
END_ENTITY; -- total_runout_tolerance


ENTITY geometrically_bounded_surface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_SET', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_SET', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1))> 0 ;
	WR3 :  SIZEOF(QUERY(mi <* QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it))| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN  TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))AND(SIZEOF(QUERY(mr_it <* mi \ mapped_item.mapping_source.mapped_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_SET' IN TYPEOF(mr_it))))> 0))))= 0 ;
	WR4 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(pnt <* QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POINT' IN TYPEOF(gsel))| NOT(gbsf_check_point(pnt))))= 0)))= 0 ;
	WR5 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cv <* QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE' IN TYPEOF(gsel))| NOT(gbsf_check_curve(cv))))= 0)))= 0 ;
	WR6 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(sf <* QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE' IN TYPEOF(gsel))| NOT(gbsf_check_surface(sf))))= 0)))= 0 ;
	WR7 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| SIZEOF(QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE' IN TYPEOF(gsel)))> 0))> 0 ;
END_ENTITY; -- geometrically_bounded_surface_shape_representation


ENTITY advanced_face
	SUBTYPE OF (face_surface);
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ELEMENTARY_SURFACE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_SURFACE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SWEPT_SURFACE' ] * TYPEOF(face_geometry))= 1 ;
	WR2 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_CURVE' IN TYPEOF(oe \ oriented_edge.edge_element))))= 0)))= 0 ;
	WR3 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LINE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CONIC', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLYLINE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element \ edge_curve.edge_geometry))= 1)))= 0)))= 0 ;
	WR4 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT((('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VERTEX_POINT' IN  TYPEOF(oe \ edge.edge_start))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(oe \ edge.edge_start \ vertex_point.vertex_geometry)))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VERTEX_POINT' IN  TYPEOF(oe \ edge.edge_end))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CARTESIAN_POINT' IN TYPEOF(oe \ edge.edge_end \ vertex_point.vertex_geometry))))))= 0)))= 0 ;
	WR5 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_PATH' IN TYPEOF(elp_fbnds.bound))))= 0 ;
	WR6 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SWEPT_SURFACE' IN TYPEOF(face_geometry))OR(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LINE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CONIC', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLYLINE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF(face_geometry \ swept_surface.swept_curve))= 1);
	WR7 :  SIZEOF(QUERY(vlp_fbnds <* QUERY(bnds <* bounds |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VERTEX_LOOP' IN  TYPEOF(bnds.bound)))| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VERTEX_POINT' IN  TYPEOF(vlp_fbnds \ face_bound.bound \ vertex_loop.loop_vertex))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds \ face_bound.bound \ vertex_loop.loop_vertex \ vertex_point.vertex_geometry)))))= 0 ;
	WR8 :  SIZEOF(QUERY(bnd <* bounds | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VERTEX_LOOP' ] * TYPEOF(bnd.bound))= 1)))= 0 ;
	WR9 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF(oe \ oriented_edge.edge_element \ edge_curve.edge_geometry))AND NOT(SIZEOF(QUERY(sc_ag <* oe.edge_element \ edge_curve.edge_geometry \ surface_curve.associated_geometry | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(sc_ag))))= 0)))= 0)))= 0 ;
	WR10 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SWEPT_SURFACE' IN  TYPEOF(face_geometry))OR(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLYLINE' IN  TYPEOF(face_geometry \ swept_surface.swept_curve))OR(SIZEOF(face_geometry \ swept_surface.swept_curve \ polyline.points)>= 3)))AND(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLYLINE' IN TYPEOF(oe \ oriented_edge.edge_element \ edge_curve.edge_geometry))AND NOT(SIZEOF(oe \ oriented_edge.edge_element \ edge_curve.edge_geometry \ polyline.points)>= 3)))= 0)))= 0);
END_ENTITY; -- advanced_face


ENTITY altered_package_terminal
	ABSTRACT SUPERTYPE OF (((shape_formed_terminal ANDOR surface_prepped_terminal) ANDOR length_trimmed_terminal))
	SUBTYPE OF (package_terminal);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'terminal to be altered'))= 1 ;
	WR2 : (SELF.of_shape.definition \ product_definition.description = 'altered package');
END_ENTITY; -- altered_package_terminal


ENTITY length_trimmed_terminal
	SUBTYPE OF (altered_package_terminal);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2))= 2))= 1)))= 0);
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum trimmed length')))= 1))= 1)))= 0);
	WR3 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum trimmed length')))= 1))= 1)))= 0);
END_ENTITY; -- length_trimmed_terminal


ENTITY shape_formed_terminal
	SUBTYPE OF (altered_package_terminal);
WHERE
	WR1 : (SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document))AND(ada.assigned_document.kind \ document_type.product_data_type = 'lead form specification')AND(SIZEOF(QUERY(dr <* USEDIN(ada.assigned_document, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT')| dr.relating_document.kind \ document_type.product_data_type = 'material specification'))= 1)))= 1);
END_ENTITY; -- shape_formed_terminal


ENTITY surface_prepped_terminal
	SUBTYPE OF (altered_package_terminal);
WHERE
	WR2 : (SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document))AND(ada.assigned_document.kind \ document_type.product_data_type = 'surface finish specification')))= 1);
END_ENTITY; -- surface_prepped_terminal


ENTITY across_port_variable
	SUBTYPE OF (port_variable);
END_ENTITY; -- across_port_variable


ENTITY analog_analytical_model_port
	SUBTYPE OF (analytical_model_port);
END_ENTITY; -- analog_analytical_model_port


ENTITY analytical_model
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 2 ;
	WR2 :  SIZEOF(QUERY(dr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| dr.assigned_document.kind \ document_type.product_data_type = 'language reference manual'))= 1 ;
	WR3 :  SIZEOF(QUERY(it <* SELF.items | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODEL_PARAMETER' IN TYPEOF(it))))= 0 ;
	WR4 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr \ representation_relationship.name = 'access mechanism')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(rr.rep_2))))>= 1 ;
END_ENTITY; -- analytical_model


ENTITY analytical_model_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ analytical_model_definition)))= 0 ;
END_ENTITY; -- analytical_model_definition


ENTITY analytical_model_make_from_relationship
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' ] * TYPEOF(SELF.rep_1))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' ] * TYPEOF(SELF.rep_2))= 1 ;
	WR3 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2)))))= 0 ;
	WR4 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT((rr \ representation_relationship.name = 'associated make from')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2)))))= 0 ;
	WR5 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' ] * TYPEOF(SELF))= 0 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF \ analytical_model_make_from_relationship)))= 0 ;
END_ENTITY; -- analytical_model_make_from_relationship


ENTITY analytical_model_parameter
	SUBTYPE OF (model_parameter);
WHERE
	WR1 :  SIZEOF(QUERY(cri <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(cri))))= 1 ;
END_ENTITY; -- analytical_model_parameter


ENTITY analytical_model_port
	SUPERTYPE OF ((analytical_model_vector_port ANDOR ONEOF (analog_analytical_model_port, digital_analytical_model_port)))
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(am <* QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| rr \ representation_relationship.name = 'access mechanism')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(am.rep_1)))= 1 ;
END_ENTITY; -- analytical_model_port


ENTITY analytical_model_port_assignment
	SUBTYPE OF (property_definition_representation, representation_relationship);
END_ENTITY; -- analytical_model_port_assignment


ENTITY analytical_model_scalar_port
	SUBTYPE OF (analytical_model_vector_port);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'size')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COUNT_MEASURE' IN TYPEOF(it \ measure_with_unit.value_component))AND(it \ measure_with_unit.value_component = 1)))= 1 ;
END_ENTITY; -- analytical_model_scalar_port


ENTITY analytical_model_vector_port
	SUBTYPE OF (analytical_model_port);
WHERE
	WR1 : (SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'size')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COUNT_MEASURE' IN  TYPEOF(it \ measure_with_unit.value_component))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONTEXT_DEPENDENT_UNIT' IN TYPEOF(it \ measure_with_unit.unit_component))))= 1);
END_ENTITY; -- analytical_model_vector_port


ENTITY analytical_representation
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))>= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1)))= 1 ;
END_ENTITY; -- analytical_representation


ENTITY digital_analytical_model_port
	SUBTYPE OF (analytical_model_port);
WHERE
	WR2 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'nominal signal flow direction')AND(it \ descriptive_representation_item.description IN [ 'input direction', 'output direction', 'bidirectional', 'unknown direction' ])))= 1 ;
	WR3 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'port type')AND(it \ descriptive_representation_item.description IN [ 'string property type', 'logical property type', 'boolean property type' ])))= 1 ;
END_ENTITY; -- digital_analytical_model_port


ENTITY make_from_model_port_relationship
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL_PORT' ] * TYPEOF(SELF.rep_1))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL_PORT' ] * TYPEOF(SELF.rep_2))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF \ make_from_model_port_relationship))= 0 ;
	WR4 :  rep_1 :<>: rep_2 ;
	WR5 :  SIZEOF(QUERY(rr1 <* USEDIN(SELF.rep_1, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(SIZEOF(QUERY(rr2 <* USEDIN(SELF.rep_2, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(rr1.rep_1 :=: rr2.rep_1)))= 0)))= 1 ;
	WR6 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL_MAKE_FROM_RELATIONSHIP')IN TYPEOF(rr.rep_1))))= 1 ;
END_ENTITY; -- make_from_model_port_relationship


ENTITY port_variable
	SUPERTYPE OF (ONEOF (across_port_variable, through_port_variable, transform_port_variable))
	SUBTYPE OF (representation, representation_item);
END_ENTITY; -- port_variable


ENTITY through_port_variable
	SUBTYPE OF (port_variable);
END_ENTITY; -- through_port_variable


ENTITY transform_port_variable
	SUBTYPE OF (port_variable);
WHERE
	WR1 : (SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'nominal signal flow direction')AND(it \ descriptive_representation_item.description IN [ 'input direction', 'output direction', 'unknown direction' ]))))= 1 ;
END_ENTITY; -- transform_port_variable


ENTITY applied_promissory_usage_in_product_model_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF promissory_usage_in_product_model_assigned_item;
WHERE
	WR1 :  SIZEOF(QUERY(pm <* items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_CONCEPT' IN TYPEOF(pm)))= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(pd)))= 1 ;
	WR3 :  SIZEOF(items)= 2 ;
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROMISSORY_USAGE_IN_PRODUCT_MODEL' IN TYPEOF(SELF \ group_assignment.assigned_group);
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))<= 1 ;
END_ENTITY; -- applied_promissory_usage_in_product_model_assignment


ENTITY promissory_usage_in_product_model
	SUBTYPE OF (group);
WHERE
	WR1 :  SIZEOF(QUERY(aga <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PROMISSORY_USAGE_IN_PRODUCT_MODEL_ASSIGNMENT' IN TYPEOF(aga)))>= 1 ;
END_ENTITY; -- promissory_usage_in_product_model


ENTITY supplied_part_relationship
	SUBTYPE OF (product_definition_relationship);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN TYPEOF(SELF.related_product_definition.formation);
	WR2 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION' IN ROLESOF(SELF));
END_ENTITY; -- supplied_part_relationship


ENTITY application_context;
	application : label;
DERIVE
	description : text :=  get_description_value(SELF);
	id : identifier :=  get_id_value(SELF);
INVERSE
	context_elements: SET [1:?] OF application_context_element FOR frame_of_reference;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- application_context


ENTITY application_context_element
	SUPERTYPE OF (ONEOF (library_context, product_concept_context, product_context, product_definition_context));
	name : label;
	frame_of_reference : application_context;
END_ENTITY; -- application_context_element


ENTITY application_context_relationship;
	name : label;
	description : OPTIONAL text;
	relating_context : application_context;
	related_context : application_context;
END_ENTITY; -- application_context_relationship


ENTITY application_protocol_definition;
	status : label;
	application_interpreted_model_schema_name : label;
	application_protocol_year : year_number;
	application : application_context;
END_ENTITY; -- application_protocol_definition


ENTITY library_context
	SUBTYPE OF (application_context_element);
	library_reference : label;
END_ENTITY; -- library_context


ENTITY product_concept_context
	SUBTYPE OF (application_context_element);
	market_segment_type : label;
END_ENTITY; -- product_concept_context


ENTITY product_context
	SUBTYPE OF (application_context_element);
	discipline_type : label;
END_ENTITY; -- product_context


ENTITY product_definition_context
	SUBTYPE OF (application_context_element);
	life_cycle_stage : label;
END_ENTITY; -- product_definition_context


ENTITY applied_approval_assignment
	SUBTYPE OF (approval_assignment);
	items : SET [1:?] OF approval_item;
END_ENTITY; -- applied_approval_assignment


ENTITY approval;
	status : approval_status;
	level : label;
END_ENTITY; -- approval


ENTITY approval_date_time;
	date_time : date_time_select;
	dated_approval : approval;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- approval_date_time


ENTITY approval_person_organization;
	person_organization : person_organization_select;
	authorized_approval : approval;
	role : approval_role;
END_ENTITY; -- approval_person_organization


ENTITY approval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_approval : approval;
	related_approval : approval;
END_ENTITY; -- approval_relationship


ENTITY approval_role;
	role : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- approval_role


ENTITY approval_status;
	name : label;
END_ENTITY; -- approval_status


ENTITY component_mounting_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 : (SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTER_STRATUM_FEATURE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROBE_ACCESS_AREA', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LAND' ] * TYPEOF(SELF))= 0);
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = 'planar projected shape'))<= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = '3d bound volume shape'))<= 1)))= 0 ;
	WR5 : (NOT(SELF  \ shape_aspect.description IN [ 'component feature' ]))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design usage'))<= 1);
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
END_ENTITY; -- component_mounting_feature


ENTITY packaged_component
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1 ;
	WR2 :  SIZEOF(QUERY(pa <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'package alternate')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ] * TYPEOF(pa.relating_product_definition))= 1)AND(pa.relating_product_definition \ product_definition.description = 'altered package')))<= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'packaged component join terminal')))>= 1)))= 0 ;
	WR4 : (NOT(SELF  \ product_definition.description = 'packaged connector component'))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(ip.relating_product_definition))= 1)AND(TRUE)))= 1);
	WR5 : (NOT(SELF  \ product_definition.description = 'packaged connector component'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'packaged component join terminal')))>= 1)))= 0);
	WR6 : (NOT(SELF  \ product_definition.description = 'routed packaged component'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| SIZEOF(QUERY(pd <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))= 1))= 1))= 1)))= 0);
END_ENTITY; -- packaged_component


ENTITY routed_physical_component
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1 ;
	WR2 :  SELF \ product_definition.description :<>: 'laminate component' ;
END_ENTITY; -- routed_physical_component


ENTITY assembly_definition
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  EXISTS(SELF \ product_definition.name);
	WR2 :  NOT EXISTS(SELF  \ product_definition.name)OR(SELF \ product_definition.name = 'assembly module');
	WR3 : (NOT(SELF.frame_of_reference.name = 'physical design'))OR(SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_DEFINITION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION' ] * TYPEOF(du.relating_product_definition))= 1)AND(du.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(du.relating_product_definition \ product_definition.name = 'assembly module')))= 1);
	WR4 : (NOT(SELF.frame_of_reference.name = 'physical design usage'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'pca terminal')))>= 2)))= 0);
END_ENTITY; -- assembly_definition


ENTITY assembly_module_interface_terminal
	SUBTYPE OF (assembly_module_terminal);
END_ENTITY; -- assembly_module_interface_terminal


ENTITY assembly_module_terminal
	SUPERTYPE OF (assembly_module_interface_terminal)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  EXISTS(SELF.of_shape.definition \ product_definition.name);
	WR2 :  NOT EXISTS(SELF.of_shape.definition \ product_definition.name)OR(SELF.of_shape.definition \ product_definition.name = 'assembly module');
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
	WR5 : (NOT(SELF  \ shape_aspect.description = 'pca terminal'))OR((SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_DEFINITION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION' ])>= 1)AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical design usage'));
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))= 1 ;
	WR7 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'interface terminal'))<= 1 ;
END_ENTITY; -- assembly_module_terminal


ENTITY electromagnetic_compatibility_requirement_allocation
	SUPERTYPE OF (shield_allocation)
	SUBTYPE OF (requirement_assignment);
END_ENTITY; -- electromagnetic_compatibility_requirement_allocation


ENTITY shield_allocation
	SUBTYPE OF (electromagnetic_compatibility_requirement_allocation);
END_ENTITY; -- shield_allocation


ENTITY thermal_requirement_allocation
	SUBTYPE OF (requirement_assignment);
END_ENTITY; -- thermal_requirement_allocation


ENTITY assembly_bond_definition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1 ;
	WR2 :  SIZEOF(QUERY(aga <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BOND_CATEGORY' IN TYPEOF(aga.assigned_group)))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 1'))= 1 ;
	WR4 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 2'))= 1 ;
	WR5 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SIZEOF(QUERY(prpc <* USEDIN(SELF.of_shape.definition.formation.of_product, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'technology specific model'))>= 1));
	WR6 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.name = 'assembly bond model');
END_ENTITY; -- assembly_bond_definition


ENTITY assembly_joint
	SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
	WR1 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' IN  TYPEOF(SELF.relating_shape_aspect))AND(SELF.relating_shape_aspect \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'package terminal occurrence', 'packaged component join terminal' ]))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN  TYPEOF(SELF.relating_shape_aspect))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL' IN  TYPEOF(SELF.relating_shape_aspect))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
	WR2 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' IN  TYPEOF(SELF.related_shape_aspect))AND(SELF.related_shape_aspect \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'package terminal occurrence', 'packaged component join terminal' ]))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN  TYPEOF(SELF.relating_shape_aspect))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL' IN  TYPEOF(SELF.related_shape_aspect))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
	WR3 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with bonding'))OR(SIZEOF(QUERY(ddu <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'default definition usage')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect)))= 1);
	WR4 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with bonding'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'bond assembly position')AND(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MAPPED_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'assembly position')))= 1)))= 1))<= 1);
	WR5 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with fasteners'))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
	WR6 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))OR is_assembly_module_design(SELF.of_shape.definition);
	WR7 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with bonding'))OR(SIZEOF(QUERY(ddu <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'default definition usage')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect))AND(SIZEOF(QUERY(sar <* USEDIN(ddu.relating_shape_aspect, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 1'))= 1)AND(SIZEOF(QUERY(sar <* USEDIN(ddu.relating_shape_aspect, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 1'))= 1)))= 1);
	WR8 :  acyclic_shape_aspect_relationship(SELF , [ SELF \ shape_aspect_relationship.related_shape_aspect ], 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT');
END_ENTITY; -- assembly_joint


ENTITY component_mating_constraint_condition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name, of_shape;
END_ENTITY; -- component_mating_constraint_condition


ENTITY connection_zone_based_assembly_joint
	SUBTYPE OF (assembly_joint);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'zone 1'))= 1 ;
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'zone 2'))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar.relating_shape_aspect \ shape_aspect.description = 'connection zone'))= 2 ;
END_ENTITY; -- connection_zone_based_assembly_joint


ENTITY reference_packaged_part_assembly_implementation
	SUBTYPE OF (physical_unit);
WHERE
	WR1 : (SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1)AND(SELF \ product_definition.name = 'assembly module');
	WR2 : (NOT(SELF.frame_of_reference.name = 'physical design'))OR(SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_DEFINITION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION' ] * TYPEOF(du.relating_product_definition))= 1)AND(du.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(du.relating_product_definition \ product_definition.name = 'assembly module')AND(SIZEOF(QUERY(prpc <* USEDIN(du.relating_product_definition.formation.of_product, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1)))= 1);
END_ENTITY; -- reference_packaged_part_assembly_implementation


ENTITY bare_die
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  SIZEOF(QUERY(ifdu <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ property_definition_relationship.name = 'implemented function')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition))AND(ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage')))= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(dut <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'device unit technology')| dut.relating_property_definition \ property_definition.name = 'unit technology'))= 1))= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))>= 2)))= 0 ;
END_ENTITY; -- bare_die


ENTITY bare_die_bottom_surface
	SUBTYPE OF (bare_die_surface);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ bare_die_bottom_surface || SELF  \ part_mounting_feature || SELF \ bare_die_surface))= 0 ;
END_ENTITY; -- bare_die_bottom_surface


ENTITY bare_die_edge_segment_surface
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	wr1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	wr2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	wr3 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR4 :  SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed surface')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect))))= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ bare_die_edge_segment_surface))= 0 ;
END_ENTITY; -- bare_die_edge_segment_surface


ENTITY bare_die_edge_surface
	SUBTYPE OF (bare_die_surface);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ part_mounting_feature || SELF  \ bare_die_edge_surface || SELF \ bare_die_surface))= 0 ;
END_ENTITY; -- bare_die_edge_surface


ENTITY bare_die_surface
	ABSTRACT SUPERTYPE OF (ONEOF (bare_die_bottom_surface, bare_die_top_surface, bare_die_edge_surface))
	SUBTYPE OF (part_mounting_feature);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
END_ENTITY; -- bare_die_surface


ENTITY bare_die_terminal
	SUBTYPE OF (minimally_defined_bare_die_terminal);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'external connection area')| eca.related_shape_aspect \ shape_aspect.description = 'connection zone'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1 ;
	WR4 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'seating plane zone')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))<= 1 ;
END_ENTITY; -- bare_die_terminal


ENTITY bare_die_top_surface
	SUBTYPE OF (bare_die_surface);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ part_mounting_feature || SELF  \ bare_die_top_surface || SELF \ bare_die_surface))= 0 ;
END_ENTITY; -- bare_die_top_surface


ENTITY minimally_defined_bare_die_terminal
	SUPERTYPE OF (bare_die_terminal)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'external connection area')| eca.related_shape_aspect \ shape_aspect.description = 'connection zone'))<= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))<= 1 ;
	WR4 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
END_ENTITY; -- minimally_defined_bare_die_terminal


ENTITY description_attribute;
	attribute_value : text;
	described_item : description_attribute_select;
END_ENTITY; -- description_attribute


ENTITY id_attribute;
	attribute_value : identifier;
	identified_item : id_attribute_select;
END_ENTITY; -- id_attribute


ENTITY name_attribute;
	attribute_value : label;
	named_item : name_attribute_select;
END_ENTITY; -- name_attribute


ENTITY object_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- object_role


ENTITY role_association;
	role : object_role;
	item_with_role : role_select;
END_ENTITY; -- role_association


ENTITY applied_certification_assignment
	SUBTYPE OF (certification_assignment);
	items : SET [1:?] OF certification_item;
END_ENTITY; -- applied_certification_assignment


ENTITY certification;
	name : label;
	purpose : text;
	kind : certification_type;
END_ENTITY; -- certification


ENTITY certification_type;
	description : label;
END_ENTITY; -- certification_type


ENTITY characteristic_type
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name IN [ 'string property', 'logical property', 'boolean property', 'numeric property', 'physical property', 'externally defined property', 'polar complex numeric property', 'compound characteristic' ] ;
END_ENTITY; -- characteristic_type


ENTITY coordinated_representation_item
	SUBTYPE OF (representation, representation_item);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| SIZEOF(USEDIN(pdr, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATA_ENVIRONMENT.ELEMENTS'))<= 1))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 1 ;
	WR3 : (NOT(SELF  \ representation_item.name = 'tolerance'))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))>= 1);
	WR4 : (NOT(SELF  \ representation_item.name = 'plus minus tolerance'))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))= 3);
	WR5 : (NOT(SELF  \ representation_item.name = 'symmetrical tolerance'))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))= 2);
	WR6 : (NOT(SELF  \ representation_item.name = 'plus minus tolerance'))OR((SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'basic value')))= 1)AND(SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'plus value')))= 1)AND(SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'minus value')))= 1));
	WR7 : (NOT(SELF  \ representation_item.name = 'symmetrical tolerance'))OR((SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'basic value')))= 1)AND(SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'deviation value')))= 1));
END_ENTITY; -- coordinated_representation_item


ENTITY parameter_type
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name IN [ 'string property type', 'logical property type', 'physical property type', 'boolean property type' ] ;
END_ENTITY; -- parameter_type


ENTITY applied_classification_assignment
	SUBTYPE OF (classification_assignment);
	items : SET [1:?] OF classification_item;
END_ENTITY; -- applied_classification_assignment


ENTITY class
	SUBTYPE OF (group);
END_ENTITY; -- class


ENTITY class_by_extension
	SUBTYPE OF (class);
END_ENTITY; -- class_by_extension


ENTITY class_by_intension
	SUBTYPE OF (class);
END_ENTITY; -- class_by_intension


ENTITY classification
	SUBTYPE OF (classification_assignment);
	classified : classification_select;
DERIVE
	classifier : class :=  SELF \ classification_assignment.assigned_class ;
END_ENTITY; -- classification


ENTITY complete_membership
	SUBTYPE OF (classification_assignment);
DERIVE
	containing_set : class :=  SELF \ classification_assignment.assigned_class ;
END_ENTITY; -- complete_membership


ENTITY complete_membership_of_empty_set
	SUBTYPE OF (complete_membership);
END_ENTITY; -- complete_membership_of_empty_set


ENTITY complete_membership_of_non_empty_set
	SUBTYPE OF (complete_membership);
	members : SET [1:?] OF complete_membership_select;
END_ENTITY; -- complete_membership_of_non_empty_set


ENTITY characterized_class
	SUBTYPE OF (characterized_object, class);
END_ENTITY; -- characterized_class


ENTITY class_system
	SUBTYPE OF (group);
END_ENTITY; -- class_system


ENTITY component_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
END_ENTITY; -- component_feature


ENTITY component_feature_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ component_feature_relationship))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
END_ENTITY; -- component_feature_relationship


ENTITY component_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : (SELF  \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'component termination passage join terminal', 'conductive interconnect element terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'land join terminal', 'minimally defined component terminal', 'non functional land join terminal', 'packaged component join terminal', 'printed component join terminal', 'package terminal occurrence', 'via terminal' ])OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERCONNECT_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN TYPEOF(SELF));
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
	WR4 :  SIZEOF(QUERY(at <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated terminals')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(at.relating_shape_aspect)))<= 1 ;
	WR5 :  SIZEOF(QUERY(cr <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connectivity requirement')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_NETWORK' IN TYPEOF(cr.relating_shape_aspect)))<= 1 ;
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design usage'))<= 1 ;
	WR7 : (NOT(SELF  \ shape_aspect.description IN [ 'assembly module component terminal', 'bare die component terminal', 'package terminal occurrence', 'packaged component join terminal', 'printed component join terminal' ]))OR(SELF.product_definitional);
	WR8 : (NOT(SELF  \ shape_aspect.description = 'assembly module component terminal'))OR((SELF.of_shape.definition.frame_of_reference.name = 'physical occurrence')AND(EXISTS(SELF.of_shape.definition \ product_definition.name))AND(NOT(EXISTS(SELF.of_shape.definition \ product_definition.name))OR(SELF.of_shape.definition \ product_definition.name = 'assembly module')));
	WR9 : (NOT(SELF  \ shape_aspect.description = 'assembly module component terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))))= 1);
	WR10 : (NOT(SELF  \ shape_aspect.description = 'bare die component terminal'))OR(SELF.of_shape.definition \ product_definition.description = 'bare die component');
	WR11 : (NOT(SELF  \ shape_aspect.description = 'bare die component terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))))= 1);
	WR13 : (NOT(SELF  \ shape_aspect.description = 'component termination passage join terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| i_f.relating_shape_aspect \ shape_aspect.description = 'component termination passage template join terminal'))= 1);
	WR15 : (NOT(SELF  \ shape_aspect.description IN [ 'conductive interconnect element terminal', 'interconnect component join terminal', 'printed component join terminal' ]))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))<= 1);
	WR16 : (NOT(SELF  \ shape_aspect.description = 'interconnect module component terminal'))OR((SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence')AND(EXISTS(SELF.of_shape.definition \ product_definition.name))AND(NOT(EXISTS(SELF.of_shape.definition \ product_definition.name))OR(SELF.of_shape.definition \ product_definition.name = 'interconnect module')));
	WR17 : (NOT(SELF  \ shape_aspect.description = 'interconnect module component terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))= 1);
	WR18 : (NOT(SELF  \ shape_aspect.description IN  [ 'land join terminal', 'non functional land join terminal' ]))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(TRUE))))= 1);
	WR20 : (NOT(SELF  \ shape_aspect.description = 'minimally defined terminal'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'part terminal external reference'))= 1);
	WR22 : (NOT(SELF  \ shape_aspect.description = 'package terminal occurrence'))OR(SIZEOF(QUERY(ud <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'usage definition')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(ud.relating_shape_aspect))))= 1);
	WR23 : (NOT(SELF  \ shape_aspect.description IN  [ 'package terminal occurrence', 'packaged component join terminal' ]))OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence'));
	WR24 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(i_f.relating_shape_aspect \ shape_aspect.description = 'join terminal')))= 1);
	WR25 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2))<= 2))<= 1))<= 1);
	WR26 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'maximum wire length'))<= 1))<= 1))<= 1);
	WR27 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'minimum wire length'))<= 1))<= 1))<= 1);
	WR28 : (NOT(SELF  \ shape_aspect.description = 'printed component join terminal'))OR((SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'layout occurrence')AND(SELF.of_shape.definition \ product_definition.name = 'interconnect module'));
	WR29 : (NOT(SELF  \ shape_aspect.description = 'printed component join terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(i_f.relating_shape_aspect \ shape_aspect.description = 'join terminal')))= 1);
	WR30 : (NOT(SELF  \ shape_aspect.description = 'printed component join terminal'))OR(SIZEOF(QUERY(i <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| pdr \ shape_aspect_relationship.name = 'implementation')|((SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(i.relating_shape_aspect))>= 1)AND(i.relating_shape_aspect \ shape_aspect.description = 'stratum feature template component'))))= 1);
	WR32 : (NOT(SELF  \ shape_aspect.description = 'via terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| i_f.relating_shape_aspect \ shape_aspect.description = 'via template terminal'))= 1);
	WR33 : (NOT(SELF  \ shape_aspect.description = 'interconnect component join terminal'))OR((SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence')AND NOT(SELF.of_shape.definition \ product_definition.description IN [ 'assembly module component', 'bare die component', 'interconnect module component', 'laminate component', 'packaged component' ]));
	WR34 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(dri <* pdr.used_representation.items |(dri \ representation_item.name = 'global swappable')AND(dri \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1))<= 1 ;
	WR35 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(dri <* pdr.used_representation.items |(dri \ representation_item.name = 'local swappable')AND(dri \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1))<= 1 ;
	WR36 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(dri <* pdr.used_representation.items | dri \ representation_item.name = 'swap code'))= 1))= 1))<= 1 ;
END_ENTITY; -- component_terminal


ENTITY make_from_feature_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.relating_shape_aspect))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.related_shape_aspect))= 1 ;
	WR3 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN  TYPEOF(SELF.relating_shape_aspect)))OR(SELF.relating_shape_aspect \ shape_aspect.description IN [ 'component feature', 'component termination passage interface terminal', 'land or non functional land interface terminal', 'printed connector component interface terminal' ]);
	WR4 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN  TYPEOF(SELF.related_shape_aspect)))OR(SELF.related_shape_aspect \ shape_aspect.description IN [ 'component feature', 'component termination passage interface terminal', 'land or non functional land interface terminal', 'printed connector component interface terminal' ]);
END_ENTITY; -- make_from_feature_relationship


ENTITY array_placement_group_component_definition
	SUPERTYPE OF (ONEOF (linear_array_placement_group_component_definition, rectangular_array_placement_group_component_definition))
	SUBTYPE OF (assembly_group_component_definition);
END_ENTITY; -- array_placement_group_component_definition


ENTITY array_placement_group_component_shape_aspect
	SUPERTYPE OF (ONEOF (linear_array_placement_group_component_shape_aspect, rectangular_array_placement_group_component_shape_aspect))
	SUBTYPE OF (assembly_group_component_shape_aspect);
END_ENTITY; -- array_placement_group_component_shape_aspect


ENTITY assembly_group_component_definition
	SUBTYPE OF (component_definition);
WHERE
	WR1 : (SIZEOF(QUERY(gc <* QUERY(pdr <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'group component')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(gc.related_product_definition))))>= 1)OR(SIZEOF(QUERY(agcsa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(agcsa))))= 0);
	WR2 : (SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(acu <* USEDIN(aj \ shape_aspect_relationship.relating_shape_aspect, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))>= 1)))>= 1);
	WR3 : (SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(acu <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))= 0)))= 0);
	WR4 : (SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(cl <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect.of_shape.definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_LOCATION' IN  TYPEOF(cl))AND(aj IN cl \ representation.items)))= 0)))= 0);
END_ENTITY; -- assembly_group_component_definition


ENTITY assembly_group_component_definition_placement_link
	SUBTYPE OF (product_definition, product_definition_relationship);
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.related_product_definition);
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.relating_product_definition);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF  \ product_definition_relationship || SELF \ assembly_group_component_definition_placement_link))= 0 ;
	WR5 :  SELF \ product_definition.name = '' ;
	WR6 :  SELF \ product_definition_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))= 1 ;
END_ENTITY; -- assembly_group_component_definition_placement_link


ENTITY assembly_group_component_shape_aspect
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 : (SIZEOF(QUERY(gc <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'group component')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(gc.related_shape_aspect))))>= 1);
END_ENTITY; -- assembly_group_component_shape_aspect


ENTITY assembly_group_component_shape_aspect_placement_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ assembly_group_component_shape_aspect_placement_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))= 1 ;
END_ENTITY; -- assembly_group_component_shape_aspect_placement_link


ENTITY interfaced_group_component_definition
	SUBTYPE OF (assembly_group_component_definition);
WHERE
	WR1 : (SIZEOF(QUERY(gc <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'group component')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(gc.related_product_definition))))>= 1);
END_ENTITY; -- interfaced_group_component_definition


ENTITY linear_array_component_definition_link
	SUBTYPE OF (product_definition, product_definition_relationship);
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.related_product_definition);
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.relating_product_definition);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF  \ product_definition_relationship || SELF \ linear_array_component_definition_link))= 0 ;
	WR5 :  SELF \ product_definition.name = '' ;
	WR6 :  SELF \ product_definition_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))= 1 ;
END_ENTITY; -- linear_array_component_definition_link


ENTITY linear_array_component_shape_aspect_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ linear_array_component_shape_aspect_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))= 1 ;
END_ENTITY; -- linear_array_component_shape_aspect_link


ENTITY linear_array_placement_group_component_definition
	SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY; -- linear_array_placement_group_component_definition


ENTITY linear_array_placement_group_component_shape_aspect
	SUBTYPE OF (array_placement_group_component_shape_aspect);
END_ENTITY; -- linear_array_placement_group_component_shape_aspect


ENTITY rectangular_array_placement_group_component_definition
	SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY; -- rectangular_array_placement_group_component_definition


ENTITY rectangular_array_placement_group_component_shape_aspect
	SUBTYPE OF (array_placement_group_component_shape_aspect);
END_ENTITY; -- rectangular_array_placement_group_component_shape_aspect


ENTITY configurable_item
	SUBTYPE OF (configuration_item);
	item_concept_feature : SET [1:?] OF product_concept_feature_association;
END_ENTITY; -- configurable_item


ENTITY configuration_design;
	configuration : configuration_item;
	design : configuration_design_item;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
UNIQUE
	UR1 : configuration, design;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- configuration_design


ENTITY configuration_effectivity
	SUBTYPE OF (product_definition_effectivity);
	configuration : configuration_design;
UNIQUE
	UR1 : configuration, usage, id;
WHERE
	WR1 :  'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF \ product_definition_effectivity.usage);
END_ENTITY; -- configuration_effectivity


ENTITY configuration_item;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	item_concept : product_concept;
	purpose : OPTIONAL label;
END_ENTITY; -- configuration_item


ENTITY configuration_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_configuration_item : configuration_item;
	related_configuration_item : configuration_item;
END_ENTITY; -- configuration_item_relationship


ENTITY applied_contract_assignment
	SUBTYPE OF (contract_assignment);
	items : SET [1:?] OF contract_item;
END_ENTITY; -- applied_contract_assignment


ENTITY contract;
	name : label;
	purpose : text;
	kind : contract_type;
END_ENTITY; -- contract


ENTITY contract_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_contract : contract;
	related_contract : contract;
END_ENTITY; -- contract_relationship


ENTITY contract_type;
	description : label;
END_ENTITY; -- contract_type


ENTITY applied_date_and_time_assignment
	SUBTYPE OF (date_and_time_assignment);
	items : SET [1:?] OF date_and_time_item;
END_ENTITY; -- applied_date_and_time_assignment


ENTITY applied_date_assignment
	SUBTYPE OF (date_assignment);
	items : SET [1:?] OF date_item;
END_ENTITY; -- applied_date_assignment


ENTITY calendar_date
	SUBTYPE OF (date);
	day_component : day_in_month_number;
	month_component : month_in_year_number;
WHERE
	WR1 :  valid_calendar_date(SELF);
END_ENTITY; -- calendar_date


ENTITY coordinated_universal_time_offset;
	hour_offset : INTEGER;
	minute_offset : OPTIONAL INTEGER;
	sense : ahead_or_behind;
DERIVE
	actual_minute_offset : INTEGER :=  NVL(minute_offset, 0);
WHERE
	WR1 :  { 0 <= hour_offset < 24 } ;
	WR2 :  { 0 <= actual_minute_offset <= 59 } ;
	WR3 :  NOT(((hour_offset <> 0)OR(actual_minute_offset <> 0))AND(sense = exact));
END_ENTITY; -- coordinated_universal_time_offset


ENTITY date
	SUPERTYPE OF (ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date));
	year_component : year_number;
END_ENTITY; -- date


ENTITY date_and_time;
	date_component : date;
	time_component : local_time;
END_ENTITY; -- date_and_time


ENTITY date_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- date_role


ENTITY date_time_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- date_time_role


ENTITY event_occurrence;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence


ENTITY event_occurrence_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence_context_role


ENTITY event_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	relating_event : event_occurrence;
	related_event : event_occurrence;
END_ENTITY; -- event_occurrence_relationship


ENTITY event_occurrence_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence_role


ENTITY local_time;
	hour_component : hour_in_day;
	minute_component : OPTIONAL minute_in_hour;
	second_component : OPTIONAL second_in_minute;
	zone : coordinated_universal_time_offset;
WHERE
	WR1 :  valid_time(SELF);
END_ENTITY; -- local_time


ENTITY ordinal_date
	SUBTYPE OF (date);
	day_component : day_in_year_number;
WHERE
	WR1 : (NOT leap_year(SELF.year_component)AND  { 1 <= day_component <= 365 })OR(leap_year(SELF.year_component)AND { 1 <= day_component <= 366 });
END_ENTITY; -- ordinal_date


ENTITY relative_event_occurrence
	SUBTYPE OF (event_occurrence);
	base_event : event_occurrence;
	offset : time_measure_with_unit;
END_ENTITY; -- relative_event_occurrence


ENTITY time_interval;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- time_interval


ENTITY time_interval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_time_interval : time_interval;
	related_time_interval : time_interval;
END_ENTITY; -- time_interval_relationship


ENTITY time_interval_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- time_interval_role


ENTITY time_interval_with_bounds
	SUBTYPE OF (time_interval);
	primary_bound : OPTIONAL date_time_or_event_occurrence;
	secondary_bound : OPTIONAL date_time_or_event_occurrence;
	duration : OPTIONAL time_measure_with_unit;
WHERE
	WR1 :  NOT(EXISTS(secondary_bound)AND EXISTS(duration));
	WR2 :  EXISTS(primary_bound)OR EXISTS(secondary_bound);
END_ENTITY; -- time_interval_with_bounds


ENTITY time_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- time_role


ENTITY week_of_year_and_day_date
	SUBTYPE OF (date);
	week_component : week_in_year_number;
	day_component : OPTIONAL day_in_week_number;
END_ENTITY; -- week_of_year_and_day_date


ENTITY add_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object addition')))= 1 ;
END_ENTITY; -- add_design_object_assignment


ENTITY add_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object addition')))= 1 ;
END_ENTITY; -- add_design_object_request_assignment


ENTITY change_from_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_assignment.assigned_action, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHANGE_TO_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
END_ENTITY; -- change_from_design_object_assignment


ENTITY change_from_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_request_assignment.assigned_action_request, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHANGE_TO_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
END_ENTITY; -- change_from_design_object_request_assignment


ENTITY change_to_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_assignment.assigned_action, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHANGE_FROM_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr))AND(pdr \ product_definition_relationship.name = 'design object change')))= 1 ;
END_ENTITY; -- change_to_design_object_assignment


ENTITY change_to_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_request_assignment.assigned_action_request, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHANGE_FROM_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr))AND(pdr \ product_definition_relationship.name = 'design object change')))= 1 ;
END_ENTITY; -- change_to_design_object_request_assignment


ENTITY delete_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object deletion')))= 1 ;
END_ENTITY; -- delete_design_object_assignment


ENTITY delete_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object deletion')))= 1 ;
END_ENTITY; -- delete_design_object_request_assignment


ENTITY frozen_assignment
	SUBTYPE OF (approval_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SELF \ approval_assignment.assigned_approval.status.name IN [ 'approved', 'not yet approved' ] ;
END_ENTITY; -- frozen_assignment


ENTITY directed_dimensional_location
	SUBTYPE OF (dimensional_location);
END_ENTITY; -- directed_dimensional_location


ENTITY externally_defined_dimension_definition
	SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
	WR1 : (SELF  \ externally_defined_item.item_id = 'external size dimension')AND(SELF \ externally_defined_item.source.source_id = 'external size dimension specification');
	WR2 :  1 >= SIZEOF(QUERY(adr <* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adr.assigned_document.description = 'external size dimension specification')));
END_ENTITY; -- externally_defined_dimension_definition


ENTITY applied_document_reference
	SUBTYPE OF (document_reference);
	items : SET [1:?] OF document_reference_item;
END_ENTITY; -- applied_document_reference


ENTITY applied_document_usage_constraint_assignment
	SUBTYPE OF (document_usage_constraint_assignment);
	items : SET [1:?] OF document_reference_item;
END_ENTITY; -- applied_document_usage_constraint_assignment


ENTITY document_product_equivalence
	SUBTYPE OF (document_product_association);
WHERE
	WR1 :  SELF \ document_product_association.name = 'equivalence' ;
	WR2 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRODUCT' IN TYPEOF(SELF  \ document_product_association.related_product))OR((SELF  \ document_product_association.relating_document.kind.product_data_type = 'configuration controlled document')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF \ document_product_association.related_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
	WR3 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product))OR((SELF  \ document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF.related_product \ product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
	WR4 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product))OR((SELF  \ document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF \ document_product_association.related_product \ product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
END_ENTITY; -- document_product_equivalence


ENTITY document;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	kind : document_type;
INVERSE
	representation_types: SET [0:?] OF document_representation_type FOR represented_document;
END_ENTITY; -- document


ENTITY document_product_association;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_product : product_or_formation_or_definition;
END_ENTITY; -- document_product_association


ENTITY document_relationship;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_document : document;
END_ENTITY; -- document_relationship


ENTITY document_representation_type;
	name : label;
	represented_document : document;
END_ENTITY; -- document_representation_type


ENTITY document_type;
	product_data_type : label;
END_ENTITY; -- document_type


ENTITY document_usage_constraint;
	source : document;
	subject_element : label;
	subject_element_value : text;
END_ENTITY; -- document_usage_constraint


ENTITY document_with_class
	SUBTYPE OF (document);
	class : identifier;
END_ENTITY; -- document_with_class


ENTITY applied_effectivity_assignment
	SUBTYPE OF (effectivity_assignment);
	items : SET [1:?] OF effectivity_item;
END_ENTITY; -- applied_effectivity_assignment


ENTITY dated_effectivity
	SUBTYPE OF (effectivity);
	effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
	effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY; -- dated_effectivity


ENTITY effectivity
	SUPERTYPE OF (ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity));
	id : identifier;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- effectivity


ENTITY effectivity_relationship;
	name : label;
	description : OPTIONAL text;
	related_effectivity : effectivity;
	relating_effectivity : effectivity;
END_ENTITY; -- effectivity_relationship


ENTITY lot_effectivity
	SUBTYPE OF (effectivity);
	effectivity_lot_id : identifier;
	effectivity_lot_size : measure_with_unit;
END_ENTITY; -- lot_effectivity


ENTITY serial_numbered_effectivity
	SUBTYPE OF (effectivity);
	effectivity_start_id : identifier;
	effectivity_end_id : OPTIONAL identifier;
END_ENTITY; -- serial_numbered_effectivity


ENTITY time_interval_based_effectivity
	SUBTYPE OF (effectivity);
	effectivity_period : time_interval;
END_ENTITY; -- time_interval_based_effectivity


ENTITY applied_event_occurrence_assignment
	SUBTYPE OF (event_occurrence_assignment);
	items : SET [1:?] OF event_occurrence_item;
END_ENTITY; -- applied_event_occurrence_assignment


ENTITY experience;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience


ENTITY experience_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_experience : experience;
	related_experience : experience;
END_ENTITY; -- experience_relationship


ENTITY experience_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_type


ENTITY experience_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_experience_type : experience_type;
	related_experience_type : experience_type;
END_ENTITY; -- experience_type_relationship


ENTITY auxiliary_characteristic_dimension_representation
	SUBTYPE OF (dimensional_characteristic_representation);
END_ENTITY; -- auxiliary_characteristic_dimension_representation


ENTITY curve_dimension
	SUBTYPE OF (dimensional_size);
WHERE
	WR1 :  SELF \ dimensional_size.name <> 'angular' ;
END_ENTITY; -- curve_dimension


ENTITY datum_difference
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_DATUM' IN  TYPEOF(SELF  \ shape_aspect_relationship.relating_shape_aspect))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect));
	WR2 :  SELF  \ shape_aspect.name = SELF \ shape_aspect_relationship.name ;
	WR3 :  SELF  \ shape_aspect.description = SELF \ shape_aspect_relationship.description ;
	WR4 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR5 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ datum_difference)))= 0 ;
END_ENTITY; -- datum_difference


ENTITY datum_difference_based_characteristic
	SUBTYPE OF (representation_item);
WHERE
	WR1 :  SIZEOF(QUERY(r <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')|(SIZEOF(QUERY(prd2 <* QUERY(prd <* USEDIN(r, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|((('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION')IN  TYPEOF(prd))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION')IN  TYPEOF(prd \ property_definition_representation.definition))))|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_DIFFERENCE' IN TYPEOF(prd2 \ property_definition_representation.definition \ property_definition.definition))))= 1)))= 1 ;
END_ENTITY; -- datum_difference_based_characteristic


ENTITY dimensional_size_property
	SUBTYPE OF (dimensional_size, property_definition);
END_ENTITY; -- dimensional_size_property


ENTITY edge_segment_vertex
	SUBTYPE OF (physical_unit_datum);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ physical_unit_datum || SELF \ edge_segment_vertex))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| pd \ property_definition.description = 'shape element characterization'))= 1 ;
	WR3 :  SELF \ shape_aspect.of_shape \ property_definition.definition.frame_of_reference \ application_context_element.name IN [ 'physical design occurrence', 'physical design usage' ] ;
	WR4 :  SELF \ shape_aspect.name = 'single datum' ;
END_ENTITY; -- edge_segment_vertex


ENTITY geometric_tolerance_group
	SUBTYPE OF (property_definition);
WHERE
	WR1 :  SELF \ property_definition.description IN [ 'separate requirement', 'simultaneous requirement' ] ;
	WR2 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'group geometric tolerance')))>= 1);
	WR3 : (NOT(SELF  \ property_definition.description = 'simultaneous requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))>= 2);
	WR4 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.name = 'linear profile refinement')AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))= 0);
	WR5 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.name = 'surface profile refinement')AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))= 0);
	WR6 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITION_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.name = 'feature relating position')AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))= 0);
	WR7 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'group geometric tolerance')AND(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SURFACE_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITION_TOLERANCE' ] * TYPEOF(pdr.related_property_definition))> 0)))= 0);
END_ENTITY; -- geometric_tolerance_group


ENTITY linear_profile_tolerance
	SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
	WR1 : (NOT(SELF  \ geometric_tolerance.name = 'linear profile refinement'))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control')AND((gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile locating')OR(gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement')))))= 1);
	WR2 : (NOT(SELF  \ geometric_tolerance.name = 'linear profile locating'))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement'))AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control')))= 1);
	WR3 : (NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN  TYPEOF(SELF))AND(SELF  \ geometric_tolerance.name = 'linear profile refinement')))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement')AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control')))= 0);
	WR4 : (NOT(SELF  \ geometric_tolerance.name = 'linear profile refinement'))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr.related_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement')AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control'))))<= 1);
	WR5 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
END_ENTITY; -- linear_profile_tolerance


ENTITY opposing_boundary_dimensional_size
	SUBTYPE OF (dimensional_size);
WHERE
	WR1 :  SELF \ dimensional_size.name IN [ 'angular', 'linear' ] ;
END_ENTITY; -- opposing_boundary_dimensional_size


ENTITY physical_unit_datum
	SUPERTYPE OF (edge_segment_vertex)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'axis', 'plane', 'point', '' ] ;
	WR2 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR3 :  SELF \ shape_aspect.name IN [ 'single datum', 'common datum', '' ] ;
	WR4 : (NOT(SELF  \ shape_aspect.name = 'common datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum feature usage in  datum system')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_SYSTEM' IN TYPEOF(SAR))))>= 1);
	WR5 : (NOT(SELF  \ shape_aspect.name = 'common datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum feature usage in  common datum')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_SYSTEM' IN TYPEOF(SAR))))>= 2);
	WR6 : (NOT((SELF  \ shape_aspect.description = 'axis')AND(SELF  \ shape_aspect.name IN  [ 'common datum', 'single datum' ])))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT(sar \ shape_aspect_relationship.name = 'reference axis')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR))))= 1);
	WR7 : (NOT((SELF  \ shape_aspect.description = 'plane')AND(SELF  \ shape_aspect.name IN  [ 'common datum', 'single datum' ])))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT(sar \ shape_aspect_relationship.name = 'reference plane')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR))))= 1);
	WR8 : (NOT((SELF  \ shape_aspect.description = 'point')AND(SELF  \ shape_aspect.name IN  [ 'common datum', 'single datum' ])))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT(sar \ shape_aspect_relationship.name = 'reference origin')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR))))= 1);
	WR9 : (NOT(SELF  \ shape_aspect.name = 'single datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum usage in  datum system')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_SYSTEM' IN TYPEOF(SAR))))>= 1);
	WR10 : (NOT(SELF  \ shape_aspect.name = 'single datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum feature usage in single datum')AND(TRUE)))<= 1);
	WR11 :  NOT((SELF  \ shape_aspect.name IN  [ '' ])AND(SELF \ shape_aspect.description IN [ '' ]));
	WR12 : (NOT(SELF  \ shape_aspect.description = 'plane'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| pd \ property_definition.description = 'datum direction property'))<= 2);
END_ENTITY; -- physical_unit_datum


ENTITY physical_unit_datum_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')|(pd \ property_definition.description = 'datum feature identification'))))= 1 ;
	WR2 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name IN  [ 'datum feature usage in  common datum', 'datum feature usage in single datum' ]))>= 1);
	WR3 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'datum feature usage in single datum'))<= 1);
END_ENTITY; -- physical_unit_datum_feature


ENTITY physical_unit_datum_target_set
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'datum target usage'))>= 1);
	WR2 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'constituent'))= 0);
END_ENTITY; -- physical_unit_datum_target_set


ENTITY physical_unit_geometric_tolerance
	SUBTYPE OF (geometric_tolerance, property_definition);
WHERE
	WR1 :  SELF  \ geometric_tolerance.name = SELF \ property_definition.name ;
	WR2 :  SELF  \ geometric_tolerance.toleranced_shape_aspect = SELF \ property_definition.definition ;
	WR3 : (NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SURFACE_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITION_TOLERANCE' ] * TYPEOF(SELF))= 0))OR(SELF \ geometric_tolerance.name IN [ 'circularity', 'cylindricity', 'flatness', 'straightness' ]);
	WR4 : (NOT(SELF  \ geometric_tolerance.name = 'circularity'))OR(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
	WR5 : (NOT(SELF  \ geometric_tolerance.name = 'cylindricity'))OR(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
	WR6 : (NOT(SELF  \ geometric_tolerance.name = 'flatness'))OR(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
	WR7 : (SIZEOF(QUERY(pugt <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'group geometric tolerance')| pugt.relating_shape_aspect \ shape_aspect.description = 'simultaneous requirement'))<= 1);
END_ENTITY; -- physical_unit_geometric_tolerance


ENTITY positional_boundary
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'dimension related positional boundary', 'profile related positional boundary' ] ;
	WR2 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR3 : (NOT(SELF  \ shape_aspect.description = 'dimension related positional boundary'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'boundary member')))>= 1);
	WR4 : (NOT(SELF  \ shape_aspect.description = 'dimension related positional boundary'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar.related_shape_aspect.product_definitional = TRUE)AND(sar \ shape_aspect_relationship.name = 'constrained feature')))+ SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.related_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'constrained feature')))= 1);
	WR5 : (NOT(SELF  \ shape_aspect.description = 'dimension related positional boundary'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'dimension related positional boundary property')))= 1);
	WR6 : (NOT(SELF  \ shape_aspect.description = 'profile related positional boundary'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'profile related positional boundary property')))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'profile related positional boundary'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'positional boundary and profile boundary member')))= 1);
END_ENTITY; -- positional_boundary


ENTITY positional_boundary_member
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'positional boundary member property')))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'boundary member')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'dimension related positional boundary')))= 1 ;
END_ENTITY; -- positional_boundary_member


ENTITY statistical_dimensional_location
	SUBTYPE OF (dimensional_location);
END_ENTITY; -- statistical_dimensional_location


ENTITY statistical_dimensional_size
	SUBTYPE OF (dimensional_size_property);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'substitutable dimension')))<= 1)))<= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'dimensional tolerance statistical control requirement')))<= 1)))<= 1 ;
	WR3 : (NOT(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DIMENSIONAL_SIZE' IN  TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'substitutable dimension')))<= 1)))<= 1))OR(NOT(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DIMENSIONAL_SIZE' IN  TYPEOF(pdr.related_property_definition))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STATISTICAL_DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)))AND(pdr \ property_definition_relationship.name = 'substitutable dimension')))<= 1)))<= 1));
END_ENTITY; -- statistical_dimensional_size


ENTITY statistical_geometric_tolerance
	SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
	WR1 :  SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr \ geometric_tolerance_relationship.name = 'substitutable geometric tolerance')))<= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'geometric tolerance statistical control requirement')))= 1 ;
	WR3 :  SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STATISTICAL_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr \ geometric_tolerance_relationship.name = 'substitutable geometric tolerance')))<= 0 ;
END_ENTITY; -- statistical_geometric_tolerance


ENTITY tolerance_zone_boundary
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : (NOT(SELF  \ shape_aspect.description = 'conical'))OR(NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF))));
	WR2 : (NOT(SELF  \ shape_aspect.description = 'circular or  cylindrical or  spherical'))OR(NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF))));
	WR3 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR4 :  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN  TYPEOF(SELF))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
	WR5 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'boundary zone definition with specified size')OR(pd \ property_definition.description = 'conical tolerance zone boundary')))= 1 ;
	WR6 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TOLERANCE_ZONE_DEFINITION.BOUNDARIES'))= 1 ;
END_ENTITY; -- tolerance_zone_boundary


ENTITY tolerance_zone_explicit_opposing_boundary_set
	SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY; -- tolerance_zone_explicit_opposing_boundary_set


ENTITY tolerance_zone_implicit_opposing_boundary_set
	SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY; -- tolerance_zone_implicit_opposing_boundary_set


ENTITY viewing_plane
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description = 'affected plane' ;
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')|(pd \ property_definition.description = 'viewing plane property'))))= 1 ;
	WR3 :  NOT SELF \ shape_aspect.product_definitional ;
END_ENTITY; -- viewing_plane


ENTITY value_range
	SUBTYPE OF (compound_representation_item);
WHERE
	WR1 : ('value_with_unit_mim.' + 'SET_REPRESENTATION_ITEM' IN TYPEOF(item_element))AND value_range_wr1(item_element);
	WR2 :  value_range_wr2(item_element);
	WR3 :  value_range_wr3(item_element);
END_ENTITY; -- value_range


ENTITY external_class_library
	SUBTYPE OF (external_source);
END_ENTITY; -- external_class_library


ENTITY externally_defined_class
	SUBTYPE OF (class, externally_defined_item);
END_ENTITY; -- externally_defined_class


ENTITY applied_external_identification_assignment
	SUBTYPE OF (external_identification_assignment);
	items : SET [1:?] OF external_identification_item;
END_ENTITY; -- applied_external_identification_assignment


ENTITY external_source;
	source_id : source_item;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- external_source


ENTITY external_source_relationship;
	name : label;
	description : OPTIONAL text;
	relating_source : external_source;
	related_source : external_source;
END_ENTITY; -- external_source_relationship


ENTITY externally_defined_item;
	item_id : source_item;
	source : external_source;
END_ENTITY; -- externally_defined_item


ENTITY externally_defined_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_item : externally_defined_item;
	related_item : externally_defined_item;
END_ENTITY; -- externally_defined_item_relationship


ENTITY pre_defined_item;
	name : label;
END_ENTITY; -- pre_defined_item


ENTITY connection_zone_interface_plane_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect_relationship || SELF  \ connection_zone_interface_plane_relationship || SELF \ shape_aspect))= 0 ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR3 :  SELF \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'plane' ;
	WR4 :  SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'connection zone' ;
	WR5 :  SELF \ shape_aspect_relationship.description IN [ 'area', 'edge' ] ;
	WR6 :  SELF  \ shape_aspect.of_shape = SELF \ shape_aspect_relationship.related_shape_aspect.of_shape ;
	WR7 :  SELF  \ shape_aspect.of_shape = SELF \ shape_aspect_relationship.relating_shape_aspect.of_shape ;
	WR8 :  SIZEOF(QUERY(dz <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'derived zone')| dz.related_shape_aspect \ shape_aspect.description = 'connection zone'))= 1 ;
END_ENTITY; -- connection_zone_interface_plane_relationship


ENTITY document_file
	SUBTYPE OF (document, characterized_object);
WHERE
	WR1 :  SELF \ characterized_object.name = '' ;
	WR2 :  NOT EXISTS(SELF \ characterized_object.description);
	WR3 :  SIZEOF(QUERY(drt <* SELF \ document.representation_types | drt.name IN [ 'digital', 'physical' ]))= 1 ;
END_ENTITY; -- document_file


ENTITY make_from_connectivity_relationship
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.relating_shape_aspect);
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.related_shape_aspect);
END_ENTITY; -- make_from_connectivity_relationship


ENTITY physical_connectivity_definition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name, of_shape;
WHERE
	WR1 :  SIZEOF(QUERY(at <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated terminals')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(at.related_shape_aspect))AND((at.related_shape_aspect \ shape_aspect.description = 'assembly module component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'bare die component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'interconnect component join terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'interconnect module component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'minimally defined component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'packaged component join terminal'))))> 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'connectivity allocation'))= 1)))<= 1 ;
END_ENTITY; -- physical_connectivity_definition


ENTITY physical_connectivity_element
	SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
	WR1 : (SELF.relating_shape_aspect \ shape_aspect.description = 'topological junction')XOR(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' ] * TYPEOF(SELF.relating_shape_aspect))= 1);
	WR2 : (SELF.related_shape_aspect \ shape_aspect.description = 'topological junction')XOR(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' ] * TYPEOF(SELF.related_shape_aspect))= 1);
	WR3 :  SIZEOF(QUERY(se <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'structure element')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(se.relating_shape_aspect)))= 1 ;
	WR4 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical design');
END_ENTITY; -- physical_connectivity_element


ENTITY physical_unit_network_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SELF.frame_of_reference.name IN [ 'physical network design' ] ;
END_ENTITY; -- physical_unit_network_definition


ENTITY functional_specification
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(rr \ representation_relationship.name = 'functional characteristic category')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNAL_DEFINITION' IN TYPEOF(rr.rep_1.items [ 1 ]))))= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr \ representation_relationship.name = 'characterizing signal' + 'for functional specification')))= 1 ;
	WR3 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr \ representation_relationship.name = 'reference signal for' + 'functional specification')))= 1 ;
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ functional_specification))= 0 ;
	WR5 :  SELF \ representation.name = '' ;
	WR6 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.definition.definition))))= 0 ;
END_ENTITY; -- functional_specification


ENTITY functional_specification_definition
	SUBTYPE OF (functional_unit);
WHERE
	WR1 :  SELF.frame_of_reference \ application_context_element.name = 'functional network design' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_SPECIFICATION' IN TYPEOF(pdr.used_representation))))> 0)))> 0 ;
END_ENTITY; -- functional_specification_definition


ENTITY general_material_property
	SUBTYPE OF (general_property);
WHERE
	WR1 :  SIZEOF(QUERY(gpa <* USEDIN(SELF, 'MATERIAL_ASPECTS_MIM.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION')| NOT('MATERIAL_ASPECTS_MIM.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition))))= 0 ;
END_ENTITY; -- general_material_property


ENTITY block
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
END_ENTITY; -- block


ENTITY boolean_result
	SUBTYPE OF (geometric_representation_item);
	operator : boolean_operator;
	first_operand : boolean_operand;
	second_operand : boolean_operand;
END_ENTITY; -- boolean_result


ENTITY box_domain
	SUBTYPE OF (founded_item);
	corner : cartesian_point;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	zlength : positive_length_measure;
WHERE
	WR1 :  SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOXED_HALF_SPACE' IN TYPEOF(item))))= 0 ;
END_ENTITY; -- box_domain


ENTITY boxed_half_space
	SUBTYPE OF (half_space_solid);
	enclosure : box_domain;
END_ENTITY; -- boxed_half_space


ENTITY brep_2d
	SUBTYPE OF (solid_model);
	extent : face;
WHERE
	WR1 :  SIZEOF([ 'TOPOLOGY_SCHEMA.FACE_SURFACE', 'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE' ] * TYPEOF(SELF.extent))= 0 ;
	WR2 :  SIZEOF(QUERY(bnds <* extent.bounds | NOT('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))))= 0 ;
	WR3 :  SIZEOF(QUERY(bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))= 1 ;
	WR4 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT(('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element))AND(oe.edge_element \ geometric_representation_item.dim = 2))))= 0)))= 0 ;
END_ENTITY; -- brep_2d


ENTITY brep_with_voids
	SUBTYPE OF (manifold_solid_brep);
	voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY; -- brep_with_voids


ENTITY circular_area
	SUBTYPE OF (primitive_2d);
	centre : cartesian_point;
	radius : positive_length_measure;
END_ENTITY; -- circular_area


ENTITY convex_hexahedron
	SUBTYPE OF (faceted_primitive);
WHERE
	WR1 :  SIZEOF(points)= 8 ;
	WR2 :  above_plane(points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ])= 0.0 ;
	WR3 :  above_plane(points [ 5 ], points [ 8 ], points [ 7 ], points [ 6 ])= 0.0 ;
	WR4 :  above_plane(points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ])= 0.0 ;
	WR5 :  above_plane(points [ 4 ], points [ 3 ], points [ 7 ], points [ 8 ])= 0.0 ;
	WR6 :  above_plane(points [ 3 ], points [ 2 ], points [ 6 ], points [ 7 ])= 0.0 ;
	WR7 :  above_plane(points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ])= 0.0 ;
	WR8 :  same_side([ points [ 1 ], points [ 2 ], points [ 3 ] ], [ points [ 5 ], points [ 6 ], points [ 7 ], points [ 8 ] ]);
	WR9 :  same_side([ points [ 1 ], points [ 4 ], points [ 8 ] ], [ points [ 3 ], points [ 7 ], points [ 6 ], points [ 2 ] ]);
	WR10 :  same_side([ points [ 1 ], points [ 2 ], points [ 5 ] ], [ points [ 3 ], points [ 7 ], points [ 8 ], points [ 4 ] ]);
	WR11 :  same_side([ points [ 5 ], points [ 6 ], points [ 7 ] ], [ points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ] ]);
	WR12 :  same_side([ points [ 3 ], points [ 7 ], points [ 6 ] ], [ points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ] ]);
	WR13 :  same_side([ points [ 3 ], points [ 7 ], points [ 8 ] ], [ points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ] ]);
END_ENTITY; -- convex_hexahedron


ENTITY csg_solid
	SUBTYPE OF (solid_model);
	tree_root_expression : csg_select;
END_ENTITY; -- csg_solid


ENTITY cyclide_segment_solid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	radius1 : positive_length_measure;
	radius2 : positive_length_measure;
	cone_angle1 : plane_angle_measure;
	cone_angle2 : plane_angle_measure;
	turn_angle : plane_angle_measure;
END_ENTITY; -- cyclide_segment_solid


ENTITY eccentric_cone
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	height : positive_length_measure;
	x_offset : length_measure;
	y_offset : length_measure;
	ratio : REAL;
WHERE
	WR1 :  ratio >= 0.0 ;
END_ENTITY; -- eccentric_cone


ENTITY edge_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	ebwm_boundary : SET [1:?] OF connected_edge_set;
END_ENTITY; -- edge_based_wireframe_model


ENTITY ellipsoid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	semi_axis_3 : positive_length_measure;
END_ENTITY; -- ellipsoid


ENTITY elliptic_area
	SUBTYPE OF (primitive_2d);
	position : axis2_placement_2d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
END_ENTITY; -- elliptic_area


ENTITY extruded_area_solid
	SUBTYPE OF (swept_area_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 :  dot_product((SELF \ swept_area_solid.swept_area.basis_surface \ elementary_surface.position.p [ 3 ]), extruded_direction)<> 0.0 ;
END_ENTITY; -- extruded_area_solid


ENTITY extruded_face_solid
	SUBTYPE OF (swept_face_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 :  dot_product((SELF \ swept_face_solid.swept_face.face_geometry \ elementary_surface.position.p [ 3 ]), extruded_direction)<> 0.0 ;
END_ENTITY; -- extruded_face_solid


ENTITY face_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	fbsm_faces : SET [1:?] OF connected_face_set;
END_ENTITY; -- face_based_surface_model


ENTITY faceted_brep
	SUBTYPE OF (manifold_solid_brep);
END_ENTITY; -- faceted_brep


ENTITY faceted_primitive
	SUPERTYPE OF (ONEOF (tetrahedron, convex_hexahedron))
	SUBTYPE OF (geometric_representation_item);
	points : LIST [4:?] OF  UNIQUE cartesian_point;
WHERE
	WR1 :  points [ 1 ].dim = 3 ;
END_ENTITY; -- faceted_primitive


ENTITY geometric_curve_set
	SUBTYPE OF (geometric_set);
WHERE
	WR1 :  SIZEOF(QUERY(temp <* SELF \ geometric_set.elements | 'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp)))= 0 ;
END_ENTITY; -- geometric_curve_set


ENTITY geometric_set
	SUPERTYPE OF (ONEOF (geometric_curve_set, geometric_set_replica))
	SUBTYPE OF (geometric_representation_item);
	elements : SET [1:?] OF geometric_set_select;
END_ENTITY; -- geometric_set


ENTITY geometric_set_replica
	SUBTYPE OF (geometric_set);
	parent_set : geometric_set;
	transformation : cartesian_transformation_operator;
DERIVE
	SELF\geometric_set.elements : SET [1:?] OF geometric_set_select :=  build_transformed_set(transformation, parent_set);
WHERE
	WR1 :  acyclic_set_replica(SELF, parent_set);
END_ENTITY; -- geometric_set_replica


ENTITY half_space_2d
	SUBTYPE OF (geometric_representation_item);
	base_curve : curve;
	agreement_flag : BOOLEAN;
END_ENTITY; -- half_space_2d


ENTITY half_space_solid
	SUBTYPE OF (geometric_representation_item);
	base_surface : surface;
	agreement_flag : BOOLEAN;
END_ENTITY; -- half_space_solid


ENTITY manifold_solid_brep
	SUBTYPE OF (solid_model);
	outer : closed_shell;
END_ENTITY; -- manifold_solid_brep


ENTITY polygonal_area
	SUBTYPE OF (primitive_2d);
	bounds : LIST [3:?] OF  UNIQUE cartesian_point;
END_ENTITY; -- polygonal_area


ENTITY primitive_2d
	SUPERTYPE OF (ONEOF (circular_area, elliptic_area, rectangular_area, polygonal_area))
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- primitive_2d


ENTITY rectangle_domain
	SUBTYPE OF (founded_item);
	corner : cartesian_point;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
WHERE
	WR1 :  SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.RECTANGLED_HALF_SPACE' IN TYPEOF(item))))= 0 ;
END_ENTITY; -- rectangle_domain


ENTITY rectangled_half_space
	SUBTYPE OF (half_space_2d);
	enclosure : rectangle_domain;
END_ENTITY; -- rectangled_half_space


ENTITY rectangular_area
	SUBTYPE OF (primitive_2d);
	position : axis2_placement_2d;
	x : positive_length_measure;
	y : positive_length_measure;
END_ENTITY; -- rectangular_area


ENTITY rectangular_pyramid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- rectangular_pyramid


ENTITY revolved_area_solid
	SUBTYPE OF (swept_area_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line :=  representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY; -- revolved_area_solid


ENTITY revolved_face_solid
	SUBTYPE OF (swept_face_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line :=  representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY; -- revolved_face_solid


ENTITY right_angular_wedge
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
	ltx : length_measure;
WHERE
	WR1 : ((0.0 <= ltx)AND(ltx < x));
END_ENTITY; -- right_angular_wedge


ENTITY right_circular_cone
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 :  radius >= 0.0 ;
END_ENTITY; -- right_circular_cone


ENTITY right_circular_cylinder
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : positive_length_measure;
END_ENTITY; -- right_circular_cylinder


ENTITY sectioned_spine
	SUBTYPE OF (geometric_curve_set);
	cross_sections : LIST [2:?] OF curve;
	spine_points : LIST [2:?] OF point;
WHERE
	WR1 :  SIZEOF(SELF \ geometric_set.elements)= 1 ;
	WR2 :  'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF \ geometric_set.elements [ 1 ]);
	WR3 :  SIZEOF(cross_sections)= SIZEOF(spine_points);
	WR4 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- sectioned_spine


ENTITY shell_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	sbsm_boundary : SET [1:?] OF shell;
WHERE
	WR1 :  constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY; -- shell_based_surface_model


ENTITY shell_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	sbwm_boundary : SET [1:?] OF shell;
WHERE
	WR1 :  constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY; -- shell_based_wireframe_model


ENTITY solid_model
	SUPERTYPE OF (ONEOF (csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid, solid_replica, brep_2d, trimmed_volume))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- solid_model


ENTITY solid_replica
	SUBTYPE OF (solid_model);
	parent_solid : solid_model;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 :  acyclic_solid_replica(SELF, parent_solid);
	WR2 :  parent_solid \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- solid_replica


ENTITY sphere
	SUBTYPE OF (geometric_representation_item);
	radius : positive_length_measure;
	centre : point;
END_ENTITY; -- sphere


ENTITY surface_curve_swept_area_solid
	SUBTYPE OF (swept_area_solid);
	directrix : curve;
	start_param : REAL;
	end_param : REAL;
	reference_surface : surface;
WHERE
	WR1 : (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR(reference_surface IN(directrix \ surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_area_solid


ENTITY surface_curve_swept_face_solid
	SUBTYPE OF (swept_face_solid);
	directrix : curve;
	start_param : REAL;
	end_param : REAL;
	reference_surface : surface;
WHERE
	WR1 : (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR(reference_surface IN(directrix \ surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_face_solid


ENTITY swept_area_solid
	SUPERTYPE OF (ONEOF (revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid))
	SUBTYPE OF (solid_model);
	swept_area : curve_bounded_surface;
WHERE
	WR1 :  'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY; -- swept_area_solid


ENTITY swept_disk_solid
	SUBTYPE OF (solid_model);
	directrix : curve;
	radius : positive_length_measure;
	inner_radius : OPTIONAL positive_length_measure;
	start_param : REAL;
	end_param : REAL;
WHERE
	WR1 :  directrix.dim = 3 ;
	WR2 : (NOT EXISTS(inner_radius))OR(radius > inner_radius);
END_ENTITY; -- swept_disk_solid


ENTITY swept_face_solid
	SUPERTYPE OF (ONEOF (extruded_face_solid, revolved_face_solid, surface_curve_swept_face_solid))
	SUBTYPE OF (solid_model);
	swept_face : face_surface;
WHERE
	WR1 :  'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY; -- swept_face_solid


ENTITY tetrahedron
	SUBTYPE OF (faceted_primitive);
WHERE
	WR1 :  SIZEOF(points)= 4 ;
	WR2 :  above_plane(points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ])<> 0.0 ;
END_ENTITY; -- tetrahedron


ENTITY torus
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
WHERE
	WR1 :  major_radius > minor_radius ;
END_ENTITY; -- torus


ENTITY trimmed_volume
	SUBTYPE OF (solid_model);
	basis_volume : volume;
	u1 : parameter_value;
	u2 : parameter_value;
	v1 : parameter_value;
	v2 : parameter_value;
	w1 : parameter_value;
	w2 : parameter_value;
WHERE
	WR1 :  u1 <> u2 ;
	WR2 :  v1 <> v2 ;
	WR3 :  w1 <> w2 ;
END_ENTITY; -- trimmed_volume


ENTITY placed_datum_target_feature
	SUBTYPE OF (datum_target);
DERIVE
	representation_associations : SET [0:?] OF property_definition_representation :=  get_shape_aspect_property_definition_representations(SELF);
WHERE
	WR1 :  SELF.description IN [ 'point', 'line', 'rectangle', 'circle', 'circular line' ] ;
	WR2 :  SIZEOF(QUERY(pdr <* representation_associations | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))= 1 ;
	WR3 :  valid_datum_target_parameters(SELF);
END_ENTITY; -- placed_datum_target_feature


ENTITY shape_representation_with_parameters
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(i <* SELF.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PLACEMENT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' ] * TYPEOF(i))= 1))= SIZEOF(SELF.items);
END_ENTITY; -- shape_representation_with_parameters


ENTITY axis1_placement
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
DERIVE
	z : direction :=  NVL(normalise(axis), dummy_gri || direction([ 0.0, 0.0, 1.0 ]));
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- axis1_placement


ENTITY axis2_placement_2d
	SUBTYPE OF (placement);
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [2:2] OF direction :=  build_2axes(ref_direction);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- axis2_placement_2d


ENTITY axis2_placement_3d
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [3:3] OF direction :=  build_axes(axis, ref_direction);
WHERE
	WR1 :  SELF \ placement.location.dim = 3 ;
	WR2 : (NOT(EXISTS(axis)))OR(axis.dim = 3);
	WR3 : (NOT(EXISTS(ref_direction)))OR(ref_direction.dim = 3);
	WR4 : (NOT(EXISTS(axis)))OR(NOT(EXISTS(ref_direction)))OR(cross_product(axis, ref_direction).magnitude > 0.0);
END_ENTITY; -- axis2_placement_3d


ENTITY b_spline_curve
	SUPERTYPE OF ((ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve))
	SUBTYPE OF (bounded_curve);
	degree : INTEGER;
	control_points_list : LIST [2:?] OF cartesian_point;
	curve_form : b_spline_curve_form;
	closed_curve : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:??] OF cartesian_point :=  list_to_array(control_points_list, 0, upper_index_on_control_points);
	upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list)- 1);
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.UNIFORM_CURVE' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.QUASI_UNIFORM_CURVE' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BEZIER_CURVE' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_curve


ENTITY b_spline_curve_with_knots
	SUBTYPE OF (b_spline_curve);
	knot_multiplicities : LIST [2:?] OF INTEGER;
	knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	upper_index_on_knots : INTEGER :=  SIZEOF(knots);
WHERE
	WR1 :  constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots);
	WR2 :  SIZEOF(knot_multiplicities)= upper_index_on_knots ;
END_ENTITY; -- b_spline_curve_with_knots


ENTITY b_spline_surface
	SUPERTYPE OF ((ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface))
	SUBTYPE OF (bounded_surface);
	u_degree : INTEGER;
	v_degree : INTEGER;
	control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
	surface_form : b_spline_surface_form;
	u_closed : LOGICAL;
	v_closed : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:??] OF ARRAY [0:??] OF cartesian_point :=  make_array_of_array(control_points_list, 0, u_upper, 0, v_upper);
	u_upper : INTEGER :=  SIZEOF(control_points_list)- 1 ;
	v_upper : INTEGER :=  SIZEOF(control_points_list [ 1 ])- 1 ;
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.UNIFORM_SURFACE' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.QUASI_UNIFORM_SURFACE' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BEZIER_SURFACE' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_surface


ENTITY b_spline_surface_with_knots
	SUBTYPE OF (b_spline_surface);
	u_multiplicities : LIST [2:?] OF INTEGER;
	v_multiplicities : LIST [2:?] OF INTEGER;
	u_knots : LIST [2:?] OF parameter_value;
	v_knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	knot_u_upper : INTEGER :=  SIZEOF(u_knots);
	knot_v_upper : INTEGER :=  SIZEOF(v_knots);
WHERE
	WR1 :  constraints_param_b_spline(SELF  \ b_spline_surface.u_degree, knot_u_upper, SELF \ b_spline_surface.u_upper, u_multiplicities, u_knots);
	WR2 :  constraints_param_b_spline(SELF  \ b_spline_surface.v_degree, knot_v_upper, SELF \ b_spline_surface.v_upper, v_multiplicities, v_knots);
	WR3 :  SIZEOF(u_multiplicities)= knot_u_upper ;
	WR4 :  SIZEOF(v_multiplicities)= knot_v_upper ;
END_ENTITY; -- b_spline_surface_with_knots


ENTITY b_spline_volume
	SUPERTYPE OF ((ONEOF (b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume, bezier_volume) ANDOR rational_b_spline_volume))
	SUBTYPE OF (volume);
	u_degree : INTEGER;
	v_degree : INTEGER;
	w_degree : INTEGER;
	control_points_list : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF cartesian_point;
DERIVE
	control_points : ARRAY [0:??] OF ARRAY [0:??] OF ARRAY [0:??] OF cartesian_point :=  make_array_of_array_of_array(control_points_list, 0, u_upper, 0, v_upper, 0, w_upper);
	u_upper : INTEGER :=  SIZEOF(control_points_list)- 1 ;
	v_upper : INTEGER :=  SIZEOF(control_points_list [ 1 ])- 1 ;
	w_upper : INTEGER :=  SIZEOF(control_points_list [ 1 ] [ 1 ])- 1 ;
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BEZIER_VOLUME' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.UNIFORM_VOLUME' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.QUASI_UNIFORM_VOLUME' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_volume


ENTITY b_spline_volume_with_knots
	SUBTYPE OF (b_spline_volume);
	u_multiplicities : LIST [2:?] OF INTEGER;
	v_multiplicities : LIST [2:?] OF INTEGER;
	w_multiplicities : LIST [2:?] OF INTEGER;
	u_knots : LIST [2:?] OF parameter_value;
	v_knots : LIST [2:?] OF parameter_value;
	w_knots : LIST [2:?] OF parameter_value;
DERIVE
	knot_u_upper : INTEGER :=  SIZEOF(u_knots);
	knot_v_upper : INTEGER :=  SIZEOF(v_knots);
	knot_w_upper : INTEGER :=  SIZEOF(w_knots);
WHERE
	WR1 :  constraints_param_b_spline(SELF  \ b_spline_volume.u_degree, knot_u_upper, SELF \ b_spline_volume.u_upper, u_multiplicities, u_knots);
	WR2 :  constraints_param_b_spline(SELF  \ b_spline_volume.v_degree, knot_v_upper, SELF \ b_spline_volume.v_upper, v_multiplicities, v_knots);
	WR3 :  constraints_param_b_spline(SELF  \ b_spline_volume.w_degree, knot_w_upper, SELF \ b_spline_volume.w_upper, w_multiplicities, w_knots);
	WR4 :  SIZEOF(u_multiplicities)= knot_u_upper ;
	WR5 :  SIZEOF(v_multiplicities)= knot_v_upper ;
	WR6 :  SIZEOF(w_multiplicities)= knot_w_upper ;
END_ENTITY; -- b_spline_volume_with_knots


ENTITY bezier_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- bezier_curve


ENTITY bezier_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- bezier_surface


ENTITY bezier_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- bezier_volume


ENTITY block_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
END_ENTITY; -- block_volume


ENTITY boundary_curve
	SUBTYPE OF (composite_curve_on_surface);
WHERE
	WR1 :  SELF \ composite_curve.closed_curve ;
END_ENTITY; -- boundary_curve


ENTITY bounded_curve
	SUPERTYPE OF (ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve))
	SUBTYPE OF (curve);
END_ENTITY; -- bounded_curve


ENTITY bounded_pcurve
	SUBTYPE OF (pcurve, bounded_curve);
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOUNDED_CURVE' IN TYPEOF(SELF \ pcurve.reference_to_curve.items [ 1 ]));
END_ENTITY; -- bounded_pcurve


ENTITY bounded_surface
	SUPERTYPE OF (ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface))
	SUBTYPE OF (surface);
END_ENTITY; -- bounded_surface


ENTITY bounded_surface_curve
	SUBTYPE OF (surface_curve, bounded_curve);
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOUNDED_CURVE' IN TYPEOF(SELF \ surface_curve.curve_3d));
END_ENTITY; -- bounded_surface_curve


ENTITY cartesian_point
	SUPERTYPE OF (ONEOF (cylindrical_point, polar_point, spherical_point))
	SUBTYPE OF (point);
	coordinates : LIST [1:3] OF length_measure;
END_ENTITY; -- cartesian_point


ENTITY cartesian_transformation_operator
	SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))
	SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
	axis1 : OPTIONAL direction;
	axis2 : OPTIONAL direction;
	local_origin : cartesian_point;
	scale : OPTIONAL REAL;
DERIVE
	scl : REAL :=  NVL(scale, 1.0);
WHERE
	WR1 :  scl > 0.0 ;
END_ENTITY; -- cartesian_transformation_operator


ENTITY cartesian_transformation_operator_2d
	SUBTYPE OF (cartesian_transformation_operator);
DERIVE
	u : LIST [2:2] OF direction :=  base_axis(2, SELF  \ cartesian_transformation_operator.axis1, SELF \ cartesian_transformation_operator.axis2, ?);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- cartesian_transformation_operator_2d


ENTITY cartesian_transformation_operator_3d
	SUBTYPE OF (cartesian_transformation_operator);
	axis3 : OPTIONAL direction;
DERIVE
	u : LIST [3:3] OF direction :=  base_axis(3, SELF  \ cartesian_transformation_operator.axis1, SELF \ cartesian_transformation_operator.axis2, axis3);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- cartesian_transformation_operator_3d


ENTITY circle
	SUBTYPE OF (conic);
	radius : positive_length_measure;
END_ENTITY; -- circle


ENTITY circular_involute
	SUBTYPE OF (curve);
	position : axis2_placement;
	base_radius : positive_length_measure;
END_ENTITY; -- circular_involute


ENTITY clothoid
	SUBTYPE OF (curve);
	position : axis2_placement;
	clothoid_constant : length_measure;
END_ENTITY; -- clothoid


ENTITY composite_curve
	SUBTYPE OF (bounded_curve);
	segments : LIST [1:?] OF composite_curve_segment;
	self_intersect : LOGICAL;
DERIVE
	closed_curve : LOGICAL :=  segments [ n_segments ].transition <> discontinuous ;
	n_segments : INTEGER :=  SIZEOF(segments);
WHERE
	WR1 : ((NOT closed_curve)AND(SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous))= 1))OR((closed_curve)AND(SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous))= 0));
END_ENTITY; -- composite_curve


ENTITY composite_curve_on_surface
	SUPERTYPE OF (boundary_curve)
	SUBTYPE OF (composite_curve);
DERIVE
	basis_surface : SET [0:2] OF surface :=  get_basis_surface(SELF);
WHERE
	WR1 :  SIZEOF(basis_surface)> 0 ;
	WR2 :  constraints_composite_curve_on_surface(SELF);
END_ENTITY; -- composite_curve_on_surface


ENTITY composite_curve_segment
	SUBTYPE OF (founded_item);
	transition : transition_code;
	same_sense : BOOLEAN;
	parent_curve : curve;
INVERSE
	using_curves: BAG [1:?] OF composite_curve FOR segments;
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY; -- composite_curve_segment


ENTITY conic
	SUPERTYPE OF (ONEOF (circle, ellipse, hyperbola, parabola))
	SUBTYPE OF (curve);
	position : axis2_placement;
END_ENTITY; -- conic


ENTITY conical_surface
	SUBTYPE OF (elementary_surface);
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 :  radius >= 0.0 ;
END_ENTITY; -- conical_surface


ENTITY curve
	SUPERTYPE OF (ONEOF (line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- curve


ENTITY curve_bounded_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	boundaries : SET [1:?] OF boundary_curve;
	implicit_outer : BOOLEAN;
WHERE
	WR1 : (NOT implicit_outer)OR(SIZEOF(QUERY(temp <* boundaries | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))= 0);
	WR2 : (NOT(implicit_outer))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
	WR3 :  SIZEOF(QUERY(temp <* boundaries | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))<= 1 ;
	WR4 :  SIZEOF(QUERY(temp <* boundaries |(temp \ composite_curve_on_surface.basis_surface [ 1 ] <> SELF.basis_surface)))= 0 ;
END_ENTITY; -- curve_bounded_surface


ENTITY curve_replica
	SUBTYPE OF (curve);
	parent_curve : curve;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 :  transformation.dim = parent_curve.dim ;
	WR2 :  acyclic_curve_replica(SELF, parent_curve);
END_ENTITY; -- curve_replica


ENTITY cylindrical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	z : length_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=  [ r * COS(theta), r * SIN(theta), z ] ;
WHERE
	WR1 :  r >= 0.0 ;
END_ENTITY; -- cylindrical_point


ENTITY cylindrical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY; -- cylindrical_surface


ENTITY cylindrical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	radius : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- cylindrical_volume


ENTITY degenerate_pcurve
	SUBTYPE OF (point);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 :  SIZEOF(reference_to_curve \ representation.items)= 1 ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE' IN TYPEOF(reference_to_curve \ representation.items [ 1 ]);
	WR3 :  reference_to_curve \ representation.items [ 1 ] \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- degenerate_pcurve


ENTITY degenerate_toroidal_surface
	SUBTYPE OF (toroidal_surface);
	select_outer : BOOLEAN;
WHERE
	WR1 :  major_radius < minor_radius ;
END_ENTITY; -- degenerate_toroidal_surface


ENTITY direction
	SUBTYPE OF (geometric_representation_item);
	direction_ratios : LIST [2:3] OF REAL;
WHERE
	WR1 :  SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0))> 0 ;
END_ENTITY; -- direction


ENTITY dupin_cyclide_surface
	SUBTYPE OF (elementary_surface);
	generalised_major_radius : positive_length_measure;
	generalised_minor_radius : positive_length_measure;
	skewness : length_measure;
WHERE
	WR1 :  skewness >= 0.0 ;
END_ENTITY; -- dupin_cyclide_surface


ENTITY eccentric_conical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	height : positive_length_measure;
	x_offset : length_measure;
	y_offset : length_measure;
	ratio : REAL;
WHERE
	WR1 :  ratio >= 0.0 ;
END_ENTITY; -- eccentric_conical_volume


ENTITY elementary_surface
	SUPERTYPE OF (ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))
	SUBTYPE OF (surface);
	position : axis2_placement_3d;
END_ENTITY; -- elementary_surface


ENTITY ellipse
	SUBTYPE OF (conic);
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
END_ENTITY; -- ellipse


ENTITY ellipsoid_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	semi_axis_3 : positive_length_measure;
END_ENTITY; -- ellipsoid_volume


ENTITY evaluated_degenerate_pcurve
	SUBTYPE OF (degenerate_pcurve);
	equivalent_point : cartesian_point;
END_ENTITY; -- evaluated_degenerate_pcurve


ENTITY fixed_reference_swept_surface
	SUBTYPE OF (swept_surface);
	directrix : curve;
	fixed_reference : direction;
END_ENTITY; -- fixed_reference_swept_surface


ENTITY geometric_representation_context
	SUBTYPE OF (representation_context);
	coordinate_space_dimension : dimension_count;
END_ENTITY; -- geometric_representation_context


ENTITY geometric_representation_item
	SUPERTYPE OF (ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge, ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid, half_space_2d, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set))
	SUBTYPE OF (representation_item);
DERIVE
	dim : dimension_count :=  dimension_of(SELF);
WHERE
	WR1 :  SIZEOF(QUERY(using_rep <* using_representations(SELF)| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(using_rep.context_of_items))))= 0 ;
END_ENTITY; -- geometric_representation_item


ENTITY hexahedron_volume
	SUBTYPE OF (volume);
	points : LIST [8:8] OF cartesian_point;
WHERE
	WR1 :  above_plane(points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ])= 0.0 ;
	WR2 :  above_plane(points [ 5 ], points [ 8 ], points [ 7 ], points [ 6 ])= 0.0 ;
	WR3 :  above_plane(points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ])= 0.0 ;
	WR4 :  above_plane(points [ 4 ], points [ 3 ], points [ 7 ], points [ 8 ])= 0.0 ;
	WR5 :  above_plane(points [ 3 ], points [ 2 ], points [ 6 ], points [ 7 ])= 0.0 ;
	WR6 :  above_plane(points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ])= 0.0 ;
	WR7 :  same_side([ points [ 1 ], points [ 2 ], points [ 3 ] ], [ points [ 5 ], points [ 6 ], points [ 7 ], points [ 8 ] ]);
	WR8 :  same_side([ points [ 1 ], points [ 4 ], points [ 8 ] ], [ points [ 3 ], points [ 7 ], points [ 6 ], points [ 2 ] ]);
	WR9 :  same_side([ points [ 1 ], points [ 2 ], points [ 5 ] ], [ points [ 3 ], points [ 7 ], points [ 8 ], points [ 4 ] ]);
	WR10 :  same_side([ points [ 5 ], points [ 6 ], points [ 7 ] ], [ points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ] ]);
	WR11 :  same_side([ points [ 3 ], points [ 7 ], points [ 6 ] ], [ points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ] ]);
	WR12 :  same_side([ points [ 3 ], points [ 7 ], points [ 8 ] ], [ points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ] ]);
	WR13 :  points [ 1 ].dim = 3 ;
END_ENTITY; -- hexahedron_volume


ENTITY hyperbola
	SUBTYPE OF (conic);
	semi_axis : positive_length_measure;
	semi_imag_axis : positive_length_measure;
END_ENTITY; -- hyperbola


ENTITY intersection_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 :  SIZEOF(SELF \ surface_curve.associated_geometry)= 2 ;
	WR2 :  associated_surface(SELF  \ surface_curve.associated_geometry [ 1 ])<> associated_surface(SELF \ surface_curve.associated_geometry [ 2 ]);
END_ENTITY; -- intersection_curve


ENTITY line
	SUBTYPE OF (curve);
	pnt : cartesian_point;
	dir : vector;
WHERE
	WR1 :  dir.dim = pnt.dim ;
END_ENTITY; -- line


ENTITY offset_curve_2d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
WHERE
	WR1 :  basis_curve.dim = 2 ;
END_ENTITY; -- offset_curve_2d


ENTITY offset_curve_3d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
	ref_direction : direction;
WHERE
	WR1 : (basis_curve.dim = 3)AND(ref_direction.dim = 3);
END_ENTITY; -- offset_curve_3d


ENTITY offset_surface
	SUBTYPE OF (surface);
	basis_surface : surface;
	distance : length_measure;
	self_intersect : LOGICAL;
END_ENTITY; -- offset_surface


ENTITY oriented_surface
	SUBTYPE OF (surface);
	orientation : BOOLEAN;
END_ENTITY; -- oriented_surface


ENTITY outer_boundary_curve
	SUBTYPE OF (boundary_curve);
END_ENTITY; -- outer_boundary_curve


ENTITY parabola
	SUBTYPE OF (conic);
	focal_dist : length_measure;
WHERE
	WR1 :  focal_dist <> 0.0 ;
END_ENTITY; -- parabola


ENTITY pcurve
	SUBTYPE OF (curve);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 :  SIZEOF(reference_to_curve \ representation.items)= 1 ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE' IN TYPEOF(reference_to_curve \ representation.items [ 1 ]);
	WR3 :  reference_to_curve \ representation.items [ 1 ] \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- pcurve


ENTITY placement
	SUPERTYPE OF (ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d))
	SUBTYPE OF (geometric_representation_item);
	location : cartesian_point;
END_ENTITY; -- placement


ENTITY plane
	SUBTYPE OF (elementary_surface);
END_ENTITY; -- plane


ENTITY point
	SUPERTYPE OF (ONEOF (cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica, degenerate_pcurve))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- point


ENTITY point_in_volume
	SUBTYPE OF (point);
	basis_volume : volume;
	point_parameter_u : parameter_value;
	point_parameter_v : parameter_value;
	point_parameter_w : parameter_value;
END_ENTITY; -- point_in_volume


ENTITY point_on_curve
	SUBTYPE OF (point);
	basis_curve : curve;
	point_parameter : parameter_value;
END_ENTITY; -- point_on_curve


ENTITY point_on_surface
	SUBTYPE OF (point);
	basis_surface : surface;
	point_parameter_u : parameter_value;
	point_parameter_v : parameter_value;
END_ENTITY; -- point_on_surface


ENTITY point_replica
	SUBTYPE OF (point);
	parent_pt : point;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 :  transformation.dim = parent_pt.dim ;
	WR2 :  acyclic_point_replica(SELF, parent_pt);
END_ENTITY; -- point_replica


ENTITY polar_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=  [ r * COS(theta), r * SIN(theta)] ;
WHERE
	WR1 :  r >= 0.0 ;
END_ENTITY; -- polar_point


ENTITY polyline
	SUBTYPE OF (bounded_curve);
	points : LIST [2:?] OF cartesian_point;
END_ENTITY; -- polyline


ENTITY pyramid_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- pyramid_volume


ENTITY quasi_uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- quasi_uniform_curve


ENTITY quasi_uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- quasi_uniform_surface


ENTITY quasi_uniform_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- quasi_uniform_volume


ENTITY rational_b_spline_curve
	SUBTYPE OF (b_spline_curve);
	weights_data : LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:??] OF REAL :=  list_to_array(weights_data, 0, upper_index_on_control_points);
WHERE
	WR1 :  SIZEOF(weights_data)= SIZEOF(SELF \ b_spline_curve.control_points_list);
	WR2 :  curve_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_curve


ENTITY rational_b_spline_surface
	SUBTYPE OF (b_spline_surface);
	weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:??] OF ARRAY [0:??] OF REAL :=  make_array_of_array(weights_data, 0, u_upper, 0, v_upper);
WHERE
	WR1 : (SIZEOF(weights_data)= SIZEOF(SELF  \ b_spline_surface.control_points_list))AND(SIZEOF(weights_data [ 1 ])= SIZEOF(SELF \ b_spline_surface.control_points_list [ 1 ]));
	WR2 :  surface_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_surface


ENTITY rational_b_spline_volume
	SUBTYPE OF (b_spline_volume);
	weights_data : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:??] OF ARRAY [0:??] OF ARRAY [0:??] OF REAL :=  make_array_of_array_of_array(weights_data, 0, u_upper, 0, v_upper, 0, w_upper);
WHERE
	WR1 : (SIZEOF(weights_data)= SIZEOF(SELF  \ b_spline_volume.control_points_list))AND(SIZEOF(weights_data [ 1 ])= SIZEOF(SELF  \ b_spline_volume.control_points_list [ 1 ]))AND(SIZEOF(weights_data [ 1 ] [ 1 ])= SIZEOF(SELF \ b_spline_volume.control_points_list [ 1 ] [ 1 ]));
	WR2 :  volume_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_volume


ENTITY rectangular_composite_surface
	SUBTYPE OF (bounded_surface);
	segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
DERIVE
	n_u : INTEGER :=  SIZEOF(segments);
	n_v : INTEGER :=  SIZEOF(segments [ 1 ]);
WHERE
	WR1 :  SIZEOF(QUERY(s <* segments | n_v <> SIZEOF(s)))= 0 ;
	WR2 :  constraints_rectangular_composite_surface(SELF);
END_ENTITY; -- rectangular_composite_surface


ENTITY rectangular_trimmed_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	u1 : parameter_value;
	u2 : parameter_value;
	v1 : parameter_value;
	v2 : parameter_value;
	usense : BOOLEAN;
	vsense : BOOLEAN;
WHERE
	WR1 :  u1 <> u2 ;
	WR2 :  v1 <> v2 ;
	WR3 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ELEMENTARY_SURFACE' IN  TYPEOF(basis_surface))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PLANE' IN  TYPEOF(basis_surface))))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))OR(usense =(u2 > u1));
	WR4 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SPHERICAL_SURFACE' IN  TYPEOF(basis_surface))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))OR(vsense =(v2 > v1));
END_ENTITY; -- rectangular_trimmed_surface


ENTITY reparametrised_composite_curve_segment
	SUBTYPE OF (composite_curve_segment);
	param_length : parameter_value;
WHERE
	WR1 :  param_length > 0.0 ;
END_ENTITY; -- reparametrised_composite_curve_segment


ENTITY seam_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 :  SIZEOF(SELF \ surface_curve.associated_geometry)= 2 ;
	WR2 :  associated_surface(SELF  \ surface_curve.associated_geometry [ 1 ])= associated_surface(SELF \ surface_curve.associated_geometry [ 2 ]);
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(SELF \ surface_curve.associated_geometry [ 1 ]);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(SELF \ surface_curve.associated_geometry [ 2 ]);
END_ENTITY; -- seam_curve


ENTITY spherical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	phi : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=  [ r * SIN(theta)* COS(phi), r * SIN(theta)* SIN(phi), r * COS(theta)] ;
WHERE
	WR1 :  r >= 0.0 ;
END_ENTITY; -- spherical_point


ENTITY spherical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY; -- spherical_surface


ENTITY spherical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	radius : positive_length_measure;
END_ENTITY; -- spherical_volume


ENTITY surface
	SUPERTYPE OF (ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- surface


ENTITY surface_curve
	SUPERTYPE OF ((ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve))
	SUBTYPE OF (curve);
	curve_3d : curve;
	associated_geometry : LIST [1:2] OF pcurve_or_surface;
	master_representation : preferred_surface_curve_representation;
DERIVE
	basis_surface : SET [1:2] OF surface :=  get_basis_surface(SELF);
WHERE
	WR1 :  curve_3d.dim = 3 ;
	WR2 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(associated_geometry [ 1 ]))OR(master_representation <> pcurve_s1);
	WR3 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(associated_geometry [ 2 ]))OR(master_representation <> pcurve_s2);
	WR4 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY; -- surface_curve


ENTITY surface_curve_swept_surface
	SUBTYPE OF (swept_surface);
	directrix : curve;
	reference_surface : surface;
WHERE
	WR1 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF(directrix)))OR(reference_surface IN(directrix \ surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_surface


ENTITY surface_of_linear_extrusion
	SUBTYPE OF (swept_surface);
	extrusion_axis : vector;
END_ENTITY; -- surface_of_linear_extrusion


ENTITY surface_of_revolution
	SUBTYPE OF (swept_surface);
	axis_position : axis1_placement;
DERIVE
	axis_line : line :=  representation_item('')|| geometric_representation_item()|| curve()|| line(axis_position.location, representation_item('')|| geometric_representation_item()|| vector(axis_position.z, 1.0));
END_ENTITY; -- surface_of_revolution


ENTITY surface_patch
	SUBTYPE OF (founded_item);
	parent_surface : bounded_surface;
	u_transition : transition_code;
	v_transition : transition_code;
	u_sense : BOOLEAN;
	v_sense : BOOLEAN;
INVERSE
	using_surfaces: BAG [1:?] OF rectangular_composite_surface FOR segments;
WHERE
	WR1 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)));
END_ENTITY; -- surface_patch


ENTITY surface_replica
	SUBTYPE OF (surface);
	parent_surface : surface;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 :  acyclic_surface_replica(SELF, parent_surface);
END_ENTITY; -- surface_replica


ENTITY swept_surface
	SUPERTYPE OF (ONEOF (surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface, fixed_reference_swept_surface))
	SUBTYPE OF (surface);
	swept_curve : curve;
END_ENTITY; -- swept_surface


ENTITY tetrahedron_volume
	SUBTYPE OF (volume);
	point_1 : cartesian_point;
	point_2 : cartesian_point;
	point_3 : cartesian_point;
	point_4 : cartesian_point;
WHERE
	WR1 :  point_1.dim = 3 ;
	WR2 :  above_plane(point_1, point_2, point_3, point_4)<> 0.0 ;
END_ENTITY; -- tetrahedron_volume


ENTITY toroidal_surface
	SUBTYPE OF (elementary_surface);
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
END_ENTITY; -- toroidal_surface


ENTITY toroidal_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
WHERE
	WR1 :  minor_radius < major_radius ;
END_ENTITY; -- toroidal_volume


ENTITY trimmed_curve
	SUBTYPE OF (bounded_curve);
	basis_curve : curve;
	trim_1 : SET [1:2] OF trimming_select;
	trim_2 : SET [1:2] OF trimming_select;
	sense_agreement : BOOLEAN;
	master_representation : trimming_preference;
WHERE
	WR1 : (HIINDEX(trim_1)= 1)OR(TYPEOF(trim_1 [ 1 ])<> TYPEOF(trim_1 [ 2 ]));
	WR2 : (HIINDEX(trim_2)= 1)OR(TYPEOF(trim_2 [ 1 ])<> TYPEOF(trim_2 [ 2 ]));
END_ENTITY; -- trimmed_curve


ENTITY uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- uniform_curve


ENTITY uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- uniform_surface


ENTITY uniform_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- uniform_volume


ENTITY vector
	SUBTYPE OF (geometric_representation_item);
	orientation : direction;
	magnitude : length_measure;
WHERE
	WR1 :  magnitude >= 0.0 ;
END_ENTITY; -- vector


ENTITY volume
	SUPERTYPE OF (ONEOF (block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume))
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- volume


ENTITY wedge_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
	ltx : length_measure;
WHERE
	WR1 : ((0.0 <= ltx)AND(ltx < x));
END_ENTITY; -- wedge_volume


ENTITY applied_group_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF groupable_item;
END_ENTITY; -- applied_group_assignment


ENTITY group;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- group


ENTITY group_relationship;
	name : label;
	description : OPTIONAL text;
	relating_group : group;
	related_group : group;
END_ENTITY; -- group_relationship


ENTITY applied_identification_assignment
	SUBTYPE OF (identification_assignment);
	items : SET [1:?] OF identification_item;
END_ENTITY; -- applied_identification_assignment


ENTITY component_interface_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'interconnect component interface terminal', 'packaged connector component interface terminal' ] ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
	WR4 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design usage'))<= 1 ;
	WR5 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
	WR6 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence');
	WR7 : (NOT(SELF  \ shape_aspect.description = 'interconnect component interface terminal'))OR((SIZEOF(QUERY(sar <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1)AND NOT(SELF.of_shape.definition \ product_definition.description IN [ 'assembly module component', 'bare die component', 'interconnect module component', 'laminate component', 'packaged component' ]));
	WR8 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(SELF.product_definitional);
	WR9 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.description = 'packaged connector component')AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence'));
	WR10 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(i_f.relating_shape_aspect \ shape_aspect.description = 'interface terminal')))= 1);
END_ENTITY; -- component_interface_terminal


ENTITY interface_component_definition
	SUBTYPE OF (component_definition);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL' IN  TYPEOF(sa))AND(sa \ shape_aspect.description IN [ 'interconnect component interface terminal', 'packaged connector component interface terminal' ])))>= 1))>= 1);
END_ENTITY; -- interface_component_definition


ENTITY abs_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- abs_function


ENTITY acos_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- acos_function


ENTITY and_expression
	SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY; -- and_expression


ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- asin_function


ENTITY atan_function
	SUBTYPE OF (binary_function_call);
END_ENTITY; -- atan_function


ENTITY binary_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
	SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY; -- binary_boolean_expression


ENTITY binary_function_call
	ABSTRACT SUPERTYPE OF (atan_function)
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- binary_function_call


ENTITY binary_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (minus_expression, div_expression, mod_expression, slash_expression, power_expression, binary_function_call))
	SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF numeric_expression;
END_ENTITY; -- binary_numeric_expression


ENTITY boolean_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY; -- boolean_defined_function


ENTITY boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression, unary_boolean_expression, binary_boolean_expression, multiple_arity_boolean_expression, comparison_expression, interval_expression, boolean_defined_function))
	SUBTYPE OF (expression);
END_ENTITY; -- boolean_expression


ENTITY boolean_literal
	SUBTYPE OF (simple_boolean_expression, generic_literal);
	the_value : BOOLEAN;
END_ENTITY; -- boolean_literal


ENTITY boolean_variable
	SUBTYPE OF (simple_boolean_expression, variable);
END_ENTITY; -- boolean_variable


ENTITY comparison_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_equal


ENTITY comparison_expression
	ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal, comparison_greater, comparison_greater_equal, comparison_less, comparison_less_equal, comparison_not_equal, like_expression))
	SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF expression;
WHERE
	WR1 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 2 ])))OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOOLEAN_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOOLEAN_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 2 ])))OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF \ binary_generic_expression.operands [ 2 ])));
END_ENTITY; -- comparison_expression


ENTITY comparison_greater
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_greater


ENTITY comparison_greater_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_greater_equal


ENTITY comparison_less
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_less


ENTITY comparison_less_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_less_equal


ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_not_equal


ENTITY concat_expression
	SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF string_expression;
END_ENTITY; -- concat_expression


ENTITY cos_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- cos_function


ENTITY defined_function
	ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function, string_defined_function, boolean_defined_function) ANDOR SQL_mappable_defined_function));
END_ENTITY; -- defined_function


ENTITY div_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- div_expression


ENTITY equals_expression
	SUBTYPE OF (binary_boolean_expression);
END_ENTITY; -- equals_expression


ENTITY exp_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- exp_function


ENTITY expression
	ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression, boolean_expression, string_expression))
	SUBTYPE OF (generic_expression);
END_ENTITY; -- expression


ENTITY format_function
	SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	format_string : generic_expression :=  SELF \ binary_generic_expression.operands [ 2 ] ;
	value_to_format : generic_expression :=  SELF \ binary_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION')IN  TYPEOF(value_to_format))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION')IN TYPEOF(format_string));
END_ENTITY; -- format_function


ENTITY index_expression
	SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	index : generic_expression :=  SELF \ binary_generic_expression.operands [ 2 ] ;
	operand : generic_expression :=  SELF \ binary_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(operand))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index));
	WR2 :  is_int_expr(index);
END_ENTITY; -- index_expression


ENTITY int_literal
	SUBTYPE OF (literal_number);
	SELF\literal_number.the_value : INTEGER;
END_ENTITY; -- int_literal


ENTITY int_numeric_variable
	SUBTYPE OF (numeric_variable);
END_ENTITY; -- int_numeric_variable


ENTITY int_value_function
	SUBTYPE OF (value_function);
END_ENTITY; -- int_value_function


ENTITY integer_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (numeric_defined_function);
END_ENTITY; -- integer_defined_function


ENTITY interval_expression
	SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
DERIVE
	interval_high : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 3 ] ;
	interval_item : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	interval_low : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EXPRESSION' IN  TYPEOF(interval_low))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EXPRESSION' IN  TYPEOF(interval_item))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EXPRESSION' IN TYPEOF(interval_high));
	WR2 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_low))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_high))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_item)))OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_low))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(SELF.interval_item))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_high)));
END_ENTITY; -- interval_expression


ENTITY length_function
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : string_expression;
END_ENTITY; -- length_function


ENTITY like_expression
	SUBTYPE OF (comparison_expression);
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF \ binary_generic_expression.operands [ 2 ]));
END_ENTITY; -- like_expression


ENTITY literal_number
	ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
	SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value : NUMBER;
END_ENTITY; -- literal_number


ENTITY log10_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- log10_function


ENTITY log2_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- log2_function


ENTITY log_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- log_function


ENTITY maximum_function
	SUBTYPE OF (multiple_arity_function_call);
END_ENTITY; -- maximum_function


ENTITY minimum_function
	SUBTYPE OF (multiple_arity_function_call);
END_ENTITY; -- minimum_function


ENTITY minus_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- minus_expression


ENTITY minus_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- minus_function


ENTITY mod_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- mod_expression


ENTITY mult_expression
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY; -- mult_expression


ENTITY multiple_arity_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
	SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF boolean_expression;
END_ENTITY; -- multiple_arity_boolean_expression


ENTITY multiple_arity_function_call
	ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, minimum_function))
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY; -- multiple_arity_function_call


ENTITY multiple_arity_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (plus_expression, mult_expression, multiple_arity_function_call))
	SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF numeric_expression;
END_ENTITY; -- multiple_arity_numeric_expression


ENTITY not_expression
	SUBTYPE OF (unary_boolean_expression);
	SELF\unary_generic_expression.operand : boolean_expression;
END_ENTITY; -- not_expression


ENTITY numeric_defined_function
	ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function, real_defined_function))
	SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY; -- numeric_defined_function


ENTITY numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression, unary_numeric_expression, binary_numeric_expression, multiple_arity_numeric_expression, length_function, value_function, numeric_defined_function))
	SUBTYPE OF (expression);
DERIVE
	is_int : BOOLEAN :=  is_int_expr(SELF);
	sql_mappable : BOOLEAN :=  is_SQL_mappable(SELF);
END_ENTITY; -- numeric_expression


ENTITY numeric_variable
	SUPERTYPE OF (ONEOF (int_numeric_variable, real_numeric_variable))
	SUBTYPE OF (simple_numeric_expression, variable);
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INT_NUMERIC_VARIABLE' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(SELF));
END_ENTITY; -- numeric_variable


ENTITY odd_function
	SUBTYPE OF (unary_boolean_expression);
	SELF\unary_generic_expression.operand : numeric_expression;
WHERE
	WR1 :  is_int_expr(SELF \ numeric_expression);
END_ENTITY; -- odd_function


ENTITY or_expression
	SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY; -- or_expression


ENTITY plus_expression
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY; -- plus_expression


ENTITY power_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- power_expression


ENTITY real_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (numeric_defined_function);
END_ENTITY; -- real_defined_function


ENTITY real_literal
	SUBTYPE OF (literal_number);
	SELF\literal_number.the_value : REAL;
END_ENTITY; -- real_literal


ENTITY real_numeric_variable
	SUBTYPE OF (numeric_variable);
END_ENTITY; -- real_numeric_variable


ENTITY simple_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal, boolean_variable))
	SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY; -- simple_boolean_expression


ENTITY simple_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
	SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY; -- simple_numeric_expression


ENTITY simple_string_expression
	ABSTRACT SUPERTYPE OF (ONEOF (string_literal, string_variable))
	SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY; -- simple_string_expression


ENTITY sin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- sin_function


ENTITY slash_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- slash_expression


ENTITY sql_mappable_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function);
END_ENTITY; -- SQL_mappable_defined_function


ENTITY square_root_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- square_root_function


ENTITY string_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function, string_expression);
END_ENTITY; -- string_defined_function


ENTITY string_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression, index_expression, substring_expression, concat_expression, format_function, string_defined_function))
	SUBTYPE OF (expression);
END_ENTITY; -- string_expression


ENTITY string_literal
	SUBTYPE OF (simple_string_expression, generic_literal);
	the_value : STRING;
END_ENTITY; -- string_literal


ENTITY string_variable
	SUBTYPE OF (simple_string_expression, variable);
END_ENTITY; -- string_variable


ENTITY substring_expression
	SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	index1 : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	index2 : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 3 ] ;
	operand : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(operand))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(index1))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index2));
	WR2 :  SIZEOF(SELF \ multiple_arity_generic_expression.operands)= 3 ;
	WR3 :  is_int_expr(index1);
	WR4 :  is_int_expr(index2);
END_ENTITY; -- substring_expression


ENTITY tan_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- tan_function


ENTITY unary_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
	SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY; -- unary_boolean_expression


ENTITY unary_function_call
	ABSTRACT SUPERTYPE OF (ONEOF (abs_function, minus_function, sin_function, cos_function, tan_function, asin_function, acos_function, exp_function, log_function, log2_function, log10_function, square_root_function))
	SUBTYPE OF (unary_numeric_expression);
END_ENTITY; -- unary_function_call


ENTITY unary_numeric_expression
	ABSTRACT SUPERTYPE OF (unary_function_call)
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : numeric_expression;
END_ENTITY; -- unary_numeric_expression


ENTITY value_function
	SUPERTYPE OF (int_value_function)
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : string_expression;
END_ENTITY; -- value_function


ENTITY variable
	ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable, boolean_variable, string_variable))
	SUBTYPE OF (generic_variable);
END_ENTITY; -- variable


ENTITY xor_expression
	SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF boolean_expression;
END_ENTITY; -- xor_expression


ENTITY binary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:2] OF generic_expression;
END_ENTITY; -- binary_generic_expression


ENTITY environment;
	syntactic_representation : generic_variable;
	semantics : variable_semantics;
END_ENTITY; -- environment


ENTITY generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression));
WHERE
	WR1 :  is_acyclic(SELF);
END_ENTITY; -- generic_expression


ENTITY generic_literal
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
END_ENTITY; -- generic_literal


ENTITY generic_variable
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation: environment FOR syntactic_representation;
END_ENTITY; -- generic_variable


ENTITY multiple_arity_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:?] OF generic_expression;
END_ENTITY; -- multiple_arity_generic_expression


ENTITY simple_generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (generic_literal, generic_variable))
	SUBTYPE OF (generic_expression);
END_ENTITY; -- simple_generic_expression


ENTITY unary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operand : generic_expression;
END_ENTITY; -- unary_generic_expression


ENTITY variable_semantics
	ABSTRACT SUPERTYPE;
END_ENTITY; -- variable_semantics


ENTITY shape_definition_3d_intersection
	SUBTYPE OF (representation, shape_representation_relationship, representation_relationship_with_transformation);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SELF  \ representation_relationship.rep_1 :<>: SELF \ representation_relationship.rep_2 ;
	WR2 : (SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ shape_representation_relationship || SELF  \ representation_relationship_with_transformation || SELF  \ shape_definition_3d_intersection)))= 0)OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EDGE_SEGMENT_CROSS_SECTION' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRE_DEFINED_PARALLEL_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN  TYPEOF(SELF))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_PLANE_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF));
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF(SELF \ representation_relationship_with_transformation.transformation_operator);
END_ENTITY; -- shape_definition_3d_intersection


ENTITY shape_item_relationship
	SUBTYPE OF (representation_item, representation_item_relationship);
UNIQUE
	UR1 : relating_representation_item, related_representation_item;
WHERE
	WR1 :  SELF  \ representation_item_relationship.relating_representation_item :<>: SELF \ representation_item_relationship.related_representation_item ;
	WR2 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation_item || SELF  \ representation_item_relationship || SELF \ shape_item_relationship)))= 0 ;
END_ENTITY; -- shape_item_relationship


ENTITY location;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location


ENTITY location_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_location : location;
	related_location : location;
END_ENTITY; -- location_relationship


ENTITY action_assignment
	ABSTRACT SUPERTYPE;
	assigned_action : action;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- action_assignment


ENTITY action_method_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_method : action_method;
	role : action_method_role;
END_ENTITY; -- action_method_assignment


ENTITY action_method_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- action_method_role


ENTITY action_request_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_request : versioned_action_request;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- action_request_assignment


ENTITY approval_assignment
	ABSTRACT SUPERTYPE;
	assigned_approval : approval;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- approval_assignment


ENTITY attribute_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	attribute_name : label;
	role : classification_role;
END_ENTITY; -- attribute_classification_assignment


ENTITY attribute_value_assignment
	ABSTRACT SUPERTYPE;
	attribute_name : label;
	attribute_value : attribute_type;
	role : attribute_value_role;
END_ENTITY; -- attribute_value_assignment


ENTITY attribute_value_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- attribute_value_role


ENTITY certification_assignment
	ABSTRACT SUPERTYPE;
	assigned_certification : certification;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- certification_assignment


ENTITY classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	role : classification_role;
END_ENTITY; -- classification_assignment


ENTITY classification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- classification_role


ENTITY contract_assignment
	ABSTRACT SUPERTYPE;
	assigned_contract : contract;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- contract_assignment


ENTITY date_and_time_assignment
	ABSTRACT SUPERTYPE;
	assigned_date_and_time : date_and_time;
	role : date_time_role;
END_ENTITY; -- date_and_time_assignment


ENTITY date_assignment
	ABSTRACT SUPERTYPE;
	assigned_date : date;
	role : date_role;
END_ENTITY; -- date_assignment


ENTITY document_reference
	ABSTRACT SUPERTYPE;
	assigned_document : document;
	source : label;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- document_reference


ENTITY document_usage_constraint_assignment
	ABSTRACT SUPERTYPE;
	assigned_document_usage : document_usage_constraint;
	role : document_usage_role;
END_ENTITY; -- document_usage_constraint_assignment


ENTITY document_usage_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- document_usage_role


ENTITY effectivity_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity : effectivity;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- effectivity_assignment


ENTITY effectivity_context_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity_assignment : effectivity_assignment;
	role : effectivity_context_role;
END_ENTITY; -- effectivity_context_assignment


ENTITY effectivity_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- effectivity_context_role


ENTITY event_occurrence_assignment
	ABSTRACT SUPERTYPE;
	assigned_event_occurrence : event_occurrence;
	role : event_occurrence_role;
END_ENTITY; -- event_occurrence_assignment


ENTITY event_occurrence_context_assignment
	ABSTRACT SUPERTYPE;
	assigned_event_occurrence_assignment : event_occurrence_assignment;
	role : event_occurrence_context_role;
END_ENTITY; -- event_occurrence_context_assignment


ENTITY experience_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_experience : experience;
	role : experience_role;
END_ENTITY; -- experience_assignment


ENTITY experience_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_role


ENTITY experience_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_experience_type : experience_type;
	role : experience_type_role;
END_ENTITY; -- experience_type_assignment


ENTITY experience_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_type_role


ENTITY external_identification_assignment
	ABSTRACT SUPERTYPE
	SUBTYPE OF (identification_assignment);
	source : external_source;
END_ENTITY; -- external_identification_assignment


ENTITY external_referent_assignment
	ABSTRACT SUPERTYPE;
	assigned_name : label;
DERIVE
	role : object_role :=  get_role(SELF);
UNIQUE
	UR1 : assigned_name;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- external_referent_assignment


ENTITY group_assignment
	ABSTRACT SUPERTYPE;
	assigned_group : group;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- group_assignment


ENTITY identification_assignment
	ABSTRACT SUPERTYPE;
	assigned_id : identifier;
	role : identification_role;
END_ENTITY; -- identification_assignment


ENTITY identification_assignment_relationship;
	name : label;
	description : OPTIONAL text;
	relating_identification_assignment : identification_assignment;
	related_identification_assignment : identification_assignment;
END_ENTITY; -- identification_assignment_relationship


ENTITY identification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- identification_role


ENTITY library_assignment
	ABSTRACT SUPERTYPE
	SUBTYPE OF (external_referent_assignment);
	frame_of_reference : library_context;
UNIQUE
	UR1 : frame_of_reference;
END_ENTITY; -- library_assignment


ENTITY location_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_location : location;
	role : location_role;
END_ENTITY; -- location_assignment


ENTITY location_representation_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	represented_location : location;
	role : location_representation_role;
END_ENTITY; -- location_representation_assignment


ENTITY location_representation_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location_representation_role


ENTITY location_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location_role


ENTITY name_assignment
	ABSTRACT SUPERTYPE;
	assigned_name : label;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- name_assignment


ENTITY organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_organization : organization;
	role : organization_role;
END_ENTITY; -- organization_assignment


ENTITY organization_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_organization_type : organization_type;
	role : organization_type_role;
END_ENTITY; -- organization_type_assignment


ENTITY organization_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization_type_role


ENTITY organizational_project_assignment
	ABSTRACT SUPERTYPE;
	assigned_organizational_project : organizational_project;
	role : organizational_project_role;
END_ENTITY; -- organizational_project_assignment


ENTITY organizational_project_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organizational_project_role


ENTITY person_and_organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_person_and_organization : person_and_organization;
	role : person_and_organization_role;
END_ENTITY; -- person_and_organization_assignment


ENTITY person_assignment
	ABSTRACT SUPERTYPE;
	assigned_person : person;
	role : person_role;
END_ENTITY; -- person_assignment


ENTITY person_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_person_type : person_type;
	role : person_type_role;
END_ENTITY; -- person_type_assignment


ENTITY person_type_definition_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_person_type_definition : person_type_definition;
	role : person_type_definition_role;
END_ENTITY; -- person_type_definition_assignment


ENTITY person_type_definition_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type_definition_role


ENTITY person_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type_role


ENTITY position_in_organization_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_position_in_organization : position_in_organization;
	role : position_in_organization_role;
END_ENTITY; -- position_in_organization_assignment


ENTITY position_in_organization_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_role


ENTITY position_in_organization_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_position_in_organization_type : position_in_organization_type;
	role : position_in_organization_type_role;
END_ENTITY; -- position_in_organization_type_assignment


ENTITY position_in_organization_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_type_role


ENTITY qualification_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_qualification : qualification;
	role : qualification_role;
END_ENTITY; -- qualification_assignment


ENTITY qualification_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_role


ENTITY qualification_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_qualification_type : qualification_type;
	role : qualification_type_role;
END_ENTITY; -- qualification_type_assignment


ENTITY qualification_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_type_role


ENTITY security_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_security_classification : security_classification;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- security_classification_assignment


ENTITY time_assignment
	ABSTRACT SUPERTYPE;
	assigned_time : local_time;
	role : time_role;
END_ENTITY; -- time_assignment


ENTITY time_interval_assignment
	ABSTRACT SUPERTYPE;
	assigned_time_interval : time_interval;
	role : time_interval_role;
END_ENTITY; -- time_interval_assignment


ENTITY material_designation;
	name : label;
	definitions : SET [1:?] OF characterized_definition;
END_ENTITY; -- material_designation


ENTITY material_designation_characterization;
	name : label;
	description : text;
	designation : material_designation;
	property : characterized_material_property;
END_ENTITY; -- material_designation_characterization


ENTITY material_property
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : name, definition;
WHERE
	WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN  TYPEOF(SELF  \ property_definition.definition))OR(SIZEOF(bag_to_set(USEDIN(SELF , 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))- QUERY(temp <* bag_to_set(USEDIN(SELF, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' + 'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp))))= 0);
END_ENTITY; -- material_property


ENTITY product_material_composition_relationship
	SUBTYPE OF (product_definition_relationship);
	class : label;
	constituent_amount : SET [1:?] OF measure_with_unit;
	composition_basis : label;
	determination_method : text;
END_ENTITY; -- product_material_composition_relationship


ENTITY property_definition_relationship;
	name : label;
	description : text;
	relating_property_definition : property_definition;
	related_property_definition : property_definition;
END_ENTITY; -- property_definition_relationship


ENTITY data_environment;
	name : label;
	description : text;
	elements : SET [1:?] OF property_definition_representation;
END_ENTITY; -- data_environment


ENTITY data_environment_relationship;
	name : label;
	description : text;
	relating_data_environment : data_environment;
	related_data_environment : data_environment;
END_ENTITY; -- data_environment_relationship


ENTITY material_property_representation
	SUBTYPE OF (property_definition_representation);
	dependent_environment : data_environment;
END_ENTITY; -- material_property_representation


ENTITY abstracted_expression_function
	SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
	expr : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
	SELF\quantifier_expression.variables : LIST [1:?] OF  UNIQUE generic_variable :=  remove_first(SELF \ multiple_arity_generic_expression.operands);
WHERE
	WR1 :  SIZEOF(QUERY(operand <* SELF \ multiple_arity_generic_expression.operands | NOT(has_values_space(operand))))= 0 ;
END_ENTITY; -- abstracted_expression_function


ENTITY application_defined_function
	SUBTYPE OF (maths_function);
	explicit_domain : tuple_space;
	explicit_range : tuple_space;
	parameters : LIST [0:?] OF maths_value;
WHERE
	WR1 :  expression_is_constant(explicit_domain);
	WR2 :  expression_is_constant(explicit_range);
END_ENTITY; -- application_defined_function


ENTITY atom_based_literal
	SUBTYPE OF (generic_literal);
	lit_value : atom_based_value;
END_ENTITY; -- atom_based_literal


ENTITY b_spline_basis
	SUBTYPE OF (maths_function, generic_literal);
	degree : nonnegative_integer;
	repeated_knots : LIST [2:?] OF REAL;
DERIVE
	num_basis : positive_integer :=  SIZEOF(repeated_knots)- order ;
	order : positive_integer :=  degree + 1 ;
WHERE
	WR1 :  num_basis >= order ;
	WR2 :  nondecreasing(repeated_knots);
	WR3 :  repeated_knots [ order ] < repeated_knots [ num_basis + 1 ] ;
END_ENTITY; -- b_spline_basis


ENTITY b_spline_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	basis : LIST [1:?] OF b_spline_basis;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	coef : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_table(coef);
	WR2 : (space_dimension(coef.range)= 1)AND(number_superspace_of(factor1(coef.range))= the_reals);
	WR3 :  SIZEOF(basis)<= SIZEOF(shape_of_array(coef));
	WR4 :  compare_basis_and_coef(basis, coef);
END_ENTITY; -- b_spline_function


ENTITY banded_matrix
	SUBTYPE OF (linearized_table_function);
	default_entry : maths_value;
	below : INTEGER;
	above : INTEGER;
	order : ordering_type;
WHERE
	WR1 :  SIZEOF(SELF \ explicit_table_function.shape)= 2 ;
	WR2 :  - below <= above ;
	WR3 :  member_of(default_entry, factor1(SELF \ linearized_table_function.source.range));
END_ENTITY; -- banded_matrix


ENTITY basic_sparse_matrix
	SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
	default_entry : maths_value;
	order : ordering_type;
	SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
DERIVE
	index : maths_function :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
	loc : maths_function :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	val : maths_function :=  SELF \ multiple_arity_generic_expression.operands [ 3 ] ;
WHERE
	WR1 :  function_is_1d_table(index);
	WR2 :  function_is_1d_table(loc);
	WR3 :  function_is_1d_table(val);
	WR4 :  check_sparse_index_domain(index.domain, index_base, shape, order);
	WR5 :  check_sparse_index_to_loc(index.range, loc.domain);
	WR6 :  loc.domain = val.domain ;
	WR7 :  check_sparse_loc_range(loc.range, index_base, shape, order);
	WR8 :  member_of(default_entry, val.range);
END_ENTITY; -- basic_sparse_matrix


ENTITY binary_literal
	SUBTYPE OF (generic_literal);
	lit_value : BINARY;
END_ENTITY; -- binary_literal


ENTITY bound_variable_semantics
	SUBTYPE OF (variable_semantics);
END_ENTITY; -- bound_variable_semantics


ENTITY cartesian_complex_number_region
	SUBTYPE OF (maths_space, generic_literal);
	real_constraint : real_interval;
	imag_constraint : real_interval;
WHERE
	WR1 :  min_exists(real_constraint)OR  max_exists(real_constraint)OR  min_exists(imag_constraint)OR max_exists(imag_constraint);
END_ENTITY; -- cartesian_complex_number_region


ENTITY complex_number_literal
	SUBTYPE OF (generic_literal);
	real_part : REAL;
	imag_part : REAL;
END_ENTITY; -- complex_number_literal


ENTITY constant_function
	SUBTYPE OF (maths_function, generic_literal);
	sole_output : maths_value;
	source_of_domain : maths_space_or_function;
WHERE
	WR1 :  no_cyclic_domain_reference(source_of_domain, [ SELF ]);
	WR2 :  expression_is_constant(domain_from(source_of_domain));
END_ENTITY; -- constant_function


ENTITY definite_integral_expression
	SUBTYPE OF (quantifier_expression);
	lower_limit_neg_infinity : BOOLEAN;
	upper_limit_pos_infinity : BOOLEAN;
DERIVE
	integrand : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
	variable_of_integration : maths_variable :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	SELF\quantifier_expression.variables : LIST [1:1] OF  UNIQUE generic_variable :=  [ variable_of_integration ] ;
WHERE
	WR1 :  has_values_space(integrand);
	WR2 :  space_is_continuum(values_space_of(integrand));
	WR3 :  definite_integral_expr_check(SELF \ multiple_arity_generic_expression.operands, lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY; -- definite_integral_expression


ENTITY definite_integral_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	variable_of_integration : input_selector;
	lower_limit_neg_infinity : BOOLEAN;
	upper_limit_pos_infinity : BOOLEAN;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	integrand : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  space_is_continuum(integrand.range);
	WR2 :  definite_integral_check(integrand.domain, variable_of_integration, lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY; -- definite_integral_function


ENTITY dependent_variable_definition
	SUBTYPE OF (unary_generic_expression);
	name : label;
	description : text;
END_ENTITY; -- dependent_variable_definition


ENTITY elementary_function
	SUBTYPE OF (maths_function, generic_literal);
	func_id : elementary_function_enumerators;
END_ENTITY; -- elementary_function


ENTITY elementary_space
	SUBTYPE OF (maths_space, generic_literal);
	space_id : elementary_space_enumerators;
END_ENTITY; -- elementary_space


ENTITY explicit_table_function
	ABSTRACT SUPERTYPE OF (ONEOF (listed_real_data, listed_integer_data, listed_logical_data, listed_string_data, listed_complex_number_data, listed_data, externally_listed_data, linearized_table_function, basic_sparse_matrix))
	SUBTYPE OF (maths_function);
	index_base : zero_or_one;
	shape : LIST [1:?] OF positive_integer;
END_ENTITY; -- explicit_table_function


ENTITY expression_denoted_function
	SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
	expr : generic_expression :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 : (schema_prefix + 'FUNCTION_SPACE')IN TYPEOF(values_space_of(expr));
END_ENTITY; -- expression_denoted_function


ENTITY extended_tuple_space
	SUBTYPE OF (maths_space, generic_literal);
	base : product_space;
	extender : maths_space;
WHERE
	WR1 :  expression_is_constant(base)AND expression_is_constant(extender);
	WR2 :  no_cyclic_space_reference(SELF, [ ]);
	WR3 :  extender <> the_empty_space ;
END_ENTITY; -- extended_tuple_space


ENTITY externally_listed_data
	SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
	value_range : maths_space;
WHERE
	WR1 :  expression_is_constant(value_range);
END_ENTITY; -- externally_listed_data


ENTITY finite_function
	SUBTYPE OF (maths_function, generic_literal);
	pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
	WR1 :  VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY; -- finite_function


ENTITY finite_integer_interval
	SUBTYPE OF (maths_space, generic_literal);
	min : INTEGER;
	max : INTEGER;
DERIVE
	size : positive_integer :=  max - min + 1 ;
WHERE
	WR1 :  min <= max ;
END_ENTITY; -- finite_integer_interval


ENTITY finite_real_interval
	SUBTYPE OF (maths_space, generic_literal);
	min : REAL;
	min_closure : open_closed;
	max : REAL;
	max_closure : open_closed;
WHERE
	WR1 :  min < max ;
END_ENTITY; -- finite_real_interval


ENTITY finite_space
	SUBTYPE OF (maths_space, generic_literal);
	members : SET [0:?] OF maths_value;
WHERE
	WR1 :  VALUE_UNIQUE(members);
	WR2 :  SIZEOF(QUERY(expr <* QUERY(member <* members | 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN TYPEOF(member))| NOT expression_is_constant(expr)))= 0 ;
	WR3 :  no_cyclic_space_reference(SELF, [ ]);
END_ENTITY; -- finite_space


ENTITY free_variable_semantics
	SUBTYPE OF (variable_semantics);
END_ENTITY; -- free_variable_semantics


ENTITY function_application
	SUBTYPE OF (multiple_arity_generic_expression);
	func : maths_function_select;
	arguments : LIST [1:?] OF maths_expression;
DERIVE
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression :=  [ convert_to_maths_function(func)] + convert_to_operands(arguments);
WHERE
	WR1 :  function_applicability(func, arguments);
END_ENTITY; -- function_application


ENTITY function_space
	SUBTYPE OF (maths_space, generic_literal);
	domain_constraint : space_constraint_type;
	domain_argument : maths_space;
	range_constraint : space_constraint_type;
	range_argument : maths_space;
WHERE
	WR1 :  expression_is_constant(domain_argument)AND expression_is_constant(range_argument);
	WR2 : (domain_argument <> the_empty_space)AND(range_argument <> the_empty_space);
	WR3 : (domain_constraint <> sc_member)OR NOT member_of(the_empty_space, domain_argument);
	WR4 : (range_constraint <> sc_member)OR NOT member_of(the_empty_space, range_argument);
	WR5 :  NOT(any_space_satisfies(domain_constraint, domain_argument)AND any_space_satisfies(range_constraint, range_argument));
END_ENTITY; -- function_space


ENTITY general_linear_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	sum_index : one_or_two;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	mat : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_2d_table(mat);
	WR2 : (space_dimension(mat.range)= 1)AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY; -- general_linear_function


ENTITY homogeneous_linear_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	sum_index : one_or_two;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	mat : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_2d_table(mat);
	WR2 : (space_dimension(mat.range)= 1)AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY; -- homogeneous_linear_function


ENTITY imported_curve_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : curve;
	parametric_domain : tuple_space;
WHERE
	WR1 :  expression_is_constant(parametric_domain);
END_ENTITY; -- imported_curve_function


ENTITY imported_point_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : point;
END_ENTITY; -- imported_point_function


ENTITY imported_surface_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : surface;
	parametric_domain : tuple_space;
WHERE
	WR1 :  expression_is_constant(parametric_domain);
END_ENTITY; -- imported_surface_function


ENTITY imported_volume_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : volume;
	parametric_domain : tuple_space;
WHERE
	WR1 :  expression_is_constant(parametric_domain);
END_ENTITY; -- imported_volume_function


ENTITY integer_interval_from_min
	SUBTYPE OF (maths_space, generic_literal);
	min : INTEGER;
END_ENTITY; -- integer_interval_from_min


ENTITY integer_interval_to_max
	SUBTYPE OF (maths_space, generic_literal);
	max : INTEGER;
END_ENTITY; -- integer_interval_to_max


ENTITY integer_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [1:?] OF INTEGER;
END_ENTITY; -- integer_tuple_literal


ENTITY linearized_table_function
	SUPERTYPE OF (ONEOF (standard_table_function, regular_table_function, triangular_matrix, symmetric_matrix, banded_matrix))
	SUBTYPE OF (explicit_table_function, unary_generic_expression);
	first : INTEGER;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	source : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_1d_array(source);
	WR2 :  member_of(first, source.domain);
END_ENTITY; -- linearized_table_function


ENTITY listed_complex_number_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [2:?] OF REAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)/ 2 ] ;
WHERE
	WR1 :  NOT ODD(SIZEOF(values));
END_ENTITY; -- listed_complex_number_data


ENTITY listed_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF maths_value;
	value_range : maths_space;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
WHERE
	WR1 :  expression_is_constant(value_range);
	WR2 :  SIZEOF(QUERY(val <* values | NOT(member_of(val, value_range))))= 0 ;
END_ENTITY; -- listed_data


ENTITY listed_integer_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF INTEGER;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_integer_data


ENTITY listed_logical_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF LOGICAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_logical_data


ENTITY listed_product_space
	SUBTYPE OF (maths_space, generic_literal);
	factors : LIST [0:?] OF maths_space;
WHERE
	WR1 :  SIZEOF(QUERY(space <* factors | NOT(expression_is_constant(space))))= 0 ;
	WR2 :  no_cyclic_space_reference(SELF, [ ]);
	WR3 :  NOT(the_empty_space IN factors);
END_ENTITY; -- listed_product_space


ENTITY listed_real_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF REAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_real_data


ENTITY listed_string_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF STRING;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_string_data


ENTITY logical_literal
	SUBTYPE OF (generic_literal);
	lit_value : LOGICAL;
END_ENTITY; -- logical_literal


ENTITY mathematical_description;
	described : maths_expression;
	describing : STRING;
	encoding : label;
END_ENTITY; -- mathematical_description


ENTITY maths_boolean_variable
	SUBTYPE OF (maths_variable, boolean_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_booleans);
END_ENTITY; -- maths_boolean_variable


ENTITY maths_enum_literal
	SUBTYPE OF (generic_literal);
	lit_value : maths_enum_atom;
END_ENTITY; -- maths_enum_literal


ENTITY maths_function
	ABSTRACT SUPERTYPE OF (ONEOF (finite_function, constant_function, selector_function, elementary_function, restriction_function, repackaging_function, reindexed_array_function, series_composed_function, parallel_composed_function, explicit_table_function, homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function, rationalize_function, partial_derivative_function, definite_integral_function, abstracted_expression_function, expression_denoted_function, imported_point_function, imported_curve_function, imported_surface_function, imported_volume_function, application_defined_function))
	SUBTYPE OF (generic_expression);
DERIVE
	domain : tuple_space :=  derive_function_domain(SELF);
	range : tuple_space :=  derive_function_range(SELF);
END_ENTITY; -- maths_function


ENTITY maths_integer_variable
	SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_integers);
END_ENTITY; -- maths_integer_variable


ENTITY maths_real_variable
	SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_reals);
END_ENTITY; -- maths_real_variable


ENTITY maths_space
	ABSTRACT SUPERTYPE OF (ONEOF (elementary_space, finite_integer_interval, integer_interval_from_min, integer_interval_to_max, finite_real_interval, real_interval_from_min, real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region, finite_space, uniform_product_space, listed_product_space, extended_tuple_space, function_space))
	SUBTYPE OF (generic_expression);
END_ENTITY; -- maths_space


ENTITY maths_string_variable
	SUBTYPE OF (maths_variable, string_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_strings);
END_ENTITY; -- maths_string_variable


ENTITY maths_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [0:?] OF maths_value;
END_ENTITY; -- maths_tuple_literal


ENTITY maths_variable
	SUBTYPE OF (generic_variable);
	values_space : maths_space;
	name : label;
WHERE
	WR1 :  expression_is_constant(values_space);
END_ENTITY; -- maths_variable


ENTITY parallel_composed_function
	SUBTYPE OF (maths_function, multiple_arity_generic_expression);
	source_of_domain : maths_space_or_function;
	prep_functions : LIST [1:?] OF maths_function;
	final_function : maths_function_select;
DERIVE
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression :=  convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function);
WHERE
	WR1 :  no_cyclic_domain_reference(source_of_domain, [ SELF ]);
	WR2 :  expression_is_constant(domain_from(source_of_domain));
	WR3 :  parallel_composed_function_domain_check(domain_from(source_of_domain), prep_functions);
	WR4 :  parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY; -- parallel_composed_function


ENTITY partial_derivative_expression
	SUBTYPE OF (unary_generic_expression);
	d_variables : LIST [1:?] OF maths_variable;
	extension : extension_options;
DERIVE
	derivand : generic_expression :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  has_values_space(derivand);
	WR2 :  space_is_continuum(values_space_of(derivand));
	WR3 :  SIZEOF(QUERY(vbl <* d_variables |(NOT  subspace_of(values_space_of(vbl), the_reals))AND(NOT subspace_of(values_space_of(vbl), the_complex_numbers))))= 0 ;
END_ENTITY; -- partial_derivative_expression


ENTITY partial_derivative_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	d_variables : LIST [1:?] OF input_selector;
	extension : extension_options;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	derivand : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  space_is_continuum(derivand.range);
	WR2 :  partial_derivative_check(derivand.domain, d_variables);
END_ENTITY; -- partial_derivative_function


ENTITY polar_complex_number_literal
	SUBTYPE OF (generic_literal);
	radius : REAL;
	angle : REAL;
WHERE
	WR1 :  radius >= 0 ;
	WR2 :  { 0 <= angle < 2 * PI } ;
END_ENTITY; -- polar_complex_number_literal


ENTITY polar_complex_number_region
	SUBTYPE OF (maths_space, generic_literal);
	centre : complex_number_literal;
	distance_constraint : real_interval;
	direction_constraint : finite_real_interval;
WHERE
	WR1 :  min_exists(distance_constraint)AND(real_min(distance_constraint)>= 0.0);
	WR2 :  { - PI  <= direction_constraint.min < PI } ;
	WR3 :  direction_constraint.max - direction_constraint.min <= 2.0 * PI ;
	WR4 : (direction_constraint.max - direction_constraint.min < 2.0 * PI)OR(direction_constraint.min_closure = open);
	WR5 : (direction_constraint.max - direction_constraint.min < 2.0 * PI)OR(direction_constraint.max_closure = open)OR(direction_constraint.min = - PI);
	WR6 : (real_min(distance_constraint)> 0.0)OR  max_exists(distance_constraint)OR(direction_constraint.max - direction_constraint.min < 2.0 * PI)OR(direction_constraint.max_closure = open);
END_ENTITY; -- polar_complex_number_region


ENTITY quantifier_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (multiple_arity_generic_expression);
	variables : LIST [1:?] OF  UNIQUE generic_variable;
WHERE
	WR1 :  SIZEOF(QUERY(vrbl <* variables | NOT(vrbl IN SELF \ multiple_arity_generic_expression.operands)))= 0 ;
	WR2 :  SIZEOF(QUERY(vrbl <* variables | NOT((schema_prefix + 'BOUND_VARIABLE_SEMANTICS')IN TYPEOF(vrbl.interpretation.semantics))))= 0 ;
END_ENTITY; -- quantifier_expression


ENTITY rationalize_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	fun : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 : (space_dimension(fun.domain)= 1)AND(space_dimension(fun.range)= 1);
	WR2 :  number_tuple_subspace_check(factor1(fun.range));
	WR3 :  space_dimension(factor1(fun.range))> 1 ;
END_ENTITY; -- rationalize_function


ENTITY real_interval_from_min
	SUBTYPE OF (maths_space, generic_literal);
	min : REAL;
	min_closure : open_closed;
END_ENTITY; -- real_interval_from_min


ENTITY real_interval_to_max
	SUBTYPE OF (maths_space, generic_literal);
	max : REAL;
	max_closure : open_closed;
END_ENTITY; -- real_interval_to_max


ENTITY real_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [1:?] OF REAL;
END_ENTITY; -- real_tuple_literal


ENTITY regular_table_function
	SUBTYPE OF (linearized_table_function);
	increments : LIST [1:?] OF INTEGER;
WHERE
	WR1 :  SIZEOF(increments)= SIZEOF(SELF \ explicit_table_function.shape);
	WR2 :  extremal_position_check(SELF);
END_ENTITY; -- regular_table_function


ENTITY reindexed_array_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	starting_indices : LIST [1:?] OF INTEGER;
	SELF\unary_generic_expression.operand : maths_function;
WHERE
	WR1 :  function_is_array(SELF \ unary_generic_expression.operand);
	WR2 :  SIZEOF(starting_indices)= SIZEOF(shape_of_array(SELF \ unary_generic_expression.operand));
END_ENTITY; -- reindexed_array_function


ENTITY repackaging_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	input_repack : repackage_options;
	output_repack : repackage_options;
	selected_output : nonnegative_integer;
	SELF\unary_generic_expression.operand : maths_function;
WHERE
	WR1 : (input_repack <> ro_wrap_as_tuple)OR((space_dimension(operand.domain)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN TYPEOF(factor1(operand.domain))));
	WR2 : (output_repack <> ro_unwrap_tuple)OR((space_dimension(operand.range)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN TYPEOF(factor1(operand.range))));
	WR3 :  selected_output <= space_dimension(repackage(operand.range, output_repack));
END_ENTITY; -- repackaging_function


ENTITY restriction_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	SELF\unary_generic_expression.operand : maths_space;
END_ENTITY; -- restriction_function


ENTITY selector_function
	SUBTYPE OF (maths_function, generic_literal);
	selector : input_selector;
	source_of_domain : maths_space_or_function;
WHERE
	WR1 :  no_cyclic_domain_reference(source_of_domain, [ SELF ]);
	WR2 :  expression_is_constant(domain_from(source_of_domain));
END_ENTITY; -- selector_function


ENTITY series_composed_function
	SUBTYPE OF (maths_function, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF maths_function;
WHERE
	WR1 :  composable_sequence(SELF \ multiple_arity_generic_expression.operands);
END_ENTITY; -- series_composed_function


ENTITY standard_table_function
	SUBTYPE OF (linearized_table_function);
	order : ordering_type;
WHERE
	WR1 :  extremal_position_check(SELF);
END_ENTITY; -- standard_table_function


ENTITY strict_triangular_matrix
	SUBTYPE OF (triangular_matrix);
	main_diagonal_value : maths_value;
END_ENTITY; -- strict_triangular_matrix


ENTITY symmetric_banded_matrix
	SUBTYPE OF (symmetric_matrix);
	default_entry : maths_value;
	above : nonnegative_integer;
WHERE
	WR1 :  member_of(default_entry, factor1(SELF \ linearized_table_function.source.range));
END_ENTITY; -- symmetric_banded_matrix


ENTITY symmetric_matrix
	SUBTYPE OF (linearized_table_function);
	symmetry : symmetry_type;
	triangle : lower_upper;
	order : ordering_type;
WHERE
	WR1 :  SIZEOF(SELF \ explicit_table_function.shape)= 2 ;
	WR2 :  SELF  \ explicit_table_function.shape [ 1 ] = SELF \ explicit_table_function.shape [ 2 ] ;
	WR3 :  NOT(symmetry = skew)OR((space_dimension(SELF  \ linearized_table_function.source.range)= 1)AND subspace_of_es(factor1(SELF \ linearized_table_function.source.range), es_numbers));
	WR4 :  NOT((symmetry = hermitian)OR(symmetry = skew_hermitian))OR((space_dimension(SELF  \ linearized_table_function.source.range)= 1)AND subspace_of_es(factor1(SELF \ linearized_table_function.source.range), es_complex_numbers));
END_ENTITY; -- symmetric_matrix


ENTITY triangular_matrix
	SUBTYPE OF (linearized_table_function);
	default_entry : maths_value;
	lo_up : lower_upper;
	order : ordering_type;
WHERE
	WR1 :  SIZEOF(SELF \ explicit_table_function.shape)= 2 ;
	WR2 :  member_of(default_entry, SELF \ maths_function.range);
END_ENTITY; -- triangular_matrix


ENTITY uniform_product_space
	SUBTYPE OF (maths_space, generic_literal);
	base : maths_space;
	exponent : positive_integer;
WHERE
	WR1 :  expression_is_constant(base);
	WR2 :  no_cyclic_space_reference(SELF, [ ]);
	WR3 :  base <> the_empty_space ;
END_ENTITY; -- uniform_product_space


ENTITY amount_of_substance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- amount_of_substance_measure_with_unit


ENTITY amount_of_substance_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 1.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- amount_of_substance_unit


ENTITY area_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AREA_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- area_measure_with_unit


ENTITY area_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 2.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- area_unit


ENTITY celsius_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- celsius_temperature_measure_with_unit


ENTITY context_dependent_unit
	SUBTYPE OF (named_unit);
	name : label;
END_ENTITY; -- context_dependent_unit


ENTITY conversion_based_unit
	SUBTYPE OF (named_unit);
	name : label;
	conversion_factor : measure_with_unit;
END_ENTITY; -- conversion_based_unit


ENTITY derived_unit;
	elements : SET [1:?] OF derived_unit_element;
DERIVE
	name : label :=  get_name_value(SELF);
WHERE
	WR1 : (SIZEOF(elements)> 1)OR((SIZEOF(elements)= 1)AND(elements [ 1 ].exponent <> 1.0));
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- derived_unit


ENTITY derived_unit_element;
	unit : named_unit;
	exponent : REAL;
END_ENTITY; -- derived_unit_element


ENTITY dimensional_exponents;
	length_exponent : REAL;
	mass_exponent : REAL;
	time_exponent : REAL;
	electric_current_exponent : REAL;
	thermodynamic_temperature_exponent : REAL;
	amount_of_substance_exponent : REAL;
	luminous_intensity_exponent : REAL;
END_ENTITY; -- dimensional_exponents


ENTITY electric_current_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- electric_current_measure_with_unit


ENTITY electric_current_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 1.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- electric_current_unit


ENTITY global_unit_assigned_context
	SUBTYPE OF (representation_context);
	units : SET [1:?] OF unit;
END_ENTITY; -- global_unit_assigned_context


ENTITY length_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- length_measure_with_unit


ENTITY length_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 1.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- length_unit


ENTITY luminous_intensity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- luminous_intensity_measure_with_unit


ENTITY luminous_intensity_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY; -- luminous_intensity_unit


ENTITY mass_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MASS_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- mass_measure_with_unit


ENTITY mass_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 1.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- mass_unit


ENTITY measure_with_unit
	SUPERTYPE OF (ONEOF (length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit));
	value_component : measure_value;
	unit_component : unit;
WHERE
	WR1 :  valid_units(SELF);
END_ENTITY; -- measure_with_unit


ENTITY named_unit
	SUPERTYPE OF ((ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit, ratio_unit)));
	dimensions : dimensional_exponents;
END_ENTITY; -- named_unit


ENTITY plane_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- plane_angle_measure_with_unit


ENTITY plane_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- plane_angle_unit


ENTITY ratio_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- ratio_measure_with_unit


ENTITY ratio_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- ratio_unit


ENTITY si_unit
	SUBTYPE OF (named_unit);
	prefix : OPTIONAL si_prefix;
	name : si_unit_name;
DERIVE
	SELF\named_unit.dimensions : dimensional_exponents :=  dimensions_for_si_unit(name);
END_ENTITY; -- si_unit


ENTITY solid_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- solid_angle_measure_with_unit


ENTITY solid_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- solid_angle_unit


ENTITY thermodynamic_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- thermodynamic_temperature_measure_with_unit


ENTITY thermodynamic_temperature_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 1.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- thermodynamic_temperature_unit


ENTITY time_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TIME_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- time_measure_with_unit


ENTITY time_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 1.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- time_unit


ENTITY volume_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- volume_measure_with_unit


ENTITY volume_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 3.000000)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.time_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.000000)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY; -- volume_unit


ENTITY category_model_parameter
	SUBTYPE OF (model_parameter);
END_ENTITY; -- category_model_parameter


ENTITY model_parameter
	SUBTYPE OF (descriptive_representation_item, group_assignment, general_property);
	items : OPTIONAL SET [1:1] OF model_parameter_assigned_item;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 1 ;
	WR2 :  SIZEOF(QUERY(aga <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PARAMETER_TYPE' IN  TYPEOF(aga.assigned_group))AND(aga.assigned_group \ group.name IN [ 'string property type', 'logical property type', 'physical property type', 'boolean property type' ])))= 1 ;
END_ENTITY; -- model_parameter


ENTITY parameter_assignment_override
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF \ parameter_assignment_override)))= 0 ;
	WR2 :  SELF  \ representation_relationship.rep_1 <> SELF \ representation_relationship.rep_2 ;
	WR3 :  SELF \ representation_relationship.name = '' ;
	WR4 :  SELF \ representation.name = '' ;
	WR5 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_1);
	WR6 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_2);
END_ENTITY; -- parameter_assignment_override


ENTITY parameter_assignment_representation
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(SELF.items)= 2 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF(TYPEOF(it)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODEL_PARAMETER' ])= 1)))= 1 ;
	WR3 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF(TYPEOF(it)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COORDINATED_REPRESENTATION_ITEM' ])= 1)))<= 1 ;
	WR4 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF(QUERY(aga <* USEDIN(it, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')|(SIZEOF(TYPEOF(aga \ group_assignment.assigned_group)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHARACTERISTIC_TYPE' ])= 1)))= 1)))<= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ parameter_assignment_representation))= 0 ;
END_ENTITY; -- parameter_assignment_representation


ENTITY product_specific_parameter_value_assignment
	SUBTYPE OF (characterized_object, product_related_product_category);
WHERE
	WR1 :  SIZEOF(SELF \ product_related_product_category.products)= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'assigned parameter')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' ] * TYPEOF(pdr.used_representation))= 1)))= 1)))= 1 ;
	WR3 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHARACTERIZED_PRODUCT_CATEGORY' IN TYPEOF(SELF));
	WR4 :  SELF  \ characterized_object.name = SELF \ product_category.name ;
END_ENTITY; -- product_specific_parameter_value_assignment


ENTITY schema_based_model_parameter
	SUBTYPE OF (model_parameter);
END_ENTITY; -- schema_based_model_parameter


ENTITY attribute_language_assignment
	SUBTYPE OF (attribute_classification_assignment);
	items : SET [1:?] OF attribute_language_item;
	SELF\attribute_classification_assignment.assigned_class : language;
WHERE
	WR1 :  SELF \ attribute_classification_assignment.role.name IN [ 'primary', 'translated' ] ;
	WR2 :  SELF \ attribute_classification_assignment.attribute_name <> '' ;
END_ENTITY; -- attribute_language_assignment


ENTITY language
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name <> '' ;
END_ENTITY; -- language


ENTITY multi_language_attribute_assignment
	SUBTYPE OF (attribute_value_assignment);
	items : SET [1:?] OF multi_language_attribute_item;
DERIVE
	translation_language : language :=  language_indication [ 1 ] \ attribute_classification_assignment.assigned_class ;
INVERSE
	language_indication: SET [1:1] OF attribute_language_assignment FOR items;
WHERE
	WR1 : (SELF \ attribute_value_assignment.role.name = 'alternate language');
	WR2 :  SIZEOF(QUERY(ala <* language_indication |(ala \ attribute_classification_assignment.attribute_name = 'attribute_value')AND(ala \ attribute_classification_assignment.role.name = 'translated')))= 1 ;
	WR3 :  SELF \ attribute_value_assignment.attribute_name <> '' ;
	WR4 :  SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')|(ata \ attribute_value_assignment.attribute_name = SELF \ attribute_value_assignment.attribute_name)AND(ata.translation_language :=: translation_language)))> 1))= 0 ;
	WR5 :  SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')|(ata \ attribute_classification_assignment.role.name = 'primary')AND(ata \ attribute_classification_assignment.attribute_name = SELF \ attribute_value_assignment.attribute_name)AND(ata \ attribute_classification_assignment.assigned_class :=: translation_language)))> 0))= 0 ;
END_ENTITY; -- multi_language_attribute_assignment


ENTITY applied_name_assignment
	SUBTYPE OF (name_assignment);
	item : name_item;
END_ENTITY; -- applied_name_assignment


ENTITY bus_element_link
	SUBTYPE OF (product_definition, product_definition_relationship);
UNIQUE
	UR1 : related_product_definition, relating_product_definition;
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN  TYPEOF(SELF  \ product_definition_relationship.related_product_definition))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.related_product_definition));
	WR3 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN  TYPEOF(SELF  \ product_definition_relationship.relating_product_definition))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.relating_product_definition));
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF  \ product_definition_relationship || SELF \ bus_element_link))= 0 ;
	WR5 :  NOT EXISTS(SELF  \ product_definition.name)OR(SELF \ product_definition.name = '');
	WR6 :  SELF \ product_definition_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))>= 1 ;
END_ENTITY; -- bus_element_link


ENTITY bus_structural_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SIZEOF(QUERY(bce <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'bus composition')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_ELEMENT_LINK' IN TYPEOF(bce.related_product_definition)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment'))<= 1))<= 1 ;
	WR3 :  consistent_bus_structural_definition(bag_to_set(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_ELEMENT_LINK' IN TYPEOF(pdr.related_product_definition))));
END_ENTITY; -- bus_structural_definition


ENTITY component_functional_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated terminal')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(it.relating_shape_aspect)))= 1 ;
	WR3 :  SIZEOF(QUERY(futba <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit terminal bus assignment')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(futba.relating_property_definition.definition)))<= 1 ;
	WR4 :  SIZEOF(QUERY(futna <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit terminal node assignment')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(futna.relating_property_definition.definition)))<= 1 ;
END_ENTITY; -- component_functional_terminal


ENTITY component_functional_unit
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'functional occurrence' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_FUNCTIONAL_TERMINAL' IN TYPEOF(sa)))>= 1))>= 1 ;
	WR3 :  SIZEOF(QUERY(ifu <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated functional unit')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)))= 1 ;
	WR4 :  SIZEOF(QUERY(nc <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'network composition')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(nc.relating_product_definition))AND(nc.relating_product_definition.frame_of_reference.name = 'functional network design')))= 1 ;
END_ENTITY; -- component_functional_unit


ENTITY network_node_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'functional network design' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(funtdna <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition node assignment')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(funtdna.related_property_definition))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(funtdna.related_property_definition.definition))))<= 1))<= 1 ;
	WR3 :  SIZEOF(QUERY(funn <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(funn.relating_product_definition))AND(funn.relating_product_definition.frame_of_reference.name = 'functional network design')))= 1 ;
END_ENTITY; -- network_node_definition


ENTITY functional_terminal_group
	SUBTYPE OF (group);
UNIQUE
	UR1 : name;
END_ENTITY; -- functional_terminal_group


ENTITY functional_unit
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name IN [ 'functional design usage', 'functional network design' ] ;
	WR2 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR3 :  SIZEOF(QUERY(adta <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))= 1 ;
	WR4 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR5 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR6 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR7 : (NOT(SELF.frame_of_reference.name = 'functional network design'))OR(SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')| du.relating_product_definition.frame_of_reference.name = 'functional design usage'))= 1);
	WR8 : (NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'THERMAL_NETWORK', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ELECTRICAL_NETWORK' ] * TYPEOF(SELF))= 1))OR(SELF.frame_of_reference.name = 'functional network design');
END_ENTITY; -- functional_unit


ENTITY functional_unit_terminal_definition
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'functional design usage');
	WR2 :  SIZEOF(QUERY(pd2 <* QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION' IN  TYPEOF(pd))| SIZEOF(QUERY(funtdba <* QUERY(pdr <* USEDIN(pd2, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(funtdba.relating_property_definition.definition)))<= 1))<= 1 ;
	WR3 :  SIZEOF(QUERY(pd2 <* QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION' IN  TYPEOF(pd))| SIZEOF(QUERY(funtdna <* QUERY(pdr <* USEDIN(pd2, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition node assignment')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(funtdna.relating_property_definition.definition)))<= 1))<= 1 ;
END_ENTITY; -- functional_unit_terminal_definition


ENTITY make_from_functional_unit_terminal_definition_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : relating_shape_aspect, related_shape_aspect;
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' ] * TYPEOF(SELF.relating_shape_aspect))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' ] * TYPEOF(SELF.related_shape_aspect))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ make_from_functional_unit_terminal_definition_relationship))= 0 ;
	WR4 :  relating_shape_aspect.of_shape :<>: related_shape_aspect.of_shape ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect.description = '' ;
	WR7 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR8 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'))= 0 ;
	WR9 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESIGN_MAKE_FROM_RELATIONSHIP')IN TYPEOF(sar.of_shape \ property_definition.definition))))= 1 ;
END_ENTITY; -- make_from_functional_unit_terminal_definition_relationship


ENTITY scalar_terminal_definition_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : related_shape_aspect, relating_shape_aspect;
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ scalar_terminal_definition_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SELF \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'scalar terminal' ;
	WR8 :  SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'scalar terminal' ;
END_ENTITY; -- scalar_terminal_definition_link


ENTITY group_shape_aspect
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(SELF \ shape_aspect.of_shape.definition);
	WR2 :  NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ])OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF  \ shape_aspect.of_shape.definition))AND(EXISTS(SELF  \ shape_aspect.of_shape.definition \ product_definition.name))AND(NOT EXISTS(SELF  \ shape_aspect.of_shape.definition \ product_definition.name)OR(SELF \ shape_aspect.of_shape.definition \ product_definition.name = 'interconnect module')));
	WR3 : ((NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'constrained object')AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY')IN TYPEOF(pdr.related_property_definition.definition)))))= 1)))= 1));
	WR4 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'design specific purpose')))= 1))= 1)))= 0);
	WR5 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'keepout')AND(it \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1)))= 0);
	WR6 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))= 1))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'requirement')AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY')IN TYPEOF(pdr.relating_property_definition)))))= 1)))= 1);
	WR8 : (NOT(SELF  \ shape_aspect.description = 'termination constraint'))OR(SIZEOF(QUERY(ctm <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'constrained termination member')| ctm.related_shape_aspect \ shape_aspect.description = 'mating connector termination'))>= 2);
	WR9 :  EXISTS(SELF \ shape_aspect.description);
	WR10 : (NOT(SELF  \ shape_aspect.description IN  [ 'placement group' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'requirement')AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY')IN TYPEOF(pdr.relating_property_definition))AND(pdr.relating_property_definition \ property_definition.name = 'requirement'))))= 1)))= 1);
	WR11 : (NOT(SELF  \ shape_aspect.description IN  [ 'termination constraint' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'termination usage constraint')AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY')IN TYPEOF(pdr.relating_property_definition))AND(pdr.relating_property_definition \ property_definition.name = 'termination usage constraint'))))= 1)))= 1);
END_ENTITY; -- group_shape_aspect


ENTITY reference_graphic_registration_mark
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = FALSE ;
END_ENTITY; -- reference_graphic_registration_mark


ENTITY seating_plane
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF \ seating_plane))= 0 ;
END_ENTITY; -- seating_plane


ENTITY functional_orientation_feature
	SUBTYPE OF (shape_aspect);
END_ENTITY; -- functional_orientation_feature


ENTITY guided_wave_terminal
	SUBTYPE OF (package_terminal);
END_ENTITY; -- guided_wave_terminal


ENTITY package
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'physical design usage' ;
	WR2 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'package'))> 0 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY' IN TYPEOF(sa)))= 1)))<= 1 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(sa)))>= 1)))>= 1 ;
	WR5 : (NOT(SELF  \ product_definition.description = 'altered package'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'package alteration')AND(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ] * TYPEOF(pdr.relating_product_definition))= 1)))= 1);
	WR6 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'package mounting data'))= 1)))= 1 ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body height above seating plane'))= 1)))= 1)))= 1 ;
	WR8 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body height below seating plane'))= 1)))= 1)))<= 1 ;
	WR9 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body clearance above seating plane'))= 1)))= 1)))<= 1 ;
	WR10 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body clearance below seating plane'))= 1)))= 1)))<= 1 ;
	WR11 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'minimum body clearance above seating plane'))= 1)))= 1)))<= 1 ;
	WR12 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'minimum body clearance below seating plane'))= 1)))= 1)))<= 1 ;
	WR13 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum lead length below seating plane'))= 1)))= 1)))<= 1 ;
	WR14 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'least lead length below seating plane'))= 1)))= 1)))<= 1 ;
	WR15 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(sa))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'package seating plane')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(sar.related_shape_aspect)))))= 1))))= 1)))= 1 ;
	WR16 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(sa))))= 1)))= 1 ;
	WR17 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(sa))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'of datum reference plane')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar.related_shape_aspect)))))= 1))))= 1)))<= 1 ;
	WR18 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sa))))= 1)))<= 1 ;
END_ENTITY; -- package


ENTITY package_body
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ])= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1 ;
END_ENTITY; -- package_body


ENTITY package_body_bottom_surface
	SUBTYPE OF (package_body_surface);
END_ENTITY; -- package_body_bottom_surface


ENTITY package_body_edge_segment_surface
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	wr1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	wr2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	wr3 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR4 :  SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed surface')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect))))= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ package_body_edge_segment_surface))= 0 ;
END_ENTITY; -- package_body_edge_segment_surface


ENTITY package_body_edge_surface
	SUBTYPE OF (package_body_surface);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional ;
	WR2 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ part_mounting_feature || SELF  \ package_body_edge_surface || SELF \ package_body_surface))= 0 ;
END_ENTITY; -- package_body_edge_surface


ENTITY package_body_surface
	ABSTRACT SUPERTYPE OF (ONEOF (package_body_top_surface, package_body_edge_surface, package_body_bottom_surface))
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(TYPEOF(sar \ shape_aspect_relationship.relating_shape_aspect)= [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY' ])))= 1 ;
END_ENTITY; -- package_body_surface


ENTITY package_body_top_surface
	SUBTYPE OF (package_body_surface);
END_ENTITY; -- package_body_top_surface


ENTITY package_terminal
	SUPERTYPE OF (((guided_wave_terminal ANDOR wire_terminal) ANDOR primary_reference_terminal))
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1)))= 0 ;
	WR2 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ])= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND(sar \ shape_aspect_relationship.name = 'terminal core material')AND(sar.relating_shape_aspect.of_shape.definition.frame_of_reference \ application_context_element.name = 'material definition')))<= 1 ;
	WR4 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND(sar \ shape_aspect_relationship.name = 'terminal surface material')AND(sar.relating_shape_aspect.of_shape.definition.frame_of_reference \ application_context_element.name = 'material definition')))= 1 ;
	WR5 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'external connection zone')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))>= 0 ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'maximum terminal diametrical extent'))<= 1))<= 1))<= 1 ;
	WR8 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'minimum terminal diametrical extent'))<= 1))<= 1))<= 1 ;
	WR9 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))<= 1 ;
	WR10 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))<= 1 ;
	WR11 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'seating plane zone')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))<= 1 ;
END_ENTITY; -- package_terminal


ENTITY primary_orientation_feature
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = TRUE ;
	WR2 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
	WR3 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
END_ENTITY; -- primary_orientation_feature


ENTITY primary_reference_terminal
	SUBTYPE OF (package_terminal);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))<= 1 ;
END_ENTITY; -- primary_reference_terminal


ENTITY secondary_orientation_feature
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 :  SIZEOF((TYPEOF(SELF))* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRIMARY_ORIENTATION_FEATURE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SEATING_PLANE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'VIEWING_PLANE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_DATUM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ])= 0 ;
	WR2 :  SELF.product_definitional = TRUE ;
	WR3 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
	WR4 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
END_ENTITY; -- secondary_orientation_feature


ENTITY tertiary_orientation_feature
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 :  SIZEOF((TYPEOF(SELF))* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRIMARY_ORIENTATION_FEATURE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SECONDARY_ORIENTATION_FEATURE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SEATING_PLANE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'VIEWING_PLANE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_DATUM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ])= 0 ;
	WR2 :  SELF.product_definitional = TRUE ;
	WR3 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
	WR4 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
END_ENTITY; -- tertiary_orientation_feature


ENTITY wire_terminal
	SUBTYPE OF (package_terminal);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF(QUERY(it <* pdr.used_representation.items |(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM')IN  TYPEOF(it))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_UNIT')IN TYPEOF(it \ measure_with_unit.unit_component))))= 2)))= 1))))= 0);
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'maximum wire terminal length')AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_UNIT')IN TYPEOF(it \ measure_with_unit.unit_component))))= 1)))= 1))))= 0);
	WR3 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'minimum wire terminal length')AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_UNIT')IN TYPEOF(it \ measure_with_unit.unit_component))))= 1)))= 1))))= 0);
	WR4 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'internal connection zone')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1);
END_ENTITY; -- wire_terminal


ENTITY packaged_connector
	SUBTYPE OF (packaged_part);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sa))))= 1)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'interface plane'))= 1)))= 1)))<= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(sa))))= 1)))<= 1 ;
END_ENTITY; -- packaged_connector


ENTITY packaged_connector_terminal_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 : (SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ])= 1)AND(SELF.of_shape.definition \ product_definition.description = 'packaged connector');
	WR2 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF  \ shape_aspect_relationship.related_shape_aspect))AND(SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'interface terminal'));
	WR3 : (('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF  \ shape_aspect_relationship.related_shape_aspect))AND(SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'join terminal'));
END_ENTITY; -- packaged_connector_terminal_relationship


ENTITY packaged_part
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))>= 0)))= 0 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))<= 1 ;
	WR3 :  SIZEOF(QUERY(ifu <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'implemented function')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition))AND(ifu.relating_product_definition.frame_of_reference.name = 'functional design usage')))<= 1 ;
	WR4 :  NOT(EXISTS(SELF  \ product_definition.description))OR((NOT(SELF  \ product_definition.description = 'altered packaged part'))OR(SIZEOF(QUERY(bpp <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'base packaged part')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(bpp.relating_product_definition))= 1)AND(bpp.relating_product_definition.frame_of_reference.name = 'physical design usage')))>= 1));
	WR5 :  SIZEOF(QUERY(upkg <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'used package')| SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ] * TYPEOF(upkg.relating_product_definition))= 1))>= 1 ;
	WR6 :  SELF.frame_of_reference.name = 'physical design usage' ;
END_ENTITY; -- packaged_part


ENTITY packaged_part_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ] ;
	WR2 : (SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ])= 1)AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical design usage');
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(top <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'terminal of package')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(top.related_shape_aspect)))>= 1 ;
	WR5 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
	WR6 : (NOT(SELF  \ shape_aspect.description = 'interface terminal'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))AND(sar.relating_shape_aspect \ shape_aspect.description = 'join terminal')))>= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'join terminal'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))AND(sar.relating_shape_aspect \ shape_aspect.description = 'interface terminal')))<= 1);
END_ENTITY; -- packaged_part_terminal


ENTITY fiducial_part_feature
	SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- fiducial_part_feature


ENTITY part_interface_access_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'interface_access area')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1 ;
END_ENTITY; -- part_interface_access_feature


ENTITY part_mating_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'mating area')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1 ;
END_ENTITY; -- part_mating_feature


ENTITY part_mounting_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'mounting area')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1 ;
END_ENTITY; -- part_mounting_feature


ENTITY part_tooling_feature
	SUPERTYPE OF ((ONEOF (fiducial_part_feature, tool_registration_mark) ANDOR test_point_part_feature))
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = TRUE ;
END_ENTITY; -- part_tooling_feature


ENTITY test_point_part_feature
	SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- test_point_part_feature


ENTITY thermal_feature
	SUBTYPE OF (shape_aspect);
END_ENTITY; -- thermal_feature


ENTITY tool_registration_mark
	SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- tool_registration_mark


ENTITY part_connected_terminals_definition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART_TERMINAL' ] * TYPEOF(mct.related_shape_aspect))= 1))>= 2 ;
END_ENTITY; -- part_connected_terminals_definition


ENTITY applied_organization_assignment
	SUBTYPE OF (organization_assignment);
	items : SET [1:?] OF organization_item;
END_ENTITY; -- applied_organization_assignment


ENTITY applied_person_and_organization_assignment
	SUBTYPE OF (person_and_organization_assignment);
	items : SET [1:?] OF person_and_organization_item;
END_ENTITY; -- applied_person_and_organization_assignment


ENTITY person_and_organization_address
	SUBTYPE OF (organizational_address, personal_address);
	SELF\organizational_address.organizations : SET [1:1] OF organization;
	SELF\personal_address.people : SET [1:1] OF person;
WHERE
	WR1 :  SIZEOF(QUERY(pao <* USEDIN(SELF  \ personal_address.people [ 1 ], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON')| pao.the_organization :=: SELF \ organizational_address.organizations [ 1 ]))= 1 ;
END_ENTITY; -- person_and_organization_address


ENTITY address;
	internal_location : OPTIONAL label;
	street_number : OPTIONAL label;
	street : OPTIONAL label;
	postal_box : OPTIONAL label;
	town : OPTIONAL label;
	region : OPTIONAL label;
	postal_code : OPTIONAL label;
	country : OPTIONAL label;
	facsimile_number : OPTIONAL label;
	telephone_number : OPTIONAL label;
	electronic_mail_address : OPTIONAL label;
	telex_number : OPTIONAL label;
DERIVE
	name : label :=  get_name_value(SELF);
	url : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  EXISTS(internal_location)OR  EXISTS(street_number)OR  EXISTS(street)OR  EXISTS(postal_box)OR  EXISTS(town)OR  EXISTS(region)OR  EXISTS(postal_code)OR  EXISTS(country)OR  EXISTS(facsimile_number)OR  EXISTS(telephone_number)OR  EXISTS(electronic_mail_address)OR EXISTS(telex_number);
END_ENTITY; -- address


ENTITY organization;
	id : OPTIONAL identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization


ENTITY organization_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organization : organization;
	related_organization : organization;
END_ENTITY; -- organization_relationship


ENTITY organization_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- organization_role


ENTITY organization_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization_type


ENTITY organization_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_organization_type : organization_type;
	related_organization_type : organization_type;
END_ENTITY; -- organization_type_relationship


ENTITY organizational_address
	SUBTYPE OF (address);
	organizations : SET [1:?] OF organization;
	description : OPTIONAL text;
END_ENTITY; -- organizational_address


ENTITY organizational_project;
	name : label;
	description : OPTIONAL text;
	responsible_organizations : SET [1:?] OF organization;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- organizational_project


ENTITY organizational_project_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organizational_project : organizational_project;
	related_organizational_project : organizational_project;
END_ENTITY; -- organizational_project_relationship


ENTITY person;
	id : identifier;
	last_name : OPTIONAL label;
	first_name : OPTIONAL label;
	middle_names : OPTIONAL LIST [1:?] OF label;
	prefix_titles : OPTIONAL LIST [1:?] OF label;
	suffix_titles : OPTIONAL LIST [1:?] OF label;
WHERE
	WR1 :  EXISTS(last_name)OR EXISTS(first_name);
END_ENTITY; -- person


ENTITY person_and_organization;
	the_person : person;
	the_organization : organization;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- person_and_organization


ENTITY person_and_organization_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- person_and_organization_role


ENTITY person_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- person_role


ENTITY person_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type


ENTITY person_type_definition;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	formation : person_type_definition_formation;
END_ENTITY; -- person_type_definition


ENTITY person_type_definition_formation;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	of_person_type : person_type;
END_ENTITY; -- person_type_definition_formation


ENTITY person_type_definition_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_person_type_definition : person_type_definition;
	related_person_type_definition : person_type_definition;
END_ENTITY; -- person_type_definition_relationship


ENTITY personal_address
	SUBTYPE OF (address);
	people : SET [1:?] OF person;
	description : OPTIONAL text;
END_ENTITY; -- personal_address


ENTITY position_in_organization;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization


ENTITY position_in_organization_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_position_in_organization : position_in_organization;
	related_position_in_organization : position_in_organization;
END_ENTITY; -- position_in_organization_relationship


ENTITY position_in_organization_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_type


ENTITY part_template_definition
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.of_shape \ property_definition.definition.frame_of_reference \ application_context_element.name = 'template definition' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'part template analytical model')))<= 1)))= 0 ;
	WR3 : (NOT(SELF  \ shape_aspect.description = 'component termination passage template'))OR(SIZEOF(QUERY(ctpt <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(ctpt.relating_shape_aspect))AND(ctpt.relating_shape_aspect \ shape_aspect.description = 'default component termination passage definition')))= 1);
	WR4 : (NOT(SELF  \ shape_aspect.description = 'component termination passage template'))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'access mechanism')| am.related_shape_aspect \ shape_aspect.description IN [ 'component termination passage template interface terminal', 'component termination passage template join terminal' ]))>= 2);
	WR5 : (NOT(SELF  \ shape_aspect.description = 'default trace template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))= 1))= 1);
	WR6 : (NOT(SELF  \ shape_aspect.description = 'inter stratum feature template'))OR(SIZEOF(QUERY(isfpt <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(isfpt.relating_shape_aspect))))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'printed connector template'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name IN [ 'connector' ]))>= 1);
	WR8 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'transmission line model')))= 1)))= 0);
	WR9 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2))= 2))= 1)))= 0);
	WR10 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum width')))= 1))= 1)))= 0);
	WR11 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum width')))= 1))= 1)))= 0);
	WR12 : (NOT(SELF  \ shape_aspect.description = 'printed part template'))OR(SIZEOF(QUERY(impl_func <* QUERY(pdr <* USEDIN(SELF.of_shape.definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'implemented function')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(impl_func.relating_product_definition))AND(impl_func.relating_product_definition.frame_of_reference.name = 'functional design usage')))= 1);
	WR13 : (NOT(SELF  \ shape_aspect.description = 'printed part template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated definition')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(ad.related_shape_aspect))AND(ad.related_shape_aspect \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ])))>= 2);
	WR14 : (NOT(SELF  \ shape_aspect.description = 'trace template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'curve style parameters'))= 1)))= 1);
	WR15 : (NOT(SELF  \ shape_aspect.description = 'unsupported passage template'))OR(SIZEOF(QUERY(upt <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(upt.relating_shape_aspect))AND(upt.relating_shape_aspect \ shape_aspect.description = 'default unsupported passage definition')))= 1);
	WR16 : (NOT(SELF  \ shape_aspect.description = 'via template'))OR(SIZEOF(QUERY(vpt <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(vpt.relating_shape_aspect))AND(vpt.relating_shape_aspect \ shape_aspect.description = 'default via definition')))= 1);
	WR17 : (NOT(SELF  \ shape_aspect.description = 'via template'))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'access mechanism')| am.related_shape_aspect \ shape_aspect.description = 'via template terminal'))>= 2);
	WR18 :  EXISTS(SELF \ shape_aspect.name);
	WR19 : (NOT(SELF  \ shape_aspect.description = 'non conductive cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition))))= 1))= 1);
	WR20 : (NOT(SELF  \ shape_aspect.description = 'non conductive cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'nominal width')))= 1))= 1)))= 0);
	WR21 : (NOT(SELF  \ shape_aspect.description = 'printed connector template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated definition')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(ad.related_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ])))>= 2);
	WR22 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'horizontal material link')| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'left')))))= 0);
	WR27 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'horizontal material link')| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'right')))))= 0);
	WR28 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'vertical material link')| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'bottom')))))= 0);
	WR29 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'vertical material link')| NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'top')))))= 0);
	WR30 :  SELF \ shape_aspect.name = 'NULL' ;
END_ENTITY; -- part_template_definition


ENTITY component_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = 'planar projected shape'))<= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = '3d bound volume shape'))<= 1)))= 0 ;
	WR3 : (NOT(SELF  \ product_definition.description = 'bare die component'))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1);
	WR4 :  NOT(is_assembly_module_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(ip.relating_product_definition \ product_definition.name = 'assembly module')))= 1);
	WR5 :  NOT(is_assembly_module_occurrence(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'assembly module component terminal')))>= 2))>= 1);
	WR6 :  NOT(is_interconnect_module_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(SELF \ product_definition.name = 'interconnect module')))= 1);
	WR7 : (NOT(SELF  \ product_definition.description = 'mating connector'))OR((('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN  TYPEOF(SELF))AND(SIZEOF(QUERY(doc <* SELF  \ product_definition_with_associated_documents.documentation_ids | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EE_SPECIFICATION' IN  TYPEOF(doc)))= 1))OR(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pt_occ <* QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| sa \ shape_aspect.description = 'part template occurrence')| SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(pt_occ, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'printed connector template')))= 1))= 1)))= 0)OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition \ product_definition.description = 'packaged connector')))= 1));
	WR8 : (NOT(SELF  \ product_definition.description = 'mating connector'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'mating connector placement'))= 1))= 1);
	WR9 : (NOT(SELF  \ product_definition.description = 'mating connector'))OR((SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdr)))= 0)AND(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr)))= 0));
	WR10 :  SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| NOT(NOT(pdr \ product_definition_relationship.name = 'instantiated part')OR(SELF.formation :=: pdr.relating_product_definition.formation))))= 0 ;
	WR11 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))|(sr_pdr.used_representation \ representation.name = 'part template non planar 2d shape')OR(sr_pdr.used_representation \ representation.name = 'non planar 2d shape')OR(sr_pdr.used_representation \ representation.name = 'open shell based surface')))<= 1)))= 0 ;
	WR13 :  NOT(is_assembly_module_macro_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design definition')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design')AND(ip.relating_product_definition \ product_definition.name = 'assembly module')))= 1);
	WR14 :  NOT(is_interconnect_module_macro_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design definition')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design')AND(ip.relating_product_definition \ product_definition.name = 'interconnect module')))= 1);
	WR15 :  SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'instantiated definition')AND(NOT(SELF.formation :=: pdr.relating_product_definition.formation)))))= 0 ;
	WR16 : (NOT(SELF  \ product_definition.description = 'routed interconnect component'))OR((SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1)AND(SELF.frame_of_reference.name = 'physical occurrence'));
END_ENTITY; -- component_definition


ENTITY component_shape_aspect
	SUPERTYPE OF (thermal_component_shape_aspect)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 : (SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTER_STRATUM_FEATURE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FIDUCIAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONNECTED_AREA_COMPONENT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'THERMAL_COMPONENT_SHAPE_ASPECT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTEGRAL_SHIELD', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROBE_ACCESS_AREA', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LAND' ] * TYPEOF(SELF))>= 1)OR(SELF \ shape_aspect.description IN [ 'part template occurrence', 'laminate component', 'laminate text component', 'laminate text string component', 'conductive interconnect element with  pre defined transitions', 'join 2 physical connectivity definition supporting', 'conductive interconnect element with user defined single transition', 'special symbol laminate component', 'primary stratum indicator symbol', 'stratum feature template component' ]);
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = 'planar projected shape'))<= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = '3d bound volume shape'))<= 1)))= 0 ;
	WR5 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'laminate text component', 'laminate text string component', 'special symbol laminate component', 'primary stratum indicator symbol', 'stratum feature template component' ])OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.description = 'laminate component')));
	WR6 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description = 'laminate text component')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_TEXT_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))))= 1));
	WR7 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'stratum feature template component' ])OR(SIZEOF(QUERY(sfi <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'stratum feature implementation')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect))))= 1));
	WR8 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'conductive interconnect element with  pre defined transitions', 'join 2 physical connectivity definition supporting', 'conductive interconnect element with ' + 'user defined single transition' ])OR(SIZEOF(QUERY(cc <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed conductor')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(cc.related_shape_aspect))))= 1));
	WR10 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'special symbol laminate component', 'primary stratum indicator symbol' ])OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.related_shape_aspect \ shape_aspect.description = 'special symbol part template'))))= 1));
	WR11 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description = 'stratum feature template component')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN  TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'stratum feature template'))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))<= 1));
	WR12 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'laminate text component' ])OR(SIZEOF(QUERY(sfi <* QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'stratum feature implementation')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect))))>= 1));
	WR13 :  NOT((SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTER_STRATUM_FEATURE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FIDUCIAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONNECTED_AREA_COMPONENT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'THERMAL_COMPONENT_SHAPE_ASPECT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTEGRAL_SHIELD', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROBE_ACCESS_AREA', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LAND' ] * TYPEOF(SELF))>= 1)OR(SELF  \ shape_aspect.description IN  [ 'laminate component', 'laminate text component', 'laminate text string component', 'conductive interconnect element with  pre defined transitions', 'join 2 physical connectivity definition supporting', 'conductive interconnect element with user defined single transition', 'special symbol laminate component', 'primary stratum indicator symbol', 'stratum feature template component' ]))OR(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference \ application_context_element.name = 'layout occurrence'));
	WR14 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template'))<= 1 ;
	WR15 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description = 'join 2 physical connectivity definition supporting')OR(SIZEOF(QUERY(propd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(ri <* QUERY(propdr <* USEDIN(propd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| propdr \ property_definition_relationship.name = 'requirement implementation')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP' IN  TYPEOF(ri.relating_property_definition.definition))AND(ri.relating_property_definition.definition \ shape_aspect_relationship.name = 'ordered physical connectivity definition')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN  TYPEOF(ri.relating_property_definition.definition.related_shape_aspect))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(ri.relating_property_definition.definition.relating_shape_aspect))))= 1)))= 1));
END_ENTITY; -- component_shape_aspect


ENTITY thermal_component
	SUBTYPE OF (component_definition);
END_ENTITY; -- thermal_component


ENTITY thermal_component_shape_aspect
	SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- thermal_component_shape_aspect


ENTITY connection_zone_map_identification
	SUBTYPE OF (shape_aspect, representation_relationship);
WHERE
	WR1 :  SELF  \ representation_relationship.rep_2 :<>: SELF \ representation_relationship.rep_1 ;
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF \ representation_relationship.rep_1);
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF \ representation_relationship.rep_2);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ representation_relationship || SELF \ connection_zone_map_identification))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ representation_relationship.name = '' ;
	WR7 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FOOTPRINT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
END_ENTITY; -- connection_zone_map_identification


ENTITY make_from_part_feature_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : relating_shape_aspect, related_shape_aspect;
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.relating_shape_aspect))= 0 ;
	WR2 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.related_shape_aspect))= 0 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ make_from_part_feature_relationship))= 0 ;
	WR4 :  SELF.related_shape_aspect.product_definitional = TRUE ;
	WR5 :  SELF.relating_shape_aspect.product_definitional = TRUE ;
	WR6 :  SELF \ shape_aspect.name = '' ;
	WR7 :  SELF \ shape_aspect.description = '' ;
	WR8 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR9 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'))= 0 ;
	WR10 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESIGN_MAKE_FROM_RELATIONSHIP')IN TYPEOF(sar.of_shape \ property_definition.definition))))= 1 ;
END_ENTITY; -- make_from_part_feature_relationship


ENTITY part_feature_template_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ part_feature_template_definition)))= 0 ;
	WR7 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1 ;
END_ENTITY; -- part_feature_template_definition


ENTITY physical_unit
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SELF.frame_of_reference.name IN [ 'physical design', 'physical design usage' ] ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(dut <* QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'physical unit technology')| dut.relating_property_definition \ property_definition.name = 'unit technology'))= 1))<= 1 ;
	WR8 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)))>= 1)))= 0);
	WR9 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'maximum negative component height'))<= 1)))= 0);
	WR10 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'maximum positive component height'))<= 1)))= 0);
	WR11 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')))= 1);
	WR12 :  NOT(is_assembly_module_design(SELF))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')|(is_laminate_component(pdr.related_product_definition))))= 0);
	WR14 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')))<= 1);
	WR15 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd1 <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(pd1))AND(SIZEOF(QUERY(cd <* USEDIN(pd1, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHARACTERIZED_DEFINITION' IN TYPEOF(cd))AND(SIZEOF(QUERY(pd2 <* USEDIN(cd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd2 \ property_definition.name = 'located interconnect module thickness')AND(SIZEOF(USEDIN(pd2, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))> 1)))= 1)))= 1)))<= 1);
	WR16 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')))<= 1);
	WR17 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'minimum thickness over metal requirement')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR18 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'maximum thickness over metal requirement')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR19 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'minimum thickness over dielectric requirement')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR20 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'maximum thickness over dielectric requirement')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR21 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|((pd \ property_definition.name = 'restraint')OR(pd \ property_definition.name = 'tolerance specific restraint'))))<= 1);
	WR22 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(sa \ shape_aspect.description = 'interconnect module primary surface')))<= 1)))= 0);
	WR23 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(sa \ shape_aspect.description = 'interconnect module secondary surface')))<= 1)))= 0);
	WR24 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(sa \ shape_aspect.description = 'interconnect module edge surface')))<= 1)))= 0);
	WR25 :  NOT(is_assembly_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'assembly module')AND(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(sa))))> 0)))= 0)))OR(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(sa))AND(SIZEOF(QUERY(acu <* USEDIN(sa \ shape_aspect_relationship.relating_shape_aspect.of_shape.definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))>= 1)))>= 1)))>= 1));
	WR26 :  NOT(is_assembly_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'assembly module')))AND(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(acu <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))= 0)))= 0));
	WR27 :  NOT(is_assembly_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'assembly module')))AND(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(cl <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect.of_shape.definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_LOCATION' IN  TYPEOF(cl))AND(aj IN cl \ representation.items)))= 0)))= 0));
	WR28 :  NOT(is_interconnect_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'interconnect module')))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN  TYPEOF(pdr))AND(pdr \ product_definition_relationship.name = 'interconnect module stratum assembly relationship')AND(pdr.related_product_definition \ product_definition.description = 'primary design layer stratum')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRATUM' IN TYPEOF(pdr.related_product_definition)))))= 1));
END_ENTITY; -- physical_unit


ENTITY usage_view_connection_zone_terminal_shape_relationship
	SUBTYPE OF (representation, representation_relationship_with_transformation);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' ] * TYPEOF(SELF.rep_1))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' ] * TYPEOF(SELF.rep_2))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ representation_relationship_with_transformation || SELF \ usage_view_connection_zone_terminal_shape_relationship)))= 0 ;
	WR4 :  SELF  \ representation_relationship.rep_1 <> SELF \ representation_relationship.rep_2 ;
END_ENTITY; -- usage_view_connection_zone_terminal_shape_relationship


ENTITY known_source
	SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY; -- known_source


ENTITY action_property_representation;
	name : label;
	description : text;
	property : action_property;
	representation : representation;
END_ENTITY; -- action_property_representation


ENTITY resource_property_representation;
	name : label;
	description : text;
	property : resource_property;
	representation : representation;
END_ENTITY; -- resource_property_representation


ENTITY action_property;
	name : label;
	description : text;
	definition : characterized_action_definition;
END_ENTITY; -- action_property


ENTITY action_property_relationship;
	name : label;
	description : text;
	relating_action_property : action_property;
	related_action_property : action_property;
WHERE
	WR1 :  relating_action_property :<>: related_action_property ;
END_ENTITY; -- action_property_relationship


ENTITY action_resource_requirement;
	name : label;
	description : text;
	kind : resource_requirement_type;
	operations : SET [1:?] OF characterized_action_definition;
END_ENTITY; -- action_resource_requirement


ENTITY action_resource_requirement_relationship;
	name : label;
	description : text;
	relating_action_resource_requirement : action_resource_requirement;
	related_action_resource_requirement : action_resource_requirement;
WHERE
	WR1 :  relating_action_resource_requirement :<>: related_action_resource_requirement ;
END_ENTITY; -- action_resource_requirement_relationship


ENTITY process_product_association;
	name : label;
	description : text;
	defined_product : characterized_product_definition;
	process : product_definition_process;
END_ENTITY; -- process_product_association


ENTITY process_property_association;
	name : label;
	description : text;
	process : property_process;
	property_or_shape : property_or_shape_select;
END_ENTITY; -- process_property_association


ENTITY product_definition_process
	SUBTYPE OF (action);
	identification : identifier;
INVERSE
	product_definitions: SET [1:?] OF process_product_association FOR process;
END_ENTITY; -- product_definition_process


ENTITY property_process
	SUBTYPE OF (action);
	identification : identifier;
INVERSE
	properties: SET [1:?] OF process_property_association FOR process;
END_ENTITY; -- property_process


ENTITY replacement_relationship
	SUBTYPE OF (action_relationship);
WHERE
	WR1 :  acyclic_action_relationship(SELF , [ SELF \ action_relationship.related_action ], 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REPLACEMENT_RELATIONSHIP');
END_ENTITY; -- replacement_relationship


ENTITY requirement_for_action_resource
	SUBTYPE OF (action_resource_requirement);
	resources : SET [1:?] OF action_resource;
END_ENTITY; -- requirement_for_action_resource


ENTITY resource_property;
	name : label;
	description : text;
	resource : characterized_resource_definition;
END_ENTITY; -- resource_property


ENTITY resource_property_relationship;
	name : label;
	description : text;
	relating_resource_property : resource_property;
	related_resource_property : resource_property;
WHERE
	WR1 :  relating_resource_property :<>: related_resource_property ;
END_ENTITY; -- resource_property_relationship


ENTITY resource_requirement_type;
	name : label;
	description : text;
END_ENTITY; -- resource_requirement_type


ENTITY resource_requirement_type_relationship;
	name : label;
	description : text;
	relating_requirement_type : resource_requirement_type;
	related_requirement_type : resource_requirement_type;
WHERE
	WR1 :  relating_requirement_type :<>: related_requirement_type ;
END_ENTITY; -- resource_requirement_type_relationship


ENTITY concept_feature_operator;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- concept_feature_operator


ENTITY concept_feature_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept_feature : product_concept_feature;
	related_product_concept_feature : product_concept_feature;
END_ENTITY; -- concept_feature_relationship


ENTITY concept_feature_relationship_with_condition
	SUBTYPE OF (concept_feature_relationship);
	conditional_operator : concept_feature_operator;
END_ENTITY; -- concept_feature_relationship_with_condition


ENTITY conditional_concept_feature
	SUBTYPE OF (product_concept_feature);
	condition : concept_feature_relationship_with_condition;
END_ENTITY; -- conditional_concept_feature


ENTITY product_concept;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	market_context : product_concept_context;
UNIQUE
	UR1 : id;
END_ENTITY; -- product_concept


ENTITY product_concept_feature;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- product_concept_feature


ENTITY product_concept_feature_association;
	name : label;
	description : OPTIONAL text;
	concept : product_concept;
	feature : product_concept_feature;
END_ENTITY; -- product_concept_feature_association


ENTITY product_concept_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept : product_concept;
	related_product_concept : product_concept;
END_ENTITY; -- product_concept_relationship


ENTITY product;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	frame_of_reference : SET [1:?] OF product_context;
END_ENTITY; -- product


ENTITY product_category;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- product_category


ENTITY product_category_relationship;
	name : label;
	description : OPTIONAL text;
	category : product_category;
	sub_category : product_category;
WHERE
	WR1 :  acyclic_product_category_relationship(SELF , [ SELF.sub_category ]);
END_ENTITY; -- product_category_relationship


ENTITY product_definition;
	id : identifier;
	description : OPTIONAL text;
	formation : product_definition_formation;
	frame_of_reference : product_definition_context;
DERIVE
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- product_definition


ENTITY product_definition_context_association;
	definition : product_definition;
	frame_of_reference : product_definition_context;
	role : product_definition_context_role;
END_ENTITY; -- product_definition_context_association


ENTITY product_definition_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- product_definition_context_role


ENTITY product_definition_effectivity
	SUBTYPE OF (effectivity);
	usage : product_definition_relationship;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'))= 0 ;
END_ENTITY; -- product_definition_effectivity


ENTITY product_definition_formation;
	id : identifier;
	description : OPTIONAL text;
	of_product : product;
UNIQUE
	UR1 : id, of_product;
END_ENTITY; -- product_definition_formation


ENTITY product_definition_formation_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition_formation : product_definition_formation;
	related_product_definition_formation : product_definition_formation;
END_ENTITY; -- product_definition_formation_relationship


ENTITY product_definition_formation_with_specified_source
	SUBTYPE OF (product_definition_formation);
	make_or_buy : source;
END_ENTITY; -- product_definition_formation_with_specified_source


ENTITY product_definition_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition : product_definition;
	related_product_definition : product_definition;
END_ENTITY; -- product_definition_relationship


ENTITY product_definition_substitute;
	description : OPTIONAL text;
	context_relationship : product_definition_relationship;
	substitute_definition : product_definition;
DERIVE
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  context_relationship.related_product_definition :<>: substitute_definition ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- product_definition_substitute


ENTITY product_definition_with_associated_documents
	SUBTYPE OF (product_definition);
	documentation_ids : SET [1:?] OF document;
END_ENTITY; -- product_definition_with_associated_documents


ENTITY product_related_product_category
	SUBTYPE OF (product_category);
	products : SET [1:?] OF product;
END_ENTITY; -- product_related_product_category


ENTITY product_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product : product;
	related_product : product;
END_ENTITY; -- product_relationship


ENTITY externally_defined_product_definition
	SUPERTYPE OF (library_defined_product_definition)
	SUBTYPE OF (product_definition, externally_defined_item);
END_ENTITY; -- externally_defined_product_definition


ENTITY library_defined_product_definition
	SUBTYPE OF (externally_defined_product_definition);
DERIVE
	library : external_source :=  SELF \ externally_defined_item.source ;
END_ENTITY; -- library_defined_product_definition


ENTITY characterized_object;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- characterized_object


ENTITY characterized_object_relationship;
	name : label;
	description : OPTIONAL text;
	relating_object : characterized_object;
	related_object : characterized_object;
END_ENTITY; -- characterized_object_relationship


ENTITY general_property;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- general_property


ENTITY general_property_association;
	name : label;
	description : OPTIONAL text;
	base_definition : general_property;
	derived_definition : derived_property_select;
WHERE
	WR1 :  SIZEOF(USEDIN(derived_definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION'))= 1 ;
	WR2 :  derived_definition.name = base_definition.name ;
END_ENTITY; -- general_property_association


ENTITY general_property_relationship;
	name : label;
	description : OPTIONAL text;
	relating_property : general_property;
	related_property : general_property;
END_ENTITY; -- general_property_relationship


ENTITY product_definition_shape
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : definition;
WHERE
	WR1 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CHARACTERIZED_OBJECT' ] * TYPEOF(SELF \ property_definition.definition))> 0 ;
END_ENTITY; -- product_definition_shape


ENTITY property_definition;
	name : label;
	description : OPTIONAL text;
	definition : characterized_definition;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- property_definition


ENTITY shape_aspect;
	name : label;
	description : OPTIONAL text;
	of_shape : product_definition_shape;
	product_definitional : LOGICAL;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- shape_aspect


ENTITY shape_aspect_relationship;
	name : label;
	description : OPTIONAL text;
	relating_shape_aspect : shape_aspect;
	related_shape_aspect : shape_aspect;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- shape_aspect_relationship


ENTITY context_dependent_shape_representation;
	representation_relation : shape_representation_relationship;
	represented_product_relation : product_definition_shape;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition);
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- context_dependent_shape_representation


ENTITY item_identified_representation_usage;
	name : label;
	description : OPTIONAL text;
	definition : represented_definition;
	used_representation : representation;
	identified_item : representation_item;
WHERE
	WR1 :  SELF.used_representation IN using_representations(SELF.identified_item);
END_ENTITY; -- item_identified_representation_usage


ENTITY property_definition_representation;
	definition : represented_definition;
	used_representation : representation;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- property_definition_representation


ENTITY shape_definition_representation
	SUBTYPE OF (property_definition_representation);
WHERE
	WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(SELF.definition))OR('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition));
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
END_ENTITY; -- shape_definition_representation


ENTITY shape_representation
	SUBTYPE OF (representation);
END_ENTITY; -- shape_representation


ENTITY shape_representation_relationship
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SHAPE_REPRESENTATION' IN(TYPEOF(SELF  \ representation_relationship.rep_1)+ TYPEOF(SELF \ representation_relationship.rep_2));
END_ENTITY; -- shape_representation_relationship


ENTITY rule_action
	SUBTYPE OF (action);
WHERE
	WR1 :  SIZEOF(QUERY(aaa <* QUERY(aa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ACTION_ASSIGNMENT' IN  TYPEOF(aa))| SIZEOF(QUERY(it <* aaa.items |(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it))AND(it \ product_definition_formation.description = 'rule version'))))= 1))= 1 ;
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'participant date and time'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'participant date'))= 1 ;
	WR3 : (NOT(SELF  \ action.name = 'rule justification'))OR(SIZEOF(QUERY(ja <* QUERY(ar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| ar \ action_relationship.name = 'justified action')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_ACTION' IN TYPEOF(ja.relating_action)))= 1);
	WR4 : (NOT(SELF  \ action.name = 'rule modification'))OR(SIZEOF(QUERY(mr <* QUERY(ar <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| ar \ action_relationship.name = 'modification rationale')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_ACTION' IN TYPEOF(mr.relating_action))AND(mr.relating_action \ action.name = 'rule change request')))= 1);
	WR5 : (NOT(SELF  \ action.name = 'rule replacement from'))OR(SIZEOF(QUERY(rrfa <* QUERY(aa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_REPLACEMENT_FROM_ASSIGNMENT' IN  TYPEOF(aa))| SIZEOF(QUERY(it <* rrfa.items |(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it))AND(it \ product_definition_formation.description = 'rule version'))))= 1))= 1);
	WR6 : (NOT(SELF  \ action.name = 'rule replacement to'))OR(SIZEOF(QUERY(rrta <* QUERY(aa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_REPLACEMENT_TO_ASSIGNMENT' IN  TYPEOF(aa))| SIZEOF(QUERY(it <* rrta.items |(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it))AND(it \ product_definition_formation.description = 'rule version'))))= 1))= 1);
END_ENTITY; -- rule_action


ENTITY rule_boolean_function_definition
	SUBTYPE OF (rule_function_definition);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODEL_PARAMETER' IN TYPEOF(it)))>= 1 ;
END_ENTITY; -- rule_boolean_function_definition


ENTITY rule_complex_clause
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr.rep_1)))>= 1 ;
	WR2 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_complex_clause))= 0 ;
END_ENTITY; -- rule_complex_clause


ENTITY rule_conclusion_definition
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr \ representation_relationship.rep_1)))>= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_conclusion_definition))= 0 ;
END_ENTITY; -- rule_conclusion_definition


ENTITY rule_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF \ product_definition.formation.description = 'rule version' ;
END_ENTITY; -- rule_definition


ENTITY rule_function_definition
	SUPERTYPE OF (rule_boolean_function_definition)
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MODEL_PARAMETER' IN TYPEOF(it)))>= 1 ;
	WR2 :  SIZEOF(QUERY(adf <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adf \ document_reference.assigned_document.kind \ document_type.product_data_type = 'reference document')AND(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EE_SPECIFICATION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DOCUMENT' ] * TYPEOF(adf \ document_reference.assigned_document))>= 1)))= 1 ;
	WR3 :  SIZEOF(QUERY(adf <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adf \ document_reference.assigned_document.kind \ document_type.product_data_type = 'source code')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(adf \ document_reference.assigned_document))))= 1 ;
END_ENTITY; -- rule_function_definition


ENTITY rule_function_domain_parameter
	SUBTYPE OF (model_parameter);
WHERE
	WR1 :  SIZEOF(QUERY(cri <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri))))= 1 ;
END_ENTITY; -- rule_function_domain_parameter


ENTITY rule_function_range_parameter
	SUBTYPE OF (model_parameter);
WHERE
	WR1 :  SIZEOF(QUERY(cri <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri))))= 1 ;
END_ENTITY; -- rule_function_range_parameter


ENTITY rule_general_clause
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))>= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(rr.rep_1)))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_general_clause))= 0 ;
END_ENTITY; -- rule_general_clause


ENTITY rule_premise_definition
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_COMPLEX_CLAUSE' IN TYPEOF(rr \ representation_relationship.rep_1)))>= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_premise_definition))= 0 ;
END_ENTITY; -- rule_premise_definition


ENTITY rule_set
	SUBTYPE OF (product_definition);
END_ENTITY; -- rule_set


ENTITY rule_set_group
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SIZEOF(QUERY(rsge <* QUERY(gr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| gr \ product_definition_relationship.name = 'rule set group element')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_SET' IN TYPEOF(rsge.related_product_definition)))>= 1 ;
END_ENTITY; -- rule_set_group


ENTITY rule_simple_clause
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))>= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_BOOLEAN_FUNCTION_DEFINITION' IN TYPEOF(rr.rep_1)))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_simple_clause))= 0 ;
END_ENTITY; -- rule_simple_clause


ENTITY rule_superseded_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF rule_superseded_item;
END_ENTITY; -- rule_superseded_assignment


ENTITY rule_supersedence
	SUBTYPE OF (rule_action);
END_ENTITY; -- rule_supersedence


ENTITY alternate_product_relationship;
	name : label;
	definition : OPTIONAL text;
	alternate : product;
	base : product;
	basis : text;
UNIQUE
	UR1 : alternate, base;
WHERE
	WR1 :  alternate :<>: base ;
END_ENTITY; -- alternate_product_relationship


ENTITY assembly_component_usage
	SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence))
	SUBTYPE OF (product_definition_usage);
	reference_designator : OPTIONAL identifier;
END_ENTITY; -- assembly_component_usage


ENTITY assembly_component_usage_substitute;
	name : label;
	definition : OPTIONAL text;
	base : assembly_component_usage;
	substitute : assembly_component_usage;
UNIQUE
	UR1 : base, substitute;
WHERE
	WR1 :  base.relating_product_definition :=: substitute.relating_product_definition ;
	WR2 :  base :<>: substitute ;
END_ENTITY; -- assembly_component_usage_substitute


ENTITY assembly_component_usage_substitute_with_ranking
	SUBTYPE OF (assembly_component_usage_substitute);
	ranking : INTEGER;
	ranking_rationale : text;
END_ENTITY; -- assembly_component_usage_substitute_with_ranking


ENTITY make_from_usage_option
	SUBTYPE OF (product_definition_usage);
	ranking : INTEGER;
	ranking_rationale : text;
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT('NUMBER' IN TYPEOF(quantity.value_component)))OR(quantity.value_component > 0);
END_ENTITY; -- make_from_usage_option


ENTITY make_from_usage_option_group;
	members : SET [2:?] OF make_from_usage_option;
WHERE
	WR1 :  SIZEOF(QUERY(example <* members | example.related_product_definition :=: members [ 1 ].related_product_definition))= SIZEOF(members);
END_ENTITY; -- make_from_usage_option_group


ENTITY next_assembly_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- next_assembly_usage_occurrence


ENTITY product_definition_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	occurrence : product_definition;
	occurrence_usage : assembly_component_usage;
WHERE
	WR1 :  occurrence_usage.relating_product_definition :<>: occurrence ;
	WR2 :  occurrence_usage.related_product_definition :<>: occurrence ;
	WR3 :  occurrence.formation :=: occurrence_usage.related_product_definition.formation ;
END_ENTITY; -- product_definition_occurrence_relationship


ENTITY product_definition_usage
	SUPERTYPE OF (ONEOF (make_from_usage_option, assembly_component_usage))
	SUBTYPE OF (product_definition_relationship);
UNIQUE
	UR1 : id, relating_product_definition, related_product_definition;
WHERE
	WR1 :  acyclic_product_definition_relationship(SELF , [ SELF \ product_definition_relationship.related_product_definition ], 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY; -- product_definition_usage


ENTITY promissory_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- promissory_usage_occurrence


ENTITY quantified_assembly_component_usage
	SUBTYPE OF (assembly_component_usage);
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT('NUMBER' IN TYPEOF(quantity.value_component)))OR(quantity.value_component > 0);
END_ENTITY; -- quantified_assembly_component_usage


ENTITY specified_higher_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
	upper_usage : assembly_component_usage;
	next_usage : next_assembly_usage_occurrence;
UNIQUE
	UR1 : upper_usage, next_usage;
WHERE
	WR1 :  SELF :<>: upper_usage ;
	WR2 :  SELF \ product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition ;
	WR3 :  SELF \ product_definition_relationship.related_product_definition :=: next_usage.related_product_definition ;
	WR4 : (upper_usage.related_product_definition :=: next_usage.relating_product_definition)OR(SIZEOF(QUERY(pdr <* USEDIN(upper_usage.related_product_definition, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr.relating_product_definition :=: next_usage.relating_product_definition))= 1);
	WR5 :  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE' ] * TYPEOF(upper_usage))= 1 ;
END_ENTITY; -- specified_higher_usage_occurrence


ENTITY applied_organizational_project_assignment
	SUBTYPE OF (organizational_project_assignment);
	items : SET [1:?] OF project_item;
END_ENTITY; -- applied_organizational_project_assignment


ENTITY qualification;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification


ENTITY qualification_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_qualification : qualification;
	related_qualification : qualification;
END_ENTITY; -- qualification_relationship


ENTITY qualification_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_type


ENTITY qualification_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_qualification_type : qualification_type;
	related_qualification_type : qualification_type;
END_ENTITY; -- qualification_type_relationship


ENTITY descriptive_representation_item
	SUBTYPE OF (representation_item);
	description : text;
END_ENTITY; -- descriptive_representation_item


ENTITY expanded_uncertainty
	SUBTYPE OF (standard_uncertainty);
	coverage_factor : REAL;
END_ENTITY; -- expanded_uncertainty


ENTITY measure_qualification;
	name : label;
	description : text;
	qualified_measure : measure_with_unit;
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 :  SIZEOF(QUERY(temp <* qualifiers | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)))< 2 ;
END_ENTITY; -- measure_qualification


ENTITY measure_representation_item
	SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY; -- measure_representation_item


ENTITY precision_qualifier;
	precision_value : INTEGER;
END_ENTITY; -- precision_qualifier


ENTITY qualified_representation_item
	SUBTYPE OF (representation_item);
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 :  SIZEOF(QUERY(temp <* qualifiers | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)))< 2 ;
END_ENTITY; -- qualified_representation_item


ENTITY qualitative_uncertainty
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : text;
END_ENTITY; -- qualitative_uncertainty


ENTITY standard_uncertainty
	SUPERTYPE OF (expanded_uncertainty)
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : REAL;
END_ENTITY; -- standard_uncertainty


ENTITY type_qualifier;
	name : label;
END_ENTITY; -- type_qualifier


ENTITY uncertainty_qualifier
	SUPERTYPE OF (ONEOF (standard_uncertainty, qualitative_uncertainty));
	measure_name : label;
	description : text;
END_ENTITY; -- uncertainty_qualifier


ENTITY compound_representation_item
	SUBTYPE OF (representation_item);
	item_element : compound_item_definition;
END_ENTITY; -- compound_representation_item


ENTITY definitional_representation
	SUBTYPE OF (representation);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF \ representation.context_of_items);
END_ENTITY; -- definitional_representation


ENTITY founded_item;
END_ENTITY; -- founded_item


ENTITY functionally_defined_transformation;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- functionally_defined_transformation


ENTITY global_uncertainty_assigned_context
	SUBTYPE OF (representation_context);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- global_uncertainty_assigned_context


ENTITY item_defined_transformation;
	name : label;
	description : OPTIONAL text;
	transform_item_1 : representation_item;
	transform_item_2 : representation_item;
END_ENTITY; -- item_defined_transformation


ENTITY mapped_item
	SUBTYPE OF (representation_item);
	mapping_source : representation_map;
	mapping_target : representation_item;
WHERE
	WR1 :  acyclic_mapped_representation(using_representations(SELF ), [ SELF ]);
END_ENTITY; -- mapped_item


ENTITY parametric_representation_context
	SUBTYPE OF (representation_context);
END_ENTITY; -- parametric_representation_context


ENTITY representation;
	name : label;
	items : SET [1:?] OF representation_item;
	context_of_items : representation_context;
DERIVE
	description : text :=  get_description_value(SELF);
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- representation


ENTITY representation_context;
	context_identifier : identifier;
	context_type : text;
INVERSE
	representations_in_context: SET [1:?] OF representation FOR context_of_items;
END_ENTITY; -- representation_context


ENTITY representation_item;
	name : label;
WHERE
	WR1 :  SIZEOF(using_representations(SELF))> 0 ;
END_ENTITY; -- representation_item


ENTITY representation_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_representation_item : representation_item;
	related_representation_item : representation_item;
END_ENTITY; -- representation_item_relationship


ENTITY representation_map;
	mapping_origin : representation_item;
	mapped_representation : representation;
INVERSE
	map_usage: SET [1:?] OF mapped_item FOR mapping_source;
WHERE
	WR1 :  item_in_context(SELF.mapping_origin, SELF.mapped_representation.context_of_items);
END_ENTITY; -- representation_map


ENTITY representation_relationship;
	name : label;
	description : OPTIONAL text;
	rep_1 : representation;
	rep_2 : representation;
END_ENTITY; -- representation_relationship


ENTITY representation_relationship_with_transformation
	SUBTYPE OF (representation_relationship);
	transformation_operator : transformation;
WHERE
	WR1 :  SELF  \ representation_relationship.rep_1.context_of_items :<>: SELF \ representation_relationship.rep_2.context_of_items ;
END_ENTITY; -- representation_relationship_with_transformation


ENTITY uncertainty_assigned_representation
	SUBTYPE OF (representation);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- uncertainty_assigned_representation


ENTITY uncertainty_measure_with_unit
	SUBTYPE OF (measure_with_unit);
	name : label;
	description : OPTIONAL text;
WHERE
	WR1 :  valid_measure_value(SELF \ measure_with_unit.value_component);
END_ENTITY; -- uncertainty_measure_with_unit


ENTITY value_representation_item
	SUBTYPE OF (representation_item);
	value_component : measure_value;
WHERE
	WR1 :  SIZEOF(QUERY(rep <* using_representations(SELF)| NOT('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(rep.context_of_items))))= 0 ;
END_ENTITY; -- value_representation_item


ENTITY assigned_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY; -- assigned_requirement


ENTITY requirement_assigned_object
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_assigned_item;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY; -- requirement_assigned_object


ENTITY requirement_assignment
	SUBTYPE OF (characterized_object, group);
END_ENTITY; -- requirement_assignment


ENTITY requirement_source
	SUBTYPE OF (group);
END_ENTITY; -- requirement_source


ENTITY source_for_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_source_item;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY; -- source_for_requirement


ENTITY sourced_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY; -- sourced_requirement


ENTITY material_electrical_conductivity_category
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name IN [ 'conductive', 'non conductive', 'resistive', 'semi conductive' ] ;
END_ENTITY; -- material_electrical_conductivity_category


ENTITY requirement_allocation_group
	SUBTYPE OF (group, property_definition_relationship);
WHERE
	WR1 : (SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga))|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONFIGURATION_ITEM' ] * TYPEOF(aga.items))= 1)))= 1);
	WR2 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(SELF \ property_definition_relationship.relating_property_definition);
	WR4 :  NOT(SELF  \ property_definition_relationship.related_property_definition.description = 'test requirement')OR(SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga))|(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION' ] * TYPEOF(aga.items))= 1)))>= 1);
END_ENTITY; -- requirement_allocation_group


ENTITY requirement_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ requirement_definition)))= 0 ;
	WR7 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'requirements model'))>= 1 ;
END_ENTITY; -- requirement_definition


ENTITY requirements_property
	SUBTYPE OF (property_definition);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'requirements property composition'))<= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'requirements description')))= 1))<= 1 ;
	WR3 :  SIZEOF(QUERY(dr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(dr.assigned_document)))>= 1 ;
	WR4 :  NOT(EXISTS(SELF  \ property_definition.description))OR(NOT(SELF  \ property_definition.description IN  [ 'constraint', 'part based constraint' ])OR(SIZEOF(QUERY(dc <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'design constraint')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RULE_DEFINITION' IN TYPEOF(dc.relating_property_definition.definition)))= 1));
	WR5 :  NOT(EXISTS(SELF  \ property_definition.description))OR(NOT(SELF  \ property_definition.description = 'part based constraint')OR(SIZEOF(QUERY(cp <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'constraining part')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(cp.relating_property_definition.definition))AND(cp.relating_property_definition.definition \ product_definition_relationship.name = 'constraining part')AND(cp.relating_property_definition.definition.related_product_definition.frame_of_reference.name = 'design requirement')))= 1));
	WR6 :  NOT(EXISTS(SELF  \ property_definition.description))OR(NOT(SELF  \ property_definition.description = 'interface requirement')OR(SIZEOF(QUERY(itnha <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'interface to next higher assembly')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION' IN  TYPEOF(itnha.relating_property_definition.definition))AND(itnha.relating_property_definition.definition.frame_of_reference.name = 'design requirement')AND(SIZEOF(QUERY(hai <* QUERY(pdr <* USEDIN(itnha.relating_property_definition.definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'higher assembly interface')| SIZEOF(QUERY(pdr <* USEDIN(hai, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdr)))= 1))= 1)))= 1));
END_ENTITY; -- requirements_property


ENTITY applied_security_classification_assignment
	SUBTYPE OF (security_classification_assignment);
	items : SET [1:?] OF security_classification_item;
END_ENTITY; -- applied_security_classification_assignment


ENTITY security_classification;
	name : label;
	purpose : text;
	security_level : security_classification_level;
END_ENTITY; -- security_classification


ENTITY security_classification_level;
	name : label;
END_ENTITY; -- security_classification_level


ENTITY apex
	SUBTYPE OF (derived_shape_aspect);
END_ENTITY; -- apex


ENTITY centre_of_symmetry
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sadr <* SELF \ derived_shape_aspect.deriving_relationships | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SYMMETRIC_SHAPE_ASPECT' IN TYPEOF(sadr \ shape_aspect_relationship.related_shape_aspect))))= 0 ;
END_ENTITY; -- centre_of_symmetry


ENTITY composite_shape_aspect
	SUBTYPE OF (shape_aspect);
INVERSE
	component_relationships: SET [2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
END_ENTITY; -- composite_shape_aspect


ENTITY datum
	SUBTYPE OF (shape_aspect);
	identification : identifier;
INVERSE
	established_by_relationships: SET [1:?] OF shape_aspect_relationship FOR related_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(x <* SELF \ datum.established_by_relationships | SIZEOF(TYPEOF(x \ shape_aspect_relationship.relating_shape_aspect)* [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DATUM_FEATURE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DATUM_TARGET' ])<> 1))= 0 ;
END_ENTITY; -- datum


ENTITY datum_feature
	SUBTYPE OF (shape_aspect);
INVERSE
	feature_basis_relationship: shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(sar <* bag_to_set(USEDIN(SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' + 'RELATING_SHAPE_ASPECT'))| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DATUM' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 0 ;
	WR2 :  SELF \ shape_aspect.product_definitional = TRUE ;
END_ENTITY; -- datum_feature


ENTITY datum_reference;
	precedence : INTEGER;
	referenced_datum : datum;
WHERE
	WR1 :  precedence > 0 ;
END_ENTITY; -- datum_reference


ENTITY datum_target
	SUBTYPE OF (shape_aspect);
	target_id : identifier;
INVERSE
	target_basis_relationship: shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(sar <* bag_to_set(USEDIN(SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' + 'RELATING_SHAPE_ASPECT'))| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DATUM' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 0 ;
	WR2 :  SELF \ shape_aspect.product_definitional = TRUE ;
END_ENTITY; -- datum_target


ENTITY derived_shape_aspect
	SUPERTYPE OF (ONEOF (apex, centre_of_symmetry, geometric_alignment, geometric_intersection, parallel_offset, perpendicular_to, extension, tangent))
	SUBTYPE OF (shape_aspect);
INVERSE
	deriving_relationships: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(dr <* SELF \ derived_shape_aspect.deriving_relationships | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_DERIVING_RELATIONSHIP' IN TYPEOF(dr))))= 0 ;
END_ENTITY; -- derived_shape_aspect


ENTITY extension
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- extension


ENTITY geometric_alignment
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)> 1 ;
END_ENTITY; -- geometric_alignment


ENTITY geometric_intersection
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)> 1 ;
END_ENTITY; -- geometric_intersection


ENTITY parallel_offset
	SUBTYPE OF (derived_shape_aspect);
	offset : measure_with_unit;
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- parallel_offset


ENTITY perpendicular_to
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- perpendicular_to


ENTITY referenced_modified_datum
	SUBTYPE OF (datum_reference);
	modifier : limit_condition;
END_ENTITY; -- referenced_modified_datum


ENTITY shape_aspect_deriving_relationship
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DERIVED_SHAPE_ASPECT' IN TYPEOF(SELF \ SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
END_ENTITY; -- shape_aspect_deriving_relationship


ENTITY symmetric_shape_aspect
	SUBTYPE OF (shape_aspect);
INVERSE
	basis_relationships: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(x <* SELF \ symmetric_shape_aspect.basis_relationships | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF(x \ shape_aspect_relationship.related_shape_aspect)))>= 1 ;
END_ENTITY; -- symmetric_shape_aspect


ENTITY tangent
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- tangent


ENTITY composite_group_shape_aspect
	SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_group_shape_aspect


ENTITY composite_unit_shape_aspect
	SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_unit_shape_aspect


ENTITY angular_location
	SUBTYPE OF (dimensional_location);
	angle_selection : angle_relator;
END_ENTITY; -- angular_location


ENTITY angular_size
	SUBTYPE OF (dimensional_size);
	angle_selection : angle_relator;
END_ENTITY; -- angular_size


ENTITY dimensional_characteristic_representation;
	dimension : dimensional_characteristic;
	representation : shape_dimension_representation;
END_ENTITY; -- dimensional_characteristic_representation


ENTITY dimensional_location
	SUPERTYPE OF (ONEOF (angular_location, dimensional_location_with_path))
	SUBTYPE OF (shape_aspect_relationship);
END_ENTITY; -- dimensional_location


ENTITY dimensional_location_with_path
	SUBTYPE OF (dimensional_location);
	path : shape_aspect;
END_ENTITY; -- dimensional_location_with_path


ENTITY dimensional_size
	SUPERTYPE OF (ONEOF (angular_size, dimensional_size_with_path));
	applies_to : shape_aspect;
	name : label;
WHERE
	WR1 :  applies_to.product_definitional = TRUE ;
END_ENTITY; -- dimensional_size


ENTITY dimensional_size_with_path
	SUBTYPE OF (dimensional_size);
	path : shape_aspect;
END_ENTITY; -- dimensional_size_with_path


ENTITY shape_dimension_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(temp <* SELF \ representation.items | NOT('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(temp))))= 0 ;
	WR2 :  SIZEOF(SELF \ representation.items)<= 3 ;
	WR3 :  SIZEOF(QUERY(pos_mri <* QUERY(real_mri <* SELF \ representation.items | 'REAL' IN TYPEOF(real_mri \ measure_with_unit.value_component))| NOT(pos_mri \ measure_with_unit.value_component > 0.0)))= 0 ;
END_ENTITY; -- shape_dimension_representation


ENTITY keepout_design_object_category
	SUBTYPE OF (characterized_object);
WHERE
	WR1 :  SELF \ characterized_object.description IN [ 'assembly module assembly component category', 'component feature category', 'assembly ee material category', 'interconnect ee material category', 'interconnect module assembly component category', 'via category', 'inter stratum feature category', 'cutout category', 'fill area category', 'laminate component category', 'stratum feature category' ] ;
END_ENTITY; -- keepout_design_object_category


ENTITY dimension_related_tolerance_zone_element;
	related_dimension : dimensional_location;
	related_element : tolerance_zone_definition;
END_ENTITY; -- dimension_related_tolerance_zone_element


ENTITY geometric_tolerance;
	name : label;
	description : text;
	magnitude : measure_with_unit;
	toleranced_shape_aspect : shape_aspect;
WHERE
	WR1 : ('NUMBER' IN TYPEOF(magnitude \ measure_with_unit.value_component))AND(magnitude \ measure_with_unit.value_component >= 0.0);
END_ENTITY; -- geometric_tolerance


ENTITY geometric_tolerance_relationship;
	name : label;
	description : text;
	relating_geometric_tolerance : geometric_tolerance;
	related_geometric_tolerance : geometric_tolerance;
END_ENTITY; -- geometric_tolerance_relationship


ENTITY geometric_tolerance_with_datum_reference
	SUBTYPE OF (geometric_tolerance);
	datum_system : SET [1:?] OF datum_reference;
END_ENTITY; -- geometric_tolerance_with_datum_reference


ENTITY geometric_tolerance_with_defined_unit
	SUBTYPE OF (geometric_tolerance);
	unit_size : measure_with_unit;
WHERE
	WR1 : ('NUMBER' IN TYPEOF(unit_size \ measure_with_unit.value_component))AND(unit_size \ measure_with_unit.value_component > 0.0);
END_ENTITY; -- geometric_tolerance_with_defined_unit


ENTITY limits_and_fits;
	form_variance : label;
	zone_variance : label;
	grade : label;
	source : text;
END_ENTITY; -- limits_and_fits


ENTITY modified_geometric_tolerance
	SUBTYPE OF (geometric_tolerance);
	modifier : limit_condition;
END_ENTITY; -- modified_geometric_tolerance


ENTITY plus_minus_tolerance;
	range : tolerance_method_definition;
	toleranced_dimension : dimensional_characteristic;
UNIQUE
	UR1 : toleranced_dimension;
END_ENTITY; -- plus_minus_tolerance


ENTITY projected_zone_definition
	SUBTYPE OF (tolerance_zone_definition);
	projection_end : shape_aspect;
	projected_length : measure_with_unit;
WHERE
	WR1 : ('NUMBER' IN TYPEOF(projected_length \ measure_with_unit.value_component))AND(projected_length \ measure_with_unit.value_component > 0.0);
	WR2 : (derive_dimensional_exponents(projected_length \ measure_with_unit.unit_component)= dimensional_exponents(1, 0, 0, 0, 0, 0, 0));
END_ENTITY; -- projected_zone_definition


ENTITY runout_zone_definition
	SUBTYPE OF (tolerance_zone_definition);
	orientation : runout_zone_orientation;
END_ENTITY; -- runout_zone_definition


ENTITY runout_zone_orientation;
	angle : measure_with_unit;
END_ENTITY; -- runout_zone_orientation


ENTITY runout_zone_orientation_reference_direction
	SUBTYPE OF (runout_zone_orientation);
	orientation_defining_relationship : shape_aspect_relationship;
END_ENTITY; -- runout_zone_orientation_reference_direction


ENTITY statistical_distribution_for_tolerance
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(item <* SELF \ representation.items | NOT('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(item))))= 0 ;
END_ENTITY; -- statistical_distribution_for_tolerance


ENTITY tolerance_value;
	lower_bound : measure_with_unit;
	upper_bound : measure_with_unit;
WHERE
	WR1 :  upper_bound \ measure_with_unit.value_component > lower_bound \ measure_with_unit.value_component ;
	WR2 :  upper_bound \ measure_with_unit.unit_component = lower_bound \ measure_with_unit.unit_component ;
END_ENTITY; -- tolerance_value


ENTITY tolerance_with_statistical_distribution;
	associated_tolerance : shape_tolerance_select;
	tolerance_allocation : statistical_distribution_for_tolerance;
END_ENTITY; -- tolerance_with_statistical_distribution


ENTITY tolerance_zone
	SUBTYPE OF (shape_aspect);
	defining_tolerance : SET [1:?] OF geometric_tolerance;
	form : tolerance_zone_form;
END_ENTITY; -- tolerance_zone


ENTITY tolerance_zone_definition
	SUPERTYPE OF (ONEOF (projected_zone_definition, runout_zone_definition));
	zone : tolerance_zone;
	boundaries : SET [1:?] OF shape_aspect;
END_ENTITY; -- tolerance_zone_definition


ENTITY tolerance_zone_form;
	name : label;
END_ENTITY; -- tolerance_zone_form


ENTITY discrete_shield
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'physical occurrence' ;
	WR2 :  SIZEOF(QUERY(si <* QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'shielded item')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(si.relating_product_definition)))>= 1 ;
END_ENTITY; -- discrete_shield


ENTITY integral_shield
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(pdr.relating_property_definition))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(pdr.relating_property_definition)))AND(pdr \ property_definition_relationship.name = 'shielded item')))>= 1 ;
END_ENTITY; -- integral_shield


ENTITY composite_signal_property_relationship
	SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
	WR1 :  SELF  \ property_definition_relationship.related_property_definition.definition :<>: SELF \ property_definition_relationship.relating_property_definition.definition ;
	WR2 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ property_definition_relationship || SELF  \ composite_signal_property_relationship || SELF \ property_definition))= 0 ;
	WR3 :  SELF \ property_definition_relationship.related_property_definition.name = 'signal property' ;
	WR4 :  SELF \ property_definition_relationship.relating_property_definition.name = 'composite signal property' ;
	WR5 :  SELF \ property_definition.name = '' ;
	WR6 :  SELF \ property_definition.description = '' ;
	WR7 :  SELF \ property_definition_relationship.name = '' ;
	WR8 :  SELF \ property_definition_relationship.description = '' ;
	WR9 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(SELF  \ property_definition.definition))AND(SELF \ property_definition.definition.description = 'aggregate operation');
	WR10 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNAL_DEFINITION' IN TYPEOF(SELF \ property_definition.definition);
END_ENTITY; -- composite_signal_property_relationship


ENTITY signal
	SUBTYPE OF (characterized_object);
WHERE
	WR1 :  SIZEOF(QUERY(aca <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SIGNAL_CATEGORY' IN TYPEOF(aca.assigned_group)))>= 1 ;
	WR2 : (SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| SIZEOF(QUERY(duc <* USEDIN(ada.assigned_document, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| duc \ document_usage_constraint.subject_element = 'signal category'))= 1))= 1);
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 1 ;
END_ENTITY; -- signal


ENTITY signal_category
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.description IN [ 'signal characteristic category', 'signal property category' ] ;
END_ENTITY; -- signal_category


ENTITY document_identifier
	SUBTYPE OF (group);
UNIQUE
	UR1 : name, description;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING.' + 'DOCUMENT_IDENTIFIER_ASSIGNMENT'))> 0 ;
END_ENTITY; -- document_identifier


ENTITY document_identifier_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF document_identifier_assigned_item;
	SELF\group_assignment.assigned_group : document_identifier;
END_ENTITY; -- document_identifier_assignment


ENTITY ee_specification
	SUBTYPE OF (document);
WHERE
	WR1 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'document source'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'document source'))>= 1 ;
	WR2 :  SELF \ document.kind \ document_type.product_data_type IN [ 'assembly technology specification', 'design specification', 'fabrication technology specification', 'interface specification', 'language reference manual', 'lead form specification', 'material specification', 'reference document', 'source code', 'font registration document', 'process specification', 'surface finish specification', 'test specification' ] ;
END_ENTITY; -- ee_specification


ENTITY structured_text_representation_context
	SUBTYPE OF (representation_context);
WHERE
	WR1 :  SIZEOF(QUERY(rep <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.CONTEXT_OF_ITEMS')| NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rep))))= 0 ;
END_ENTITY; -- structured_text_representation_context


ENTITY structured_text_representation_item
	SUBTYPE OF (representation, descriptive_representation_item);
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rr.rep_1)))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))>= 1 ;
	WR3 : (SIZEOF(QUERY(it <* SELF \ representation.items | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_REPRESENTATION_ITEM' IN TYPEOF(it)))= 1);
END_ENTITY; -- structured_text_representation_item


ENTITY closed_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY; -- closed_shell


ENTITY connected_edge_set
	SUBTYPE OF (topological_representation_item);
	ces_edges : SET [1:?] OF edge;
END_ENTITY; -- connected_edge_set


ENTITY connected_face_set
	SUPERTYPE OF (ONEOF (closed_shell, open_shell))
	SUBTYPE OF (topological_representation_item);
	cfs_faces : SET [1:?] OF face;
END_ENTITY; -- connected_face_set


ENTITY connected_face_sub_set
	SUBTYPE OF (connected_face_set);
	parent_face_set : connected_face_set;
END_ENTITY; -- connected_face_sub_set


ENTITY edge
	SUPERTYPE OF (ONEOF (edge_curve, oriented_edge, subedge))
	SUBTYPE OF (topological_representation_item);
	edge_start : vertex;
	edge_end : vertex;
END_ENTITY; -- edge


ENTITY edge_curve
	SUBTYPE OF (edge, geometric_representation_item);
	edge_geometry : curve;
	same_sense : BOOLEAN;
END_ENTITY; -- edge_curve


ENTITY edge_loop
	SUBTYPE OF (loop, path);
DERIVE
	ne : INTEGER :=  SIZEOF(SELF \ path.edge_list);
WHERE
	WR1 : (SELF  \ path.edge_list [ 1 ].edge_start):=:(SELF \ path.edge_list [ ne ].edge_end);
END_ENTITY; -- edge_loop


ENTITY face
	SUPERTYPE OF (ONEOF (face_surface, subface, oriented_face))
	SUBTYPE OF (topological_representation_item);
	bounds : SET [1:?] OF face_bound;
WHERE
	WR1 :  NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
	WR2 :  SIZEOF(QUERY(temp <* bounds | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(temp)))<= 1 ;
END_ENTITY; -- face


ENTITY face_bound
	SUBTYPE OF (topological_representation_item);
	bound : loop;
	orientation : BOOLEAN;
END_ENTITY; -- face_bound


ENTITY face_outer_bound
	SUBTYPE OF (face_bound);
END_ENTITY; -- face_outer_bound


ENTITY face_surface
	SUBTYPE OF (face, geometric_representation_item);
	face_geometry : surface;
	same_sense : BOOLEAN;
WHERE
	WR1 :  NOT('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
END_ENTITY; -- face_surface


ENTITY loop
	SUPERTYPE OF (ONEOF (vertex_loop, edge_loop, poly_loop))
	SUBTYPE OF (topological_representation_item);
END_ENTITY; -- loop


ENTITY open_path
	SUBTYPE OF (path);
DERIVE
	ne : INTEGER :=  SIZEOF(SELF \ path.edge_list);
WHERE
	WR1 : (SELF  \ path.edge_list [ 1 ].edge_element.edge_start):<>:(SELF \ path.edge_list [ ne ].edge_element.edge_end);
END_ENTITY; -- open_path


ENTITY open_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY; -- open_shell


ENTITY oriented_closed_shell
	SUBTYPE OF (closed_shell);
	closed_shell_element : closed_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=  conditional_reverse(SELF.orientation, SELF.closed_shell_element.cfs_faces);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element));
END_ENTITY; -- oriented_closed_shell


ENTITY oriented_edge
	SUBTYPE OF (edge);
	edge_element : edge;
	orientation : BOOLEAN;
DERIVE
	SELF\edge.edge_end : vertex :=  boolean_choose(SELF.orientation, SELF.edge_element.edge_end, SELF.edge_element.edge_start);
	SELF\edge.edge_start : vertex :=  boolean_choose(SELF.orientation, SELF.edge_element.edge_start, SELF.edge_element.edge_end);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
END_ENTITY; -- oriented_edge


ENTITY oriented_face
	SUBTYPE OF (face);
	face_element : face;
	orientation : BOOLEAN;
DERIVE
	SELF\face.bounds : SET [1:?] OF face_bound :=  conditional_reverse(SELF.orientation, SELF.face_element.bounds);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
END_ENTITY; -- oriented_face


ENTITY oriented_open_shell
	SUBTYPE OF (open_shell);
	open_shell_element : open_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=  conditional_reverse(SELF.orientation, SELF.open_shell_element.cfs_faces);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF.open_shell_element));
END_ENTITY; -- oriented_open_shell


ENTITY oriented_path
	SUBTYPE OF (path);
	path_element : path;
	orientation : BOOLEAN;
DERIVE
	SELF\path.edge_list : LIST [1:?] OF  UNIQUE oriented_edge :=  conditional_reverse(SELF.orientation, SELF.path_element.edge_list);
WHERE
	WR1 :  NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
END_ENTITY; -- oriented_path


ENTITY path
	SUPERTYPE OF (ONEOF (open_path, edge_loop, oriented_path))
	SUBTYPE OF (topological_representation_item);
	edge_list : LIST [1:?] OF  UNIQUE oriented_edge;
WHERE
	WR1 :  path_head_to_tail(SELF);
END_ENTITY; -- path


ENTITY poly_loop
	SUBTYPE OF (loop, geometric_representation_item);
	polygon : LIST [3:?] OF  UNIQUE cartesian_point;
END_ENTITY; -- poly_loop


ENTITY seam_edge
	SUBTYPE OF (oriented_edge);
	pcurve_reference : pcurve;
WHERE
	WR1 : ('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_CURVE' IN  TYPEOF(edge_element))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SEAM_CURVE' IN TYPEOF(edge_element \ edge_curve.edge_geometry));
	WR2 :  pcurve_reference IN edge_element \ edge_curve.edge_geometry \ surface_curve.associated_geometry ;
END_ENTITY; -- seam_edge


ENTITY subedge
	SUBTYPE OF (edge);
	parent_edge : edge;
END_ENTITY; -- subedge


ENTITY subface
	SUBTYPE OF (face);
	parent_face : face;
WHERE
	WR1 :  NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))+ list_to_set(list_face_loops(parent_face))));
END_ENTITY; -- subface


ENTITY topological_representation_item
	SUPERTYPE OF (ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set, (loop ANDOR path)))
	SUBTYPE OF (representation_item);
END_ENTITY; -- topological_representation_item


ENTITY vertex
	SUBTYPE OF (topological_representation_item);
END_ENTITY; -- vertex


ENTITY vertex_loop
	SUBTYPE OF (loop);
	loop_vertex : vertex;
END_ENTITY; -- vertex_loop


ENTITY vertex_point
	SUBTYPE OF (vertex, geometric_representation_item);
	vertex_geometry : point;
END_ENTITY; -- vertex_point


ENTITY vertex_shell
	SUBTYPE OF (topological_representation_item);
	vertex_shell_extent : vertex_loop;
END_ENTITY; -- vertex_shell


ENTITY wire_shell
	SUBTYPE OF (topological_representation_item);
	wire_shell_extent : SET [1:?] OF loop;
WHERE
	WR1 :  NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY; -- wire_shell


ENTITY absorbed_dose_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ absorbed_dose_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = gray ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- absorbed_dose_measure_with_unit


ENTITY activity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ activity_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = becquerel ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- activity_measure_with_unit


ENTITY capacitance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ capacitance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = farad ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- capacitance_measure_with_unit


ENTITY conductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ conductance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = siemens ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- conductance_measure_with_unit


ENTITY dose_equivalent_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ dose_equivalent_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = sievert ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- dose_equivalent_measure_with_unit


ENTITY electric_charge_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ electric_charge_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = coulomb ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- electric_charge_measure_with_unit


ENTITY electromotive_force_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ electromotive_force_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = volt ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- electromotive_force_measure_with_unit


ENTITY energy_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ energy_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = joule ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- energy_measure_with_unit


ENTITY expression_conversion_based_unit
	SUBTYPE OF (context_dependent_unit, variable_semantics);
INVERSE
	associated_variable_environment: environment FOR semantics;
END_ENTITY; -- expression_conversion_based_unit


ENTITY force_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ force_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = newton ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- force_measure_with_unit


ENTITY frequency_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ frequency_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = hertz ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- frequency_measure_with_unit


ENTITY illuminance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ illuminance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = lux ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- illuminance_measure_with_unit


ENTITY inductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ inductance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = henry ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- inductance_measure_with_unit


ENTITY luminous_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ luminous_flux_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = lumen ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- luminous_flux_measure_with_unit


ENTITY magnetic_flux_density_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ magnetic_flux_density_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = tesla ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- magnetic_flux_density_measure_with_unit


ENTITY magnetic_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ magnetic_flux_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = weber ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- magnetic_flux_measure_with_unit


ENTITY power_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ power_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = watt ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- power_measure_with_unit


ENTITY pressure_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ pressure_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = pascal ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- pressure_measure_with_unit


ENTITY resistance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ resistance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = ohm ;
	WR3 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- resistance_measure_with_unit


ENTITY scattering_parameter
	SUBTYPE OF (polar_complex_number_literal);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ polar_complex_number_literal || SELF \ scattering_parameter)))= 0 ;
END_ENTITY; -- scattering_parameter


ENTITY applied_action_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF action_request_item;
END_ENTITY; -- applied_action_request_assignment


SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
	ONEOF (classification, complete_membership);
END_SUBTYPE_CONSTRAINT; -- classification_or_complete_membership

RULE analytical_model_port_unique_constraint FOR (analytical_model_port);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 amp_bag : BAG  OF  analytical_model_port;
 rr_bag : BAG  OF  representation_relationship;
 pass : BOOLEAN := TRUE;
 am_bag : BAG OF analytical_model;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(analytical_model_port)BY  1;
 IF  EXISTS(analytical_model_port [ i ] \ representation.name)THEN  IF(NOT(analytical_model_port [ i ] \ representation.name IN  name_bag))THEN  name_bag := name_bag + analytical_model_port [ i ] \ representation.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 amp_bag := QUERY(amp <* analytical_model_port |(amp \ representation.name = name_bag [ i ]));
 am_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(amp_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 rr_bag := QUERY(rr <* USEDIN(amp_bag [ j ], 'ANALYTICAL_MODEL_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|((rr \ representation_relationship.name = 'access mechanism')AND('ANALYTICAL_MODEL_MIM.' + 'ANALYTICAL_MODEL' IN  TYPEOF(rr.rep_1))));
 REPEAT k := 1 TO SIZEOF(rr_bag)BY 1;
 IF  EXISTS(rr_bag [ k ].rep_1)THEN  IF(rr_bag [ k ].rep_1 IN am_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE am_bag := am_bag + rr_bag [ k ].rep_1;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- analytical_model_port_unique_constraint

RULE approval_requires_approval_date_time FOR (approval, approval_date_time);
 
WHERE
	WR1 :  SIZEOF(QUERY(app <* approval | NOT(SIZEOF(QUERY(adt <* approval_date_time | app :=: adt.dated_approval))= 1)))= 0 ;
END_RULE; -- approval_requires_approval_date_time

RULE approval_requires_approval_person_organization FOR (approval, approval_person_organization);
 
WHERE
	WR1 :  SIZEOF(QUERY(app <* approval | NOT(SIZEOF(QUERY(apo <* approval_person_organization | app :=: apo.authorized_approval))>= 1)))= 0 ;
END_RULE; -- approval_requires_approval_person_organization

RULE approval_role_constraint FOR (approval_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(apr <* approval_role | NOT(apr \ approval_role.role = 'authorizer')))= 0 ;
END_RULE; -- approval_role_constraint

RULE approvals_are_assigned FOR (approval, approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(app <* approval | NOT(SIZEOF(QUERY(aa <* approval_assignment | app :=: aa.assigned_approval))>= 1)))= 0 ;
END_RULE; -- approvals_are_assigned

RULE assembly_composition_relationship_unique_constraint FOR (assembly_component_usage);
 LOCAL
 acr : BAG  OF  assembly_component_usage := QUERY(acu <* assembly_component_usage |(acu \ product_definition_relationship.name = 'assembly composition'));
 pu_bag : BAG  OF  physical_unit := [ ];
 acu_bag : BAG  OF  assembly_component_usage;
 pass : BOOLEAN := TRUE;
 cd_bag : BAG OF component_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(acr)BY  1;
 IF  EXISTS(acr [ i ].relating_product_definition)THEN  IF((acr [ i ].relating_product_definition.frame_of_reference.name = 'physical design')AND('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(acr [ i ].relating_product_definition)))THEN  IF(NOT(acr [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + acr [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 cd_bag := [ ];
 acu_bag := QUERY(acu <* acr |(acu.relating_product_definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(acu_bag)BY 1;
 IF  EXISTS(acu_bag [ j ].related_product_definition)THEN  IF('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(acu_bag [ j ].related_product_definition))THEN  IF(acu_bag [ j ].related_product_definition IN cd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE cd_bag := cd_bag + acu_bag [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- assembly_composition_relationship_unique_constraint

RULE certification_requires_date_or_date_and_time FOR (certification, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(cert <* certification | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment | cert IN  adata.items))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment | cert IN ada.items))= 1))))= 0 ;
END_RULE; -- certification_requires_date_or_date_and_time

RULE certification_unique_constraint FOR (certification);
 LOCAL
 r : BAG  OF  certification := QUERY(r <* certification | TRUE );
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ] \ certification.name)THEN  IF(r [ i ] \ certification.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + r [ i ] \ certification.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- certification_unique_constraint

RULE configuration_item_requires_person_organization FOR (configuration_item, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(ci <* configuration_item | NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | ci IN  apaoa.items))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | ci IN aoa.items))= 1))))= 0 ;
END_RULE; -- configuration_item_requires_person_organization

RULE contract_unique_constraint FOR (contract);
 LOCAL
 r : BAG  OF  contract := QUERY(r <* contract | TRUE );
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ] \ contract.name)THEN  IF(r [ i ] \ contract.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + r [ i ] \ contract.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- contract_unique_constraint

RULE date_and_time_require_minute_and_second FOR (date_and_time);
 
WHERE
	WR1 :  SIZEOF(QUERY(dat <* date_and_time | NOT(EXISTS(dat.time_component.minute_component))))= 0 ;
	WR2 :  SIZEOF(QUERY(dat <* date_and_time | NOT(EXISTS(dat.time_component.second_component))))= 0 ;
END_RULE; -- date_and_time_require_minute_and_second

RULE date_constraint FOR (date);
 
WHERE
	WR1 :  SIZEOF(QUERY(d <* date | d.year_component < 1856))= 0 ;
END_RULE; -- date_constraint

RULE dependent_instantiable_action_directive FOR (action_directive);
 
WHERE
	WR1 :  SIZEOF(QUERY(ad <* action_directive | NOT(SIZEOF(USEDIN(ad, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_action_directive

RULE dependent_instantiable_approval_status FOR (approval_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ast <* approval_status | NOT(SIZEOF(USEDIN(ast, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_approval_status

RULE dependent_instantiable_certification_type FOR (certification_type);
 
WHERE
	WR1 :  SIZEOF(QUERY(ct <* certification_type | NOT(SIZEOF(USEDIN(ct, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_certification_type

RULE dependent_instantiable_contract_type FOR (contract_type);
 
WHERE
	WR1 :  SIZEOF(QUERY(ct <* contract_type | NOT(SIZEOF(USEDIN(ct, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_contract_type

RULE dependent_instantiable_date FOR (date);
 
WHERE
	WR1 :  SIZEOF(QUERY(dt <* date | NOT(SIZEOF(USEDIN(dt, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_date

RULE dependent_instantiable_date_role FOR (date_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(dr <* date_role | NOT(SIZEOF(USEDIN(dr, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_date_role

RULE dependent_instantiable_date_time_role FOR (date_time_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(dtr <* date_time_role | NOT(SIZEOF(USEDIN(dtr, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_date_time_role

RULE dependent_instantiable_document_type FOR (document_type);
 
WHERE
	WR1 :  SIZEOF(QUERY(dt <* document_type | NOT(SIZEOF(USEDIN(dt, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_document_type

RULE dependent_instantiable_named_unit FOR (named_unit);
 
WHERE
	WR1 :  SIZEOF(QUERY(nu <* named_unit | NOT(SIZEOF(USEDIN(nu, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_named_unit

RULE dependent_instantiable_organization_role FOR (organization_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(org <* organization_role | NOT(SIZEOF(USEDIN(org, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_organization_role

RULE dependent_instantiable_parametric_representation_context FOR (parametric_representation_context);
 
WHERE
	WR1 :  SIZEOF(QUERY(prc <* parametric_representation_context | NOT(SIZEOF(USEDIN(prc, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_parametric_representation_context

RULE dependent_instantiable_person_and_organization_role FOR (person_and_organization_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(poar <* person_and_organization_role | NOT(SIZEOF(USEDIN(poar, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_person_and_organization_role

RULE dependent_instantiable_representation_item FOR (representation_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(ri <* representation_item | NOT(SIZEOF(USEDIN(ri, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_representation_item

RULE dependent_instantiable_security_classification_level FOR (security_classification_level);
 
WHERE
	WR1 :  SIZEOF(QUERY(scl <* security_classification_level | NOT(SIZEOF(USEDIN(scl, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_security_classification_level

RULE dependent_instantiable_shape_representation FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation | NOT(SIZEOF(USEDIN(sr, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_shape_representation

RULE directed_action_requires_approval FOR (directed_action, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(da <* directed_action | NOT(SIZEOF(QUERY(aaa <* applied_approval_assignment | da IN aaa.items))= 1)))= 0 ;
END_RULE; -- directed_action_requires_approval

RULE directed_action_requires_date_or_date_and_time FOR (directed_action, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(da <* directed_action | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment |(da IN  adata.items)AND(adata.role \ date_time_role.name = 'start date')))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment |(da IN ada.items)AND(ada.role \ date_role.name = 'start date')))= 1))))= 0 ;
END_RULE; -- directed_action_requires_date_or_date_and_time

RULE ee_document_constraint FOR (document);
 
WHERE
	WR1 :  SIZEOF(QUERY(doc <* document |(SIZEOF(QUERY(adata <* USEDIN(doc, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')|(adata.role \ date_time_role.name = 'creation date')))= 0)))= 0 ;
	WR2 :  SIZEOF(QUERY(doc <* document | NOT((SIZEOF(QUERY(aoa <* USEDIN(doc, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'publisher')))= 1)OR(SIZEOF(QUERY(apaoa <* USEDIN(doc, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(apaoa.role \ person_and_organization_role.name = 'publisher')))= 1))))= 0 ;
	WR3 :  SIZEOF(QUERY(doc <* document | NOT(SIZEOF(USEDIN(doc, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS'))= 1)))= 0 ;
END_RULE; -- ee_document_constraint

RULE ee_document_unique_constraint FOR (document, document_identifier_assignment);
 LOCAL
 pass : BOOLEAN := TRUE;
 rev_exists_bag : BAG  OF  document := [ ];
 dia_bag : BAG  OF  document_identifier_assignment := [ ];
 desc_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(document)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 IF  NOT(EXISTS(document [ i ].description))THEN  pass := FALSE ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(document_identifier_assignment)BY  1;
 IF(NOT  pass)THEN  ESCAPE;
 END_IF ;
 desc_bag := [ ];
 REPEAT j := 1 TO SIZEOF(document_identifier_assignment [ i ].items)BY 1;
 desc_bag := desc_bag + document_identifier_assignment [ i ].items [ j ] \ document.description;
 END_REPEAT ;
 IF NOT(VALUE_UNIQUE(desc_bag))THEN pass := FALSE;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_document_unique_constraint

RULE ee_material_unique_constraint FOR (material_designation);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 md_bag : BAG  OF  material_designation;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 doc_bag : BAG OF ee_specification;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(material_designation)BY  1;
 IF  EXISTS(material_designation [ i ].name)THEN  IF(NOT(material_designation [ i ].name IN  name_bag))THEN  name_bag := name_bag + material_designation [ i ].name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 md_bag := QUERY(md <* material_designation |(md \ material_designation.name = name_bag [ i ]));
 doc_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(md_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := QUERY(adr <* USEDIN(md_bag [ j ],('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'DOCUMENT')IN  TYPEOF(adr.assigned_document)));
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN doc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE doc_bag := doc_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_material_unique_constraint

RULE ee_product_configuration_unique_constraint FOR (configuration_item);
 LOCAL
 id_bag : BAG  OF  STRING := [ ];
 ci_bag : BAG  OF  configuration_item;
 cd_bag : BAG  OF  configuration_design;
 pass : BOOLEAN := TRUE;
 pdf_bag : BAG OF product_definition_formation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(configuration_item)BY  1;
 IF  EXISTS(configuration_item [ i ].id)THEN  IF(NOT(configuration_item [ i ].id IN  id_bag))THEN  id_bag := id_bag + configuration_item [ i ].id;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(id_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdf_bag := [ ];
 ci_bag := QUERY(ci <* configuration_item |(ci.id = id_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(ci_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 cd_bag := USEDIN(ci_bag [ j ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'CONFIGURATION_DESIGN.CONFIGURATION');
 REPEAT k := 1 TO SIZEOF(cd_bag)BY 1;
 IF  EXISTS(cd_bag [ k ].design)THEN  IF(cd_bag [ k ].design IN pdf_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pdf_bag := pdf_bag + cd_bag [ k ].design;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_product_configuration_unique_constraint

RULE ee_product_constraint FOR (product);
 
WHERE
	WR1 :  SIZEOF(QUERY(prod <* product | NOT((SIZEOF(QUERY(aoa <* USEDIN(prod, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'design owner')))= 1)OR(SIZEOF(QUERY(apaoa <* USEDIN(prod, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(apaoa.role \ person_and_organization_role.name = 'design owner')))= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(p <* product | SIZEOF(USEDIN(p, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'))= 0))= 0 ;
END_RULE; -- ee_product_constraint

RULE ee_product_definition_constraint FOR (product_definition_with_associated_documents);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(QUERY(adata <* USEDIN(pdwad, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')|(adata.role \ date_time_role.name = 'creation date')))= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(QUERY(aoa <* USEDIN(pdwad, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'creator')))= 1)OR(SIZEOF(QUERY(apaoa <* USEDIN(pdwad, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(apaoa.role \ person_and_organization_role.name = 'creator')))= 1))))= 0 ;
	WR3 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(USEDIN(pdwad, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1))))= 0 ;
	WR4 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(USEDIN(pdwad, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1))))= 0 ;
END_RULE; -- ee_product_definition_constraint

RULE ee_product_model_unique_constraint FOR (product_concept);
 LOCAL
 r : BAG  OF  product_concept := QUERY(r <* product_concept | TRUE );
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ].id)THEN  IF(r [ i ] \ product_concept.id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + r [ i ].id;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_product_model_unique_constraint

RULE ee_product_unique_constraint FOR (product);
 LOCAL
 id_bag : BAG  OF  STRING := [ ];
 p_bag : BAG  OF  product;
 aoa_bag : BAG  OF  applied_organization_assignment;
 apaoa_bag : BAG  OF  applied_person_and_organization_assignment;
 pass : BOOLEAN := TRUE;
 o_bag : BAG  OF  organization;
 pao_bag : BAG OF person_and_organization;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(product)BY  1;
 IF  EXISTS(product [ i ].id)THEN  IF(NOT(product [ i ].id IN  id_bag))THEN  id_bag := id_bag + product [ i ].id;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(id_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 o_bag := [ ];
 pao_bag := [ ];
 p_bag := QUERY(p <* product |(p.id = id_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(p_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 aoa_bag := QUERY(aoa <* USEDIN(p_bag [ j ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'ORGANIZATION' IN  TYPEOF(aoa.assigned_organization))AND(aoa.role \ organization_role.name = 'design owner')));
 REPEAT  k := 1 TO  SIZEOF(aoa_bag)BY  1;
 IF  EXISTS(aoa_bag [ k ].assigned_organization)THEN  IF(aoa_bag [ k ].assigned_organization IN  o_bag)THEN  pass := FALSE ;
 ESCAPE ;
 ELSE  o_bag := o_bag + aoa_bag [ k ].assigned_organization;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 apaoa_bag := QUERY(apaoa <* USEDIN(p_bag [ j ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PERSON_AND_ORGANIZATION' IN  TYPEOF(apaoa.assigned_person_and_organization))AND(apaoa.role \ person_and_organization_role.name = 'design owner')));
 REPEAT k := 1 TO SIZEOF(apaoa_bag)BY 1;
 IF  EXISTS(apaoa_bag [ k ].assigned_person_and_organization)THEN  IF(apaoa_bag [ k ].assigned_person_and_organization IN pao_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pao_bag := pao_bag + apaoa_bag [ k ].assigned_person_and_organization;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_product_unique_constraint

RULE ee_product_version_supersedence_constraint FOR (product_definition_formation_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |((pdfr \ product_definition_formation_relationship.name = 'product version supersedence')AND(NOT(pdfr.relating_product_definition_formation.of_product :=: pdfr.related_product_definition_formation.of_product)))))= 0 ;
END_RULE; -- ee_product_version_supersedence_constraint

RULE next_higher_assembly_relationship_constraint FOR (next_assembly_usage_occurrence);
 
WHERE
	WR1 :  SIZEOF(QUERY(nauo <* next_assembly_usage_occurrence | NOT(SIZEOF(QUERY(pd <* USEDIN(nauo, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|((SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_LOCATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 3)))<= 1)AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))<= 1))))<= 1)))= 0 ;
END_RULE; -- next_higher_assembly_relationship_constraint

RULE next_higher_assembly_relationship_unique_constraint FOR (next_assembly_usage_occurrence);
 LOCAL
 pu_bag : BAG  OF  physical_unit := [ ];
 nauo_bag : BAG  OF  next_assembly_usage_occurrence;
 pass : BOOLEAN := TRUE;
 refdes_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(next_assembly_usage_occurrence)BY  1;
 IF  EXISTS(next_assembly_usage_occurrence [ i ].relating_product_definition)THEN  IF((next_assembly_usage_occurrence [ i ].relating_product_definition.frame_of_reference.name = 'physical design')AND('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(next_assembly_usage_occurrence [ i ].relating_product_definition)))THEN  IF(NOT(next_assembly_usage_occurrence [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + next_assembly_usage_occurrence [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 refdes_bag := [ ];
 nauo_bag := QUERY(nauo <* next_assembly_usage_occurrence |(nauo.relating_product_definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(nauo_bag)BY 1;
 IF  EXISTS(nauo_bag [ j ].reference_designator)THEN  IF(nauo_bag [ j ].reference_designator IN refdes_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE refdes_bag := refdes_bag + nauo_bag [ j ].reference_designator;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- next_higher_assembly_relationship_unique_constraint

RULE organization_unique_constraint FOR (organization);
 LOCAL
 r : BAG  OF  organization := QUERY(r <* organization | TRUE );
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ].id)THEN  IF(r [ i ] \ organization.id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + r [ i ].id;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- organization_unique_constraint

RULE planned_effectivity_constraint FOR (configuration_effectivity);
 
WHERE
	WR1 :  SIZEOF(QUERY(ce <* configuration_effectivity | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage))AND(ce.usage \ product_definition_relationship.name = 'assembly composition'))))= 0 ;
	WR2 :  SIZEOF(QUERY(ce <* configuration_effectivity | SIZEOF(USEDIN(ce, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 0))= 0 ;
END_RULE; -- planned_effectivity_constraint

RULE planned_effectivity_unique_constraint FOR (configuration_effectivity);
 LOCAL
 ce_bag : BAG  OF  configuration_effectivity;
 ci_bag : BAG  OF  configuration_item := [ ];
 pass : BOOLEAN := TRUE;
 acu_bag : BAG OF assembly_component_usage;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(configuration_effectivity)BY  1;
 IF  EXISTS(configuration_effectivity [ i ].configuration.configuration)THEN  IF(NOT(configuration_effectivity [ i ].configuration.configuration IN  ci_bag))THEN  ci_bag := ci_bag + configuration_effectivity [ i ].configuration.configuration;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(ci_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 ce_bag := QUERY(r <* configuration_effectivity |((r.configuration.configuration :=: ci_bag [ i ])AND(r.usage \ product_definition_relationship.name = 'assembly composition')AND('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'ASSEMBLY_COMPONENT_USAGE' IN  TYPEOF(r.usage))));
 acu_bag := [ ];
 REPEAT j := 1 TO SIZEOF(ce_bag)BY 1;
 IF  EXISTS(ce_bag [ j ].usage)THEN  IF(ce_bag [ j ].usage IN acu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE acu_bag := acu_bag + ce_bag [ j ].usage;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- planned_effectivity_unique_constraint

RULE product_association_constraint FOR (product_definition_formation_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |(pdfr \ product_definition_formation_relationship.name = 'product association')AND(SIZEOF(QUERY(adr <* USEDIN(pdfr, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document))))= 0)))= 0 ;
END_RULE; -- product_association_constraint

RULE product_association_unique_constraint FOR (product_definition_formation_relationship);
 LOCAL
 pdfr : BAG  OF  product_definition_formation_relationship := QUERY(r <* product_definition_formation_relationship |(r \ product_definition_formation_relationship.name = 'product association'));
 pdf_bag : BAG  OF  product_definition_formation := [ ];
 pdfr_bag : BAG  OF  product_definition_formation_relationship;
 pass : BOOLEAN := TRUE;
 adr_bag : BAG  OF  applied_document_reference;
 es_bag : BAG OF ee_specification;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pdfr)BY  1;
 IF  EXISTS(pdfr [ i ].relating_product_definition_formation)THEN  IF(NOT(pdfr [ i ].relating_product_definition_formation IN  pdf_bag))THEN  pdf_bag := pdf_bag + pdfr [ i ].relating_product_definition_formation;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pdf_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdfr_bag := QUERY(r <* pdfr |(r.relating_product_definition_formation :=: pdf_bag [ i ]));
 es_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(pdfr_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := QUERY(adr <* USEDIN(pdfr_bag [ j ],('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'EE_SPECIFICATION')IN  TYPEOF(adr.assigned_document)));
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN es_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE es_bag := es_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- product_association_unique_constraint

RULE product_concept_requires_configuration_item FOR (product_concept, configuration_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(pc <* product_concept | NOT(SIZEOF(QUERY(ci <* configuration_item | pc :=: ci.item_concept))>= 1)))= 0 ;
END_RULE; -- product_concept_requires_configuration_item

RULE product_definition_formation_requires_approval FOR (product_definition, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition |(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN  TYPEOF(pd)))AND(NOT(SIZEOF(QUERY(aaa <* applied_approval_assignment | pd.formation IN aaa.items))= 1))))= 0 ;
END_RULE; -- product_definition_formation_requires_approval

RULE product_definition_formation_requires_person_organization FOR (product_definition, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition |(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN  TYPEOF(pd)))AND(NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment |(pd.formation IN  apaoa.items)AND(apaoa.role \ person_and_organization_role.name = 'creator')))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment |(pd.formation IN aoa.items)AND(aoa.role \ organization_role.name = 'creator')))= 1)))))= 0 ;
END_RULE; -- product_definition_formation_requires_person_organization

RULE product_requires_person_organization FOR (product, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(prod <* product | NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | prod IN  apaoa.items))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | prod IN aoa.items))= 1))))= 0 ;
END_RULE; -- product_requires_person_organization

RULE product_requires_product_definition_formation FOR (product, product_definition_formation);
 
WHERE
	WR1 :  SIZEOF(QUERY(prod <* product | NOT(SIZEOF(QUERY(pdf <* product_definition_formation | prod :=: pdf.of_product))>= 1)))= 0 ;
END_RULE; -- product_requires_product_definition_formation

RULE restrict_action_request_status FOR (action_request_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ars <* action_request_status | NOT(ars \ action_request_status.status IN [ 'proposed', 'in work', 'issued', 'hold' ])))= 0 ;
END_RULE; -- restrict_action_request_status

RULE restrict_approval_status FOR (approval_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ast <* approval_status | NOT(ast \ approval_status.name IN [ 'approved', 'not yet approved', 'disapproved', 'withdrawn' ])))= 0 ;
END_RULE; -- restrict_approval_status

RULE restrict_date_role FOR (date_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(dr <* date_role | NOT(dr \ date_role.name IN [ 'creation date', 'request date', 'release date', 'start date', 'contract date', 'certification date', 'sign off date', 'classification date', 'declassification date' ])))= 0 ;
END_RULE; -- restrict_date_role

RULE security_classification_constraint FOR (security_classification, applied_date_and_time_assignment, applied_date_assignment, applied_person_and_organization_assignment, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(sc <* security_classification | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment |(sc IN  adata.items)AND('classification date' = adata.role \ date_time_role.name)))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment |(sc IN ada.items)AND('classification date' = ada.role \ date_role.name)))= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(sc <* security_classification | SIZEOF(QUERY(apa <* applied_person_and_organization_assignment |(sc IN apa.items)AND(apa.role \ person_and_organization_role.name = 'classification officer')))= 0))= 0 ;
	WR3 :  SIZEOF(QUERY(sc <* security_classification | SIZEOF(QUERY(aaa <* applied_approval_assignment |(sc IN aaa.items)))= 0))= 0 ;
END_RULE; -- security_classification_constraint

RULE subtype_exclusive_action_request_assignment FOR (action_request_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(ara <* action_request_assignment | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHANGE_REQUEST', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'START_REQUEST' ] * TYPEOF(ara))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_action_request_assignment

RULE subtype_exclusive_product_definition_relationship FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_USAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SUPPLIED_PART_RELATIONSHIP' ] * TYPEOF(pdr))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_product_definition_relationship

RULE subtype_exclusive_property_definition_representation FOR (property_definition_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_representation | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_DEFINITION_REPRESENTATION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MATERIAL_PROPERTY_REPRESENTATION' ] * TYPEOF(pdr))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_property_definition_representation

RULE subtype_mandatory_address FOR (address);
 
WHERE
	WR1 :  SIZEOF(QUERY(add <* address | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PERSONAL_ADDRESS', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ORGANIZATIONAL_ADDRESS' ] * TYPEOF(add))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_address

RULE subtype_mandatory_date FOR (date);
 
WHERE
	WR1 :  SIZEOF(QUERY(d <* date | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CALENDAR_DATE' IN TYPEOF(d))))= 0 ;
END_RULE; -- subtype_mandatory_date

RULE subtype_mandatory_product_definition_usage FOR (product_definition_usage);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdu <* product_definition_usage | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MAKE_FROM_USAGE_OPTION' ] * TYPEOF(pdu))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_product_definition_usage

RULE supplied_product_version_unique_constraint FOR (product_definition_formation_with_specified_source);
 LOCAL
 spv : BAG  OF  product_definition_formation_with_specified_source := QUERY(r <* product_definition_formation_with_specified_source |(SIZEOF(QUERY(pd <* USEDIN(r, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION.FORMATION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'SUPPLIED_PART_RELATIONSHIP')IN  TYPEOF(pdr))))> 0)))> 0));
 aoa_bag : BAG  OF  applied_organization_assignment;
 o_bag : BAG  OF  organization := [ ];
 pdf_bag : BAG  OF  product_definition_formation_with_specified_source;
 spn_bag : BAG OF STRING;
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(spv)BY  1;
 aoa_bag := QUERY(aoa <* USEDIN(spv [ i ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'supplier'));
 REPEAT  j := 1 TO  SIZEOF(aoa_bag)BY  1;
 IF  EXISTS(aoa_bag [ j ].assigned_organization)THEN  IF(NOT(aoa_bag [ j ].assigned_organization IN  o_bag))THEN  o_bag := o_bag + aoa_bag [ j ].assigned_organization;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(o_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdf_bag := QUERY(pdf <* spv |(SIZEOF(QUERY(aoa <* USEDIN(pdf, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|((aoa.role \ organization_role.name = 'supplier')AND(aoa.assigned_organization :=: o_bag [ i ]))))> 0));
 spn_bag := [ ];
 REPEAT j := 1 TO SIZEOF(pdf_bag)BY 1;
 IF  EXISTS(pdf_bag [ j ].of_product.id)THEN  IF(pdf_bag [ j ].of_product.id IN spn_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE spn_bag := spn_bag + pdf_bag [ j ].of_product.id;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- supplied_product_version_unique_constraint

RULE versioned_action_request_requires_approval FOR (versioned_action_request, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(varq <* versioned_action_request | NOT(SIZEOF(QUERY(aaa <* applied_approval_assignment | varq IN aaa.items))= 1)))= 0 ;
END_RULE; -- versioned_action_request_requires_approval

RULE versioned_action_request_requires_date_or_date_and_time FOR (versioned_action_request, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(varq <* versioned_action_request | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment | varq IN  adata.items))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment | varq IN ada.items))= 1))))= 0 ;
END_RULE; -- versioned_action_request_requires_date_or_date_and_time

RULE versioned_action_request_requires_person_organization FOR (versioned_action_request, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(varq <* versioned_action_request | NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | varq IN  apaoa.items))>= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | varq IN aoa.items))>= 1))))= 0 ;
END_RULE; -- versioned_action_request_requires_person_organization

RULE versioned_action_request_requires_status FOR (versioned_action_request, action_request_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ar <* versioned_action_request | NOT(SIZEOF(QUERY(ars <* action_request_status | ar :=: ars.assigned_request))= 1)))= 0 ;
END_RULE; -- versioned_action_request_requires_status

RULE work_request_unique_constraint FOR (versioned_action_request);
 LOCAL
 r : BAG  OF  versioned_action_request := QUERY(r <* versioned_action_request |(SIZEOF(QUERY(ara <* USEDIN(r, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')|((('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'CHANGE_REQUEST')IN  TYPEOF(ara))OR(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'START_REQUEST')IN  TYPEOF(ara)))))> 0));
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ].id)THEN  IF(r [ i ].id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + r [ i ].id;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- work_request_unique_constraint

RULE component_external_reference_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'design owner'))))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'part number'))))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'revision code'))))= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'product definition id'))))= 1)))= 0 ;
	WR5 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'reference designation'))))= 1)))= 0 ;
END_RULE; -- component_external_reference_constraint

RULE component_feature_external_reference_unique_constraint FOR (descriptive_representation_item);
 LOCAL
 cfer : BAG  OF  descriptive_representation_item := QUERY(dri <* descriptive_representation_item |(dri \ representation_item.name = 'component feature external reference'));
 desc_bag : BAG  OF  STRING := [ ];
 dri_bag : BAG  OF  descriptive_representation_item;
 rep_bag : BAG  OF  representation;
 pass : BOOLEAN := TRUE;
 r_bag : BAG OF representation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(cfer)BY  1;
 IF  EXISTS(cfer [ i ] \ descriptive_representation_item.description)THEN  IF(NOT(cfer [ i ] \ descriptive_representation_item.description IN  desc_bag))THEN  desc_bag := desc_bag + cfer [ i ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(desc_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 r_bag := [ ];
 dri_bag := QUERY(dri <* cfer |(dri \ descriptive_representation_item.description = desc_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(dri_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 rep_bag := QUERY(r <* USEDIN(dri_bag [ j ], 'ASSEMBLY_MODULE_DESIGN_MIM.' + 'REPRESENTATION.ITEMS')|(r \ representation.name = 'component external reference'));
 REPEAT k := 1 TO SIZEOF(rep_bag)BY 1;
 IF  EXISTS(rep_bag [ k ])THEN  IF(rep_bag [ k ] IN r_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE r_bag := r_bag + rep_bag [ k ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_feature_external_reference_unique_constraint

RULE component_mounting_clearance_relationship_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'mounting clearance')AND(SIZEOF(QUERY(lmwu <* rep.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'minimum height')))= 0)))= 0 ;
END_RULE; -- component_mounting_clearance_relationship_constraint

RULE component_overlap_relationship_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'overlap clearance')AND(SIZEOF(QUERY(lmwu <* rep.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'minimum clearance')))= 0)))= 0 ;
END_RULE; -- component_overlap_relationship_constraint

RULE mating_connector_placement_relationship_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'mating connector placement')AND(SIZEOF(QUERY(p <* sr.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PLACEMENT' IN TYPEOF(p))AND(p \ representation_item.name = 'connector placement')))= 0)))= 0 ;
END_RULE; -- mating_connector_placement_relationship_constraint

RULE next_higher_assembly_interface_requirement_constraint FOR (specified_higher_usage_occurrence);
 
WHERE
	WR1 :  SIZEOF(QUERY(shuo <* specified_higher_usage_occurrence | NOT(SIZEOF(QUERY(pd <* USEDIN(shuo, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = '3d bound volume shape')))= 0)))= 0)))= 0 ;
END_RULE; -- next_higher_assembly_interface_requirement_constraint

RULE interface_component_allocation_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'interface component allocation')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition \ product_definition.description = 'mating connector'))))= 0 ;
END_RULE; -- interface_component_allocation_constraint

RULE default_assembly_bond_shape_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'default assembly bond shape')AND NOT(SIZEOF(QUERY(pdr <* USEDIN(sr, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition))))= 1)))= 0 ;
END_RULE; -- default_assembly_bond_shape_constraint

RULE bare_die_unique_constraint FOR (bare_die);
 LOCAL
 bd : BAG  OF  physical_unit := QUERY(r <* bare_die |(r.frame_of_reference.name = 'physical design usage'));
 pu : BAG  OF  physical_unit;
 pdr_bag : BAG  OF  product_definition_relationship;
 fu_bag : BAG  OF  functional_unit := [ ];
 pu_bag : BAG  OF  physical_unit;
 ut_bag : BAG  OF  property_definition;
 pass : BOOLEAN := TRUE;
 pd_bag : BAG OF property_definition;
 END_LOCAL
;
 pu := bd;
 REPEAT  i := 1 TO  SIZEOF(pu)BY  1;
 pdr_bag := QUERY(pdr <* USEDIN(pu [ i ], 'BARE_DIE_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')AND('BARE_DIE_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(pdr.relating_product_definition))));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF  EXISTS(pdr_bag [ j ].relating_product_definition)THEN  IF(NOT(pdr_bag [ j ].relating_product_definition IN  fu_bag))THEN  fu_bag := fu_bag + pdr_bag [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fu_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pu_bag := QUERY(r <* pu |(SIZEOF(QUERY(pdr <* USEDIN(fu_bag [ i ], 'BARE_DIE_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.related_product_definition :=: r))))> 0));
 pd_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 ut_bag := QUERY(pd <* USEDIN(pu_bag [ j ], 'BARE_DIE_MIM.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'unit technology'));
 REPEAT k := 1 TO SIZEOF(ut_bag)BY 1;
 IF  EXISTS(ut_bag [ k ])THEN  IF(ut_bag [ k ] IN pd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pd_bag := pd_bag + ut_bag [ k ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- bare_die_unique_constraint

RULE restrict_classification_assignments FOR (applied_classification_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(aia <* applied_classification_assignment | NOT class_assignment_is_valid(aia)))= 0 ;
END_RULE; -- restrict_classification_assignments

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(gr <* group_relationship |(gr.name = 'class hierarchy')AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CLASS' IN  TYPEOF(gr.related_group))OR NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CLASS' IN TYPEOF(gr.relating_group)))))= 0 ;
END_RULE; -- restrict_group_relationship_for_classification_hierarchy

RULE component_feature_unique_constraint FOR (component_terminal, component_interface_terminal);
 LOCAL
 ct : BAG  OF  shape_aspect := QUERY(ct <* component_terminal |(ct \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'interconnect module component stratum based terminal', 'minimally defined component terminal', 'packaged component join terminal' ]));
 cit : BAG  OF  shape_aspect := QUERY(cit <* component_interface_terminal |(cit \ shape_aspect.description IN  [ 'interconnect component interface terminal', 'packaged connector component interface terminal' ]));
 cf : BAG  OF  shape_aspect;
 cd_bag : BAG  OF  component_definition := [ ];
 sa_bag : BAG  OF  shape_aspect;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 def_bag : BAG OF shape_aspect;
 END_LOCAL
;
 cf := ct + cit;
 REPEAT  i := 1 TO  SIZEOF(cf)BY  1;
 IF  EXISTS(cf [ i ].of_shape.definition)THEN  IF('COMPONENT_FEATURE_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(cf [ i ].of_shape.definition))THEN  IF(NOT(cf [ i ].of_shape.definition IN  cd_bag))THEN  cd_bag := cd_bag + cf [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 def_bag := [ ];
 sa_bag := QUERY(sa <* cf |(sa.of_shape.definition :=: cd_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(sa_bag [ j ], 'COMPONENT_FEATURE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'instantiated feature'));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ k ].relating_shape_aspect)THEN  IF(sar_bag [ k ].relating_shape_aspect IN def_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE def_bag := def_bag + sar_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_feature_unique_constraint

RULE add_design_object_management_relationship_unique_constraint FOR (add_design_object_assignment, add_design_object_request_assignment);
 LOCAL
 pdr_bag : BAG  OF  product_definition_relationship := [ ];
 pd_bag : BAG  OF  product_definition := [ ];
 adoa_bag : BAG  OF  add_design_object_assignment;
 adora_bag : BAG  OF  add_design_object_request_assignment;
 pass : BOOLEAN := TRUE;
 mdo_bag : BAG OF managed_design_object;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(add_design_object_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(add_design_object_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(add_design_object_assignment [ i ].items [ j ]))AND(add_design_object_assignment [ i ].items [ j ].name = 'design object addition'))THEN  IF  EXISTS(add_design_object_assignment [ i ].items [ j ].related_product_definition)THEN  IF(NOT(add_design_object_assignment [ i ].items [ j ].related_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + add_design_object_assignment [ i ].items [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(add_design_object_request_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(add_design_object_request_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(add_design_object_request_assignment [ i ].items [ j ]))AND(add_design_object_request_assignment [ i ].items [ j ].name = 'design object addition'))THEN  IF  EXISTS(add_design_object_request_assignment [ i ].items [ j ].related_product_definition)THEN  IF(NOT(add_design_object_request_assignment [ i ].items [ j ].related_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + add_design_object_request_assignment [ i ].items [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object addition'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 adoa_bag := QUERY(adoa <* add_design_object_assignment |(pdr_bag [ j ] IN  adoa.items));
 REPEAT  k := 1 TO  SIZEOF(adoa_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(adoa_bag [ k ].items)BY  1;
 IF  EXISTS(adoa_bag [ k ].items [ l ])THEN  IF(adoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + adoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 adora_bag := QUERY(adora <* add_design_object_request_assignment |(pdr_bag [ j ] IN  adora.items));
 REPEAT  k := 1 TO  SIZEOF(adora_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(adora_bag [ k ].items)BY 1;
 IF(adora_bag [ k ].items [ l ] IN mdo_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE mdo_bag := mdo_bag + adora_bag [ k ].items [ l ];
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- add_design_object_management_relationship_unique_constraint

RULE change_design_object_management_relationship_unique_constraint FOR (change_from_design_object_assignment, change_from_design_object_request_assignment, change_to_design_object_assignment, change_to_design_object_request_assignment);
 LOCAL
 pd_bag : BAG  OF  product_definition := [ ];
 pdr_bag : BAG  OF  product_definition_relationship;
 ctdoa_bag : BAG  OF  change_to_design_object_assignment;
 ctdora_bag : BAG  OF  change_to_design_object_request_assignment;
 cfdoa_bag : BAG  OF  change_from_design_object_assignment;
 cfdora_bag : BAG  OF  change_from_design_object_request_assignment;
 pass1 : BOOLEAN  := TRUE ;
 pass2 : BOOLEAN := TRUE;
 mdo_bag : BAG OF managed_design_object;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(change_from_design_object_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(change_from_design_object_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(change_from_design_object_assignment [ i ].items [ j ]))AND(change_from_design_object_assignment [ i ].items [ j ].name = 'design object change'))THEN  IF  EXISTS(change_from_design_object_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(change_from_design_object_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + change_from_design_object_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(change_from_design_object_request_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(change_from_design_object_request_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(change_from_design_object_request_assignment [ i ].items [ j ]))AND(change_from_design_object_request_assignment [ i ].items [ j ].name = 'design object change'))THEN  IF  EXISTS(change_from_design_object_request_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(change_from_design_object_request_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + change_from_design_object_request_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT(pass1 AND pass2))THEN  ESCAPE ;
 END_IF ;
 IF(pass1)THEN  mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object change'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 ctdoa_bag := QUERY(ctdoa <* change_to_design_object_assignment |(pdr_bag [ j ] IN  ctdoa.items));
 REPEAT  k := 1 TO  SIZEOF(ctdoa_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(ctdoa_bag [ k ].items)BY  1;
 IF  EXISTS(ctdoa_bag [ k ].items [ l ])THEN  IF(ctdoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + ctdoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 ctdora_bag := QUERY(ctdora <* change_to_design_object_request_assignment |(pdr_bag [ j ] IN  ctdora.items));
 REPEAT  k := 1 TO  SIZEOF(ctdora_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(ctdora_bag [ k ].items)BY  1;
 IF  EXISTS(ctdora_bag [ k ].items [ l ])THEN  IF(ctdora_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + ctdora_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_IF ;
 IF(pass2)THEN  mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object change'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass2)THEN  ESCAPE ;
 END_IF ;
 cfdoa_bag := QUERY(cfdoa <* change_from_design_object_assignment |(pdr_bag [ j ] IN  cfdoa.items));
 REPEAT  k := 1 TO  SIZEOF(cfdoa_bag)BY  1;
 IF(NOT  pass2)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(cfdoa_bag [ k ].items)BY  1;
 IF  EXISTS(cfdoa_bag [ k ].items [ l ])THEN  IF(cfdoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass2 := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + cfdoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass2)THEN  ESCAPE ;
 END_IF ;
 cfdora_bag := QUERY(cfdora <* change_from_design_object_request_assignment |(pdr_bag [ j ] IN  cfdora.items));
 REPEAT  k := 1 TO  SIZEOF(cfdora_bag)BY  1;
 IF(NOT pass2)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(cfdora_bag [ k ].items)BY 1;
 IF  EXISTS(cfdora_bag [ k ].items [ l ])THEN  IF(cfdora_bag [ k ].items [ l ] IN mdo_bag)THEN pass2 := FALSE;
 ESCAPE;
 ELSE mdo_bag := mdo_bag + cfdora_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- change_design_object_management_relationship_unique_constraint

RULE delete_design_object_management_relationship_unique_constraint FOR (delete_design_object_assignment, delete_design_object_request_assignment);
 LOCAL
 pdr_bag : BAG  OF  product_definition_relationship := [ ];
 pd_bag : BAG  OF  product_definition := [ ];
 ddoa_bag : BAG  OF  delete_design_object_assignment;
 ddora_bag : BAG  OF  delete_design_object_request_assignment;
 pass : BOOLEAN := TRUE;
 mdo_bag : BAG OF managed_design_object;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(delete_design_object_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(delete_design_object_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(delete_design_object_assignment [ i ].items [ j ]))AND(delete_design_object_assignment [ i ].items [ j ].name = 'design object deletion'))THEN  IF  EXISTS(delete_design_object_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(delete_design_object_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + delete_design_object_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(delete_design_object_request_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(delete_design_object_request_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(delete_design_object_request_assignment [ i ].items [ j ]))AND(delete_design_object_request_assignment [ i ].items [ j ].name = 'design object deletion'))THEN  IF  EXISTS(delete_design_object_request_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(delete_design_object_request_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + delete_design_object_request_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object deletion'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ddoa_bag := QUERY(ddoa <* delete_design_object_assignment |(pdr_bag [ j ] IN  ddoa.items));
 REPEAT  k := 1 TO  SIZEOF(ddoa_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(ddoa_bag [ k ].items)BY  1;
 IF  EXISTS(ddoa_bag [ k ].items [ l ])THEN  IF(ddoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + ddoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ddora_bag := QUERY(ddora <* delete_design_object_request_assignment |(pdr_bag [ j ] IN  ddora.items));
 REPEAT  k := 1 TO  SIZEOF(ddora_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(ddora_bag [ k ].items)BY 1;
 IF  EXISTS(ddora_bag [ k ].items [ l ])THEN  IF(ddora_bag [ k ].items [ l ] IN mdo_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE mdo_bag := mdo_bag + ddora_bag [ k ].items [ l ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- delete_design_object_management_relationship_unique_constraint

RULE boundary_size_characteristic_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |((rep \ representation.name = 'diametrical boundary size')OR(rep \ representation.name = 'opposing boundary set size'))AND(NOT(SIZEOF(QUERY(lmwu <* rep.items |(lmwu \ representation_item.name = 'tolerance value')))= 1))))= 0 ;
END_RULE; -- boundary_size_characteristic_constraint

RULE directed_axis_constraint FOR (derived_shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(dsa <* derived_shape_aspect |(dsa \ shape_aspect.description = 'directed axis')AND  NOT(SIZEOF(QUERY(sar <* USEDIN(dsa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'derived axis')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))AND(sar \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'axis')))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(dsa <* derived_shape_aspect |(dsa \ shape_aspect.description = 'directed axis')AND  NOT(SIZEOF(QUERY(sar <* USEDIN(dsa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'end shape aspect')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(dsa <* derived_shape_aspect |(dsa \ shape_aspect.description = 'directed axis')AND  NOT(SIZEOF(QUERY(sar <* USEDIN(dsa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'start shape aspect')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 1)))= 0 ;
END_RULE; -- directed_axis_constraint

RULE directed_axis_unique_constraint FOR (derived_shape_aspect);
 LOCAL
 da : BAG  OF  derived_shape_aspect := QUERY(r <* derived_shape_aspect |(r \ shape_aspect.description = 'directed axis'));
 sar_bag : BAG  OF  shape_aspect_relationship;
 cos_bag : BAG  OF  centre_of_symmetry := [ ];
 sar2_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 sa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(da)BY  1;
 sar_bag := QUERY(sar <* USEDIN(da [ i ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'derived axis')AND(sar.related_shape_aspect \ shape_aspect.description = 'axis')AND('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'CENTRE_OF_SYMMETRY' IN  TYPEOF(sar.related_shape_aspect))));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(NOT(sar_bag [ j ].related_shape_aspect IN  cos_bag))THEN  cos_bag := cos_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cos_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 sa_bag := [ ];
 sar_bag := QUERY(sar <* USEDIN(cos_bag [ i ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'derived axis')AND(sar.relating_shape_aspect IN  da)));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar2_bag := QUERY(sar <* USEDIN(sar_bag [ j ].relating_shape_aspect, 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'start shape aspect'));
 REPEAT k := 1 TO SIZEOF(sar2_bag)BY 1;
 IF  EXISTS(sar2_bag [ k ].related_shape_aspect)THEN  IF(sar2_bag [ k ].related_shape_aspect IN sa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sa_bag := sa_bag + sar2_bag [ k ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- directed_axis_unique_constraint

RULE direction_element_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'direction element')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'element direction vector')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.description = 'datum direction_property')))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'direction element')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'half datum plane direction vector')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.description = 'datum direction_property')))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'direction element')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'direction component')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.description = 'datum based vector orientation')))= 1)))= 0 ;
END_RULE; -- direction_element_constraint

RULE edge_segment_vertex_constraint FOR (shape_aspect_relationship, edge_segment_vertex);
 LOCAL
 sar : BAG  OF  shape_aspect_relationship := [ ];
 esv : BAG OF edge_segment_vertex := edge_segment_vertex;
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(esv)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 sar := QUERY(sar <* shape_aspect_relationship | esv [ i ] = sar \ shape_aspect_relationship.related_shape_aspect);
 pass :=(SIZEOF(sar)= 2);
 REPEAT j := 2 TO SIZEOF(sar)BY 1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pass :=((sar [ j ]):<>:(sar [ j - 1 ]));
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pass :=(TYPEOF(sar [ j ])= TYPEOF(sar [ j - 1 ]));
 IF(NOT pass)THEN ESCAPE;
 END_IF;
 pass :=(sar [ j ].relating_shape_aspect :=: sar [ j - 1 ].relating_shape_aspect);
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- edge_segment_vertex_constraint

RULE edge_segment_vertex_unique_constraint FOR (edge_segment_vertex);
 LOCAL
 esv : BAG  OF  edge_segment_vertex := QUERY(r <* edge_segment_vertex |(r \ shape_aspect.name = 'single datum'));
 pd_bag : BAG  OF  property_definition;
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 desc_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(esv)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pd_bag := QUERY(pd <* USEDIN(esv [ i ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'shape element characterization'));
 REPEAT  j := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := USEDIN(pd_bag [ j ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF((pdr_bag [ k ].used_representation \ representation.name = 'shape element characterization')AND('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(pdr_bag [ k ].used_representation.items [ 1 ])))THEN  IF  EXISTS(pdr_bag [ k ].used_representation.items [ 1 ] \ descriptive_representation_item.description)THEN  IF(pdr_bag [ k ].used_representation.items [ 1 ] \ descriptive_representation_item.description IN desc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE desc_bag := desc_bag + pdr_bag [ k ].used_representation.items [ 1 ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- edge_segment_vertex_unique_constraint

RULE geometric_tolerance_qualifier_constraint FOR (measure_qualification);
 
WHERE
	WR1 :  SIZEOF(QUERY(mq <* measure_qualification |((mq \ measure_qualification.name = 'predefined geometric tolerance qualifier')OR(mq \ measure_qualification.name = 'user defined geometric tolerance qualifier'))AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_WITH_UNIT' IN  TYPEOF(mq.qualified_measure))AND(SIZEOF(QUERY(pugt <* USEDIN(mq.qualified_measure, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE.MAGNITUDE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt))))= 0))))= 0 ;
END_RULE; -- geometric_tolerance_qualifier_constraint

RULE positional_boundary_member_definition_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary member property')AND NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition)))))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary member property')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DIMENSIONAL_SIZE_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'boundary member associated dimension')))= 1)))= 0 ;
END_RULE; -- positional_boundary_member_definition_constraint

RULE positional_boundary_offset_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary offset')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(pd.definition))AND(pd.definition \ shape_aspect_relationship.name = 'positional boundary and profile boundary member'))))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary offset')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'boundary offset')AND(pdr.relating_property_definition \ property_definition.name = 'profile related positional boundary property')))= 1)))= 0 ;
END_RULE; -- positional_boundary_offset_constraint

RULE profile_related_positional_boundary_definition_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'profile related positional boundary property')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition))AND(pd.definition \ shape_aspect.description = 'profile related positional boundary'))))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'profile related positional boundary property')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr.related_property_definition \ property_definition.description = 'positional boundary offset')AND(pdr \ property_definition_relationship.name = 'boundary offset')))= 1)))= 0 ;
END_RULE; -- profile_related_positional_boundary_definition_constraint

RULE projected_zone_and_base_relationship_constraint FOR (projected_zone_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pzd <* projected_zone_definition | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end))OR(pzd.projection_end.product_definitional = TRUE))))= 0 ;
END_RULE; -- projected_zone_and_base_relationship_constraint

RULE projected_zone_height_characteristic_constraint FOR (projected_zone_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pzd <* projected_zone_definition | NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length))))= 0 ;
END_RULE; -- projected_zone_height_characteristic_constraint

RULE restraint_condition_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |((pd \ property_definition.description = 'restraint')OR(pd \ property_definition.description = 'tolerance specific restraint'))AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'restraint description')))= 0)))= 0 ;
END_RULE; -- restraint_condition_constraint

RULE shape_element_deriving_relationship_unique_constraint FOR (shape_aspect_deriving_relationship);
 LOCAL
 sa_bag : BAG  OF  shape_aspect := [ ];
 sadr_bag : BAG  OF  shape_aspect_deriving_relationship;
 pass : BOOLEAN := TRUE;
 rsa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(shape_aspect_deriving_relationship)BY  1;
 IF  EXISTS(shape_aspect_deriving_relationship [ i ].relating_shape_aspect)THEN  IF(NOT(shape_aspect_deriving_relationship [ i ].relating_shape_aspect IN  sa_bag))THEN  sa_bag := sa_bag + shape_aspect_deriving_relationship [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sadr_bag := QUERY(r <* shape_aspect_deriving_relationship |(r.relating_shape_aspect :=: sa_bag [ i ]));
 rsa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sadr_bag)BY 1;
 IF  EXISTS(sadr_bag [ j ].related_shape_aspect)THEN  IF(sadr_bag [ j ].related_shape_aspect IN rsa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rsa_bag := rsa_bag + sadr_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- shape_element_deriving_relationship_unique_constraint

RULE subtype_exclusive_dimensional_location FOR (dimensional_location);
 
WHERE
	WR1 :  SIZEOF(QUERY(dl <* dimensional_location | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANGULAR_DIMENSION_WITH_ORIENTATION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DIMENSIONAL_LOCATION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DIMENSIONAL_LOCATION_WITH_PATH' ] * TYPEOF(dl))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_dimensional_location

RULE subtype_exclusive_dimensional_size FOR (dimensional_size);
 
WHERE
	WR1 :  SIZEOF(QUERY(ds <* dimensional_size | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CURVE_DIMENSION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ANGULAR_SIZE' ] * TYPEOF(ds))<= 1)OR NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CURVE_DIMENSION', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE' ] * TYPEOF(ds))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_dimensional_size

RULE subtype_mandatory_extended_geometric_tolerance FOR (geometric_tolerance);
 
WHERE
	WR1 :  SIZEOF(QUERY(gt <* geometric_tolerance | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' ] * TYPEOF(gt))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_extended_geometric_tolerance

RULE subtype_mandatory_runout_zone_orientation FOR (runout_zone_orientation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rzo <* runout_zone_orientation | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION' ] * TYPEOF(rzo))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_runout_zone_orientation

RULE subtype_exclusiveness_representation_item FOR (representation_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(cri <* representation_item | NOT(type_check_function(cri, [ 'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM', 'REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM' ], 3))))= 0 ;
END_RULE; -- subtype_exclusiveness_representation_item

RULE connection_zone_constraint FOR (shape_aspect, representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sa <* shape_aspect |(sa \ shape_aspect.description = 'connection zone')AND NOT(SIZEOF(USEDIN(sa, ''))>= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(sa <* shape_aspect |(sa \ shape_aspect.description = 'connection zone')AND NOT(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name IN [ 'connection', 'minimum attachment region size', 'maximum attachment region size', 'external connection area', 'external connection zone', 'internal connection zone', 'mounting area', 'terminal connection zone' ])))>= 1)))= 0 ;
END_RULE; -- connection_zone_constraint

RULE design_functional_unit_allocation_to_assembly_component_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to assembly component')AND(NOT((pdr.relating_product_definition \ product_definition.description = 'design definition path')AND(pdr.relating_product_definition.id = 'design composition path')))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to assembly component')AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.related_product_definition)))))= 0 ;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_constraint

RULE design_functional_unit_allocation_to_assembly_component_unique_constraint FOR (product_definition_relationship);
 LOCAL
 dfuatac : BAG  OF  product_definition_relationship := QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to  assembly component'));
 cd_bag : BAG  OF  component_definition := [ ];
 pdr_bag : BAG  OF  product_definition_relationship;
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(dfuatac)BY  1;
 IF  EXISTS(dfuatac [ i ].related_product_definition)THEN  IF('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(dfuatac [ i ].related_product_definition))THEN  IF(NOT(dfuatac [ i ].related_product_definition IN  cd_bag))THEN  cd_bag := cd_bag + dfuatac [ i ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* dfuatac |(pdr.related_product_definition :=: cd_bag [ i ]));
 id_bag := [ ];
 REPEAT j := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ j ].id)THEN  IF(pdr_bag [ j ].id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + pdr_bag [ j ].id;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_unique_constraint

RULE reference_composition_path_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference composition path')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition \ product_definition.description = 'reference definition path')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional occurrence'))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference composition path')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.related_product_definition))AND(pdr.related_product_definition.frame_of_reference.name = 'functional occurrence'))))= 0 ;
END_RULE; -- reference_composition_path_constraint

RULE reference_functional_unit_assignment_to_part_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference functional unit assignment to part')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION' IN  TYPEOF(pdr.related_product_definition))AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLICATION_CONTEXT_ELEMENT' IN TYPEOF(pdr.related_product_definition.frame_of_reference))AND((pdr.relating_product_definition.frame_of_reference.name = 'physical design')OR(pdr.relating_product_definition.frame_of_reference.name = 'physical design usage')))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference functional unit assignment to part')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition \ product_definition.description = 'design definition path')AND(pdr.relating_product_definition.id = 'reference composition path'))))= 0 ;
END_RULE; -- reference_functional_unit_assignment_to_part_constraint

RULE reference_functional_unit_assignment_to_part_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 sar : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'reference functional unit assignment to  part'));
 d_bag : BAG  OF  STRING := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 pd_bag : BAG OF product_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 IF  EXISTS(sar [ i ] \ shape_aspect_relationship.description)THEN  IF(NOT(sar [ i ] \ shape_aspect_relationship.description IN  d_bag))THEN  d_bag := d_bag + sar [ i ] \ shape_aspect_relationship.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(d_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(r <* sar |(r \ shape_aspect_relationship.description = d_bag [ i ]));
 pd_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect.of_shape.definition)THEN  IF(sar_bag [ j ].related_shape_aspect.of_shape.definition IN pd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pd_bag := pd_bag + sar_bag [ j ].related_shape_aspect.of_shape.definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- reference_functional_unit_assignment_to_part_unique_constraint

RULE physical_connectivity_definition_relationship_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'physical connectivity definition change')AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.related_shape_aspect))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'physical connectivity definition change')AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))))= 0 ;
	WR3 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'physical connectivity definition change')AND(SIZEOF(QUERY(rpd <* USEDIN(sar, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rpd))))= 0)))= 0 ;
END_RULE; -- physical_connectivity_definition_relationship_constraint

RULE physical_connectivity_element_unique_constraint FOR (physical_connectivity_element);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 pce_bag : BAG  OF  physical_connectivity_element;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 pcd_bag : BAG OF physical_connectivity_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(physical_connectivity_element)BY  1;
 IF  EXISTS(physical_connectivity_element [ i ] \ shape_aspect.name)THEN  IF(NOT(physical_connectivity_element [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + physical_connectivity_element [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pcd_bag := [ ];
 pce_bag := QUERY(pce <* physical_connectivity_element |(pce \ shape_aspect.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(pce_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(pce_bag [ j ], 'FUNCTIONAL_DESIGN_ELABORATION_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'structure element')AND('FUNCTIONAL_DESIGN_ELABORATION_MIM.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect))));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].relating_shape_aspect)THEN  IF(sar_bag [ j ].relating_shape_aspect IN pcd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pcd_bag := pcd_bag + sar_bag [ j ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- physical_connectivity_element_unique_constraint

RULE subtype_exclusiveness_geometric_tolerance FOR (geometric_tolerance);
 
WHERE
	WR1 :  SIZEOF(QUERY(gt <* geometric_tolerance | NOT(type_check_function(gt, [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FLATNESS_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POSITION_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TOTAL_RUNOUT_TOLERANCE' ], 3))))= 0 ;
END_RULE; -- subtype_exclusiveness_geometric_tolerance

RULE subtype_mandatory_geometric_tolerance FOR (geometric_tolerance);
 
WHERE
	WR1 :  SIZEOF(QUERY(gt <* geometric_tolerance | NOT(type_check_function(gt, [ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FLATNESS_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POSITION_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TOTAL_RUNOUT_TOLERANCE' ], 0))))= 0 ;
END_RULE; -- subtype_mandatory_geometric_tolerance

RULE compatible_dimension FOR (cartesian_point, direction, representation_context, geometric_representation_context);
 
WHERE
	WR1 :  SIZEOF(QUERY(x <* cartesian_point | SIZEOF(QUERY(y <* geometric_representation_context | item_in_context(x, y)AND(HIINDEX(x.coordinates)<> y.coordinate_space_dimension)))> 0))= 0 ;
	WR2 :  SIZEOF(QUERY(x <* direction | SIZEOF(QUERY(y <* geometric_representation_context | item_in_context(x, y)AND(HIINDEX(x.direction_ratios)<> y.coordinate_space_dimension)))> 0))= 0 ;
END_RULE; -- compatible_dimension

RULE product_definition_replacement_requires_effectivity_assignment FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr.name = 'definition replacement')AND(SIZEOF(USEDIN(pdr, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS'))= 0)))= 0 ;
END_RULE; -- product_definition_replacement_requires_effectivity_assignment

RULE restrict_assembly_category FOR (product_definition);
 LOCAL
 assembly_definitions : SET OF product_definition := [ ];
 END_LOCAL
;
 assembly_definitions := QUERY(pd <* product_definition | SIZEOF(QUERY(pdca <* USEDIN(pd, 'ITEM_DEFINITION_STRUCTURE_MIM.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION')| pdca.frame_of_reference.name = 'assembly definition'))> 0);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* assembly_definitions | NOT('assembly' IN categories_of_product(pd.formation.of_product))))= 0 ;
END_RULE; -- restrict_assembly_category

RULE restrict_product_definitions_for_part_definition_relationship FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr.name IN [ 'geometrical relationship', 'definition replacement' ])AND((pdr.relating_product_definition.frame_of_reference.name <> 'part definition')OR(pdr.related_product_definition.frame_of_reference.name <> 'part definition'))))= 0 ;
END_RULE; -- restrict_product_definitions_for_part_definition_relationship

RULE planar_curve_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(NOT(NOT(sr \ representation.name IN [ 'planar projected shape', 'bevel edge feature shape', 'step edge feature shape', 'radius edge feature shape' ])OR(sr \ representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))))= 0 ;
END_RULE; -- planar_curve_constraint

RULE feature_shape_definition_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'zone shape')AND(sr.context_of_items.coordinate_space_dimension = 3)AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(sr))))= 0 ;
END_RULE; -- feature_shape_definition_constraint

RULE model_parameter_unique_constraint FOR (model_parameter);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 mp_bag : BAG  OF  model_parameter;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 d_bag : BAG OF document;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(model_parameter)BY  1;
 IF  EXISTS(model_parameter [ i ] \ representation_item.name)THEN  IF(NOT(model_parameter [ i ] \ representation_item.name IN  name_bag))THEN  name_bag := name_bag + model_parameter [ i ] \ representation_item.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 mp_bag := QUERY(mp <* model_parameter |(mp \ representation_item.name = name_bag [ i ]));
 d_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(mp_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := USEDIN(mp_bag [ j ], 'MODEL_PARAMETER_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN d_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE d_bag := d_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- model_parameter_unique_constraint

RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(ala1 <* attribute_language_assignment | SIZEOF(QUERY(it <* ala1.items | SIZEOF(QUERY(ala2 <* USEDIN(it, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')|(ala1 \ attribute_classification_assignment.attribute_name = ala2 \ attribute_classification_assignment.attribute_name)AND(ala1 \ attribute_classification_assignment.assigned_class :=: ala2 \ attribute_classification_assignment.assigned_class)))> 1))> 0))= 0 ;
END_RULE; -- restrict_language_assignment_per_attribute

RULE bus_structural_definition_unique_constraint FOR (bus_structural_definition, product_definition_formation, product);
 LOCAL
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(bus_structural_definition)BY 1;
 IF  EXISTS(bus_structural_definition [ i ].formation.of_product.name)THEN  IF(bus_structural_definition [ i ].formation.of_product.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + bus_structural_definition [ i ] \ product_definition.formation.of_product.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- bus_structural_definition_unique_constraint

RULE functional_unit_network_node_definition_unique_constraint FOR (network_node_definition);
 LOCAL
 funnd : BAG  OF  network_node_definition := QUERY(nnd <* network_node_definition |(nnd.frame_of_reference.name = 'functional network design'));
 name_bag : BAG  OF  STRING := [ ];
 nnd_bag : BAG  OF  network_node_definition;
 pdr_bag : BAG  OF  product_definition_relationship;
 pass : BOOLEAN := TRUE;
 fu_bag : BAG OF functional_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(funnd)BY  1;
 IF  EXISTS(funnd [ i ] \ product_definition.name)THEN  IF(NOT(funnd [ i ] \ product_definition.name IN  name_bag))THEN  name_bag := name_bag + funnd [ i ] \ product_definition.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 fu_bag := [ ];
 nnd_bag := QUERY(nnd <* funnd |(nnd \ product_definition.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(nnd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(nnd_bag [ j ], 'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(pdr.relating_product_definition))AND(pdr \ product_definition_relationship.name = 'functional unit network node')));
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ k ].relating_product_definition)THEN  IF(pdr_bag [ k ].relating_product_definition IN fu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE fu_bag := fu_bag + pdr_bag [ k ].relating_product_definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_unit_network_node_definition_unique_constraint

RULE functional_unit_network_terminal_definition_bus_assignment_constraint FOR (property_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_relationship |(pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment')AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* property_definition_relationship |(pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(pdr.related_property_definition.definition))AND(SIZEOF(QUERY(futd <* USEDIN(pdr.related_property_definition.definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION.OF_SHAPE' IN TYPEOF(futd))))> 0))))= 0 ;
END_RULE; -- functional_unit_network_terminal_definition_bus_assignment_constraint

RULE functional_unit_terminal_bus_assignment_constraint FOR (property_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_relationship |(pdr \ property_definition_relationship.name = 'functional unit terminal bus assignment')AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition))))= 0 ;
END_RULE; -- functional_unit_terminal_bus_assignment_constraint

RULE functional_unit_unique_constraint FOR (component_functional_unit);
 LOCAL
 fu : BAG  OF  component_functional_unit := QUERY(cfu <* component_functional_unit |(cfu.frame_of_reference.name = 'functional occurrence'));
 id_bag : BAG  OF  STRING := [ ];
 cfu_bag : BAG  OF  component_functional_unit;
 pdr_bag : BAG  OF  product_definition_relationship;
 pass : BOOLEAN := TRUE;
 fu_bag : BAG OF functional_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(fu)BY  1;
 IF  EXISTS(fu [ i ].id)THEN  IF(NOT(fu [ i ].id IN  id_bag))THEN  id_bag := id_bag + fu [ i ].id;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(id_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 fu_bag := [ ];
 cfu_bag := QUERY(cfu <* fu |(cfu.id = id_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(cfu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(cfu_bag [ j ], 'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'network composition')AND('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition.frame_of_reference.name = 'functional network design')));
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ k ].relating_product_definition)THEN  IF(pdr_bag [ k ].relating_product_definition IN fu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE fu_bag := fu_bag + pdr_bag [ k ].relating_product_definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_unit_unique_constraint

RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR (functional_unit_terminal_definition);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 futd_bag : BAG  OF  functional_unit_terminal_definition;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 fu_bag : BAG OF functional_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(functional_unit_terminal_definition)BY  1;
 IF  EXISTS(functional_unit_terminal_definition [ i ] \ shape_aspect.name)THEN  IF(NOT(functional_unit_terminal_definition [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + functional_unit_terminal_definition [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 fu_bag := [ ];
 futd_bag := QUERY(futd <* functional_unit_terminal_definition |((futd \ shape_aspect.name = name_bag [ i ])AND('NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(futd.of_shape.definition))AND(futd.of_shape.definition.frame_of_reference.name = 'functional design usage')));
 REPEAT j := 1 TO SIZEOF(futd_bag)BY 1;
 IF  EXISTS(futd_bag [ j ].of_shape.definition)THEN  IF(futd_bag [ j ].of_shape.definition IN fu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE fu_bag := fu_bag + futd_bag [ j ].of_shape.definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_unit_usage_view_terminal_definition_unique_constraint

RULE package_unique_constraint FOR (package);
 LOCAL
 p : BAG  OF  physical_unit := QUERY(r <* package |(r.frame_of_reference.name = 'physical design usage'));
 pu : BAG  OF  physical_unit;
 pd_bag : BAG  OF  property_definition;
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 r_bag : BAG OF representation := [ ];
 END_LOCAL
;
 pu := p;
 REPEAT  i := 1 TO  SIZEOF(pu)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pd_bag := USEDIN(pu [ i ], 'PACKAGE_MIM.' + 'PROPERTY_DEFINITION.DEFINITION');
 REPEAT  j := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ j ], 'PACKAGE_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'registered case style'));
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ k ].used_representation)THEN  IF(pdr_bag [ k ].used_representation IN r_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE r_bag := r_bag + pdr_bag [ k ].used_representation;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- package_unique_constraint

RULE polarity_indication_feature_constraint FOR (shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(NOT(sa \ shape_aspect.description = 'polarity indication feature')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'associated body vertical extent'))|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(NOT(sa \ shape_aspect.description = 'polarity indication feature')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'associated body vertical extent'))|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1))))= 0 ;
	WR3 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(NOT(sa \ shape_aspect.description = 'polarity indication feature')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'associated terminal'))|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(it.relating_shape_aspect))))= 1))))= 0 ;
END_RULE; -- polarity_indication_feature_constraint

RULE packaged_connector_terminal_relationship_unique_constraint FOR (packaged_connector_terminal_relationship);
 LOCAL
 pu_bag : BAG  OF  physical_unit := [ ];
 pctr_bag : BAG  OF  packaged_connector_terminal_relationship;
 it_bag : BAG  OF  packaged_part_terminal;
 jt_bag : BAG OF packaged_part_terminal;
 pass1 : BOOLEAN  := TRUE ;
 pass2 : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(packaged_connector_terminal_relationship)BY  1;
 IF  EXISTS(packaged_connector_terminal_relationship [ i ].of_shape.definition)THEN  IF('PACKAGED_CONNECTOR_MODEL_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(packaged_connector_terminal_relationship [ i ].of_shape.definition))THEN  IF(NOT(packaged_connector_terminal_relationship [ i ].of_shape.definition IN  pu_bag))THEN  pu_bag := pu_bag + packaged_connector_terminal_relationship [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT(pass1 OR  pass2))THEN  ESCAPE ;
 END_IF ;
 it_bag := [ ];
 jt_bag := [ ];
 pctr_bag := QUERY(r <* packaged_connector_terminal_relationship |(r.of_shape.definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(pctr_bag)BY 1;
 IF(NOT(pass1 OR pass2))THEN  ESCAPE ;
 END_IF ;
 IF(pass1 AND('PACKAGED_CONNECTOR_MODEL_MIM.' + 'PACKAGED_PART_TERMINAL' IN  TYPEOF(pctr_bag [ j ].relating_shape_aspect))AND(pctr_bag [ j ].relating_shape_aspect \ shape_aspect.description = 'join terminal'))THEN  IF  EXISTS(pctr_bag [ j ].relating_shape_aspect)THEN  IF(pctr_bag [ j ].relating_shape_aspect IN  jt_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  jt_bag := jt_bag + pctr_bag [ j ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 IF(pass2 AND('PACKAGED_CONNECTOR_MODEL_MIM.' + 'PACKAGED_PART_TERMINAL' IN  TYPEOF(pctr_bag [ j ].related_shape_aspect))AND(pctr_bag [ j ].related_shape_aspect \ shape_aspect.description = 'interface terminal'))THEN  IF  EXISTS(pctr_bag [ j ].related_shape_aspect)THEN  IF(pctr_bag [ j ].related_shape_aspect IN it_bag)THEN pass2 := FALSE;
 ESCAPE;
 ELSE it_bag := it_bag + pctr_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- packaged_connector_terminal_relationship_unique_constraint

RULE packaged_part_unique_constraint FOR (packaged_part);
 LOCAL
 pp : SET OF  physical_unit := packaged_part;
 pdr_bag : BAG  OF  product_definition_relationship;
 pdf_bag : BAG OF product_definition_formation := [ ];
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pp)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdf_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pp [ i ], 'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'used package')AND(('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' + 'PACKAGE' IN  TYPEOF(pdr.relating_product_definition)))));
 pdf_bag := pdf_bag + pdr_bag [ 1 ].relating_product_definition.formation;
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF(NOT  pass)THEN  ESCAPE;
 END_IF ;
 IF  EXISTS(pdr_bag [ k ].relating_product_definition.formation)THEN  IF NOT(pdr_bag [ k ].relating_product_definition.formation IN pdf_bag)THEN pass := FALSE;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- packaged_part_unique_constraint

RULE package_external_reference_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'design owner'))))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'part number'))))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'revision code'))))= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'product definition id'))))= 1)))= 0 ;
END_RULE; -- package_external_reference_constraint

RULE package_terminal_external_reference_constraint FOR (descriptive_representation_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(dri <* descriptive_representation_item |(dri \ representation_item.name = 'package terminal external reference')AND(SIZEOF(QUERY(rep <* USEDIN(dri, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REPRESENTATION.ITEMS')|(rep \ representation.name = 'package external reference')))= 0)))= 0 ;
END_RULE; -- package_terminal_external_reference_constraint

RULE package_terminal_external_reference_unique_constraint FOR (descriptive_representation_item);
 LOCAL
 pter : BAG  OF  descriptive_representation_item := QUERY(dri <* descriptive_representation_item |(dri \ representation_item.name = 'package terminal external reference'));
 desc_bag : BAG  OF  STRING := [ ];
 dri_bag : BAG  OF  descriptive_representation_item;
 rep_bag : BAG  OF  representation;
 pass : BOOLEAN := TRUE;
 r_bag : BAG OF representation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pter)BY  1;
 IF  EXISTS(pter [ i ] \ descriptive_representation_item.description)THEN  IF(NOT(pter [ i ] \ descriptive_representation_item.description IN  desc_bag))THEN  desc_bag := desc_bag + pter [ i ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(desc_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 r_bag := [ ];
 dri_bag := QUERY(dri <* pter |(dri \ descriptive_representation_item.description = desc_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(dri_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 rep_bag := QUERY(r <* USEDIN(dri_bag [ j ], 'PART_EXTERNAL_REFERENCE_MIM.' + 'REPRESENTATION.ITEMS')|(r \ representation.name = 'package external reference'));
 REPEAT k := 1 TO SIZEOF(rep_bag)BY 1;
 IF  EXISTS(rep_bag [ k ])THEN  IF(rep_bag [ k ] IN r_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE r_bag := r_bag + rep_bag [ k ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- package_terminal_external_reference_unique_constraint

RULE part_terminal_external_reference_unique_constraint FOR (representation);
 LOCAL
 pter : BAG  OF  representation := QUERY(r <* representation |(r \ representation.name = 'part terminal external reference'));
 fn_bag : BAG  OF  STRING  := [ ];
 ft_bag : BAG  OF  STRING := [ ];
 r_bag : BAG  OF  representation;
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 ptd_bag : BAG OF part_template_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pter)BY  1;
 REPEAT  j := 1 TO  SIZEOF(pter [ i ].items)BY  1;
 IF('PART_EXTERNAL_REFERENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(pter [ i ].items [ j ]))THEN  IF((pter [ i ].items [ j ] \ representation_item.name = 'feature name')AND(NOT(pter [ i ].items [ j ] \ descriptive_representation_item.description IN  fn_bag)))THEN  fn_bag := fn_bag + pter [ i ].items [ j ] \ descriptive_representation_item.description;
 END_IF ;
 IF((pter [ i ].items [ j ] \ representation_item.name = 'feature type')AND(NOT(pter [ i ].items [ j ] \ descriptive_representation_item.description IN  ft_bag)))THEN  ft_bag := ft_bag + pter [ i ].items [ j ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fn_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT  j := 1 TO  SIZEOF(ft_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 r_bag := QUERY(r <* pter |((SIZEOF(QUERY(ri <* r.items |((ri \ descriptive_representation_item.description = ft_bag [ j ])AND(ri \ representation_item.name = 'feature type'))))> 0)AND(SIZEOF(QUERY(ri <* r.items |((ri \ descriptive_representation_item.description = fn_bag [ i ])AND(ri \ representation_item.name = 'feature name'))))> 0)));
 ptd_bag := [ ];
 REPEAT  k := 1 TO  SIZEOF(r_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := USEDIN(r_bag [ k ], 'PART_EXTERNAL_REFERENCE_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
 REPEAT l := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ l ].definition.definition)THEN  IF('PART_EXTERNAL_REFERENCE_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(pdr_bag [ l ].definition.definition))THEN  IF(pdr_bag [ l ].definition.definition IN ptd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE ptd_bag := ptd_bag + pdr_bag [ l ].definition.definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- part_terminal_external_reference_unique_constraint

RULE restrict_part_occurrence FOR (product_definition);
 LOCAL
 part_occurrences : SET OF product_definition := [ ];
 END_LOCAL
;
 part_occurrences := QUERY(pd <* product_definition |(pd.frame_of_reference.name = 'part occurrence'));
 
WHERE
	wr1 :  SIZEOF(QUERY(pd <* part_occurrences |(NOT(pd.name IN [ 'single instance', 'selected instance', 'quantified instance', 'specified instance' ]))))= 0 ;
	wr2 :  SIZEOF(QUERY(pd <* part_occurrences |(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr.name = 'definition usage'))<> 1)AND(SIZEOF(QUERY(cd <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN')|(cd.name = 'occurrence usage definition')AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF(cd.configuration)))))<> 1)))= 0 ;
	wr3 :  SIZEOF(QUERY(pd <* part_occurrences |(SIZEOF(QUERY(cd <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_USAGE' IN TYPEOF(cd))))= 0)AND(SIZEOF(USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE'))= 0)))= 0 ;
	wr4 :  SIZEOF(QUERY(pd <* part_occurrences |(pd.name = 'selected instance')AND NOT valid_selected_instance_representation(pd)))= 0 ;
	wr5 :  SIZEOF(QUERY(pd <* part_occurrences |(pd.name = 'quantified instance')AND(SIZEOF(QUERY(ppd <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(ppd.name = 'occurrence quantity')AND(SIZEOF(QUERY(pdr <* USEDIN(ppd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation.name = 'quantity')AND(SIZEOF(pdr.used_representation.items)= 1)AND(SIZEOF(QUERY(i <* pdr.used_representation.items |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i))AND(i.name = 'quantity measure')))= 1)))= 1)))= 0)))= 0 ;
	wr6 :  SIZEOF(QUERY(pd <* part_occurrences |(pd.name = 'specified instance')AND(SIZEOF(QUERY(pdor <* USEDIN(pd, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdor.occurrence_usage)))= 0)))= 0 ;
END_RULE; -- restrict_part_occurrence

RULE restrict_part_occurrence_category FOR (product_definition);
 LOCAL
 part_occurrences : SET OF product_definition := [ ];
 END_LOCAL
;
 part_occurrences := QUERY(pd <* product_definition |(pd.frame_of_reference.name = 'part occurrence'));
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* part_occurrences |(SIZEOF(QUERY(prpc <* USEDIN(pd.formation.of_product, 'PRODUCT_OCCURRENCE_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name IN [ 'part', 'raw material', 'tool' ]))= 0)))= 0 ;
END_RULE; -- restrict_part_occurrence_category

RULE restrict_product_definitions_for_definition_usage FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr.name = 'definition usage')AND((pdr.relating_product_definition.frame_of_reference.name <> 'part definition')OR(pdr.related_product_definition.frame_of_reference.name <> 'part occurrence'))))= 0 ;
END_RULE; -- restrict_product_definitions_for_definition_usage

RULE selected_instance_usage_requires_representation FOR (assembly_component_usage);
 LOCAL
 selected_instance_usages : SET OF assembly_component_usage := [ ];
 END_LOCAL
;
 selected_instance_usages := QUERY(acr <* assembly_component_usage |(acr.name = 'selected instance usage'));
 
WHERE
	WR1 :  SIZEOF(QUERY(acr <* selected_instance_usages | NOT valid_selected_instance_representation(acr)))= 0 ;
END_RULE; -- selected_instance_usage_requires_representation

RULE functional_usage_view_to_part_terminal_assignment_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'functional terminal allocation')AND  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'scalar terminal'))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'functional terminal allocation')AND NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN  TYPEOF(sar.related_shape_aspect))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BARE_DIE_TERMINAL' IN  TYPEOF(sar.related_shape_aspect))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL' IN  TYPEOF(sar.related_shape_aspect))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.related_shape_aspect)))))= 0 ;
END_RULE; -- functional_usage_view_to_part_terminal_assignment_constraint

RULE functional_usage_view_to_part_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 fuvtpta : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'functional terminal allocation'));
 futd_bag : BAG  OF  functional_unit_terminal_definition := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 sa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(fuvtpta)BY  1;
 IF  EXISTS(fuvtpta [ i ].relating_shape_aspect)THEN  IF(fuvtpta [ i ].relating_shape_aspect \ shape_aspect.description = 'scalar terminal')THEN  IF(NOT(fuvtpta [ i ].relating_shape_aspect IN  futd_bag))THEN  futd_bag := futd_bag + fuvtpta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(futd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* fuvtpta |((sar.relating_shape_aspect :=: futd_bag [ i ])AND(SIZEOF([ 'PART_TERMINAL_MIM.' + 'ASSEMBLY_MODULE_TERMINAL', 'PART_TERMINAL_MIM.' + 'BARE_DIE_TERMINAL', 'PART_TERMINAL_MIM.' + 'INTERCONNECT_MODULE_TERMINAL', 'PART_TERMINAL_MIM.' + 'PACKAGED_PART_TERMINAL' ] * TYPEOF(sar.related_shape_aspect))> 0)));
 sa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(sar_bag [ j ].related_shape_aspect IN sa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sa_bag := sa_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_usage_view_to_part_terminal_assignment_unique_constraint

RULE part_feature_constraint FOR (shape_aspect, product_definition, shape_aspect_relationship);
 LOCAL
 pass : BOOLEAN := TRUE;
 name_bag : BAG  OF  STRING := [ ];
 sa : BAG  OF  shape_aspect := [ ];
 pd : BAG OF product_definition := QUERY(pd <* product_definition | pd.frame_of_reference \ application_context_element.name = 'physical design usage');
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pd)BY  1;
 name_bag := [ ];
 sa := QUERY(sa <* shape_aspect |((sa.of_shape \ property_definition.definition = pd [ i ])AND(sa.product_definitional)AND(NOT(sa \ shape_aspect.description = 'connection zone'))));
 REPEAT j := 1 TO SIZEOF(sa)BY 1;
 IF(NOT pass)THEN  ESCAPE;
 END_IF ;
 IF sa [ j ] \ shape_aspect.name IN name_bag THEN pass := FALSE;
 ELSE name_bag := name_bag + sa [ j ] \ shape_aspect.name;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'precedent feature')AND(sar.related_shape_aspect = sar.relating_shape_aspect)))= 0 ;
	WR3 :  SIZEOF(QUERY(sa <* shape_aspect |((sa \ shape_aspect.description = 'part group feature')OR(sa \ shape_aspect.description = 'part generic feature')OR(sa \ shape_aspect.description = 'polarity indication feature'))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feature'))> 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(sa <* shape_aspect |((sa \ shape_aspect.description = 'interconnect module edge segment surface')OR(sa \ shape_aspect.description = 'interconnect module cavity surface')OR(sa \ shape_aspect.description = 'interconnect module cutout surface')OR(sa \ shape_aspect.description = 'interconnect module edge surface')OR(sa \ shape_aspect.description = 'interconnect module primary surface')OR(sa \ shape_aspect.description = 'interconnect module secondary surface')OR(sa \ shape_aspect.description = 'interconnect module surface feature'))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feature'))> 0)))= 0 ;
END_RULE; -- part_feature_constraint

RULE product_definition_requires_date_or_date_and_time FOR (product_definition, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition | NOT(NOT(is_ee_product_definition(pd))OR((SIZEOF(QUERY(adata <* applied_date_and_time_assignment | pd IN  adata.items))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment | pd IN ada.items))= 1)))))= 0 ;
END_RULE; -- product_definition_requires_date_or_date_and_time

RULE product_definition_requires_person_organization FOR (product_definition, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition | NOT(NOT(is_ee_product_definition(pd))OR((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | pd IN  apaoa.items))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | pd IN aoa.items))= 1)))))= 0 ;
END_RULE; -- product_definition_requires_person_organization

RULE promissory_usage_relationship_constraint FOR (promissory_usage_occurrence);
 
WHERE
	WR1 :  SIZEOF(QUERY(puo <* promissory_usage_occurrence |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(puo.relating_product_definition))AND(puo.relating_product_definition.frame_of_reference.name = 'physical design')))= 0 ;
	WR2 :  SIZEOF(QUERY(puo <* promissory_usage_occurrence | SIZEOF(USEDIN(puo, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 0))= 0 ;
END_RULE; -- promissory_usage_relationship_constraint

RULE promissory_usage_relationship_unique_constraint FOR (promissory_usage_occurrence);
 LOCAL
 pu_bag : BAG  OF  physical_unit := [ ];
 puo_bag : BAG  OF  promissory_usage_occurrence;
 pass : BOOLEAN := TRUE;
 comp_bag : BAG OF physical_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(promissory_usage_occurrence)BY  1;
 IF  EXISTS(promissory_usage_occurrence [ i ].relating_product_definition)THEN  IF((('PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 'PHYSICAL_UNIT')IN  TYPEOF(promissory_usage_occurrence [ i ].relating_product_definition))AND(promissory_usage_occurrence [ i ].relating_product_definition.frame_of_reference.name = 'physical design'))THEN  IF(NOT(promissory_usage_occurrence [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + promissory_usage_occurrence [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 puo_bag := QUERY(puo <* promissory_usage_occurrence |(puo.relating_product_definition :=: pu_bag [ i ]));
 comp_bag := [ ];
 REPEAT j := 1 TO SIZEOF(puo_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF((('PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 'PHYSICAL_UNIT')IN  TYPEOF(puo_bag [ j ].related_product_definition))AND(puo_bag [ j ].related_product_definition.frame_of_reference.name IN  [ 'physical design', 'physical design usage' ]))THEN  IF  EXISTS(puo_bag [ j ].related_product_definition)THEN  IF(puo_bag [ j ].related_product_definition IN comp_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE comp_bag := comp_bag + puo_bag [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- promissory_usage_relationship_unique_constraint

RULE rule_action_unique_constraint FOR (rule_action);
 LOCAL
 adta : BAG  OF  applied_date_and_time_assignment;
 adta_bag : BAG  OF  applied_date_and_time_assignment := [ ];
 ra_bag : BAG  OF  rule_action;
 aaa_bag : BAG  OF  applied_action_assignment;
 pass : BOOLEAN := TRUE;
 rd_bag : BAG OF product_definition_formation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(rule_action)BY  1;
 adta := USEDIN(rule_action [ i ], 'PRODUCT_RULE_MIM.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS');
 REPEAT  j := 1 TO  SIZEOF(adta)BY  1;
 IF  EXISTS(adta [ j ])THEN  IF(NOT(adta [ j ] IN  adta_bag))THEN  adta_bag := adta_bag + adta [ j ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(adta_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ra_bag := QUERY(r <* rule_action |(r IN  adta_bag [ i ].items));
 rd_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(ra_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 aaa_bag := QUERY(aa <* USEDIN(ra_bag [ j ], 'PRODUCT_RULE_MIM.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')|(('PRODUCT_RULE_MIM.' + 'APPLIED_ACTION_ASSIGNMENT')IN  TYPEOF(aa)));
 REPEAT  k := 1 TO  SIZEOF(aaa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(aaa_bag [ k ].items)BY 1;
 IF  EXISTS(aaa_bag [ k ].items [ l ])THEN  IF(('PRODUCT_RULE_MIM.' + 'PRODUCT_DEFINITION_FORMATION' IN  TYPEOF(aaa_bag [ k ].items [ l ]))AND(aaa_bag [ k ].items [ l ] \ product_definition_formation.description = 'rule version'))THEN  IF(aaa_bag [ k ].items [ l ] IN rd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rd_bag := rd_bag + aaa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_action_unique_constraint

RULE rule_conclusion_definition_unique_constraint FOR (rule_conclusion_definition, representation, representation_relationship);
 LOCAL
 r : BAG  OF  representation := QUERY(r <* representation | r \ representation.name = 'rule definition');
 rr : BAG  OF  representation_relationship := [ ];
 pass : BOOLEAN := TRUE;
 count : INTEGER := 0;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(r)BY  1;
 count := 0;
 name_bag := [ ];
 IF  NOT pass THEN  ESCAPE;
 END_IF ;
 rr := USEDIN(r [ i ], 'PRODUCT_RULE_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_1');
 REPEAT j := 1 TO SIZEOF(rr)BY 1;
 IF  'PRODUCT_RULE_MIM.' + 'RULE_CONCLUSION_DEFINITION' IN  TYPEOF(rr [ j ].rep_2)THEN  IF  EXISTS(rr [ j ].rep_2 \ representation.name)THEN  IF rr [ j ].rep_2 \ representation.name IN name_bag THEN pass := FALSE;
 ELSE name_bag := name_bag + rr [ j ].rep_2 \ representation.name;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_conclusion_definition_unique_constraint

RULE rule_function_unique_constraint FOR (rule_function_definition);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 rfd_bag : BAG  OF  rule_function_definition;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 doc_bag : BAG OF document;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(rule_function_definition)BY  1;
 IF  EXISTS(rule_function_definition [ i ] \ representation.name)THEN  IF(NOT(rule_function_definition [ i ] \ representation.name IN  name_bag))THEN  name_bag := name_bag + rule_function_definition [ i ] \ representation.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 doc_bag := [ ];
 rfd_bag := QUERY(am <* rule_function_definition |(am \ representation.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(rfd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := QUERY(adr <* USEDIN(rfd_bag [ j ], 'PRODUCT_RULE_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adr.assigned_document.kind \ document_type.product_data_type = 'reference document'));
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN doc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE doc_bag := doc_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_function_unique_constraint

RULE rule_premise_definition_unique_constraint FOR (rule_premise_definition, representation, representation_relationship);
 LOCAL
 rr : BAG  OF  representation_relationship := [ ];
 rpd : BAG OF rule_premise_definition := [ ];
 pass : BOOLEAN := TRUE;
 count : INTEGER := 0;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(rule_premise_definition)BY  1;
 count := 0;
 IF  NOT  pass THEN  ESCAPE ;
 END_IF ;
 rr := USEDIN(rule_premise_definition [ i ], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_2');
 REPEAT j := 1 TO SIZEOF(rr)BY 1;
 IF  NOT pass THEN  ESCAPE;
 END_IF ;
 IF(rr [ j ] \ representation_relationship.rep_1 \ representation.description IN [ 'rule definition' ])THEN  count := count + 1;
 END_IF ;
 IF count = 2 THEN pass := FALSE;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_premise_definition_unique_constraint

RULE operational_requirement_occurrence_relationship_constraint FOR (property_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_relationship |((pdr \ property_definition_relationship.name = 'and operation')OR(pdr \ property_definition_relationship.name = 'or operation'))AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* property_definition_relationship |((pdr \ property_definition_relationship.name = 'and operation')OR(pdr \ property_definition_relationship.name = 'or operation'))AND NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition))))= 0 ;
END_RULE; -- operational_requirement_occurrence_relationship_constraint

RULE requirements_property_constraint FOR (product_definition, descriptive_representation_item, requirements_property);
 LOCAL
 ri : BAG  OF  descriptive_representation_item := QUERY(dri <* descriptive_representation_item | dri \ representation_item.name = 'requirements name');
 pd : BAG  OF  product_definition := QUERY(tpd <* product_definition |('REQUIREMENT_DECOMPOSITION_MIM.' + 'APPLICATION_CONTEXT_ELEMENT' IN  TYPEOF(tpd.frame_of_reference))AND(tpd.frame_of_reference.name IN  [ 'requirement', 'design requirement', 'assembly requirement' ])AND(tpd.name = 'requirements model'));
 r : BAG  OF  representation := [ ];
 pdr : BAG  OF  property_definition_representation := [ ];
 pass1 : BOOLEAN  := TRUE ;
 rp : BAG OF property_definition := [ ];
 pass2 : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(ri)BY  1;
 r := [ ];
 pdr := [ ];
 r :=(USEDIN(ri [ i ], 'REQUIREMENT_DECOMPOSITION_MIM.' + 'REPRESENTATION.ITEMS'));
 pass1 :=(SIZEOF(r)= 1);
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 pdr :=(USEDIN(r [ 1 ], 'REQUIREMENT_DECOMPOSITION_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 pass1 :=(SIZEOF(pdr)= 1);
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 pass1 :=('REQUIREMENT_DECOMPOSITION_MIM.' + 'REQUIREMENTS_PROPERTY' IN  TYPEOF(pdr [ 1 ].definition));
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pd)BY 1;
 rp := [ ];
 IF(NOT pass2)THEN ESCAPE;
 END_IF;
 rp := QUERY(rp <* USEDIN(pd [ i ], 'REQUIREMENT_DECOMPOSITION_MIM.' + 'PROPERTY_DEFINITION.DEFINITION')| 'REQUIREMENT_DECOMPOSITION_MIM.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
 pass2 :=(SIZEOF(rp)= 1);
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- requirements_property_constraint

RULE requirements_property_unique_constraint FOR (descriptive_representation_item, requirements_property);
 LOCAL
 desc_bag : BAG  OF  STRING := [ ];
 pass1 : BOOLEAN := TRUE;
 pdr : BAG  OF  property_definition_representation := [ ];
 rep : BAG  OF  representation := [ ];
 pd : BAG OF product_definition := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(requirements_property)BY 1;
 IF(NOT pass1)THEN  ESCAPE;
 END_IF ;
 IF('REQUIREMENT_DECOMPOSITION_MIM.' + 'PRODUCT_DEFINITION' IN TYPEOF(requirements_property [ i ].definition))THEN  pd := pd + requirements_property [ i ].definition;
 END_IF ;
 END_REPEAT;
 IF(instance_unique(pd)= FALSE)THEN pass1 := FALSE;
 END_IF;
 
WHERE
	WR1 :  pass1 ;
END_RULE; -- requirements_property_unique_constraint

RULE composite_shape_element_constraint FOR (composite_shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(csa <* composite_shape_aspect | SIZEOF(QUERY(sar <* USEDIN(csa, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'composing')))< 2))= 0 ;
	WR2 :  SIZEOF(QUERY(csa <* composite_shape_aspect | NOT((SIZEOF(TYPEOF(csa))> 2)OR(csa \ shape_aspect.description <> '')OR(csa \ shape_aspect.name <> ''))))= 0 ;
END_RULE; -- composite_shape_element_constraint

RULE shape_element_composing_relationship_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'composing')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))))= 0 ;
END_RULE; -- shape_element_composing_relationship_constraint

RULE shape_element_constituent_relationship_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 sar : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name IN  [ 'constituent', 'composing', 'bare die terminal surface constituent relationship', 'interconnect module terminal surface constituent relationship', 'package terminal surface constituent relationship' ]));
 sa_bag : BAG  OF  shape_aspect := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 rsa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 IF  EXISTS(sar [ i ].relating_shape_aspect)THEN  IF(NOT(sar [ i ].relating_shape_aspect IN  sa_bag))THEN  sa_bag := sa_bag + sar [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(r <* sar |(r \ shape_aspect_relationship.relating_shape_aspect :=: sa_bag [ i ]));
 rsa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(sar_bag [ j ].related_shape_aspect IN rsa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rsa_bag := rsa_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- shape_element_constituent_relationship_unique_constraint

RULE shape_element_locating_relationship_unique_constraint FOR (dimensional_location);
 LOCAL
 sa_bag : BAG  OF  shape_aspect := [ ];
 dl_bag : BAG  OF  dimensional_location;
 pass : BOOLEAN := TRUE;
 rsa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(dimensional_location)BY  1;
 IF  EXISTS(dimensional_location [ i ].relating_shape_aspect)THEN  IF(NOT(dimensional_location [ i ].relating_shape_aspect IN  sa_bag))THEN  sa_bag := sa_bag + dimensional_location [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 dl_bag := QUERY(r <* dimensional_location |(r.relating_shape_aspect :=: sa_bag [ i ]));
 rsa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(dl_bag)BY 1;
 IF  EXISTS(dl_bag [ j ].related_shape_aspect)THEN  IF(dl_bag [ j ].related_shape_aspect IN rsa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rsa_bag := rsa_bag + dl_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- shape_element_locating_relationship_unique_constraint

RULE subtype_mandatory_composite_shape_aspect FOR (composite_shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(csa <* composite_shape_aspect | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPOSITE_GROUP_SHAPE_ASPECT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPOSITE_UNIT_SHAPE_ASPECT' ] * TYPEOF(csa))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_composite_shape_aspect

RULE product_requires_category FOR (product);
 
WHERE
	WR1 :  SIZEOF(QUERY(p <* product | SIZEOF(USEDIN(p, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS'))= 0))= 0 ;
END_RULE; -- product_requires_category

RULE subtype_exclusive_measure_with_unit FOR (measure_with_unit);
 
WHERE
	WR1 :  SIZEOF(QUERY(mwu <* measure_with_unit | NOT(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ABSORBED_DOSE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTIVITY_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'AREA_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CAPACITANCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONDUCTANCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DOSE_EQUIVALENT_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ELECTRIC_CHARGE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ELECTRIC_CURRENT_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ELECTROMOTIVE_FORCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ENERGY_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FORCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'FREQUENCY_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ILLUMINANCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'INDUCTANCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LUMINOUS_FLUX_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LUMINOUS_INTENSITY_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MAGNETIC_FLUX_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'MASS_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PLANE_ANGLE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POWER_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRESSURE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RATIO_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'RESISTANCE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SOLID_ANGLE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TIME_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'UNCERTAINTY_MEASURE_WITH_UNIT', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'VOLUME_MEASURE_WITH_UNIT' ] * TYPEOF(mwu))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_measure_with_unit

FUNCTION acyclic_action_method_relationship
	(relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF action_method_relationship;
 END_LOCAL
;
 IF  relation.relating_method IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD'))| specific_relation IN TYPEOF(am));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_action_method_relationship(x [ i ], relatives + relation.relating_method, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_action_method_relationship

FUNCTION acyclic_action_relationship
	(relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF action_relationship;
 END_LOCAL
;
 IF  relation.relating_action IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION'))| specific_relation IN TYPEOF(actn));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_action_relationship(x [ i ], relatives + relation.relating_action, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_action_relationship

FUNCTION acyclic_action_resource_relationship
	(relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF action_resource_relationship;
 END_LOCAL
;
 IF  relation.relating_resource IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE'))| specific_relation IN TYPEOF(ar));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_action_resource_relationship(x [ i ], relatives + relation.relating_resource, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_action_resource_relationship

FUNCTION acyclic_versioned_action_request_relationship
	(relation : versioned_action_request_relationship; relatives : SET [0:?] OF versioned_action_request; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF versioned_action_request_relationship;
 END_LOCAL
;
 IF  relation.relating_versioned_action_request IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST'))| specific_relation IN TYPEOF(varr));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_versioned_action_request_relationship(x [ i ], relatives + relation.relating_versioned_action_request, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_versioned_action_request_relationship

FUNCTION gbsf_check_curve
	(cv : representation_item) : BOOLEAN;
 IF  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOUNDED_CURVE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CONIC', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE_REPLICA', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LINE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OFFSET_CURVE_3D' ] * TYPEOF(cv))> 1 THEN  RETURN(FALSE );
 END_IF ;
 IF  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CIRCLE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ELLIPSE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TRIMMED_CURVE' ] * TYPEOF(cv))= 1 THEN  RETURN(TRUE );
 ELSE  IF(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_CURVE' IN  TYPEOF(cv))AND(cv \ b_spline_curve.self_intersect = FALSE)OR(cv \ b_spline_curve.self_intersect = UNKNOWN))THEN  RETURN(TRUE );
 ELSE  IF(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPOSITE_CURVE' IN  TYPEOF(cv))AND(cv \ composite_curve.self_intersect = FALSE)OR(cv \ composite_curve.self_intersect = UNKNOWN))THEN  RETURN(SIZEOF(QUERY(seg <* cv \ composite_curve.segments | NOT(gbsf_check_curve(seg.parent_curve))))= 0);
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE_REPLICA' IN  TYPEOF(cv)THEN  RETURN(gbsf_check_curve(cv \ curve_replica.parent_curve));
 ELSE  IF(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OFFSET_CURVE_3D' IN  TYPEOF(cv))AND((cv \ offset_curve_3d.self_intersect = FALSE)OR(cv \ offset_curve_3d.self_intersect = UNKNOWN))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLYLINE' IN  TYPEOF(cv \ offset_curve_3d.basis_curve))))THEN  RETURN(gbsf_check_curve(cv \ offset_curve_3d.basis_curve));
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN  TYPEOF(cv)THEN  RETURN((gbsf_check_curve(cv \ pcurve.reference_to_curve \ representation.items [ 1 ]))AND(gbsf_check_surface(cv \ pcurve.basis_surface)));
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLYLINE' IN  TYPEOF(cv)THEN  IF(SIZEOF(cv \ polyline.points)>= 3)THEN  RETURN(TRUE );
 END_IF ;
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF(cv)THEN  IF  gbsf_check_curve(cv \ surface_curve.curve_3d)THEN  REPEAT i := 1 TO SIZEOF(cv \ surface_curve.associated_geometry);
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE' IN  TYPEOF(cv \ surface_curve.associated_geometry [ i ])THEN  IF  NOT  gbsf_check_surface(cv \ surface_curve.associated_geometry [ i ])THEN  RETURN(FALSE );
 END_IF ;
 ELSE IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(cv \ surface_curve.associated_geometry [ i ])THEN  IF NOT gbsf_check_curve(cv \ surface_curve.associated_geometry [ i ])THEN RETURN(FALSE );
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT;
 RETURN(TRUE);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- gbsf_check_curve

FUNCTION gbsf_check_point
	(pnt : point) : BOOLEAN;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(pnt)THEN  RETURN(TRUE);
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POINT_ON_CURVE' IN  TYPEOF(pnt)THEN  RETURN(gbsf_check_curve(pnt \ point_on_curve.basis_curve));
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POINT_ON_SURFACE' IN  TYPEOF(pnt)THEN  RETURN(gbsf_check_surface(pnt \ point_on_surface.basis_surface));
 ELSE IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(pnt)THEN RETURN((gbsf_check_curve(pnt \ degenerate_pcurve.reference_to_curve \ representation.items [ 1 ]))AND(gbsf_check_surface(pnt \ degenerate_pcurve.basis_surface)));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- gbsf_check_point

FUNCTION gbsf_check_surface
	(sf : surface) : BOOLEAN;
 IF(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_SURFACE' IN  TYPEOF(sf))AND(sf \ b_spline_surface.self_intersect = FALSE)OR(sf \ b_spline_surface.self_intersect = UNKNOWN))THEN  RETURN(TRUE );
 ELSE  IF  SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SPHERICAL_SURFACE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TOROIDAL_SURFACE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE_BOUNDED_SURFACE', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' ] * TYPEOF(sf))= 1 THEN  RETURN(TRUE );
 ELSE  IF(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OFFSET_SURFACE' IN  TYPEOF(sf))AND(sf \ offset_surface.self_intersect = FALSE)OR(sf \ offset_surface.self_intersect = UNKNOWN))THEN  RETURN(gbsf_check_surface(sf \ offset_surface.basis_surface));
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE' IN  TYPEOF(sf)THEN  REPEAT  i := 1 TO  SIZEOF(sf \ rectangular_composite_surface.segments);
 REPEAT j := 1 TO SIZEOF(sf \ rectangular_composite_surface.segments [ i ]);
 IF  NOT(gbsf_check_surface(sf \ rectangular_composite_surface.segments [ i ] [ j ].parent_surface))THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_REPEAT;
 RETURN(TRUE);
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_REPLICA' IN  TYPEOF(sf)THEN  RETURN(gbsf_check_surface(sf \ surface_replica.parent_surface));
 ELSE IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(sf)THEN RETURN(gbsf_check_curve(sf \ swept_surface.swept_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- gbsf_check_surface

FUNCTION acyclic_approval_relationship
	(relation : approval_relationship; relatives : SET [1:?] OF approval; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF approval_relationship;
 END_LOCAL
;
 IF  relation.relating_approval IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL'))| specific_relation IN TYPEOF(app));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_approval_relationship(x [ i ], relatives + relation.relating_approval, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_approval_relationship

FUNCTION get_description_value
	(obj : description_attribute_select) : text;
 LOCAL
 description_bag : BAG OF description_attribute :=(USEDIN(obj, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
 END_LOCAL
;
 IF SIZEOF(description_bag)= 1 THEN RETURN(description_bag [ 1 ].attribute_value);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_description_value

FUNCTION get_id_value
	(obj : id_attribute_select) : identifier;
 LOCAL
 id_bag : BAG OF id_attribute :=(USEDIN(obj, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
 END_LOCAL
;
 IF SIZEOF(id_bag)= 1 THEN RETURN(id_bag [ 1 ].attribute_value);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_id_value

FUNCTION get_name_value
	(obj : name_attribute_select) : label;
 LOCAL
 name_bag : BAG OF name_attribute :=(USEDIN(obj, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
 END_LOCAL
;
 IF SIZEOF(name_bag)= 1 THEN RETURN(name_bag [ 1 ].attribute_value);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_name_value

FUNCTION get_role
	(obj : role_select) : object_role;
 LOCAL
 role_bag : BAG OF role_association :=(USEDIN(obj, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
 END_LOCAL
;
 IF SIZEOF(role_bag)= 1 THEN RETURN(role_bag [ 1 ].role);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_role

FUNCTION class_assignment_is_valid
	(aia : applied_classification_assignment) : BOOLEAN;
 LOCAL
 item : classification_item;
 role : classification_role;
 END_LOCAL
;
 role := aia.role;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CLASS_SYSTEM' IN  TYPEOF(aia.assigned_class))THEN  IF(role.name <> 'class system membership')THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := LOINDEX(aia.items)TO  HIINDEX(aia.items);
 item := aia.items [ i ];
 IF(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CLASS_SYSTEM_ITEM' ] * TYPEOF(item))= 0)THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHARACTERIZED_CLASS' IN  TYPEOF(aia.assigned_class))THEN  IF  NOT(role.name IN [ 'definitional', 'non-definitional', '' ])THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := LOINDEX(aia.items)TO HIINDEX(aia.items);
 item := aia.items [ i ];
 IF(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CLASSIFIED_ITEM' ] * TYPEOF(item))= 0)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- class_assignment_is_valid

FUNCTION acyclic_contract_relationship
	(relation : contract_relationship; relatives : SET [1:?] OF contract; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF contract_relationship;
 END_LOCAL
;
 IF  relation.relating_contract IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT'))| specific_relation IN TYPEOF(cont));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_contract_relationship(x [ i ], relatives + relation.relating_contract, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_contract_relationship

FUNCTION acyclic_event_occurrence_relationship
	(relation : event_occurrence_relationship; relatives : SET [1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF event_occurrence_relationship;
 END_LOCAL
;
 IF  relation.relating_event IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT'))| specific_relation IN TYPEOF(evnt));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_event_occurrence_relationship(x [ i ], relatives + relation.relating_event, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_event_occurrence_relationship

FUNCTION acyclic_time_interval_relationship
	(relation : time_interval_relationship; relatives : SET [1:?] OF time_interval; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF time_interval_relationship;
 END_LOCAL
;
 IF  relation.relating_time_interval IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL'))| specific_relation IN TYPEOF(ti));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_time_interval_relationship(x [ i ], relatives + relation.relating_time_interval, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_time_interval_relationship

FUNCTION leap_year
	(year : year_number) : BOOLEAN;
 IF((((year MOD  4)= 0)AND((year MOD  100)<> 0))OR((year MOD 400)= 0))THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- leap_year

FUNCTION valid_calendar_date
	(date : calendar_date) : LOGICAL;
 CASE date.month_component OF 1 : RETURN({ 1 <= date.day_component <= 31 });
 2 : BEGIN IF(leap_year(date.year_component))THEN RETURN({ 1 <= date.day_component <= 29 });
 ELSE RETURN({ 1 <= date.day_component <= 28 });
 END_IF;
 END;
 3 : RETURN({ 1 <= date.day_component <= 31 });
 4 : RETURN({ 1 <= date.day_component <= 30 });
 5 : RETURN({ 1 <= date.day_component <= 31 });
 6 : RETURN({ 1 <= date.day_component <= 30 });
 7 : RETURN({ 1 <= date.day_component <= 31 });
 8 : RETURN({ 1 <= date.day_component <= 31 });
 9 : RETURN({ 1 <= date.day_component <= 30 });
 10 : RETURN({ 1 <= date.day_component <= 31 });
 11 : RETURN({ 1 <= date.day_component <= 30 });
 12 : RETURN({ 1 <= date.day_component <= 31 });
 END_CASE;
 RETURN(FALSE);
 END_FUNCTION; -- valid_calendar_date

FUNCTION valid_time
	(time : local_time) : BOOLEAN;
 IF EXISTS(time.second_component)THEN RETURN(EXISTS(time.minute_component));
 ELSE RETURN(TRUE);
 END_IF;
 END_FUNCTION; -- valid_time

FUNCTION acyclic_document_relationship
	(relation : document_relationship; relatives : SET [1:?] OF document; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF document_relationship;
 END_LOCAL
;
 IF  relation.relating_document IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT'))| specific_relation IN TYPEOF(doc));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_document_relationship(x [ i ], relatives + relation.relating_document, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_document_relationship

FUNCTION acyclic_effectivity_relationship
	(relation : effectivity_relationship; relatives : SET [1:?] OF effectivity; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF effectivity_relationship;
 END_LOCAL
;
 IF  relation.relating_effectivity IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY'))| specific_relation IN TYPEOF(eff));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_effectivity_relationship(x [ i ], relatives + relation.relating_effectivity, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_effectivity_relationship

FUNCTION acyclic_experience_relationship
	(relation : experience_relationship; relatives : SET [0:?] OF experience; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF experience_relationship;
 END_LOCAL
;
 IF  relation.relating_experience IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE'))| specific_relation IN TYPEOF(expr));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_experience_relationship(x [ i ], relatives + relation.relating_experience, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_experience_relationship

FUNCTION acyclic_experience_type_relationship
	(relation : experience_type_relationship; relatives : SET [0:?] OF experience_type; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF experience_type_relationship;
 END_LOCAL
;
 IF  relation.relating_experience_type IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE'))| specific_relation IN TYPEOF(exptyp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_experience_type_relationship(x [ i ], relatives + relation.relating_experience_type, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_experience_type_relationship

FUNCTION value_range_wr1
	(agg : compound_item_definition) : BOOLEAN;
 BEGIN IF(SIZEOF(agg)= 2)AND((SIZEOF(QUERY(i1 <* agg |('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i1))))= 2)OR(SIZEOF(QUERY(i2 <* agg |('REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF(i2))))= 2))THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END;
 END_FUNCTION; -- value_range_wr1

FUNCTION value_range_wr2
	(agg : compound_item_definition) : BOOLEAN;
 BEGIN IF(SIZEOF(QUERY(i <* agg |(i.name = 'upper limit')))= 1)AND(SIZEOF(QUERY(i <* agg |(i.name = 'lower limit')))= 1)THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END;
 END_FUNCTION; -- value_range_wr2

FUNCTION value_range_wr3
	(agg : compound_item_definition) : BOOLEAN;
 BEGIN IF(SIZEOF(QUERY(i1 <* agg |('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i1))AND(SIZEOF(QUERY(i2 <* agg |('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i2))AND(i1 :<>: i2)AND(i1 \ measure_with_unit.unit_component :=: i2 \ measure_with_unit.unit_component)))= 1)))= 2)THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END;
 END_FUNCTION; -- value_range_wr3

FUNCTION acyclic_external_source_relationship
	(relation : external_source_relationship; relatives : SET [1:?] OF external_source; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF external_source_relationship;
 END_LOCAL
;
 IF  relation.relating_source IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE'))| specific_relation IN TYPEOF(es));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_external_source_relationship(x [ i ], relatives + relation.relating_source, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_external_source_relationship

FUNCTION acyclic_externally_defined_item_relationship
	(relation : externally_defined_item_relationship; relatives : SET [1:?] OF externally_defined_item; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF externally_defined_item_relationship;
 END_LOCAL
;
 IF  relation.relating_item IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM'))| specific_relation IN TYPEOF(edi));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_externally_defined_item_relationship(x [ i ], relatives + relation.relating_item, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_externally_defined_item_relationship

FUNCTION acyclic_set_replica
	(rep : geometric_set_replica; parent : geometric_set) : BOOLEAN;
 IF  NOT(('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_set_replica(rep, parent \ geometric_set_replica.parent_set));
 END_IF;
 END_FUNCTION; -- acyclic_set_replica

FUNCTION acyclic_solid_replica
	(rep : solid_replica; parent : solid_model) : BOOLEAN;
 IF  NOT(('GEOMETRY_SCHEMA.SOLID_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_solid_replica(rep, parent \ solid_replica.parent_solid));
 END_IF;
 END_FUNCTION; -- acyclic_solid_replica

FUNCTION build_transformed_set
	(tr : cartesian_transformation_operator; gset : geometric_set) : SET [0:?] OF geometric_set_select;
 LOCAL
 s : SET  [ 1 : ? ] OF  geometric_set_select := gset.elements;
 trset : SET [ 0 : ? ] OF geometric_set_select := [ ];
 END_LOCAL
;
 REPEAT j := 1 TO SIZEOF(s);
 IF('GEOMETRY_SCHEMA.CURVE' IN  TYPEOF(s [ j ]))THEN  trset := trset + dummy_gri || curve()|| curve_replica(s [ j ], tr);
 ELSE  IF('GEOMETRY_SCHEMA.POINT' IN  TYPEOF(s [ j ]))THEN  trset := trset + dummy_gri || point()|| point_replica(s [ j ], tr);
 ELSE IF('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s [ j ]))THEN trset := trset + dummy_gri || surface()|| surface_replica(s [ j ], tr || cartesian_transformation_operator_3d(?));
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 RETURN(trset);
 END_FUNCTION; -- build_transformed_set

FUNCTION constraints_geometry_shell_based_surface_model
	(m : shell_based_surface_model) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
 IF(NOT('TOPOLOGY_SCHEMA.OPEN_SHELL' IN  TYPEOF(m.sbsm_boundary [ j ]))AND(NOT('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary [ j ]))))THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- constraints_geometry_shell_based_surface_model

FUNCTION constraints_geometry_shell_based_wireframe_model
	(m : shell_based_wireframe_model) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
 IF(NOT('TOPOLOGY_SCHEMA.WIRE_SHELL' IN  TYPEOF(m.sbwm_boundary [ j ]))AND(NOT('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary [ j ]))))THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

FUNCTION msb_shells
	(brep : manifold_solid_brep) : SET [1:?] OF closed_shell;
 IF SIZEOF(QUERY(msbtype <* TYPEOF(brep)| msbtype LIKE '*BREP_WITH_VOIDS'))>= 1 THEN RETURN(brep \ brep_with_voids.voids + brep.outer);
 ELSE RETURN([ brep.outer ]);
 END_IF;
 END_FUNCTION; -- msb_shells

FUNCTION get_shape_aspect_property_definition_representations
	(s_a_instance : shape_aspect) : SET [0:?] OF property_definition_representation;
 LOCAL
 pd_set : SET  OF  property_definition := [ ];
 pdr_set : SET OF property_definition_representation := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(USEDIN(s_a_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set +(QUERY(pdr <* USEDIN(pd_set [ i ], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION')| 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_shape_aspect_property_definition_representations

FUNCTION valid_datum_target_parameters
	(pdf : placed_datum_target_feature) : BOOLEAN;
 LOCAL
 rep_set : SET  OF  representation := [ ];
 parameter_representations : SET OF  representation;
 END_LOCAL
;
 REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
 rep_set := rep_set + pdf.representation_associations [ i ].used_representation;
 END_REPEAT;
 parameter_representations := QUERY(rep <* rep_set |('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN  TYPEOF(rep)));
 IF(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'orientation')AND('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PLACEMENT' IN TYPEOF(i))))= 1)))<> 1)THEN RETURN(FALSE );
 END_IF;
 CASE pdf \ shape_aspect.description OF 'point' : RETURN(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(srwp.items)= 1)))= 1);
 'circle' : RETURN((SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(srwp.items)= 2)))= 1)AND(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target diameter')AND(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1));
 'line' : RETURN(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target length')AND(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1);
 'rectangle' : RETURN((SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(srwp.items)= 3)))= 1)AND(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target length')AND(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1)AND(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target width')AND(SIZEOF([ 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1));
 OTHERWISE : RETURN(FALSE);
 END_CASE;
 END_FUNCTION; -- valid_datum_target_parameters

FUNCTION above_plane
	(p1 : cartesian_point; p2 : cartesian_point; p3 : cartesian_point; p4 : cartesian_point) : REAL;
 LOCAL
 dir2, dir3, dir4 : direction := dummy_gri || direction([ 1.0, 0.0, 0.0 ]);
 val, mag : REAL;
 END_LOCAL
;
 IF(p1.dim <> 3)THEN RETURN(?);
 END_IF;
 REPEAT i := 1 TO 3;
 dir2.direction_ratios [ i ] := p2.coordinates [ i ] - p1.coordinates [ i ];
 dir3.direction_ratios [ i ] := p3.coordinates [ i ] - p1.coordinates [ i ];
 dir4.direction_ratios [ i ] := p4.coordinates [ i ] - p1.coordinates [ i ];
 mag := dir4.direction_ratios [ i ] * dir4.direction_ratios [ i ];
 END_REPEAT;
 mag := SQRT(mag);
 val := mag * dot_product(dir4, cross_product(dir2, dir3).orientation);
 RETURN(val);
 END_FUNCTION; -- above_plane

FUNCTION acyclic_curve_replica
	(rep : curve_replica; parent : curve) : BOOLEAN;
 IF  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CURVE_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_curve_replica(rep, parent \ curve_replica.parent_curve));
 END_IF;
 END_FUNCTION; -- acyclic_curve_replica

FUNCTION acyclic_point_replica
	(rep : point_replica; parent : point) : BOOLEAN;
 IF  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POINT_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_point_replica(rep, parent \ point_replica.parent_pt));
 END_IF;
 END_FUNCTION; -- acyclic_point_replica

FUNCTION acyclic_surface_replica
	(rep : surface_replica; parent : surface) : BOOLEAN;
 IF  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_surface_replica(rep, parent \ surface_replica.parent_surface));
 END_IF;
 END_FUNCTION; -- acyclic_surface_replica

FUNCTION associated_surface
	(arg : pcurve_or_surface) : surface;
 LOCAL
 surf : surface;
 END_LOCAL
;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN TYPEOF(arg)THEN surf := arg.basis_surface;
 ELSE surf := arg;
 END_IF;
 RETURN(surf);
 END_FUNCTION; -- associated_surface

FUNCTION base_axis
	(dim : INTEGER; axis1 : direction; axis2 : direction; axis3 : direction) : LIST [2:3] OF direction;
 LOCAL
 u : LIST [ 2 : 3 ] OF direction;
 factor : REAL;
 d1, d2 : direction;
 END_LOCAL
;
 IF(dim = 3)THEN  d1 := NVL(normalise(axis3), dummy_gri || direction([ 0.0, 0.0, 1.0 ]));
 d2 := first_proj_axis(d1, axis1);
 u := [ d2, second_proj_axis(d1, d2, axis2), d1 ];
 ELSE  IF  EXISTS(axis1)THEN  d1 := normalise(axis1);
 u := [ d1, orthogonal_complement(d1)];
 IF  EXISTS(axis2)THEN  factor := dot_product(axis2, u [ 2 ]);
 IF(factor < 0.0)THEN  u [ 2 ].direction_ratios [ 1 ] := - u [ 2 ].direction_ratios [ 1 ];
 u [ 2 ].direction_ratios [ 2 ] := - u [ 2 ].direction_ratios [ 2 ];
 END_IF ;
 END_IF ;
 ELSE  IF EXISTS(axis2)THEN d1 := normalise(axis2);
 u := [ orthogonal_complement(d1), d1 ];
 u [ 1 ].direction_ratios [ 1 ] := - u [ 1 ].direction_ratios [ 1 ];
 u [ 1 ].direction_ratios [ 2 ] := - u [ 1 ].direction_ratios [ 2 ];
 ELSE u := [ dummy_gri || direction([ 1.0, 0.0 ]), dummy_gri || direction([ 0.0, 1.0 ])];
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(u);
 END_FUNCTION; -- base_axis

FUNCTION build_2axes
	(ref_direction : direction) : LIST [2:2] OF direction;
 LOCAL
 d : direction := NVL(normalise(ref_direction), dummy_gri || direction([ 1.0, 0.0 ]));
 END_LOCAL
;
 RETURN([ d, orthogonal_complement(d)]);
 END_FUNCTION; -- build_2axes

FUNCTION build_axes
	(axis : direction; ref_direction : direction) : LIST [3:3] OF direction;
 LOCAL
 d1, d2 : direction;
 END_LOCAL
;
 d1 := NVL(normalise(axis), dummy_gri || direction([ 0.0, 0.0, 1.0 ]));
 d2 := first_proj_axis(d1, ref_direction);
 RETURN([ d2, normalise(cross_product(d1, d2)).orientation, d1 ]);
 END_FUNCTION; -- build_axes

FUNCTION constraints_composite_curve_on_surface
	(c : composite_curve_on_surface) : BOOLEAN;
 LOCAL
 n_segments : INTEGER := SIZEOF(c.segments);
 END_LOCAL
;
 REPEAT k := 1 TO n_segments;
 IF(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN  TYPEOF(c \ composite_curve.segments [ k ].parent_curve)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF(c \ composite_curve.segments [ k ].parent_curve)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c \ composite_curve.segments [ k ].parent_curve)))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- constraints_composite_curve_on_surface

FUNCTION constraints_param_b_spline
	(degree : INTEGER; up_knots : INTEGER; up_cp : INTEGER; knot_mult : LIST [0:?] OF INTEGER; knots : LIST [0:?] OF parameter_value) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 k, sum : INTEGER;
 END_LOCAL
;
 sum := knot_mult [ 1 ];
 REPEAT  i := 2 TO  up_knots;
 sum := sum + knot_mult [ i ];
 END_REPEAT ;
 IF(degree < 1)OR(up_knots < 2)OR(up_cp < degree)OR(sum <>(degree + up_cp + 2))THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 k := knot_mult [ 1 ];
 IF(k < 1)OR(k > degree + 1)THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 REPEAT i := 2 TO up_knots;
 IF(knot_mult [ i ] < 1)OR(knots [ i ] <= knots [ i - 1 ])THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 k := knot_mult [ i ];
 IF(i < up_knots)AND(k > degree)THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 IF(i = up_knots)AND(k > degree + 1)THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- constraints_param_b_spline

FUNCTION constraints_rectangular_composite_surface
	(s : rectangular_composite_surface) : BOOLEAN;
 REPEAT  i := 1 TO  s.n_u;
 REPEAT  j := 1 TO  s.n_v;
 IF  NOT(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.B_SPLINE_SURFACE' IN  TYPEOF(s.segments [ i ] [ j ].parent_surface))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.segments [ i ] [ j ].parent_surface)))THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  s.n_u - 1;
 REPEAT  j := 1 TO  s.n_v;
 IF  s.segments [ i ] [ j ].u_transition = discontinuous THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  s.n_u;
 REPEAT j := 1 TO s.n_v - 1;
 IF s.segments [ i ] [ j ].v_transition = discontinuous THEN RETURN(FALSE);
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- constraints_rectangular_composite_surface

FUNCTION cross_product
	(arg1 : direction; arg2 : direction) : vector;
 LOCAL
 mag : REAL ;
 res : direction;
 v1, v2 : LIST [ 3 : 3 ] OF REAL;
 result : vector;
 END_LOCAL
;
 IF(NOT  EXISTS(arg1)OR(arg1.dim = 2))OR(NOT EXISTS(arg2)OR(arg2.dim = 2))THEN  RETURN(?);
 ELSE  BEGIN v1 := normalise(arg1).direction_ratios;
 v2 := normalise(arg2).direction_ratios;
 res := dummy_gri || direction([(v1 [ 2 ] * v2 [ 3 ] - v1 [ 3 ] * v2 [ 2 ]),(v1 [ 3 ] * v2 [ 1 ] - v1 [ 1 ] * v2 [ 3 ]),(v1 [ 1 ] * v2 [ 2 ] - v1 [ 2 ] * v2 [ 1 ])]);
 mag := 0.0;
 REPEAT i := 1 TO 3;
 mag := mag + res.direction_ratios [ i ] * res.direction_ratios [ i ];
 END_REPEAT;
 IF(mag > 0.0)THEN result := dummy_gri || vector(res, SQRT(mag));
 ELSE result := dummy_gri || vector(arg1, 0.0);
 END_IF ;
 RETURN(result);
 END;
 END_IF;
 END_FUNCTION; -- cross_product

FUNCTION curve_weights_positive
	(b : rational_b_spline_curve) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT i := 0 TO b.upper_index_on_control_points;
 IF b.weights [ i ] <= 0.0 THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- curve_weights_positive

FUNCTION default_b_spline_curve_weights
	(up_cp : INTEGER) : ARRAY [0:??] OF REAL;
 RETURN([ 1 : up_cp + 1 ]);
 END_FUNCTION; -- default_b_spline_curve_weights

FUNCTION default_b_spline_knot_mult
	(degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST [2:?] OF INTEGER;
 LOCAL
 knot_mult : LIST [ 1 : up_knots ] OF INTEGER;
 END_LOCAL
;
 IF  uniform = uniform_knots THEN  knot_mult := [ 1 : up_knots ];
 ELSE  IF  uniform = quasi_uniform_knots THEN  knot_mult := [ 1 : up_knots ];
 knot_mult [ 1 ] := degree + 1;
 knot_mult [ up_knots ] := degree + 1;
 ELSE  IF uniform = piecewise_bezier_knots THEN knot_mult := [ degree : up_knots ];
 knot_mult [ 1 ] := degree + 1;
 knot_mult [ up_knots ] := degree + 1;
 ELSE knot_mult := [ 0 : up_knots ];
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(knot_mult);
 END_FUNCTION; -- default_b_spline_knot_mult

FUNCTION default_b_spline_knots
	(degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST [2:?] OF parameter_value;
 LOCAL
 knots : LIST [ 1 : up_knots ] OF parameter_value := [ 0 : up_knots ];
 ishift : INTEGER := 1;
 END_LOCAL
;
 IF(uniform = uniform_knots)THEN  ishift := degree + 1;
 END_IF ;
 IF(uniform = uniform_knots)OR(uniform = quasi_uniform_knots)OR(uniform = piecewise_bezier_knots)THEN REPEAT i := 1 TO up_knots;
 knots [ i ] := i - ishift;
 END_REPEAT;
 END_IF;
 RETURN(knots);
 END_FUNCTION; -- default_b_spline_knots

FUNCTION default_b_spline_surface_weights
	(u_upper : INTEGER; v_upper : INTEGER) : ARRAY [0:??] OF ARRAY [0:??] OF REAL;
 RETURN([ [ 1 : v_upper + 1 ] : u_upper + 1 ]);
 END_FUNCTION; -- default_b_spline_surface_weights

FUNCTION dimension_of
	(item : geometric_representation_item) : dimension_count;
 LOCAL
 x : SET OF representation;
 y : representation_context;
 dim : dimension_count;
 END_LOCAL
;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(item)THEN  dim := SIZEOF(item \ cartesian_point.coordinates);
 RETURN(dim);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DIRECTION' IN  TYPEOF(item)THEN  dim := SIZEOF(item \ direction.direction_ratios);
 RETURN(dim);
 END_IF ;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN TYPEOF(item)THEN dim := SIZEOF(item \ vector.orientation \ direction.direction_ratios);
 RETURN(dim);
 END_IF;
 x := using_representations(item);
 y := x [ 1 ].context_of_items;
 dim := y \ geometric_representation_context.coordinate_space_dimension;
 RETURN(dim);
 END_FUNCTION; -- dimension_of

FUNCTION dot_product
	(arg1 : direction; arg2 : direction) : REAL;
 LOCAL
 scalar : REAL;
 vec1, vec2 : direction;
 ndim : INTEGER;
 END_LOCAL
;
 IF  NOT  EXISTS(arg1)OR NOT EXISTS(arg2)THEN  scalar := ?;
 ELSE  IF(arg1.dim <> arg2.dim)THEN scalar := ?;
 ELSE BEGIN vec1 := normalise(arg1);
 vec2 := normalise(arg2);
 ndim := arg1.dim;
 scalar := 0.0;
 REPEAT i := 1 TO ndim;
 scalar := scalar + vec1.direction_ratios [ i ] * vec2.direction_ratios [ i ];
 END_REPEAT;
 END;
 END_IF ;
 END_IF;
 RETURN(scalar);
 END_FUNCTION; -- dot_product

FUNCTION first_proj_axis
	(z_axis : direction; arg : direction) : direction;
 LOCAL
 x_axis : direction;
 v : direction;
 z : direction;
 x_vec : vector;
 END_LOCAL
;
 IF(NOT  EXISTS(z_axis))THEN  RETURN(?);
 ELSE  z := normalise(z_axis);
 IF  NOT EXISTS(arg)THEN  IF((z.direction_ratios <> [ 1.0, 0.0, 0.0 ])AND(z.direction_ratios <> [ - 1.0, 0.0, 0.0 ]))THEN  v := dummy_gri || direction([ 1.0, 0.0, 0.0 ]);
 ELSE  v := dummy_gri || direction([ 0.0, 1.0, 0.0 ]);
 END_IF ;
 ELSE  IF(arg.dim <> 3)THEN  RETURN(?);
 END_IF ;
 IF((cross_product(arg, z).magnitude)= 0.0)THEN RETURN(?);
 ELSE v := normalise(arg);
 END_IF ;
 END_IF ;
 x_vec := scalar_times_vector(dot_product(v, z), z);
 x_axis := vector_difference(v, x_vec).orientation;
 x_axis := normalise(x_axis);
 END_IF;
 RETURN(x_axis);
 END_FUNCTION; -- first_proj_axis

FUNCTION get_basis_surface
	(c : curve_on_surface) : SET [0:2] OF surface;
 LOCAL
 surfs : SET [ 0 : 2 ] OF surface;
 n : INTEGER;
 END_LOCAL
;
 surfs := [ ];
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PCURVE' IN  TYPEOF(c)THEN  surfs := [ c \ pcurve.basis_surface ];
 ELSE IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF(c)THEN  n := SIZEOF(c \ surface_curve.associated_geometry);
 REPEAT  i := 1 TO  n;
 surfs := surfs + associated_surface(c \ surface_curve.associated_geometry [ i ]);
 END_REPEAT ;
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)THEN  n := SIZEOF(c \ composite_curve.segments);
 surfs := get_basis_surface(c \ composite_curve.segments [ 1 ].parent_curve);
 IF n > 1 THEN REPEAT i := 2 TO n;
 surfs := surfs * get_basis_surface(c \ composite_curve.segments [ i ].parent_curve);
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(surfs);
 END_FUNCTION; -- get_basis_surface

FUNCTION list_to_array
	(lis : LIST [0:?] OF GENERIC; low : INTEGER; u : INTEGER) : ARRAY [??:??] OF GENERIC;
 LOCAL
 n : INTEGER;
 res : ARRAY [ low : u ] OF GENERIC : T;
 END_LOCAL
;
 n := SIZEOF(lis);
 IF(n <>(u - low + 1))THEN RETURN(?);
 ELSE res := [ lis [ 1 ] : n ];
 REPEAT i := 2 TO n;
 res [ low + i - 1 ] := lis [ i ];
 END_REPEAT;
 RETURN(res);
 END_IF;
 END_FUNCTION; -- list_to_array

FUNCTION make_array_of_array
	(lis : LIST [1:?] OF LIST [1:?] OF GENERIC; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER) : ARRAY [??:??] OF ARRAY [??:??] OF GENERIC;
 LOCAL
 res : ARRAY  [ low1 : u1 ] OF  ARRAY [ low2 : u2 ] OF GENERIC : T;
 END_LOCAL
;
 IF(u1 - low1 + 1)<> SIZEOF(lis)THEN  RETURN(?);
 END_IF ;
 IF(u2 - low2 + 1)<> SIZEOF(lis [ 1 ])THEN  RETURN(?);
 END_IF ;
 res := [ list_to_array(lis [ 1 ], low2, u2):(u1 - low1 + 1)];
 REPEAT i := 2 TO HIINDEX(lis);
 IF(u2 - low2 + 1)<> SIZEOF(lis [ i ])THEN RETURN(?);
 END_IF;
 res [ low1 + i - 1 ] := list_to_array(lis [ i ], low2, u2);
 END_REPEAT;
 RETURN(res);
 END_FUNCTION; -- make_array_of_array

FUNCTION make_array_of_array_of_array
	(lis : LIST [1:?] OF LIST [1:?] OF LIST [1:?] OF GENERIC; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER; low3 : INTEGER; u3 : INTEGER) : ARRAY [??:??] OF ARRAY [??:??] OF ARRAY [??:??] OF GENERIC;
 LOCAL
 res : ARRAY  [ low1 : u1 ] OF  ARRAY  [ low2 : u2 ] OF  ARRAY [ low3 : u3 ] OF GENERIC : T;
 END_LOCAL
;
 IF(u1 - low1 + 1)<> SIZEOF(lis)THEN  RETURN(?);
 END_IF ;
 IF(u2 - low2 + 1)<> SIZEOF(lis [ 1 ])THEN  RETURN(?);
 END_IF ;
 res := [ make_array_of_array(lis [ 1 ], low2, u2, low3, u3):(u1 - low1 + 1)];
 REPEAT i := 2 TO HIINDEX(lis);
 IF(u2 - low2 + 1)<> SIZEOF(lis [ i ])THEN RETURN(?);
 END_IF;
 res [ low1 + i - 1 ] := make_array_of_array(lis [ i ], low2, u2, low3, u3);
 END_REPEAT;
 RETURN(res);
 END_FUNCTION; -- make_array_of_array_of_array

FUNCTION normalise
	(arg : vector_or_direction) : vector_or_direction;
 LOCAL
 ndim : INTEGER;
 v : direction;
 result : vector_or_direction;
 vec : vector;
 mag : REAL;
 END_LOCAL
;
 IF  NOT EXISTS(arg)THEN  result := ?;
 ELSE  ndim := arg.dim;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN  TYPEOF(arg)THEN  BEGIN v := dummy_gri || direction(arg.orientation.direction_ratios);
 IF  arg.magnitude = 0.0 THEN  RETURN(?);
 ELSE  vec := dummy_gri || vector(v, 1.0);
 END_IF ;
 END;
 ELSE  v := dummy_gri || direction(arg.direction_ratios);
 END_IF ;
 mag := 0.0;
 REPEAT  i := 1 TO  ndim;
 mag := mag + v.direction_ratios [ i ] * v.direction_ratios [ i ];
 END_REPEAT ;
 IF  mag > 0.0 THEN  mag := SQRT(mag);
 REPEAT i := 1 TO ndim;
 v.direction_ratios [ i ] := v.direction_ratios [ i ] / mag;
 END_REPEAT;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN TYPEOF(arg)THEN vec.orientation := v;
 result := vec;
 ELSE  result := v;
 END_IF ;
 ELSE RETURN(?);
 END_IF ;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- normalise

FUNCTION orthogonal_complement
	(vec : direction) : direction;
 LOCAL
 result : direction;
 END_LOCAL
;
 IF(vec.dim <> 2)OR NOT EXISTS(vec)THEN RETURN(?);
 ELSE result := dummy_gri || direction([ - vec.direction_ratios [ 2 ], vec.direction_ratios [ 1 ] ]);
 RETURN(result);
 END_IF;
 END_FUNCTION; -- orthogonal_complement

FUNCTION same_side
	(plane_pts : LIST [3:3] OF cartesian_point; test_points : LIST [2:?] OF cartesian_point) : BOOLEAN;
 LOCAL
 val1, val2 : REAL;
 n : INTEGER;
 END_LOCAL
;
 IF(plane_pts [ 1 ].dim = 2)OR(test_points [ 1 ].dim = 2)THEN  RETURN(?);
 END_IF ;
 n := SIZEOF(test_points);
 val1 := above_plane(plane_pts [ 1 ], plane_pts [ 2 ], plane_pts [ 3 ], test_points [ 1 ]);
 REPEAT i := 2 TO n;
 val2 := above_plane(plane_pts [ 1 ], plane_pts [ 2 ], plane_pts [ 3 ], test_points [ i ]);
 IF(val1 * val2 <= 0.0)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- same_side

FUNCTION scalar_times_vector
	(scalar : REAL; vec : vector_or_direction) : vector;
 LOCAL
 v : direction;
 mag : REAL;
 result : vector;
 END_LOCAL
;
 IF  NOT  EXISTS(scalar)OR NOT EXISTS(vec)THEN  RETURN(?);
 ELSE  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN TYPEOF(vec)THEN  v := dummy_gri || direction(vec.orientation.direction_ratios);
 mag := scalar * vec.magnitude;
 ELSE v := dummy_gri || direction(vec.direction_ratios);
 mag := scalar;
 END_IF ;
 IF(mag < 0.0)THEN REPEAT i := 1 TO SIZEOF(v.direction_ratios);
 v.direction_ratios [ i ] := - v.direction_ratios [ i ];
 END_REPEAT;
 mag := - mag;
 END_IF ;
 result := dummy_gri || vector(normalise(v), mag);
 END_IF;
 RETURN(result);
 END_FUNCTION; -- scalar_times_vector

FUNCTION second_proj_axis
	(z_axis : direction; x_axis : direction; arg : direction) : direction;
 LOCAL
 y_axis : vector;
 v : direction;
 temp : vector;
 END_LOCAL
;
 IF NOT EXISTS(arg)THEN v := dummy_gri || direction([ 0.0, 1.0, 0.0 ]);
 ELSE v := arg;
 END_IF;
 temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
 y_axis := vector_difference(v, temp);
 temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
 y_axis := vector_difference(y_axis, temp);
 y_axis := normalise(y_axis);
 RETURN(y_axis.orientation);
 END_FUNCTION; -- second_proj_axis

FUNCTION surface_weights_positive
	(b : rational_b_spline_surface) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 0 TO  b.u_upper;
 REPEAT j := 0 TO b.v_upper;
 IF(b.weights [ i ] [ j ] <= 0.0)THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- surface_weights_positive

FUNCTION vector_difference
	(arg1 : vector_or_direction; arg2 : vector_or_direction) : vector;
 LOCAL
 result : vector;
 res, vec1, vec2 : direction;
 mag, mag1, mag2 : REAL;
 ndim : INTEGER;
 END_LOCAL
;
 IF((NOT  EXISTS(arg1))OR(NOT EXISTS(arg2)))OR(arg1.dim <> arg2.dim)THEN  RETURN(?);
 ELSE  BEGIN IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN  mag1 := arg1.magnitude;
 vec1 := arg1.orientation;
 ELSE  mag1 := 1.0;
 vec1 := arg1;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN  mag2 := arg2.magnitude;
 vec2 := arg2.orientation;
 ELSE  mag2 := 1.0;
 vec2 := arg2;
 END_IF ;
 vec1 := normalise(vec1);
 vec2 := normalise(vec2);
 ndim := SIZEOF(vec1.direction_ratios);
 mag := 0.0;
 res := dummy_gri || direction(vec1.direction_ratios);
 REPEAT i := 1 TO ndim;
 res.direction_ratios [ i ] := mag1 * vec1.direction_ratios [ i ] + mag2 * vec2.direction_ratios [ i ];
 mag := mag +(res.direction_ratios [ i ] * res.direction_ratios [ i ]);
 END_REPEAT;
 IF(mag > 0.0)THEN result := dummy_gri || vector(res, SQRT(mag));
 ELSE result := dummy_gri || vector(vec1, 0.0);
 END_IF ;
 END;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- vector_difference

FUNCTION vector_sum
	(arg1 : vector_or_direction; arg2 : vector_or_direction) : vector;
 LOCAL
 result : vector;
 res, vec1, vec2 : direction;
 mag, mag1, mag2 : REAL;
 ndim : INTEGER;
 END_LOCAL
;
 IF((NOT  EXISTS(arg1))OR(NOT EXISTS(arg2)))OR(arg1.dim <> arg2.dim)THEN  RETURN(?);
 ELSE  BEGIN IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN  mag1 := arg1.magnitude;
 vec1 := arg1.orientation;
 ELSE  mag1 := 1.0;
 vec1 := arg1;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN  mag2 := arg2.magnitude;
 vec2 := arg2.orientation;
 ELSE  mag2 := 1.0;
 vec2 := arg2;
 END_IF ;
 vec1 := normalise(vec1);
 vec2 := normalise(vec2);
 ndim := SIZEOF(vec1.direction_ratios);
 mag := 0.0;
 res := dummy_gri || direction(vec1.direction_ratios);
 REPEAT i := 1 TO ndim;
 res.direction_ratios [ i ] := mag1 * vec1.direction_ratios [ i ] + mag2 * vec2.direction_ratios [ i ];
 mag := mag +(res.direction_ratios [ i ] * res.direction_ratios [ i ]);
 END_REPEAT;
 IF(mag > 0.0)THEN result := dummy_gri || vector(res, SQRT(mag));
 ELSE result := dummy_gri || vector(vec1, 0.0);
 END_IF ;
 END;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- vector_sum

FUNCTION volume_weights_positive
	(b : rational_b_spline_volume) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 0 TO  b.u_upper;
 REPEAT  j := 0 TO  b.v_upper;
 REPEAT k := 0 TO b.w_upper;
 IF(b.weights [ i ] [ j ] [ k ] <= 0.0)THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- volume_weights_positive

FUNCTION acyclic_group_relationship
	(relation : group_relationship; relatives : SET [1:?] OF group; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF group_relationship;
 END_LOCAL
;
 IF  relation.relating_group IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP'))| specific_relation IN TYPEOF(grp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_group_relationship(x [ i ], relatives + relation.relating_group, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_group_relationship

FUNCTION is_int_expr
	(arg : numeric_expression) : BOOLEAN;
 LOCAL
 i : INTEGER;
 END_LOCAL
;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INT_LITERAL' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REAL_LITERAL' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INT_NUMERIC_VARIABLE' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REAL_NUMERIC_VARIABLE' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ABS_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(is_int_expr(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MINUS_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(is_int_expr(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ASIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ACOS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ATAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EXP_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LOG_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LOG2_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LOG10_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SQUARE_ROOT_FUNCTION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PLUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MULT_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAXIMUM_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MINIMUM_FUNCTION' IN  TYPEOF(arg))THEN  REPEAT i := 1 TO SIZEOF(arg \ multiple_arity_numeric_expression.operands);
 IF  NOT is_int_expr(arg \ multiple_arity_numeric_expression.operands [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE );
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MINUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POWER_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(is_int_expr(arg \ binary_numeric_expression.operands [ 1 ])AND is_int_expr(arg \ binary_numeric_expression.operands [ 2 ]));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DIV_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MOD_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SLASH_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VALUE_FUNCTION' IN  TYPEOF(arg)THEN  IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INT_VALUE_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 ELSE RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INTEGER_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REAL_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)THEN RETURN(FALSE );
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- is_int_expr

FUNCTION is_sql_mappable
	(arg : expression) : BOOLEAN;
 LOCAL
 i : INTEGER;
 END_LOCAL
;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SIMPLE_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MINUS_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ABS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ASIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ACOS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ATAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EXP_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LOG_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LOG2_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LOG10_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SQUARE_ROOT_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VALUE_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_FUNCTION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PLUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MULT_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAXIMUM_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MINIMUM_FUNCTION' IN  TYPEOF(arg))THEN  REPEAT  i := 1 TO  SIZEOF(arg \ multiple_arity_numeric_expression.operands);
 IF  NOT  is_SQL_mappable(arg \ multiple_arity_numeric_expression.operands [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(TRUE );
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MINUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SLASH_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(is_SQL_mappable(arg \ binary_numeric_expression.operands [ 1 ])AND  is_SQL_mappable(arg \ binary_numeric_expression.operands [ 2 ]));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DIV_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MOD_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POWER_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NOT_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ UNARY_GENERIC_EXPRESSION.OPERAND));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ODD_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.XOR_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AND_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OR_EXPRESSION' IN  TYPEOF(arg))THEN  REPEAT i := 1 TO SIZEOF(arg \ MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
 IF  NOT is_SQL_mappable(arg \ MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EQUALS_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ BINARY_GENERIC_EXPRESSION.OPERANDS [ 1 ])AND  is_SQL_mappable(arg \ BINARY_GENERIC_EXPRESSION.OPERANDS [ 2 ]));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPARISON_EQUAL' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPARISON_GREATER' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPARISON_GREATER_EQUAL' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPARISON_LESS' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPARISON_LESS_EQUAL' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPARISON_NOT_EQUAL' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LIKE_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(is_SQL_mappable(arg \ COMPARISON_EXPRESSION.OPERANDS [ 1 ])AND  is_SQL_mappable(arg \ COMPARISON_EXPRESSION.OPERANDS [ 2 ]));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INTERVAL_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ interval_expression.interval_low)AND  is_SQL_mappable(arg \ interval_expression.interval_high)AND is_SQL_mappable(arg \ interval_expression.interval_item));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.NUMERIC_DEFINED_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.STRING_DEFINED_FUNCTION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SIMPLE_STRING_EXPRESSION' IN  TYPEOF(ARG)THEN  RETURN(TRUE);
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INDEX_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SUBSTRING_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CONCAT_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FORMAT_FUNCTION' IN TYPEOF(arg))THEN RETURN(FALSE );
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- is_SQL_mappable

FUNCTION used_functions
	(arg : expression) : SET [0:?] OF defined_function;
 LOCAL
 result : SET OF defined_function := [ ];
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DEFINED_FUNCTION' IN  TYPEOF(arg))THEN  RETURN([ arg ]);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.UNARY_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BINARY_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ binary_numeric_expression.operands [ 1 ])+ used_functions(arg \ binary_numeric_expression.operands [ 2 ]));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  REPEAT  i := 1 TO  SIZEOF(arg \ multiple_arity_numeric_expression.operands);
 result := result + used_functions(arg \ multiple_arity_numeric_expression.operands [ i ]);
 END_REPEAT ;
 RETURN(result);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.UNARY_GENERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ unary_generic_expression.operand));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BINARY_BOOLEAN_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ binary_generic_expression.operands [ 1 ])+ used_functions(arg \ binary_generic_expression.operands [ 2 ]));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' IN  TYPEOF(arg)THEN  REPEAT  i := 1 TO  SIZEOF(arg \ multiple_arity_Boolean_expression.operands);
 result := result + used_functions(arg \ multiple_arity_Boolean_expression.operands [ i ]);
 END_REPEAT ;
 RETURN(result);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.COMPARISON_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ comparison_expression.operands [ 1 ])+ used_functions(arg \ comparison_expression.operands [ 2 ]));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INTERVAL_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ interval_expression.interval_low)+ used_functions(arg \ interval_expression.interval_high)+ used_functions(arg \ interval_expression.interval_item));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.INDEX_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ index_expression.operand)+ used_functions(arg \ index_expression.index));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SUBSTRING_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ substring_expression.operand)+ used_functions(arg \ substring_expression.index1)+ used_functions(arg \ substring_expression.index2));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CONCAT_EXPRESSION' IN  TYPEOF(arg)THEN  REPEAT i := 1 TO SIZEOF(arg \ concat_expression.operands);
 result := result + used_functions(arg \ concat_expression.operands [ i ]);
 END_REPEAT;
 RETURN(result);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FORMAT_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ format_function.value_to_format)+ used_functions(arg \ format_function.format_string));
 END_IF ;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LIKE_EXPRESSION' IN TYPEOF(arg)THEN RETURN(used_functions(arg \ like_expression.operands [ 1 ])+ used_functions(arg \ like_expression.operands [ 2 ]));
 END_IF;
 RETURN([ ]);
 END_FUNCTION; -- used_functions

FUNCTION acyclic
	(arg1 : generic_expression; arg2 : SET [0:?] OF generic_expression) : BOOLEAN;
 LOCAL
 result : BOOLEAN;
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SIMPLE_GENERIC_EXPRESSION' IN  TYPEOF(arg1))THEN  RETURN(TRUE );
 END_IF ;
 IF  arg1 IN  arg2 THEN  RETURN(FALSE);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.UNARY_GENERIC_EXPRESSION' IN  TYPEOF(arg1)THEN  RETURN(acyclic(arg1 \ unary_generic_expression.operand, arg2 + [ arg1 ]));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BINARY_GENERIC_EXPRESSION' IN  TYPEOF(arg1)THEN  RETURN(acyclic(arg1 \ binary_generic_expression.operands [ 1 ], arg2 + [ arg1 ])AND  acyclic(arg1 \ binary_generic_expression.operands [ 2 ], arg2 + [ arg1 ]));
 END_IF ;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg1)THEN result := TRUE;
 REPEAT i := 1 TO SIZEOF(arg1 \ multiple_arity_generic_expression.operands);
 result := result AND acyclic(arg1 \ multiple_arity_generic_expression.operands [ i ], arg2 + [ arg1 ]);
 END_REPEAT;
 RETURN(result);
 END_IF;
 END_FUNCTION; -- acyclic

FUNCTION is_acyclic
	(arg : generic_expression) : BOOLEAN;
 RETURN(acyclic(arg, [ ]));
 END_FUNCTION; -- is_acyclic

FUNCTION used_variables
	(arg : generic_expression) : SET [0:?] OF generic_variable;
 LOCAL
 result : SET OF generic_variable := [ ];
 END_LOCAL
;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.GENERIC_VARIABLE' IN  TYPEOF(arg)THEN  RETURN([ arg ]);
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.UNARY_GENERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_variables(arg \ unary_generic_expression.operand));
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.BINARY_GENERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_variables(arg \ binary_generic_expression.operands [ 1 ])+ used_variables(arg \ binary_generic_expression.operands [ 2 ]));
 END_IF ;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg)THEN REPEAT i := 1 TO SIZEOF(arg \ multiple_arity_generic_expression.operands);
 result := result + used_variables(arg \ multiple_arity_generic_expression.operands [ i ]);
 END_REPEAT;
 RETURN(result);
 END_IF;
 RETURN([ ]);
 END_FUNCTION; -- used_variables

FUNCTION acyclic_location_relationship
	(relation : location_relationship; relatives : SET [0:?] OF location; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF location_relationship;
 END_LOCAL
;
 IF  relation.relating_location IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION'))| specific_relation IN TYPEOF(lctn));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_location_relationship(x [ i ], relatives + relation.relating_location, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_location_relationship

FUNCTION acyclic_identification_assignment_relationship
	(relation : identification_assignment_relationship; relatives : SET [1:?] OF identification_assignment; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF identification_assignment_relationship;
 END_LOCAL
;
 IF  relation.relating_identification_assignment IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT'))| specific_relation IN TYPEOF(ia));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_identification_assignment_relationship(x [ i ], relatives + relation.relating_identification_assignment, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_identification_assignment_relationship

FUNCTION acyclic_property_definition_relationship
	(relation : property_definition_relationship; relatives : SET [1:?] OF property_definition; specific_relation : STRING) : LOGICAL;
 LOCAL
 x : SET OF property_definition_relationship;
 END_LOCAL
;
 IF  relation.relating_property_definition IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_property_definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.' + 'RELATED_PROPERTY_DEFINITION'))| specific_relation IN TYPEOF(pd));
 REPEAT I := 1 TO HIINDEX(x);
 IF NOT acyclic_property_definition_relationship(x [ i ], relatives + relation.relating_property_definition, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_property_definition_relationship

FUNCTION all_members_of_es
	(sv : SET [0:?] OF maths_value; es : elementary_space_enumerators) : LOGICAL;
 LOCAL
 v : maths_value;
 key_type : STRING  := '';
 types : SET OF  STRING;
 ge : generic_expression;
 cum : LOGICAL := TRUE ;
 vspc : maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(sv)OR NOT  EXISTS(es)THEN  RETURN(FALSE );
 END_IF ;
 CASE es OF es_numbers : key_type := 'NUMBER';
 es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
 es_reals : key_type := 'REAL';
 es_integers : key_type := 'INTEGER';
 es_logicals : key_type := 'LOGICAL';
 es_booleans : key_type := 'BOOLEAN';
 es_strings : key_type := 'STRING';
 es_binarys : key_type := 'BINARY';
 es_maths_spaces : key_type := 'MATHS_SPACE';
 es_maths_functions : key_type := 'MATHS_FUNCTION';
 es_generics : RETURN(TRUE);
 END_CASE;
 REPEAT i := 1 TO SIZEOF(sv);
 IF  NOT  EXISTS(sv [ i ])THEN  RETURN(FALSE );
 END_IF ;
 v := simplify_maths_value(sv [ i ]);
 types := stripped_typeof(v);
 IF  key_type IN  types THEN  SKIP ;
 END_IF ;
 IF(es = es_numbers)AND('COMPLEX_NUMBER_LITERAL' IN types)THEN  SKIP;
 END_IF ;
 IF  SIZEOF(base_types * types)> 0 THEN  RETURN(FALSE );
 END_IF ;
 ge := v;
 IF  has_values_space(ge)THEN  vspc := values_space_of(ge);
 IF  NOT  subspace_of_es(vspc, es)THEN  IF  NOT compatible_spaces(vspc, make_elementary_space(es))THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END_IF ;
 ELSE cum := UNKNOWN;
 END_IF ;
 IF cum = FALSE  THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(cum);
 END_FUNCTION; -- all_members_of_es

FUNCTION angle
	(a : REAL) : REAL;
 REPEAT  WHILE  a > PI ;
 a := a - 2.0 * PI ;
 END_REPEAT ;
 REPEAT WHILE a <= - PI ;
 a := a + 2.0 * PI;
 END_REPEAT;
 RETURN(a);
 END_FUNCTION; -- angle

FUNCTION angle2
	(a : REAL) : REAL;
 REPEAT  WHILE  a > PI ;
 a := a - 2.0 * PI ;
 END_REPEAT ;
 REPEAT WHILE a <= - PI ;
 a := a + 2.0 * PI;
 END_REPEAT;
 RETURN(a);
 END_FUNCTION; -- angle2

FUNCTION any_space_satisfies
	(sc : space_constraint_type; spc : maths_space) : BOOLEAN;
 LOCAL
 spc_id : elementary_space_enumerators;
 END_LOCAL
;
 IF(sc = sc_equal)OR  NOT('ELEMENTARY_SPACE' IN stripped_typeof(spc))THEN  RETURN(FALSE);
 END_IF ;
 spc_id := spc \ elementary_space.space_id;
 IF  sc = sc_subspace THEN  RETURN(bool(spc_id = es_generics));
 END_IF ;
 IF sc = sc_member THEN RETURN(bool((spc_id = es_generics)OR(spc_id = es_maths_spaces)));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- any_space_satisfies

FUNCTION assoc_product_space
	(ts1 : tuple_space; ts2 : tuple_space) : tuple_space;
 LOCAL
 types1 : SET  OF  STRING  := stripped_typeof(ts1);
 types2 : SET OF  STRING := stripped_typeof(ts2);
 up1, up2 : uniform_product_space := make_uniform_product_space(the_reals, 1);
 lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
 et1, et2, ets : extended_tuple_space := the_tuples;
 use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
 factors : LIST OF maths_space := [ ];
 tspace : tuple_space;
 END_LOCAL
;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types1 THEN  up1 := ts1;
 use_up1 := TRUE ;
 use_lp1 := FALSE ;
 ELSE  IF  'LISTED_PRODUCT_SPACE' IN  types1 THEN  lp1 := ts1;
 use_up1 := FALSE ;
 use_lp1 := TRUE ;
 ELSE  IF  NOT('EXTENDED_TUPLE_SPACE' IN  types1)THEN  RETURN(?);
 END_IF ;
 et1 := ts1;
 use_up1 := FALSE ;
 use_lp1 := FALSE ;
 END_IF ;
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types2 THEN  up2 := ts2;
 use_up2 := TRUE ;
 use_lp2 := FALSE ;
 ELSE  IF  'LISTED_PRODUCT_SPACE' IN  types2 THEN  lp2 := ts2;
 use_up2 := FALSE ;
 use_lp2 := TRUE;
 ELSE  IF  NOT('EXTENDED_TUPLE_SPACE' IN types2)THEN  RETURN(?);
 END_IF ;
 et2 := ts2;
 use_up2 := FALSE ;
 use_lp2 := FALSE;
 END_IF ;
 END_IF ;
 IF  use_up1 THEN  IF  use_up2 THEN  IF  up1.base = up2.base THEN  tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
 ELSE  factors := [ up1.base : up1.exponent, up2.base : up2.exponent ];
 tspace := make_listed_product_space(factors);
 END_IF ;
 ELSE  IF  use_lp2 THEN  factors := [ up1.base : up1.exponent ];
 factors := factors + lp2.factors;
 tspace := make_listed_product_space(factors);
 ELSE  tspace := assoc_product_space(up1, et2.base);
 tspace := make_extended_tuple_space(tspace, et2.extender);
 END_IF ;
 END_IF ;
 ELSE  IF  use_lp1 THEN  IF  use_up2 THEN  factors := [ up2.base : up2.exponent ];
 factors := lp1.factors + factors;
 tspace := make_listed_product_space(factors);
 ELSE  IF  use_lp2 THEN  tspace := make_listed_product_space(lp1.factors + lp2.factors);
 ELSE  tspace := assoc_product_space(lp1, et2.base);
 tspace := make_extended_tuple_space(tspace, et2.extender);
 END_IF ;
 END_IF ;
 ELSE  IF  use_up2 THEN  IF  et1.extender = up2.base THEN  tspace := assoc_product_space(et1.base, up2);
 tspace := make_extended_tuple_space(tspace, et1.extender);
 ELSE  RETURN(?);
 END_IF ;
 ELSE  IF  use_lp2 THEN  factors := lp2.factors;
 REPEAT i := 1 TO SIZEOF(factors);
 IF  et1.extender <> factors [ i ] THEN  RETURN(?);
 END_IF ;
 END_REPEAT;
 tspace := assoc_product_space(et1.base, lp2);
 tspace := make_extended_tuple_space(tspace, et1.extender);
 ELSE  IF et1.extender = et2.extender THEN tspace := assoc_product_space(et1, et2.base);
 ELSE RETURN(?);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(tspace);
 END_FUNCTION; -- assoc_product_space

FUNCTION atan2
	(y : REAL; x : REAL) : REAL;
 LOCAL
 r : REAL;
 END_LOCAL
;
 IF(y = 0.0)AND(x = 0.0)THEN  RETURN(?);
 END_IF ;
 r := ATAN(y, x);
 IF  x < 0.0 THEN  IF y < 0.0 THEN r := r - PI ;
 ELSE r := r + PI;
 END_IF ;
 END_IF;
 RETURN(r);
 END_FUNCTION; -- atan2

FUNCTION bool
	(lgcl : LOGICAL) : BOOLEAN;
 IF  NOT EXISTS(lgcl)THEN  RETURN(FALSE );
 END_IF ;
 IF lgcl <> TRUE  THEN RETURN(FALSE);
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- bool

FUNCTION check_sparse_index_domain
	(idxdom : tuple_space; base : zero_or_one; shape : LIST [1:?] OF positive_integer; order : ordering_type) : BOOLEAN;
 LOCAL
 mthspc : maths_space;
 interval : finite_integer_interval;
 i : INTEGER;
 END_LOCAL
;
 mthspc := factor1(idxdom);
 interval := mthspc;
 IF order = by_rows THEN i := 1;
 ELSE i := 2;
 END_IF;
 RETURN(bool((interval.min <= base)AND(interval.max >= base + shape [ i ])));
 END_FUNCTION; -- check_sparse_index_domain

FUNCTION check_sparse_index_to_loc
	(index_range : tuple_space; loc_domain : tuple_space) : BOOLEAN;
 LOCAL
 temp : maths_space;
 idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
 END_LOCAL
;
 temp := factor1(index_range);
 IF(schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(temp)THEN  temp := factor1(temp);
 END_IF ;
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  TYPEOF(temp))THEN  RETURN(FALSE );
 END_IF ;
 idx_rng_itvl := temp;
 temp := factor1(loc_domain);
 IF(schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(temp)THEN  temp := factor1(temp);
 END_IF ;
 IF NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN RETURN(FALSE);
 END_IF;
 loc_dmn_itvl := temp;
 RETURN(bool((loc_dmn_itvl.min <= idx_rng_itvl.min)AND(idx_rng_itvl.max <= loc_dmn_itvl.max + 1)));
 END_FUNCTION; -- check_sparse_index_to_loc

FUNCTION check_sparse_loc_range
	(locrng : tuple_space; base : zero_or_one; shape : LIST [1:?] OF positive_integer; order : ordering_type) : BOOLEAN;
 LOCAL
 mthspc : maths_space;
 interval : finite_integer_interval;
 i : INTEGER;
 END_LOCAL
;
 IF  space_dimension(locrng)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 mthspc := factor1(locrng);
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(mthspc))THEN  RETURN(FALSE);
 END_IF ;
 interval := mthspc;
 IF order = by_rows THEN i := 2;
 ELSE i := 1;
 END_IF;
 RETURN(bool((interval.min >= base)AND(interval.max <= base + shape [ i ] - 1)));
 END_FUNCTION; -- check_sparse_loc_range

FUNCTION compare_basis_and_coef
	(basis : LIST [1:?] OF b_spline_basis; coef : maths_function) : BOOLEAN;
 LOCAL
 shape : LIST OF positive_integer;
 END_LOCAL
;
 IF  NOT  EXISTS(basis)OR NOT  EXISTS(coef)THEN  RETURN(FALSE );
 END_IF ;
 shape := shape_of_array(coef);
 IF  NOT EXISTS(shape)THEN  RETURN(FALSE );
 END_IF ;
 IF  SIZEOF(shape)< SIZEOF(basis)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(basis);
 IF(basis [ i ].num_basis = shape [ i ])<> TRUE  THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- compare_basis_and_coef

FUNCTION compare_list_and_value
	(lv : LIST [0:?] OF GENERIC; op : elementary_function_enumerators; v : GENERIC:G) : BOOLEAN;
 IF  NOT  EXISTS(lv)OR  NOT  EXISTS(op)OR NOT  EXISTS(v)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(lv);
 IF NOT compare_values(lv [ i ], op, v)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- compare_list_and_value

FUNCTION compare_values
	(v1 : GENERIC:G; op : elementary_function_enumerators; v2 : GENERIC:G) : BOOLEAN;
 LOCAL
 logl : LOGICAL := UNKNOWN;
 END_LOCAL
;
 IF  NOT  EXISTS(v1)OR  NOT  EXISTS(op)OR NOT EXISTS(v2)THEN  RETURN(FALSE );
 END_IF ;
 CASE op OF ef_eq_i : logl :=(v1 = v2);
 ef_ne_i : logl :=(v1 <> v2);
 ef_gt_i : logl :=(v1 > v2);
 ef_lt_i : logl :=(v1 < v2);
 ef_ge_i : logl :=(v1 >= v2);
 ef_le_i : logl :=(v1 <= v2);
 END_CASE;
 IF  EXISTS(logl)THEN  IF logl = TRUE  THEN RETURN(TRUE);
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- compare_values

FUNCTION compatible_complex_number_regions
	(sp1 : maths_space; sp2 : maths_space) : BOOLEAN;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(sp1);
 crgn1, crgn2 : cartesian_complex_number_region;
 prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
 sp1_is_crgn, sp2_is_crgn : BOOLEAN;
 END_LOCAL
;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  typenames THEN  sp1_is_crgn := TRUE ;
 crgn1 := sp1;
 ELSE  IF  'POLAR_COMPLEX_NUMBER_REGION' IN  typenames THEN  sp1_is_crgn := FALSE ;
 prgn1 := sp1;
 ELSE  RETURN(TRUE );
 END_IF ;
 END_IF ;
 typenames := stripped_typeof(sp2);
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  typenames THEN  sp2_is_crgn := TRUE ;
 crgn2 := sp2;
 ELSE  IF  'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN  sp2_is_crgn := FALSE ;
 prgn2 := sp2;
 ELSE RETURN(TRUE );
 END_IF ;
 END_IF ;
 IF  sp1_is_crgn AND  sp2_is_crgn THEN  RETURN(compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)AND  compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
 END_IF ;
 IF  NOT  sp1_is_crgn AND  NOT  sp2_is_crgn AND(prgn1.centre.real_part = prgn2.centre.real_part)AND(prgn1.centre.imag_part = prgn2.centre.imag_part)THEN  IF  NOT  compatible_intervals(prgn1.distance_constraint, prgn2.distance_constraint)THEN  RETURN(FALSE );
 END_IF ;
 IF  compatible_intervals(prgn1.direction_constraint, prgn2.direction_constraint)THEN  RETURN(TRUE);
 END_IF ;
 IF(prgn1.direction_constraint.max > PI)AND(prgn2.direction_constraint.max < PI)THEN  RETURN(compatible_intervals(prgn2.direction_constraint, make_finite_real_interval(- PI , open, prgn1.direction_constraint.max - 2.0 * PI , prgn1.direction_constraint.max_closure)));
 END_IF ;
 IF(prgn2.direction_constraint.max > PI)AND(prgn1.direction_constraint.max < PI)THEN  RETURN(compatible_intervals(prgn1.direction_constraint, make_finite_real_interval(- PI , open, prgn2.direction_constraint.max - 2.0 * PI, prgn2.direction_constraint.max_closure)));
 END_IF ;
 RETURN(FALSE);
 END_IF ;
 IF  sp1_is_crgn AND  NOT  sp2_is_crgn THEN  crgn2 := enclose_pregion_in_cregion(prgn2);
 prgn1 := enclose_cregion_in_pregion(crgn1, prgn2.centre);
 RETURN(compatible_complex_number_regions(crgn1, crgn2)AND  compatible_complex_number_regions(prgn1, prgn2));
 END_IF ;
 IF NOT sp1_is_crgn AND  sp2_is_crgn THEN crgn1 := enclose_pregion_in_cregion(prgn1);
 prgn2 := enclose_cregion_in_pregion(crgn2, prgn1.centre);
 RETURN(compatible_complex_number_regions(crgn1, crgn2)AND  compatible_complex_number_regions(prgn1, prgn2));
 END_IF;
 prgn1c2 := enclose_pregion_in_pregion(prgn1, prgn2.centre);
 prgn2c1 := enclose_pregion_in_pregion(prgn2, prgn1.centre);
 RETURN(compatible_complex_number_regions(prgn1, prgn2c1)AND compatible_complex_number_regions(prgn1c2, prgn2));
 END_FUNCTION; -- compatible_complex_number_regions

FUNCTION compatible_es_values
	(esval1 : elementary_space_enumerators; esval2 : elementary_space_enumerators) : BOOLEAN;
 LOCAL
 esval1_is_numeric, esval2_is_numeric : LOGICAL;
 END_LOCAL
;
 IF(esval1 = esval2)OR(esval1 = es_generics)OR(esval2 = es_generics)THEN  RETURN(TRUE );
 END_IF ;
 esval1_is_numeric :=(esval1 >= es_numbers)AND(esval1 <= es_integers);
 esval2_is_numeric :=(esval2 >= es_numbers)AND(esval2 <= es_integers);
 IF(esval1_is_numeric AND(esval2 = es_numbers))OR(esval2_is_numeric AND(esval1 = es_numbers))THEN  RETURN(TRUE );
 END_IF ;
 IF  esval1_is_numeric XOR esval2_is_numeric THEN  RETURN(FALSE );
 END_IF ;
 IF((esval1 = es_logicals)AND(esval2 = es_booleans))OR((esval1 = es_booleans)AND(esval2 = es_logicals))THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- compatible_es_values

FUNCTION compatible_intervals
	(sp1 : maths_space; sp2 : maths_space) : BOOLEAN;
 LOCAL
 amin, amax : REAL;
 END_LOCAL
;
 IF  min_exists(sp1)AND  max_exists(sp2)THEN  amin := real_min(sp1);
 amax := real_max(sp2);
 IF  amin > amax THEN  RETURN(FALSE );
 END_IF ;
 IF  amin = amax THEN  RETURN(min_included(sp1)AND  max_included(sp2));
 END_IF ;
 END_IF ;
 IF  min_exists(sp2)AND  max_exists(sp1)THEN  amin := real_min(sp2);
 amax := real_max(sp1);
 IF  amin > amax THEN  RETURN(FALSE);
 END_IF ;
 IF amin = amax THEN RETURN(min_included(sp2)AND max_included(sp1));
 END_IF ;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- compatible_intervals

FUNCTION compatible_spaces
	(sp1 : maths_space; sp2 : maths_space) : BOOLEAN;
 LOCAL
 types1 : SET  OF  STRING  := stripped_typeof(sp1);
 types2 : SET OF  STRING := stripped_typeof(sp2);
 lgcl : LOGICAL := UNKNOWN ;
 m, n : INTEGER;
 s1, s2 : maths_space;
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  types1 THEN  REPEAT  i := 1 TO  SIZEOF(sp1 \ finite_space.members);
 lgcl := member_of(sp1 \ finite_space.members [ i ], sp2);
 IF  lgcl <> FALSE  THEN  RETURN(TRUE );
 END_IF ;
 END_REPEAT ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_SPACE' IN  types2 THEN  REPEAT  i := 1 TO  SIZEOF(sp2 \ finite_space.members);
 lgcl := member_of(sp2 \ finite_space.members [ i ], sp1);
 IF  lgcl <> FALSE  THEN  RETURN(TRUE );
 END_IF ;
 END_REPEAT ;
 RETURN(FALSE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types1 THEN  IF  sp1 \ elementary_space.space_id = es_generics THEN  RETURN(TRUE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types2 THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, sp2 \ elementary_space.space_id));
 END_IF ;
 IF('FINITE_INTEGER_INTERVAL' IN  types2)OR('INTEGER_INTERVAL_FROM_MIN' IN  types2)OR('INTEGER_INTERVAL_TO_MAX' IN  types2)THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, es_integers));
 END_IF ;
 IF('FINITE_REAL_INTERVAL' IN  types2)OR('REAL_INTERVAL_FROM_MIN' IN  types2)OR('REAL_INTERVAL_TO_MAX' IN  types2)THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, es_reals));
 END_IF ;
 IF('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types2)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types2)THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, es_complex_numbers));
 END_IF ;
 IF  'TUPLE_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types2 THEN  RETURN(bool(sp1 \ elementary_space.space_id = es_maths_functions));
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types2 THEN  IF  sp2 \ elementary_space.space_id = es_generics THEN  RETURN(TRUE );
 END_IF ;
 IF('FINITE_INTEGER_INTERVAL' IN  types1)OR('INTEGER_INTERVAL_FROM_MIN' IN  types1)OR('INTEGER_INTERVAL_TO_MAX' IN  types1)THEN  RETURN(compatible_es_values(sp2 \ elementary_space.space_id, es_integers));
 END_IF ;
 IF('FINITE_REAL_INTERVAL' IN  types1)OR('REAL_INTERVAL_FROM_MIN' IN  types1)OR('REAL_INTERVAL_TO_MAX' IN  types1)THEN  RETURN(compatible_es_values(sp2 \ elementary_space.space_id, es_reals));
 END_IF ;
 IF('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types1)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types1)THEN  RETURN(compatible_es_values(sp2 \ elementary_space.space_id, es_complex_numbers));
 END_IF ;
 IF  'TUPLE_SPACE' IN  types1 THEN  RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types1 THEN  RETURN(bool(sp2 \ elementary_space.space_id = es_maths_functions));
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  subspace_of_es(sp1, es_integers)THEN  IF  subspace_of_es(sp2, es_integers)THEN  RETURN(compatible_intervals(sp1, sp2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp2, es_integers)THEN  RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp1, es_reals)THEN  IF  subspace_of_es(sp2, es_reals)THEN  RETURN(compatible_intervals(sp1, sp2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp2, es_reals)THEN  RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp1, es_complex_numbers)THEN  IF  subspace_of_es(sp2, es_complex_numbers)THEN  RETURN(compatible_complex_number_regions(sp1, sp2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp2, es_complex_numbers)THEN  RETURN(FALSE );
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types1 THEN  IF  'UNIFORM_PRODUCT_SPACE' IN  types2 THEN  IF  sp1 \ uniform_product_space.exponent <> sp2 \ uniform_product_space.exponent THEN  RETURN(FALSE );
 END_IF ;
 RETURN(compatible_spaces(sp1 \ uniform_product_space.base, sp2 \ uniform_product_space.base));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types2 THEN  n := SIZEOF(sp2 \ listed_product_space.factors);
 IF  sp1 \ uniform_product_space.exponent <> n THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  n;
 IF  NOT  compatible_spaces(sp1 \ uniform_product_space.base, sp2 \ listed_product_space.factors [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(TRUE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  m := sp1 \ uniform_product_space.exponent;
 n := space_dimension(sp2 \ extended_tuple_space.base);
 IF  m < n THEN  RETURN(FALSE );
 END_IF ;
 IF  m = n THEN  RETURN(compatible_spaces(sp1, sp2 \ extended_tuple_space.base));
 END_IF ;
 RETURN(compatible_spaces(sp1, assoc_product_space(sp2 \ extended_tuple_space.base, make_uniform_product_space(sp2 \ extended_tuple_space.extender, m - n))));
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types1 THEN  n := SIZEOF(sp1 \ listed_product_space.factors);
 IF  'UNIFORM_PRODUCT_SPACE' IN  types2 THEN  IF  n <> sp2 \ uniform_product_space.exponent THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  n;
 IF  NOT  compatible_spaces(sp2 \ uniform_product_space.base, sp1 \ listed_product_space.factors [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(TRUE );
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types2 THEN  IF  n <> SIZEOF(sp2 \ listed_product_space.factors)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO n;
 IF  NOT  compatible_spaces(sp1 \ listed_product_space.factors [ i ], sp2 \ listed_product_space.factors [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  m := space_dimension(sp2 \ extended_tuple_space.base);
 IF  n < m THEN  RETURN(FALSE );
 END_IF ;
 IF  n = m THEN  RETURN(compatible_spaces(sp1, sp2 \ extended_tuple_space.base));
 END_IF ;
 RETURN(compatible_spaces(sp1, assoc_product_space(sp2 \ extended_tuple_space.base, make_uniform_product_space(sp2 \ extended_tuple_space.extender, n - m))));
 END_IF ;
 IF(schema_prefix + 'FUNCTION_SPACE')IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types1 THEN  IF('UNIFORM_PRODUCT_SPACE' IN  types2)OR('LISTED_PRODUCT_SPACE' IN  types2)THEN  RETURN(compatible_spaces(sp2, sp1));
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  IF  NOT compatible_spaces(sp1 \ extended_tuple_space.extender, sp2 \ extended_tuple_space.extender)THEN  RETURN(FALSE );
 END_IF ;
 n := space_dimension(sp1 \ extended_tuple_space.base);
 m := space_dimension(sp2 \ extended_tuple_space.base);
 IF  n < m THEN  RETURN(compatible_spaces(assoc_product_space(sp1 \ extended_tuple_space.base, make_uniform_product_space(sp1 \ extended_tuple_space.extender, m - n)), sp2 \ extended_tuple_space.base));
 END_IF ;
 IF  n = m THEN  RETURN(compatible_spaces(sp1 \ extended_tuple_space.base, sp2 \ extended_tuple_space.base));
 END_IF ;
 IF  n > m THEN  RETURN(compatible_spaces(sp1 \ extended_tuple_space.base, assoc_product_space(sp2 \ extended_tuple_space.base, make_uniform_product_space(sp2 \ extended_tuple_space.extender, n - m))));
 END_IF ;
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types1 THEN  IF  'FUNCTION_SPACE' IN types2 THEN  s1 := sp1 \ function_space.domain_argument;
 s2 := sp2 \ function_space.domain_argument;
 CASE  sp1 \ function_space.domain_constraint OF  sc_equal : BEGIN  CASE  sp2 \ function_space.domain_constraint OF  sc_equal : lgcl := subspace_of(s1, s2)AND  subspace_of(s2, s1);
 sc_subspace : lgcl := subspace_of(s1, s2);
 sc_member : lgcl := member_of(s1, s2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  sp2 \ function_space.domain_constraint OF  sc_equal : lgcl := subspace_of(s2, s1);
 sc_subspace : lgcl := compatible_spaces(s1, s2);
 sc_member : lgcl := UNKNOWN ;
 END_CASE ;
 END ;
 sc_member : BEGIN  CASE  sp2 \ function_space.domain_constraint OF  sc_equal : lgcl := member_of(s2, s1);
 sc_subspace : lgcl := UNKNOWN ;
 sc_member : lgcl := compatible_spaces(s1, s2);
 END_CASE ;
 END ;
 END_CASE ;
 IF  lgcl = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 s1 := sp1 \ function_space.range_argument;
 s2 := sp2 \ function_space.range_argument;
 CASE  sp1 \ function_space.range_constraint OF  sc_equal : BEGIN  CASE  sp2 \ function_space.range_constraint OF  sc_equal : lgcl := subspace_of(s1, s2)AND subspace_of(s2, s1);
 sc_subspace : lgcl := subspace_of(s1, s2);
 sc_member : lgcl := member_of(s1, s2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  sp2 \ function_space.range_constraint OF  sc_equal : lgcl := subspace_of(s2, s1);
 sc_subspace : lgcl := compatible_spaces(s1, s2);
 sc_member : lgcl := UNKNOWN ;
 END_CASE ;
 END ;
 sc_member : BEGIN CASE sp2 \ function_space.range_constraint OF sc_equal : lgcl := member_of(s2, s1);
 sc_subspace : lgcl := UNKNOWN;
 sc_member : lgcl := compatible_spaces(s1, s2);
 END_CASE ;
 END;
 END_CASE;
 IF lgcl = FALSE  THEN RETURN(FALSE);
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 RETURN(TRUE );
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- compatible_spaces

FUNCTION composable_sequence
	(operands : LIST [2:?] OF maths_function) : BOOLEAN;
 REPEAT i := 1 TO SIZEOF(operands)- 1;
 IF NOT compatible_spaces(operands [ i ].range, operands [ i + 1 ].domain)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- composable_sequence

FUNCTION convert_to_literal
	(val : maths_atom) : generic_literal;
 LOCAL
 types : SET OF STRING := TYPEOF(val);
 END_LOCAL
;
 IF  'INTEGER' IN  types THEN  RETURN(make_int_literal(val));
 END_IF ;
 IF  'REAL' IN  types THEN  RETURN(make_real_literal(val));
 END_IF ;
 IF  'BOOLEAN' IN  types THEN  RETURN(make_boolean_literal(val));
 END_IF ;
 IF  'STRING' IN  types THEN  RETURN(make_string_literal(val));
 END_IF ;
 IF  'LOGICAL' IN  types THEN  RETURN(make_logical_literal(val));
 END_IF ;
 IF  'BINARY' IN  types THEN  RETURN(make_binary_literal(val));
 END_IF ;
 IF(schema_prefix + 'MATHS_ENUM_ATOM')IN types THEN RETURN(make_maths_enum_literal(val));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- convert_to_literal

FUNCTION convert_to_maths_function
	(func : maths_function_select) : maths_function;
 LOCAL
 efenum : elementary_function_enumerators;
 mthfun : maths_function;
 END_LOCAL
;
 IF(schema_prefix + 'MATHS_FUNCTION')IN TYPEOF(func)THEN mthfun := func;
 ELSE efenum := func;
 mthfun := make_elementary_function(efenum);
 END_IF;
 RETURN(mthfun);
 END_FUNCTION; -- convert_to_maths_function

FUNCTION convert_to_maths_value
	(val : GENERIC:G) : maths_value;
 LOCAL
 types : SET OF STRING := TYPEOF(val);
 ival : maths_integer;
 rval : maths_real;
 nval : maths_number;
 tfval : maths_boolean;
 lval : maths_logical;
 sval : maths_string;
 bval : maths_binary;
 tval : maths_tuple := the_empty_maths_tuple;
 mval : maths_value;
 END_LOCAL
;
 IF(schema_prefix + 'MATHS_VALUE')IN  types THEN  RETURN(val);
 END_IF ;
 IF  'INTEGER' IN  types THEN  ival := val;
 RETURN(ival);
 END_IF ;
 IF  'REAL' IN  types THEN  rval := val;
 RETURN(rval);
 END_IF ;
 IF  'NUMBER' IN  types THEN  nval := val;
 RETURN(nval);
 END_IF ;
 IF  'BOOLEAN' IN  types THEN  tfval := val;
 RETURN(tfval);
 END_IF ;
 IF  'LOGICAL' IN  types THEN  lval := val;
 RETURN(lval);
 END_IF ;
 IF  'STRING' IN  types THEN  sval := val;
 RETURN(sval);
 END_IF ;
 IF  'BINARY' IN  types THEN  bval := val;
 RETURN(bval);
 END_IF ;
 IF  'LIST' IN types THEN  REPEAT i := 1 TO SIZEOF(val);
 mval := convert_to_maths_value(val [ i ]);
 IF NOT EXISTS(mval)THEN RETURN(?);
 END_IF ;
 INSERT(tval, mval, i - 1);
 END_REPEAT;
 RETURN(tval);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- convert_to_maths_value

FUNCTION convert_to_operand
	(val : maths_value) : generic_expression;
 LOCAL
 types : SET OF STRING := stripped_typeof(val);
 END_LOCAL
;
 IF  'GENERIC_EXPRESSION' IN  types THEN  RETURN(val);
 END_IF ;
 IF  'MATHS_ATOM' IN  types THEN  RETURN(convert_to_literal(val));
 END_IF ;
 IF  'ATOM_BASED_VALUE' IN  types THEN  RETURN(make_atom_based_literal(val));
 END_IF ;
 IF 'MATHS_TUPLE' IN types THEN RETURN(make_maths_tuple_literal(val));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- convert_to_operand

FUNCTION convert_to_operands
	(values : AGGREGATE OF maths_value) : LIST [0:?] OF generic_expression;
 LOCAL
 operands : LIST OF generic_expression := [ ];
 loc : INTEGER := 0;
 END_LOCAL
;
 IF NOT EXISTS(values)THEN RETURN(?);
 END_IF;
 REPEAT i := LOINDEX(values)TO HIINDEX(values);
 INSERT(operands, convert_to_operand(values [ i ]), loc);
 loc := loc + 1;
 END_REPEAT;
 RETURN(operands);
 END_FUNCTION; -- convert_to_operands

FUNCTION convert_to_operands_prcmfn
	(srcdom : maths_space_or_function; prepfun : LIST [0:?] OF maths_function; finfun : maths_function_select) : LIST [2:?] OF generic_expression;
 LOCAL
 operands : LIST OF generic_expression := [ ];
 END_LOCAL
;
 INSERT(operands, srcdom, 0);
 REPEAT i := 1 TO SIZEOF(prepfun);
 INSERT(operands, prepfun [ i ], i);
 END_REPEAT;
 INSERT(operands, convert_to_maths_function(finfun), SIZEOF(prepfun)+ 1);
 RETURN(operands);
 END_FUNCTION; -- convert_to_operands_prcmfn

FUNCTION ctmv
	(x : GENERIC:G) : maths_value;
 RETURN(convert_to_maths_value(x));
 END_FUNCTION; -- ctmv

FUNCTION definite_integral_check
	(domain : tuple_space; vrblint : input_selector; lowerinf : BOOLEAN; upperinf : BOOLEAN) : BOOLEAN;
 LOCAL
 domn : tuple_space := domain;
 fspc : maths_space;
 dim : nonnegative_integer;
 k : positive_integer;
 END_LOCAL
;
 IF(space_dimension(domain)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(domain)))THEN  domn := factor1(domain);
 END_IF ;
 dim := space_dimension(domn);
 k := vrblint;
 IF  k > dim THEN  RETURN(FALSE );
 END_IF ;
 fspc := factor_space(domn, k);
 IF  NOT((schema_prefix + 'REAL_INTERVAL')IN TYPEOF(fspc))THEN  RETURN(FALSE );
 END_IF ;
 IF  lowerinf AND  min_exists(fspc)THEN  RETURN(FALSE );
 END_IF ;
 IF upperinf AND max_exists(fspc)THEN RETURN(FALSE);
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- definite_integral_check

FUNCTION definite_integral_expr_check
	(operands : LIST [2:?] OF generic_expression; lowerinf : BOOLEAN; upperinf : BOOLEAN) : BOOLEAN;
 LOCAL
 nops : INTEGER := 2;
 vspc : maths_space;
 dim : nonnegative_integer;
 k : positive_integer;
 bspc : maths_space;
 END_LOCAL
;
 IF  NOT  lowerinf THEN  nops := nops + 1;
 END_IF ;
 IF  NOT  upperinf THEN  nops := nops + 1;
 END_IF ;
 IF  SIZEOF(operands)<> nops THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT('GENERIC_VARIABLE' IN  stripped_typeof(operands [ 2 ]))THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT  has_values_space(operands [ 2 ])THEN  RETURN(FALSE );
 END_IF ;
 vspc := values_space_of(operands [ 2 ]);
 IF  NOT('REAL_INTERVAL' IN stripped_typeof(vspc))THEN  RETURN(FALSE );
 END_IF ;
 IF  lowerinf THEN  IF  min_exists(vspc)THEN  RETURN(FALSE );
 END_IF ;
 k := 3;
 ELSE  IF  NOT  has_values_space(operands [ 3 ])THEN  RETURN(FALSE );
 END_IF ;
 bspc := values_space_of(operands [ 3 ]);
 IF  NOT  compatible_spaces(bspc, vspc)THEN  RETURN(FALSE );
 END_IF ;
 k := 4;
 END_IF ;
 IF  upperinf THEN  IF  max_exists(vspc)THEN  RETURN(FALSE );
 END_IF ;
 ELSE IF  NOT  has_values_space(operands [ k ])THEN  RETURN(FALSE );
 END_IF ;
 bspc := values_space_of(operands [ k ]);
 IF NOT compatible_spaces(bspc, vspc)THEN RETURN(FALSE);
 END_IF ;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- definite_integral_expr_check

FUNCTION derive_definite_integral_domain
	(igrl : definite_integral_function) : tuple_space;
 LOCAL
 idomn : tuple_space := igrl.integrand.domain;
 types : SET OF STRING := TYPEOF(idomn);
 idx : INTEGER  := igrl.variable_of_integration;
 tupled : BOOLEAN := bool(((space_dimension(idomn)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  types)));
 prefix : INTEGER := 0;
 espc : extended_tuple_space;
 vdomn : maths_space;
 END_LOCAL
;
 IF  tupled THEN  idomn := factor1(idomn);
 types := TYPEOF(idomn);
 END_IF ;
 IF  igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;
 END_IF ;
 IF  igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;
 END_IF ;
 vdomn := factor_space(idomn, idx);
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN types THEN  espc := idomn;
 idomn := make_extended_tuple_space(process_product_space(espc.base, idx, prefix, vdomn), espc.extender);
 ELSE  idomn := process_product_space(idomn, idx, prefix, vdomn);
 END_IF ;
 IF tupled THEN RETURN(one_tuples_of(idomn));
 ELSE RETURN(idomn);
 END_IF;
 END_FUNCTION; -- derive_definite_integral_domain

FUNCTION derive_elementary_function_domain
	(ef_val : elementary_function_enumerators) : tuple_space;
 IF NOT EXISTS(ef_val)THEN RETURN(?);
 END_IF;
 CASE ef_val OF ef_and : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
 ef_or : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
 ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
 ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_add_i : RETURN(the_integer_tuples);
 ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_multiply_i : RETURN(the_integer_tuples);
 ef_divide_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_mod_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_eq_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_ne_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_gt_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_lt_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_ge_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_le_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_if_i : RETURN(make_listed_product_space([ the_logicals, the_integers, the_integers ]));
 ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_add_r : RETURN(the_real_tuples);
 ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_multiply_r : RETURN(the_real_tuples);
 ef_divide_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_mod_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_exponentiate_r : RETURN(make_listed_product_space([ the_nonnegative_reals, the_reals ]));
 ef_exponentiate_ri : RETURN(make_listed_product_space([ the_reals, the_integers ]));
 ef_eq_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_ne_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_gt_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_lt_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_ge_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_le_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_abs_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_acos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_asin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_atan2_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_cos_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_exp_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_ln_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_log2_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_log10_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_sin_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_if_r : RETURN(make_listed_product_space([ the_logicals, the_reals, the_reals ]));
 ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_add_c : RETURN(the_complex_tuples);
 ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_multiply_c : RETURN(the_complex_tuples);
 ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_exponentiate_ci : RETURN(make_listed_product_space([ the_complex_numbers, the_integers ]));
 ef_eq_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_ne_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_abs_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_arg_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_if_c : RETURN(make_listed_product_space([ the_logicals, the_complex_numbers, the_complex_numbers ]));
 ef_subscript_s : RETURN(make_listed_product_space([ the_strings, the_integers ]));
 ef_eq_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_ne_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_gt_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_lt_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_ge_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_le_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_subsequence_s : RETURN(make_listed_product_space([ the_strings, the_integers, the_integers ]));
 ef_concat_s : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_strings));
 ef_size_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_format : RETURN(make_listed_product_space([ the_numbers, the_strings ]));
 ef_value : RETURN(make_uniform_product_space(the_strings, 1));
 ef_like : RETURN(make_uniform_product_space(the_strings, 2));
 ef_if_s : RETURN(make_listed_product_space([ the_logicals, the_strings, the_strings ]));
 ef_subscript_b : RETURN(make_listed_product_space([ the_binarys, the_integers ]));
 ef_eq_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_ne_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_gt_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_lt_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_ge_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_le_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_subsequence_b : RETURN(make_listed_product_space([ the_binarys, the_integers, the_integers ]));
 ef_concat_b : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_binarys));
 ef_size_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_if_b : RETURN(make_listed_product_space([ the_logicals, the_binarys, the_binarys ]));
 ef_subscript_t : RETURN(make_listed_product_space([ the_tuples, the_integers ]));
 ef_eq_t : RETURN(make_uniform_product_space(the_tuples, 2));
 ef_ne_t : RETURN(make_uniform_product_space(the_tuples, 2));
 ef_concat_t : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_tuples));
 ef_size_t : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_entuple : RETURN(the_tuples);
 ef_detuple : RETURN(make_uniform_product_space(the_generics, 1));
 ef_insert : RETURN(make_listed_product_space([ the_tuples, the_generics, the_integers ]));
 ef_remove : RETURN(make_listed_product_space([ the_tuples, the_integers ]));
 ef_if_t : RETURN(make_listed_product_space([ the_logicals, the_tuples, the_tuples ]));
 ef_sum_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_product_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_add_it : RETURN(make_extended_tuple_space(the_integer_tuples, the_integer_tuples));
 ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
 ef_scalar_mult_it : RETURN(make_listed_product_space([ the_integers, the_integer_tuples ]));
 ef_dot_prod_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
 ef_sum_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_product_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_add_rt : RETURN(make_extended_tuple_space(the_real_tuples, the_real_tuples));
 ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
 ef_scalar_mult_rt : RETURN(make_listed_product_space([ the_reals, the_real_tuples ]));
 ef_dot_prod_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
 ef_norm_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_sum_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_product_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_add_ct : RETURN(make_extended_tuple_space(the_complex_tuples, the_complex_tuples));
 ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
 ef_scalar_mult_ct : RETURN(make_listed_product_space([ the_complex_numbers, the_complex_tuples ]));
 ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
 ef_norm_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_if : RETURN(make_listed_product_space([ the_logicals, the_generics, the_generics ]));
 ef_ensemble : RETURN(the_tuples);
 ef_member_of : RETURN(make_listed_product_space([ the_generics, the_maths_spaces ]));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- derive_elementary_function_domain

FUNCTION derive_elementary_function_range
	(ef_val : elementary_function_enumerators) : tuple_space;
 IF NOT EXISTS(ef_val)THEN RETURN(?);
 END_IF;
 CASE ef_val OF ef_and : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_or : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
 ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_add_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_multiply_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_divide_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_mod_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_eq_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_if_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_add_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_multiply_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_divide_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_mod_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_exponentiate_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_exponentiate_ri : RETURN(make_uniform_product_space(the_reals, 1));
 ef_eq_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_abs_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_acos_r : RETURN(make_uniform_product_space(the_zero_pi_interval, 1));
 ef_asin_r : RETURN(make_uniform_product_space(the_neghalfpi_halfpi_interval, 1));
 ef_atan2_r : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
 ef_cos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_exp_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_ln_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_log2_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_log10_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_sin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_if_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_add_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_multiply_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exponentiate_ci : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_eq_c : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_c : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_abs_c : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_arg_c : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
 ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_if_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_subscript_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_eq_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_subsequence_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_concat_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_size_s : RETURN(make_uniform_product_space(the_integers, 1));
 ef_format : RETURN(make_uniform_product_space(the_strings, 1));
 ef_value : RETURN(make_uniform_product_space(the_reals, 1));
 ef_like : RETURN(make_uniform_product_space(the_booleans, 1));
 ef_if_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_subscript_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_eq_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_subsequence_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_concat_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_size_b : RETURN(make_uniform_product_space(the_integers, 1));
 ef_if_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_subscript_t : RETURN(make_uniform_product_space(the_generics, 1));
 ef_eq_t : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_t : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_concat_t : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_size_t : RETURN(make_uniform_product_space(the_integers, 1));
 ef_entuple : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_detuple : RETURN(the_tuples);
 ef_insert : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_remove : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_if_t : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_sum_it : RETURN(make_uniform_product_space(the_integers, 1));
 ef_product_it : RETURN(make_uniform_product_space(the_integers, 1));
 ef_add_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_scalar_mult_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_dot_prod_it : RETURN(make_uniform_product_space(the_integers, 1));
 ef_sum_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_product_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_add_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_scalar_mult_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_dot_prod_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_norm_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_sum_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_product_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_add_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_scalar_mult_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_norm_ct : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_if : RETURN(make_uniform_product_space(the_generics, 1));
 ef_ensemble : RETURN(make_uniform_product_space(the_maths_spaces, 1));
 ef_member_of : RETURN(make_uniform_product_space(the_logicals, 1));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- derive_elementary_function_range

FUNCTION derive_finite_function_domain
	(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
 LOCAL
 result : SET OF maths_value := [ ];
 END_LOCAL
;
 result := result + list_selected_components(pairs, 1);
 RETURN(one_tuples_of(make_finite_space(result)));
 END_FUNCTION; -- derive_finite_function_domain

FUNCTION derive_finite_function_range
	(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
 LOCAL
 result : SET OF maths_value := [ ];
 END_LOCAL
;
 result := result + list_selected_components(pairs, 2);
 RETURN(one_tuples_of(make_finite_space(result)));
 END_FUNCTION; -- derive_finite_function_range

FUNCTION derive_function_domain
	(func : maths_function) : tuple_space;
 LOCAL
 typenames : SET OF  STRING := stripped_typeof(func);
 tspace : tuple_space := make_listed_product_space([ ]);
 shape : LIST  OF  positive_integer;
 sidxs : LIST  OF  INTEGER := [ 0 ];
 itvl : finite_integer_interval;
 factors : LIST OF finite_integer_interval := [ ];
 is_uniform : BOOLEAN := TRUE;
 END_LOCAL
;
 IF  'FINITE_FUNCTION' IN  typenames THEN  RETURN(derive_finite_function_domain(func \ finite_function.pairs));
 END_IF ;
 IF  'CONSTANT_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ constant_function.source_of_domain));
 END_IF ;
 IF  'SELECTOR_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ selector_function.source_of_domain));
 END_IF ;
 IF  'ELEMENTARY_FUNCTION' IN  typenames THEN  RETURN(derive_elementary_function_domain(func \ elementary_function.func_id));
 END_IF ;
 IF  'RESTRICTION_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(func \ restriction_function.operand));
 END_IF ;
 IF  'REPACKAGING_FUNCTION' IN  typenames THEN  IF  func \ repackaging_function.input_repack = ro_nochange THEN  RETURN(func \ repackaging_function.operand.domain);
 END_IF ;
 IF  func \ repackaging_function.input_repack = ro_wrap_as_tuple THEN  RETURN(factor1(func \ repackaging_function.operand.domain));
 END_IF ;
 IF  func \ repackaging_function.input_repack = ro_unwrap_tuple THEN  RETURN(one_tuples_of(func \ repackaging_function.operand.domain));
 END_IF ;
 RETURN(?);
 END_IF ;
 IF  'REINDEXED_ARRAY_FUNCTION' IN  typenames THEN  shape := shape_of_array(func \ unary_generic_expression.operand);
 sidxs := func \ reindexed_array_function.starting_indices;
 REPEAT  i := 1 TO  SIZEOF(shape);
 itvl := make_finite_integer_interval(sidxs [ i ], sidxs [ i ] + shape [ i ] - 1);
 INSERT(factors, itvl, i - 1);
 IF  shape [ i ] <> shape [ 1 ] THEN  is_uniform := FALSE ;
 END_IF ;
 END_REPEAT ;
 IF  is_uniform THEN  RETURN(make_uniform_product_space(factors [ 1 ], SIZEOF(shape)));
 END_IF ;
 RETURN(make_listed_product_space(factors));
 END_IF ;
 IF  'SERIES_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(func \ series_composed_function.operands [ 1 ].domain);
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ parallel_composed_function.source_of_domain));
 END_IF ;
 IF  'EXPLICIT_TABLE_FUNCTION' IN  typenames THEN  shape := func \ explicit_table_function.shape;
 sidxs [ 1 ] := func \ explicit_table_function.index_base;
 REPEAT  i := 1 TO  SIZEOF(shape);
 itvl := make_finite_integer_interval(sidxs [ 1 ], sidxs [ 1 ] + shape [ i ] - 1);
 INSERT(factors, itvl, i - 1);
 IF  shape [ i ] <> shape [ 1 ] THEN  is_uniform := FALSE;
 END_IF ;
 END_REPEAT ;
 IF  is_uniform THEN  RETURN(make_uniform_product_space(factors [ 1 ], SIZEOF(shape)));
 END_IF ;
 RETURN(make_listed_product_space(factors));
 END_IF ;
 IF  'HOMOGENEOUS_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ homogeneous_linear_function.mat.range), func \ homogeneous_linear_function.mat \ explicit_table_function.shape [ func \ homogeneous_linear_function.sum_index ])));
 END_IF ;
 IF  'GENERAL_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ general_linear_function.mat.range), func \ general_linear_function.mat \ explicit_table_function.shape [ func \ general_linear_function.sum_index ] - 1)));
 END_IF ;
 IF  'B_SPLINE_BASIS' IN  typenames THEN  RETURN(one_tuples_of(make_finite_real_interval(func \ b_spline_basis.repeated_knots [ func \ b_spline_basis.order ], closed, func \ b_spline_basis.repeated_knots [ func \ b_spline_basis.num_basis + 1 ], closed)));
 END_IF ;
 IF  'B_SPLINE_FUNCTION' IN  typenames THEN  REPEAT  i := 1 TO  SIZEOF(func \ b_spline_function.basis);
 tspace := assoc_product_space(tspace, func \ b_spline_function.basis [ i ].domain);
 END_REPEAT ;
 RETURN(one_tuples_of(tspace));
 END_IF ;
 IF  'RATIONALIZE_FUNCTION' IN  typenames THEN  RETURN(func \ rationalize_function.fun.domain);
 END_IF ;
 IF  'PARTIAL_DERIVATIVE_FUNCTION' IN  typenames THEN  RETURN(func \ partial_derivative_function.derivand.domain);
 END_IF ;
 IF  'DEFINITE_INTEGRAL_FUNCTION' IN  typenames THEN  RETURN(derive_definite_integral_domain(func));
 END_IF ;
 IF  'ABSTRACTED_EXPRESSION_FUNCTION' IN  typenames THEN  REPEAT i := 1 TO SIZEOF(func \ abstracted_expression_function.variables);
 tspace := assoc_product_space(tspace, one_tuples_of(values_space_of(func \ abstracted_expression_function.variables [ i ])));
 END_REPEAT;
 RETURN(tspace);
 END_IF ;
 IF  'EXPRESSION_DENOTED_FUNCTION' IN  typenames THEN  RETURN(values_space_of(func \ expression_denoted_function.expr)\ function_space.domain_argument);
 END_IF ;
 IF  'IMPORTED_POINT_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_listed_product_space([ ])));
 END_IF ;
 IF  'IMPORTED_CURVE_FUNCTION' IN  typenames THEN  RETURN(func \ imported_curve_function.parametric_domain);
 END_IF ;
 IF  'IMPORTED_SURFACE_FUNCTION' IN  typenames THEN  RETURN(func \ imported_surface_function.parametric_domain);
 END_IF ;
 IF  'IMPORTED_VOLUME_FUNCTION' IN  typenames THEN  RETURN(func \ imported_volume_function.parametric_domain);
 END_IF ;
 IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN RETURN(func \ application_defined_function.explicit_domain);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- derive_function_domain

FUNCTION derive_function_range
	(func : maths_function) : tuple_space;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(func);
 tspace : tuple_space := make_listed_product_space([ ]);
 m, n : nonnegative_integer := 0;
 END_LOCAL
;
 IF  'FINITE_FUNCTION' IN  typenames THEN  RETURN(derive_finite_function_range(func \ finite_function.pairs));
 END_IF ;
 IF  'CONSTANT_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_finite_space([ func \ constant_function.sole_output ])));
 END_IF ;
 IF  'SELECTOR_FUNCTION' IN  typenames THEN  tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(tspace))THEN  tspace := factor1(tspace);
 END_IF ;
 RETURN(one_tuples_of(factor_space(tspace, func \ selector_function.selector)));
 END_IF ;
 IF  'ELEMENTARY_FUNCTION' IN  typenames THEN  RETURN(derive_elementary_function_range(func \ elementary_function.func_id));
 END_IF ;
 IF  'RESTRICTION_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(func \ restriction_function.operand));
 END_IF ;
 IF  'REPACKAGING_FUNCTION' IN  typenames THEN  tspace := func \ repackaging_function.operand.range;
 IF  func \ repackaging_function.output_repack = ro_wrap_as_tuple THEN  tspace := one_tuples_of(tspace);
 END_IF ;
 IF  func \ repackaging_function.output_repack = ro_unwrap_tuple THEN  tspace := factor1(tspace);
 END_IF ;
 IF  func \ repackaging_function.selected_output > 0 THEN  tspace := one_tuples_of(factor_space(tspace, func \ repackaging_function.selected_output));
 END_IF ;
 RETURN(tspace);
 END_IF ;
 IF  'REINDEXED_ARRAY_FUNCTION' IN  typenames THEN  RETURN(func \ unary_generic_expression.operand \ maths_function.range);
 END_IF ;
 IF  'SERIES_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(func \ series_composed_function.operands [ SIZEOF(func \ series_composed_function.operands)].range);
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(func \ parallel_composed_function.final_function.range);
 END_IF ;
 IF  'EXPLICIT_TABLE_FUNCTION' IN  typenames THEN  IF  'LISTED_REAL_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_reals));
 END_IF ;
 IF  'LISTED_INTEGER_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_integers));
 END_IF ;
 IF  'LISTED_LOGICAL_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_logicals));
 END_IF ;
 IF  'LISTED_STRING_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_strings));
 END_IF ;
 IF  'LISTED_COMPLEX_NUMBER_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_complex_numbers));
 END_IF ;
 IF  'LISTED_DATA' IN  typenames THEN  RETURN(one_tuples_of(func \ listed_data.value_range));
 END_IF ;
 IF  'EXTERNALLY_LISTED_DATA' IN  typenames THEN  RETURN(one_tuples_of(func \ externally_listed_data.value_range));
 END_IF ;
 IF  'LINEARIZED_TABLE_FUNCTION' IN  typenames THEN  RETURN(func \ linearized_table_function.source.range);
 END_IF ;
 IF  'BASIC_SPARSE_MATRIX' IN  typenames THEN  RETURN(func \ basic_sparse_matrix.val.range);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF  'HOMOGENEOUS_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ homogeneous_linear_function.mat.range), func \ homogeneous_linear_function.mat \ explicit_table_function.shape [ 3 - func \ homogeneous_linear_function.sum_index ])));
 END_IF ;
 IF  'GENERAL_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ general_linear_function.mat.range), func \ general_linear_function.mat \ explicit_table_function.shape [ 3 - func \ general_linear_function.sum_index ])));
 END_IF ;
 IF  'B_SPLINE_BASIS' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, func \ b_spline_basis.num_basis)));
 END_IF ;
 IF  'B_SPLINE_FUNCTION' IN  typenames THEN  tspace := factor1(func \ b_spline_function.coef.domain);
 m := SIZEOF(func \ b_spline_function.basis);
 n := space_dimension(tspace);
 IF  m = n THEN  RETURN(one_tuples_of(the_reals));
 END_IF ;
 IF  m = n - 1 THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, factor_space(tspace, n)\ finite_integer_interval.size)));
 END_IF ;
 tspace := extract_factors(tspace, m + 1, n);
 RETURN(one_tuples_of(make_function_space(sc_equal, tspace, sc_subspace, number_superspace_of(func \ b_spline_function.coef.range))));
 END_IF ;
 IF  'RATIONALIZE_FUNCTION' IN  typenames THEN  tspace := factor1(func \ rationalize_function.fun.range);
 n := space_dimension(tspace);
 RETURN(one_tuples_of(make_uniform_product_space(number_superspace_of(factor1(tspace)), n - 1)));
 END_IF ;
 IF  'PARTIAL_DERIVATIVE_FUNCTION' IN  typenames THEN  RETURN(drop_numeric_constraints(func \ partial_derivative_function.derivand.range));
 END_IF ;
 IF  'DEFINITE_INTEGRAL_FUNCTION' IN  typenames THEN  RETURN(drop_numeric_constraints(func \ definite_integral_function.integrand.range));
 END_IF ;
 IF  'ABSTRACTED_EXPRESSION_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(values_space_of(func \ abstracted_expression_function.expr)));
 END_IF ;
 IF  'EXPRESSION_DENOTED_FUNCTION' IN  typenames THEN  RETURN(values_space_of(func \ expression_denoted_function.expr)\ function_space.range_argument);
 END_IF ;
 IF  'IMPORTED_POINT_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_point_function.geometry))));
 END_IF ;
 IF  'IMPORTED_CURVE_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_curve_function.geometry))));
 END_IF ;
 IF  'IMPORTED_SURFACE_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_surface_function.geometry))));
 END_IF ;
 IF  'IMPORTED_VOLUME_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_volume_function.geometry))));
 END_IF ;
 IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN RETURN(func \ application_defined_function.explicit_range);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- derive_function_range

FUNCTION domain_from
	(ref : maths_space_or_function) : tuple_space;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(ref);
 func : maths_function;
 END_LOCAL
;
 IF  NOT EXISTS(ref)THEN  RETURN(?);
 END_IF ;
 IF  'TUPLE_SPACE' IN  typenames THEN  RETURN(ref);
 END_IF ;
 IF  'MATHS_SPACE' IN  typenames THEN  RETURN(one_tuples_of(ref));
 END_IF ;
 func := ref;
 IF  'CONSTANT_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ constant_function.source_of_domain));
 END_IF ;
 IF  'SELECTOR_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ selector_function.source_of_domain));
 END_IF ;
 IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN RETURN(domain_from(func \ parallel_composed_function.source_of_domain));
 END_IF;
 RETURN(func.domain);
 END_FUNCTION; -- domain_from

FUNCTION dot_count
	(str : STRING) : INTEGER;
 LOCAL
 n : INTEGER := 0;
 END_LOCAL
;
 REPEAT i := 1 TO LENGTH(str);
 IF str [ i ] = '.' THEN n := n + 1;
 END_IF;
 END_REPEAT;
 RETURN(n);
 END_FUNCTION; -- dot_count

FUNCTION dotted_identifiers_syntax
	(str : STRING) : BOOLEAN;
 LOCAL
 k : positive_integer;
 m : positive_integer;
 END_LOCAL
;
 IF  NOT EXISTS(str)THEN  RETURN(FALSE );
 END_IF ;
 k := parse_express_identifier(str, 1);
 IF  k = 1 THEN  RETURN(FALSE );
 END_IF ;
 REPEAT WHILE k <= LENGTH(str);
 IF(str [ k ] <> '.')OR(k = LENGTH(str))THEN  RETURN(FALSE );
 END_IF ;
 m := parse_express_identifier(str, k + 1);
 IF m = k + 1 THEN RETURN(FALSE);
 END_IF;
 k := m;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- dotted_identifiers_syntax

FUNCTION drop_numeric_constraints
	(spc : maths_space) : maths_space;
 LOCAL
 typenames : SET OF  STRING := stripped_typeof(spc);
 tspc : listed_product_space;
 factors : LIST OF maths_space := [ ];
 xspc : extended_tuple_space;
 END_LOCAL
;
 IF  'UNIFORM_PRODUCT_SPACE' IN  typenames THEN  RETURN(make_uniform_product_space(drop_numeric_constraints(spc \ uniform_product_space.base), spc \ uniform_product_space.exponent));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  typenames THEN  tspc := spc;
 REPEAT i := 1 TO SIZEOF(tspc.factors);
 INSERT(factors, drop_numeric_constraints(tspc.factors [ i ]), i - 1);
 END_REPEAT;
 RETURN(make_listed_product_space(factors));
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN typenames THEN  xspc := spc;
 RETURN(make_extended_tuple_space(drop_numeric_constraints(xspc.base), drop_numeric_constraints(xspc.extender)));
 END_IF ;
 IF subspace_of_es(spc, es_numbers)THEN RETURN(number_superspace_of(spc));
 END_IF;
 RETURN(spc);
 END_FUNCTION; -- drop_numeric_constraints

FUNCTION enclose_cregion_in_pregion
	(crgn : cartesian_complex_number_region; centre : complex_number_literal) : polar_complex_number_region;
 LOCAL
 xitv, yitv : real_interval;
 is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN ;
 xmin, xmax, ymin, ymax, xc, yc : REAL  := 0.0;
 xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN  := FALSE ;
 rmin, rmax : REAL  := - 1.0;
 amin : REAL  := 4.0;
 amax : REAL  := - 4.0;
 rmax_exists, outside : BOOLEAN  := TRUE;
 rmin_in, rmax_in, amin_in, amax_in : BOOLEAN  := FALSE ;
 ab, a, r : REAL := 0.0;
 incl : BOOLEAN;
 ritv : real_interval;
 aitv : finite_real_interval;
 minclo, maxclo : open_closed := open;
 END_LOCAL
;
 IF  NOT  EXISTS(crgn)OR NOT  EXISTS(centre)THEN  RETURN(?);
 END_IF ;
 xitv := crgn.real_constraint;
 yitv := crgn.imag_constraint;
 xc := centre.real_part;
 yc := centre.imag_part;
 is_xmin := min_exists(xitv);
 is_xmax := max_exists(xitv);
 is_ymin := min_exists(yitv);
 is_ymax := max_exists(yitv);
 IF  is_xmin THEN  xmin := real_min(xitv);
 xmin_in := min_included(xitv);
 END_IF ;
 IF  is_xmax THEN  xmax := real_max(xitv);
 xmax_in := max_included(xitv);
 END_IF ;
 IF  is_ymin THEN  ymin := real_min(yitv);
 ymin_in := min_included(yitv);
 END_IF ;
 IF  is_ymax THEN  ymax := real_max(yitv);
 ymax_in := max_included(yitv);
 END_IF ;
 rmax_exists := is_xmin AND  is_xmax AND  is_ymin AND  is_ymax;
 IF  is_xmin AND(xc <= xmin)THEN  ab := 0.0;
 ELSE  IF  is_ymin AND(yc <= ymin)THEN  ab := 0.5 * PI ;
 ELSE  IF  is_ymax AND(yc >= ymax)THEN  ab := - 0.5 * PI ;
 ELSE  IF  is_xmax AND(xc >= xmax)THEN  ab := PI ;
 ELSE  outside := FALSE ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 IF  NOT  outside AND  NOT  rmax_exists THEN  RETURN(?);
 END_IF ;
 IF  is_xmin AND(xc <= xmin)AND  strictly_in(yc, yitv)THEN  rmin := xmin - xc;
 rmin_in := xmin_in;
 ELSE  IF  is_ymin AND(yc <= ymin)AND  strictly_in(xc, xitv)THEN  rmin := ymin - yc;
 rmin_in := ymin_in;
 ELSE  IF  is_ymax AND(yc >= ymax)AND  strictly_in(xc, xitv)THEN  rmin := yc - ymax;
 rmin_in := ymax_in;
 ELSE  IF  is_xmax AND(xc >= xmax)AND  strictly_in(yc, yitv)THEN  rmin := xc - xmax;
 rmin_in := xmax_in;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 IF  is_xmin THEN  IF  is_ymin THEN  r := SQRT((xmin - xc)** 2 +(ymin - yc)** 2);
 incl := xmin_in AND  ymin_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymin - yc, xmin - xc)- ab);
 IF  xc = xmin THEN  incl := xmin_in;
 END_IF ;
 IF  yc = ymin THEN  incl := ymin_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmin_in AND  ymin_in;
 amin := angle(0.0 - ab);
 amin_in := ymin_in;
 amax := angle(0.5 * PI  - ab);
 amax_in := xmin_in;
 END_IF ;
 END_IF ;
 ELSE  IF  xc <= xmin THEN  angle_minmax(ab, - 0.5 * PI ,(xc = xmin)AND  xmin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT  is_ymax AND(xc <= xmin)THEN  angle_minmax(ab, 0.5 * PI ,(xc = xmin)AND  xmin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  is_ymin THEN  IF  is_xmax THEN  r := SQRT((xmax - xc)** 2 +(ymin - yc)** 2);
 incl := xmax_in AND  ymin_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymin - yc, xmax - xc)- ab);
 IF  xc = xmax THEN  incl := xmax_in;
 END_IF ;
 IF  yc = ymin THEN  incl := ymin_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmax_in AND  ymin_in;
 amin := angle(0.5 * PI  - ab);
 amin_in := ymin_in;
 amax := angle(PI  - ab);
 amax_in := xmax_in;
 END_IF ;
 END_IF ;
 ELSE  IF  yc <= ymin THEN  angle_minmax(ab, 0.0,(yc = ymin)AND  ymin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT  is_xmin AND(yc <= ymin)THEN  angle_minmax(ab, PI ,(yc = ymin)AND  ymin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  is_xmax THEN  IF  is_ymax THEN  r := SQRT((xmax - xc)** 2 +(ymax - yc)** 2);
 incl := xmax_in AND  ymax_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymax - yc, xmax - xc)- ab);
 IF  xc = xmax THEN  incl := xmax_in;
 END_IF ;
 IF  yc = ymax THEN  incl := ymax_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmax_in AND  ymax_in;
 amin := angle(- PI  - ab);
 amin_in := ymax_in;
 amax := angle(- 0.5 * PI  - ab);
 amax_in := xmax_in;
 END_IF ;
 END_IF ;
 ELSE  IF  xc >= xmax THEN  angle_minmax(ab, 0.5 * PI ,(xc = xmax)AND  xmax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT  is_ymin AND(xc >= xmax)THEN  angle_minmax(ab, - 0.5 * PI ,(xc = xmax)AND  xmax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  is_ymax THEN  IF  is_xmin THEN  r := SQRT((xmin - xc)** 2 +(ymax - yc)** 2);
 incl := xmin_in AND  ymax_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymax - yc, xmin - xc)- ab);
 IF  xc = xmin THEN  incl := xmin_in;
 END_IF ;
 IF  yc = ymax THEN  incl := ymax_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmin_in AND  ymax_in;
 amin := angle(0.5 * PI  - ab);
 amin_in := ymax_in;
 amax := angle(PI  - ab);
 amax_in := xmin_in;
 END_IF ;
 END_IF ;
 ELSE  IF  yc >= ymax THEN  angle_minmax(ab, PI ,(yc = ymax)AND  ymax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT is_xmax AND(yc >= ymax)THEN  angle_minmax(ab, 0.0,(yc = ymax)AND ymax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  outside THEN  amin := angle(amin + ab);
 IF  amin = PI  THEN  amin := - PI ;
 END_IF ;
 amax := angle(amax + ab);
 IF  amax <= amin THEN  amax := amax + 2.0 * PI ;
 END_IF ;
 ELSE  amin := - PI ;
 amin_in := FALSE ;
 amax := PI;
 amax_in := FALSE;
 END_IF ;
 IF  amin_in THEN  minclo := closed;
 END_IF ;
 IF  amax_in THEN  maxclo := closed;
 END_IF ;
 aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
 minclo := open;
 IF  rmin_in THEN  minclo := closed;
 END_IF ;
 IF  rmax_exists THEN  maxclo := open;
 IF rmax_in THEN maxclo := closed;
 END_IF ;
 ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
 ELSE ritv := make_real_interval_from_min(rmin, minclo);
 END_IF;
 RETURN(make_polar_complex_number_region(centre, ritv, aitv));
 END_FUNCTION; -- enclose_cregion_in_pregion

FUNCTION enclose_pregion_in_cregion
	(prgn : polar_complex_number_region) : cartesian_complex_number_region;
 LOCAL
 xc, yc, xmin, xmax, ymin, ymax : REAL  := 0.0;
 ritv, xitv, yitv : real_interval;
 aitv : finite_real_interval;
 xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN ;
 xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN  := FALSE ;
 a, r : REAL := 0.0;
 a_in : BOOLEAN := FALSE ;
 min_clo, max_clo : open_closed := open;
 END_LOCAL
;
 IF  NOT  EXISTS(prgn)THEN  RETURN(?);
 END_IF ;
 xc := prgn.centre.real_part;
 yc := prgn.centre.imag_part;
 ritv := prgn.distance_constraint;
 aitv := prgn.direction_constraint;
 nearest_good_direction(PI , aitv, a, a_in);
 IF  COS(a)>= 0.0 THEN  xmin_exists := TRUE ;
 xmin := xc + real_min(ritv)* COS(a);
 xmin_in := a_in AND(min_included(ritv)OR(COS(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  xmin_exists := TRUE ;
 xmin := xc + real_max(ritv)* COS(a);
 xmin_in := a_in AND  max_included(ritv);
 ELSE  xmin_exists := FALSE ;
 END_IF ;
 END_IF ;
 nearest_good_direction(0.0, aitv, a, a_in);
 IF  COS(a)<= 0.0 THEN  xmax_exists := TRUE ;
 xmax := xc + real_min(ritv)* COS(a);
 xmax_in := a_in AND(min_included(ritv)OR(COS(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  xmax_exists := TRUE ;
 xmax := xc + real_max(ritv)* COS(a);
 xmax_in := a_in AND  max_included(ritv);
 ELSE  xmax_exists := FALSE ;
 END_IF ;
 END_IF ;
 nearest_good_direction(- 0.5 * PI , aitv, a, a_in);
 IF  SIN(a)>= 0.0 THEN  ymin_exists := TRUE ;
 ymin := yc + real_min(ritv)* SIN(a);
 ymin_in := a_in AND(min_included(ritv)OR(SIN(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  ymin_exists := TRUE ;
 ymin := yc + real_max(ritv)* SIN(a);
 ymin_in := a_in AND  max_included(ritv);
 ELSE  ymin_exists := FALSE ;
 END_IF ;
 END_IF ;
 nearest_good_direction(0.5 * PI, aitv, a, a_in);
 IF  SIN(a)<= 0.0 THEN  ymax_exists := TRUE ;
 ymax := yc + real_min(ritv)* SIN(a);
 ymax_in := a_in AND(min_included(ritv)OR(SIN(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  ymax_exists := TRUE;
 ymax := yc + real_max(ritv)* SIN(a);
 ymax_in := a_in AND max_included(ritv);
 ELSE  ymax_exists := FALSE;
 END_IF ;
 END_IF ;
 IF  NOT(xmin_exists OR  xmax_exists OR  ymin_exists OR ymax_exists)THEN  RETURN(?);
 END_IF ;
 IF  xmin_exists THEN  IF  xmin_in THEN  min_clo := closed;
 ELSE  min_clo := open;
 END_IF ;
 IF  xmax_exists THEN  IF  xmax_in THEN  max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 xitv := make_finite_real_interval(xmin, min_clo, xmax, max_clo);
 ELSE  xitv := make_real_interval_from_min(xmin, min_clo);
 END_IF ;
 ELSE  IF  xmax_exists THEN  IF  xmax_in THEN  max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 xitv := make_real_interval_to_max(xmax, max_clo);
 ELSE  xitv := the_reals;
 END_IF ;
 END_IF ;
 IF  ymin_exists THEN  IF  ymin_in THEN  min_clo := closed;
 ELSE  min_clo := open;
 END_IF ;
 IF  ymax_exists THEN  IF  ymax_in THEN  max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 yitv := make_finite_real_interval(ymin, min_clo, ymax, max_clo);
 ELSE  yitv := make_real_interval_from_min(ymin, min_clo);
 END_IF ;
 ELSE  IF  ymax_exists THEN  IF ymax_in THEN max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 yitv := make_real_interval_to_max(ymax, max_clo);
 ELSE yitv := the_reals;
 END_IF ;
 END_IF;
 RETURN(make_cartesian_complex_number_region(xitv, yitv));
 END_FUNCTION; -- enclose_pregion_in_cregion

FUNCTION enclose_pregion_in_pregion
	(prgn : polar_complex_number_region; centre : complex_number_literal) : polar_complex_number_region;
 LOCAL
 ritp, ritv : real_interval;
 aitp, aitv : finite_real_interval;
 xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL  := 0.0;
 rmax_in, rmin_in, amin_in, amax_in : BOOLEAN  := FALSE ;
 rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
 in0, in1, in2, in3, inn : BOOLEAN := FALSE ;
 minclo, maxclo : open_closed := open;
 END_LOCAL
;
 IF  NOT  EXISTS(prgn)OR  NOT  EXISTS(centre)THEN  RETURN(?);
 END_IF ;
 xp := prgn.centre.real_part;
 yp := prgn.centre.imag_part;
 ritp := prgn.distance_constraint;
 aitp := prgn.direction_constraint;
 xc := centre.real_part;
 yc := centre.imag_part;
 IF(xc = xp)AND(yc = yp)THEN  RETURN(prgn);
 END_IF ;
 rc := SQRT((xp - xc)** 2 +(yp - yc)** 2);
 acp := atan2(yp - yc, xp - xc);
 apc := atan2(yc - yp, xc - xp);
 rmnp := real_min(ritp);
 IF  max_exists(ritp)THEN  rmxp := real_max(ritp);
 IF  aitp.max - aitp.min = 2.0 * PI  THEN  inn := NOT  max_included(aitp);
 a := angle2(aitp.min);
 rmax := rc + rmxp;
 rmax_in := max_included(ritp);
 IF  inn AND(acp = a)THEN  rmax_in := FALSE ;
 END_IF ;
 IF  rc > rmxp THEN  a0 := ASIN(rmxp / rc);
 amin := angle2(acp - a0);
 amin_in := max_included(ritp);
 IF  amin = PI  THEN  amin := - PI ;
 END_IF ;
 amax := angle2(acp + a0);
 amax_in := amin_in;
 IF  amax < amin THEN  amax := amax + 2.0 * PI ;
 END_IF ;
 rmin := rc - rmxp;
 rmin_in := amin_in;
 IF  inn THEN  IF  apc = a THEN  rmin_in := FALSE ;
 END_IF ;
 IF  angle2(amin + 0.5 * PI)= a THEN  amin_in := FALSE ;
 END_IF ;
 IF  angle2(amax - 0.5 * PI)= a THEN  amax_in := FALSE ;
 END_IF ;
 END_IF ;
 ELSE  IF  rc = rmxp THEN  amin := angle2(acp - 0.5 * PI );
 amin_in := FALSE ;
 IF  amin = PI  THEN  amin := - PI ;
 END_IF ;
 amax := angle2(acp + 0.5 * PI );
 amax_in := FALSE ;
 IF  amax < amin THEN  amax := amax + 2.0 * PI ;
 END_IF ;
 rmin := 0.0;
 rmin_in := max_included(ritp);
 IF  inn AND(apc = a)THEN  rmin_in := FALSE ;
 END_IF ;
 ELSE  IF  rc > rmnp THEN  IF  inn AND(apc = a)THEN  rmin := 0.0;
 rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  rmin := 0.0;
 rmin_in := TRUE ;
 amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 END_IF ;
 ELSE  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 IF  inn THEN  IF  apc = a THEN  rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  IF  acp = a THEN  amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 ELSE  x := xp + rmxp * COS(aitp.min)- xc;
 y := yp + rmxp * SIN(aitp.min)- yc;
 r0 := SQRT(x ** 2 + y ** 2);
 in0 := max_included(ritp)AND  min_included(aitp);
 IF  r0 <> 0.0 THEN  a0 := atan2(y, x);
 END_IF ;
 x := xp + rmxp * COS(aitp.max)- xc;
 y := yp + rmxp * SIN(aitp.max)- yc;
 r1 := SQRT(x ** 2 + y ** 2);
 in1 := max_included(ritp)AND  max_included(aitp);
 IF  r1 <> 0.0 THEN  a1 := atan2(y, x);
 END_IF ;
 x := xp + rmnp * COS(aitp.max)- xc;
 y := yp + rmnp * SIN(aitp.max)- yc;
 r2 := SQRT(x ** 2 + y ** 2);
 in2 := min_included(ritp)AND  max_included(aitp);
 IF  r2 <> 0.0 THEN  a2 := atan2(y, x);
 ELSE  a2 := a1;
 in2 := in1;
 END_IF ;
 IF  r1 = 0.0 THEN  a1 := a2;
 in1 := in2;
 END_IF ;
 x := xp + rmnp * COS(aitp.min)- xc;
 y := yp + rmnp * SIN(aitp.min)- yc;
 r3 := SQRT(x ** 2 + y ** 2);
 in3 := min_included(ritp)AND  min_included(aitp);
 IF  r3 <> 0.0 THEN  a3 := atan2(y, x);
 ELSE  a3 := a0;
 in3 := in0;
 END_IF ;
 IF  r0 = 0.0 THEN  a0 := a3;
 in0 := in3;
 END_IF ;
 IF  rmnp = 0.0 THEN  in2 := min_included(ritp);
 in3 := in2;
 END_IF ;
 IF(apc = angle2(aitp.min))OR(acp = angle2(aitp.min))THEN  in0 := min_included(aitp);
 in3 := in0;
 ELSE  IF(apc = angle2(aitp.max))OR(acp = angle2(aitp.max))THEN  in1 := max_included(aitp);
 in2 := in1;
 END_IF ;
 END_IF ;
 IF  strictly_in2(acp, aitp)THEN  rmax := rc + rmxp;
 rmax_in := max_included(ritp);
 ELSE  rmax := r0;
 rmax_in := in0;
 IF  rmax = r1 THEN  rmax_in := rmax_in OR  in1;
 END_IF ;
 IF  rmax < r1 THEN  rmax := r1;
 rmax_in := in1;
 END_IF ;
 IF  rmax = r2 THEN  rmax_in := rmax_in OR  in2;
 END_IF ;
 IF  rmax < r2 THEN  rmax := r2;
 rmax_in := in2;
 END_IF ;
 IF  rmax = r3 THEN  rmax_in := rmax_in OR  in3;
 END_IF ;
 IF  rmax < r3 THEN  rmax := r3;
 rmax_in := in3;
 END_IF ;
 END_IF ;
 IF  strictly_in2(apc, aitp)THEN  IF  rc >= rmxp THEN  rmin := rc - rmxp;
 rmin_in := max_included(ritp);
 ELSE  IF  rc <= rmnp THEN  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 ELSE  rmin := 0.0;
 rmin_in := TRUE ;
 END_IF ;
 END_IF ;
 ELSE  rmin := r0;
 rmin_in := in0;
 a := apc - aitp.min;
 r := rc * COS(a);
 IF  { rmnp < r < rmxp } THEN  rmin := rc * SIN(ABS(a));
 rmin_in := min_included(aitp);
 END_IF ;
 a := apc - aitp.max;
 r := rc * COS(a);
 IF  { rmnp < r < rmxp } THEN  r := rc * SIN(ABS(a));
 inn := max_included(aitp);
 IF  r = rmin THEN  rmin_in := rmin_in OR  inn;
 END_IF ;
 IF  r < rmin THEN  rmin := r;
 rmin_in := inn;
 END_IF ;
 END_IF ;
 IF  r1 = rmin THEN  rmin_in := rmin_in OR  in1;
 END_IF ;
 IF  r1 < rmin THEN  rmin := r1;
 rmin_in := in1;
 END_IF ;
 IF  r2 = rmin THEN  rmin_in := rmin_in OR  in2;
 END_IF ;
 IF  r2 < rmin THEN  rmin := r2;
 rmin_in := in2;
 END_IF ;
 IF  r3 = rmin THEN  rmin_in := rmin_in OR  in3;
 END_IF ;
 IF  r3 < rmin THEN  rmin := r3;
 rmin_in := in3;
 END_IF ;
 END_IF ;
 IF  rc >= rmxp THEN  ab := acp;
 find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
 a := ACOS(rmxp / rc);
 IF  strictly_in2(apc - a, aitp)THEN  amin := ab - ASIN(rmxp / rc);
 amin_in := max_included(ritp);
 END_IF ;
 IF  strictly_in2(apc + a, aitp)THEN  amax := ab + ASIN(rmxp / rc);
 amax_in := max_included(ritp);
 END_IF ;
 angle_range(amin, amax);
 ELSE  IF  rc > rmnp THEN  ab := angle2(0.5 *(aitp.min + aitp.max));
 find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
 ELSE  ab := angle2(0.5 *(aitp.min + aitp.max));
 a0 := angle2(a0 - ab);
 a1 := angle2(a1 - ab);
 a2 := angle2(a2 - ab);
 a3 := angle2(a3 - ab);
 IF  a3 > a2 THEN  a2 := a2 + 2.0 * PI ;
 END_IF ;
 IF  a0 > a1 THEN  a0 := a0 + 2.0 * PI ;
 END_IF ;
 IF  a3 < a0 THEN  amin := a3;
 amin_in := in3;
 ELSE  amin := a0;
 amin_in := in0;
 END_IF ;
 IF  a2 > a1 THEN  amax := a2;
 amax_in := in2;
 ELSE  amax := a1;
 amax_in := in1;
 END_IF ;
 IF(amax - amin > 2.0 * PI)OR((amax - amin = 2.0 * PI)AND(amin_in OR  amax_in))THEN  amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 ELSE  amin := amin + ab;
 amax := amax + ab;
 angle_range(amin, amax);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 IF  rmin_in THEN  minclo := closed;
 END_IF ;
 IF  rmax_in THEN  maxclo := closed;
 END_IF ;
 ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
 ELSE  IF(rc > rmnp)AND  strictly_in2(apc, aitp)THEN  RETURN(?);
 END_IF ;
 IF  aitp.max - aitp.min = 2.0 * PI  THEN  a := angle2(aitp.min);
 IF  rc > rmnp THEN  IF  max_included(aitp)THEN  RETURN(?);
 END_IF ;
 rmin := 0.0;
 rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 IF  NOT max_included(aitp)THEN  IF  apc = a THEN  rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  IF  acp = a THEN  amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 ELSE  a0 := angle2(aitp.min);
 in0 := FALSE ;
 a1 := angle2(aitp.max);
 in1 := FALSE ;
 x := xp + rmnp * COS(aitp.max)- xc;
 y := yp + rmnp * SIN(aitp.max)- yc;
 r2 := SQRT(x ** 2 + y ** 2);
 in2 := min_included(ritp)AND  max_included(aitp);
 IF  r2 <> 0.0 THEN  a2 := atan2(y, x);
 ELSE  a2 := a1;
 in2 := in1;
 END_IF ;
 x := xp + rmnp * COS(aitp.min)- xc;
 y := yp + rmnp * SIN(aitp.min)- yc;
 r3 := SQRT(x ** 2 + y ** 2);
 in3 := min_included(ritp)AND  min_included(aitp);
 IF  r3 <> 0.0 THEN  a3 := atan2(y, x);
 ELSE  a3 := a0;
 in3 := in0;
 END_IF ;
 IF  rmnp = 0.0 THEN  in2 := min_included(ritp);
 in3 := in2;
 END_IF ;
 IF(apc = angle2(aitp.min))OR(acp = angle2(aitp.min))THEN  in0 := min_included(aitp);
 in3 := in0;
 ELSE  IF(apc = angle2(aitp.max))OR(acp = angle2(aitp.max))THEN  in1 := max_included(aitp);
 in2 := in1;
 END_IF ;
 END_IF ;
 IF  strictly_in2(apc, aitp)THEN  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 ELSE  rmin := r2;
 rmin_in := in2;
 a := apc - aitp.min;
 r := rc * COS(a);
 IF  rmnp < r THEN  rmin := rc * SIN(ABS(a));
 rmin_in := min_included(aitp);
 END_IF ;
 a := apc - aitp.max;
 r := rc * COS(a);
 IF  rmnp < r THEN  r := rc * SIN(ABS(a));
 inn := max_included(aitp);
 IF  r = rmin THEN  rmin_in := rmin_in OR  inn;
 END_IF ;
 IF  r < rmin THEN  rmin := r;
 rmin_in := inn;
 END_IF ;
 END_IF ;
 IF  r3 = rmin THEN  rmin_in := rmin_in OR  in3;
 END_IF ;
 IF  r3 < rmin THEN  rmin := r3;
 rmin_in := in3;
 END_IF ;
 END_IF ;
 ab := angle2(0.5 *(aitp.min + aitp.max));
 IF  rc > rmnp THEN  find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
 ELSE  a0 := angle2(a0 - ab);
 a1 := angle2(a1 - ab);
 a2 := angle2(a2 - ab);
 a3 := angle2(a3 - ab);
 IF  a3 > a2 THEN  a2 := a2 + 2.0 * PI ;
 END_IF ;
 IF  a0 > a1 THEN  a0 := a0 + 2.0 * PI ;
 END_IF ;
 IF  a3 < a0 THEN  amin := a3;
 amin_in := in3;
 ELSE  amin := a0;
 amin_in := in0;
 END_IF ;
 IF  a2 > a1 THEN  amax := a2;
 amax_in := in2;
 ELSE  amax := a1;
 amax_in := in1;
 END_IF ;
 IF(amax - amin > 2.0 * PI)OR((amax - amin = 2.0 * PI)AND(amin_in OR amax_in))THEN  amin := - PI ;
 amin_in := FALSE;
 amax := PI;
 amax_in := TRUE;
 IF(rmin = 0.0)AND rmin_in THEN  RETURN(?);
 END_IF ;
 ELSE amin := amin + ab;
 amax := amax + ab;
 angle_range(amin, amax);
 END_IF ;
 END_IF ;
 END_IF ;
 IF  rmin_in THEN  minclo := closed;
 END_IF ;
 ritv := make_real_interval_from_min(rmin, minclo);
 END_IF ;
 minclo := open;
 maxclo := open;
 IF  amin_in THEN  minclo := closed;
 END_IF ;
 IF amax_in THEN maxclo := closed;
 END_IF;
 aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
 RETURN(make_polar_complex_number_region(centre, ritv, aitv));
 END_FUNCTION; -- enclose_pregion_in_pregion

FUNCTION equal_cregion_pregion
	(crgn : cartesian_complex_number_region; prgn : polar_complex_number_region) : LOGICAL;
 LOCAL
 arng, amin, xc, yc : REAL;
 aitv, xitv, yitv : real_interval;
 c_in : BOOLEAN;
 END_LOCAL
;
 IF  NOT  EXISTS(crgn)OR  NOT  EXISTS(prgn)THEN  RETURN(FALSE );
 END_IF ;
 IF  max_exists(prgn.distance_constraint)THEN  RETURN(FALSE );
 END_IF ;
 IF  real_min(prgn.distance_constraint)<> 0.0 THEN  RETURN(FALSE );
 END_IF ;
 c_in := min_included(prgn.distance_constraint);
 aitv := prgn.direction_constraint;
 amin := aitv.min;
 arng := aitv.max - amin;
 xc := prgn.centre.real_part;
 yc := prgn.centre.imag_part;
 xitv := crgn.real_constraint;
 yitv := crgn.imag_constraint;
 IF  arng = 0.5 * PI  THEN  IF  amin = 0.0 THEN  RETURN(NOT  max_exists(xitv)AND  NOT  max_exists(yitv)AND  min_exists(xitv)AND  min_exists(yitv)AND(real_min(xitv)= xc)AND(real_min(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  NOT  min_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  NOT  min_included(yitv))));
 END_IF ;
 IF  amin = 0.5 * PI  THEN  RETURN(max_exists(xitv)AND  NOT  max_exists(yitv)AND  NOT  min_exists(xitv)AND  min_exists(yitv)AND(real_max(xitv)= xc)AND(real_min(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  NOT  min_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  NOT  min_included(yitv))));
 END_IF ;
 IF  amin = - PI  THEN  RETURN(max_exists(xitv)AND  max_exists(yitv)AND  NOT  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_max(xitv)= xc)AND(real_max(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  NOT  max_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  NOT  max_included(yitv))));
 END_IF ;
 IF  amin = - 0.5 * PI  THEN  RETURN(NOT  max_exists(xitv)AND  max_exists(yitv)AND  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_min(xitv)= xc)AND(real_max(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  NOT  max_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  NOT  max_included(yitv))));
 END_IF ;
 END_IF ;
 IF  arng = PI  THEN  IF  amin = 0.0 THEN  RETURN(NOT  max_exists(xitv)AND  NOT  max_exists(yitv)AND  NOT  min_exists(xitv)AND  min_exists(yitv)AND(real_min(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(yitv))));
 END_IF ;
 IF  amin = 0.5 * PI  THEN  RETURN(max_exists(xitv)AND  NOT  max_exists(yitv)AND  NOT  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_max(xitv)= xc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv))));
 END_IF ;
 IF  amin = - PI  THEN  RETURN(NOT  max_exists(xitv)AND  max_exists(yitv)AND  NOT  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_max(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(yitv))));
 END_IF ;
 IF amin = - 0.5 * PI THEN RETURN(NOT  max_exists(xitv)AND  NOT  max_exists(yitv)AND  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_min(xitv)= xc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND NOT min_included(xitv))));
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- equal_cregion_pregion

FUNCTION equal_maths_functions
	(fun1 : maths_function; fun2 : maths_function) : LOGICAL;
 LOCAL
 cum : LOGICAL;
 END_LOCAL
;
 IF  fun1 = fun2 THEN  RETURN(TRUE);
 END_IF ;
 cum := equal_maths_spaces(fun1.domain, fun2.domain);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 cum := cum AND equal_maths_spaces(fun1.range, fun2.range);
 IF cum = FALSE  THEN RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- equal_maths_functions

FUNCTION equal_maths_spaces
	(spc1 : maths_space; spc2 : maths_space) : LOGICAL;
 LOCAL
 spc1types : SET  OF  STRING  := stripped_typeof(spc1);
 spc2types : SET  OF  STRING := stripped_typeof(spc2);
 set1, set2 : SET OF  maths_value;
 cum : LOGICAL  := TRUE ;
 base : maths_space;
 expnt : INTEGER;
 factors : LIST  OF  maths_space;
 factors2 : LIST OF maths_space;
 fs1, fs2 : function_space;
 cum2 : LOGICAL;
 END_LOCAL
;
 IF  spc1 = spc2 THEN  RETURN(TRUE );
 END_IF ;
 IF  'FINITE_SPACE' IN  spc1types THEN  set1 := spc1 \ finite_space.members;
 IF  'FINITE_SPACE' IN  spc2types THEN  set2 := spc2 \ finite_space.members;
 REPEAT  i := 1 TO  SIZEOF(set1);
 cum := cum AND  member_of(set1 [ i ], spc2);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 IF  cum = TRUE THEN  REPEAT  i := 1 TO  SIZEOF(set2);
 cum := cum AND  member_of(set2 [ i ], spc1);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_IF ;
 RETURN(cum);
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN  spc2types THEN  set2 := [ ];
 REPEAT  i := spc2 \ finite_integer_interval.min TO  spc2 \ finite_integer_interval.max;
 set2 := set2 + [ i ];
 END_REPEAT ;
 RETURN(equal_maths_spaces(spc1, make_finite_space(set2)));
 END_IF ;
 END_IF ;
 IF('FINITE_INTEGER_INTERVAL' IN  spc1types)AND('FINITE_SPACE' IN  spc2types)THEN  set1 := [ ];
 REPEAT  i := spc1 \ finite_integer_interval.min TO  spc1 \ finite_integer_interval.max;
 set1 := set1 + [ i ];
 END_REPEAT ;
 RETURN(equal_maths_spaces(make_finite_space(set1), spc2));
 END_IF ;
 IF('CARTESIAN_COMPLEX_NUMBER_REGION' IN  spc1types)AND('POLAR_COMPLEX_NUMBER_REGION' IN  spc2types)THEN  RETURN(equal_cregion_pregion(spc1, spc2));
 END_IF ;
 IF('POLAR_COMPLEX_NUMBER_REGION' IN  spc1types)AND('CARTESIAN_COMPLEX_NUMBER_REGION' IN  spc2types)THEN  RETURN(equal_cregion_pregion(spc2, spc1));
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  spc1types THEN  base := spc1 \ uniform_product_space.base;
 expnt := spc1 \ uniform_product_space.exponent;
 IF  'UNIFORM_PRODUCT_SPACE' IN  spc2types THEN  IF  expnt <> spc2 \ uniform_product_space.exponent THEN  RETURN(FALSE );
 END_IF ;
 RETURN(equal_maths_spaces(base, spc2 \ uniform_product_space.base));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  spc2types THEN  factors := spc2 \ listed_product_space.factors;
 IF  expnt <> SIZEOF(factors)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(factors);
 cum := cum AND  equal_maths_spaces(base, factors [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  spc1types THEN  factors := spc1 \ listed_product_space.factors;
 IF  'UNIFORM_PRODUCT_SPACE' IN  spc2types THEN  IF  spc2 \ uniform_product_space.exponent <> SIZEOF(factors)THEN  RETURN(FALSE );
 END_IF ;
 base := spc2 \ uniform_product_space.base;
 REPEAT  i := 1 TO  SIZEOF(factors);
 cum := cum AND  equal_maths_spaces(base, factors [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  spc2types THEN  factors2 := spc2 \ listed_product_space.factors;
 IF  SIZEOF(factors)<> SIZEOF(factors2)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(factors);
 cum := cum AND  equal_maths_spaces(factors [ i ], factors2 [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 END_IF ;
 IF('EXTENDED_TUPLE_SPACE' IN  spc1types)AND('EXTENDED_TUPLE_SPACE' IN  spc2types)THEN  RETURN(equal_maths_spaces(spc1 \ extended_tuple_space.extender, spc2 \ extended_tuple_space.extender)AND  equal_maths_spaces(spc1 \ extended_tuple_space.base, spc2 \ extended_tuple_space.base));
 END_IF ;
 IF('FUNCTION_SPACE' IN  spc1types)AND('FUNCTION_SPACE' IN  spc2types)THEN  fs1 := spc1;
 fs2 := spc2;
 IF  fs1.domain_constraint <> fs2.domain_constraint THEN  IF(fs1.domain_constraint = sc_equal)OR(fs2.domain_constraint = sc_equal)THEN  RETURN(FALSE );
 END_IF ;
 IF(fs1.domain_constraint <> sc_subspace)THEN  fs1 := spc2;
 fs2 := spc1;
 END_IF ;
 IF(fs1.domain_constraint <> sc_subspace)OR(fs2.domain_constraint <> sc_member)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF  any_space_satisfies(fs1.domain_constraint, fs1.domain_argument)<> any_space_satisfies(fs2.domain_constraint, fs2.domain_argument)THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT('FINITE_SPACE' IN  stripped_typeof(fs2.domain_argument))THEN  RETURN(FALSE );
 END_IF ;
 IF  SIZEOF([ 'FINITE_SPACE', 'FINITE_INTEGER_INTERVAL' ] * stripped_typeof(fs1.domain_argument))= 0 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 cum := equal_maths_spaces(fs1.domain_argument, fs2.domain_argument);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 IF  fs1.range_constraint <> fs2.range_constraint THEN  IF(fs1.range_constraint = sc_equal)OR(fs2.range_constraint = sc_equal)THEN  RETURN(FALSE );
 END_IF ;
 IF(fs1.range_constraint <> sc_subspace)THEN  fs1 := spc2;
 fs2 := spc1;
 END_IF ;
 IF(fs1.range_constraint <> sc_subspace)OR(fs2.range_constraint <> sc_member)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF  any_space_satisfies(fs1.range_constraint, fs1.range_argument)<> any_space_satisfies(fs2.range_constraint, fs2.range_argument)THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT('FINITE_SPACE' IN stripped_typeof(fs2.range_argument))THEN  RETURN(FALSE );
 END_IF ;
 IF SIZEOF([ 'FINITE_SPACE', 'FINITE_INTEGER_INTERVAL' ] * stripped_typeof(fs1.range_argument))= 0 THEN RETURN(FALSE );
 END_IF ;
 RETURN(UNKNOWN);
 END_IF ;
 cum := cum AND equal_maths_spaces(fs1.range_argument, fs2.range_argument);
 RETURN(cum);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- equal_maths_spaces

FUNCTION equal_maths_values
	(val1 : maths_value; val2 : maths_value) : LOGICAL;
 LOCAL
 types1, types2 : SET OF  STRING;
 list1, list2 : LIST OF maths_value;
 cum : LOGICAL := TRUE ;
 END_LOCAL
;
 IF  NOT  EXISTS(val1)OR  NOT  EXISTS(val2)THEN  RETURN(FALSE );
 END_IF ;
 IF  val1 = val2 THEN  RETURN(TRUE);
 END_IF ;
 types1 := stripped_typeof(val1);
 types2 := stripped_typeof(val2);
 IF('MATHS_ATOM' IN  types1)OR('COMPLEX_NUMBER_LITERAL' IN  types1)THEN  IF  'MATHS_ATOM' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'COMPLEX_NUMBER_LITERAL' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'LIST' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'MATHS_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF('MATHS_ATOM' IN  types2)OR('COMPLEX_NUMBER_LITERAL' IN  types2)THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF  'LIST' IN  types1 THEN  IF  'LIST' IN  types2 THEN  list1 := val1;
 list2 := val2;
 IF  SIZEOF(list1)<> SIZEOF(list2)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(list1);
 cum := cum AND  equal_maths_values(list1 [ i ], list2 [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 IF  'MATHS_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'LIST' IN  types2 THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF  'MATHS_SPACE' IN  types1 THEN  IF  'MATHS_SPACE' IN  types2 THEN  RETURN(equal_maths_spaces(val1, val2));
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'MATHS_SPACE' IN  types2 THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types1 THEN  IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(equal_maths_functions(val1, val2));
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF('GENERIC_EXPRESSION' IN  types1)AND('GENERIC_EXPRESSION' IN types2)THEN  IF  NOT  has_values_space(val1)OR NOT  has_values_space(val2)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF NOT compatible_spaces(values_space_of(val1), values_space_of(val2))THEN RETURN(FALSE);
 END_IF ;
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- equal_maths_values

FUNCTION es_subspace_of_es
	(es1 : elementary_space_enumerators; es2 : elementary_space_enumerators) : BOOLEAN;
 IF  NOT  EXISTS(es1)OR  NOT EXISTS(es2)THEN  RETURN(FALSE );
 END_IF ;
 IF  es1 = es2 THEN  RETURN(TRUE );
 END_IF ;
 IF  es2 = es_generics THEN  RETURN(TRUE );
 END_IF ;
 IF(es1 = es_booleans)AND(es2 = es_logicals)THEN  RETURN(TRUE );
 END_IF ;
 IF(es2 = es_numbers)AND((es1 = es_complex_numbers)OR(es1 = es_reals)OR(es1 = es_integers))THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- es_subspace_of_es

FUNCTION expression_is_constant
	(expr : generic_expression) : BOOLEAN;
 RETURN(bool(SIZEOF(free_variables_of(expr))= 0));
 END_FUNCTION; -- expression_is_constant

FUNCTION extract_factors
	(tspace : tuple_space; m : INTEGER; n : INTEGER) : tuple_space;
 LOCAL
 tsp : tuple_space := the_zero_tuple_space;
 END_LOCAL
;
 REPEAT i := m TO n;
 tsp := assoc_product_space(tsp, factor_space(tspace, i));
 END_REPEAT;
 RETURN(tsp);
 END_FUNCTION; -- extract_factors

FUNCTION extremal_position_check
	(fun : linearized_table_function) : BOOLEAN;
 LOCAL
 source_domain : maths_space;
 source_interval : finite_integer_interval;
 index : INTEGER  := 1;
 base : INTEGER ;
 shape : LIST  OF  positive_integer;
 ndim : positive_integer;
 slo, shi : INTEGER ;
 sublo : LIST  OF  INTEGER  := [ ];
 subhi : LIST OF INTEGER := [ ];
 END_LOCAL
;
 IF  NOT  EXISTS(fun)THEN  RETURN(FALSE );
 END_IF ;
 source_domain := factor1(fun.source.domain);
 IF(schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(source_domain)THEN  source_domain := factor1(source_domain);
 END_IF ;
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  TYPEOF(source_domain))THEN  RETURN(FALSE );
 END_IF ;
 source_interval := source_domain;
 base := fun \ explicit_table_function.index_base;
 shape := fun \ explicit_table_function.shape;
 IF(schema_prefix + 'STANDARD_TABLE_FUNCTION')IN  TYPEOF(fun)THEN  REPEAT  j := 1 TO  SIZEOF(shape);
 index := index * shape [ j ];
 END_REPEAT ;
 index := fun.first + index - 1;
 RETURN(bool({ source_interval.min <= index <= source_interval.max }));
 END_IF ;
 IF(schema_prefix + 'REGULAR_TABLE_FUNCTION')IN TYPEOF(fun)THEN  ndim := SIZEOF(fun \ explicit_table_function.shape);
 REPEAT j := 1 TO ndim;
 slo := base;
 shi := base + shape [ j ] - 1;
 IF  fun \ regular_table_function.increments [ j ] >= 0 THEN  INSERT(sublo, slo, j - 1);
 INSERT(subhi, shi, j - 1);
 ELSE INSERT(sublo, shi, j - 1);
 INSERT(subhi, slo, j - 1);
 END_IF ;
 END_REPEAT;
 index := regular_indexing(sublo, base, shape, fun \ regular_table_function.increments, fun.first);
 IF  NOT({ source_interval.min <= index <= source_interval.max })THEN  RETURN(FALSE );
 END_IF ;
 index := regular_indexing(subhi, base, shape, fun \ regular_table_function.increments, fun.first);
 IF NOT({ source_interval.min <= index <= source_interval.max })THEN RETURN(FALSE );
 END_IF ;
 RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- extremal_position_check

FUNCTION factor1
	(tspace : tuple_space) : maths_space;
 LOCAL
 typenames : SET OF STRING := TYPEOF(tspace);
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  typenames THEN  RETURN(tspace \ uniform_product_space.base);
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  typenames THEN  RETURN(tspace \ listed_product_space.factors [ 1 ]);
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN typenames THEN RETURN(factor1(tspace \ extended_tuple_space.base));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- factor1

FUNCTION factor_space
	(tspace : tuple_space; idx : positive_integer) : maths_space;
 LOCAL
 typenames : SET OF STRING := TYPEOF(tspace);
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  typenames THEN  IF  idx <= tspace \ uniform_product_space.exponent THEN  RETURN(tspace \ uniform_product_space.base);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  typenames THEN  IF  idx <= SIZEOF(tspace \ listed_product_space.factors)THEN  RETURN(tspace \ listed_product_space.factors [ idx ]);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN typenames THEN  IF idx <= space_dimension(tspace \ extended_tuple_space.base)THEN RETURN(factor_space(tspace \ extended_tuple_space.base, idx));
 END_IF ;
 RETURN(tspace \ extended_tuple_space.extender);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- factor_space

FUNCTION fedex
	(val : AGGREGATE OF GENERIC; i : INTEGER) : GENERIC:X;
 RETURN(val [ i ]);
 END_FUNCTION; -- fedex

FUNCTION free_variables_of
	(expr : generic_expression) : SET [0:?] OF generic_variable;
 LOCAL
 typenames : SET  OF  STRING := stripped_typeof(expr);
 result : SET OF  generic_variable := [ ];
 exprs : LIST OF generic_expression := [ ];
 END_LOCAL
;
 IF  'GENERIC_LITERAL' IN  typenames THEN  RETURN(result);
 END_IF ;
 IF  'GENERIC_VARIABLE' IN  typenames THEN  result := result + expr;
 RETURN(result);
 END_IF ;
 IF  'QUANTIFIER_EXPRESSION' IN  typenames THEN  exprs := QUERY(ge <* expr \ multiple_arity_generic_expression.operands | NOT(ge IN  expr \ quantifier_expression.variables));
 REPEAT  i := 1 TO  SIZEOF(exprs);
 result := result + free_variables_of(exprs [ i ]);
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(expr \ quantifier_expression.variables);
 result := result - expr \ quantifier_expression.variables [ i ];
 END_REPEAT ;
 RETURN(result);
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  typenames THEN  RETURN(free_variables_of(expr \ unary_generic_expression.operand));
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  typenames THEN  result := free_variables_of(expr \ binary_generic_expression.operands [ 1 ]);
 RETURN(result + free_variables_of(expr \ binary_generic_expression.operands [ 2 ]));
 END_IF ;
 IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN REPEAT i := 1 TO SIZEOF(expr \ multiple_arity_generic_expression.operands);
 result := result + free_variables_of(expr \ multiple_arity_generic_expression.operands [ i ]);
 END_REPEAT;
 RETURN(result);
 END_IF;
 RETURN(result);
 END_FUNCTION; -- free_variables_of

FUNCTION function_applicability
	(func : maths_function_select; arguments : LIST [1:?] OF maths_value) : BOOLEAN;
 LOCAL
 domain : tuple_space := convert_to_maths_function(func).domain;
 domain_types : SET OF STRING := TYPEOF(domain);
 narg : positive_integer := SIZEOF(arguments);
 arg : generic_expression;
 END_LOCAL
;
 IF(schema_prefix + 'PRODUCT_SPACE')IN  domain_types THEN  IF  space_dimension(domain)<> narg THEN  RETURN(FALSE );
 END_IF ;
 ELSE  IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN domain_types THEN  IF  space_dimension(domain)> narg THEN  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE );
 END_IF ;
 END_IF ;
 REPEAT i := 1 TO narg;
 arg := convert_to_operand(arguments [ i ]);
 IF  NOT  has_values_space(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF NOT compatible_spaces(factor_space(domain, i), values_space_of(arg))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- function_applicability

FUNCTION function_is_1d_array
	(func : maths_function) : BOOLEAN;
 LOCAL
 temp : maths_space;
 END_LOCAL
;
 IF  NOT EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 IF  space_dimension(func.domain)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(func.domain);
 IF(schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(temp)THEN  IF  space_dimension(temp)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(temp);
 END_IF ;
 IF(schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp)THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- function_is_1d_array

FUNCTION function_is_1d_table
	(func : maths_function) : BOOLEAN;
 LOCAL
 temp : maths_space;
 itvl : finite_integer_interval;
 END_LOCAL
;
 IF  NOT EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 IF  space_dimension(func.domain)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(func.domain);
 IF(schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(temp)THEN  IF  space_dimension(temp)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(temp);
 END_IF ;
 IF(schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp)THEN itvl := temp;
 RETURN(bool((itvl.min = 0)OR(itvl.min = 1)));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- function_is_1d_table

FUNCTION function_is_2d_table
	(func : maths_function) : BOOLEAN;
 LOCAL
 temp : maths_space;
 pspace : product_space;
 itvl1, itvl2 : finite_integer_interval;
 END_LOCAL
;
 IF  NOT  EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 IF  space_dimension(func.domain)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(func.domain);
 IF  NOT('PRODUCT_SPACE' IN  stripped_typeof(temp))THEN  RETURN(FALSE );
 END_IF ;
 pspace := temp;
 IF  space_dimension(pspace)<> 2 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(pspace);
 IF  NOT('FINITE_INTEGER_INTERVAL' IN  stripped_typeof(temp))THEN  RETURN(FALSE );
 END_IF ;
 itvl1 := temp;
 temp := factor_space(pspace, 2);
 IF NOT('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))THEN RETURN(FALSE);
 END_IF;
 itvl2 := temp;
 RETURN(bool((itvl1.min = itvl2.min)AND((itvl1.min = 0)OR(itvl1.min = 1))));
 END_FUNCTION; -- function_is_2d_table

FUNCTION function_is_array
	(func : maths_function) : BOOLEAN;
 LOCAL
 tspace : tuple_space;
 temp : maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(tspace)))THEN  tspace := factor1(tspace);
 END_IF ;
 IF  NOT((schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(tspace))THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO space_dimension(tspace);
 temp := factor_space(tspace, i);
 IF NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- function_is_array

FUNCTION function_is_table
	(func : maths_function) : BOOLEAN;
 LOCAL
 tspace : tuple_space;
 temp : maths_space;
 base : INTEGER;
 END_LOCAL
;
 IF  NOT  EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(tspace)))THEN  tspace := factor1(tspace);
 END_IF ;
 IF  NOT((schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(tspace))THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(tspace);
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  TYPEOF(temp))THEN  RETURN(FALSE );
 END_IF ;
 base := temp \ finite_integer_interval.min;
 IF(base <> 0)AND(base <> 1)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 2 TO space_dimension(tspace);
 temp := factor_space(tspace, i);
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN  RETURN(FALSE );
 END_IF ;
 IF temp \ finite_integer_interval.min <> base THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- function_is_table

FUNCTION good_t
	(v : maths_value; tn : STRING) : BOOLEAN;
 LOCAL
 tpl : LIST OF maths_value;
 END_LOCAL
;
 IF  'LIST' IN  TYPEOF(v)THEN  tpl := v;
 REPEAT i := 1 TO SIZEOF(tpl);
 IF NOT(tn IN TYPEOF(tpl [ i ]))THEN RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- good_t

FUNCTION has_values_space
	(expr : generic_expression) : BOOLEAN;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(expr);
 END_LOCAL
;
 IF  'EXPRESSION' IN  typenames THEN  RETURN(bool(('NUMERIC_EXPRESSION' IN  typenames)OR('STRING_EXPRESSION' IN  typenames)OR('BOOLEAN_EXPRESSION' IN  typenames)));
 END_IF ;
 IF  'MATHS_FUNCTION' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'FUNCTION_APPLICATION' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_SPACE' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_VARIABLE' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'DEPENDENT_VARIABLE_DEFINITION' IN  typenames THEN  RETURN(has_values_space(expr \ unary_generic_expression.operand));
 END_IF ;
 IF  'COMPLEX_NUMBER_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'LOGICAL_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'BINARY_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_ENUM_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'REAL_TUPLE_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'INTEGER_TUPLE_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'ATOM_BASED_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_TUPLE_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'PARTIAL_DERIVATIVE_EXPRESSION' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- has_values_space

FUNCTION list_selected_components
	(aggr : AGGREGATE OF LIST [0:?] OF maths_value; k : positive_integer) : LIST [0:?] OF maths_value;
 LOCAL
 result : LIST OF maths_value := [ ];
 j : INTEGER := 0;
 END_LOCAL
;
 REPEAT i := LOINDEX(aggr)TO HIINDEX(aggr);
 IF k <= SIZEOF(aggr [ i ])THEN INSERT(result, aggr [ i ] [ k ], j);
 j := j + 1;
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- list_selected_components

FUNCTION make_abstracted_expression_function
	(operands : LIST [2:?] OF generic_expression) : abstracted_expression_function;
 RETURN(abstracted_expression_function()|| maths_function()|| generic_expression()|| quantifier_expression(remove_first(operands))|| multiple_arity_generic_expression(operands));
 END_FUNCTION; -- make_abstracted_expression_function

FUNCTION make_atom_based_literal
	(lit_value : atom_based_value) : atom_based_literal;
 RETURN(atom_based_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_atom_based_literal

FUNCTION make_b_spline_basis
	(degree : nonnegative_integer; repeated_knots : LIST [2:?] OF REAL) : b_spline_basis;
 RETURN(b_spline_basis(degree, repeated_knots)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_b_spline_basis

FUNCTION make_b_spline_function
	(coef : maths_function; bases : LIST [1:?] OF b_spline_basis) : b_spline_function;
 RETURN(b_spline_function(bases)|| maths_function()|| generic_expression()|| unary_generic_expression(coef));
 END_FUNCTION; -- make_b_spline_function

FUNCTION make_banded_matrix
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; source : maths_function; first : INTEGER; default_entry : maths_value; below : INTEGER; above : INTEGER; order : ordering_type) : banded_matrix;
 RETURN(banded_matrix(default_entry, below, above, order)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(source));
 END_FUNCTION; -- make_banded_matrix

FUNCTION make_basic_sparse_matrix
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; operands : LIST [3:3] OF maths_function; default_entry : maths_value; order : ordering_type) : basic_sparse_matrix;
 RETURN(basic_sparse_matrix(default_entry, order)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| multiple_arity_generic_expression(operands));
 END_FUNCTION; -- make_basic_sparse_matrix

FUNCTION make_binary_literal
	(lit_value : BINARY) : binary_literal;
 RETURN(binary_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_binary_literal

FUNCTION make_boolean_literal
	(lit_value : BOOLEAN) : boolean_literal;
 RETURN(boolean_literal(lit_value)|| simple_boolean_expression()|| boolean_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_boolean_literal

FUNCTION make_cartesian_complex_number_region
	(real_constraint : real_interval; imag_constraint : real_interval) : cartesian_complex_number_region;
 RETURN(cartesian_complex_number_region(real_constraint, imag_constraint)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_cartesian_complex_number_region

FUNCTION make_complex_number_literal
	(rpart : REAL; ipart : REAL) : complex_number_literal;
 RETURN(complex_number_literal(rpart, ipart)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_complex_number_literal

FUNCTION make_constant_function
	(sole_value : maths_value; src_of_domn : maths_space_or_function) : constant_function;
 RETURN(constant_function(sole_value, src_of_domn)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_constant_function

FUNCTION make_cos_expression
	(operand : numeric_expression) : cos_function;
 RETURN(cos_expression()|| unary_numeric_call_expression()|| unary_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_cos_expression

FUNCTION make_definite_integral_expression
	(operands : LIST [2:4] OF generic_expression; loinf : BOOLEAN; upinf : BOOLEAN) : definite_integral_expression;
 RETURN(definite_integral_expression(loinf, upinf)|| quantifier_expression([ operands [ 2 ] ])|| multiple_arity_generic_expression(operands)|| generic_expression());
 END_FUNCTION; -- make_definite_integral_expression

FUNCTION make_definite_integral_function
	(integrand : maths_function; varintg : input_selector; loinf : BOOLEAN; upinf : BOOLEAN) : definite_integral_function;
 RETURN(definite_integral_function(varintg, loinf, upinf)|| maths_function()|| generic_expression()|| unary_generic_expression(integrand));
 END_FUNCTION; -- make_definite_integral_function

FUNCTION make_elementary_function
	(func_id : elementary_function_enumerators) : elementary_function;
 RETURN(elementary_function(func_id)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_elementary_function

FUNCTION make_elementary_space
	(space_id : elementary_space_enumerators) : elementary_space;
 RETURN(elementary_space(space_id)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_elementary_space

FUNCTION make_environment
	(varbl : generic_variable; sem : variable_semantics) : environment;
 RETURN(environment(varbl, sem));
 END_FUNCTION; -- make_environment

FUNCTION make_expression_denoted_function
	(expression : generic_expression) : expression_denoted_function;
 RETURN(expression_denoted_function()|| maths_function()|| generic_expression()|| unary_generic_expression(expression));
 END_FUNCTION; -- make_expression_denoted_function

FUNCTION make_extended_tuple_space
	(base : product_space; extender : maths_space) : extended_tuple_space;
 RETURN(extended_tuple_space(base, extender)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_extended_tuple_space

FUNCTION make_finite_function
	(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : finite_function;
 RETURN(finite_function(pairs)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_function

FUNCTION make_finite_integer_interval
	(min : INTEGER; max : INTEGER) : finite_integer_interval;
 RETURN(finite_integer_interval(min, max)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_integer_interval

FUNCTION make_finite_real_interval
	(min : REAL; minclo : open_closed; max : REAL; maxclo : open_closed) : finite_real_interval;
 RETURN(finite_real_interval(min, minclo, max, maxclo)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_real_interval

FUNCTION make_finite_space
	(members : SET [0:?] OF maths_value) : finite_space;
 RETURN(finite_space(members)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_space

FUNCTION make_function_application
	(afunction : maths_function_select; arguments : LIST [1:?] OF maths_value) : function_application;
 RETURN(function_application(afunction, arguments)|| multiple_arity_generic_expression(convert_to_maths_function(afunction)+ convert_to_operands(arguments))|| generic_expression());
 END_FUNCTION; -- make_function_application

FUNCTION make_function_space
	(domain_constraint : space_constraint_type; domain_argument : maths_space; range_constraint : space_constraint_type; range_argument : maths_space) : function_space;
 RETURN(function_space(domain_constraint, domain_argument, range_constraint, range_argument)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_function_space

FUNCTION make_general_linear_function
	(mat : maths_function; sum_index : one_or_two) : general_linear_function;
 RETURN(general_linear_function(sum_index)|| maths_function()|| generic_expression()|| unary_generic_expression(mat));
 END_FUNCTION; -- make_general_linear_function

FUNCTION make_int_literal
	(lit_value : INTEGER) : int_literal;
 RETURN(int_literal()|| literal_number(lit_value)|| simple_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_int_literal

FUNCTION make_integer_interval_from_min
	(min : INTEGER) : integer_interval_from_min;
 RETURN(integer_interval_from_min(min)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_integer_interval_from_min

FUNCTION make_listed_complex_number_data
	(index_base : zero_or_one; values : LIST [2:?] OF REAL) : listed_complex_number_data;
 RETURN(listed_complex_number_data(values)|| explicit_table_function(index_base, [ SIZEOF(values)/ 2 ])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_complex_number_data

FUNCTION make_listed_data
	(index_base : zero_or_one; values : LIST [2:?] OF maths_value; value_range : maths_space) : listed_data;
 RETURN(listed_data(values, value_range)|| explicit_table_function(index_base, [ SIZEOF(values)])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_data

FUNCTION make_listed_integer_data
	(index_base : zero_or_one; values : LIST [1:?] OF INTEGER) : listed_integer_data;
 RETURN(listed_integer_data(values)|| explicit_table_function(index_base, [ SIZEOF(values)])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_integer_data

FUNCTION make_listed_product_space
	(factors : LIST [0:?] OF maths_space) : listed_product_space;
 RETURN(listed_product_space(factors)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_product_space

FUNCTION make_listed_real_data
	(index_base : zero_or_one; values : LIST [1:?] OF REAL) : listed_real_data;
 RETURN(listed_real_data(values)|| explicit_table_function(index_base, [ SIZEOF(values)])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_real_data

FUNCTION make_logical_literal
	(lit_value : LOGICAL) : logical_literal;
 RETURN(logical_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_logical_literal

FUNCTION make_maths_enum_literal
	(lit_value : maths_enum_atom) : maths_enum_literal;
 RETURN(maths_enum_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_maths_enum_literal

FUNCTION make_maths_real_variable
	(values_space : maths_space; name : label) : maths_real_variable;
 RETURN(maths_real_variable()|| maths_variable(values_space, name)|| generic_variable()|| simple_generic_expression()|| generic_expression()|| real_numeric_variable()|| numeric_variable()|| variable());
 END_FUNCTION; -- make_maths_real_variable

FUNCTION make_maths_tuple_literal
	(lit_value : LIST [0:?] OF maths_value) : maths_tuple_literal;
 RETURN(maths_tuple_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_maths_tuple_literal

FUNCTION make_mult_expression
	(operands : LIST [2:?] OF generic_expression) : mult_expression;
 RETURN(mult_expression()|| multiple_arity_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| multiple_arity_generic_expression(operands));
 END_FUNCTION; -- make_mult_expression

FUNCTION make_number_literal
	(nmb : NUMBER) : generic_literal;
 IF 'INTEGER' IN TYPEOF(nmb)THEN RETURN(make_int_literal(nmb));
 END_IF;
 RETURN(make_real_literal(nmb));
 END_FUNCTION; -- make_number_literal

FUNCTION make_parallel_composed_function
	(srcdom : maths_space_or_function; prepfuncs : LIST [2:?] OF maths_function; finfunc : maths_function_select) : parallel_composed_function;
 RETURN(parallel_composed_function(srcdom, prepfuncs, finfunc)|| maths_function()|| generic_expression()|| multiple_arity_generic_expression(convert_to_operands_prcmfn(srcdom, prepfuncs, finfunc)));
 END_FUNCTION; -- make_parallel_composed_function

FUNCTION make_partial_derivative_expression
	(derivand : generic_expression; dvars : LIST [1:?] OF maths_variable; extend : extension_options) : partial_derivative_expression;
 RETURN(partial_derivative_expression(dvars, extend)|| unary_generic_expression(derivand)|| generic_expression());
 END_FUNCTION; -- make_partial_derivative_expression

FUNCTION make_partial_derivative_function
	(derivand : maths_function; dvars : LIST [1:?] OF input_selector; extend : extension_options) : partial_derivative_function;
 RETURN(partial_derivative_function(dvars, extend)|| maths_function()|| generic_expression()|| unary_generic_expression(derivand));
 END_FUNCTION; -- make_partial_derivative_function

FUNCTION make_polar_complex_number_region
	(centre : complex_number_literal; dis_constraint : real_interval; dir_constraint : finite_real_interval) : polar_complex_number_region;
 RETURN(polar_complex_number_region(centre, dis_constraint, dir_constraint)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_polar_complex_number_region

FUNCTION make_rationalize_function
	(fun : maths_function) : rationalize_function;
 RETURN(rationalize_function()|| maths_function()|| generic_expression()|| unary_generic_expression(fun));
 END_FUNCTION; -- make_rationalize_function

FUNCTION make_real_interval_from_min
	(min : REAL; minclo : open_closed) : real_interval_from_min;
 RETURN(real_interval_from_min(min, minclo)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_real_interval_from_min

FUNCTION make_real_interval_to_max
	(max : REAL; maxclo : open_closed) : real_interval_to_max;
 RETURN(real_interval_to_max(max, maxclo)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_real_interval_to_max

FUNCTION make_real_literal
	(lit_value : REAL) : real_literal;
 RETURN(real_literal()|| literal_number(lit_value)|| simple_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_real_literal

FUNCTION make_regular_table_function
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; operand : maths_function; first : INTEGER; increments : LIST [1:?] OF INTEGER) : regular_table_function;
 RETURN(regular_table_function(increments)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_regular_table_function

FUNCTION make_reindexed_array_function
	(func : maths_function; start_idxs : LIST [1:?] OF INTEGER) : reindexed_array_function;
 RETURN(reindexed_array_function(start_idxs)|| maths_function()|| generic_expression()|| unary_generic_expression(func));
 END_FUNCTION; -- make_reindexed_array_function

FUNCTION make_repackaging_function
	(operand : maths_function; input_repack : repackage_options; output_repack : repackage_options; selected_output : nonnegative_integer) : repackaging_function;
 RETURN(repackaging_function(input_repack, output_repack, selected_output)|| maths_function()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_repackaging_function

FUNCTION make_selector_function
	(selector : input_selector; src_of_domn : maths_space_or_function) : selector_function;
 RETURN(selector_function(selector, src_of_domn)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_selector_function

FUNCTION make_series_composed_function
	(functions : LIST [2:?] OF maths_function) : series_composed_function;
 RETURN(series_composed_function()|| maths_function()|| generic_expression()|| multiple_arity_generic_expression(functions));
 END_FUNCTION; -- make_series_composed_function

FUNCTION make_sin_expression
	(operand : numeric_expression) : sin_function;
 RETURN(sin_expression()|| unary_numeric_call_expression()|| unary_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_sin_expression

FUNCTION make_standard_table_function
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; operand : maths_function; first : INTEGER; order : ordering_type) : standard_table_function;
 RETURN(standard_table_function(order)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_standard_table_function

FUNCTION make_strict_triangular_matrix
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; source : maths_function; first : INTEGER; default_entry : maths_value; lo_up : lower_upper; order : ordering_type; main_diagonal_value : maths_value) : strict_triangular_matrix;
 RETURN(strict_triangular_matrix(main_diagonal_value)|| triangular_matrix(default_entry, lo_up, order)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(source));
 END_FUNCTION; -- make_strict_triangular_matrix

FUNCTION make_string_literal
	(lit_value : STRING) : string_literal;
 RETURN(string_literal(lit_value)|| simple_string_expression()|| string_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_string_literal

FUNCTION make_unary_minus_expression
	(operand : numeric_expression) : minus_function;
 RETURN(unary_minus_expression()|| unary_numeric_call_expression()|| unary_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_unary_minus_expression

FUNCTION make_uniform_product_space
	(base : maths_space; exponent : positive_integer) : uniform_product_space;
 RETURN(uniform_product_space(base, exponent)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_uniform_product_space

FUNCTION makec
	(x : REAL; y : REAL) : complex_number_literal;
 RETURN(make_complex_number_literal(x, y));
 END_FUNCTION; -- makec

FUNCTION max_exists
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_TO_MAX')IN  types)OR((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)OR((schema_prefix + 'REAL_INTERVAL_TO_MAX')IN types)));
 END_FUNCTION; -- max_exists

FUNCTION max_included
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_TO_MAX')IN  types)THEN  RETURN(TRUE);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(bool(spc \ finite_real_interval.max_closure = closed));
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_TO_MAX')IN types)THEN RETURN(bool(spc \ real_interval_to_max.max_closure = closed));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- max_included

FUNCTION mem_of_vs
	(val1 : maths_value; val2 : maths_value) : LOGICAL;
 IF  NOT  has_values_space(val2)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF NOT member_of(val1, values_space_of(val2))THEN RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- mem_of_vs

FUNCTION member_of
	(val : GENERIC:G; spc : maths_space) : LOGICAL;
 LOCAL
 v : maths_value := simplify_maths_value(convert_to_maths_value(val));
 vtypes : SET  OF  STRING  := stripped_typeof(v);
 s : maths_space := simplify_maths_space(spc);
 stypes : SET  OF  STRING := stripped_typeof(s);
 tmp_int : INTEGER;
 tmp_real : REAL;
 tmp_cmplx : complex_number_literal;
 lgcl, cum : LOGICAL;
 vspc, sspc : maths_space;
 smem : SET OF  maths_value;
 factors : LIST OF  maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(s)THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT  EXISTS(v)THEN  RETURN(s = the_generics);
 END_IF ;
 IF('GENERIC_EXPRESSION' IN  vtypes)AND  NOT('MATHS_SPACE' IN  vtypes)AND  NOT('MATHS_FUNCTION' IN  vtypes)AND  NOT('COMPLEX_NUMBER_LITERAL' IN  vtypes)THEN  IF  has_values_space(v)THEN  vspc := values_space_of(v);
 IF  subspace_of(vspc, s)THEN  RETURN(TRUE );
 END_IF ;
 IF  NOT  compatible_spaces(vspc, s)THEN  RETURN(FALSE );
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  stypes THEN  CASE  s \ elementary_space.space_id OF  es_numbers : RETURN(('NUMBER' IN  vtypes)OR('COMPLEX_NUMBER_LITERAL' IN  vtypes));
 es_complex_numbers : RETURN('COMPLEX_NUMBER_LITERAL' IN  vtypes);
 es_reals : RETURN(('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes));
 es_integers : RETURN('INTEGER' IN  vtypes);
 es_logicals : RETURN('LOGICAL' IN  vtypes);
 es_booleans : RETURN('BOOLEAN' IN  vtypes);
 es_strings : RETURN('STRING' IN  vtypes);
 es_binarys : RETURN('BINARY' IN  vtypes);
 es_maths_spaces : RETURN('MATHS_SPACE' IN  vtypes);
 es_maths_functions : RETURN('MATHS_FUNCTION' IN  vtypes);
 es_generics : RETURN(TRUE );
 END_CASE ;
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN  stypes THEN  IF  'INTEGER' IN  vtypes THEN  tmp_int := v;
 RETURN({ s \ finite_integer_interval.min <= tmp_int <= s \ finite_integer_interval.max });
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'INTEGER_INTERVAL_FROM_MIN' IN  stypes THEN  IF  'INTEGER' IN  vtypes THEN  tmp_int := v;
 RETURN(s \ integer_interval_from_min.min <= tmp_int);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'INTEGER_INTERVAL_TO_MAX' IN  stypes THEN  IF  'INTEGER' IN  vtypes THEN  tmp_int := v;
 RETURN(tmp_int <= s \ integer_interval_to_max.max);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_REAL_INTERVAL' IN  stypes THEN  IF('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes)THEN  tmp_real := v;
 IF  s \ finite_real_interval.min_closure = closed THEN  IF  s \ finite_real_interval.max_closure = closed THEN  RETURN({ s \ finite_real_interval.min <= tmp_real <= s \ finite_real_interval.max });
 ELSE  RETURN({ s \ finite_real_interval.min <= tmp_real < s \ finite_real_interval.max });
 END_IF ;
 ELSE  IF  s \ finite_real_interval.max_closure = closed THEN  RETURN({ s \ finite_real_interval.min < tmp_real <= s \ finite_real_interval.max });
 ELSE  RETURN({ s \ finite_real_interval.min < tmp_real < s \ finite_real_interval.max });
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_FROM_MIN' IN  stypes THEN  IF('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes)THEN  tmp_real := v;
 IF  s \ real_interval_from_min.min_closure = closed THEN  RETURN(s \ real_interval_from_min.min <= tmp_real);
 ELSE  RETURN(s \ real_interval_from_min.min < tmp_real);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_TO_MAX' IN  stypes THEN  IF('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes)THEN  tmp_real := v;
 IF  s \ real_interval_to_max.max_closure = closed THEN  RETURN(tmp_real <= s \ real_interval_to_max.max);
 ELSE RETURN(tmp_real < s \ real_interval_to_max.max);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  stypes THEN  IF  'COMPLEX_NUMBER_LITERAL' IN  vtypes THEN  RETURN(member_of(v \ complex_number_literal.real_part, s \ cartesian_complex_number_region.real_constraint)AND  member_of(v \ complex_number_literal.imag_part, s \ cartesian_complex_number_region.imag_constraint));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  stypes THEN  IF  'COMPLEX_NUMBER_LITERAL' IN  vtypes THEN  tmp_cmplx := v;
 tmp_cmplx.real_part := tmp_cmplx.real_part - s \ polar_complex_number_region.centre.real_part;
 tmp_cmplx.imag_part := tmp_cmplx.imag_part - s \ polar_complex_number_region.centre.imag_part;
 tmp_real := SQRT(tmp_cmplx.real_part ** 2 + tmp_cmplx.imag_part ** 2);
 IF  NOT member_of(tmp_real, s \ polar_complex_number_region.distance_constraint)THEN  RETURN(FALSE );
 END_IF ;
 IF  tmp_real = 0.0 THEN  RETURN(TRUE );
 END_IF ;
 tmp_real := atan2(tmp_cmplx.imag_part, tmp_cmplx.real_part);
 RETURN(member_of(tmp_real, s \ polar_complex_number_region.direction_constraint)OR  member_of(tmp_real + 2.0 * PI, s \ polar_complex_number_region.direction_constraint));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_SPACE' IN  stypes THEN  smem := s \ finite_space.members;
 cum := FALSE ;
 REPEAT  i := 1 TO  SIZEOF(smem);
 cum := cum OR equal_maths_values(v, smem [ i ]);
 IF  cum = TRUE  THEN  RETURN(TRUE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  stypes THEN  IF  'LIST' IN  vtypes THEN  IF  SIZEOF(v)= s \ uniform_product_space.exponent THEN  sspc := s \ uniform_product_space.base;
 cum := TRUE ;
 REPEAT  i := 1 TO  SIZEOF(v);
 cum := cum AND  member_of(v [ i ], sspc);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  stypes THEN  IF  'LIST' IN  vtypes THEN  factors := s \ listed_product_space.factors;
 IF  SIZEOF(v)= SIZEOF(factors)THEN  cum := TRUE ;
 REPEAT  i := 1 TO  SIZEOF(v);
 cum := cum AND  member_of(v [ i ], factors [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  stypes THEN  IF  'LIST' IN  vtypes THEN  sspc := s \ extended_tuple_space.base;
 tmp_int := space_dimension(sspc);
 IF  SIZEOF(v)>= tmp_int THEN  cum := TRUE;
 REPEAT  i := 1 TO  tmp_int;
 cum := cum AND  member_of(v [ i ], factor_space(sspc, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 sspc := s \ extended_tuple_space.extender;
 REPEAT i := tmp_int + 1 TO SIZEOF(v);
 cum := cum AND  member_of(v [ i ], sspc);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  stypes THEN  IF  'MATHS_FUNCTION' IN vtypes THEN  vspc := v \ maths_function.domain;
 sspc := s \ function_space.domain_argument;
 CASE  s \ function_space.domain_constraint OF  sc_equal : cum := equal_maths_spaces(vspc, sspc);
 sc_subspace : cum := subspace_of(vspc, sspc);
 sc_member : cum := member_of(vspc, sspc);
 END_CASE ;
 IF cum = FALSE  THEN RETURN(FALSE );
 END_IF ;
 vspc := v \ maths_function.range;
 sspc := s \ function_space.range_argument;
 CASE s \ function_space.range_constraint OF sc_equal : cum := cum AND  equal_maths_spaces(vspc, sspc);
 sc_subspace : cum := cum AND  subspace_of(vspc, sspc);
 sc_member : cum := cum AND member_of(vspc, sspc);
 END_CASE;
 RETURN(cum);
 END_IF ;
 RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- member_of

FUNCTION min_exists
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN')IN  types)OR((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)OR((schema_prefix + 'REAL_INTERVAL_FROM_MIN')IN types)));
 END_FUNCTION; -- min_exists

FUNCTION min_included
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN')IN  types)THEN  RETURN(TRUE);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(bool(spc \ finite_real_interval.min_closure = closed));
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_FROM_MIN')IN types)THEN RETURN(bool(spc \ real_interval_from_min.min_closure = closed));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- min_included

FUNCTION no_cyclic_domain_reference
	(ref : maths_space_or_function; used : SET [0:?] OF maths_function) : BOOLEAN;
 LOCAL
 typenames : SET OF STRING := TYPEOF(ref);
 func : maths_function;
 END_LOCAL
;
 IF(NOT  EXISTS(ref))OR(NOT EXISTS(used))THEN  RETURN(FALSE );
 END_IF ;
 IF(schema_prefix + 'MATHS_SPACE')IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 func := ref;
 IF  func IN  used THEN  RETURN(FALSE);
 END_IF ;
 IF(schema_prefix + 'CONSTANT_FUNCTION')IN  typenames THEN  RETURN(no_cyclic_domain_reference(func \ constant_function.source_of_domain, used + [ func ]));
 END_IF ;
 IF(schema_prefix + 'SELECTOR_FUNCTION')IN  typenames THEN  RETURN(no_cyclic_domain_reference(func \ selector_function.source_of_domain, used + [ func ]));
 END_IF ;
 IF(schema_prefix + 'PARALLEL_COMPOSED_FUNCTION')IN typenames THEN RETURN(no_cyclic_domain_reference(func \ parallel_composed_function.source_of_domain, used + [ func ]));
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- no_cyclic_domain_reference

FUNCTION no_cyclic_space_reference
	(spc : maths_space; refs : SET [0:?] OF maths_space) : BOOLEAN;
 LOCAL
 types : SET  OF  STRING;
 refs_plus : SET OF maths_space;
 END_LOCAL
;
 IF(spc IN  refs)THEN  RETURN(FALSE);
 END_IF ;
 types := TYPEOF(spc);
 refs_plus := refs + spc;
 IF(schema_prefix + 'FINITE_SPACE')IN  types THEN  RETURN(bool(SIZEOF(QUERY(sp <* QUERY(mem <* spc \ finite_space.members |(schema_prefix + 'MATHS_SPACE')IN  TYPEOF(mem))| NOT  no_cyclic_space_reference(sp, refs_plus)))= 0));
 END_IF ;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  types THEN  RETURN(no_cyclic_space_reference(spc \ uniform_product_space.base, refs_plus));
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  types THEN  RETURN(bool(SIZEOF(QUERY(fac <* spc \ listed_product_space.factors | NOT no_cyclic_space_reference(fac, refs_plus)))= 0));
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN types THEN RETURN(no_cyclic_space_reference(spc \ extended_tuple_space.base, refs_plus)AND no_cyclic_space_reference(spc \ extended_tuple_space.extender, refs_plus));
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- no_cyclic_space_reference

FUNCTION nondecreasing
	(lr : LIST [0:?] OF REAL) : BOOLEAN;
 IF  NOT EXISTS(lr)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT j := 2 TO SIZEOF(lr);
 IF lr [ j ] < lr [ j - 1 ] THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- nondecreasing

FUNCTION number_superspace_of
	(spc : maths_space) : elementary_space;
 IF  subspace_of_es(spc, es_integers)THEN  RETURN(the_integers);
 END_IF ;
 IF  subspace_of_es(spc, es_reals)THEN  RETURN(the_reals);
 END_IF ;
 IF  subspace_of_es(spc, es_complex_numbers)THEN  RETURN(the_complex_numbers);
 END_IF ;
 IF subspace_of_es(spc, es_numbers)THEN RETURN(the_numbers);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- number_superspace_of

FUNCTION number_tuple_subspace_check
	(spc : maths_space) : LOGICAL;
 LOCAL
 types : SET OF  STRING := stripped_typeof(spc);
 factors : LIST OF maths_space;
 cum : LOGICAL := TRUE;
 END_LOCAL
;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types THEN  RETURN(subspace_of_es(spc \ uniform_product_space.base, es_numbers));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types THEN  factors := spc \ listed_product_space.factors;
 REPEAT i := 1 TO SIZEOF(factors);
 cum := cum AND  subspace_of_es(factors [ i ], es_numbers);
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 IF 'EXTENDED_TUPLE_SPACE' IN types THEN cum := subspace_of_es(spc \ extended_tuple_space.extender, es_numbers);
 cum := cum AND number_tuple_subspace_check(spc \ extended_tuple_space.base);
 RETURN(cum);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- number_tuple_subspace_check

FUNCTION one_tuples_of
	(spc : maths_space) : tuple_space;
 RETURN(make_uniform_product_space(spc, 1));
 END_FUNCTION; -- one_tuples_of

FUNCTION parallel_composed_function_composability_check
	(funcs : LIST [0:?] OF maths_function; final : maths_function_select) : BOOLEAN;
 LOCAL
 tplsp : tuple_space := the_zero_tuple_space;
 finfun : maths_function := convert_to_maths_function(final);
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(funcs);
 tplsp := assoc_product_space(tplsp, funcs [ i ].range);
 END_REPEAT;
 RETURN(compatible_spaces(tplsp, finfun.domain));
 END_FUNCTION; -- parallel_composed_function_composability_check

FUNCTION parallel_composed_function_domain_check
	(comdom : tuple_space; funcs : LIST [0:?] OF maths_function) : BOOLEAN;
 REPEAT i := 1 TO SIZEOF(funcs);
 IF NOT(compatible_spaces(comdom, funcs [ i ].domain))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- parallel_composed_function_domain_check

FUNCTION parse_express_identifier
	(s : STRING; i : positive_integer) : positive_integer;
 LOCAL
 k : positive_integer;
 END_LOCAL
;
 k := i;
 IF  i <= LENGTH(s)THEN  IF(s [ i ] LIKE  '@')THEN REPEAT UNTIL(k > LENGTH(s))OR((s [ k ] <> '_')AND  NOT(s [ k ] LIKE  '@')AND NOT(s [ k ] LIKE '#'));
 k := k + 1;
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(k);
 END_FUNCTION; -- parse_express_identifier

FUNCTION partial_derivative_check
	(domain : tuple_space; d_vars : LIST [1:?] OF input_selector) : BOOLEAN;
 LOCAL
 domn : tuple_space := domain;
 fspc : maths_space;
 dim : INTEGER ;
 k : INTEGER;
 END_LOCAL
;
 IF(space_dimension(domain)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN TYPEOF(factor1(domain)))THEN  domn := factor1(domain);
 END_IF ;
 dim := space_dimension(domn);
 REPEAT i := 1 TO SIZEOF(d_vars);
 k := d_vars [ i ];
 IF  k > dim THEN  RETURN(FALSE );
 END_IF ;
 fspc := factor_space(domn, k);
 IF(NOT  subspace_of_es(fspc, es_reals))AND(NOT subspace_of_es(fspc, es_complex_numbers))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- partial_derivative_check

FUNCTION process_product_space
	(spc : product_space; idx : INTEGER; prefix : INTEGER; vdomn : maths_space) : product_space;
 LOCAL
 uspc : uniform_product_space;
 expnt : INTEGER;
 factors : LIST OF maths_space;
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN TYPEOF(spc)THEN  uspc := spc;
 expnt := uspc.exponent + prefix;
 IF  idx <= uspc.exponent THEN  expnt := expnt - 1;
 END_IF ;
 IF  expnt = 0 THEN  RETURN(make_listed_product_space([ ]));
 ELSE  RETURN(make_uniform_product_space(uspc.base, expnt));
 END_IF ;
 ELSE factors := spc \ listed_product_space.factors;
 IF  idx <= SIZEOF(factors)THEN  REMOVE(factors, idx);
 END_IF ;
 IF  prefix > 0 THEN  INSERT(factors, vdomn, 0);
 IF prefix > 1 THEN INSERT(factors, vdomn, 0);
 END_IF ;
 END_IF ;
 RETURN(make_listed_product_space(factors));
 END_IF;
 END_FUNCTION; -- process_product_space

FUNCTION real_max
	(spc : maths_space) : REAL;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)THEN  RETURN(spc \ finite_integer_interval.max);
 END_IF ;
 IF((schema_prefix + 'INTEGER_INTERVAL_TO_MAX')IN  types)THEN  RETURN(spc \ integer_interval_to_max.max);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(spc \ finite_real_interval.max);
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_TO_MAX')IN types)THEN RETURN(spc \ real_interval_to_max.max);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- real_max

FUNCTION real_min
	(spc : maths_space) : REAL;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)THEN  RETURN(spc \ finite_integer_interval.min);
 END_IF ;
 IF((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN')IN  types)THEN  RETURN(spc \ integer_interval_from_min.min);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(spc \ finite_real_interval.min);
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_FROM_MIN')IN types)THEN RETURN(spc \ real_interval_from_min.min);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- real_min

FUNCTION regular_indexing
	(sub : LIST [0:?] OF INTEGER; base : zero_or_one; shape : LIST [1:?] OF positive_integer; inc : LIST [1:?] OF INTEGER; first : INTEGER) : INTEGER;
 LOCAL
 k : INTEGER ;
 index : INTEGER;
 END_LOCAL
;
 IF  NOT  EXISTS(sub)OR  NOT  EXISTS(base)OR  NOT  EXISTS(shape)OR  NOT  EXISTS(inc)OR  NOT  EXISTS(first)THEN  RETURN(?);
 END_IF ;
 IF(SIZEOF(sub)<> SIZEOF(inc))OR(SIZEOF(sub)<> SIZEOF(shape))THEN  RETURN(?);
 END_IF ;
 index := first;
 REPEAT j := 1 TO SIZEOF(sub);
 IF  NOT  EXISTS(sub [ j ])OR NOT  EXISTS(inc [ j ])THEN  RETURN(?);
 END_IF ;
 k := sub [ j ] - base;
 IF NOT({ 0 <= k < shape [ j ] })THEN RETURN(?);
 END_IF;
 index := index + k * inc [ j ];
 END_REPEAT;
 RETURN(index);
 END_FUNCTION; -- regular_indexing

FUNCTION remove_first
	(alist : LIST [0:?] OF GENERIC) : LIST [0:?] OF GENERIC;
 LOCAL
 blist : LIST OF GENERIC : GEN := alist;
 END_LOCAL
;
 IF SIZEOF(blist)> 0 THEN REMOVE(blist, 1);
 END_IF;
 RETURN(blist);
 END_FUNCTION; -- remove_first

FUNCTION repackage
	(tspace : tuple_space; repckg : repackage_options) : tuple_space;
 CASE repckg OF ro_nochange : RETURN(tspace);
 ro_wrap_as_tuple : RETURN(one_tuples_of(tspace));
 ro_unwrap_tuple : RETURN(factor1(tspace));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- repackage

FUNCTION restore_binary
	(expr : binary_generic_expression; opd1 : generic_expression; opd2 : generic_expression) : generic_expression;
 expr.operands [ 1 ] := opd1;
 expr.operands [ 2 ] := opd2;
 RETURN(expr);
 END_FUNCTION; -- restore_binary

FUNCTION restore_mulary
	(expr : multiple_arity_generic_expression; ops : LIST [0:?] OF generic_expression) : generic_expression;
 expr.operands := ops;
 RETURN(expr);
 END_FUNCTION; -- restore_mulary

FUNCTION restore_unary
	(expr : unary_generic_expression; opnd : generic_expression) : generic_expression;
 expr.operand := opnd;
 RETURN(expr);
 END_FUNCTION; -- restore_unary

FUNCTION shape_of_array
	(func : maths_function) : LIST [0:?] OF positive_integer;
 LOCAL
 tspace : tuple_space;
 temp : maths_space;
 result : LIST OF positive_integer := [ ];
 END_LOCAL
;
 IF(schema_prefix + 'EXPLICIT_TABLE_FUNCTION')IN  TYPEOF(func)THEN  RETURN(func \ explicit_table_function.shape);
 END_IF ;
 tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(tspace)))THEN  tspace := factor1(tspace);
 END_IF ;
 REPEAT i := 1 TO space_dimension(tspace);
 temp := factor_space(tspace, i);
 IF NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN RETURN(?);
 END_IF;
 INSERT(result, temp \ finite_integer_interval.size, i - 1);
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- shape_of_array

FUNCTION simplify_function_application
	(expr : function_application) : maths_value;
 LOCAL
 types : SET  OF  STRING  := stripped_typeof(expr.func);
 ef_val : elementary_function_enumerators;
 is_elementary : BOOLEAN  := FALSE ;
 v, v1, v2, v3 : maths_value;
 vlist : LIST  OF  maths_value := [ ];
 gexpr : generic_expression;
 pairs : SET  [ 1 : ? ] OF  LIST  [ 2 : 2 ] OF  maths_value;
 boo : BOOLEAN;
 lgc, cum : LOGICAL;
 j, k, n : INTEGER;
 p, q, r, s, t, u : REAL;
 str, st2 : STRING;
 bin, bi2 : BINARY;
 tpl, tp2 : LIST OF  maths_value;
 mem : SET OF  maths_value := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(expr.arguments);
 v := simplify_maths_value(expr.arguments [ i ]);
 INSERT(vlist, v, i - 1);
 END_REPEAT ;
 IF  SIZEOF(vlist)>= 1 THEN  v1 := vlist [ 1 ];
 END_IF ;
 IF  SIZEOF(vlist)>= 2 THEN  v2 := vlist [ 2 ];
 END_IF ;
 IF  SIZEOF(vlist)>= 3 THEN  v3 := vlist [ 3 ];
 END_IF ;
 IF  'ELEMENTARY_FUNCTION_ENUMERATORS' IN  types THEN  ef_val := expr.func;
 is_elementary := TRUE ;
 END_IF ;
 IF  'ELEMENTARY_FUNCTION' IN  types THEN  ef_val := expr.func \ elementary_function.func_id;
 is_elementary := TRUE ;
 END_IF ;
 IF  is_elementary THEN  CASE ef_val OF ef_and : BEGIN  cum := TRUE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'LOGICAL' IN  TYPEOF(vlist [ i ])THEN  lgc := vlist [ i ];
 cum := cum AND  lgc;
 IF  lgc = FALSE  THEN  RETURN(ctmv(FALSE));
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(cum));
 END_IF ;
 IF  cum <> TRUE  THEN  INSERT(vlist, ctmv(cum), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_or : BEGIN  cum := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'LOGICAL' IN  TYPEOF(vlist [ i ])THEN  lgc := vlist [ i ];
 cum := cum OR  lgc;
 IF  lgc = TRUE  THEN  RETURN(ctmv(TRUE));
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(cum));
 END_IF ;
 IF  cum <> FALSE  THEN  INSERT(vlist, ctmv(cum), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_not : IF  'LOGICAL' IN  TYPEOF(v1)THEN  lgc := v1;
 RETURN(ctmv(NOT  lgc));
 END_IF ;
 ef_xor : BEGIN  IF  'LOGICAL' IN  TYPEOF(v1)THEN  lgc := v1;
 IF  'LOGICAL' IN  TYPEOF(v2)THEN  cum := v2;
 RETURN(ctmv(lgc XOR cum));
 ELSE  IF  lgc = FALSE  THEN  RETURN(ctmv(v2));
 ELSE  IF  lgc = UNKNOWN  THEN  RETURN(ctmv(UNKNOWN));
 ELSE  RETURN(make_function_application(ef_not, [ v2 ]));
 END_IF ;
 END_IF ;
 END_IF ;
 ELSE  IF  'LOGICAL' IN  TYPEOF(v2)THEN  lgc := v2;
 IF  lgc = FALSE  THEN  RETURN(ctmv(v1));
 ELSE  IF  lgc = UNKNOWN  THEN  RETURN(ctmv(UNKNOWN));
 ELSE  RETURN(make_function_application(ef_not, [ v1 ]));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END ;
 ef_negate_i : IF  'INTEGER' IN  TYPEOF(v1)THEN  j := v1;
 RETURN(ctmv(- j));
 END_IF ;
 ef_add_i : BEGIN  j := 0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  k := vlist [ i ];
 j := j + k;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  j <> 0 THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j - k));
 END_IF ;
 ef_multiply_i : BEGIN  j := 1;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  k := vlist [ i ];
 j := j * k;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  j <> 1 THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_divide_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j DIV  k));
 END_IF ;
 ef_mod_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j MOD k));
 END_IF ;
 ef_exponentiate_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 n := 1;
 REPEAT  i := 1 TO  ABS(k);
 n := n * j;
 END_REPEAT ;
 IF  k < 0 THEN  n := 1 DIV  n;
 END_IF ;
 RETURN(ctmv(n));
 END_IF ;
 ef_eq_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j = k));
 END_IF ;
 ef_ne_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j <> k));
 END_IF ;
 ef_gt_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j > k));
 END_IF ;
 ef_lt_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j < k));
 END_IF ;
 ef_ge_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j >= k));
 END_IF ;
 ef_le_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j <= k));
 END_IF ;
 ef_abs_i : IF  'INTEGER' IN  TYPEOF(v1)THEN  j := v1;
 RETURN(ctmv(ABS(j)));
 END_IF ;
 ef_max_i : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  k := vlist [ i ];
 IF  k > j THEN  j := k;
 END_IF ;
 ELSE  j := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_min_i : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  k := vlist [ i ];
 IF  k < j THEN  j := k;
 END_IF ;
 ELSE  j := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_negate_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(- r));
 END_IF ;
 ef_reciprocal_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(1.0 / r));
 END_IF ;
 ef_add_r : BEGIN  r := 0.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  s := vlist [ i ];
 r := r + s;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  r <> 0.0 THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r - s));
 END_IF ;
 ef_multiply_r : BEGIN  r := 1.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  s := vlist [ i ];
 r := r * s;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  r <> 1.0 THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_divide_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r / s));
 END_IF ;
 ef_mod_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 t := r / s;
 j := t DIV 1;
 IF(t < 0.0)AND(j <> t)THEN  j := j - 1;
 END_IF ;
 RETURN(ctmv(r - j * s));
 END_IF ;
 ef_exponentiate_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r ** s));
 END_IF ;
 ef_exponentiate_ri : IF('REAL' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  r := v1;
 k := v2;
 t := 1.0;
 REPEAT  i := 1 TO  ABS(k);
 t := t * r;
 END_REPEAT ;
 IF  k < 0 THEN  t := 1.0 / t;
 END_IF ;
 RETURN(ctmv(t));
 END_IF ;
 ef_eq_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r = s));
 END_IF ;
 ef_ne_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r <> s));
 END_IF ;
 ef_gt_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r > s));
 END_IF ;
 ef_lt_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r < s));
 END_IF ;
 ef_ge_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r >= s));
 END_IF ;
 ef_le_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r <= s));
 END_IF ;
 ef_abs_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(ABS(r)));
 END_IF ;
 ef_max_r : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  s := vlist [ i ];
 IF  s > r THEN  r := s;
 END_IF ;
 ELSE  r := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_min_r : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  s := vlist [ i ];
 IF  s < r THEN  r := s;
 END_IF ;
 ELSE  r := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_acos_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(ACOS(r)));
 END_IF ;
 ef_asin_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(ASIN(r)));
 END_IF ;
 ef_atan2_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(atan2(r, s)));
 END_IF ;
 ef_cos_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(COS(r)));
 END_IF ;
 ef_exp_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(EXP(r)));
 END_IF ;
 ef_ln_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(LOG(r)));
 END_IF ;
 ef_log2_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(LOG2(r)));
 END_IF ;
 ef_log10_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(LOG10(r)));
 END_IF ;
 ef_sin_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(SIN(r)));
 END_IF ;
 ef_sqrt_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(SQRT(r)));
 END_IF ;
 ef_tan_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(TAN(r)));
 END_IF ;
 ef_form_c : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(makec(r, s));
 END_IF ;
 ef_rpart_c : IF  cnlit IN  TYPEOF(v1)THEN  RETURN(ctmv(v1 \ complex_number_literal.real_part));
 END_IF ;
 ef_ipart_c : IF  cnlit IN  TYPEOF(v1)THEN  RETURN(ctmv(v1 \ complex_number_literal.imag_part));
 END_IF ;
 ef_negate_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(- p, - q));
 END_IF ;
 ef_reciprocal_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := p * p + q * q;
 RETURN(makec(p / t, - q / t));
 END_IF ;
 ef_add_c : BEGIN  p := 0.0;
 q := 0.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  cnlit IN  TYPEOF(vlist [ i ])THEN  parts(vlist [ i ], r, s);
 p := p + r;
 q := q + s;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(makec(p, q));
 END_IF ;
 IF  p * p + q * q <> 0.0 THEN  INSERT(vlist, makec(p, q), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 RETURN(makec(p - r, q - s));
 END_IF ;
 ef_multiply_c : BEGIN  p := 1.0;
 q := 0.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  cnlit IN  TYPEOF(vlist [ i ])THEN  parts(vlist [ i ], r, s);
 p := p * r - q * s;
 q := p * s + q * r;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(makec(p, q));
 END_IF ;
 IF(p <> 1.0)OR(q <> 0.0)THEN  INSERT(vlist, makec(p, q), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_divide_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 t := r * r + s * s;
 RETURN(makec((p * r + q * s)/ t,(q * r - p * s)/ t));
 END_IF ;
 ef_exponentiate_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 t := 0.5 * LOG(p * p + q * q);
 u := atan2(q, p);
 p := r * t - s * u;
 q := r * u + s * t;
 r := EXP(p);
 RETURN(makec(r * COS(q), r * SIN(q)));
 END_IF ;
 ef_exponentiate_ci : IF(cnlit IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  parts(v1, p, q);
 k := v2;
 r := 1.0;
 s := 0.0;
 REPEAT  i := 1 TO  ABS(k);
 r := p * r - q * s;
 s := p * s + q * r;
 END_REPEAT ;
 IF  k < 0 THEN  t := r * r + s * s;
 r := r / t;
 s := - s / t;
 END_IF ;
 RETURN(makec(r, s));
 END_IF ;
 ef_eq_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 RETURN(ctmv((p = r)AND(q = s)));
 END_IF ;
 ef_ne_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 RETURN(ctmv((p <> r)OR(q <> s)));
 END_IF ;
 ef_conjugate_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(p, - q));
 END_IF ;
 ef_abs_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(ctmv(SQRT(p * p + q * q)));
 END_IF ;
 ef_arg_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(ctmv(atan2(q, p)));
 END_IF ;
 ef_cos_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := 0.5 * EXP(- q);
 u := 0.5 * EXP(q);
 RETURN(makec((t + u)* COS(p),(t - u)* SIN(p)));
 END_IF ;
 ef_exp_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(EXP(p)* COS(q), EXP(p)* SIN(q)));
 END_IF ;
 ef_ln_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(0.5 * LOG(p * p + q * q), atan2(q, p)));
 END_IF ;
 ef_sin_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := 0.5 * EXP(- q);
 u := 0.5 * EXP(q);
 RETURN(makec((t + u)* SIN(p),(u - t)* COS(p)));
 END_IF ;
 ef_sqrt_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := SQRT(SQRT(p * p + q * q));
 u := 0.5 * atan2(q, p);
 RETURN(makec(t * COS(u), t * SIN(u)));
 END_IF ;
 ef_tan_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := EXP(2.0 * q)+ EXP(- 2.0 * q)+ 2.0 * COS(2.0 * p);
 RETURN(makec(2.0 * SIN(2.0 * p)/ t,(EXP(- 2.0 * q)- EXP(2.0 * q))/ t));
 END_IF ;
 ef_subscript_s : IF('STRING' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  str := v1;
 k := v2;
 RETURN(ctmv(str [ k ]));
 END_IF ;
 ef_eq_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str = st2));
 END_IF ;
 ef_ne_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str <> st2));
 END_IF ;
 ef_gt_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str > st2));
 END_IF ;
 ef_lt_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str < st2));
 END_IF ;
 ef_ge_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str >= st2));
 END_IF ;
 ef_le_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str <= st2));
 END_IF ;
 ef_subsequence_s : IF('STRING' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))AND('INTEGER' IN  TYPEOF(v3))THEN  str := v1;
 j := v2;
 k := v3;
 RETURN(ctmv(str [ j : k ]));
 END_IF ;
 ef_concat_s : BEGIN  str := '';
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'STRING' IN  TYPEOF(vlist [ i ])THEN  st2 := vlist [ i ];
 str := str + st2;
 REMOVE(vlist, i);
 ELSE  IF  str <> '' THEN  INSERT(vlist, ctmv(str), i);
 str := '';
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(str));
 END_IF ;
 IF  str <> '' THEN  INSERT(vlist, ctmv(str), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_size_s : IF  'STRING' IN  TYPEOF(v1)THEN  str := v1;
 RETURN(ctmv(LENGTH(str)));
 END_IF ;
 ef_format : IF('NUMBER' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  RETURN(ctmv(FORMAT(v1, v2)));
 END_IF ;
 ef_value : IF  'STRING' IN  TYPEOF(v1)THEN  str := v1;
 RETURN(ctmv(VALUE(str)));
 END_IF ;
 ef_like : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  RETURN(ctmv(v1 LIKE v2));
 END_IF ;
 ef_subscript_b : IF('BINARY' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  bin := v1;
 k := v2;
 RETURN(ctmv(bin [ k ]));
 END_IF ;
 ef_eq_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin = bi2));
 END_IF ;
 ef_ne_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin <> bi2));
 END_IF ;
 ef_gt_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin > bi2));
 END_IF ;
 ef_lt_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin < bi2));
 END_IF ;
 ef_ge_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin >= bi2));
 END_IF ;
 ef_le_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin <= bi2));
 END_IF ;
 ef_subsequence_b : IF('BINARY' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))AND('INTEGER' IN  TYPEOF(v3))THEN  bin := v1;
 j := v2;
 k := v3;
 RETURN(ctmv(bin [ j : k ]));
 END_IF ;
 ef_concat_b : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'BINARY' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  bi2 := vlist [ i ];
 bin := bin + bi2;
 ELSE  bin := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 ELSE  IF  boo THEN  INSERT(vlist, ctmv(bin), i);
 boo := FALSE ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(bin));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(bin), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_size_b : IF  'BINARY' IN  TYPEOF(v1)THEN  bin := v1;
 RETURN(ctmv(BLENGTH(bin)));
 END_IF ;
 ef_subscript_t : IF('LIST' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  tpl := v1;
 k := v2;
 RETURN(ctmv(tpl [ k ]));
 END_IF ;
 ef_eq_t : IF('LIST' IN  TYPEOF(v1))AND('LIST' IN  TYPEOF(v2))THEN  lgc := equal_maths_values(v1, v2);
 IF  lgc <> UNKNOWN  THEN  RETURN(ctmv(lgc));
 END_IF ;
 END_IF ;
 ef_ne_t : IF('LIST' IN  TYPEOF(v1))AND('LIST' IN  TYPEOF(v2))THEN  lgc := equal_maths_values(v1, v2);
 IF  lgc <> UNKNOWN  THEN  RETURN(ctmv(NOT  lgc));
 END_IF ;
 END_IF ;
 ef_concat_t : BEGIN  tpl := [ ];
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'STRING' IN  TYPEOF(vlist [ i ])THEN  tp2 := vlist [ i ];
 tpl := tpl + tp2;
 REMOVE(vlist, i);
 ELSE  IF  SIZEOF(tpl)<> 0 THEN  INSERT(vlist, ctmv(tpl), i);
 tpl := [ ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  SIZEOF(tpl)<> 0 THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_size_t : IF  'LIST' IN  TYPEOF(v1)THEN  tpl := v1;
 RETURN(ctmv(SIZEOF(tpl)));
 END_IF ;
 ef_entuple : RETURN(ctmv(vlist));
 ef_detuple : IF  'LIST' IN  TYPEOF(v1)THEN  tpl := v1;
 RETURN(ctmv(tpl [ 1 ]));
 END_IF ;
 ef_insert : IF('LIST' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v3))THEN  tpl := v1;
 k := v3;
 INSERT(tpl, v2, k);
 RETURN(ctmv(tpl));
 END_IF ;
 ef_remove : IF('LIST' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  tpl := v1;
 k := v2;
 REMOVE(tpl, k);
 RETURN(ctmv(tpl));
 END_IF ;
 ef_sum_it : IF  good_t(v1, 'INTEGER')THEN  tpl := v1;
 j := 0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 j := j + tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(j));
 END_IF ;
 ef_product_it : IF  good_t(v1, 'INTEGER')THEN  tpl := v1;
 j := 1;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 j := j * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(j));
 END_IF ;
 ef_add_it : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  good_t(vlist [ i ], 'INTEGER')THEN  IF  NOT  boo THEN  tpl := vlist [ i ];
 boo := TRUE ;
 ELSE  tp2 := vlist [ i ];
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(tpl);
 tpl [ j ] := tpl [ j ] + tp2 [ j ];
 END_REPEAT ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_it : IF  good_t(v1, 'INTEGER')AND  good_t(v2, 'INTEGER')THEN  tpl := v1;
 tp2 := v2;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := tpl [ i ] - tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_scalar_mult_it : IF('INTEGER' IN  TYPEOF(v1))AND  good_t(v2, 'INTEGER')THEN  j := v1;
 tpl := v2;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := j * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_dot_prod_it : IF  good_t(v1, 'INTEGER')AND  good_t(v2, 'INTEGER')THEN  tpl := v1;
 tp2 := v2;
 j := 0;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 j := j + tpl [ i ] * tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(j));
 END_IF ;
 ef_sum_rt : IF  good_t(v1, 'REAL')THEN  tpl := v1;
 r := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r + tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(r));
 END_IF ;
 ef_product_rt : IF  good_t(v1, 'REAL')THEN  tpl := v1;
 r := 1.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(r));
 END_IF ;
 ef_add_rt : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  good_t(vlist [ i ], 'REAL')THEN  IF  NOT  boo THEN  tpl := vlist [ i ];
 boo := TRUE ;
 ELSE  tp2 := vlist [ i ];
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(tpl);
 tpl [ j ] := tpl [ j ] + tp2 [ j ];
 END_REPEAT ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_rt : IF  good_t(v1, 'REAL')AND  good_t(v2, 'REAL')THEN  tpl := v1;
 tp2 := v2;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := tpl [ i ] - tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_scalar_mult_rt : IF('REAL' IN  TYPEOF(v1))AND  good_t(v2, 'REAL')THEN  r := v1;
 tpl := v2;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := r * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_dot_prod_rt : IF  good_t(v1, 'REAL')AND  good_t(v2, 'REAL')THEN  tpl := v1;
 tp2 := v2;
 r := 0;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r + tpl [ i ] * tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(r));
 END_IF ;
 ef_norm_rt : IF  good_t(v1, 'REAL')THEN  tpl := v1;
 r := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r + tpl [ i ] * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(SQRT(r)));
 END_IF ;
 ef_sum_ct : IF  good_t(v1, cnlit)THEN  tpl := v1;
 p := 0.0;
 q := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], r, s);
 p := p + r;
 q := q + s;
 END_REPEAT ;
 RETURN(makec(p, q));
 END_IF ;
 ef_product_ct : IF  good_t(v1, cnlit)THEN  tpl := v1;
 p := 1.0;
 q := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], r, s);
 p := p * r - q * s;
 q := p * s + q * r;
 END_REPEAT ;
 RETURN(makec(p, q));
 END_IF ;
 ef_add_ct : BEGIN boo := FALSE;
 REPEAT  i := SIZEOF(vlist)TO  1 BY - 1;
 IF  good_t(vlist [ i ], cnlit)THEN  IF  NOT boo THEN  tpl := vlist [ i ];
 boo := TRUE;
 ELSE  tp2 := vlist [ i ];
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(tpl);
 parts(tpl [ j ], p, q);
 parts(tp2 [ j ], r, s);
 tpl [ j ] := makec(p + r, q + s);
 END_REPEAT ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END;
 ef_subtract_ct : IF  good_t(v1, cnlit)AND  good_t(v2, cnlit)THEN  tpl := v1;
 tp2 := v2;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], p, q);
 parts(tp2 [ i ], r, s);
 tpl [ i ] := makec(p - r, q - s);
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_scalar_mult_ct : IF(cnlit IN  TYPEOF(v1))AND  good_t(v2, cnlit)THEN  parts(v1, p, q);
 tpl := v2;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], r, s);
 tpl [ i ] := makec(p * r - q * s, p * s + q * r);
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_dot_prod_ct : IF  good_t(v1, cnlit)AND good_t(v2, cnlit)THEN  tpl := v1;
 tp2 := v2;
 t := 0.0;
 u := 0.0;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], p, q);
 parts(tp2 [ i ], r, s);
 t := t + p * r + q * s;
 u := u + q * r - p * s;
 END_REPEAT ;
 RETURN(makec(t, u));
 END_IF ;
 ef_norm_ct : IF  good_t(v1, cnlit)THEN  tpl := v1;
 r := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], p, q);
 r := r + p * p + q * q;
 END_REPEAT ;
 RETURN(ctmv(SQRT(r)));
 END_IF ;
 ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t : IF  'LOGICAL' IN  TYPEOF(v1)THEN  lgc := v1;
 IF  lgc THEN  RETURN(v2);
 ELSE RETURN(v3);
 END_IF ;
 END_IF ;
 ef_ensemble : RETURN(make_finite_space(mem + vlist));
 ef_member_of : IF(schema_prefix + 'MATHS_SPACE')IN  TYPEOF(v2)THEN  lgc := member_of(v1, v2);
 IF  lgc <> UNKNOWN THEN  RETURN(ctmv(lgc));
 END_IF ;
 END_IF ;
 END_CASE;
 RETURN(make_function_application(expr.func, vlist));
 END_IF ;
 IF  'ABSTRACTED_EXPRESSION_FUNCTION' IN  types THEN  gexpr := substitute(expr.func \ abstracted_expression_function.expr, expr.func \ quantifier_expression.variables, vlist);
 RETURN(simplify_generic_expression(gexpr));
 END_IF ;
 IF  'FINITE_FUNCTION' IN types THEN  pairs := expr.func \ finite_function.pairs;
 REPEAT i := 1 TO SIZEOF(pairs);
 IF equal_maths_values(vlist [ 1 ], pairs [ i ] [ 1 ])THEN RETURN(simplify_maths_value(pairs [ i ] [ 2 ]));
 END_IF ;
 END_REPEAT;
 RETURN(make_function_application(expr.func, vlist));
 END_IF;
 RETURN(expr);
 END_FUNCTION; -- simplify_function_application

FUNCTION simplify_generic_expression
	(expr : generic_expression) : maths_value;
 LOCAL
 types : SET OF  STRING  := stripped_typeof(expr);
 v1, v2 : maths_value;
 vlist : LIST  OF  maths_value := [ ];
 op1, op2 : generic_expression;
 oplist : LIST  OF  generic_expression := [ ];
 opnds : LIST [ 2 : ? ] OF generic_expression;
 n, m : INTEGER;
 finfun : maths_function_select;
 boo : BOOLEAN;
 str : STRING;
 nmb : NUMBER;
 END_LOCAL
;
 IF  'INT_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ int_literal.the_value));
 END_IF ;
 IF  'REAL_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ real_literal.the_value));
 END_IF ;
 IF  'BOOLEAN_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ boolean_literal.the_value));
 END_IF ;
 IF  'STRING_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ string_literal.the_value));
 END_IF ;
 IF  'COMPLEX_NUMBER_LITERAL' IN  types THEN  RETURN(expr);
 END_IF ;
 IF  'LOGICAL_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ logical_literal.lit_value));
 END_IF ;
 IF  'BINARY_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ binary_literal.lit_value));
 END_IF ;
 IF  'MATHS_ENUM_LITERAL' IN  types THEN  RETURN(expr \ maths_enum_literal.lit_value);
 END_IF ;
 IF  'REAL_TUPLE_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ real_tuple_literal.lit_value));
 END_IF ;
 IF  'INTEGER_TUPLE_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ integer_tuple_literal.lit_value));
 END_IF ;
 IF  'ATOM_BASED_LITERAL' IN  types THEN  RETURN(expr \ atom_based_literal.lit_value);
 END_IF ;
 IF  'MATHS_TUPLE_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ maths_tuple_literal.lit_value));
 END_IF ;
 IF  'MATHS_SPACE' IN  types THEN  RETURN(simplify_maths_space(expr));
 END_IF ;
 IF  'FUNCTION_APPLICATION' IN  types THEN  RETURN(simplify_function_application(expr));
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  types THEN  v1 := simplify_generic_expression(expr \ unary_generic_expression.operand);
 op1 := convert_to_operand(v1);
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  types THEN  v1 := simplify_generic_expression(expr \ binary_generic_expression.operands [ 1 ]);
 op1 := convert_to_operand(v1);
 v2 := simplify_generic_expression(expr \ binary_generic_expression.operands [ 2 ]);
 op2 := convert_to_operand(v2);
 END_IF ;
 IF  'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN  types THEN  opnds := expr \ multiple_arity_generic_expression.operands;
 REPEAT  i := 1 TO  SIZEOF(opnds);
 v1 := simplify_generic_expression(opnds [ i ]);
 INSERT(vlist, v1, i - 1);
 INSERT(oplist, convert_to_operand(v1), i - 1);
 END_REPEAT ;
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  types THEN  v1 := vlist [ 1 ];
 n := SIZEOF(vlist);
 finfun := vlist [ n ];
 REMOVE(vlist, n);
 REMOVE(vlist, 1);
 RETURN(make_parallel_composed_function(v1, vlist, finfun));
 END_IF ;
 IF('ABS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ABS(v1)));
 END_IF ;
 IF('ACOS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ACOS(v1)));
 END_IF ;
 IF  'AND_EXPRESSION' IN  types THEN  REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'BOOLEAN' IN  TYPEOF(vlist [ i ])THEN  boo := vlist [ i ];
 IF  NOT  boo THEN  RETURN(convert_to_maths_value(FALSE));
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(TRUE));
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('ASIN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ASIN(v1)));
 END_IF ;
 IF('ATAN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(ATAN(v1, v2)));
 END_IF ;
 IF('COMPARISON_EXPRESSION' IN  types)AND((('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2)))OR(('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2)))OR(('BOOLEAN' IN  TYPEOF(v1))AND('BOOLEAN' IN  TYPEOF(v2))))THEN  IF  'COMPARISON_EQUAL' IN  types THEN  boo := bool(v1 = v2);
 ELSE  IF  'COMPARISON_GREATER' IN  types THEN  boo := bool(v1 > v2);
 ELSE  IF  'COMPARISON_GREATER_EQUAL' IN  types THEN  boo := bool(v1 >= v2);
 ELSE  IF  'COMPARISON_LESS' IN  types THEN  boo := bool(v1 < v2);
 ELSE  IF  'COMPARISON_LESS_EQUAL' IN  types THEN  boo := bool(v1 <= v2);
 ELSE  IF  'COMPARISON_NOT_EQUAL' IN  types THEN  boo := bool(v1 <> v2);
 ELSE  IF  'LIKE_EXPRESSION' IN  types THEN  boo := bool(v1 LIKE v2);
 ELSE  RETURN(?);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN(convert_to_maths_value(boo));
 END_IF ;
 IF  'CONCAT_EXPRESSION' IN  types THEN  str := '';
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'STRING' IN  TYPEOF(vlist [ i ])THEN  str := vlist [ i ] + str;
 REMOVE(oplist, i);
 ELSE  IF  LENGTH(str)> 0 THEN  INSERT(oplist, make_string_literal(str), i);
 str := '';
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(str));
 END_IF ;
 IF  LENGTH(str)> 0 THEN  INSERT(oplist, make_string_literal(str), 0);
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('COS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(COS(v1)));
 END_IF ;
 IF('DIV_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 DIV v2));
 END_IF ;
 IF  'EQUALS_EXPRESSION' IN  types THEN  opnds := expr \ binary_generic_expression.operands;
 RETURN(convert_to_maths_value(opnds [ 1 ] :=: opnds [ 2 ]));
 END_IF ;
 IF('EXP_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(EXP(v1)));
 END_IF ;
 IF('FORMAT_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(FORMAT(v1, v2)));
 END_IF ;
 IF('INDEX_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  str := v1;
 n := v2;
 RETURN(convert_to_maths_value(str [ n ]));
 END_IF ;
 IF('INT_VALUE_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(VALUE(v1)));
 END_IF ;
 IF  'INTERVAL_EXPRESSION' IN  types THEN  str := '';
 IF  'NUMBER' IN  TYPEOF(vlist [ 1 ])THEN  str := 'NUMBER';
 END_IF ;
 IF  'STRING' IN  TYPEOF(vlist [ 1 ])THEN  str := 'STRING';
 END_IF ;
 IF  'BOOLEAN' IN  TYPEOF(vlist [ 1 ])THEN  str := 'BOOLEAN';
 END_IF ;
 IF(LENGTH(str)> 0)AND(str IN  TYPEOF(vlist [ 2 ]))AND(str IN  TYPEOF(vlist [ 3 ]))THEN  RETURN(convert_to_maths_value({ vlist [ 1 ] <= vlist [ 2 ] <= vlist [ 3 ] }));
 END_IF ;
 END_IF ;
 IF('LENGTH_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LENGTH(v1)));
 END_IF ;
 IF('LOG_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LOG(v1)));
 END_IF ;
 IF('LOG10_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LOG10(v1)));
 END_IF ;
 IF('LOG2_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LOG2(v1)));
 END_IF ;
 IF  'MAXIMUM_EXPRESSION' IN  types THEN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  IF  nmb < vlist [ i ] THEN  nmb := vlist [ i ];
 END_IF ;
 ELSE  nmb := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  boo THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 END_IF ;
 IF  'MINIMUM_EXPRESSION' IN  types THEN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  IF  nmb > vlist [ i ] THEN  nmb := vlist [ i ];
 END_IF ;
 ELSE nmb := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  boo THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 END_IF ;
 IF('MINUS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 - v2));
 END_IF ;
 IF('MOD_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 MOD v2));
 END_IF ;
 IF  'MULT_EXPRESSION' IN  types THEN  nmb := 1;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  nmb := nmb * vlist [ i ];
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  nmb <> 1 THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('NOT_EXPRESSION' IN  types)AND('BOOLEAN' IN  TYPEOF(v1))THEN  boo := v1;
 RETURN(convert_to_maths_value(NOT(boo)));
 END_IF ;
 IF('ODD_EXPRESSION' IN  types)AND('INTEGER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ODD(v1)));
 END_IF ;
 IF  'OR_EXPRESSION' IN  types THEN  REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'BOOLEAN' IN  TYPEOF(vlist [ i ])THEN  boo := vlist [ i ];
 IF  boo THEN  RETURN(convert_to_maths_value(TRUE));
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(FALSE));
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF  'PLUS_EXPRESSION' IN  types THEN  nmb := 0;
 REPEAT i := SIZEOF(vlist)TO 1 BY - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  nmb := nmb + vlist [ i ];
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  nmb <> 0 THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('POWER_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 ** v2));
 END_IF ;
 IF('SIN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(SIN(v1)));
 END_IF ;
 IF('SLASH_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 / v2));
 END_IF ;
 IF('SQUARE_ROOT_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(SQRT(v1)));
 END_IF ;
 IF('SUBSTRING_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(vlist [ 1 ]))AND('NUMBER' IN  TYPEOF(vlist [ 2 ]))AND('NUMBER' IN  TYPEOF(vlist [ 3 ]))THEN  str := vlist [ 1 ];
 n := vlist [ 2 ];
 m := vlist [ 3 ];
 RETURN(convert_to_maths_value(str [ n : m ]));
 END_IF ;
 IF('TAN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(TAN(v1)));
 END_IF ;
 IF('UNARY_MINUS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  nmb := v1;
 RETURN(convert_to_maths_value(- nmb));
 END_IF ;
 IF('VALUE_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(VALUE(v1)));
 END_IF ;
 IF('XOR_EXPRESSION' IN  types)AND('BOOLEAN' IN  TYPEOF(v1))AND('BOOLEAN' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 XOR v2));
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  types THEN  RETURN(restore_unary(expr, op1));
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  types THEN  RETURN(restore_binary(expr, op1, op2));
 END_IF ;
 IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN RETURN(restore_mulary(expr, oplist));
 END_IF;
 RETURN(expr);
 END_FUNCTION; -- simplify_generic_expression

FUNCTION simplify_maths_space
	(spc : maths_space) : maths_space;
 LOCAL
 stypes : SET  OF  STRING := stripped_typeof(spc);
 sset : SET  OF  maths_value;
 zset : SET OF  maths_value := [ ];
 zval : maths_value;
 zspc : maths_space;
 zallint : BOOLEAN := TRUE;
 zint, zmin, zmax : INTEGER;
 factors : LIST  OF  maths_space;
 zfactors : LIST OF maths_space := [ ];
 rspc : maths_space;
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  stypes THEN  sset := spc \ finite_space.members;
 REPEAT  i := 1 TO  SIZEOF(sset);
 zval := simplify_maths_value(sset [ i ]);
 zset := zset + [ zval ];
 IF  zallint AND('INTEGER' IN  TYPEOF(zval))THEN  zint := zval;
 IF  i = 1 THEN  zmin := zint;
 zmax := zint;
 ELSE  IF  zint < zmin THEN  zmin := zint;
 END_IF ;
 IF  zint > zmax THEN  zmax := zint;
 END_IF ;
 END_IF ;
 ELSE zallint := FALSE;
 END_IF ;
 END_REPEAT ;
 IF  zallint AND(SIZEOF(zset)= zmax - zmin + 1)THEN  RETURN(make_finite_integer_interval(zmin, zmax));
 END_IF ;
 RETURN(make_finite_space(zset));
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  stypes THEN  zspc := simplify_maths_space(spc \ uniform_product_space.base);
 RETURN(make_uniform_product_space(zspc, spc \ uniform_product_space.exponent));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  stypes THEN  factors := spc \ listed_product_space.factors;
 REPEAT i := 1 TO SIZEOF(factors);
 INSERT(zfactors, simplify_maths_space(factors [ i ]), i - 1);
 END_REPEAT;
 RETURN(make_listed_product_space(zfactors));
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  stypes THEN  zspc := simplify_maths_space(spc \ extended_tuple_space.base);
 rspc := simplify_maths_space(spc \ extended_tuple_space.extender);
 RETURN(make_extended_tuple_space(zspc, rspc));
 END_IF ;
 IF 'FUNCTION_SPACE' IN stypes THEN zspc := simplify_maths_space(spc \ function_space.domain_argument);
 rspc := simplify_maths_space(spc \ function_space.range_argument);
 RETURN(make_function_space(spc \ function_space.domain_constraint, zspc, spc \ function_space.range_constraint, rspc));
 END_IF;
 RETURN(spc);
 END_FUNCTION; -- simplify_maths_space

FUNCTION simplify_maths_value
	(val : maths_value) : maths_value;
 LOCAL
 vtypes : SET OF  STRING := stripped_typeof(val);
 vlist : LIST  OF  maths_value;
 nlist : LIST OF maths_value := [ ];
 END_LOCAL
;
 IF  'GENERIC_EXPRESSION' IN  vtypes THEN  RETURN(simplify_generic_expression(val));
 END_IF ;
 IF 'LIST' IN vtypes THEN vlist := val;
 REPEAT i := 1 TO SIZEOF(vlist);
 INSERT(nlist, simplify_maths_value(vlist [ i ]), i - 1);
 END_REPEAT;
 RETURN(convert_to_maths_value(nlist));
 END_IF;
 RETURN(val);
 END_FUNCTION; -- simplify_maths_value

FUNCTION singleton_member_of
	(spc : maths_space) : maths_value;
 LOCAL
 types : SET OF STRING := stripped_typeof(spc);
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  types THEN  IF  SIZEOF(spc \ finite_space.members)= 1 THEN  RETURN(spc \ finite_space.members [ 1 ]);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN types THEN  IF spc \ finite_integer_interval.size = 1 THEN RETURN(spc \ finite_integer_interval.min);
 END_IF ;
 RETURN(?);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- singleton_member_of

FUNCTION space_dimension
	(tspace : tuple_space) : nonnegative_integer;
 LOCAL
 types : SET OF STRING := TYPEOF(tspace);
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  types THEN  RETURN(tspace \ uniform_product_space.exponent);
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  types THEN  RETURN(SIZEOF(tspace \ listed_product_space.factors));
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN types THEN RETURN(space_dimension(tspace \ extended_tuple_space.base));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- space_dimension

FUNCTION space_is_continuum
	(space : maths_space) : BOOLEAN;
 LOCAL
 typenames : SET OF  STRING := TYPEOF(space);
 factors : LIST OF maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(space)THEN  RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(space, es_reals)OR subspace_of_es(space, es_complex_numbers)THEN  RETURN(TRUE );
 END_IF ;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  typenames THEN  RETURN(space_is_continuum(space \ uniform_product_space.base));
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN typenames THEN  factors := space \ listed_product_space.factors;
 IF  SIZEOF(factors)= 0 THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(factors);
 IF NOT space_is_continuum(factors [ i ])THEN RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- space_is_continuum

FUNCTION space_is_singleton
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := stripped_typeof(spc);
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  types THEN  RETURN(bool(SIZEOF(spc \ finite_space.members)= 1));
 END_IF ;
 IF 'FINITE_INTEGER_INTERVAL' IN types THEN RETURN(bool(spc \ finite_integer_interval.size = 1));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- space_is_singleton

FUNCTION strictly_in
	(z : REAL; zitv : real_interval) : LOGICAL;
 RETURN((NOT  min_exists(zitv)OR(z > real_min(zitv)))AND(NOT max_exists(zitv)OR(z < real_max(zitv))));
 END_FUNCTION; -- strictly_in

FUNCTION strictly_in2
	(a : REAL; aitv : finite_real_interval) : LOGICAL;
 a := angle2(a);
 RETURN({ aitv.min < a < aitv.max } OR { aitv.min < a + 2.0 * PI < aitv.max });
 END_FUNCTION; -- strictly_in2

FUNCTION stripped_typeof
	(arg : GENERIC:G) : SET [0:?] OF STRING;
 LOCAL
 types : SET  OF  STRING  := TYPEOF(arg);
 stypes : SET OF STRING := [ ];
 n : INTEGER := LENGTH(schema_prefix);
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(types);
 IF types [ i ] [ 1 : n ] = schema_prefix THEN stypes := stypes + [ types [ i ] [ n + 1 : LENGTH(types [ i ])] ];
 ELSE stypes := stypes + [ types [ i ] ];
 END_IF;
 END_REPEAT;
 RETURN(stypes);
 END_FUNCTION; -- stripped_typeof

FUNCTION subspace_of
	(space1 : maths_space; space2 : maths_space) : LOGICAL;
 LOCAL
 spc1 : maths_space := simplify_maths_space(space1);
 spc2 : maths_space := simplify_maths_space(space2);
 types1 : SET  OF  STRING  := stripped_typeof(spc1);
 types2 : SET OF  STRING := stripped_typeof(spc2);
 lgcl, cum : LOGICAL;
 es_val : elementary_space_enumerators;
 bnd1, bnd2 : REAL;
 n : INTEGER;
 sp1, sp2 : maths_space;
 prgn1, prgn2 : polar_complex_number_region;
 aitv : finite_real_interval;
 END_LOCAL
;
 IF  NOT  EXISTS(spc1)OR  NOT  EXISTS(spc2)THEN  RETURN(FALSE );
 END_IF ;
 IF  spc2 = the_generics THEN  RETURN(TRUE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types1 THEN  IF  NOT('ELEMENTARY_SPACE' IN  types2)THEN  RETURN(FALSE );
 END_IF ;
 es_val := spc2 \ elementary_space.space_id;
 IF  spc1 \ elementary_space.space_id = es_val THEN  RETURN(TRUE );
 END_IF ;
 CASE  spc1 \ elementary_space.space_id OF  es_numbers : RETURN(FALSE );
 es_complex_numbers : RETURN(es_val = es_numbers);
 es_reals : RETURN(es_val = es_numbers);
 es_integers : RETURN(es_val = es_numbers);
 es_logicals : RETURN(FALSE );
 es_booleans : RETURN(es_val = es_logicals);
 es_strings : RETURN(FALSE );
 es_binarys : RETURN(FALSE );
 es_maths_spaces : RETURN(FALSE );
 es_maths_functions : RETURN(FALSE );
 es_generics : RETURN(FALSE );
 END_CASE ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN  types1 THEN  cum := TRUE ;
 REPEAT  i := spc1 \ finite_integer_interval.min TO  spc1 \ finite_integer_interval.max;
 cum := cum AND  member_of(i, spc2);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'INTEGER_INTERVAL_FROM_MIN' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_integers));
 END_IF ;
 IF  'INTEGER_INTERVAL_FROM_MIN' IN  types2 THEN  RETURN(spc1 \ integer_interval_from_min.min >= spc2 \ integer_interval_from_min.min);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'INTEGER_INTERVAL_TO_MAX' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_integers));
 END_IF ;
 IF  'INTEGER_INTERVAL_TO_MAX' IN  types2 THEN  RETURN(spc1 \ integer_interval_to_max.max <= spc2 \ integer_interval_to_max.max);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_REAL_INTERVAL' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_reals));
 END_IF ;
 IF('FINITE_REAL_INTERVAL' IN  types2)OR('REAL_INTERVAL_FROM_MIN' IN  types2)OR('REAL_INTERVAL_TO_MAX' IN  types2)THEN  IF  min_exists(spc2)THEN  bnd1 := spc1 \ finite_real_interval.min;
 bnd2 := real_min(spc2);
 IF(bnd1 < bnd2)OR((bnd1 = bnd2)AND  min_included(spc1)AND  NOT  min_included(spc2))THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  max_exists(spc2)THEN  bnd1 := spc1 \ finite_real_interval.max;
 bnd2 := real_max(spc2);
 IF(bnd1 > bnd2)OR((bnd1 = bnd2)AND  max_included(spc1)AND  NOT  max_included(spc2))THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_FROM_MIN' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_reals));
 END_IF ;
 IF  'REAL_INTERVAL_FROM_MIN' IN  types2 THEN  bnd1 := spc1 \ real_interval_from_min.min;
 bnd2 := spc2 \ real_interval_from_min.min;
 RETURN((bnd2 < bnd1)OR((bnd2 = bnd1)AND(min_included(spc2)OR  NOT  min_included(spc1))));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_TO_MAX' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_reals));
 END_IF ;
 IF  'REAL_INTERVAL_TO_MAX' IN  types2 THEN  bnd1 := spc1 \ real_interval_to_max.max;
 bnd2 := spc2 \ real_interval_to_max.max;
 RETURN((bnd2 > bnd1)OR((bnd2 = bnd1)AND(max_included(spc2)OR  NOT  max_included(spc1))));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_complex_numbers));
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  types2 THEN  RETURN(subspace_of(spc1 \ cartesian_complex_number_region.real_constraint, spc2 \ cartesian_complex_number_region.real_constraint)AND  subspace_of(spc1 \ cartesian_complex_number_region.imag_constraint, spc2 \ cartesian_complex_number_region.imag_constraint));
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  types2 THEN  RETURN(subspace_of(enclose_cregion_in_pregion(spc1, spc2 \ polar_complex_number_region.centre), spc2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_complex_numbers));
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  types2 THEN  RETURN(subspace_of(enclose_pregion_in_cregion(spc1), spc2));
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  types2 THEN  prgn1 := spc1;
 prgn2 := spc2;
 IF  prgn1.centre = prgn2.centre THEN  IF  prgn2.direction_constraint.max > PI  THEN  aitv := make_finite_real_interval(- PI , open, prgn2.direction_constraint.max - 2.0 * PI, prgn2.direction_constraint.max_closure);
 RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint)AND(subspace_of(prgn1.direction_constraint, prgn2.direction_constraint)OR subspace_of(prgn1.direction_constraint, aitv)));
 ELSE RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint)AND  subspace_of(prgn1.direction_constraint, prgn2.direction_constraint));
 END_IF ;
 END_IF ;
 RETURN(subspace_of(enclose_pregion_in_pregion(prgn1, prgn2.centre), prgn2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_SPACE' IN  types1 THEN  cum := TRUE ;
 REPEAT  i := 1 TO  SIZEOF(spc1 \ finite_space.members);
 cum := cum AND  member_of(spc1 \ finite_space.members [ i ], spc2);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'PRODUCT_SPACE' IN  types1 THEN  IF  'PRODUCT_SPACE' IN  types2 THEN  IF  space_dimension(spc1)= space_dimension(spc2)THEN  cum := TRUE ;
 REPEAT  i := 1 TO  space_dimension(spc1);
 cum := cum AND  subspace_of(factor_space(spc1, i), factor_space(spc2, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  IF  space_dimension(spc1)>= space_dimension(spc2)THEN  cum := TRUE ;
 REPEAT  i := 1 TO  space_dimension(spc1);
 cum := cum AND  subspace_of(factor_space(spc1, i), factor_space(spc2, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types1 THEN  IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  n := space_dimension(spc1);
 IF  n < space_dimension(spc2)THEN  n := space_dimension(spc2);
 END_IF ;
 cum := TRUE ;
 REPEAT i := 1 TO n + 1;
 cum := cum AND  subspace_of(factor_space(spc1, i), factor_space(spc2, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  RETURN(spc2 \ elementary_space.space_id = es_maths_functions);
 END_IF ;
 IF  'FUNCTION_SPACE' IN types2 THEN  cum := TRUE;
 sp1 := spc1 \ function_space.domain_argument;
 sp2 := spc2 \ function_space.domain_argument;
 CASE  spc1 \ function_space.domain_constraint OF  sc_equal : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : cum := cum AND  equal_maths_spaces(sp1, sp2);
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : cum := cum AND  member_of(sp1, sp2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : RETURN(FALSE );
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : BEGIN  IF  NOT  member_of(sp1, sp2)THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 END_CASE ;
 END ;
 sc_member : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : cum := cum AND  space_is_singleton(sp1)AND  equal_maths_spaces(singleton_member_of(sp1), sp2);
 sc_subspace : BEGIN  IF  NOT  member_of(sp2, sp1)THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 sc_member : cum := cum AND(subspace_of(sp1, sp2));
 END_CASE ;
 END ;
 END_CASE ;
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 sp1 := spc1 \ function_space.range_argument;
 sp2 := spc2 \ function_space.range_argument;
 CASE  spc1 \ function_space.range_constraint OF  sc_equal : BEGIN  CASE  spc2 \ function_space.range_constraint OF  sc_equal : cum := cum AND  equal_maths_spaces(sp1, sp2);
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : cum := cum AND  member_of(sp1, sp2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : RETURN(FALSE );
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : BEGIN  IF  NOT  member_of(sp1, sp2)THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 END_CASE ;
 END ;
 sc_member : BEGIN  CASE spc2 \ function_space.domain_constraint OF sc_equal : cum := cum AND  space_is_singleton(sp1)AND  equal_maths_spaces(singleton_member_of(sp1), sp2);
 sc_subspace : BEGIN IF NOT member_of(sp2, sp1)THEN RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 sc_member : cum := cum AND subspace_of(sp1, sp2);
 END_CASE ;
 END;
 END_CASE;
 RETURN(cum);
 END_IF ;
 RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- subspace_of

FUNCTION subspace_of_es
	(spc : maths_space; es : elementary_space_enumerators) : LOGICAL;
 LOCAL
 types : SET OF  STRING := stripped_typeof(spc);
 END_LOCAL
;
 IF  NOT  EXISTS(spc)OR  NOT EXISTS(es)THEN  RETURN(FALSE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types THEN  RETURN(es_subspace_of_es(spc \ elementary_space.space_id, es));
 END_IF ;
 IF 'FINITE_SPACE' IN  types THEN RETURN(all_members_of_es(spc \ finite_space.members, es));
 END_IF;
 CASE es OF es_numbers : RETURN(('FINITE_INTEGER_INTERVAL' IN  types)OR('INTEGER_INTERVAL_FROM_MIN' IN  types)OR('INTEGER_INTERVAL_TO_MAX' IN  types)OR('FINITE_REAL_INTERVAL' IN  types)OR('REAL_INTERVAL_FROM_MIN' IN  types)OR('REAL_INTERVAL_TO_MAX' IN  types)OR('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types));
 es_complex_numbers : RETURN(('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types));
 es_reals : RETURN(('FINITE_REAL_INTERVAL' IN  types)OR('REAL_INTERVAL_FROM_MIN' IN  types)OR('REAL_INTERVAL_TO_MAX' IN  types));
 es_integers : RETURN(('FINITE_INTEGER_INTERVAL' IN  types)OR('INTEGER_INTERVAL_FROM_MIN' IN  types)OR('INTEGER_INTERVAL_TO_MAX' IN  types));
 es_logicals : RETURN(FALSE );
 es_booleans : RETURN(FALSE );
 es_strings : RETURN(FALSE );
 es_binarys : RETURN(FALSE );
 es_maths_spaces : RETURN(FALSE);
 es_maths_functions : RETURN('FUNCTION_SPACE' IN types);
 es_generics : RETURN(TRUE);
 END_CASE;
 RETURN(UNKNOWN);
 END_FUNCTION; -- subspace_of_es

FUNCTION substitute
	(expr : generic_expression; vars : LIST [1:?] OF generic_variable; vals : LIST [1:?] OF maths_value) : generic_expression;
 LOCAL
 types : SET OF  STRING := stripped_typeof(expr);
 opnds : LIST  OF  generic_expression;
 op1, op2 : generic_expression;
 qvars : LIST  OF  generic_variable;
 srcdom : maths_space_or_function;
 prpfun : LIST [ 1 : ? ] OF maths_function;
 finfun : maths_function_select;
 END_LOCAL
;
 IF  SIZEOF(vars)<> SIZEOF(vals)THEN  RETURN(?);
 END_IF ;
 IF  'GENERIC_LITERAL' IN  types THEN  RETURN(expr);
 END_IF ;
 IF  'GENERIC_VARIABLE' IN  types THEN  REPEAT  i := 1 TO  SIZEOF(vars);
 IF  expr :=: vars [ i ] THEN  RETURN(vals [ i ]);
 END_IF ;
 END_REPEAT ;
 RETURN(expr);
 END_IF ;
 IF  'QUANTIFIER_EXPRESSION' IN  types THEN  qvars := expr \ quantifier_expression.variables;
 REPEAT  i := SIZEOF(vars)TO  1 BY - 1;
 IF  vars [ i ] IN  qvars THEN  REMOVE(vars, i);
 REMOVE(vals, i);
 END_IF ;
 END_REPEAT ;
 opnds := expr \ multiple_arity_generic_expression.operands;
 REPEAT  i := 1 TO  SIZEOF(opnds);
 IF  NOT(opnds [ i ] IN  qvars)THEN  expr \ multiple_arity_generic_expression.operands [ i ] := substitute(opnds [ i ], vars, vals);
 END_IF ;
 END_REPEAT ;
 RETURN(expr);
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  types THEN  op1 := expr \ unary_generic_expression.operand;
 expr \ unary_generic_expression.operand := substitute(op1, vars, vals);
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  types THEN  op1 := expr \ binary_generic_expression.operands [ 1 ];
 expr \ binary_generic_expression.operands [ 1 ] := substitute(op1, vars, vals);
 op2 := expr \ binary_generic_expression.operands [ 2 ];
 expr \ binary_generic_expression.operands [ 2 ] := substitute(op2, vars, vals);
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  types THEN  srcdom := expr \ parallel_composed_function.source_of_domain;
 prpfun := expr \ parallel_composed_function.prep_functions;
 finfun := expr \ parallel_composed_function.final_function;
 srcdom := substitute(srcdom, vars, vals);
 REPEAT  i := 1 TO  SIZEOF(prpfun);
 prpfun [ i ] := substitute(prpfun [ i ], vars, vals);
 END_REPEAT ;
 IF  'MATHS_FUNCTION' IN  stripped_typeof(finfun)THEN  finfun := substitute(finfun, vars, vals);
 END_IF ;
 RETURN(make_parallel_composed_function(srcdom, prpfun, finfun));
 END_IF ;
 IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN opnds := expr \ multiple_arity_generic_expression.operands;
 REPEAT i := 1 TO SIZEOF(opnds);
 expr \ multiple_arity_generic_expression.operands [ i ] := substitute(opnds [ i ], vars, vals);
 END_REPEAT;
 END_IF;
 RETURN(expr);
 END_FUNCTION; -- substitute

FUNCTION values_space_of
	(expr : generic_expression) : maths_space;
 LOCAL
 e_prefix : STRING  := 'ISO13584_EXPRESSIONS_SCHEMA.';
 typenames : SET OF STRING := TYPEOF(expr);
 END_LOCAL
;
 IF(schema_prefix + 'MATHS_VARIABLE')IN  typenames THEN  RETURN(expr \ maths_variable.values_space);
 END_IF ;
 IF(e_prefix + 'EXPRESSION')IN  typenames THEN  IF(e_prefix + 'NUMERIC_EXPRESSION')IN  typenames THEN  IF  expr \ numeric_expression.is_int THEN  IF(e_prefix + 'INT_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ int_literal.the_value ]));
 ELSE  RETURN(the_integers);
 END_IF ;
 ELSE  IF(e_prefix + 'REAL_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ real_literal.the_value ]));
 ELSE  RETURN(the_reals);
 END_IF ;
 END_IF ;
 END_IF ;
 IF(e_prefix + 'BOOLEAN_EXPRESSION')IN  typenames THEN  IF(e_prefix + 'BOOLEAN_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ boolean_literal.the_value ]));
 ELSE  RETURN(the_booleans);
 END_IF ;
 END_IF ;
 IF(e_prefix + 'STRING_EXPRESSION')IN  typenames THEN  IF(e_prefix + 'STRING_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ string_literal.the_value ]));
 ELSE  RETURN(the_strings);
 END_IF ;
 END_IF ;
 RETURN(?);
 END_IF ;
 IF(schema_prefix + 'MATHS_FUNCTION')IN  typenames THEN  IF  expression_is_constant(expr)THEN  RETURN(make_finite_space([ expr ]));
 ELSE  RETURN(make_function_space(sc_equal, expr \ maths_function.domain, sc_equal, expr \ maths_function.range));
 END_IF ;
 END_IF ;
 IF(schema_prefix + 'FUNCTION_APPLICATION')IN  typenames THEN  RETURN(expr \ function_application.func.range);
 END_IF ;
 IF(schema_prefix + 'MATHS_SPACE')IN  typenames THEN  IF  expression_is_constant(expr)THEN  RETURN(make_finite_space([ expr ]));
 ELSE RETURN(make_elementary_space(es_maths_spaces));
 END_IF ;
 END_IF ;
 IF(schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION')IN  typenames THEN  RETURN(values_space_of(expr \ unary_generic_expression.operand));
 END_IF ;
 IF(schema_prefix + 'COMPLEX_NUMBER_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr ]));
 END_IF ;
 IF(schema_prefix + 'LOGICAL_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ logical_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'BINARY_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ binary_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'MATHS_ENUM_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ maths_enum_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'REAL_TUPLE_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ real_tuple_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'INTEGER_TUPLE_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ integer_tuple_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'ATOM_BASED_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ atom_based_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'MATHS_TUPLE_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ maths_tuple_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION')IN  typenames THEN  RETURN(drop_numeric_constraints(values_space_of(expr \ partial_derivative_expression.derivand)));
 END_IF ;
 IF(schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION')IN typenames THEN RETURN(drop_numeric_constraints(values_space_of(expr \ definite_integral_expression.integrand)));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- values_space_of

FUNCTION derive_dimensional_exponents
	(x : unit) : dimensional_exponents;
 LOCAL
 result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
 END_LOCAL
;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.DERIVED_UNIT' IN TYPEOF(x)THEN REPEAT i := LOINDEX(x.elements)TO HIINDEX(x.elements);
 result.length_exponent := result.length_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.length_exponent);
 result.mass_exponent := result.mass_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.mass_exponent);
 result.time_exponent := result.time_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.time_exponent);
 result.electric_current_exponent := result.electric_current_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.electric_current_exponent);
 result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.thermodynamic_temperature_exponent);
 result.amount_of_substance_exponent := result.amount_of_substance_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.amount_of_substance_exponent);
 result.luminous_intensity_exponent := result.luminous_intensity_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.luminous_intensity_exponent);
 END_REPEAT;
 ELSE result := x.dimensions;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- derive_dimensional_exponents

FUNCTION dimensions_for_si_unit
	(n : si_unit_name) : dimensional_exponents;
 CASE n OF metre : RETURN(dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 gram : RETURN(dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 second : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
 ampere : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
 kelvin : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
 mole : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
 candela : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
 radian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 steradian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 hertz : RETURN(dimensional_exponents(0.0, 0.0, - 1.0, 0.0, 0.0, 0.0, 0.0));
 newton : RETURN(dimensional_exponents(1.0, 1.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 pascal : RETURN(dimensional_exponents(- 1.0, 1.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 joule : RETURN(dimensional_exponents(2.0, 1.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 watt : RETURN(dimensional_exponents(2.0, 1.0, - 3.0, 0.0, 0.0, 0.0, 0.0));
 coulomb : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
 volt : RETURN(dimensional_exponents(2.0, 1.0, - 3.0, - 1.0, 0.0, 0.0, 0.0));
 farad : RETURN(dimensional_exponents(- 2.0, - 1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
 ohm : RETURN(dimensional_exponents(2.0, 1.0, - 3.0, - 2.0, 0.0, 0.0, 0.0));
 siemens : RETURN(dimensional_exponents(- 2.0, - 1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
 weber : RETURN(dimensional_exponents(2.0, 1.0, - 2.0, - 1.0, 0.0, 0.0, 0.0));
 tesla : RETURN(dimensional_exponents(0.0, 1.0, - 2.0, - 1.0, 0.0, 0.0, 0.0));
 henry : RETURN(dimensional_exponents(2.0, 1.0, - 2.0, - 2.0, 0.0, 0.0, 0.0));
 degree_Celsius : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
 lumen : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
 lux : RETURN(dimensional_exponents(- 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
 becquerel : RETURN(dimensional_exponents(0.0, 0.0, - 1.0, 0.0, 0.0, 0.0, 0.0));
 gray : RETURN(dimensional_exponents(2.0, 0.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 sievert : RETURN(dimensional_exponents(2.0, 0.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- dimensions_for_si_unit

FUNCTION valid_units
	(m : measure_with_unit) : BOOLEAN;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LENGTH_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MASS_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.TIME_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PLANE_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SOLID_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.AREA_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VOLUME_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.RATIO_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POSITIVE_LENGTH_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)THEN  IF derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN RETURN(FALSE);
 END_IF ;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- valid_units

FUNCTION consistent_bus_structural_definition
	(input_rel : SET [1:?] OF product_definition_relationship) : BOOLEAN;
 LOCAL
 input : SET  OF  product_definition := [ ];
 vertex : SET OF product_definition := [ ];
 edge : INTEGER  := SIZEOF(input);
 vc : INTEGER  := 0;
 vertex_degree : INTEGER := 0;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(input_rel)BY  1;
 input := input + input_rel [ i ].related_product_definition;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(input)BY  1;
 vertex := vertex + input [ i ] \ product_definition_relationship.relating_product_definition;
 vertex := vertex + input [ i ] \ product_definition_relationship.related_product_definition;
 END_REPEAT ;
 vc := SIZEOF(vertex);
 IF(vc <>(edge + 1))THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  vc BY  1;
 vertex_degree := 0;
 REPEAT j := 1 TO SIZEOF(input)BY 1;
 IF  input [ j ] \ product_definition_relationship.relating_product_definition = vertex [ i ] THEN  vertex_degree := vertex_degree + 1;
 END_IF ;
 IF  input [ j ] \ product_definition_relationship.related_product_definition = vertex [ i ] THEN  vertex_degree := vertex_degree + 1;
 END_IF ;
 END_REPEAT ;
 IF(vertex_degree > 2)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- consistent_bus_structural_definition

FUNCTION valid_selected_instance_representation
	(pd : product_definition_or_assembly_relationship) : LOGICAL;
 LOCAL
 properties : SET  OF  property_definition := [ ];
 property_definition_representations : SET OF property_definition_representation := [ ];
 selected_representation : representation;
 END_LOCAL
;
 properties := QUERY(prd <* USEDIN(pd, 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION.DEFINITION')|(prd.name = 'occurrence selection'));
 IF(SIZEOF(properties)<> 1)THEN  RETURN(FALSE );
 END_IF ;
 property_definition_representations := QUERY(pdr <* USEDIN(properties [ 1 ], 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation.name = 'selection criteria'));
 IF(SIZEOF(property_definition_representations)<> 1)THEN  RETURN(FALSE );
 END_IF ;
 selected_representation := property_definition_representations [ 1 ].used_representation;
 IF(SIZEOF(selected_representation.items)< 1)OR(SIZEOF(selected_representation.items)> 2)THEN  RETURN(FALSE );
 END_IF ;
 IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |(SIZEOF([ 'PRODUCT_OCCURRENCE_MIM.MEASURE_REPRESENTATION_ITEM', 'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE' ] * TYPEOF(i))= 1)AND(i.name = 'selection quantity')))<> 1)THEN  RETURN(FALSE );
 END_IF ;
 IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |('PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(i))AND(i.name = 'selection control')))> 1)THEN  RETURN(FALSE );
 END_IF ;
 IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |('PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i))AND(i.name = 'selection control')))= 0)AND(SIZEOF(QUERY(i <* selected_representation.used_representation.items |(i.name = 'selection quantity')AND(SIZEOF([ 'PRODUCT_OCCURRENCE_MIM.QUALIFIED_REPRESENTATION_ITEM', 'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE' ] * TYPEOF(i))= 0)))> 0)THEN RETURN(FALSE);
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- valid_selected_instance_representation

FUNCTION acyclic_organization_relationship
	(relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF organization_relationship;
 END_LOCAL
;
 IF  relation.relating_organization IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION'))| specific_relation IN TYPEOF(org));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_organization_relationship(x [ i ], relatives + relation.relating_organization, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_organization_relationship

FUNCTION acyclic_organization_type_relationship
	(relation : organization_type_relationship; relatives : SET [0:?] OF organization_type; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF organization_type_relationship;
 END_LOCAL
;
 IF  relation.relating_organization_type IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE'))| specific_relation IN TYPEOF(orgtyp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_organization_type_relationship(x [ i ], relatives + relation.relating_organization_type, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_organization_type_relationship

FUNCTION acyclic_organizational_project_relationship
	(relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF organizational_project_relationship;
 END_LOCAL
;
 IF  relation.relating_organizational_project IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT'))| specific_relation IN TYPEOF(op));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_organizational_project_relationship(x [ i ], relatives + relation.relating_organizational_project, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_organizational_project_relationship

FUNCTION acyclic_person_type_definition_relationship
	(relation : person_type_definition_relationship; relatives : SET [0:?] OF person_type_definition; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF person_type_definition_relationship;
 END_LOCAL
;
 IF  relation.relating_person_type_definition IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION'))| specific_relation IN TYPEOF(ptdef));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_person_type_definition_relationship(x [ i ], relatives + relation.relating_person_type_definition, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_person_type_definition_relationship

FUNCTION acyclic_position_in_organization_relationship
	(relation : position_in_organization_relationship; relatives : SET [0:?] OF position_in_organization; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF position_in_organization_relationship;
 END_LOCAL
;
 IF  relation.relating_position_in_organization IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION'))| specific_relation IN TYPEOF(piorg));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_position_in_organization_relationship(x [ i ], relatives + relation.relating_position_in_organization, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_position_in_organization_relationship

FUNCTION is_assembly_module_macro_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'macro occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_macro_occurrence

FUNCTION is_assembly_module_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'physical occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_occurrence

FUNCTION is_interconnect_module_macro_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'macro occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_macro_occurrence

FUNCTION is_interconnect_module_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'physical occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_occurrence

FUNCTION is_assembly_module_design
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_design

FUNCTION is_assembly_module_usage
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design usage'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_usage

FUNCTION is_ee_product_definition
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF(NOT(is_laminate_component(pd))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(pd)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'STRATUM' IN  TYPEOF(pd)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN  TYPEOF(pd)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN  TYPEOF(pd)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN  TYPEOF(pd)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN  TYPEOF(pd)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN  TYPEOF(pd)))AND(NOT('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd))))THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_ee_product_definition

FUNCTION is_interconnect_module_design
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_design

FUNCTION is_interconnect_module_usage
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design usage'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_usage

FUNCTION is_laminate_component
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 IF(pd \ product_definition.description = 'laminate component')THEN  RETURN(TRUE );
 ELSE IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRINTED_COMPONENT' IN TYPEOF(pd))THEN RETURN(TRUE);
 END_IF ;
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_laminate_component

FUNCTION acyclic_product_category_relationship
	(relation : product_category_relationship; children : SET [0:?] OF product_category) : BOOLEAN;
 LOCAL
 x : SET  OF  product_category_relationship;
 local_children : SET OF product_category;
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(children);
 IF  relation.category :=: children [ i ] THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 x := bag_to_set(USEDIN(relation.category, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
 local_children := children + relation.category;
 IF  SIZEOF(x)> 0 THEN  REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_category_relationship(x [ i ], local_children)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_category_relationship

FUNCTION acyclic_product_definition_formation_relationship
	(relation : product_definition_formation_relationship; relatives : SET [1:?] OF product_definition_formation; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF product_definition_formation_relationship;
 END_LOCAL
;
 IF  relation.relating_product_definition_formation IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION'))| specific_relation IN TYPEOF(pdf));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_definition_formation_relationship(x [ i ], relatives + relation.relating_product_definition_formation, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_definition_formation_relationship

FUNCTION acyclic_product_definition_relationship
	(relation : product_definition_relationship; relatives : SET [1:?] OF product_definition; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF product_definition_relationship;
 END_LOCAL
;
 IF  relation.relating_product_definition IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))| specific_relation IN TYPEOF(pd));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_definition_relationship(x [ i ], relatives + relation.relating_product_definition, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_definition_relationship

FUNCTION acyclic_product_relationship
	(relation : product_relationship; relatives : SET [1:?] OF product; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF product_relationship;
 END_LOCAL
;
 IF  relation.relating_product IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT'))| specific_relation IN TYPEOF(prod));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_relationship(x [ i ], relatives + relation.relating_product, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_relationship

FUNCTION get_product_definitions
	(c_def_instance : product) : SET [0:?] OF product_definition;
 LOCAL
 pd_set : SET  OF  product_definition_formation := [ ];
 pdr_set : SET OF product_definition := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(USEDIN(c_def_instance, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set + bag_to_set(USEDIN(pd_set [ i ], 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRODUCT_DEFINITION.FORMATION'));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_product_definitions

FUNCTION acyclic_characterized_object_relationship
	(relation : characterized_object_relationship; relatives : SET [1:?] OF characterized_object; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF characterized_object_relationship;
 END_LOCAL
;
 IF  relation.relating_object IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT'))| specific_relation IN TYPEOF(ca));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_characterized_object_relationship(x [ i ], relatives + relation.relating_object, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_characterized_object_relationship

FUNCTION acyclic_general_property_relationship
	(relation : general_property_relationship; relatives : SET [1:?] OF general_property; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF general_property_relationship;
 END_LOCAL
;
 IF  relation.relating_property IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY'))| specific_relation IN TYPEOF(genp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_general_property_relationship(x [ i ], relatives + relation.relating_property, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_general_property_relationship

FUNCTION acyclic_shape_aspect_relationship
	(relation : shape_aspect_relationship; relatives : SET [1:?] OF shape_aspect; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF shape_aspect_relationship;
 END_LOCAL
;
 IF  relation.relating_shape_aspect IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT'))| specific_relation IN TYPEOF(sa));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_shape_aspect_relationship(x [ i ], relatives + relation.relating_shape_aspect, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_shape_aspect_relationship

FUNCTION get_shape_aspects
	(c_def_instance : characterized_definition) : SET [0:?] OF shape_aspect;
 LOCAL
 pd_set : SET  OF  product_definition_shape := [ ];
 pdr_set : SET OF shape_aspect := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PROPERTY_DEFINITION.DEFINITION')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set + bag_to_set(USEDIN(pd_set [ i ], 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_shape_aspects

FUNCTION get_property_definition_representations
	(c_def_instance : characterized_definition) : SET [0:?] OF property_definition_representation;
 LOCAL
 pd_set : SET  OF  property_definition := [ ];
 pdr_set : SET OF property_definition_representation := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set + bag_to_set(USEDIN(pd_set [ i ], 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_property_definition_representations

FUNCTION relatives_of_product_definitions
	(definition_set : SET [0:?] OF product_definition; relation_subtype : STRING) : SET [0:?] OF product_definition;
 FUNCTION local_relatives_of_product_definitions(definition_set : SET  OF  product_definition;
 total_definitions : SET  OF  product_definition;
 relation_subtype : STRING): SET  OF  product_definition;
 LOCAL
 local_def : SET  OF  product_definition := [ ];
 local_pdr : SET  OF  product_definition_relationship := [ ];
 local_total : SET OF product_definition := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(definition_set);
 local_pdr := local_pdr + bag_to_set(USEDIN(definition_set [ i ], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
 END_REPEAT ;
 REPEAT i := 1 TO HIINDEX(local_pdr);
 local_def := local_def + local_pdr [ i ].related_product_definition;
 END_REPEAT;
 IF(SIZEOF(local_def)- SIZEOF(total_definitions))= 0 THEN RETURN(local_def);
 ELSE local_total := total_definitions + local_def;
 RETURN(local_def +(local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
 END_IF;
 END_FUNCTION;
 RETURN(local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
 END_FUNCTION; -- relatives_of_product_definitions

FUNCTION relatives_of_shape_representations
	(shape_representation_set : SET [0:?] OF shape_representation) : SET [0:?] OF shape_representation;
 FUNCTION local_relatives_of_shape_representations(shape_representation_set : SET  OF  shape_representation;
 total_reps : SET  OF  shape_representation): SET  OF  shape_representation;
 LOCAL
 local_shape_rep : SET  OF  shape_representation := [ ];
 local_srr : SET  OF  shape_representation_relationship := [ ];
 local_total : SET OF shape_representation := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(shape_representation_set);
 local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set [ i ], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1'))| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP' IN  TYPEOF(rr));
 END_REPEAT ;
 REPEAT i := 1 TO HIINDEX(local_srr);
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr [ i ])THEN  local_shape_rep := local_shape_rep + local_srr [ i ].rep_2;
 END_IF ;
 END_REPEAT;
 IF SIZEOF(local_shape_rep - total_reps)= 0 THEN RETURN(shape_representation_set);
 ELSE local_total := total_reps + local_shape_rep;
 RETURN(local_shape_rep +(local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
 END_IF;
 END_FUNCTION;
 RETURN(local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));
 END_FUNCTION; -- relatives_of_shape_representations

FUNCTION acyclic_qualification_relationship
	(relation : qualification_relationship; relatives : SET [0:?] OF qualification; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF qualification_relationship;
 END_LOCAL
;
 IF  relation.relating_qualification IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION'))| specific_relation IN TYPEOF(qual));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_qualification_relationship(x [ i ], relatives + relation.relating_qualification, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_qualification_relationship

FUNCTION acyclic_qualification_type_relationship
	(relation : qualification_type_relationship; relatives : SET [0:?] OF qualification_type; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF qualification_type_relationship;
 END_LOCAL
;
 IF  relation.relating_qualification_type IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE'))| specific_relation IN TYPEOF(qultyp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_qualification_type_relationship(x [ i ], relatives + relation.relating_qualification_type, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_qualification_type_relationship

FUNCTION acyclic_mapped_representation
	(parent_set : SET [0:?] OF representation; children_set : SET [0:?] OF representation_item) : BOOLEAN;
 LOCAL
 x, y : SET OF representation_item;
 END_LOCAL
;
 x := QUERY(z <* children_set | 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.MAPPED_ITEM' IN  TYPEOF(z));
 IF  SIZEOF(x)> 0 THEN  REPEAT  i := 1 TO  HIINDEX(x);
 IF  x [ i ] \ mapped_item.mapping_source.mapped_representation IN  parent_set THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT  acyclic_mapped_representation(parent_set + x [ i ] \ mapped_item.mapping_source.mapped_representation, x [ i ] \ mapped_item.mapping_source.mapped_representation.items)THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_IF ;
 x := children_set - x;
 IF  SIZEOF(x)> 0 THEN  REPEAT i := 1 TO HIINDEX(x);
 y := QUERY(z <* bag_to_set(USEDIN(x [ i ], ''))| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
 IF NOT acyclic_mapped_representation(parent_set, y)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_mapped_representation

FUNCTION item_in_context
	(item : representation_item; cntxt : representation_context) : BOOLEAN;
 LOCAL
 y : BAG OF representation_item;
 END_LOCAL
;
 IF  SIZEOF(USEDIN(item, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REPRESENTATION.ITEMS')* cntxt.representations_in_context)> 0 THEN  RETURN(TRUE );
 ELSE y := QUERY(z <* USEDIN(item, '')| 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
 IF  SIZEOF(y)> 0 THEN  REPEAT i := 1 TO HIINDEX(y);
 IF item_in_context(y [ i ], cntxt)THEN RETURN(TRUE);
 END_IF ;
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- item_in_context

FUNCTION using_items
	(item : founded_item_select; checked_items : SET [0:?] OF founded_item_select) : SET [0:?] OF founded_item_select;
 LOCAL
 new_check_items : SET  OF  founded_item_select;
 result_items : SET  OF  founded_item_select;
 next_items : SET OF founded_item_select;
 END_LOCAL
;
 result_items := [ ];
 new_check_items := checked_items + item;
 next_items := QUERY(z <* bag_to_set(USEDIN(item, ''))|('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REPRESENTATION_ITEM' IN  TYPEOF(z))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FOUNDED_ITEM' IN  TYPEOF(z)));
 IF  SIZEOF(next_items)> 0 THEN  REPEAT i := 1 TO HIINDEX(next_items);
 IF NOT(next_items [ i ] IN new_check_items)THEN result_items := result_items + next_items [ i ] + using_items(next_items [ i ], new_check_items);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(result_items);
 END_FUNCTION; -- using_items

FUNCTION using_representations
	(item : founded_item_select) : SET [0:?] OF representation;
 LOCAL
 results : SET  OF  representation;
 result_bag : BAG OF  representation;
 intermediate_items : SET OF founded_item_select;
 END_LOCAL
;
 results := [ ];
 result_bag := USEDIN(item, 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REPRESENTATION.ITEMS');
 IF  SIZEOF(result_bag)> 0 THEN  REPEAT  i := 1 TO  HIINDEX(result_bag);
 results := results + result_bag [ i ];
 END_REPEAT ;
 END_IF ;
 intermediate_items := using_items(item, [ ]);
 IF  SIZEOF(intermediate_items)> 0 THEN  REPEAT  i := 1 TO  HIINDEX(intermediate_items);
 result_bag := USEDIN(intermediate_items [ i ], 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.REPRESENTATION.ITEMS');
 IF SIZEOF(result_bag)> 0 THEN REPEAT j := 1 TO HIINDEX(result_bag);
 results := results + result_bag [ j ];
 END_REPEAT ;
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(results);
 END_FUNCTION; -- using_representations

FUNCTION valid_measure_value
	(m : measure_value) : BOOLEAN;
 IF('REAL' IN  TYPEOF(m))THEN  RETURN(m > 0.0);
 ELSE  IF('INTEGER' IN TYPEOF(m))THEN RETURN(m > 0);
 ELSE RETURN(TRUE);
 END_IF ;
 END_IF;
 END_FUNCTION; -- valid_measure_value

FUNCTION instance_unique
	(the_bag : BAG [0:?] OF GENERIC) : BOOLEAN;
 LOCAL
 the_set : SET OF GENERIC : intype := [ ];
 i : INTEGER;
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 IF  SIZEOF(the_bag)> 0 THEN  the_set := bag_to_set(the_bag);
 END_IF ;
 IF NOT(SIZEOF(the_set)= SIZEOF(the_bag))THEN pass := FALSE;
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- instance_unique

FUNCTION categories_of_product
	(obj : product) : SET [0:?] OF STRING;
 LOCAL
 category_assignments : BAG OF  product_category;
 categories : SET OF STRING := [ ];
 i : INTEGER;
 END_LOCAL
;
 category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
 REPEAT i := LOINDEX(category_assignments)TO HIINDEX(category_assignments)BY 1;
 categories := categories + category_assignments [ i ].name;
 END_REPEAT;
 RETURN(categories);
 END_FUNCTION; -- categories_of_product

FUNCTION bag_to_set
	(the_bag : BAG [0:?] OF GENERIC) : SET [0:?] OF GENERIC;
 LOCAL
 the_set : SET OF GENERIC : intype := [ ];
 END_LOCAL
;
 IF SIZEOF(the_bag)> 0 THEN REPEAT i := 1 TO HIINDEX(the_bag);
 the_set := the_set + the_bag [ i ];
 END_REPEAT;
 END_IF;
 RETURN(the_set);
 END_FUNCTION; -- bag_to_set

FUNCTION type_check_function
	(the_type : GENERIC; sub_names : SET [0:?] OF STRING; criterion : INTEGER) : LOGICAL;
 IF((NOT  EXISTS(the_type))OR(NOT({ 0 <= criterion <= 3 }))OR(SIZEOF(sub_names)= 0))THEN RETURN(UNKNOWN);
 ELSE CASE criterion OF 0 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))> 0);
 1 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))= 0);
 2 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))= 1);
 3 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))<= 1);
 END_CASE;
 END_IF;
 END_FUNCTION; -- type_check_function

FUNCTION boolean_choose
	(b : BOOLEAN; choice1 : GENERIC:item; choice2 : GENERIC:item) : GENERIC:item;
 IF b THEN RETURN(choice1);
 ELSE RETURN(choice2);
 END_IF;
 END_FUNCTION; -- boolean_choose

FUNCTION closed_shell_reversed
	(a_shell : closed_shell) : oriented_closed_shell;
 LOCAL
 the_reverse : oriented_closed_shell;
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell))THEN the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| closed_shell()|| oriented_closed_shell(a_shell \ oriented_closed_shell.closed_shell_element, NOT(a_shell \ oriented_closed_shell.orientation));
 ELSE the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| closed_shell()|| oriented_closed_shell(a_shell, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- closed_shell_reversed

FUNCTION conditional_reverse
	(p : BOOLEAN; an_item : reversible_topology) : reversible_topology;
 IF p THEN RETURN(an_item);
 ELSE RETURN(topology_reversed(an_item));
 END_IF;
 END_FUNCTION; -- conditional_reverse

FUNCTION edge_curve_pcurves
	(an_edge : edge_curve; the_surface_curves : SET [0:?] OF surface_curve) : SET [0:?] OF pcurve;
 LOCAL
 a_curve : curve;
 result : SET OF  pcurve;
 the_geometry : LIST [ 1 : 2 ] OF pcurve_or_surface;
 END_LOCAL
;
 a_curve := an_edge.edge_geometry;
 result := [ ];
 IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF(a_curve)THEN  result := result + a_curve;
 ELSE  IF  'GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(a_curve)THEN  the_geometry := a_curve \ surface_curve.associated_geometry;
 REPEAT  k := 1 TO  SIZEOF(the_geometry);
 IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF(the_geometry [ k ])THEN  result := result + the_geometry [ k ];
 END_IF ;
 END_REPEAT ;
 ELSE REPEAT  j := 1 TO  SIZEOF(the_surface_curves);
 the_geometry := the_surface_curves [ j ].associated_geometry;
 IF  the_surface_curves [ j ].curve_3d :=: a_curve THEN  REPEAT k := 1 TO SIZEOF(the_geometry);
 IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(the_geometry [ k ])THEN result := result + the_geometry [ k ];
 END_IF ;
 END_REPEAT ;
 END_IF ;
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(RESULT);
 END_FUNCTION; -- edge_curve_pcurves

FUNCTION edge_reversed
	(an_edge : edge) : oriented_edge;
 LOCAL
 the_reverse : oriented_edge;
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_EDGE' IN TYPEOF(an_edge))THEN the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start)|| oriented_edge(an_edge \ oriented_edge.edge_element, NOT(an_edge \ oriented_edge.orientation));
 ELSE the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start)|| oriented_edge(an_edge, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- edge_reversed

FUNCTION face_bound_reversed
	(a_face_bound : face_bound) : face_bound;
 LOCAL
 the_reverse : face_bound;
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound))THEN the_reverse := dummy_tri || face_bound(a_face_bound \ face_bound.bound, NOT(a_face_bound \ face_bound.orientation))|| face_outer_bound();
 ELSE the_reverse := dummy_tri || face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- face_bound_reversed

FUNCTION face_reversed
	(a_face : face) : oriented_face;
 LOCAL
 the_reverse : oriented_face;
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_FACE' IN TYPEOF(a_face))THEN the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds))|| oriented_face(a_face \ oriented_face.face_element, NOT(a_face \ oriented_face.orientation));
 ELSE the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds))|| oriented_face(a_face, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- face_reversed

FUNCTION list_face_loops
	(f : face) : LIST [0:?] OF loop;
 LOCAL
 loops : LIST [ 0 : ? ] OF loop := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(f.bounds);
 loops := loops +(f.bounds [ i ].bound);
 END_REPEAT;
 RETURN(loops);
 END_FUNCTION; -- list_face_loops

FUNCTION list_loop_edges
	(l : loop) : LIST [0:?] OF edge;
 LOCAL
 edges : LIST [ 0 : ? ] OF edge := [ ];
 END_LOCAL
;
 IF 'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE_LOOP' IN TYPEOF(l)THEN REPEAT i := 1 TO SIZEOF(l \ path.edge_list);
 edges := edges +(l \ path.edge_list [ i ].edge_element);
 END_REPEAT;
 END_IF;
 RETURN(edges);
 END_FUNCTION; -- list_loop_edges

FUNCTION list_of_topology_reversed
	(a_list : list_of_reversible_topology_item) : list_of_reversible_topology_item;
 LOCAL
 the_reverse : list_of_reversible_topology_item;
 END_LOCAL
;
 the_reverse := [ ];
 REPEAT i := 1 TO SIZEOF(a_list);
 the_reverse := topology_reversed(a_list [ i ])+ the_reverse;
 END_REPEAT;
 RETURN(the_reverse);
 END_FUNCTION; -- list_of_topology_reversed

FUNCTION list_shell_edges
	(s : shell) : LIST [0:?] OF edge;
 LOCAL
 edges : LIST [ 0 : ? ] OF edge := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
 edges := edges + list_loop_edges(list_shell_loops(s)[ i ]);
 END_REPEAT;
 RETURN(edges);
 END_FUNCTION; -- list_shell_edges

FUNCTION list_shell_faces
	(s : shell) : LIST [0:?] OF face;
 LOCAL
 faces : LIST [ 0 : ? ] OF face := [ ];
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CLOSED_SHELL' IN  TYPEOF(s))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OPEN_SHELL' IN TYPEOF(s))THEN REPEAT i := 1 TO SIZEOF(s \ connected_face_set.cfs_faces);
 faces := faces + s \ connected_face_set.cfs_faces [ i ];
 END_REPEAT;
 END_IF;
 RETURN(faces);
 END_FUNCTION; -- list_shell_faces

FUNCTION list_shell_loops
	(s : shell) : LIST [0:?] OF loop;
 LOCAL
 loops : LIST [ 0 : ? ] OF loop := [ ];
 END_LOCAL
;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.VERTEX_SHELL' IN  TYPEOF(s)THEN  loops := loops + s.vertex_shell_extent;
 END_IF ;
 IF  'AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.WIRE_SHELL' IN  TYPEOF(s)THEN  REPEAT  i := 1 TO  SIZEOF(s.wire_shell_extent);
 loops := loops + s.wire_shell_extent [ i ];
 END_REPEAT ;
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OPEN_SHELL' IN  TYPEOF(s))OR('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CLOSED_SHELL' IN TYPEOF(s))THEN REPEAT i := 1 TO SIZEOF(s.cfs_faces);
 loops := loops + list_face_loops(s.cfs_faces [ i ]);
 END_REPEAT;
 END_IF;
 RETURN(loops);
 END_FUNCTION; -- list_shell_loops

FUNCTION list_to_set
	(l : LIST [0:?] OF GENERIC) : SET [0:?] OF GENERIC;
 LOCAL
 s : SET OF GENERIC : T := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(l);
 s := s + l [ i ];
 END_REPEAT;
 RETURN(s);
 END_FUNCTION; -- list_to_set

FUNCTION mixed_loop_type_set
	(l : SET [0:?] OF loop) : LOGICAL;
 LOCAL
 poly_loop_type : LOGICAL;
 END_LOCAL
;
 IF(SIZEOF(l)<= 1)THEN  RETURN(FALSE );
 END_IF ;
 poly_loop_type :=('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLY_LOOP' IN  TYPEOF(l [ 1 ]));
 REPEAT i := 2 TO SIZEOF(l);
 IF(('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.POLY_LOOP' IN TYPEOF(l [ i ]))<> poly_loop_type)THEN RETURN(TRUE);
 END_IF;
 END_REPEAT;
 RETURN(FALSE);
 END_FUNCTION; -- mixed_loop_type_set

FUNCTION open_shell_reversed
	(a_shell : open_shell) : oriented_open_shell;
 LOCAL
 the_reverse : oriented_open_shell;
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell))THEN the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| open_shell()|| oriented_open_shell(a_shell \ oriented_open_shell.open_shell_element,(NOT(a_shell \ oriented_open_shell.orientation)));
 ELSE the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| open_shell()|| oriented_open_shell(a_shell, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- open_shell_reversed

FUNCTION path_head_to_tail
	(a_path : path) : LOGICAL;
 LOCAL
 n : INTEGER;
 p : LOGICAL := TRUE;
 END_LOCAL
;
 n := SIZEOF(a_path.edge_list);
 REPEAT i := 2 TO n;
 p := p AND(a_path.edge_list [ i - 1 ].edge_end :=: a_path.edge_list [ i ].edge_start);
 END_REPEAT;
 RETURN(p);
 END_FUNCTION; -- path_head_to_tail

FUNCTION path_reversed
	(a_path : path) : oriented_path;
 LOCAL
 the_reverse : oriented_path;
 END_LOCAL
;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.ORIENTED_PATH' IN TYPEOF(a_path))THEN the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list))|| oriented_path(a_path \ oriented_path.path_element, NOT(a_path \ oriented_path.orientation));
 ELSE the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list))|| oriented_path(a_path, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- path_reversed

FUNCTION set_of_topology_reversed
	(a_set : set_of_reversible_topology_item) : set_of_reversible_topology_item;
 LOCAL
 the_reverse : set_of_reversible_topology_item;
 END_LOCAL
;
 the_reverse := [ ];
 REPEAT i := 1 TO SIZEOF(a_set);
 the_reverse := the_reverse + topology_reversed(a_set [ i ]);
 END_REPEAT;
 RETURN(the_reverse);
 END_FUNCTION; -- set_of_topology_reversed

FUNCTION shell_reversed
	(a_shell : shell) : shell;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.OPEN_SHELL' IN  TYPEOF(a_shell))THEN  RETURN(open_shell_reversed(a_shell));
 ELSE  IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.CLOSED_SHELL' IN TYPEOF(a_shell))THEN RETURN(closed_shell_reversed(a_shell));
 ELSE RETURN(?);
 END_IF ;
 END_IF;
 END_FUNCTION; -- shell_reversed

FUNCTION topology_reversed
	(an_item : reversible_topology) : reversible_topology;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.EDGE' IN  TYPEOF(an_item))THEN  RETURN(edge_reversed(an_item));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.PATH' IN  TYPEOF(an_item))THEN  RETURN(path_reversed(an_item));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FACE_BOUND' IN  TYPEOF(an_item))THEN  RETURN(face_bound_reversed(an_item));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.FACE' IN  TYPEOF(an_item))THEN  RETURN(face_reversed(an_item));
 END_IF ;
 IF('AP210_ASSEMBLY_PHYSICAL_INTERFACE_REQUIREMENTS_MIM_LF.SHELL' IN  TYPEOF(an_item))THEN  RETURN(shell_reversed(an_item));
 END_IF ;
 IF('SET' IN  TYPEOF(an_item))THEN  RETURN(set_of_topology_reversed(an_item));
 END_IF ;
 IF('LIST' IN TYPEOF(an_item))THEN RETURN(list_of_topology_reversed(an_item));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- topology_reversed

FUNCTION vertex_point_pcurves
	(a_vertex : vertex_point; the_degenerates : SET [0:?] OF evaluated_degenerate_pcurve) : SET [0:?] OF degenerate_pcurve;
 LOCAL
 a_point : point;
 result : SET OF degenerate_pcurve;
 END_LOCAL
;
 a_point := a_vertex.vertex_geometry;
 result := [ ];
 IF  'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point)THEN  result := result + a_point;
 ELSE REPEAT j := 1 TO SIZEOF(the_degenerates);
 IF(the_degenerates [ j ].equivalent_point :=: a_point)THEN result := result + the_degenerates [ j ];
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(RESULT);
 END_FUNCTION; -- vertex_point_pcurves

PROCEDURE angle_minmax
	(ab : REAL; a : REAL; a_in : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN; VAR amax_in : BOOLEAN);

END_PROCEDURE; -- angle_minmax

PROCEDURE angle_range
	(VAR amin : REAL; VAR amax : REAL);

END_PROCEDURE; -- angle_range

PROCEDURE find_aminmax
	(ab : REAL; a0 : REAL; a1 : REAL; a2 : REAL; a3 : REAL; in0 : BOOLEAN; in1 : BOOLEAN; in2 : BOOLEAN; in3 : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN; VAR amax_in : BOOLEAN);

END_PROCEDURE; -- find_aminmax

PROCEDURE nearest_good_direction
	(acart : REAL; aitv : finite_real_interval; VAR a : REAL; VAR a_in : BOOLEAN);

END_PROCEDURE; -- nearest_good_direction

PROCEDURE parts
	(c : complex_number_literal; VAR x : REAL; VAR y : REAL);

END_PROCEDURE; -- parts

PROCEDURE range_max
	(r : REAL; incl : BOOLEAN; VAR rmax : REAL; VAR rmax_in : BOOLEAN);

END_PROCEDURE; -- range_max

PROCEDURE range_min
	(r : REAL; incl : BOOLEAN; VAR rmin : REAL; VAR rmin_in : BOOLEAN);

END_PROCEDURE; -- range_min

END_SCHEMA; --ap210_assembly_physical_interface_requirements_mim_lf

