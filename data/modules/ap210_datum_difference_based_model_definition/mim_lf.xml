<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="ap210_datum_difference_based_model_definition_mim_lf schema_instance"/>
   <schema name="Ap210_datum_difference_based_model_definition_mim_LF">
      <constant name="dummy_gri" expression="representation_item('')||&#10;                                   geometric_representation_item()">
         <typename name="geometric_representation_item"/>
      </constant>
      <type name="action_items">
         <select selectitems="configuration_effectivity product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="action_method_items">
         <select selectitems="product product_definition_formation test_method_based_parameter_assignment"/>
      </type>
      <type name="action_request_item">
         <select selectitems="product_definition product_definition_formation product_definition_relationship property_definition versioned_action_request"/>
      </type>
      <type name="ahead_or_behind">
         <enumeration items="ahead exact behind"/>
      </type>
      <type name="aliasable_item">
         <select selectitems="approval_status contract document_file organization product product_definition product_definition_formation security_classification_level"/>
      </type>
      <type name="amount_of_substance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="angle_relator">
         <enumeration items="equal large small"/>
      </type>
      <type name="approval_item">
         <select selectitems="action action_directive applied_action_assignment certification configuration_effectivity configuration_item contract date directed_action document effectivity executed_action general_property_relationship group group_relationship product product_definition product_definition_formation product_definition_formation_relationship product_definition_relationship representation requirement_assignment security_classification shape_aspect_relationship versioned_action_request"/>
      </type>
      <type name="area_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="attribute_classification_item">
         <select selectitems="action_directive action_method action_property action_property_representation action_relationship action_request_solution action_request_status alternate_product_relationship applied_action_assignment applied_action_request_assignment applied_approval_assignment applied_certification_assignment applied_document_reference applied_document_usage_constraint_assignment applied_effectivity_assignment applied_event_occurrence_assignment applied_external_identification_assignment applied_identification_assignment applied_organization_assignment applied_organizational_project_assignment applied_person_and_organization_assignment approval approval_person_organization approval_relationship approval_status certification context_dependent_unit contract date_and_time_assignment date_assignment derived_unit descriptive_representation_item document_file document_relationship effectivity event_occurrence_relationship executed_action general_property general_property_relationship group group_relationship language measure_representation_item measure_with_unit named_unit organization_relationship organizational_address organizational_project_relationship person_and_organization person_and_organization_address product product_category product_concept product_concept_context product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition property_definition_relationship property_definition_representation representation representation_context representation_item security_classification time_interval_relationship uncertainty_measure_with_unit versioned_action_request"/>
      </type>
      <type name="attribute_language_item">
         <select selectitems="applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment applied_organizational_project_assignment approval approval_relationship approval_status attribute_value_assignment certification certification_type contract date_role date_time_role document_relationship document_usage_role external_source identification_role multi_language_attribute_assignment object_role organization_relationship organizational_project organizational_project_relationship organizational_project_role person_and_organization product product_category product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="attribute_type">
         <select selectitems="label text"/>
      </type>
      <type name="axis2_placement">
         <select selectitems="axis2_placement_2d axis2_placement_3d"/>
      </type>
      <type name="b_spline_curve_form">
         <enumeration items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified"/>
      </type>
      <type name="b_spline_surface_form">
         <enumeration items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified"/>
      </type>
      <type name="category_usage_item">
         <select selectitems="product_class"/>
      </type>
      <type name="celsius_temperature_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="certification_item">
         <select selectitems="alternate_product_relationship make_from_usage_option product_definition_formation product_definition_formation_relationship"/>
      </type>
      <type name="characterized_action_definition">
         <select selectitems="action action_method action_method_relationship action_relationship"/>
      </type>
      <type name="characterized_definition">
         <select selectitems="characterized_object characterized_product_definition shape_definition"/>
      </type>
      <type name="characterized_material_property">
         <select selectitems="material_property_representation"/>
      </type>
      <type name="characterized_product_definition">
         <select selectitems="product_definition product_definition_relationship"/>
      </type>
      <type name="classification_item">
         <select selectitems="action action_directive action_method action_property action_relationship action_request_solution action_request_status address alternate_product_relationship applied_action_assignment applied_action_request_assignment applied_approval_assignment applied_certification_assignment applied_contract_assignment applied_date_and_time_assignment applied_date_assignment applied_document_reference applied_document_usage_constraint_assignment applied_effectivity_assignment applied_event_occurrence_assignment applied_external_identification_assignment applied_identification_assignment applied_organization_assignment applied_organizational_project_assignment applied_person_and_organization_assignment applied_security_classification_assignment approval approval_person_organization approval_relationship approval_status assembly_component_usage_substitute calendar_date certification characterized_class characterized_object class configuration_item context_dependent_unit contract conversion_based_unit date_and_time date_and_time_assignment date_assignment derived_unit descriptive_representation_item directed_action document_file document_relationship effectivity event_occurrence executed_action general_property general_property_relationship group identification_assignment language material_designation measure_representation_item measure_with_unit multi_language_attribute_assignment named_unit organization organization_relationship organizational_address organizational_project organizational_project_relationship person person_and_organization_address product product_category product_concept product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition property_definition_representation representation representation_context representation_item security_classification uncertainty_measure_with_unit versioned_action_request"/>
      </type>
      <type name="compound_item_definition">
         <select selectitems="list_representation_item set_representation_item"/>
      </type>
      <type name="configuration_design_item">
         <select selectitems="product_definition product_definition_formation"/>
      </type>
      <type name="context_dependent_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="contract_item">
         <select selectitems="action_directive alternate_product_relationship directed_action organization person_and_organization product product_definition_formation"/>
      </type>
      <type name="count_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="curve_on_surface">
         <select selectitems="pcurve surface_curve composite_curve_on_surface"/>
      </type>
      <type name="date_and_time_item">
         <select selectitems="action action_directive applied_action_assignment applied_organization_assignment applied_person_and_organization_assignment applied_security_classification_assignment approval_person_organization certification contract directed_action document document_file event_occurrence executed_action organizational_project product_definition product_definition_formation product_definition_relationship rule_action security_classification versioned_action_request"/>
      </type>
      <type name="date_item">
         <select selectitems="action action_directive applied_action_assignment applied_organization_assignment applied_person_and_organization_assignment applied_security_classification_assignment approval_person_organization certification contract directed_action document document_file event_occurrence executed_action organizational_project product_definition product_definition_formation product_definition_relationship security_classification versioned_action_request"/>
      </type>
      <type name="date_time_or_event_occurrence">
         <select selectitems="date_time_select event_occurrence"/>
      </type>
      <type name="date_time_select">
         <select selectitems="date date_and_time local_time"/>
      </type>
      <type name="day_in_month_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{1 &lt;= SELF &lt;= 31}"/>
      </type>
      <type name="derived_property_select">
         <select selectitems="action_property property_definition"/>
      </type>
      <type name="description_attribute_select">
         <select selectitems="action_request_solution application_context approval_role configuration_design context_dependent_shape_representation date_role date_time_role effectivity external_source organization_role person_and_organization person_and_organization_role property_definition_representation representation"/>
      </type>
      <type name="descriptive_measure">
         <builtintype type="STRING"/>
      </type>
      <type name="dimension_count">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="SELF &gt; 0"/>
      </type>
      <type name="dimensional_characteristic">
         <select selectitems="dimensional_location dimensional_size"/>
      </type>
      <type name="document_identifier_assigned_item">
         <select selectitems="document"/>
      </type>
      <type name="document_reference_item">
         <select selectitems="action_method analytical_model_definition applied_external_identification_assignment assembly_component_usage characterized_class characterized_object configuration_item descriptive_representation_item dimensional_size executed_action externally_defined_dimension_definition externally_defined_item group group_relationship material_designation measure_representation_item model_parameter predefined_requirement_view_definition product product_category product_definition product_definition_formation product_definition_formation_relationship property_definition representation representation_item rule_set shape_aspect shape_aspect_relationship versioned_action_request"/>
      </type>
      <type name="effectivity_item">
         <select selectitems="product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="electric_current_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="event_occurrence_item">
         <select selectitems="organizational_project"/>
      </type>
      <type name="external_identification_item">
         <select selectitems="action_relationship action_request_status applied_organization_assignment applied_person_and_organization_assignment approval approval_status composite_signal_property_relationship date_and_time_assignment date_assignment digital_analytical_model_vector_port document_file externally_defined_class functional_specification organizational_address product_definition property_definition security_classification shape_dimension_representation shape_representation signal trimmed_curve versioned_action_request"/>
      </type>
      <type name="founded_item_select">
         <select selectitems="founded_item representation_item"/>
      </type>
      <type name="groupable_item">
         <select selectitems="group_relationship package_product_concept_feature predefined_requirement_view_definition product_concept_feature product_definition product_definition_formation property_definition_representation representation representation_item shape_aspect shape_aspect_relationship"/>
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.GROUP' IN TYPEOF(SELF))"/>
      </type>
      <type name="hour_in_day">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 0 &lt;= SELF &lt; 24 }"/>
      </type>
      <type name="id_attribute_select">
         <select selectitems="action address application_context group organizational_project product_category property_definition representation shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="identification_item">
         <select selectitems="aliasable_item approval_status characterized_class class configuration_item contract dimensional_size document_file group group_relationship material_designation organization person_and_organization product product_category product_class product_concept product_concept_feature product_definition product_definition_formation product_identification rule_set security_classification_level shape_aspect_relationship shape_representation"/>
      </type>
      <type name="identifier">
         <builtintype type="STRING"/>
      </type>
      <type name="knot_type">
         <enumeration items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified"/>
      </type>
      <type name="label">
         <builtintype type="STRING"/>
      </type>
      <type name="length_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="limit_condition">
         <enumeration items="maximum_material_condition least_material_condition regardless_of_feature_size"/>
      </type>
      <type name="list_representation_item">
         <aggregate type="LIST" lower="1" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="luminous_intensity_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="mass_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="measure_value">
         <select selectitems="amount_of_substance_measure area_measure celsius_temperature_measure context_dependent_measure count_measure descriptive_measure electric_current_measure length_measure luminous_intensity_measure mass_measure numeric_measure parameter_value plane_angle_measure positive_length_measure positive_plane_angle_measure positive_ratio_measure ratio_measure solid_angle_measure thermodynamic_temperature_measure time_measure volume_measure"/>
      </type>
      <type name="minute_in_hour">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 0 &lt;= SELF &lt;= 59 }"/>
      </type>
      <type name="model_parameter_assigned_item">
         <select selectitems="unit"/>
      </type>
      <type name="month_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 1 &lt;= SELF &lt;= 12 }"/>
      </type>
      <type name="multi_language_attribute_item">
         <select selectitems="applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment applied_organizational_project_assignment approval approval_relationship approval_status certification certification_type contract date_role date_time_role document_relationship document_usage_role external_source identification_role object_role organization_relationship organizational_project organizational_project_relationship organizational_project_role person_and_organization product product_category product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="name_attribute_select">
         <select selectitems="action_request_solution address configuration_design context_dependent_shape_representation derived_unit effectivity person_and_organization product_definition property_definition_representation"/>
      </type>
      <type name="name_item">
         <select selectitems="assembly_component_usage external_class_library group group_relationship product product_definition"/>
      </type>
      <type name="numeric_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="organization_item">
         <select selectitems="action action_directive applied_action_assignment applied_classification_assignment applied_identification_assignment applied_security_classification_assignment approval class configuration_item contract document_file executed_action product product_definition product_definition_formation product_definition_formation_relationship rule_action security_classification versioned_action_request"/>
      </type>
      <type name="parameter_value">
         <builtintype type="REAL"/>
      </type>
      <type name="pcurve_or_surface">
         <select selectitems="pcurve surface"/>
      </type>
      <type name="person_and_organization_item">
         <select selectitems="action action_directive applied_action_assignment applied_classification_assignment applied_identification_assignment applied_security_classification_assignment approval configuration_item contract document_file executed_action person_and_organization product product_definition product_definition_formation product_definition_formation_relationship rule_action security_classification versioned_action_request"/>
      </type>
      <type name="person_organization_select">
         <select selectitems="organization person person_and_organization"/>
      </type>
      <type name="plane_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="positive_length_measure">
         <typename name="length_measure"/>
         <where label="WR1" expression="SELF &gt; 0.0"/>
      </type>
      <type name="positive_plane_angle_measure">
         <typename name="plane_angle_measure"/>
         <where label="WR1" expression="SELF &gt; 0.0"/>
      </type>
      <type name="positive_ratio_measure">
         <typename name="ratio_measure"/>
         <where label="WR1" expression="SELF &gt; 0.0"/>
      </type>
      <type name="preferred_surface_curve_representation">
         <enumeration items="curve_3d pcurve_s1 pcurve_s2"/>
      </type>
      <type name="product_definition_or_assembly_relationship">
         <select selectitems="assembly_component_usage product_definition"/>
      </type>
      <type name="product_or_formation_or_definition">
         <select selectitems="product product_definition_formation product_definition"/>
      </type>
      <type name="project_item">
         <select selectitems="executed_action product_concept"/>
      </type>
      <type name="ratio_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="represented_definition">
         <select selectitems="general_property property_definition property_definition_relationship shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="requirement_assigned_item">
         <select selectitems="component_functional_unit configuration_item descriptive_representation_item group group_relationship product product_definition product_definition_formation product_definition_relationship property_definition representation shape_aspect shape_representation statistical_dimensional_location statistical_dimensional_size statistical_geometric_tolerance"/>
      </type>
      <type name="requirement_source_item">
         <select selectitems="characterized_object group group_relationship product product_definition product_definition_formation product_definition_relationship shape_aspect"/>
      </type>
      <type name="role_select">
         <select selectitems="action_assignment action_request_assignment approval_assignment approval_date_time certification_assignment contract_assignment document_reference effectivity_assignment group_assignment name_assignment security_classification_assignment"/>
      </type>
      <type name="rule_superseded_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="second_in_minute">
         <builtintype type="REAL"/>
         <where label="WR1" expression="{ 0 &lt;= SELF &lt;= 60.0 }"/>
      </type>
      <type name="security_classification_item">
         <select selectitems="assembly_component_usage document document_file make_from_usage_option product product_definition product_definition_formation"/>
      </type>
      <type name="set_representation_item">
         <aggregate type="SET" lower="1" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="shape_definition">
         <select selectitems="product_definition_shape shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="si_prefix">
         <enumeration items="exa peta tera giga mega kilo hecto deca deci centi milli micro nano pico femto atto"/>
      </type>
      <type name="si_unit_name">
         <enumeration items="metre gram second ampere kelvin mole candela radian steradian hertz newton pascal joule watt coulomb volt farad ohm siemens weber tesla henry degree_Celsius lumen lux becquerel gray sievert"/>
      </type>
      <type name="solid_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="source">
         <enumeration items="made bought not_known"/>
      </type>
      <type name="source_item">
         <select selectitems="identifier"/>
      </type>
      <type name="string_representation_item_select">
         <select selectitems="descriptive_representation_item included_text_block structured_text_composition"/>
      </type>
      <type name="text">
         <builtintype type="STRING"/>
      </type>
      <type name="thermodynamic_temperature_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="time_interval_item">
         <select selectitems="action"/>
      </type>
      <type name="time_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="tolerance_method_definition">
         <select selectitems="tolerance_value limits_and_fits"/>
      </type>
      <type name="transformation">
         <select selectitems="item_defined_transformation functionally_defined_transformation"/>
      </type>
      <type name="transition_code">
         <enumeration items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature"/>
      </type>
      <type name="trimming_preference">
         <enumeration items="cartesian parameter unspecified"/>
      </type>
      <type name="trimming_select">
         <select selectitems="cartesian_point parameter_value"/>
      </type>
      <type name="unit">
         <select selectitems="derived_unit named_unit"/>
      </type>
      <type name="value_qualifier">
         <select selectitems="precision_qualifier type_qualifier uncertainty_qualifier"/>
      </type>
      <type name="vector_or_direction">
         <select selectitems="vector direction"/>
      </type>
      <type name="volume_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="year_number">
         <builtintype type="INTEGER"/>
      </type>
      <entity name="absorbed_dose_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\absorbed_dose_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = gray"/>
      </entity>
      <entity name="abstract_variable" supertypes="property_definition property_definition_representation representation representation_item"/>
      <entity name="across_port_variable" supertypes="port_variable"/>
      <entity name="action">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="chosen_method">
            <typename name="action_method"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="action_assignment" abstract.supertype="YES">
         <explicit name="assigned_action">
            <typename name="action"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="action_directive">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="analysis">
            <typename name="text"/>
         </explicit>
         <explicit name="comment">
            <typename name="text"/>
         </explicit>
         <explicit name="requests">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_method">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="consequence">
            <typename name="text"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="action_method_assignment" abstract.supertype="YES">
         <explicit name="assigned_action_method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="role">
            <typename name="action_method_role"/>
         </explicit>
      </entity>
      <entity name="action_method_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="related_method">
            <typename name="action_method"/>
         </explicit>
      </entity>
      <entity name="action_method_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="action_property">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_action_definition"/>
         </explicit>
      </entity>
      <entity name="action_property_representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="property">
            <typename name="action_property"/>
         </explicit>
         <explicit name="representation">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="action_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_action">
            <typename name="action"/>
         </explicit>
         <explicit name="related_action">
            <typename name="action"/>
         </explicit>
      </entity>
      <entity name="action_request_assignment" abstract.supertype="YES">
         <explicit name="assigned_action_request">
            <typename name="versioned_action_request"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="action_request_solution">
         <explicit name="method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="request">
            <typename name="versioned_action_request"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value (SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="action_request_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_action">
            <typename name="executed_action"/>
         </explicit>
      </entity>
      <entity name="activity_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\activity_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = becquerel"/>
      </entity>
      <entity name="address">
         <explicit name="internal_location" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_box" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="town" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="region" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_code" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="country" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="facsimile_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telephone_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="electronic_mail_address" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telex_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <derived name="url" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number)"/>
      </entity>
      <entity name="advanced_face" supertypes="face_surface">
         <where label="WR1" expression="SIZEOF ([ 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ELEMENTARY_SURFACE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.B_SPLINE_SURFACE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1"/>
         <where label="WR2" expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0"/>
         <where label="WR3" expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LINE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CONIC', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POLYLINE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_CURVE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0"/>
         <where label="WR4" expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| NOT ((('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0"/>
         <where label="WR5" expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0"/>
         <where label="WR6" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LINE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CONIC', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POLYLINE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1)"/>
         <where label="WR7" expression="SIZEOF ( &#10;QUERY ( vlp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0"/>
         <where label="WR8" expression="SIZEOF ( &#10;QUERY ( bnd &lt;* bounds| NOT ( SIZEOF ([ 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_LOOP', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0"/>
         <where label="WR9" expression="SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( &#10;QUERY ( sc_ag &lt;* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0"/>
         <where label="WR10" expression="(NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) &gt;= 3))) AND ( SIZEOF ( &#10;QUERY ( elp_fbnds &lt;* &#10;QUERY ( bnds &lt;* bounds| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( &#10;QUERY ( oe &lt;* elp_fbnds.bound\path.edge_list| ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) &gt;= 3) )) = 0) )) = 0)"/>
      </entity>
      <entity name="alternate_product_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="alternate">
            <typename name="product"/>
         </explicit>
         <explicit name="base">
            <typename name="product"/>
         </explicit>
         <explicit name="basis">
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="alternate"/>
            <unique.attribute attribute="base"/>
         </unique>
         <where label="WR1" expression="alternate :&lt;&gt;: base"/>
      </entity>
      <entity name="amount_of_substance_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="amount_of_substance_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="analog_analytical_model_port" supertypes="analytical_model_port"/>
      <entity name="analog_port_variable" supertypes="representation representation_item"/>
      <entity name="analytical_model" supertypes="representation">
         <unique label="UR1">
            <unique.attribute entity-ref="representation" attribute="name"/>
         </unique>
      </entity>
      <entity name="analytical_model_definition" supertypes="product_definition"/>
      <entity name="analytical_model_make_from_relationship" supertypes="product_definition_relationship">
         <explicit name="relating_product_definition">
            <typename name="analytical_model_definition"/>
            <redeclaration entity-ref="product_definition_relationship"/>
         </explicit>
         <explicit name="related_product_definition">
            <typename name="analytical_model_definition"/>
            <redeclaration entity-ref="product_definition_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="relating_product_definition"/>
            <unique.attribute attribute="related_product_definition"/>
         </unique>
      </entity>
      <entity name="analytical_model_parameter" supertypes="model_parameter"/>
      <entity name="analytical_model_port" supertypes="representation" super.expression="analytical_model_vector_port ANDOR ONEOF (analog_analytical_model_port, digital_analytical_model_port)"/>
      <entity name="analytical_model_port_assignment" supertypes="property_definition_representation representation_relationship"/>
      <entity name="analytical_model_scalar_port" supertypes="analytical_model_vector_port"/>
      <entity name="analytical_model_vector_port" supertypes="analytical_model_port compound_representation_item"/>
      <entity name="analytical_representation" supertypes="representation">
         <unique label="UR1">
            <unique.attribute entity-ref="representation" attribute="name"/>
         </unique>
      </entity>
      <entity name="angular_location" supertypes="dimensional_location">
         <explicit name="angle_selection">
            <typename name="angle_relator"/>
         </explicit>
      </entity>
      <entity name="angular_size" supertypes="dimensional_size">
         <explicit name="angle_selection">
            <typename name="angle_relator"/>
         </explicit>
      </entity>
      <entity name="angularity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt; 3"/>
      </entity>
      <entity name="apex" supertypes="derived_shape_aspect"/>
      <entity name="application_context">
         <explicit name="application">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <inverse name="context_elements" entity="application_context_element" attribute="frame_of_reference">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="application_context_element" super.expression="ONEOF (product_concept_context, product_context, product_definition_context)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="application_context_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_context">
            <typename name="application_context"/>
         </explicit>
         <explicit name="related_context">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="application_protocol_definition">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="application_interpreted_model_schema_name">
            <typename name="label"/>
         </explicit>
         <explicit name="application_protocol_year">
            <typename name="year_number"/>
         </explicit>
         <explicit name="application">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="applied_action_assignment" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_items"/>
         </explicit>
      </entity>
      <entity name="applied_action_method_assignment" supertypes="action_method_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_method_items"/>
         </explicit>
      </entity>
      <entity name="applied_action_request_assignment" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_request_item"/>
         </explicit>
      </entity>
      <entity name="applied_approval_assignment" supertypes="approval_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="approval_item"/>
         </explicit>
      </entity>
      <entity name="applied_attribute_classification_assignment" supertypes="attribute_classification_assignment">
         <explicit name="assigned_class">
            <typename name="class"/>
            <redeclaration entity-ref="attribute_classification_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="attribute_classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_certification_assignment" supertypes="certification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="certification_item"/>
         </explicit>
      </entity>
      <entity name="applied_classification_assignment" supertypes="classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_contract_assignment" supertypes="contract_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="contract_item"/>
         </explicit>
      </entity>
      <entity name="applied_date_and_time_assignment" supertypes="date_and_time_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="date_and_time_item"/>
         </explicit>
      </entity>
      <entity name="applied_date_assignment" supertypes="date_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="date_item"/>
         </explicit>
      </entity>
      <entity name="applied_document_reference" supertypes="document_reference">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document_reference_item"/>
         </explicit>
      </entity>
      <entity name="applied_document_usage_constraint_assignment" supertypes="document_usage_constraint_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document_reference_item"/>
         </explicit>
      </entity>
      <entity name="applied_effectivity_assignment" supertypes="effectivity_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="effectivity_item"/>
         </explicit>
      </entity>
      <entity name="applied_event_occurrence_assignment" supertypes="event_occurrence_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="event_occurrence_item"/>
         </explicit>
      </entity>
      <entity name="applied_external_identification_assignment" supertypes="external_identification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="external_identification_item"/>
         </explicit>
      </entity>
      <entity name="applied_group_assignment" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="groupable_item"/>
         </explicit>
      </entity>
      <entity name="applied_identification_assignment" supertypes="identification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="identification_item"/>
         </explicit>
      </entity>
      <entity name="applied_name_assignment" supertypes="name_assignment">
         <explicit name="item">
            <typename name="name_item"/>
         </explicit>
      </entity>
      <entity name="applied_organization_assignment" supertypes="organization_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization_item"/>
         </explicit>
      </entity>
      <entity name="applied_organizational_project_assignment" supertypes="organizational_project_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="project_item"/>
         </explicit>
      </entity>
      <entity name="applied_person_and_organization_assignment" supertypes="person_and_organization_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person_and_organization_item"/>
         </explicit>
      </entity>
      <entity name="applied_security_classification_assignment" supertypes="security_classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="security_classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_time_interval_assignment" supertypes="time_interval_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="time_interval_item"/>
         </explicit>
      </entity>
      <entity name="approval">
         <explicit name="status">
            <typename name="approval_status"/>
         </explicit>
         <explicit name="level">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="approval_assignment" abstract.supertype="YES">
         <explicit name="assigned_approval">
            <typename name="approval"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="approval_date_time">
         <explicit name="date_time">
            <typename name="date_time_select"/>
         </explicit>
         <explicit name="dated_approval">
            <typename name="approval"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="approval_person_organization">
         <explicit name="person_organization">
            <typename name="person_organization_select"/>
         </explicit>
         <explicit name="authorized_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="role">
            <typename name="approval_role"/>
         </explicit>
      </entity>
      <entity name="approval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="related_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_role">
         <explicit name="role">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="approval_status">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="area_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="area_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="assembly_component_usage" supertypes="product_definition_usage" super.expression="ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence)">
         <explicit name="reference_designator" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="assembly_component_usage_substitute">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="base">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="substitute">
            <typename name="assembly_component_usage"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="base"/>
            <unique.attribute attribute="substitute"/>
         </unique>
         <where label="WR1" expression="base.relating_product_definition :=:&#10;       substitute.relating_product_definition"/>
         <where label="WR2" expression="base :&lt;&gt;: substitute"/>
      </entity>
      <entity name="assigned_requirement" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="atomic_formula" supertypes="compound_representation_item"/>
      <entity name="attribute_assertion" supertypes="fact_type property_definition_representation representation"/>
      <entity name="attribute_classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_class">
            <typename name="group"/>
         </explicit>
         <explicit name="attribute_name">
            <typename name="label"/>
         </explicit>
         <explicit name="role">
            <typename name="classification_role"/>
         </explicit>
      </entity>
      <entity name="attribute_language_assignment" supertypes="attribute_classification_assignment">
         <explicit name="assigned_class">
            <typename name="language"/>
            <redeclaration entity-ref="attribute_classification_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="attribute_language_item"/>
         </explicit>
         <where label="WR1" expression="SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']"/>
         <where label="WR2" expression="SELF\attribute_classification_assignment.attribute_name&lt;&gt; ''"/>
      </entity>
      <entity name="attribute_value_assignment" abstract.supertype="YES">
         <explicit name="attribute_name">
            <typename name="label"/>
         </explicit>
         <explicit name="attribute_value">
            <typename name="attribute_type"/>
         </explicit>
         <explicit name="role">
            <typename name="attribute_value_role"/>
         </explicit>
      </entity>
      <entity name="attribute_value_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="auxiliary_characteristic_dimension_representation" supertypes="dimensional_characteristic_representation"/>
      <entity name="axis1_placement" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="z" expression="NVL(normalise(axis), dummy_gri ||&#10;                                 direction([0.0,0.0,1.0]))">
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim  = 3"/>
      </entity>
      <entity name="axis2_placement_2d" supertypes="placement">
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_2axes(ref_direction)">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="axis2_placement_3d" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_axes(axis,ref_direction)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\placement.location.dim = 3"/>
         <where label="WR2" expression="(NOT (EXISTS (axis))) OR (axis.dim = 3)"/>
         <where label="WR3" expression="(NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3)"/>
         <where label="WR4" expression="(NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR&#10;          (cross_product(axis,ref_direction).magnitude &gt; 0.0)"/>
      </entity>
      <entity name="b_spline_curve" supertypes="bounded_curve" super.expression="ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve">
         <explicit name="degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="curve_form">
            <typename name="b_spline_curve_form"/>
         </explicit>
         <explicit name="closed_curve">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="upper_index_on_control_points" expression="(SIZEOF(control_points_list) - 1)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="control_points" expression="list_to_array(control_points_list,0,&#10;                                             upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where label="WR1" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR&#10;        ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.BEZIER_CURVE' IN TYPEOF(self)) OR&#10;        ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))"/>
      </entity>
      <entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
         <explicit name="knot_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="upper_index_on_knots" expression="SIZEOF(knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="constraints_param_b_spline(degree, upper_index_on_knots,&#10;                               upper_index_on_control_points,&#10;                               knot_multiplicities, knots)"/>
         <where label="WR2" expression="SIZEOF(knot_multiplicities) = upper_index_on_knots"/>
      </entity>
      <entity name="b_spline_surface" supertypes="bounded_surface" super.expression="ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface">
         <explicit name="u_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="surface_form">
            <typename name="b_spline_surface_form"/>
         </explicit>
         <explicit name="u_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="v_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="u_upper" expression="SIZEOF(control_points_list) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="v_upper" expression="SIZEOF(control_points_list[1]) - 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="control_points" expression="make_array_of_array(control_points_list,&#10;                                              0,u_upper,0,v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <where label="WR1" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.BEZIER_SURFACE' IN TYPEOF(SELF)) OR&#10;        ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
         <explicit name="u_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="u_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="knot_u_upper" expression="SIZEOF(u_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="knot_v_upper" expression="SIZEOF(v_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,&#10;                   knot_u_upper, SELF\b_spline_surface.u_upper,&#10;                               u_multiplicities, u_knots)"/>
         <where label="WR2" expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,&#10;                   knot_v_upper, SELF\b_spline_surface.v_upper,&#10;                               v_multiplicities, v_knots)"/>
         <where label="WR3" expression="SIZEOF(u_multiplicities) = knot_u_upper"/>
         <where label="WR4" expression="SIZEOF(v_multiplicities) = knot_v_upper"/>
      </entity>
      <entity name="back_chaining_rule" supertypes="rule_definition"/>
      <entity name="back_chaining_rule_body" supertypes="property_definition property_definition_representation representation"/>
      <entity name="bezier_curve" supertypes="b_spline_curve"/>
      <entity name="bezier_surface" supertypes="b_spline_surface"/>
      <entity name="binary_generic_expression" abstract.supertype="YES" supertypes="generic_expression">
         <explicit name="operands">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity name="boundary_curve" supertypes="composite_curve_on_surface">
         <where label="WR1" expression="SELF\composite_curve.closed_curve"/>
      </entity>
      <entity name="bounded_curve" supertypes="curve" super.expression="ONEOF (polyline, b_spline_curve, trimmed_curve, composite_curve)"/>
      <entity name="bounded_surface" supertypes="surface" super.expression="ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface)"/>
      <entity name="bus_element_link" supertypes="product_definition product_definition_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_relationship" attribute="related_product_definition"/>
            <unique.attribute entity-ref="product_definition_relationship" attribute="relating_product_definition"/>
         </unique>
         <where label="WR1" expression="SELF\product_definition_relationship.related_product_definition :&lt;&gt;:&#10;       SELF\product_definition_relationship.relating_product_definition"/>
      </entity>
      <entity name="bus_structural_definition" supertypes="product_definition"/>
      <entity name="calendar_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_month_number"/>
         </explicit>
         <explicit name="month_component">
            <typename name="month_in_year_number"/>
         </explicit>
         <where label="WR1" expression="valid_calendar_date (SELF)"/>
      </entity>
      <entity name="capacitance_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\capacitance_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = farad"/>
      </entity>
      <entity name="cartesian_point" supertypes="point">
         <explicit name="coordinates">
            <aggregate type="LIST" lower="1" upper="3"/>
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="cartesian_transformation_operator" supertypes="geometric_representation_item functionally_defined_transformation" super.expression="ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d)">
         <explicit name="axis1" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="axis2" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="local_origin">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="scale" optional="YES">
            <builtintype type="REAL"/>
         </explicit>
         <derived name="scl" expression="NVL(scale, 1.0)">
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="scl &gt; 0.0"/>
      </entity>
      <entity name="cartesian_transformation_operator_2d" supertypes="cartesian_transformation_operator">
         <derived name="u" expression="base_axis(2,SELF\cartesian_transformation_operator.axis1,&#10;                   SELF\cartesian_transformation_operator.axis2,?)">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
         <explicit name="axis3" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="u" expression="base_axis(3,SELF\cartesian_transformation_operator.axis1,&#10;                        SELF\cartesian_transformation_operator.axis2,axis3)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 3"/>
      </entity>
      <entity name="category_model_parameter" supertypes="model_parameter"/>
      <entity name="celsius_temperature_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="centre_of_symmetry" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF&#10;        (QUERY(sadr&lt;*SELF\derived_shape_aspect.deriving_relationships|&#10;    NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SYMMETRIC_SHAPE_ASPECT'&#10;     IN TYPEOF&#10;     (sadr\shape_aspect_relationship.related_shape_aspect))))=0"/>
      </entity>
      <entity name="certification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="certification_type"/>
         </explicit>
      </entity>
      <entity name="certification_assignment" abstract.supertype="YES">
         <explicit name="assigned_certification">
            <typename name="certification"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="certification_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="characteristic_type" supertypes="group"/>
      <entity name="characterized_class" supertypes="characterized_object class"/>
      <entity name="characterized_object">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="circle" supertypes="conic">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="circular_runout_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 2"/>
      </entity>
      <entity name="class" supertypes="group"/>
      <entity name="class_by_extension" supertypes="class"/>
      <entity name="class_by_intension" supertypes="class"/>
      <entity name="class_system" supertypes="group"/>
      <entity name="classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_class">
            <typename name="group"/>
         </explicit>
         <explicit name="role">
            <typename name="classification_role"/>
         </explicit>
      </entity>
      <entity name="classification_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="coaxiality_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 2"/>
      </entity>
      <entity name="common_datum" supertypes="composite_shape_aspect datum">
         <where label="WR1" expression="SIZEOF (SELF.component_relationships) = 2"/>
         <where label="WR2" expression="SIZEOF ( &#10;QUERY ( sar &lt;* SELF.component_relationships| NOT (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DATUM' IN TYPEOF (sar.related_shape_aspect)) AND NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.COMMON_DATUM' IN TYPEOF (sar.related_shape_aspect))) )) = 0"/>
      </entity>
      <entity name="complex_clause" supertypes="compound_representation_item"/>
      <entity name="complex_conjunctive_clause" supertypes="complex_clause"/>
      <entity name="complex_disjunctive_clause" supertypes="complex_clause"/>
      <entity name="component_functional_terminal" supertypes="shape_aspect"/>
      <entity name="component_functional_unit" supertypes="product_definition"/>
      <entity name="composite_curve" supertypes="bounded_curve">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="composite_curve_segment"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="n_segments" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="closed_curve" expression="segments[n_segments].transition &lt;&gt; discontinuous">
            <builtintype type="LOGICAL"/>
         </derived>
         <where label="WR1" expression="((NOT closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments |&#10;                temp.transition = discontinuous)) = 1)) OR&#10;            ((closed_curve) AND (SIZEOF(QUERY(temp &lt;* segments | &#10;                temp.transition = discontinuous)) = 0))"/>
      </entity>
      <entity name="composite_curve_on_surface" supertypes="composite_curve" super.expression="boundary_curve">
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="0" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="WR1" expression="SIZEOF(basis_surface) &gt; 0"/>
         <where label="WR2" expression="constraints_composite_curve_on_surface(SELF)"/>
      </entity>
      <entity name="composite_curve_segment" supertypes="founded_item">
         <explicit name="transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <inverse name="using_curves" entity="composite_curve" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve))"/>
      </entity>
      <entity name="composite_group_shape_aspect" supertypes="composite_shape_aspect"/>
      <entity name="composite_shape_aspect" supertypes="shape_aspect">
         <inverse name="component_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
            <inverse.aggregate type="SET" lower="2" upper="?"/>
         </inverse>
      </entity>
      <entity name="composite_signal_property_relationship" supertypes="property_definition property_definition_relationship">
         <where label="WR1" expression="SELF\property_definition_relationship.related_property_definition.definition :&lt;&gt;:&#10;       SELF\property_definition_relationship.relating_property_definition.definition"/>
      </entity>
      <entity name="composite_unit_shape_aspect" supertypes="composite_shape_aspect"/>
      <entity name="compound_representation_item" supertypes="representation_item">
         <explicit name="item_element">
            <typename name="compound_item_definition"/>
         </explicit>
      </entity>
      <entity name="concentricity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) = 1"/>
      </entity>
      <entity name="concept_feature_operator">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="concept_feature_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_concept_feature">
            <typename name="product_concept_feature"/>
         </explicit>
         <explicit name="related_product_concept_feature">
            <typename name="product_concept_feature"/>
         </explicit>
      </entity>
      <entity name="concept_feature_relationship_with_condition" supertypes="concept_feature_relationship">
         <explicit name="conditional_operator">
            <typename name="concept_feature_operator"/>
         </explicit>
      </entity>
      <entity name="conditional_concept_feature" supertypes="product_concept_feature">
         <explicit name="condition">
            <typename name="concept_feature_relationship_with_condition"/>
         </explicit>
      </entity>
      <entity name="conductance_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\conductance_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = siemens"/>
      </entity>
      <entity name="configurable_item" supertypes="configuration_item">
         <explicit name="item_concept_feature">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_concept_feature_association"/>
         </explicit>
      </entity>
      <entity name="configuration_design">
         <explicit name="configuration">
            <typename name="configuration_item"/>
         </explicit>
         <explicit name="design">
            <typename name="configuration_design_item"/>
         </explicit>
         <derived name="name" expression="get_name_value (SELF)">
            <typename name="label"/>
         </derived>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <unique label="UR1">
            <unique.attribute attribute="configuration"/>
            <unique.attribute attribute="design"/>
         </unique>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;                             'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="configuration_effectivity" supertypes="product_definition_effectivity">
         <explicit name="configuration">
            <typename name="configuration_design"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="configuration"/>
            <unique.attribute entity-ref="product_definition_effectivity" attribute="usage"/>
            <unique.attribute entity-ref="effectivity" attribute="id"/>
         </unique>
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION_USAGE' IN&#10;        TYPEOF (SELF\product_definition_effectivity.usage)"/>
      </entity>
      <entity name="configuration_item">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="item_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="purpose" optional="YES">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="conic" supertypes="curve" super.expression="ONEOF (circle, ellipse, hyperbola, parabola)">
         <explicit name="position">
            <typename name="axis2_placement"/>
         </explicit>
      </entity>
      <entity name="conical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="semi_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where label="WR1" expression="radius &gt;= 0.0"/>
      </entity>
      <entity name="connection_zone_interface_plane_relationship" supertypes="shape_aspect shape_aspect_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect" attribute="name"/>
         </unique>
      </entity>
      <entity name="connection_zone_map_identification" supertypes="shape_aspect representation_relationship">
         <explicit name="rep_1">
            <typename name="usage_view_connection_zone_terminal_shape_relationship"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="usage_view_connection_zone_terminal_shape_relationship"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <where label="WR1" expression="SELF\representation_relationship.rep_2 :&lt;&gt;:&#10;       SELF\representation_relationship.rep_1"/>
      </entity>
      <entity name="constructive_geometry_representation" supertypes="representation">
         <where label="WR1" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 &lt;= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension &lt;= 3})"/>
         <where label="WR2" expression="SIZEOF( QUERY( cgr_i &lt;* SELF.items | SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PLACEMENT', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CURVE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.EDGE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.FACE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POINT', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.FACE_SURFACE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VERTEX_POINT'] * TYPEOF(cgr_i)) &lt;&gt; 1 )) = 0"/>
         <where label="WR3" expression="SIZEOF( USEDIN( SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) &gt; 0"/>
         <where label="WR4" expression="SIZEOF( USEDIN( SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0"/>
      </entity>
      <entity name="constructive_geometry_representation_relationship" supertypes="representation_relationship">
         <where label="WR1" expression="(SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items))"/>
         <where label="WR2" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CONSTRUCTIVE_GEOMETRY_REPRESENTATION' IN TYPEOF(SELF.rep_2)"/>
         <where label="WR3" expression="SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_REPRESENTATION', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CONSTRUCTIVE_GEOMETRY_REPRESENTATION'] * TYPEOF(SELF.rep_1)) = 1"/>
         <where label="WR4" expression="NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="context_dependent_shape_representation">
         <explicit name="representation_relation">
            <typename name="shape_representation_relationship"/>
         </explicit>
         <explicit name="represented_product_relation">
            <typename name="product_definition_shape"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value (SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition)"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
         <where label="WR3" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="context_dependent_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="contract">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="contract_type"/>
         </explicit>
      </entity>
      <entity name="contract_assignment" abstract.supertype="YES">
         <explicit name="assigned_contract">
            <typename name="contract"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="contract_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="conversion_based_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="conversion_factor">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="coordinated_universal_time_offset">
         <explicit name="hour_offset">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="minute_offset" optional="YES">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="sense">
            <typename name="ahead_or_behind"/>
         </explicit>
         <derived name="actual_minute_offset" expression="NVL(minute_offset,0)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="{ 0 &lt;= hour_offset &lt; 24 }"/>
         <where label="WR2" expression="{ 0 &lt;= actual_minute_offset &lt;= 59 }"/>
         <where label="WR3" expression="NOT (((hour_offset &lt;&gt; 0) OR (actual_minute_offset &lt;&gt;0)) AND (sense = exact))"/>
      </entity>
      <entity name="curve" supertypes="geometric_representation_item" super.expression="ONEOF (line, conic, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica)"/>
      <entity name="curve_bounded_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="boundary_curve"/>
         </explicit>
         <explicit name="implicit_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="(NOT implicit_outer) OR&#10;         (SIZEOF (QUERY (temp &lt;* boundaries |&#10;           'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0)"/>
         <where label="WR2" expression="(NOT(implicit_outer)) OR&#10;                ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface))"/>
         <where label="WR3" expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;                  'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.OUTER_BOUNDARY_CURVE' IN&#10;                                         TYPEOF(temp))) &lt;= 1"/>
         <where label="WR4" expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;            (temp\composite_curve_on_surface.basis_surface [1] &lt;&gt;&#10;                                         SELF.basis_surface))) = 0"/>
      </entity>
      <entity name="curve_replica" supertypes="curve">
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="WR1" expression="transformation.dim = parent_curve.dim"/>
         <where label="WR2" expression="acyclic_curve_replica (SELF, parent_curve)"/>
      </entity>
      <entity name="cylindrical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="cylindricity_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))"/>
      </entity>
      <entity name="data_environment">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="elements">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="property_definition_representation"/>
         </explicit>
      </entity>
      <entity name="date">
         <explicit name="year_component">
            <typename name="year_number"/>
         </explicit>
      </entity>
      <entity name="date_and_time">
         <explicit name="date_component">
            <typename name="date"/>
         </explicit>
         <explicit name="time_component">
            <typename name="local_time"/>
         </explicit>
      </entity>
      <entity name="date_and_time_assignment" abstract.supertype="YES">
         <explicit name="assigned_date_and_time">
            <typename name="date_and_time"/>
         </explicit>
         <explicit name="role">
            <typename name="date_time_role"/>
         </explicit>
      </entity>
      <entity name="date_assignment" abstract.supertype="YES">
         <explicit name="assigned_date">
            <typename name="date"/>
         </explicit>
         <explicit name="role">
            <typename name="date_role"/>
         </explicit>
      </entity>
      <entity name="date_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="date_time_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="dated_effectivity" supertypes="effectivity">
         <explicit name="effectivity_end_date" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="effectivity_start_date">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
      </entity>
      <entity name="datum" supertypes="shape_aspect">
         <explicit name="identification">
            <typename name="identifier"/>
         </explicit>
         <inverse name="established_by_relationships" entity="shape_aspect_relationship" attribute="related_shape_aspect">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF (QUERY (x&lt;*SELF\datum.established_by_relationships |&#10;       SIZEOF (TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)* &#10;       ['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DATUM_FEATURE', &#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DATUM_TARGET']) &lt;&gt; 1))=0"/>
      </entity>
      <entity name="datum_difference" supertypes="shape_aspect shape_aspect_relationship">
         <where label="WR1" expression="SELF\shape_aspect_relationship.relating_shape_aspect :&lt;&gt;:&#10;       SELF\shape_aspect_relationship.related_shape_aspect"/>
      </entity>
      <entity name="datum_difference_based_characteristic" supertypes="representation_item"/>
      <entity name="datum_difference_based_model_parameter" supertypes="model_parameter"/>
      <entity name="datum_difference_functional_unit_usage_view_terminal_assignment" supertypes="shape_aspect_relationship">
         <explicit name="relating_shape_aspect">
            <typename name="datum_difference"/>
            <redeclaration entity-ref="shape_aspect_relationship"/>
         </explicit>
         <explicit name="related_shape_aspect">
            <typename name="functional_unit_terminal_definition"/>
            <redeclaration entity-ref="shape_aspect_relationship"/>
         </explicit>
      </entity>
      <entity name="datum_feature" supertypes="shape_aspect">
         <inverse name="feature_basis_relationship" entity="shape_aspect_relationship" attribute="relating_shape_aspect"/>
         <where label="WR1" expression="SIZEOF (QUERY (sar&lt;* bag_to_set (USEDIN (SELF,&#10;     'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.'+&#10;       'RELATING_SHAPE_ASPECT'))&#10;       | NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DATUM' IN TYPEOF&#10;       (sar\shape_aspect_relationship.related_shape_aspect))))=0"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = TRUE"/>
      </entity>
      <entity name="datum_reference">
         <explicit name="precedence">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="referenced_datum">
            <typename name="datum"/>
         </explicit>
         <where label="WR1" expression="precedence &gt; 0"/>
      </entity>
      <entity name="datum_target" supertypes="shape_aspect">
         <explicit name="target_id">
            <typename name="identifier"/>
         </explicit>
         <inverse name="target_basis_relationship" entity="shape_aspect_relationship" attribute="relating_shape_aspect"/>
         <where label="WR1" expression="SIZEOF (QUERY (sar&lt;* bag_to_set (USEDIN (SELF,&#10;     'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.' +&#10;       'RELATING_SHAPE_ASPECT'))&#10;      | NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DATUM' IN TYPEOF &#10;      (sar\shape_aspect_relationship.related_shape_aspect))))=0"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = TRUE"/>
      </entity>
      <entity name="default_tolerance_table" supertypes="representation">
         <where label="WR1" expression="SIZEOF( QUERY( i &lt;* SELF.items | NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DEFAULT_TOLERANCE_TABLE_CELL' IN TYPEOF(i)) )) = 0"/>
         <where label="WR2" expression="(SIZEOF( QUERY( rr &lt;* USEDIN(SELF,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | rr.name &lt; 'general tolerance definition' )) = 0) AND (SIZEOF( QUERY( rr &lt;* USEDIN(SELF,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name = 'general tolerance definition') AND (rr.rep_2.name &lt; 'default tolerance') )) = 0) AND (SIZEOF( USEDIN(SELF,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) = 0)"/>
      </entity>
      <entity name="default_tolerance_table_cell" supertypes="compound_representation_item">
         <where label="WR1" expression="SIZEOF(QUERY( x &lt;* USEDIN(SELF,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION.ITEMS') | 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DEFAULT_TOLERANCE_TABLE' IN TYPEOF(x)))=1"/>
         <where label="WR2" expression="default_tolerance_table_cell_wr2(SELF\compound_representation_item.item_element)"/>
         <where label="WR3" expression="default_tolerance_table_cell_wr3(SELF\compound_representation_item.item_element)"/>
         <where label="WR4" expression="default_tolerance_table_cell_wr4(SELF\compound_representation_item.item_element)"/>
         <where label="WR5" expression="default_tolerance_table_cell_wr5(SELF\compound_representation_item.item_element)"/>
      </entity>
      <entity name="definitional_representation" supertypes="representation">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN&#10;        TYPEOF (SELF\representation.context_of_items )"/>
      </entity>
      <entity name="definitional_representation_relationship" supertypes="representation_relationship">
         <where label="WR1" expression="acyclic_representation_relationship(SELF,&#10;       [SELF\representation_relationship.rep_2],&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+&#10;       'REPRESENTATION')"/>
      </entity>
      <entity name="degenerate_pcurve" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(reference_to_curve\representation.items) = 1"/>
         <where label="WR2" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])"/>
         <where label="WR3" expression="reference_to_curve\representation.&#10;                   items[1]\geometric_representation_item.dim =2"/>
      </entity>
      <entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
         <explicit name="select_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="major_radius &lt;   minor_radius"/>
      </entity>
      <entity name="derived_shape_aspect" supertypes="shape_aspect" super.expression="ONEOF (apex, centre_of_symmetry, geometric_alignment, geometric_intersection, parallel_offset, perpendicular_to, extension, tangent)">
         <inverse name="deriving_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF (QUERY (dr &lt;*&#10;          SELF\derived_shape_aspect.deriving_relationships |&#10;          NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;               'SHAPE_ASPECT_DERIVING_RELATIONSHIP'&#10;          IN TYPEOF (dr)))) = 0"/>
      </entity>
      <entity name="derived_unit">
         <explicit name="elements">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="derived_unit_element"/>
         </explicit>
         <derived name="name" expression="get_name_value (SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="(SIZEOF (elements) &gt; 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent &lt;&gt; 1.0))"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="derived_unit_element">
         <explicit name="unit">
            <typename name="named_unit"/>
         </explicit>
         <explicit name="exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="description_attribute">
         <explicit name="attribute_value">
            <typename name="text"/>
         </explicit>
         <explicit name="described_item">
            <typename name="description_attribute_select"/>
         </explicit>
      </entity>
      <entity name="descriptive_representation_item" supertypes="representation_item">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="digital_analytical_model_port" supertypes="analytical_model_port"/>
      <entity name="digital_analytical_model_scalar_port" supertypes="digital_analytical_model_vector_port analytical_model_scalar_port"/>
      <entity name="digital_analytical_model_vector_port" supertypes="analytical_model_vector_port"/>
      <entity name="dimension_related_tolerance_zone_element">
         <explicit name="related_dimension">
            <typename name="dimensional_location"/>
         </explicit>
         <explicit name="related_element">
            <typename name="tolerance_zone_definition"/>
         </explicit>
      </entity>
      <entity name="dimensional_characteristic_representation">
         <explicit name="dimension">
            <typename name="dimensional_characteristic"/>
         </explicit>
         <explicit name="representation">
            <typename name="shape_dimension_representation"/>
         </explicit>
      </entity>
      <entity name="dimensional_exponents">
         <explicit name="length_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="mass_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="time_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="electric_current_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="thermodynamic_temperature_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="amount_of_substance_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="luminous_intensity_exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="dimensional_location" supertypes="shape_aspect_relationship" super.expression="ONEOF (angular_location, dimensional_location_with_path)"/>
      <entity name="dimensional_location_with_path" supertypes="dimensional_location">
         <explicit name="path">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="dimensional_size" super.expression="ONEOF (angular_size, dimensional_size_with_path)">
         <explicit name="applies_to">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="applies_to.product_definitional = TRUE"/>
      </entity>
      <entity name="dimensional_size_property" supertypes="dimensional_size property_definition"/>
      <entity name="dimensional_size_with_path" supertypes="dimensional_size">
         <explicit name="path">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="directed_action" supertypes="executed_action">
         <explicit name="directive">
            <typename name="action_directive"/>
         </explicit>
      </entity>
      <entity name="directed_dimensional_location" supertypes="dimensional_location"/>
      <entity name="direction" supertypes="geometric_representation_item">
         <explicit name="direction_ratios">
            <aggregate type="LIST" lower="2" upper="3"/>
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0)) &gt; 0"/>
      </entity>
      <entity name="document">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="document_type"/>
         </explicit>
         <inverse name="representation_types" entity="document_representation_type" attribute="represented_document">
            <inverse.aggregate type="SET" lower="0" upper="?"/>
         </inverse>
      </entity>
      <entity name="document_file" supertypes="document characterized_object">
         <where label="WR1" expression="SELF\characterized_object.name = ''"/>
         <where label="WR2" expression="NOT EXISTS(SELF\characterized_object.description)"/>
         <where label="WR3" expression="SIZEOF( QUERY( drt &lt;* SELF\document.representation_types |&#10;               drt.name IN ['digital','physical'])) = 1"/>
      </entity>
      <entity name="document_identifier" supertypes="group">
         <unique label="UR1">
            <unique.attribute entity-ref="group" attribute="name"/>
            <unique.attribute entity-ref="group" attribute="description"/>
         </unique>
      </entity>
      <entity name="document_identifier_assignment" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="document_identifier"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document_identifier_assigned_item"/>
         </explicit>
      </entity>
      <entity name="document_product_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_product">
            <typename name="product_or_formation_or_definition"/>
         </explicit>
      </entity>
      <entity name="document_product_equivalence" supertypes="document_product_association">
         <where label="WR1" expression="SELF\document_product_association.name = 'equivalence'"/>
         <where label="WR2" expression="NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc &lt;* USEDIN(SELF\document_product_association.related_product,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1))"/>
         <where label="WR3" expression="NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc &lt;* USEDIN(SELF.related_product\product_definition_formation.of_product, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1))"/>
         <where label="WR4" expression="NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc &lt;* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1))"/>
      </entity>
      <entity name="document_reference" abstract.supertype="YES">
         <explicit name="assigned_document">
            <typename name="document"/>
         </explicit>
         <explicit name="source">
            <typename name="label"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="document_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_representation_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="represented_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_type">
         <explicit name="product_data_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="document_usage_constraint">
         <explicit name="source">
            <typename name="document"/>
         </explicit>
         <explicit name="subject_element">
            <typename name="label"/>
         </explicit>
         <explicit name="subject_element_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="document_usage_constraint_assignment" abstract.supertype="YES">
         <explicit name="assigned_document_usage">
            <typename name="document_usage_constraint"/>
         </explicit>
         <explicit name="role">
            <typename name="document_usage_role"/>
         </explicit>
      </entity>
      <entity name="document_usage_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="dose_equivalent_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\dose_equivalent_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = sievert"/>
      </entity>
      <entity name="edge" supertypes="topological_representation_item" super.expression="ONEOF (edge_curve, oriented_edge)">
         <explicit name="edge_start">
            <typename name="vertex"/>
         </explicit>
         <explicit name="edge_end">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="edge_curve" supertypes="edge geometric_representation_item">
         <explicit name="edge_geometry">
            <typename name="curve"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="edge_loop" supertypes="loop path">
         <derived name="ne" expression="SIZEOF(SELF\path.edge_list)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="(SELF\path.edge_list[1].edge_start) :=:&#10;        (SELF\path.edge_list[ne].edge_end)"/>
      </entity>
      <entity name="edge_segment_vertex" supertypes="physical_unit_datum"/>
      <entity name="effectivity" super.expression="ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity)">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="effectivity_assignment" abstract.supertype="YES">
         <explicit name="assigned_effectivity">
            <typename name="effectivity"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="effectivity_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="related_effectivity">
            <typename name="effectivity"/>
         </explicit>
         <explicit name="relating_effectivity">
            <typename name="effectivity"/>
         </explicit>
      </entity>
      <entity name="electric_charge_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\electric_charge_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = coulomb"/>
      </entity>
      <entity name="electric_current_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="electric_current_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="electromotive_force_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\electromotive_force_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = volt"/>
      </entity>
      <entity name="elementary_surface" supertypes="surface" super.expression="ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface)">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="ellipse" supertypes="conic">
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="energy_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\energy_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = joule"/>
      </entity>
      <entity name="entity_assertion" supertypes="fact_type"/>
      <entity name="enum_reference_prefix" supertypes="descriptive_representation_item"/>
      <entity name="environment">
         <explicit name="syntactic_representation">
            <typename name="generic_variable"/>
         </explicit>
         <explicit name="semantics">
            <typename name="variable_semantics"/>
         </explicit>
      </entity>
      <entity name="event_occurrence">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_assignment" abstract.supertype="YES">
         <explicit name="assigned_event_occurrence">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="role">
            <typename name="event_occurrence_role"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_event">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="related_event">
            <typename name="event_occurrence"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="exclusive_product_concept_feature_category" supertypes="product_concept_feature_category"/>
      <entity name="executed_action" supertypes="action"/>
      <entity name="expanded_uncertainty" supertypes="standard_uncertainty">
         <explicit name="coverage_factor">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="expression_conversion_based_unit" supertypes="context_dependent_unit variable_semantics">
         <inverse name="associated_variable_environment" entity="environment" attribute="semantics"/>
      </entity>
      <entity name="extension" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="extent" supertypes="characterized_object"/>
      <entity name="external_class_library" supertypes="external_source"/>
      <entity name="external_identification_assignment" abstract.supertype="YES" supertypes="identification_assignment">
         <explicit name="source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="external_source">
         <explicit name="source_id">
            <typename name="source_item"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="externally_defined_class" supertypes="class externally_defined_item"/>
      <entity name="externally_defined_dimension_definition" supertypes="dimensional_size externally_defined_item">
         <where label="WR1" expression="(SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification')"/>
         <where label="WR2" expression="1 &gt;= SIZEOF(QUERY ( adr &lt;* USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ))"/>
      </entity>
      <entity name="externally_defined_item">
         <explicit name="item_id">
            <typename name="source_item"/>
         </explicit>
         <explicit name="source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="face" supertypes="topological_representation_item">
         <explicit name="bounds">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face_bound"/>
         </explicit>
         <where label="WR1" expression="NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))))"/>
         <where label="WR2" expression="SIZEOF(QUERY(temp &lt;* bounds | 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.FACE_OUTER_BOUND' IN&#10;                                               TYPEOF(temp))) &lt;= 1"/>
      </entity>
      <entity name="face_bound" supertypes="topological_representation_item">
         <explicit name="bound">
            <typename name="loop"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="face_outer_bound" supertypes="face_bound"/>
      <entity name="face_surface" supertypes="face geometric_representation_item">
         <explicit name="face_geometry">
            <typename name="surface"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ORIENTED_SURFACE' IN TYPEOF(face_geometry))"/>
      </entity>
      <entity name="fact_type" supertypes="property_definition"/>
      <entity name="flatness_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))"/>
      </entity>
      <entity name="force_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\force_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = newton"/>
      </entity>
      <entity name="forward_chaining_rule" supertypes="rule_definition"/>
      <entity name="forward_chaining_rule_premise" supertypes="property_definition property_definition_representation representation"/>
      <entity name="founded_item"/>
      <entity name="frequency_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\frequency_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = hertz"/>
      </entity>
      <entity name="func" supertypes="compound_representation_item"/>
      <entity name="functional_specification" supertypes="representation"/>
      <entity name="functional_specification_definition" supertypes="functional_unit"/>
      <entity name="functional_terminal_group" supertypes="group">
         <unique label="UR1">
            <unique.attribute entity-ref="group" attribute="name"/>
         </unique>
      </entity>
      <entity name="functional_unit" supertypes="product_definition"/>
      <entity name="functional_unit_terminal_definition" supertypes="shape_aspect">
         <where label="WR1" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'FUNCTIONAL_UNIT' IN&#10;       TYPEOF (SELF.of_shape.definition))"/>
      </entity>
      <entity name="functionally_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="general_material_property" supertypes="general_property">
         <where label="WR1" expression="SIZEOF( QUERY( gpa &lt;* USEDIN(SELF,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | &#10;  NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition)) )) = 0"/>
      </entity>
      <entity name="general_property">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="general_property_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="base_definition">
            <typename name="general_property"/>
         </explicit>
         <explicit name="derived_definition">
            <typename name="derived_property_select"/>
         </explicit>
         <where label="WR1" expression="SIZEOF( USEDIN( derived_definition, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1"/>
         <where label="WR2" expression="derived_definition.name = base_definition.name"/>
      </entity>
      <entity name="general_property_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_property">
            <typename name="general_property"/>
         </explicit>
         <explicit name="related_property">
            <typename name="general_property"/>
         </explicit>
      </entity>
      <entity name="generic_expression" abstract.supertype="YES" super.expression="ONEOF (simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression)">
         <where label="WR1" expression="is_acyclic(SELF)"/>
      </entity>
      <entity name="generic_literal" abstract.supertype="YES" supertypes="simple_generic_expression"/>
      <entity name="generic_variable" abstract.supertype="YES" supertypes="simple_generic_expression">
         <inverse name="interpretation" entity="environment" attribute="syntactic_representation"/>
      </entity>
      <entity name="geometric_alignment" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)&gt; 1"/>
      </entity>
      <entity name="geometric_intersection" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)&gt; 1"/>
      </entity>
      <entity name="geometric_model_element_relationship" supertypes="geometric_representation_item representation_item_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="representation_item_relationship" attribute="relating_representation_item"/>
            <unique.attribute entity-ref="representation_item_relationship" attribute="related_representation_item"/>
         </unique>
         <where label="WR1" expression="SELF\representation_item_relationship.relating_representation_item :&lt;&gt;: &#10;       SELF\representation_item_relationship.related_representation_item"/>
      </entity>
      <entity name="geometric_representation_context" supertypes="representation_context">
         <explicit name="coordinate_space_dimension">
            <typename name="dimension_count"/>
         </explicit>
      </entity>
      <entity name="geometric_representation_item" supertypes="representation_item" super.expression="ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, vertex_point)">
         <derived name="dim" expression="dimension_of(SELF)">
            <typename name="dimension_count"/>
         </derived>
         <where label="WR1" expression="SIZEOF (QUERY (using_rep &lt;* using_representations (SELF) |&#10;      NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;      TYPEOF (using_rep.context_of_items)))) = 0"/>
      </entity>
      <entity name="geometric_tolerance">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="toleranced_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <where label="WR1" expression="('NUMBER' IN TYPEOF&#10;       (magnitude\measure_with_unit.value_component)) AND&#10;       (magnitude\measure_with_unit.value_component &gt;= 0.0)"/>
      </entity>
      <entity name="geometric_tolerance_group" supertypes="property_definition"/>
      <entity name="geometric_tolerance_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_geometric_tolerance">
            <typename name="geometric_tolerance"/>
         </explicit>
         <explicit name="related_geometric_tolerance">
            <typename name="geometric_tolerance"/>
         </explicit>
      </entity>
      <entity name="geometric_tolerance_with_datum_reference" supertypes="geometric_tolerance">
         <explicit name="datum_system">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="datum_reference"/>
         </explicit>
      </entity>
      <entity name="geometric_tolerance_with_defined_unit" supertypes="geometric_tolerance">
         <explicit name="unit_size">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="('NUMBER' IN TYPEOF&#10;       (unit_size\measure_with_unit.value_component)) AND&#10;       (unit_size\measure_with_unit.value_component &gt; 0.0)"/>
      </entity>
      <entity name="global_assignment" supertypes="representation_item_relationship"/>
      <entity name="global_uncertainty_assigned_context" supertypes="representation_context">
         <explicit name="uncertainty">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="global_unit_assigned_context" supertypes="representation_context">
         <explicit name="units">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="unit"/>
         </explicit>
      </entity>
      <entity name="ground_fact" supertypes="atomic_formula"/>
      <entity name="group">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="group_assignment" abstract.supertype="YES">
         <explicit name="assigned_group">
            <typename name="group"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="group_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_group">
            <typename name="group"/>
         </explicit>
         <explicit name="related_group">
            <typename name="group"/>
         </explicit>
      </entity>
      <entity name="group_shape_aspect" supertypes="shape_aspect"/>
      <entity name="hyperbola" supertypes="conic">
         <explicit name="semi_axis">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_imag_axis">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="id_attribute">
         <explicit name="attribute_value">
            <typename name="identifier"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="id_attribute_select"/>
         </explicit>
      </entity>
      <entity name="identification_assignment" abstract.supertype="YES">
         <explicit name="assigned_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="role">
            <typename name="identification_role"/>
         </explicit>
      </entity>
      <entity name="identification_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="illuminance_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\illuminance_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = lux"/>
      </entity>
      <entity name="included_text_block" supertypes="mapped_item">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.STRUCTURED_TEXT_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)"/>
      </entity>
      <entity name="inclusion_product_concept_feature" supertypes="conditional_concept_feature">
         <where label="WR1" expression="NOT ( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) )"/>
         <where label="WR2" expression="SIZEOF (QUERY&#10;									( cfr &lt;* USEDIN &#10;											( SELF ,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) &#10;											| &#10;											'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) &#10;									) &#10;								) + &#10;				 SIZEOF(QUERY&#10;				 					( cfr &lt;* USEDIN &#10;				 							(SELF , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) &#10;				 							| &#10;											'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)&#10;									)&#10;								)= 0"/>
         <where label="WR3" expression="SELF.condition.conditional_operator.name = 'implication'"/>
      </entity>
      <entity name="inductance_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\inductance_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = henry"/>
      </entity>
      <entity name="instanced_feature" supertypes="shape_aspect shape_feature_definition">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION' IN&#10;         TYPEOF(SELF\shape_aspect.of_shape.definition)"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional"/>
      </entity>
      <entity name="interface_plane" supertypes="shape_aspect"/>
      <entity name="item_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="transform_item_1">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="item_identified_representation_usage">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="represented_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="representation_item"/>
         </explicit>
         <where label="WR1" expression="SELF.used_representation IN using_representations(SELF.identified_item)"/>
      </entity>
      <entity name="keepout_design_object_category" supertypes="characterized_object"/>
      <entity name="known_source" supertypes="external_source pre_defined_item"/>
      <entity name="language" supertypes="group">
         <where label="WR1" expression="SELF\group.name &lt;&gt; ''"/>
      </entity>
      <entity name="length_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="length_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="limits_and_fits">
         <explicit name="form_variance">
            <typename name="label"/>
         </explicit>
         <explicit name="zone_variance">
            <typename name="label"/>
         </explicit>
         <explicit name="grade">
            <typename name="label"/>
         </explicit>
         <explicit name="source">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="line" supertypes="curve">
         <explicit name="pnt">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="dir">
            <typename name="vector"/>
         </explicit>
         <where label="WR1" expression="dir.dim  = pnt.dim"/>
      </entity>
      <entity name="line_profile_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3)"/>
         <where label="WR2" expression="SIZEOF ( &#10;QUERY ( sar &lt;* USEDIN (SELF\geometric_tolerance.toleranced_shape_aspect, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| (sar.name IN [ 'affected plane association', 'resulting intersection curve association' ]) )) = 1"/>
      </entity>
      <entity name="linear_profile_tolerance" supertypes="physical_unit_geometric_tolerance"/>
      <entity name="literal_conjunction" supertypes="simple_clause"/>
      <entity name="literal_disjunction" supertypes="simple_clause"/>
      <entity name="local_time">
         <explicit name="hour_component">
            <typename name="hour_in_day"/>
         </explicit>
         <explicit name="minute_component" optional="YES">
            <typename name="minute_in_hour"/>
         </explicit>
         <explicit name="second_component" optional="YES">
            <typename name="second_in_minute"/>
         </explicit>
         <explicit name="zone">
            <typename name="coordinated_universal_time_offset"/>
         </explicit>
         <where label="WR1" expression="valid_time (SELF)"/>
      </entity>
      <entity name="location_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF(SELF.items)= 1"/>
         <where label="WR2" expression="SIZEOF(QUERY(i &lt;* SELF.items | 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'POINT' IN TYPEOF(i)))= 1"/>
      </entity>
      <entity name="loop" supertypes="topological_representation_item" super.expression="ONEOF (vertex_loop, edge_loop)"/>
      <entity name="lot_effectivity" supertypes="effectivity">
         <explicit name="effectivity_lot_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_lot_size">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="luminous_flux_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\luminous_flux_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = lumen"/>
      </entity>
      <entity name="luminous_intensity_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="luminous_intensity_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0)"/>
      </entity>
      <entity name="magnetic_flux_density_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\magnetic_flux_density_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = tesla"/>
      </entity>
      <entity name="magnetic_flux_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\magnetic_flux_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = weber"/>
      </entity>
      <entity name="make_from_functional_unit_terminal_definition_relationship" supertypes="shape_aspect shape_aspect_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="relating_shape_aspect"/>
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="related_shape_aspect"/>
         </unique>
         <where label="WR1" expression="relating_shape_aspect.of_shape :&lt;&gt;: &#10;       related_shape_aspect.of_shape"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = FALSE"/>
      </entity>
      <entity name="make_from_model_port_relationship" supertypes="representation representation_relationship">
         <explicit name="rep_1">
            <typename name="analytical_model_port"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="analytical_model_port"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="rep_1"/>
            <unique.attribute attribute="rep_2"/>
         </unique>
         <where label="WR1" expression="rep_1 :&lt;&gt;: rep_2"/>
      </entity>
      <entity name="make_from_part_feature_relationship" supertypes="shape_aspect shape_aspect_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="relating_shape_aspect"/>
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="related_shape_aspect"/>
         </unique>
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = FALSE"/>
      </entity>
      <entity name="make_from_usage_option" supertypes="product_definition_usage">
         <explicit name="ranking">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="ranking_rationale">
            <typename name="text"/>
         </explicit>
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="(NOT ('NUMBER' IN TYPEOF(quantity.value_component)))&#10;       OR (quantity.value_component &gt; 0)"/>
      </entity>
      <entity name="mapped_item" supertypes="representation_item">
         <explicit name="mapping_source">
            <typename name="representation_map"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="representation_item"/>
         </explicit>
         <where label="WR1" expression="acyclic_mapped_representation(using_representations(SELF), [SELF])"/>
      </entity>
      <entity name="mass_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="mass_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="material_designation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definitions">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="characterized_definition"/>
         </explicit>
      </entity>
      <entity name="material_designation_characterization">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="designation">
            <typename name="material_designation"/>
         </explicit>
         <explicit name="property">
            <typename name="characterized_material_property"/>
         </explicit>
      </entity>
      <entity name="material_designation_with_conductivity_classification" supertypes="material_designation"/>
      <entity name="material_electrical_conductivity_category" supertypes="group"/>
      <entity name="material_property" supertypes="property_definition">
         <unique label="UR1">
            <unique.attribute entity-ref="property_definition" attribute="name"/>
            <unique.attribute entity-ref="property_definition" attribute="definition"/>
         </unique>
         <where label="WR1" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CHARACTERIZED_OBJECT' IN&#10;          TYPEOF(SELF\property_definition.definition)) OR&#10;       (SIZEOF(bag_to_set(USEDIN(SELF ,&#10;                     'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -&#10;              QUERY(temp &lt;* bag_to_set(USEDIN(SELF ,&#10;                       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |&#10;                       ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;                      'MATERIAL_PROPERTY_REPRESENTATION' IN&#10;                      TYPEOF(temp)))) = 0)"/>
      </entity>
      <entity name="material_property_representation" supertypes="property_definition_representation">
         <explicit name="dependent_environment">
            <typename name="data_environment"/>
         </explicit>
      </entity>
      <entity name="measure_qualification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="qualified_measure">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="qualifiers">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="value_qualifier"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(temp &lt;* qualifiers |&#10;             'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRECISION_QUALIFIER'&#10;             IN TYPEOF(temp))) &lt; 2"/>
      </entity>
      <entity name="measure_representation_item" supertypes="representation_item measure_with_unit"/>
      <entity name="measure_with_unit" super.expression="ONEOF (length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit)">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <explicit name="unit_component">
            <typename name="unit"/>
         </explicit>
         <where label="WR1" expression="valid_units (SELF)"/>
      </entity>
      <entity name="model_parameter" supertypes="descriptive_representation_item group_assignment general_property" super.expression="ONEOF (datum_difference_based_model_parameter, schema_based_model_parameter) ANDOR ONEOF (analytical_model_parameter, category_model_parameter)">
         <explicit name="items" optional="YES">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="model_parameter_assigned_item"/>
         </explicit>
      </entity>
      <entity name="modified_geometric_tolerance" supertypes="geometric_tolerance">
         <explicit name="modifier">
            <typename name="limit_condition"/>
         </explicit>
      </entity>
      <entity name="multi_language_attribute_assignment" supertypes="attribute_value_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="multi_language_attribute_item"/>
         </explicit>
         <derived name="translation_language" expression="language_indication[1]\attribute_classification_assignment.assigned_class">
            <typename name="language"/>
         </derived>
         <inverse name="language_indication" entity="attribute_language_assignment" attribute="items">
            <inverse.aggregate type="SET" lower="1" upper="1"/>
         </inverse>
         <where label="WR1" expression="(SELF\attribute_value_assignment.role.name = 'alternate language')"/>
         <where label="WR2" expression="SIZEOF( QUERY( ala &lt;* language_indication |  &#10;   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND &#10;   (ala\attribute_classification_assignment.role.name='translated') )) = 1"/>
         <where label="WR3" expression="SELF\attribute_value_assignment.attribute_name &lt;&gt; ''"/>
         <where label="WR4" expression="SIZEOF(QUERY(ci &lt;* items |&#10;SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |&#10;(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND &#10;(ata.translation_language :=: translation_language) ))&gt;1 )) =0"/>
         <where label="WR5" expression="SIZEOF(QUERY(ci &lt;* items |&#10;SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |&#10; (ata\attribute_classification_assignment.role.name='primary') AND&#10; (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND &#10; (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))&gt;0 )) =0"/>
      </entity>
      <entity name="multiple_arity_generic_expression" abstract.supertype="YES" supertypes="generic_expression">
         <explicit name="operands">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity name="name_assignment" abstract.supertype="YES">
         <explicit name="assigned_name">
            <typename name="label"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="name_attribute">
         <explicit name="attribute_value">
            <typename name="label"/>
         </explicit>
         <explicit name="named_item">
            <typename name="name_attribute_select"/>
         </explicit>
      </entity>
      <entity name="named_unit" super.expression="ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit, ratio_unit)">
         <explicit name="dimensions">
            <typename name="dimensional_exponents"/>
         </explicit>
      </entity>
      <entity name="network_node_definition" supertypes="product_definition"/>
      <entity name="next_assembly_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="object_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="offset_curve_2d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <where label="WR1" expression="basis_curve.dim = 2"/>
      </entity>
      <entity name="offset_curve_3d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="ref_direction">
            <typename name="direction"/>
         </explicit>
         <where label="WR1" expression="(basis_curve.dim = 3) AND (ref_direction.dim = 3)"/>
      </entity>
      <entity name="offset_surface" supertypes="surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="operational_requirement_occurrence_relationship" supertypes="property_definition product_definition_relationship"/>
      <entity name="opposing_boundary_dimensional_size" supertypes="dimensional_size"/>
      <entity name="organization">
         <explicit name="id" optional="YES">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organization_assignment" abstract.supertype="YES">
         <explicit name="assigned_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="role">
            <typename name="organization_role"/>
         </explicit>
      </entity>
      <entity name="organization_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="related_organization">
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="organizational_address" supertypes="address">
         <explicit name="organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organizational_project">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="responsible_organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="organizational_project_assignment" abstract.supertype="YES">
         <explicit name="assigned_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
         <explicit name="role">
            <typename name="organizational_project_role"/>
         </explicit>
      </entity>
      <entity name="organizational_project_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
         <explicit name="related_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
      </entity>
      <entity name="organizational_project_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="oriented_edge" supertypes="edge">
         <explicit name="edge_element">
            <typename name="edge"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="edge_start" expression="boolean_choose (SELF.orientation,&#10;                                            SELF.edge_element.edge_start,&#10;                                            SELF.edge_element.edge_end)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <derived name="edge_end" expression="boolean_choose (SELF.orientation,&#10;                                            SELF.edge_element.edge_end,&#10;                                            SELF.edge_element.edge_start)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element))"/>
      </entity>
      <entity name="oriented_surface" supertypes="surface">
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="package_product_concept_feature" supertypes="product_concept_feature">
         <where label="WR1" expression="NOT ( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) )"/>
         <where label="WR2" expression="SIZEOF ( QUERY &#10;									( &#10;										cfr &lt;* USEDIN ( SELF , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) &#10;										| &#10;										('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) &#10;										AND &#10;										( SIZEOF ( QUERY &#10;																( &#10;																	ipcf &lt;* USEDIN ( cfr , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.' +	'CONDITION' ) &#10;																	| &#10;																	'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) &#10;																)&#10;															)= 1 &#10;										)&#10;									)&#10;							)&gt;0"/>
      </entity>
      <entity name="parabola" supertypes="conic">
         <explicit name="focal_dist">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="focal_dist &lt;&gt; 0.0"/>
      </entity>
      <entity name="parallel_offset" supertypes="derived_shape_aspect">
         <explicit name="offset">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="parallelism_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt; 3"/>
      </entity>
      <entity name="parameter_assignment" supertypes="parameter_assignment_representation property_definition_representation"/>
      <entity name="parameter_assignment_override" supertypes="representation representation_relationship">
         <explicit name="rep_1">
            <typename name="parameter_assignment_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="parameter_assignment_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="rep_1"/>
            <unique.attribute attribute="rep_2"/>
         </unique>
         <where label="WR1" expression="SELF\representation_relationship.rep_1 &lt;&gt; &#10;       SELF\representation_relationship.rep_2"/>
      </entity>
      <entity name="parameter_assignment_representation" supertypes="representation"/>
      <entity name="parametric_representation_context" supertypes="representation_context"/>
      <entity name="part_feature_template_definition" supertypes="shape_feature_definition group">
         <where label="WR1" expression="SELF\group.name = SELF\characterized_object.name"/>
         <where label="WR2" expression="SELF\group.description = SELF\characterized_object.description"/>
      </entity>
      <entity name="partial_document_with_structured_text_representation_assignment" supertypes="applied_document_usage_constraint_assignment characterized_object"/>
      <entity name="path" supertypes="topological_representation_item">
         <explicit name="edge_list">
            <aggregate type="LIST" unique="YES" lower="1" upper="?"/>
            <typename name="oriented_edge"/>
         </explicit>
         <where label="WR1" expression="path_head_to_tail(SELF)"/>
      </entity>
      <entity name="pcurve" supertypes="curve">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(reference_to_curve\representation.items) = 1"/>
         <where label="WR2" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CURVE' IN TYPEOF&#10;                    (reference_to_curve\representation.items[1])"/>
         <where label="WR3" expression="reference_to_curve\representation.items[1]\&#10;                               geometric_representation_item.dim =2"/>
      </entity>
      <entity name="perpendicular_to" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="perpendicularity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3"/>
      </entity>
      <entity name="person">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="last_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="first_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="middle_names" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="prefix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="suffix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="EXISTS(last_name) OR EXISTS(first_name)"/>
      </entity>
      <entity name="person_and_organization">
         <explicit name="the_person">
            <typename name="person"/>
         </explicit>
         <explicit name="the_organization">
            <typename name="organization"/>
         </explicit>
         <derived name="name" expression="get_name_value (SELF)">
            <typename name="label"/>
         </derived>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="person_and_organization_address" supertypes="organizational_address personal_address">
         <explicit name="organizations">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="organization"/>
            <redeclaration entity-ref="organizational_address"/>
         </explicit>
         <explicit name="people">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="person"/>
            <redeclaration entity-ref="personal_address"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(pao &lt;* USEDIN (SELF\personal_address.people[1], 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1"/>
      </entity>
      <entity name="person_and_organization_assignment" abstract.supertype="YES">
         <explicit name="assigned_person_and_organization">
            <typename name="person_and_organization"/>
         </explicit>
         <explicit name="role">
            <typename name="person_and_organization_role"/>
         </explicit>
      </entity>
      <entity name="person_and_organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="personal_address" supertypes="address">
         <explicit name="people">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="physical_unit" supertypes="product_definition product_definition_shape"/>
      <entity name="physical_unit_datum" supertypes="shape_aspect" super.expression="edge_segment_vertex">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="physical_unit_datum_feature" supertypes="shape_aspect"/>
      <entity name="physical_unit_datum_target_set" supertypes="physical_unit_datum_feature"/>
      <entity name="physical_unit_geometric_tolerance" supertypes="geometric_tolerance property_definition"/>
      <entity name="placed_datum_target_feature" supertypes="datum_target">
         <derived name="representation_associations" expression="get_shape_aspect_property_definition_representations(SELF)">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="property_definition_representation"/>
         </derived>
         <where label="WR1" expression="SELF.description IN ['point','line','rectangle','circle', 'circular line']"/>
         <where label="WR2" expression="SIZEOF (QUERY (pdr &lt;* representation_associations | 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF (pdr.used_representation) )) = 1"/>
         <where label="WR3" expression="valid_datum_target_parameters(SELF)"/>
      </entity>
      <entity name="placed_feature" supertypes="shape_aspect"/>
      <entity name="placement" supertypes="geometric_representation_item" super.expression="ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d)">
         <explicit name="location">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="plane" supertypes="elementary_surface"/>
      <entity name="plane_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="plane_angle_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="plus_minus_tolerance">
         <explicit name="range">
            <typename name="tolerance_method_definition"/>
         </explicit>
         <explicit name="toleranced_dimension">
            <typename name="dimensional_characteristic"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="toleranced_dimension"/>
         </unique>
      </entity>
      <entity name="point" supertypes="geometric_representation_item" super.expression="ONEOF (cartesian_point, point_on_curve, point_on_surface, point_replica, degenerate_pcurve)"/>
      <entity name="point_on_curve" supertypes="point">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="point_parameter">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_on_surface" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="point_parameter_u">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="point_parameter_v">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_replica" supertypes="point">
         <explicit name="parent_pt">
            <typename name="point"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="WR1" expression="transformation.dim = parent_pt.dim"/>
         <where label="WR2" expression="acyclic_point_replica (SELF,parent_pt)"/>
      </entity>
      <entity name="polar_complex_number_literal" supertypes="generic_literal">
         <explicit name="radius">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="angle">
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="radius &gt;= 0"/>
         <where label="WR2" expression="{ 0 &lt;= angle &lt; 2*PI }"/>
      </entity>
      <entity name="polyline" supertypes="bounded_curve">
         <explicit name="points">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="port_variable" supertypes="representation representation_item" super.expression="ONEOF (across_port_variable, through_port_variable, transform_port_variable)"/>
      <entity name="position_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3)"/>
      </entity>
      <entity name="positional_boundary" supertypes="shape_aspect">
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="positional_boundary_member" supertypes="shape_aspect">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="power_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\power_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = watt"/>
      </entity>
      <entity name="pre_defined_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="precision_qualifier">
         <explicit name="precision_value">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="predefined_requirement_view_definition" supertypes="product_definition"/>
      <entity name="pressure_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\pressure_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = pascal"/>
      </entity>
      <entity name="product">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="frame_of_reference">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_context"/>
         </explicit>
      </entity>
      <entity name="product_category">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="product_category_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="category">
            <typename name="product_category"/>
         </explicit>
         <explicit name="sub_category">
            <typename name="product_category"/>
         </explicit>
         <where label="WR1" expression="acyclic_product_category_relationship (SELF, [SELF.sub_category])"/>
      </entity>
      <entity name="product_class" supertypes="product_concept characterized_object"/>
      <entity name="product_concept">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="market_context">
            <typename name="product_concept_context"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="id"/>
         </unique>
      </entity>
      <entity name="product_concept_context" supertypes="application_context_element">
         <explicit name="market_segment_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="feature">
            <typename name="product_concept_feature"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature_category" supertypes="group">
         <where label="WR1" expression="SIZEOF(QUERY&#10;									( &#10;										aga &lt;* USEDIN( SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) &#10;										|&#10;     								('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) &#10;     								AND&#10;    								(&#10;    									( aga.role.name &lt;&gt; 'specification category member' ) &#10;    									OR &#10;    									( SIZEOF(QUERY &#10;    															( &#10;    																i &lt;* aga.items &#10;    																| &#10;    																('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) &#10;    																AND &#10;    																NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i))&#10;    															)&#10;    													) &lt;&gt; SIZEOF (aga.items)&#10;    									)&#10;    								) &#10;       						) &#10;       				) =0"/>
      </entity>
      <entity name="product_concept_feature_category_usage" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="product_concept_feature_category"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="category_usage_item"/>
         </explicit>
         <where label="WR1" expression="SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ]"/>
      </entity>
      <entity name="product_concept_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="related_product_concept">
            <typename name="product_concept"/>
         </explicit>
      </entity>
      <entity name="product_context" supertypes="application_context_element">
         <explicit name="discipline_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
         <derived name="name" expression="get_name_value (SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="product_definition_context" supertypes="application_context_element">
         <explicit name="life_cycle_stage">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition_context_association">
         <explicit name="definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
         <explicit name="role">
            <typename name="product_definition_context_role"/>
         </explicit>
      </entity>
      <entity name="product_definition_context_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_definition_effectivity" supertypes="effectivity">
         <explicit name="usage">
            <typename name="product_definition_relationship"/>
         </explicit>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0"/>
      </entity>
      <entity name="product_definition_formation">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_product">
            <typename name="product"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="id"/>
            <unique.attribute attribute="of_product"/>
         </unique>
      </entity>
      <entity name="product_definition_formation_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition_formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="related_product_definition_formation">
            <typename name="product_definition_formation"/>
         </explicit>
      </entity>
      <entity name="product_definition_formation_with_specified_source" supertypes="product_definition_formation">
         <explicit name="make_or_buy">
            <typename name="source"/>
         </explicit>
      </entity>
      <entity name="product_definition_occurrence_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="occurrence">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="occurrence_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <where label="WR1" expression="occurrence_usage.relating_product_definition :&lt;&gt;: &#10;       occurrence"/>
         <where label="WR2" expression="occurrence_usage.related_product_definition :&lt;&gt;: &#10;       occurrence"/>
         <where label="WR3" expression="occurrence.formation :=:&#10;       occurrence_usage.related_product_definition.formation"/>
      </entity>
      <entity name="product_definition_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="related_product_definition">
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="product_definition_shape" supertypes="property_definition">
         <unique label="UR1">
            <unique.attribute entity-ref="property_definition" attribute="definition"/>
         </unique>
         <where label="WR1" expression="SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) &gt; 0"/>
      </entity>
      <entity name="product_definition_usage" supertypes="product_definition_relationship" super.expression="ONEOF (make_from_usage_option, assembly_component_usage)">
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_relationship" attribute="id"/>
            <unique.attribute entity-ref="product_definition_relationship" attribute="relating_product_definition"/>
            <unique.attribute entity-ref="product_definition_relationship" attribute="related_product_definition"/>
         </unique>
         <where label="WR1" expression="acyclic_product_definition_relationship&#10;         (SELF,&#10;         [SELF\product_definition_relationship.related_product_definition],&#10;         'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION_USAGE')"/>
      </entity>
      <entity name="product_definition_with_associated_documents" supertypes="product_definition">
         <explicit name="documentation_ids">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="product_identification" supertypes="configuration_item characterized_object">
         <explicit name="item_concept">
            <typename name="product_class"/>
            <redeclaration entity-ref="configuration_item"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY &#10;								( cd &lt;* USEDIN ( SELF ,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION' ) &#10;								|&#10;     						( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) &#10;     						AND &#10;    						( SIZEOF ( QUERY &#10;    												( &#10;    													prpc &lt;* USEDIN ( cd. design\product_definition_formation.of_product , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') &#10;    													| &#10;         											prpc. name IN ['part' , 'raw material' , 'tool'] ) ) &gt;0&#10;     													) &#10;     												) &#10;     											) &lt;=1"/>
         <where label="WR2" expression="NOT ( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) &#10;				XOR ( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) )"/>
      </entity>
      <entity name="product_related_product_category" supertypes="product_category">
         <explicit name="products">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product"/>
         </explicit>
      </entity>
      <entity name="product_specific_parameter_value_assignment" supertypes="characterized_object product_related_product_category"/>
      <entity name="product_specification" supertypes="product_identification configurable_item"/>
      <entity name="projected_zone_definition" supertypes="tolerance_zone_definition">
         <explicit name="projection_end">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="projected_length">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="('NUMBER' IN TYPEOF&#10;       (projected_length\measure_with_unit.value_component)) AND&#10;       (projected_length\measure_with_unit.value_component &gt; 0.0)"/>
         <where label="WR2" expression="(derive_dimensional_exponents&#10;       (projected_length\measure_with_unit.unit_component)=&#10;        dimensional_exponents(1,0,0,0,0,0,0))"/>
      </entity>
      <entity name="promissory_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="property_definition">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_definition"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="property_definition_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_property_definition">
            <typename name="property_definition"/>
         </explicit>
         <explicit name="related_property_definition">
            <typename name="property_definition"/>
         </explicit>
      </entity>
      <entity name="property_definition_representation">
         <explicit name="definition">
            <typename name="represented_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value (SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) &lt;= 1"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="qualified_representation_item" supertypes="representation_item">
         <explicit name="qualifiers">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="value_qualifier"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(temp &lt;* qualifiers |&#10;             'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRECISION_QUALIFIER'&#10;             IN TYPEOF(temp))) &lt; 2"/>
      </entity>
      <entity name="qualitative_uncertainty" supertypes="uncertainty_qualifier">
         <explicit name="uncertainty_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="quantified_assembly_component_usage" supertypes="assembly_component_usage">
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="(NOT ('NUMBER' IN TYPEOF(quantity.value_component)))&#10;       OR (quantity.value_component &gt; 0)"/>
      </entity>
      <entity name="quasi_uniform_curve" supertypes="b_spline_curve"/>
      <entity name="quasi_uniform_surface" supertypes="b_spline_surface"/>
      <entity name="range_characteristic" supertypes="representation descriptive_representation_item"/>
      <entity name="ratio_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="ratio_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="rational_b_spline_curve" supertypes="b_spline_curve">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="list_to_array(weights_data,0,&#10;                                      upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.&#10;                                           control_points_list)"/>
         <where label="WR2" expression="curve_weights_positive(SELF)"/>
      </entity>
      <entity name="rational_b_spline_surface" supertypes="b_spline_surface">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="(SIZEOF(weights_data) =&#10;                     SIZEOF(SELF\b_spline_surface.control_points_list))&#10;           AND (SIZEOF(weights_data[1]) =&#10;                  SIZEOF(SELF\b_spline_surface.control_points_list[1]))"/>
         <where label="WR2" expression="surface_weights_positive(SELF)"/>
      </entity>
      <entity name="rectangular_composite_surface" supertypes="bounded_surface">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="surface_patch"/>
         </explicit>
         <derived name="n_u" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="n_v" expression="SIZEOF(segments[1])">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="SIZEOF(QUERY (s &lt;* segments | n_v &lt;&gt; SIZEOF (s))) = 0"/>
         <where label="WR2" expression="constraints_rectangular_composite_surface(SELF)"/>
      </entity>
      <entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="u1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="u2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="usense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="vsense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="u1 &lt;&gt; u2"/>
         <where label="WR2" expression="v1 &lt;&gt; v2"/>
         <where label="WR3" expression="(('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))&#10;       AND  (NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PLANE' IN TYPEOF(basis_surface)))) OR&#10;      ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))&#10;          OR (usense = (u2 &gt; u1))"/>
         <where label="WR4" expression="(('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))&#10;          OR&#10;         ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))&#10;          OR (vsense = (v2 &gt; v1))"/>
      </entity>
      <entity name="reference_graphic_registration_mark" supertypes="shape_aspect">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = false"/>
      </entity>
      <entity name="referenced_modified_datum" supertypes="datum_reference">
         <explicit name="modifier">
            <typename name="limit_condition"/>
         </explicit>
      </entity>
      <entity name="relative_event_occurrence" supertypes="event_occurrence">
         <explicit name="base_event">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="offset">
            <typename name="time_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="context_of_items">
            <typename name="representation_context"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <derived name="description" expression="get_description_value (SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&#10;       &lt;= 1"/>
         <where label="WR2" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&#10;       &lt;= 1"/>
      </entity>
      <entity name="representation_context">
         <explicit name="context_identifier">
            <typename name="identifier"/>
         </explicit>
         <explicit name="context_type">
            <typename name="text"/>
         </explicit>
         <inverse name="representations_in_context" entity="representation" attribute="context_of_items">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="representation_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(using_representations(SELF)) &gt; 0"/>
      </entity>
      <entity name="representation_item_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_representation_item">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="related_representation_item">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="representation_map">
         <explicit name="mapping_origin">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="mapped_representation">
            <typename name="representation"/>
         </explicit>
         <inverse name="map_usage" entity="mapped_item" attribute="mapping_source">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="item_in_context(SELF.mapping_origin,&#10;       SELF.mapped_representation.context_of_items)"/>
      </entity>
      <entity name="representation_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="rep_1">
            <typename name="representation"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="representation_relationship_with_transformation" supertypes="representation_relationship">
         <explicit name="transformation_operator">
            <typename name="transformation"/>
         </explicit>
         <where label="WR1" expression="SELF\representation_relationship.rep_1.context_of_items&#10;   :&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items"/>
      </entity>
      <entity name="requirement_assigned_object" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="requirement_assigned_item"/>
         </explicit>
      </entity>
      <entity name="requirement_assignment" supertypes="characterized_object group"/>
      <entity name="requirement_definition" supertypes="product_definition"/>
      <entity name="requirement_source" supertypes="group"/>
      <entity name="requirement_view_definition_relationship" supertypes="product_definition_relationship"/>
      <entity name="resistance_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="unit_component">
            <typename name="si_unit"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <explicit name="value_component">
            <typename name="numeric_measure"/>
            <redeclaration entity-ref="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\measure_with_unit ||&#10;       SELF\resistance_measure_with_unit))) = 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = ohm"/>
      </entity>
      <entity name="role_association">
         <explicit name="role">
            <typename name="object_role"/>
         </explicit>
         <explicit name="item_with_role">
            <typename name="role_select"/>
         </explicit>
      </entity>
      <entity name="roundness_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))"/>
      </entity>
      <entity name="row_representation_item" supertypes="compound_representation_item">
         <explicit name="item_element">
            <typename name="list_representation_item"/>
            <redeclaration entity-ref="compound_representation_item"/>
         </explicit>
      </entity>
      <entity name="row_value" supertypes="compound_representation_item"/>
      <entity name="row_variable" supertypes="abstract_variable"/>
      <entity name="rule_action" supertypes="action"/>
      <entity name="rule_condition" supertypes="atomic_formula"/>
      <entity name="rule_definition" supertypes="rule_software_definition"/>
      <entity name="rule_set" supertypes="rule_software_definition"/>
      <entity name="rule_set_group" supertypes="rule_software_definition"/>
      <entity name="rule_software_definition" supertypes="product_definition"/>
      <entity name="rule_superseded_assignment" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="rule_superseded_item"/>
         </explicit>
      </entity>
      <entity name="rule_supersedence" supertypes="rule_action"/>
      <entity name="runout_zone_definition" supertypes="tolerance_zone_definition">
         <explicit name="orientation">
            <typename name="runout_zone_orientation"/>
         </explicit>
      </entity>
      <entity name="runout_zone_orientation">
         <explicit name="angle">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="runout_zone_orientation_reference_direction" supertypes="runout_zone_orientation">
         <explicit name="orientation_defining_relationship">
            <typename name="shape_aspect_relationship"/>
         </explicit>
      </entity>
      <entity name="scalar_terminal_definition_link" supertypes="shape_aspect shape_aspect_relationship">
         <explicit name="relating_shape_aspect">
            <typename name="functional_unit_terminal_definition"/>
            <redeclaration entity-ref="shape_aspect_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="related_shape_aspect"/>
            <unique.attribute attribute="relating_shape_aspect"/>
         </unique>
         <where label="WR1" expression="SELF\shape_aspect_relationship.related_shape_aspect :&lt;&gt;:&#10;       SELF\shape_aspect_relationship.relating_shape_aspect"/>
      </entity>
      <entity name="scalar_variable" supertypes="abstract_variable"/>
      <entity name="scattering_parameter" supertypes="polar_complex_number_literal">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\polar_complex_number_literal ||&#10;       SELF\scattering_parameter))) = 0"/>
      </entity>
      <entity name="schema_based_model_parameter" supertypes="model_parameter"/>
      <entity name="seating_plane" supertypes="shape_aspect"/>
      <entity name="security_classification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="security_level">
            <typename name="security_classification_level"/>
         </explicit>
      </entity>
      <entity name="security_classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_security_classification">
            <typename name="security_classification"/>
         </explicit>
         <derived name="role" expression="get_role (SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) &lt;= 1"/>
      </entity>
      <entity name="security_classification_level">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="serial_numbered_effectivity" supertypes="effectivity">
         <explicit name="effectivity_start_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_end_id" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="shape_aspect" super.expression="ONEOF (derived_shape_aspect, positional_boundary, positional_boundary_member, tolerance_zone_boundary, viewing_plane, seating_plane, reference_graphic_registration_mark)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_shape">
            <typename name="product_definition_shape"/>
         </explicit>
         <explicit name="product_definitional">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="shape_aspect_deriving_relationship" supertypes="shape_aspect_relationship">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DERIVED_SHAPE_ASPECT' IN&#10;TYPEOF&#10;            (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT)"/>
      </entity>
      <entity name="shape_aspect_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="related_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <derived name="id" expression="get_id_value (SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF (USEDIN (SELF, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) &lt;= 1"/>
      </entity>
      <entity name="shape_definition_representation" supertypes="property_definition_representation">
         <where label="WR1" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition))"/>
         <where label="WR2" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation)"/>
      </entity>
      <entity name="shape_dimension_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF (QUERY (temp &lt;* SELF\representation.items | &#10;    NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' &#10;        IN TYPEOF (temp)))) = 0"/>
         <where label="WR2" expression="SIZEOF (SELF\representation.items) &lt;= 3"/>
         <where label="WR3" expression="SIZEOF (QUERY (pos_mri &lt;* QUERY (real_mri &lt;*&#10;        SELF\representation.items | 'REAL' IN TYPEOF&#10;        (real_mri\measure_with_unit.value_component) ) |        &#10;     NOT  (pos_mri\measure_with_unit.value_component &gt; 0.0 ))) = 0"/>
      </entity>
      <entity name="shape_feature_definition" supertypes="characterized_object"/>
      <entity name="shape_representation" supertypes="representation"/>
      <entity name="shape_representation_relationship" supertypes="representation_relationship">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2))"/>
      </entity>
      <entity name="shape_representation_with_parameters" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF( QUERY( i &lt;* SELF.items | SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PLACEMENT', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(i)) = 1 )) = SIZEOF(SELF.items)"/>
      </entity>
      <entity name="si_unit" supertypes="named_unit">
         <explicit name="prefix" optional="YES">
            <typename name="si_prefix"/>
         </explicit>
         <explicit name="name">
            <typename name="si_unit_name"/>
         </explicit>
         <derived name="dimensions" expression="dimensions_for_si_unit (name)">
            <typename name="dimensional_exponents"/>
            <redeclaration entity-ref="named_unit"/>
         </derived>
      </entity>
      <entity name="signal" supertypes="characterized_object"/>
      <entity name="signal_category" supertypes="group"/>
      <entity name="simple_clause" supertypes="compound_representation_item"/>
      <entity name="simple_generic_expression" abstract.supertype="YES" supertypes="generic_expression" super.expression="ONEOF (generic_literal, generic_variable)"/>
      <entity name="solid_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="solid_angle_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="source_for_requirement" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_source"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="requirement_source_item"/>
         </explicit>
      </entity>
      <entity name="sourced_requirement" supertypes="group_assignment">
         <explicit name="assigned_group">
            <typename name="requirement_source"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="specification_definition" supertypes="product_definition"/>
      <entity name="specified_higher_usage_occurrence" supertypes="assembly_component_usage">
         <explicit name="upper_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="next_usage">
            <typename name="next_assembly_usage_occurrence"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="upper_usage"/>
            <unique.attribute attribute="next_usage"/>
         </unique>
         <where label="WR1" expression="SELF :&lt;&gt;: upper_usage"/>
         <where label="WR2" expression="SELF\product_definition_relationship.relating_product_definition&#10;       :=: upper_usage.relating_product_definition"/>
         <where label="WR3" expression="SELF\product_definition_relationship.related_product_definition&#10;       :=: next_usage.related_product_definition"/>
         <where label="WR4" expression="(upper_usage.related_product_definition :=:&#10;       next_usage.relating_product_definition) OR&#10;       (SIZEOF (QUERY (pdr &lt;* USEDIN (upper_usage.related_product_definition,&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;       'RELATED_PRODUCT_DEFINITION') |&#10;        pdr.relating_product_definition :=: &#10;        next_usage.relating_product_definition)) = 1)"/>
         <where label="WR5" expression="SIZEOF (['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']&#10;       * TYPEOF(upper_usage)) = 1"/>
      </entity>
      <entity name="spherical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="standard_uncertainty" supertypes="uncertainty_qualifier" super.expression="expanded_uncertainty">
         <explicit name="uncertainty_value">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="statistical_dimensional_location" supertypes="dimensional_location"/>
      <entity name="statistical_dimensional_size" supertypes="dimensional_size_property"/>
      <entity name="statistical_geometric_tolerance" supertypes="physical_unit_geometric_tolerance"/>
      <entity name="straightness_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF))"/>
      </entity>
      <entity name="structured_text_composition" supertypes="compound_representation_item"/>
      <entity name="structured_text_representation" supertypes="representation">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="string_representation_item_select"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="surface" supertypes="geometric_representation_item" super.expression="ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica)"/>
      <entity name="surface_curve" supertypes="curve">
         <explicit name="curve_3d">
            <typename name="curve"/>
         </explicit>
         <explicit name="associated_geometry">
            <aggregate type="LIST" lower="1" upper="2"/>
            <typename name="pcurve_or_surface"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="preferred_surface_curve_representation"/>
         </explicit>
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="WR1" expression="curve_3d.dim = 3"/>
         <where label="WR2" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1])) OR&#10;                        (master_representation &lt;&gt; pcurve_s1)"/>
         <where label="WR3" expression="('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2])) OR&#10;                        (master_representation &lt;&gt; pcurve_s2)"/>
         <where label="WR4" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PCURVE' IN TYPEOF(curve_3d))"/>
      </entity>
      <entity name="surface_of_linear_extrusion" supertypes="swept_surface">
         <explicit name="extrusion_axis">
            <typename name="vector"/>
         </explicit>
      </entity>
      <entity name="surface_of_revolution" supertypes="swept_surface">
         <explicit name="axis_position">
            <typename name="axis1_placement"/>
         </explicit>
         <derived name="axis_line" expression="representation_item('')||&#10;                     geometric_representation_item()|| curve()||&#10;                     line(axis_position.location, representation_item('')||&#10;                     geometric_representation_item()||&#10;                     vector(axis_position.z, 1.0))">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="surface_patch" supertypes="founded_item">
         <explicit name="parent_surface">
            <typename name="bounded_surface"/>
         </explicit>
         <explicit name="u_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="v_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="u_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="v_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <inverse name="using_surfaces" entity="rectangular_composite_surface" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="(NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CURVE_BOUNDED_SURFACE' &#10;                 IN TYPEOF(parent_surface)))"/>
      </entity>
      <entity name="surface_profile_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF)) OR ( SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3)"/>
      </entity>
      <entity name="surface_replica" supertypes="surface">
         <explicit name="parent_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator_3d"/>
         </explicit>
         <where label="WR1" expression="acyclic_surface_replica(SELF, parent_surface)"/>
      </entity>
      <entity name="swept_surface" supertypes="surface" super.expression="ONEOF (surface_of_linear_extrusion, surface_of_revolution)">
         <explicit name="swept_curve">
            <typename name="curve"/>
         </explicit>
      </entity>
      <entity name="symbol" supertypes="representation_item"/>
      <entity name="symmetric_shape_aspect" supertypes="shape_aspect">
         <inverse name="basis_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF (QUERY (x&lt;*SELF\symmetric_shape_aspect.basis_relationships |&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF &#10;       (x\shape_aspect_relationship.related_shape_aspect)))&gt;=1"/>
      </entity>
      <entity name="symmetry_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 3"/>
      </entity>
      <entity name="table_representation_item" supertypes="compound_representation_item characterized_object">
         <where label="WR1" expression="SIZEOF(QUERY(itet &lt;* SELF\compound_representation_item.item_element |&#10;       NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ROW_REPRESENTATION_ITEM' IN TYPEOF(itet))&#10;            )) = 0"/>
      </entity>
      <entity name="tagged_text_format" supertypes="representation_context"/>
      <entity name="tagged_text_item" supertypes="descriptive_representation_item"/>
      <entity name="tangent" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="test_method_based_parameter_assignment" supertypes="parameter_assignment"/>
      <entity name="thermodynamic_temperature_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="thermodynamic_temperature_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="through_port_variable" supertypes="port_variable"/>
      <entity name="time_interval">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="time_interval_assignment" abstract.supertype="YES">
         <explicit name="assigned_time_interval">
            <typename name="time_interval"/>
         </explicit>
         <explicit name="role">
            <typename name="time_interval_role"/>
         </explicit>
      </entity>
      <entity name="time_interval_based_effectivity" supertypes="effectivity">
         <explicit name="effectivity_period">
            <typename name="time_interval"/>
         </explicit>
      </entity>
      <entity name="time_interval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_time_interval">
            <typename name="time_interval"/>
         </explicit>
         <explicit name="related_time_interval">
            <typename name="time_interval"/>
         </explicit>
      </entity>
      <entity name="time_interval_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="time_interval_with_bounds" supertypes="time_interval">
         <explicit name="primary_bound" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="secondary_bound" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="duration" optional="YES">
            <typename name="time_measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="NOT (EXISTS(secondary_bound) AND EXISTS(duration))"/>
         <where label="WR2" expression="EXISTS(primary_bound) OR EXISTS(secondary_bound)"/>
      </entity>
      <entity name="time_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="time_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="tolerance_value">
         <explicit name="lower_bound">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="upper_bound">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="upper_bound\measure_with_unit.value_component &gt;&#10;        lower_bound\measure_with_unit.value_component"/>
         <where label="WR2" expression="upper_bound\measure_with_unit.unit_component =&#10;        lower_bound\measure_with_unit.unit_component"/>
      </entity>
      <entity name="tolerance_zone" supertypes="shape_aspect">
         <explicit name="defining_tolerance">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="geometric_tolerance"/>
         </explicit>
         <explicit name="form">
            <typename name="tolerance_zone_form"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_boundary" supertypes="shape_aspect">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="tolerance_zone_definition" super.expression="ONEOF (projected_zone_definition, runout_zone_definition)">
         <explicit name="zone">
            <typename name="tolerance_zone"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_explicit_opposing_boundary_set" supertypes="tolerance_zone_boundary"/>
      <entity name="tolerance_zone_form">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_implicit_opposing_boundary_set" supertypes="tolerance_zone_boundary"/>
      <entity name="topological_representation_item" supertypes="representation_item" super.expression="ONEOF (vertex, edge, face_bound, face, (loop ANDOR path))"/>
      <entity name="toroidal_surface" supertypes="elementary_surface">
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="total_runout_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF (SELF\geometric_tolerance_with_datum_reference.datum_system) &lt;= 2"/>
      </entity>
      <entity name="transform_port_variable" supertypes="port_variable"/>
      <entity name="trimmed_curve" supertypes="bounded_curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="trim_1">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="trim_2">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="sense_agreement">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="trimming_preference"/>
         </explicit>
         <where label="WR1" expression="(HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) &lt;&gt; TYPEOF(trim_1[2]))"/>
         <where label="WR2" expression="(HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) &lt;&gt; TYPEOF(trim_2[2]))"/>
      </entity>
      <entity name="type_qualifier">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="unary_generic_expression" abstract.supertype="YES" supertypes="generic_expression">
         <explicit name="operand">
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <where label="WR1" expression="valid_measure_value (SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="uncertainty_qualifier" super.expression="ONEOF (standard_uncertainty, qualitative_uncertainty)">
         <explicit name="measure_name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="uniform_curve" supertypes="b_spline_curve"/>
      <entity name="uniform_resource_identifier" supertypes="descriptive_representation_item"/>
      <entity name="uniform_surface" supertypes="b_spline_surface"/>
      <entity name="usage_concept_usage_relationship" supertypes="mapped_item item_identified_representation_usage">
         <explicit name="used_representation">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
         <explicit name="definition">
            <typename name="shape_aspect"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </explicit>
         <derived name="identified_item" expression="SELF">
            <typename name="representation_item"/>
            <redeclaration entity-ref="item_identified_representation_usage"/>
         </derived>
         <where label="WR1" expression="SELF IN SELF\item_identified_representation_usage.used_representation.items"/>
      </entity>
      <entity name="usage_view_connection_zone_terminal_shape_relationship" supertypes="representation representation_relationship_with_transformation">
         <explicit name="rep_1">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="rep_1"/>
            <unique.attribute attribute="rep_2"/>
         </unique>
         <where label="WR1" expression="SELF\representation_relationship.rep_1 &lt;&gt; &#10;       SELF\representation_relationship.rep_2"/>
      </entity>
      <entity name="value_range" supertypes="compound_representation_item">
         <where label="WR1" expression="( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element )"/>
         <where label="WR2" expression="value_range_wr2 ( item_element )"/>
         <where label="WR3" expression="value_range_wr3 ( item_element )"/>
      </entity>
      <entity name="value_representation_item" supertypes="representation_item">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <where label="WR1" expression="SIZEOF (QUERY (rep &lt;* using_representations (SELF) |&#10;       NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT'&#10;       IN TYPEOF (rep.context_of_items)&#10;       ))) = 0"/>
      </entity>
      <entity name="variable_semantics" abstract.supertype="YES"/>
      <entity name="vector" supertypes="geometric_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="magnitude &gt;= 0.0"/>
      </entity>
      <entity name="versioned_action_request">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="version">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="vertex" supertypes="topological_representation_item"/>
      <entity name="vertex_loop" supertypes="loop">
         <explicit name="loop_vertex">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="vertex_point" supertypes="vertex geometric_representation_item">
         <explicit name="vertex_geometry">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="viewing_plane" supertypes="shape_aspect"/>
      <entity name="volume_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="volume_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)"/>
      </entity>
      <rule name="compatible_dimension" appliesto="cartesian_point direction representation_context geometric_representation_context">
         <where label="WR1" expression="SIZEOF(QUERY(x &lt;* cartesian_point| SIZEOF(QUERY&#10;       (y &lt;* geometric_representation_context | item_in_context(x,y) AND&#10;       (HIINDEX(x.coordinates) &lt;&gt; y.coordinate_space_dimension))) &gt; 0 )) =0"/>
         <where label="WR2" expression="SIZEOF(QUERY(x &lt;* direction | SIZEOF( QUERY&#10;       (y &lt;* geometric_representation_context | item_in_context(x,y) AND&#10;       (HIINDEX(x.direction_ratios) &lt;&gt; y.coordinate_space_dimension)))&#10;       &gt; 0 )) = 0"/>
      </rule>
      <rule name="product_concept_feature_requires_category" appliesto="product_concept_feature">
         <where label="WR1" expression="SIZEOF ( QUERY ( pcf &lt;* product_concept_feature |&#10;(SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',&#10;'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf)) = 0) AND &#10;(SIZEOF ( QUERY ( aga &lt;* USEDIN ( pcf , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS' ) | &#10;( aga.role.name = 'specification category member' ) AND &#10;('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF ( aga.assigned_group )))) &lt;&gt;1 ) ) ) = 0"/>
      </rule>
      <rule name="product_definition_replacement_requires_effectivity_assignment" appliesto="product_definition_relationship">
         <where label="WR1" expression="SIZEOF( QUERY( pdr &lt;* product_definition_relationship | &#10;	(pdr.name = 'definition replacement') AND &#10;	(SIZEOF( USEDIN(pdr,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))&#10;	 = 0"/>
      </rule>
      <rule name="restrict_assembly_category" appliesto="product_definition">
         <algorithm>LOCAL
  assembly_definitions: SET OF product_definition := [];
END_LOCAL;
  assembly_definitions :=  QUERY( pd &lt;* product_definition | 
    SIZEOF( QUERY( pdca &lt;* USEDIN( pd, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
    pdca.frame_of_reference.name= 'assembly definition')) &gt; 0 );</algorithm>
         <where label="WR1" expression="SIZEOF( QUERY( pd &lt;* assembly_definitions | &#10;   NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0"/>
      </rule>
      <rule name="restrict_classification_assignments" appliesto="applied_classification_assignment">
         <where label="WR1" expression="SIZEOF(QUERY(aia &lt;* applied_classification_assignment | &#10;		NOT class_assignment_is_valid(aia)))=0"/>
      </rule>
      <rule name="restrict_concept_feature_operator" appliesto="concept_feature_operator">
         <where label="WR1" expression="SIZEOF ( QUERY ( cfo &lt;* concept_feature_operator | NOT&#10;		( cfo.name IN ['and' , 'or' , 'oneof' , 'not' , 'implication'] ) ) ) = 0"/>
         <where label="WR2" expression="SIZEOF ( QUERY ( cfo &lt;* concept_feature_operator | (cfo.name = 'implication' ) AND&#10;	 ( SIZEOF ( QUERY (cfrwc &lt;* USEDIN ( cfo , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +&#10;	'CONDITIONAL_OPERATOR' ) | &#10;		SIZEOF ( QUERY ( ccf &lt;* USEDIN( cfrwc , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION' ) | &#10;		NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ccf )))) &gt;0 )) &gt;0 ))) = 0"/>
         <where label="WR3" expression="SIZEOF( QUERY (cfo &lt;* concept_feature_operator | (cfo.name = 'not')&#10;	AND (SIZEOF(QUERY(cfrwc &lt;* USEDIN(cfo, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR') | &#10;		cfrwc.related_product_concept_feature :&lt;&gt;: cfrwc.relating_product_concept_feature)) &gt;0 ))) = 0"/>
      </rule>
      <rule name="restrict_group_relationship_for_classification_hierarchy" appliesto="group_relationship">
         <where label="WR1" expression="SIZEOF( QUERY( gr &lt;* group_relationship | &#10;  (gr.name = 'class hierarchy') AND &#10;  (NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CLASS' IN TYPEOF(gr.related_group)) OR &#10;  NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CLASS' IN TYPEOF(gr.relating_group))) )) = 0"/>
      </rule>
      <rule name="restrict_group_relationship_for_specification_category" appliesto="group_relationship">
         <where label="WR1" expression="SIZEOF( QUERY( gr &lt;* group_relationship | &#10;  (gr.name = 'specification category hierarchy') AND &#10;  (NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.related_group)) &#10;  OR NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group))) )) = 0"/>
      </rule>
      <rule name="restrict_language_assignment_per_attribute" appliesto="attribute_language_assignment">
         <where label="WR1" expression="SIZEOF ( QUERY ( ala1 &lt;* attribute_language_assignment |&#10;	SIZEOF(QUERY( it &lt;* ala1.items |&#10;	   SIZEOF ( QUERY ( ala2 &lt;* USEDIN ( it ,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | &#10;		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND &#10;		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )&#10;		 )) &gt;1 &#10;	   )) &gt;0 &#10;	)) =0"/>
      </rule>
      <rule name="restrict_part_occurrence" appliesto="product_definition">
         <algorithm>LOCAL
  part_occurrences: SET OF product_definition := QUERY(pd &lt;* product_definition | 
	( pd.frame_of_reference.name = 'part occurrence' ));
END_LOCAL;</algorithm>
         <where label="WR1" expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10;	( NOT( pd.name IN &#10;['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0"/>
         <where label="WR2" expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10; 	(SIZEOF ( QUERY ( pdr &lt;* USEDIN ( pd ,&#10;'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | &#10;	pdr.name = 'definition usage' ) ) &lt;&gt;1 ) AND &#10;	( SIZEOF ( QUERY ( cd &lt;* USEDIN ( pd , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN' ) | &#10;	( cd.name = 'occurrence usage definition' ) AND &#10;	( NOT ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) &lt;&gt;1 ) ) ) = 0"/>
         <where label="WR3" expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences |  &#10;	(SIZEOF ( QUERY ( cd &lt;* USEDIN ( pd , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |&#10; 	( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND&#10; 	( SIZEOF ( USEDIN ( pd , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0"/>
         <where label="WR4" expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10;	( pd.name = 'selected instance' ) AND &#10;	NOT valid_selected_instance_representation(pd) ))=0"/>
         <where label="WR5" expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10; 	( pd.name = 'quantified instance' ) AND &#10;	( SIZEOF ( QUERY (ppd &lt;* USEDIN ( pd , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +'PROPERTY_DEFINITION.DEFINITION' ) |&#10; 	( ppd.name ='occurrence quantity' ) AND &#10;	( SIZEOF ( QUERY ( pdr &lt;*USEDIN ( ppd , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (&#10;	pdr.used_representation.name = 'quantity' ) AND &#10;	(SIZEOF ( pdr.used_representation.items ) = 1 ) AND &#10; 	(SIZEOF ( QUERY ( i &lt;* pdr.used_representation.items | &#10;	('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND&#10;	( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0"/>
         <where label="WR6" expression="SIZEOF ( QUERY ( pd &lt;* part_occurrences | &#10;	( pd.name = 'specified instance' ) AND &#10;	( SIZEOF ( QUERY (&#10;pdor &lt;* USEDIN ( pd , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | &#10;  'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0"/>
      </rule>
      <rule name="restrict_part_occurrence_category" appliesto="product_definition">
         <algorithm>LOCAL
  part_occurrences: SET OF product_definition := QUERY( pd &lt;* product_definition |(
		pd.frame_of_reference.name = 'part occurrence'));
END_LOCAL;</algorithm>
         <where label="WR1" expression="SIZEOF( QUERY( pd &lt;* part_occurrences | &#10;(SIZEOF( QUERY( prpc &lt;* USEDIN(pd.formation.of_product, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | &#10;  prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0"/>
      </rule>
      <rule name="restrict_product_definitions_for_definition_usage" appliesto="product_definition_relationship">
         <where label="WR1" expression="SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship |&#10;     ( pdr.name = 'definition usage' ) AND &#10;	( ( pdr.relating_product_definition.frame_of_reference.name&lt;&gt; 'part definition' ) OR &#10;	( pdr.related_product_definition.frame_of_reference.name&lt;&gt;'part occurrence' )))) =0"/>
      </rule>
      <rule name="restrict_product_definitions_for_part_definition_relationship" appliesto="product_definition_relationship">
         <where label="WR1" expression="SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship |&#10;     ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND &#10;	( ( pdr.relating_product_definition.frame_of_reference.name &lt;&gt;'part definition' ) OR &#10;	( pdr.related_product_definition.frame_of_reference.name &lt;&gt;'part definition' ) ) ) ) =0"/>
      </rule>
      <rule name="selected_instance_usage_requires_representation" appliesto="assembly_component_usage">
         <algorithm>LOCAL
  selected_instance_usages: SET OF assembly_component_usage := QUERY( acr &lt;* assembly_component_usage|
		(acr.name = 'selected instance usage'));
END_LOCAL;</algorithm>
         <where label="WR1" expression="SIZEOF ( QUERY ( acr &lt;* selected_instance_usages | &#10;	NOT valid_selected_instance_representation(acr) ))=0"/>
      </rule>
      <rule name="subtype_exclusive_measure_with_unit" appliesto="measure_with_unit">
         <where label="WR1" expression="SIZEOF (QUERY (mwu &lt;* measure_with_unit |&#10;       NOT (SIZEOF ([&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'ABSORBED_DOSE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'ACTIVITY_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'AREA_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'CAPACITANCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'CONDUCTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'DOSE_EQUIVALENT_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'ELECTRIC_CHARGE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'ELECTRIC_CURRENT_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'ELECTROMOTIVE_FORCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'ENERGY_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'FORCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'FREQUENCY_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'ILLUMINANCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'INDUCTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'LENGTH_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'LUMINOUS_FLUX_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'LUMINOUS_INTENSITY_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'MAGNETIC_FLUX_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'MASS_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'PLANE_ANGLE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'POWER_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'PRESSURE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'RATIO_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'RESISTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'SOLID_ANGLE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'TIME_MEASURE_WITH_UNIT',&#10;       'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +&#10;       'VOLUME_MEASURE_WITH_UNIT'] *&#10;       TYPEOF(mwu)) &lt;= 1))) = 0"/>
      </rule>
      <rule name="subtype_exclusiveness_geometric_tolerance" appliesto="geometric_tolerance">
         <where label="WR1" expression="SIZEOF(QUERY (gt &lt;* geometric_tolerance | NOT (type_check_function(gt, ['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.FLATNESS_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POSITION_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 3)))) = 0"/>
      </rule>
      <rule name="subtype_exclusiveness_representation_item" appliesto="representation_item">
         <where label="WR1" expression="SIZEOF(QUERY (cri &lt;* representation_item | NOT (type_check_function(cri,['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM','AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VALUE_REPRESENTATION_ITEM','AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0"/>
      </rule>
      <rule name="subtype_mandatory_geometric_tolerance" appliesto="geometric_tolerance">
         <where label="WR1" expression="SIZEOF(QUERY (gt &lt;* geometric_tolerance | NOT (type_check_function(gt, ['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.FLATNESS_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POSITION_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.TOTAL_RUNOUT_TOLERANCE'] , 0)))) = 0"/>
      </rule>
      <rule name="validate_dependently_instantiable_entity_data_types" appliesto="action_method_role application_context attribute_value_role axis1_placement binary_generic_expression boundary_curve bounded_curve bounded_surface cartesian_transformation_operator concept_feature_relationship concept_feature_relationship_with_condition conic elementary_surface event_occurrence_role face generic_expression generic_variable local_time loop multiple_arity_generic_expression point product_context product_definition_context_role product_definition_effectivity simple_generic_expression surface_patch topological_representation_item unary_generic_expression vertex">
         <algorithm>LOCAL
  number_of_input_instances : INTEGER;
  previous_in_chain : LIST OF GENERIC := [];
  set_of_input_types : SET OF STRING := [];
  all_instances : SET OF GENERIC := [];
END_LOCAL;

  all_instances := action_method_role + application_context + attribute_value_role + axis1_placement + binary_generic_expression + boundary_curve + bounded_curve + bounded_surface + cartesian_transformation_operator + concept_feature_relationship + concept_feature_relationship_with_condition + conic + elementary_surface + event_occurrence_role + face + generic_expression + generic_variable + local_time + loop + multiple_arity_generic_expression + point + product_context + product_definition_context_role + product_definition_effectivity + simple_generic_expression + surface_patch + topological_representation_item + unary_generic_expression + vertex;--&lt;make a union of all implicit populations of the FOR-clause&gt;
number_of_input_instances := SIZEOF(all_instances);
(* Collect all type strings of all FOR instances into one set. *)
REPEAT i:=1 TO number_of_input_instances;
  set_of_input_types := set_of_input_types + TYPEOF(all_instances[i]);
END_REPEAT;</algorithm>
         <where label="WR1" expression="dependently_instantiated(all_instances, set_of_input_types,&#10;                                previous_in_chain)"/>
      </rule>
      <function name="acyclic">
         <parameter name="arg1">
            <typename name="generic_expression"/>
         </parameter>
         <parameter name="arg2">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
	result: BOOLEAN;
END_LOCAL;

IF ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;</algorithm>
      </function>
      <function name="acyclic_curve_replica">
         <parameter name="rep">
            <typename name="curve_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_mapped_representation">
         <parameter name="parent_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="children_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    x,y : SET OF representation_item;
  END_LOCAL;
  -- Determine the subset of children_set that are mapped_items
  x := QUERY(z &lt;* children_set | 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MAPPED_ITEM'
       IN TYPEOF(z));
  -- Determine that the subset has elements
  IF SIZEOF(x) &gt; 0 THEN
    -- Check each element of the set
    REPEAT i := 1 TO HIINDEX(x);
      -- If the selected element maps a representation in the
      -- parent_set, then return false
      IF x[i]\mapped_item.mapping_source.mapped_representation
        IN parent_set THEN
        RETURN (FALSE);
      END_IF;
      -- Recursive check of the items of mapped_representation
      IF NOT acyclic_mapped_representation
        (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Determine the subset of children_set that are not
  -- mapped_items
  x := children_set - x;
  -- Determine that the subset has elements
  IF SIZEOF(x) &gt; 0 THEN
    -- For each element of the set:
    REPEAT i := 1 TO HIINDEX(x);
      -- Determine the set of representation_items referenced
      y := QUERY(z &lt;* bag_to_set( USEDIN(x[i], '')) |
           'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Recursively check for an offending mapped_item
      -- Return false for any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return true when all elements are checked and
  -- no error conditions found
  RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_point_replica">
         <parameter name="rep">
            <typename name="point_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;</algorithm>
      </function>
      <function name="acyclic_product_category_relationship">
         <parameter name="relation">
            <typename name="product_category_relationship"/>
         </parameter>
         <parameter name="children">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_category"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_product_definition_relationship">
         <parameter name="relation">
            <typename name="product_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.relating_product_definition, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_representation_relationship">
         <parameter name="relation">
            <typename name="representation_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r &lt;* bag_to_set(USEDIN(relation.rep_1, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);</algorithm>
      </function>
      <function name="acyclic_surface_replica">
         <parameter name="rep">
            <typename name="surface_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;</algorithm>
      </function>
      <function name="associated_surface">
         <parameter name="arg">
            <typename name="pcurve_or_surface"/>
         </parameter>
         <typename name="surface"/>
         <algorithm>LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PCURVE' IN TYPEOF(arg) THEN
     surf := arg.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);</algorithm>
      </function>
      <function name="bag_to_set">
         <parameter name="the_bag">
            <aggregate type="BAG" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) &gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);</algorithm>
      </function>
      <function name="base_axis">
         <parameter name="dim">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="axis1">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis2">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis3">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor &lt; 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);</algorithm>
      </function>
      <function name="boolean_choose">
         <parameter name="b">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="choice1">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <parameter name="choice2">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <builtintype type="GENERIC" typelabel="item"/>
         <algorithm>IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;</algorithm>
      </function>
      <function name="build_2axes">
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="2"/>
         <typename name="direction"/>
         <algorithm>LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);</algorithm>
      </function>
      <function name="build_axes">
         <parameter name="axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="3" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL
     d1, d2 : direction;
   END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);</algorithm>
      </function>
      <function name="categories_of_product">
         <parameter name="obj">
            <typename name="product"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="STRING"/>
         <algorithm>LOCAL
category_assignments: BAG OF product_category;
categories: SET OF STRING:=[];
i: INTEGER;
END_LOCAL;
category_assignments := USEDIN(obj, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
categories := categories + category_assignments[i].name;
END_REPEAT;
RETURN(categories);</algorithm>
      </function>
      <function name="class_assignment_is_valid">
         <parameter name="aia">
            <typename name="applied_classification_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  item: classification_item;
  role: classification_role;
END_LOCAL;

role:= aia.role;
IF ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +'CLASS_SYSTEM' IN TYPEOF(aia.assigned_class)) THEN
  IF(role.name &lt;&gt; 'class system membership') THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a class_system
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

IF ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia.assigned_class)) THEN
  IF	NOT(role.name IN ['definitional','non-definitional','']) THEN
    RETURN(FALSE); 
  END_IF;

  REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
    item:= aia.items[i];

    IF (SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a characterized_class
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;
RETURN(TRUE);</algorithm>
      </function>
      <function name="constraints_composite_curve_on_surface">
         <parameter name="c">
            <typename name="composite_curve_on_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="constraints_param_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knot_mult">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree &lt; 1) OR (up_knots &lt; 2) OR (up_cp &lt; degree) OR
         (sum &lt;&gt; (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k &lt; 1) OR (k &gt; degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] &lt; 1) OR (knots[i] &lt;= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i &lt; up_knots) AND (k &gt; degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k &gt; degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="constraints_rectangular_composite_surface">
         <parameter name="s">
            <typename name="rectangular_composite_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);</algorithm>
      </function>
      <function name="cross_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag &gt; 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;</algorithm>
      </function>
      <function name="curve_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] &lt;= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr2">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF SIZEOF(agg) &lt;= 5 THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr3">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF (SIZEOF(QUERY ( i &lt;* agg | (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) 
  AND (i\representation_item.name = 'significant number of digits')) )) = 1) OR 
((SIZEOF(QUERY ( i &lt;* agg | (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'lower limit')) )) = 1) AND 
(SIZEOF( QUERY ( i &lt;* agg | (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'upper limit')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr4">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF (SIZEOF(QUERY ( i &lt;* agg | (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'plus minus tolerance value')) )) = 1) OR 
((SIZEOF(QUERY ( i &lt;* agg | (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'lower tolerance value')) )) = 1) AND 
(SIZEOF( QUERY ( i &lt;* agg | (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'upper tolerance value')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr5">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF (SIZEOF(QUERY ( i &lt;* agg | ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) &lt;= 1) AND 
(SIZEOF(QUERY ( i &lt;* agg | ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) = 
  SIZEOF(QUERY ( i &lt;* agg | (('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'cell description'))) )) 
THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END;</algorithm>
      </function>
      <function name="dependently_instantiated">
         <parameter name="set_of_input_instances">
            <aggregate type="SET" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="set_of_input_types">
            <aggregate type="SET" lower="0" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <parameter name="previous_in_chain">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
  number_of_input_instances     : INTEGER;
  number_of_referring_instances : INTEGER;
  bag_of_referring_instances    : BAG OF GENERIC:igen := [];
  dependently_instantiated_flag : BOOLEAN;
  previous_in_chain_plus        : LIST OF GENERIC:cgen := [];
  result                        : BOOLEAN := true;
  set_of_types                  : SET OF STRING := [];
END_LOCAL;

IF EXISTS(set_of_input_instances) THEN
  number_of_input_instances := SIZEOF(set_of_input_instances);
  (* Add the declared type of bag_of_referring_instances to the set of
     types of the REFERENCEd instances for the subset comparison later.
   *)
  set_of_input_types := set_of_input_types + 'GENERIC';
  REPEAT i:=1 TO number_of_input_instances;
    (* Determine all references to the current input instance. *)
    bag_of_referring_instances := USEDIN (set_of_input_instances[i] , '');
    IF EXISTS(bag_of_referring_instances) THEN
      number_of_referring_instances := SIZEOF(bag_of_referring_instances);
      dependently_instantiated_flag := false;
      REPEAT j:=1 TO number_of_referring_instances;
        (* Determine the type strings of the current referencing instance.
         *)
        set_of_types := TYPEOF(bag_of_referring_instances[j]);
        (* If the referencing instance is of one of the types of the
           only dependently instantiable select items, the current input
           instance may still be invalidly instantiated.
           Otherwise it is OK, and the next input instance is tested.
         *)
        IF set_of_types &lt;= set_of_input_types THEN -- subset operator
          (* The referring instance is of one of the restricted types.
             However, it may itself be referred to by a valid instance;
             then also the current instance would be valid.
             Thus, call this function recursively with the referring
             instance as input.
             To avoid an infinite loop in case a set of instances
             reference each other in a closed loop, test first whether
             the current referencing instance is in the list of
             previously processed chain members.
           *)
          IF NOT (bag_of_referring_instances[j] IN previous_in_chain) THEN
            previous_in_chain_plus := previous_in_chain +
            set_of_input_instances[i];
            IF dependently_instantiated([bag_of_referring_instances[j]],
              set_of_input_types,
              previous_in_chain_plus) THEN
              dependently_instantiated_flag := true;
              ESCAPE; -- dependently instantiated; next input instance
            ELSE
              (* Not dependently instantiated: go to next referring
              instance. *)
              SKIP;
            END_IF;
          END_IF;
        ELSE
          dependently_instantiated_flag := true;
          ESCAPE; -- dependently instantiated; take next input instance
        END_IF;
      END_REPEAT;
      IF NOT dependently_instantiated_flag THEN
        RETURN(false);
      END_IF;
    ELSE
      RETURN(false); -- not referenced at all =&gt; invalidly instantiated
    END_IF;
  END_REPEAT;
ELSE
  RETURN(false); -- no input
END_IF;

RETURN(true);</algorithm>
      </function>
      <function name="derive_dimensional_exponents">
         <parameter name="x">
            <typename name="unit"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>LOCAL
    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  END_LOCAL;

  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
      result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
      result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
      result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
      result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
      result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);</algorithm>
      </function>
      <function name="dimension_of">
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <typename name="dimension_count"/>
         <algorithm>LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty since this is required by WR1 of
  -- representation_item.
    y := x[1].context_of_items;
    dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);</algorithm>
      </function>
      <function name="dimensions_for_si_unit">
         <parameter name="n">
            <typename name="si_unit_name"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>CASE n OF
    metre          : RETURN (dimensional_exponents
                          (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram           : RETURN (dimensional_exponents
                         (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second         : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin         : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole           : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela        : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    radian         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian      : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    hertz          : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton         : RETURN (dimensional_exponents
                         (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    pascal         : RETURN (dimensional_exponents
                         (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    joule          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb        : RETURN (dimensional_exponents
                         (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
    volt           : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad          : RETURN (dimensional_exponents
                         (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
    ohm            : RETURN (dimensional_exponents
                         (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens        : RETURN (dimensional_exponents
                         (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
    weber          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    tesla          : RETURN (dimensional_exponents
                         (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
    henry          : RETURN (dimensional_exponents
                         (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
    degree_Celsius : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    lumen          : RETURN (dimensional_exponents
                         (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux            : RETURN (dimensional_exponents
                         (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel      : RETURN (dimensional_exponents
                         (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    gray           : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert        : RETURN (dimensional_exponents
                         (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    OTHERWISE      : RETURN (?);
  END_CASE;</algorithm>
      </function>
      <function name="dot_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim &lt;&gt; arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);</algorithm>
      </function>
      <function name="first_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios &lt;&gt; [1.0,0.0,0.0]) AND
          (z.direction_ratios &lt;&gt; [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim &lt;&gt; 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);</algorithm>
      </function>
      <function name="get_basis_surface">
         <parameter name="c">
            <typename name="curve_on_surface"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="2"/>
         <typename name="surface"/>
         <algorithm>LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n &gt; 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);</algorithm>
      </function>
      <function name="get_description_value">
         <parameter name="obj">
            <typename name="description_attribute_select"/>
         </parameter>
         <typename name="text"/>
         <algorithm>LOCAL
    description_bag : BAG OF description_attribute := (USEDIN(obj, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
  END_LOCAL;

  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;</algorithm>
      </function>
      <function name="get_id_value">
         <parameter name="obj">
            <typename name="id_attribute_select"/>
         </parameter>
         <typename name="identifier"/>
         <algorithm>LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
END_LOCAL;
IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
ELSE
      RETURN (?);
END_IF;</algorithm>
      </function>
      <function name="get_name_value">
         <parameter name="obj">
            <typename name="name_attribute_select"/>
         </parameter>
         <typename name="label"/>
         <algorithm>LOCAL
    name_bag : BAG OF name_attribute := (USEDIN(obj, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
  END_LOCAL;

  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;</algorithm>
      </function>
      <function name="get_role">
         <parameter name="obj">
            <typename name="role_select"/>
         </parameter>
         <typename name="object_role"/>
         <algorithm>LOCAL
    role_bag : BAG OF role_association := (USEDIN(obj, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
  END_LOCAL;

  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;</algorithm>
      </function>
      <function name="get_shape_aspect_property_definition_representations">
         <parameter name="s_a_instance">
            <typename name="shape_aspect"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="property_definition_representation"/>
         <algorithm>LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [] ;
END_LOCAL;
pd_set := bag_to_set(USEDIN(s_a_instance, 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) &lt; 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + (QUERY(pdr &lt;* USEDIN(pd_set[i], 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION') |
'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
END_REPEAT;
RETURN (pdr_set);</algorithm>
      </function>
      <function name="is_acyclic">
         <parameter name="arg">
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>RETURN (acyclic (arg, []));</algorithm>
      </function>
      <function name="item_in_context">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <parameter name="cntxt">
            <typename name="representation_context"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
    y : BAG OF representation_item;
  END_LOCAL;
  -- If there is one or more representation using both the item
  -- and cntxt return true.
  IF SIZEOF(USEDIN(item,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context) &gt; 0 THEN
    RETURN (TRUE);
    -- Determine the bag of representation_items that reference
    -- item
    ELSE y := QUERY(z &lt;* USEDIN (item , '') |
           'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
      -- Ensure that the bag is not empty
      IF SIZEOF(y) &gt; 0 THEN
      -- For each element in the bag
      REPEAT i := 1 TO HIINDEX(y);
        -- Check to see it is an item in the input cntxt.
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  -- Return false when all possible branches have been checked
  -- with no success.
  RETURN (FALSE);</algorithm>
      </function>
      <function name="leap_year">
         <parameter name="year">
            <typename name="year_number"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ((((year MOD 4) = 0) AND ((year MOD 100) &lt;&gt; 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;</algorithm>
      </function>
      <function name="list_face_loops">
         <parameter name="f">
            <typename name="face"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);</algorithm>
      </function>
      <function name="list_to_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n &lt;&gt; (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;</algorithm>
      </function>
      <function name="list_to_set">
         <parameter name="l">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);</algorithm>
      </function>
      <function name="make_array_of_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) &lt;&gt; SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) &lt;&gt; SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) &lt;&gt; SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);</algorithm>
      </function>
      <function name="mixed_loop_type_set">
         <parameter name="l">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="loop"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) &lt;= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POLY_LOOP' IN TYPEOF(l[i])) &lt;&gt; poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);</algorithm>
      </function>
      <function name="normalise">
         <parameter name="arg">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector_or_direction"/>
         <algorithm>LOCAL
     ndim   : INTEGER;
     v      : direction;
     result : vector_or_direction;
     vec    : vector;
     mag    : REAL;
   END_LOCAL;
   
   IF NOT EXISTS (arg) THEN
     result := ?;
 (* When function is called with invalid data a NULL result is returned *)
   ELSE
     ndim := arg.dim;
     IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);
         IF arg.magnitude = 0.0 THEN
           RETURN(?);
         ELSE
          vec := dummy_gri || vector (v, 1.0);
         END_IF;
       END;
     ELSE
       v := dummy_gri || direction (arg.direction_ratios);
     END_IF;
     mag := 0.0;
     REPEAT  i := 1 TO ndim;
       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
     END_REPEAT;
     IF mag &gt; 0.0 THEN
       mag := SQRT(mag);
       REPEAT  i := 1 TO ndim;
         v.direction_ratios[i] := v.direction_ratios[i]/mag;
       END_REPEAT;
       IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
         vec.orientation := v;
         result := vec;
       ELSE
         result := v;
       END_IF;
     ELSE
       RETURN(?);
     END_IF;
   END_IF;
   RETURN (result);</algorithm>
      </function>
      <function name="orthogonal_complement">
         <parameter name="vec">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim &lt;&gt; 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;</algorithm>
      </function>
      <function name="path_head_to_tail">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);</algorithm>
      </function>
      <function name="scalar_times_vector">
         <parameter name="scalar">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="vec">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
     v      : direction;
     mag    : REAL;
     result : vector;
   END_LOCAL;

   IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
     RETURN (?) ;
    ELSE
     IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VECTOR' IN TYPEOF (vec) THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);
       mag := scalar * vec.magnitude;
     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);
       mag := scalar;
     END_IF;
     IF (mag &lt; 0.0 ) THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);
         v.direction_ratios[i] := -v.direction_ratios[i];
       END_REPEAT;
       mag := -mag;
     END_IF;
     result := dummy_gri || vector(normalise(v), mag);
   END_IF;
   RETURN (result);</algorithm>
      </function>
      <function name="second_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="x_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);</algorithm>
      </function>
      <function name="surface_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] &lt;= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);</algorithm>
      </function>
      <function name="type_check_function">
         <parameter name="the_type">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="sub_names">
            <aggregate type="SET" lower="0" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <parameter name="criterion">
            <builtintype type="INTEGER"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0&lt;= criterion &lt;=3})) OR
(SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
ELSE
  CASE criterion OF
       0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) &gt; 0);
       1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
       2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
       3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) &lt;= 1);
  END_CASE;
END_IF;</algorithm>
      </function>
      <function name="using_items">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <parameter name="checked_items">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="founded_item_select"/>
         <algorithm>LOCAL
    new_check_items    : SET OF founded_item_select;
    result_items       : SET OF founded_item_select;
    next_items         : SET OF founded_item_select;
  END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  -- Find the set of representation_items or founded_items
  -- in which item is used directly.
  next_items := QUERY(z &lt;* bag_to_set( USEDIN(item , '')) |
    ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
    ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.FOUNDED_ITEM'        IN TYPEOF(z)));
  -- If the set of next_items is not empty;
  IF SIZEOF(next_items) &gt; 0 THEN
    -- For each element in the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);
      -- Check for loop in data model, i.e. one of the next_items
      -- occurred earlier in the set of check_items;
      IF NOT(next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  -- return the set of representation_items or founded_items
  -- in which the input item is used directly and indirectly.
  RETURN (result_items);</algorithm>
      </function>
      <function name="using_representations">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="representation"/>
         <algorithm>LOCAL
    results            : SET OF representation;
    result_bag         : BAG OF representation;
    intermediate_items : SET OF founded_item_select;
  END_LOCAL;
  -- Find the representations in which the item is used and add to the
  -- results set.
  results := [];
  result_bag :=
USEDIN(item,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) &gt; 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  -- Find all representation_items or founded_items
  -- by which item is referenced directly or indirectly.
  intermediate_items := using_items(item,[]);
  -- If the set of intermediate items is not empty;
  IF SIZEOF(intermediate_items) &gt; 0 THEN
    -- For each element in the set, add the
    -- representations of that element.
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i],
                    'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) &gt; 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  -- Return the set of representation in which the input item is
  -- used directly and indirectly (through intervening
  -- representation_items or founded items).
  RETURN (results);</algorithm>
      </function>
      <function name="valid_calendar_date">
         <parameter name="date">
            <typename name="calendar_date"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>CASE date.month_component OF
    1  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 &lt;= date.day_component &lt;= 29 });
           ELSE
             RETURN({ 1 &lt;= date.day_component &lt;= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    4  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    5  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    6  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    7  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    8  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    9  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    10 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
    11 : RETURN({ 1 &lt;= date.day_component &lt;= 30 });
    12 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });
  END_CASE;
  RETURN (FALSE);</algorithm>
      </function>
      <function name="valid_datum_target_parameters">
         <parameter name="pdf">
            <typename name="placed_datum_target_feature"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

rep_set : SET OF representation := [] ;

parameter_representations: SET OF representation;
END_LOCAL;


REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
rep_set := rep_set + pdf.representation_associations[i].used_representation;
END_REPEAT;
 
parameter_representations := QUERY(rep &lt;* rep_set |
('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
TYPEOF(rep)));


IF (SIZEOF( QUERY( srwp &lt;* parameter_representations |
          (SIZEOF( QUERY( i &lt;* srwp.items |
          (i.name='orientation') AND
          ('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PLACEMENT' IN TYPEOF(i)))) = 1))) &lt;&gt; 1) THEN
   RETURN(FALSE);
END_IF;

CASE pdf\shape_aspect.description OF
'point': RETURN(SIZEOF(QUERY( srwp &lt;* parameter_representations |
              (SIZEOF(srwp.items) = 1))) = 1);

'circle': RETURN((SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF(srwp.items) = 2))) = 1) AND
             (SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF( QUERY( i &lt;* srwp.items |
                (i.name='target diameter') AND
                (SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		   'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1));

'line': RETURN(SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF( QUERY( i &lt;* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1);

'rectangle': RETURN((SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF(srwp.items)= 3))) = 1) AND
             (SIZEOF( QUERY( srwp &lt;* parameter_representations |
              (SIZEOF( QUERY( i &lt;* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2))) = 1))) = 1) AND
              (SIZEOF( QUERY( srwp &lt;* parameter_representations |
               (SIZEOF( QUERY( i &lt;* srwp.items |
                 (i.name='target width') AND
                 (SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM',
 		'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                  ) = 2))) = 1) )) = 1));
OTHERWISE : RETURN(FALSE);
END_CASE;</algorithm>
      </function>
      <function name="valid_measure_value">
         <parameter name="m">
            <typename name="measure_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF ('REAL' IN TYPEOF (m)) THEN
  RETURN (m &gt; 0.0);
  ELSE
    IF ('INTEGER' IN TYPEOF (m)) THEN
    RETURN (m &gt; 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;</algorithm>
      </function>
      <function name="valid_selected_instance_representation">
         <parameter name="pd">
            <typename name="product_definition_or_assembly_relationship"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL
  properties: SET OF property_definition := bag_to_set(QUERY( prd&lt;* USEDIN ( pd ,'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PROPERTY_DEFINITION.DEFINITION' ) | 
 (prd.name = 'occurrence selection' )));

  property_definition_representations: SET OF property_definition_representation := bag_to_set(QUERY ( pdr &lt;* USEDIN ( properties[1] , 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	( pdr.used_representation.name = 'selection criteria' )));

  selected_representation: representation;
END_LOCAL;

IF (SIZEOF( properties)&lt;&gt;1) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF(property_definition_representations)&lt;&gt;1) THEN
	RETURN(FALSE);
END_IF;

selected_representation := property_definition_representations[1]\property_definition_representation.used_representation;

IF (SIZEOF(selected_representation\representation.items) &lt;1) OR (SIZEOF(selected_representation\representation.items) &gt;2) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
	( SIZEOF (['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' ,
			'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
 	( i.name = 'selection quantity' ))) &lt;&gt; 1 ) THEN
	RETURN(FALSE);
END_IF;

IF (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
	( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	( i.name = 'selection control' )))&gt; 1) THEN
	RETURN(FALSE);
END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
IF (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
	( 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
 	( i.name = 'selection control' ) ))= 0) AND 
   (SIZEOF ( QUERY ( i &lt;* selected_representation\representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.QUALIFIED_REPRESENTATION_ITEM' ,
		'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) &gt; 0 ) THEN
	RETURN(FALSE);
END_IF;
	
RETURN(TRUE);</algorithm>
      </function>
      <function name="valid_time">
         <parameter name="time">
            <typename name="local_time"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;</algorithm>
      </function>
      <function name="valid_units">
         <parameter name="m">
            <typename name="measure_with_unit"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF ( m.value_component ) THEN
    IF derive_dimensional_exponents ( m.unit_component ) &lt;&gt;
       dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);</algorithm>
      </function>
      <function name="value_range_wr1">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 &lt;* agg | (
'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
(i1)))) = 2) OR
(SIZEOF(QUERY (i2 &lt;* agg | (
'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF
(i2)))) = 2)) THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;</algorithm>
      </function>
      <function name="value_range_wr2">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
IF (SIZEOF(QUERY (i &lt;* agg | (i.name = 'upper limit'))) = 1)
AND (SIZEOF(QUERY (i &lt;* agg | (i.name = 'lower limit'))) = 1)
THEN
RETURN(TRUE);
ELSE
RETURN(FALSE);
END_IF;
END;</algorithm>
      </function>
      <function name="value_range_wr3">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
IF (SIZEOF(QUERY(i1 &lt;* agg |
('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
(SIZEOF (QUERY (i2 &lt;* agg |
('AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
(i1 :&lt;&gt;: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
THEN
RETURN (TRUE);
ELSE
RETURN (FALSE);
END_IF;
END;</algorithm>
      </function>
      <function name="vector_difference">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim &lt;&gt; arg2.dim)
       THEN
     RETURN (?) ;
    ELSE
     BEGIN
       IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1.magnitude;
         vec1 := arg1.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'AP210_DATUM_DIFFERENCE_BASED_MODEL_DEFINITION_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2.magnitude;
         vec2 := arg2.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag &gt; 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);</algorithm>
      </function>
   </schema>
</express>
