(*
// $Id$
*) 
(*
ISO TC184/SC4/WG12 N1157 - ISO/TS 10303-1047 Activity - EXPRESS MIM
*) 


SCHEMA Activity_mim;

USE FROM action_schema   -- ISO 10303-41
  (action,
   action_relationship,
   action_status,
   executed_action); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   object_role); 

USE FROM management_resources_schema   -- ISO 10303-41
  (action_assignment); 


TYPE action_items = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_action_assignment
  SUBTYPE OF (action_assignment);
  items : SET[1:?] OF action_items;
END_ENTITY;

END_SCHEMA;  -- Activity_mim
(*
 ISO TC184/SC4/WG12 N1163 - ISO/TS 10303-1049 Activity method - EXPRESS MIM
*)

SCHEMA Activity_method_mim;

USE FROM action_schema    -- ISO 10303-41
(action_method );

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N2999 - ISO/TS 10303-1249 Activity method assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2307
*) 


SCHEMA Activity_method_assignment_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method_relationship); 

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM management_resources_schema   -- ISO 10303-41
  (action_method_assignment); 


TYPE action_method_items = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_action_method_assignment
  SUBTYPE OF (action_method_assignment);
  items : SET[1:?] OF action_method_items;
END_ENTITY;

END_SCHEMA;  -- Activity_method_assignment_mim

(*
 ISO TC184/SC4/WG12 N6858 - ISO/TS 10303-1514 Advanced boundary representation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5273
*)

SCHEMA Advanced_boundary_representation_mim;

USE FROM Topologically_bounded_surface_mim; --ISO/TS 10303-1511:2004
USE FROM Solid_model_mim;
USE FROM aic_advanced_brep; --ISO/TS 10303-514

END_SCHEMA;

(*
ISO TC184/SC4/WG12 N7102 - ISO/TS 10303-1025 Alias identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5276
*)

SCHEMA Alias_identification_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021


TYPE aliasable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item;
END_TYPE; 

END_SCHEMA;  -- Alias_identification_mim
(*
   ISO TC184/SC4/WG12 N6271 - ISO/TS 10303-1601 Altered package - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5555
*)


SCHEMA Altered_package_mim;
	USE FROM Package_mim;	-- ISO/TS 10303-1707

 	TYPE ap_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
		(package);
	END_TYPE;

(** Needed by mapping *)
TYPE ap_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (package_terminal);
END_TYPE; 

ENTITY altered_package_terminal
  ABSTRACT SUPERTYPE OF ((shape_formed_terminal ANDOR
      surface_prepped_terminal) ANDOR length_trimmed_terminal)
   SUBTYPE OF (package_terminal);
END_ENTITY;

ENTITY length_trimmed_terminal
   SUBTYPE OF (altered_package_terminal);
END_ENTITY;

ENTITY shape_formed_terminal
   SUBTYPE OF (altered_package_terminal);
END_ENTITY;

ENTITY surface_prepped_terminal
   SUBTYPE OF (altered_package_terminal);
END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N3829 - ISO/TS 10303-1602 Altered part - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3286
*)


SCHEMA Altered_part_mim;
	USE FROM Altered_package_mim;	-- ISO/TS 10303-1601
	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N5279 - ISO/TS 10303-1109 Alternative solution - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4929
*)

SCHEMA Alternative_solution_mim;

USE FROM Person_organization_assignment_mim;
USE FROM Product_occurrence_mim; -- ISO/TS 10303-1063
USE FROM Functional_breakdown_mim;  -- ISO/TS 10303-1216
USE FROM Physical_breakdown_mim;

USE FROM qualified_measure_schema(
	measure_representation_item);
USE FROM measure_schema(
	ratio_measure_with_unit);

  TYPE organization_item_solution = SELECT BASED_ON organization_item WITH (product_definition_formation);
  END_TYPE;

  RULE alternative_solution_requires_solution_definition FOR (product_definition_formation);
    LOCAL
      solution_versions: SET OF product_definition_formation := [];
    END_LOCAL;
    solution_versions :=  QUERY( pdf <* product_definition_formation |
	  SIZEOF( QUERY( prpc <* USEDIN(pdf.of_product, 'ALTERNATIVE_SOLUTION_MIM' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
      prpc.name = 'alternative solution')) = 1);
    WHERE 
      WR1: SIZEOF( QUERY( pdf <* solution_versions |
        SIZEOF( QUERY( pd <* USEDIN(pdf, 'ALTERNATIVE_SOLUTION_MIM' + '.PRODUCT_DEFINITION.FORMATION') | 
        pd.frame_of_reference.name = 'alternative definition')) <> 1))= 0; 
  END_RULE;

  RULE restrict_alternative_definition FOR (product_definition);
    LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd <* product_definition |
	 (pd.frame_of_reference.name = 'alternative definition'));
    WHERE
      WR1: SIZEOF ( QUERY ( pd <* solution_definitions | 
	    ( SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
	    'ALTERNATIVE_SOLUTION_MIM' + '.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	    pdr.name = 'solution alternative definition' ) ) <>1 ) ) ) = 0;
      WR2: SIZEOF ( QUERY ( pd <* solution_definitions | 
	    NOT ( pd.name IN ['technical' , 'supplier' , 'technical supplier' , ''] ) ) ) = 0;
      WR3: SIZEOF ( QUERY ( pd <* solution_definitions | 
	    ( pd.name IN ['supplier' , 'technical supplier'] ) AND (
	    SIZEOF ( QUERY ( aoa <* USEDIN ( pd.formation ,
	    'ALTERNATIVE_SOLUTION_MIM' + '.APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | 
	    aoa.role.name = 'supplier' )) <>1 ) )) = 0;
  END_RULE; 

  RULE restrict_product_definitions_for_base_element FOR
    (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
       ( pdr. name = 'solution alternative definition' ) AND 
       ( NOT( pdr. relating_product_definition.frame_of_reference.name
        IN [ 'alternative definition' , 'functional definition' , 'conceptual definition' ] ) OR 
       ( pdr.related_product_definition.frame_of_reference.name<>'alternative definition' ) ) ) ) =0;
  END_RULE;

  RULE solution_definition_requires_solution_category FOR (product_definition);
    LOCAL
      solution_definitions: SET OF product_definition := [];
    END_LOCAL;
      solution_definitions :=  QUERY( pd <* product_definition |
        (pd.frame_of_reference.name = 'alternative definition'));
    WHERE
      WR1: SIZEOF( QUERY( pd <* solution_definitions | 
        (SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'ALTERNATIVE_SOLUTION_MIM' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
	     prpc.name = 'alternative solution')) = 0 ) )) = 0;
  END_RULE;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6274 - ISO/TS 10303-1603 Analytical model - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5558
*)


SCHEMA Analytical_model_mim;

USE FROM Model_parameter_mim;	-- ISO/TS 10303-1703
USE FROM Software_mim;	-- ISO/TS 10303-1746
USE FROM Document_structure_mim;	-- ISO/TS 10303-1124
USE FROM Product_view_definition_relationship_mim;	-- ISO/TS 10303-1041	
USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 

USE FROM date_time_schema
	(date_time_role,
	date_role);

  TYPE am_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (analytical_model_definition);
  END_TYPE; 
	
  TYPE am_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
    (digital_analytical_model_vector_port);
  END_TYPE;
  
  TYPE am_parameter_assignment_select = SELECT BASED_ON parameter_assignment_select WITH
    (analytical_model_parameter);
  END_TYPE;
	
  ENTITY across_port_variable
    SUBTYPE OF (port_variable);
  END_ENTITY;

  ENTITY analog_analytical_model_port
    SUBTYPE OF (analytical_model_port);
  END_ENTITY;

  ENTITY analog_port_variable 
    SUBTYPE OF (representation, representation_item);
  END_ENTITY;

  ENTITY analytical_model_definition
    SUBTYPE OF (product_definition);
  END_ENTITY;

  ENTITY analytical_model_make_from_relationship
    SUBTYPE OF (product_definition_relationship);
      SELF\product_definition_relationship.relating_product_definition : analytical_model_definition;
      SELF\product_definition_relationship.related_product_definition  : analytical_model_definition;
    UNIQUE
      UR1: SELF\product_definition_relationship.relating_product_definition, 
        SELF\product_definition_relationship.related_product_definition;
  END_ENTITY;

  ENTITY analytical_model_parameter 
    SUBTYPE OF (property_definition);
  END_ENTITY;

  ENTITY analytical_model_port
    SUBTYPE OF(property_definition, property_definition_representation, representation);
    DERIVE
      SELF\property_definition_representation.definition : property_definition :=SELF;
      SELF\property_definition_representation.used_representation : representation := SELF;
  END_ENTITY;

  ENTITY analytical_model_port_assignment
    SUBTYPE OF (property_definition_representation, representation_relationship);
      SELF\property_definition_representation.used_representation : analytical_model_port;
      SELF\representation_relationship.rep_1 : analytical_representation;
    DERIVE  
      SELF\representation_relationship.rep_2 : analytical_model_port := SELF\property_definition_representation.used_representation;
  END_ENTITY;

  ENTITY analytical_model_scalar_port
    SUBTYPE OF (analytical_model_vector_port);
  END_ENTITY;

  ENTITY analytical_model_vector_port
    SUBTYPE OF (analytical_model_port, compound_representation_item);
  END_ENTITY;

  ENTITY analytical_representation
    SUBTYPE OF (representation);
    UNIQUE
      UR1: SELF\representation.name;
  END_ENTITY;

  ENTITY digital_analytical_model_port
    SUBTYPE OF (analytical_model_port);
  END_ENTITY;

  ENTITY digital_analytical_model_scalar_port
    SUBTYPE OF (digital_analytical_model_vector_port, analytical_model_scalar_port);
  END_ENTITY;

  ENTITY digital_analytical_model_vector_port
    SUBTYPE OF (analytical_model_vector_port);
  END_ENTITY;

  ENTITY make_from_model_port_relationship
    SUBTYPE OF (representation, representation_relationship);
      SELF\representation_relationship.rep_1 : analytical_model_port;
      SELF\representation_relationship.rep_2 : analytical_model_port;
    UNIQUE
      UR1: SELF\representation_relationship.rep_1, 
        SELF\representation_relationship.rep_2;
    WHERE
      WR1: rep_1 :<>: rep_2;
  END_ENTITY;

  ENTITY port_variable
    SUPERTYPE OF (ONEOF(across_port_variable, through_port_variable, transform_port_variable))
    SUBTYPE OF (representation, representation_item);
  END_ENTITY;

  ENTITY through_port_variable
    SUBTYPE OF (port_variable);
  END_ENTITY;
	
  ENTITY transform_port_variable
    SUBTYPE OF (port_variable);
  END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG3 N2600 - ISO/TS 10303-410 AP210 electronic assembly interconnect and packaging design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG3 N1639
*)


SCHEMA Ap210_electronic_assembly_interconnect_and_packaging_design_mim;

	USE FROM Ap242_managed_model_based_3d_engineering_mim; 	-- ISO/TS 10303-442
		
	USE FROM Assembly_2d_shape_mim;	-- ISO/TS 10303-1632
	USE FROM Assembly_3d_shape_mim;	-- ISO/TS 10303-1633
	USE FROM Assembly_module_with_cable_component_2d_mim;	-- ISO/TS 10303-1638
	USE FROM Assembly_module_with_cable_component_3d_mim;	-- ISO/TS 10303-1639
	USE FROM Assembly_module_with_macro_component_mim;	-- ISO/TS 10303-1640
	USE FROM Assembly_physical_requirement_allocation_mim;	-- ISO/TS 10303-1648
	USE FROM Connectivity_allocation_to_physical_network_mim;	-- ISO/TS 10303-1658
	USE FROM Datum_difference_based_model_mim;	-- ISO/TS 10303-1660
	USE FROM Design_specific_assignment_to_assembly_usage_view_mim;	-- ISO/TS 10303-1662
	USE FROM Design_specific_assignment_to_interconnect_usage_view_mim;	-- ISO/TS 10303-1663
	USE FROM Device_marking_mim;	-- ISO/TS 10303-1664
	USE FROM Electrical_network_definition_mim;	-- ISO/TS 10303-1665
	USE FROM Fabrication_requirement_mim;	-- ISO/TS 10303-1669
	USE FROM Functional_decomposition_to_assembly_design_mim;	-- ISO/TS 10303-1675
	USE FROM Functional_decomposition_to_interconnect_design_mim;	-- ISO/TS 10303-1677
	USE FROM Functional_unit_requirement_allocation_mim;	-- ISO/TS 10303-1680
	USE FROM Interconnect_2d_shape_mim;	-- ISO/TS 10303-1682
	USE FROM Interconnect_module_to_assembly_module_relationship_mim;	-- ISO/TS 10303-1685
	USE FROM Interconnect_non_planar_shape_mim;	-- ISO/TS 10303-1688	
	USE FROM Interconnect_placement_requirements_mim;	-- ISO/TS 10303-1690
	USE FROM Layered_interconnect_module_2d_design_mim;	-- ISO/TS 10303-1695
	USE FROM Layered_interconnect_module_3d_design_mim;	-- ISO/TS 10303-1696
	USE FROM Layout_macro_definition_mim;	-- ISO/TS 10303-1701
	USE FROM Packaged_part_white_box_model_mim;	-- ISO/TS 10303-1709
	USE FROM Part_feature_grouping_mim;	-- ISO/TS 10303-1713
	USE FROM Physical_node_requirement_to_implementing_component_allocation_mim;	-- ISO/TS 10303-1723
	USE FROM Physical_unit_interconnect_definition_mim;	-- ISO/TS 10303-1729
	USE FROM Pre_defined_datum_symbol_mim;	-- ISO/TS 10303-1734
	USE FROM Sequential_laminate_assembly_design_mim;	-- ISO/TS 10303-1741
	USE FROM Test_requirement_allocation_mim;	-- ISO/TS 10303-1751
	USE FROM Thermal_network_definition_mim;	-- ISO/TS 10303-1752
	USE FROM Via_component_mim;	-- ISO/TS 10303-1754
	USE FROM Interconnect_physical_requirement_allocation_mim; -- ISO/TS 10303-1689
--	USE FROM Schematic_symbol_mim; -- in development
	
	REFERENCE FROM support_resource_schema(bag_to_set);

    USE FROM geometry_schema(offset_curve_2d);

SUBTYPE_CONSTRAINT aeaiapd_component_terminal_subtypes FOR physical_component_terminal;         
  (ONEOF(assembly_module_macro_component_join_terminal,
        interconnect_module_macro_component_join_terminal));
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT part_terminal_subtypes FOR shape_aspect; 
  ONEOF (minimally_defined_bare_die_terminal, -- *lam*
         assembly_module_terminal, -- *lam*
         cable_terminal, -- *lam*
         interconnect_module_terminal, -- *layered interconnect*
         packaged_part_terminal); -- *lam*
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT physical_unit_subtypes FOR physical_unit;         
 (ONEOF (bare_die, 
          package, 
          packaged_part, 
          assembly_module_design_view, 
          interconnect_module_design_view));
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT aeaiapd_shape_definition_3d_intersection_subtypes FOR shape_definition_3d_intersection;         
  (ONEOF (edge_segment_cross_section,
              pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship));
END_SUBTYPE_CONSTRAINT;        

	SUBTYPE_CONSTRAINT packaged_part_subtypes FOR packaged_part; 
	    (ONEOF (minimally_defined_connector, 
	 	packaged_connector)); 
	END_SUBTYPE_CONSTRAINT;

	SUBTYPE_CONSTRAINT ap210_apd_physical_component_subtypes FOR physical_component;         
	    ONEOF (
        assembly_module_component,
        assembly_module_macro_component,
        bare_die_component,
	    cable_component,
        interconnect_module_component,
        interconnect_module_macro_component, 
	    packaged_component,
        routed_interconnect_component, 
		routed_physical_component,
        sequential_laminate_stackup_component);    
	END_SUBTYPE_CONSTRAINT;

	(** It most likely should be in Assembly_module_design_view CC *)
	SUBTYPE_CONSTRAINT part_usage_view_subtypes FOR physical_unit;  
	    ONEOF (package,
		 bare_die,
		 cable_usage_view,
		 packaged_part);
	END_SUBTYPE_CONSTRAINT;

TYPE ap210_change_management_object = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON change_management_object WITH 
     (action,
      alternate_product_relationship,
      applied_approval_assignment,
      applied_date_and_time_assignment,
      applied_document_reference,
      applied_group_assignment,
      approval,
      approval_status,
      certification,
      characterized_object,
      composite_curve_segment,
      configuration_effectivity,
      configuration_item,
      contract,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      curve_style_parameters_representation,
      date,
      design_composition_path,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style_hatching,
      fill_area_style_tiles,
      func,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      layer_connection_point,
      material_designation,
      measure_with_unit,
      organization,
      operational_requirement_relationship,
--      requirement_view_definition_relationship,
      person,
      person_and_organization,
      plus_minus_tolerance,
      pre_defined_item,
      presentation_style_assignment,
      product,
      product_concept,
      product_definition,
      product_definition_formation,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      reference_composition_path,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
--      runout_zone_orientation,
      security_classification,
      shape_aspect,
      shape_aspect_relationship,
      tolerance_value,
      tolerance_zone_form,
      versioned_action_request,
      action_directive,
	analog_port_variable,
	applied_external_identification_assignment,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
--	auxiliary_characteristic_dimension_representation,
	assembly_component,
	assembly_component_usage,
	assembly_component_usage_substitute,
	assembly_joint,
	assembly_group_component_definition_placement_link,
	assembly_bond_definition,
	analytical_representation,
	analytical_model_port_assignment,
	analytical_model_port,
	analytical_model_make_from_relationship,
	analytical_model_definition,
	applied_identification_assignment,
	bus_element_link,
	bus_structural_definition,
	calendar_date,
	complex_clause,
	component_2d_location,
	component_3d_location,
	component_definition,
	component_feature,
	component_feature_relationship,
	component_functional_terminal,
	component_functional_unit,
	component_terminal,
	composite_signal_property_relationship,
	connection_zone_map_identification,
	connection_zone_interface_plane_relationship,
	conductive_interconnect_element_terminal_link,
	connector_based_interconnect_definition,
	range_characteristic,
	date_and_time,
	datum,
	datum_difference_functional_unit_usage_view_terminal_assignment,
	descriptive_representation_item,
	device_terminal_map,
	dimensional_location,
	direct_stratum_component_join_implementation,
	direction,
	effectivity,
	evaluated_characteristic,
	externally_defined_curve_font,
	externally_defined_hatch_style,
    draughting_pre_defined_text_font,
    externally_defined_text_font,
    text_font,
	externally_defined_tile_style,
	fabrication_joint,
	frozen_assignment,
	functional_specification,
	functional_unit_terminal_definition,
	functional_terminal_group,
	general_property_relationship,
	geometric_representation_context,
	geometric_representation_item,
--	geometric_tolerance_group,
	group_product_definition,
	group_shape_aspect,
	item_defined_transformation,
	interface_mounted_join,
	join_shape_aspect,
	layout_junction,
	linear_array_component_definition_link,
	make_from_connectivity_relationship,
	make_from_feature_relationship,
	make_from_usage_option,
	mapped_item,
	measure_qualification,
	model_parameter,
	network_node_definition,
	packaged_connector_terminal_relationship,
	parameter_assignment_override,
	parameter_assignment,
	part_connected_terminals_definition,
	passage_technology,
	physical_connectivity_definition,
	physical_connectivity_element,
	physical_network,
	physical_node_requirement_to_implementing_component_allocation,
	plated_inter_stratum_feature,
	product_category,
	product_definition_with_associated_documents,
	product_specific_parameter_value_assignment,
	promissory_usage_occurrence,
	projected_zone_definition,
	printed_connector_template_terminal_relationship,
	printed_part_template_connected_terminals_definition,
	printed_part_template_material,
	printed_part_template_material_link,
	representation_relationship_with_transformation,
	requirement_assignment,
	predefined_requirement_view_definition,
	rule_action,
	runout_zone_orientation_reference_direction,
	scalar_terminal_definition_link,
	sequential_laminate_passage_based_fabrication_joint,
	shape_dimension_representation,
	shape_representation,
	shape_representation_relationship,
	signal,
	simple_clause,
	solid_curve_font,
	specified_higher_usage_occurrence,
    stratum_feature_conductive_join,
    dielectric_crossover_area,
    stratum_feature_based_derived_pattern,
	stratum_surface,
	stratum_technology,
	stratum_technology_occurrence_link,
	styled_item,
	tolerance_zone_definition,
	usage_view_connection_zone_terminal_shape_relationship,
	vector);
END_TYPE;

TYPE ap210_presented_item_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON presented_item_select WITH 
    (action,
    action_method,
    action_relationship,
    product_concept,
    product_concept_feature,
    product_concept_feature_category,
    product_definition,
    product_definition_formation,
    product_definition_relationship);
END_TYPE;


FUNCTION valid_2d_wireframe_edge_curve
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- recursively check for valid basic curve types
  IF SIZEOF ([schma + '.LINE',
              schma + '.B_SPLINE_CURVE',
              schma + '.CIRCLE',
              schma + '.HYPERBOLA',
              schma + '.ELLIPSE',
              schma + '.PARABOLA',
              schma + '.POLYLINE'] * TYPEOF (crv)) = 1
      THEN RETURN (TRUE);
  ELSE
    -- recursively check for valid basic curves for curve_replicas
    IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\curve_replica.parent_curve, schma));
    -- recursively check for valid basis curves for offset_curves
    ELSE
      IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF (crv)
        THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\offset_curve_2d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;


FUNCTION apeaid_is_base(input : area_component) : LOGICAL;
LOCAL
 pd : SET OF property_definition := bag_to_set(QUERY(pd <* USEDIN(input,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
              pd\property_definition.name = 'is base'));
END_LOCAL;
 RETURN(pd[1].description = 'true');
END_FUNCTION;

RULE application_protocol_definition_required FOR
    (application_context);
WHERE
  WR1:  SIZEOF( QUERY( ac <* application_context |
              (SIZEOF (QUERY (apd <* USEDIN(ac,'APPLICATION_CONTEXT_SCHEMA.APPLICATION_PROTOCOL_DEFINITION.APPLICATION') |
                (apd.application_interpreted_model_schema_name = 'ap210_electronic_assembly_interconnect_and_packaging_design')
                )) > 0)
              )) > 0;
END_RULE;

RULE area_component_shape_constraint FOR
    (area_component);
WHERE
  WR1:  SIZEOF( QUERY( ac <* area_component |
            NOT(SIZEOF (QUERY (pdr <* USEDIN(ac,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
              NOT(NOT(pdr\property_definition_representation.used_representation\representation.id = 'ac2dsm') OR 
                      ('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.SINGLE_AREA_CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr\property_definition_representation.used_representation)))
                )) = 0)
              )) = 0;
  WR2:  SIZEOF( QUERY( ac <* area_component |
          NOT(apeaid_is_base(ac)) OR
            NOT(SIZEOF (QUERY (pdr <* USEDIN(ac,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
              NOT(NOT(pdr\property_definition_representation.used_representation\representation.id = 'ac2dsm') OR 
                      ('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.SINGLE_BOUNDARY_CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr\property_definition_representation.used_representation)))
                )) = 0)
              )) = 0;              
END_RULE;


RULE cartesian_coordinate_system_constraint FOR
     (global_unit_assigned_context,
      geometric_representation_context);
LOCAL
   guac_inst : SET OF global_unit_assigned_context :=
               QUERY ( guac <* global_unit_assigned_context |
             ('GEOMETRY_SCHEMA.' +
              'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (guac)));
END_LOCAL;
WHERE
   WR1: SIZEOF (QUERY (guac <* guac_inst |
        NOT (SIZEOF (guac.units) <= 3))) = 0;
   WR2: SIZEOF (QUERY (guac <* guac_inst | (NOT (
        (SIZEOF (QUERY (u <* guac.units |
        ('MEASURE_SCHEMA.LENGTH_UNIT'
        IN TYPEOF (u)))) = 1)
        AND
        (SIZEOF (QUERY (u <* guac.units |
     ('MEASURE_SCHEMA.' +
         'PLANE_ANGLE_UNIT'
        IN TYPEOF (u)))) = 1)
        AND
        (SIZEOF (QUERY (u <* guac.units |
    ('MEASURE_SCHEMA.' +
         'SOLID_ANGLE_UNIT'
        IN TYPEOF (u)) )) <= 1)
        )))) = 0;
   WR3: SIZEOF( QUERY( grc <* guac_inst |
        NOT( (grc.coordinate_space_dimension = 2) OR
        (grc.coordinate_space_dimension = 3)))) = 0;
   WR4: SIZEOF (QUERY (guac <* guac_inst |
        NOT (SIZEOF (QUERY (u <* guac.units |NOT(
    NOT((
     'MEASURE_SCHEMA.' +
     'PLANE_ANGLE_UNIT' IN TYPEOF(u)) AND
    ('MEASURE_SCHEMA.' +
     'CONVERSION_BASED_UNIT' IN TYPEOF(u)) AND
     (u\conversion_based_unit.name = 'degree'))
   OR
       ((abs(u\conversion_based_unit.
           conversion_factor\measure_with_unit.value_component -
               0.0174532925) <= 0.001) AND
        ('MEASURE_SCHEMA.' +
         'PLANE_ANGLE_MEASURE_WITH_UNIT'
        IN TYPEOF(u\conversion_based_unit.conversion_factor)))
   ))) = 0)
   )) = 0;
END_RULE;

RULE not_instantiable_pre_defined_surface_side_style FOR
    (pre_defined_surface_side_style);
WHERE
 WR1: SIZEOF (pre_defined_surface_side_style) = 0;
END_RULE;

RULE shape_representation_requires_origin FOR (shape_representation);
WHERE
  WR1: 
(* 
pseudocode
co:FOREACH (sr <* shape_representation |c1);
c1:EXACTLYONE(it <* sr\representation.items |c2) 
   or ATLEASTONE(it <* sr\representation.items |c3)
   or EXACTLYNONE(it <* sr\representation.items |c4);
c2:((it.name = 'origin') or (it.name = 'orientation')) and 
   (AXIS2_PLACEMENT_2D in TYPEOF(it)  OR
    AXIS2_PLACEMENT_3D in TYPEOF(it));
c3:STYLED_ITEM in TYPEOF(it);
c4:((it.name = 'origin') or (it.name = 'orientation')) and
   ((sr.name = 'zone shape') or 
   (sr.context_of_items.context_type = 'connection zone colour'));
*)
SIZEOF(QUERY ( sr <* shape_representation |  NOT(
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and 
   (('GEOMETRY_SCHEMA.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it))  OR
   ('GEOMETRY_SCHEMA.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it)))
))) = 1
) 
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
   ('PRESENTATION_APPEARANCE_SCHEMA.' +
    'STYLED_ITEM' in TYPEOF(it))
))) >= 1
)
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and
   ((sr\representation.name = 'zone shape') or 
   (sr.context_of_items\representation_context.context_type = 'connection zone colour'))
))) = 0
)
))) = 0;
END_RULE;

-- from SCHEMA Ap210_interconnect_design_mim;
-- likely we have to remove rule spline_curve_population_constraint
RULE spline_curve_population_constraint FOR
    (curve);
WHERE
  WR1:  SIZEOF( QUERY( cu <* curve |
('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF(cu))
              )) = 0;
END_RULE;

END_SCHEMA;


(*
ISO TC184/SC4/WG3 N2819 - ISO/TS 10303-442 AP242 managed model based 3d engineering - EXPRESS MIM
*)

SCHEMA Ap242_managed_model_based_3d_engineering_mim;

USE FROM Mating_structure_mim;
USE FROM Shape_data_quality_inspection_result_mim; -- ISO/TS 10303-1524
USE FROM Externally_conditioned_data_quality_inspection_result_mim; -- ISO/TS 10303-1822
USE FROM Geometric_constraints_mim; -- ISO/TS 10303-1789
USE FROM Machining_features_mim;
USE FROM Form_feature_in_panel_mim;
USE FROM Assembly_constraints_mim;
USE FROM Kinematic_analysis_control_and_result_mim;
USE FROM Process_plan_mim;
-- geometry model for point clouds
USE FROM Constructive_solid_geometry_2d_mim; -- ISO/TS 10303-1731
USE FROM Product_as_individual_assembly_and_test_mim;

USE FROM Characterized_representation_mim;
USE FROM Chemical_substance_mim; -- ISO/TS 10303-1655 
USE FROM Composite_material_aspects_mim; -- ISO/TS 10303-1768
USE FROM Compound_shape_representation_mim; -- ISO/TS 10303-1327
USE FROM Constructive_solid_geometry_3d_mim; -- ISO/TS 10303-1068
USE FROM Curve_swept_solid_mim; -- ISO/TS 10303-1659
USE FROM Default_tolerance_mim; -- ISO/TS 10303-1052
USE FROM Design_product_data_management_mim; -- ISO/TS 10303-1628
USE FROM Dimension_and_tolerance_callouts_mim; -- ISO/TS 10303-1362
USE FROM Dimension_tolerance_mim; -- ISO/TS 10303-1050
USE FROM Drawing_definition_mim;  -- ISO/TS 10303-1309
USE FROM Elementary_boundary_representation_mim; -- ISO/TS 10303-1329
USE FROM External_currency_mim; -- ISO/TS 10303-1777
USE FROM External_representation_item_mim; -- ISO/TS 10303-1779
USE FROM Geometric_tolerance_mim; -- ISO/TS 10303-1051
USE FROM Geometric_validation_property_representation_mim; -- ISO/TS 10303-1039
USE FROM Inertia_characteristics_mim; -- ISO/TS 10303-1350
USE FROM Manifold_subsurface_mim; -- ISO/TS 10303-1702
USE FROM Mechanical_design_presentation_representation_with_draughting_mim; -- ISO/TS 10303-1315
USE FROM Modified_swept_solid_mim; -- ISO/TS 10303-1322
USE FROM Part_and_zone_laminate_tables_mim;  -- ISO/TS 10303-1770
USE FROM Picture_representation_mim;  -- ISO/TS 10303-1308
USE FROM Planned_characteristic_mim; -- ISO/TS 10303-1733
USE FROM Ply_orientation_specification_mim;  -- ISO/TS 10303-1772
USE FROM Shape_feature_mim;    -- ISO/TS 10303-1764
USE FROM Solid_with_local_modification_mim; -- ISO/TS 10303-1319
USE FROM Surface_conditions_mim; -- ISO/TS 10303-1110 
USE FROM Text_representation_mim;	-- ISO/TS 10303-1750
USE FROM Thickened_face_solid_mim; -- ISO/TS 10303-1320
USE FROM Wireframe_2d_mim; -- ISO/TS 10303-1347
USE FROM Model_based_3d_geometrical_dimensioning_and_tolerancing_representation_mim;
USE FROM Product_and_manufacturing_annotation_presentation_mim;
USE FROM Change_management_mim; -- ISO/TS 10303-1661
USE FROM Sketch_mim; -- ISO/TS 10303-1792
USE FROM Tessellated_geometry_mim;  -- ISO/TS 10303-1819
USE FROM Edge_shape_feature_mim; -- ISO/TS 10303-1673
USE FROM Point_direction_model_mim;  -- -- ISO/TS 10303-1820
USE FROM Numerical_interface_mim; -- ISO/TS 10303-1344


USE FROM application_context_schema   -- ISO 10303-41
  (application_context,
   application_protocol_definition,
   product_context,
   product_definition_context); 
USE FROM product_concept_schema(product_concept_relationship); 
USE FROM product_definition_schema(  -- ISO 10303-41
  product_definition_context_role, 
  product_category_relationship); 
REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   type_check_function); 
USE FROM product_property_representation_schema
  (item_identified_representation_usage_definition);   
REFERENCE FROM representation_schema(founded_item);

  CONSTANT
    deprecated_interfaced_data_types : SET OF STRING := 
      ['document_with_class',
       'ordinal_date', 
       'product_definition_formation_with_specified_source', 
       'week_of_year_and_day_date']; 
    deprecated_constructed_data_types : SET OF STRING := 
      ['approved_item',
       'certified_item', 
       'change_request_item', 
       'contracted_item', 
       'cc_classified_item', 
       'date_time_item', 
       'cc_person_organization_item', 
       'cc_specified_item', 
       'start_request_item', 
       'work_item']; 
    deprecated_entity_data_types : SET OF STRING := 
      ['cc_design_approval',
       'cc_design_certification', 
       'cc_design_contract', 
       'cc_design_date_and_time_assignment', 
       'cc_design_person_and_organization_assignment', 
       'cc_design_security_classification', 
       'cc_design_specification_reference', 
       'change', 
       'change_request', 
       'design_context', 
       'design_make_from_relationship', 
       'mechanical_context',
       'product_category_relationship', 
       'start_request', 
       'start_work', 
       'supplied_part_relationship']; 
  END_CONSTANT; 
  
  TYPE property_variable_rep_select_242 = SELECT BASED_ON property_variable_rep_select WITH
   (dimensional_size,
    representation);
  END_TYPE;
    
  TYPE item_identified_representation_usage_definition_242 = SELECT BASED_ON item_identified_representation_usage_definition WITH
   (applied_action_assignment,
    applied_action_method_assignment, 
    applied_action_request_assignment, 
    applied_approval_assignment,
    applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment,
    applied_document_reference,
    applied_document_usage_constraint_assignment,
    applied_effectivity_assignment,
    applied_event_occurrence_assignment, 
    applied_external_identification_assignment,
    applied_group_assignment,
    applied_identification_assignment,
    applied_ineffectivity_assignment,
    applied_name_assignment,
    applied_organization_assignment, 
    applied_organizational_project_assignment,
    applied_person_and_organization_assignment,
    applied_security_classification_assignment,
    applied_time_interval_assignment,
    applied_usage_right,
    product_definition_relationship,
    property_definition);
  END_TYPE;
  
  TYPE draughting_model_item_definition_242 = SELECT BASED_ON draughting_model_item_definition WITH
   (applied_action_assignment,
    applied_action_method_assignment, 
    applied_action_request_assignment, 
    applied_approval_assignment,
    applied_certification_assignment, 
    applied_classification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment,
    applied_document_reference,
    applied_document_usage_constraint_assignment,
    applied_effectivity_assignment,
    applied_event_occurrence_assignment, 
    applied_external_identification_assignment,
    applied_group_assignment,
    applied_identification_assignment,
    applied_ineffectivity_assignment,
    applied_name_assignment,
    applied_organization_assignment, 
    applied_organizational_project_assignment,
    applied_person_and_organization_assignment,
    applied_security_classification_assignment,
    applied_time_interval_assignment,
    applied_usage_right,
    product_definition_relationship,
    property_definition);
  END_TYPE;
  
  TYPE ap242_change_management_object = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON change_management_object WITH 
    (action_items,
     action,
     action_relationship,
     project_item,
     class,
     event_occurrence);
  END_TYPE;

  TYPE ap242_change_relationship_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON change_relationship_select WITH 
    (product_definition_relationship,
     action_relationship,
     shape_aspect_relationship);
  END_TYPE;

  TYPE action_request_item_242 = SELECT BASED_ON action_request_item WITH 
    (product_definition_formation_relationship,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	resource_property);
  END_TYPE; 

  TYPE aliasable_item_242 = SELECT BASED_ON aliasable_item WITH 
    (approval_status, 
    general_property, 
    organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    security_classification,
    shape_representation);
  END_TYPE; 

  TYPE approval_item_242 = SELECT BASED_ON approval_item WITH 
    (alternate_product_relationship, 
    assembly_component_usage_substitute, 
    certification, 
    contract, 
    document_file, 
    executed_action, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship,
     draughting_model,
     drawing_revision,
     mechanical_design_geometric_presentation_representation,
	 presentation_area,
	 resource_property);
  END_TYPE; 

  TYPE approved_item = SELECT
    (certification, 
    change, 
    change_request, 
    configuration_effectivity, 
    configuration_item, 
    contract, 
    product, 
    security_classification, 
    start_request, 
    start_work);
  END_TYPE; 

  TYPE attribute_language_item_242 = SELECT BASED_ON attribute_language_item WITH 
    (alternate_product_relationship, 
    application_context, 
    applied_certification_assignment, 
    applied_identification_assignment, 
    applied_security_classification_assignment, 
    assembly_component_usage_substitute, 
    attribute_value_assignment, 
    configuration_design, 
    configuration_item, 
    descriptive_representation_item, 
    effectivity, 
    effectivity_relationship, 
    event_occurrence, 
    external_source, 
    general_property, 
    general_property_relationship, 
    geometric_representation_item, 
    geometric_tolerance, 
    make_from_usage_option, 
    mapped_item, 
    organization_role, 
    person_and_organization_role, 
    product_concept, 
    product_concept_relationship, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_shape, 
    product_related_product_category, 
    property_definition, 
    representation, 
    security_classification, 
    security_classification_assignment, 
    shape_aspect, 
    shape_aspect_relationship, 
    shape_representation, 
    time_interval_role, 
    topological_representation_item, 
    uncertainty_measure_with_unit, 
    uncertainty_qualifier,
	draughting_title,
	kinematic_pair,
	actuated_kinematic_pair,
	presentation_layer_assignment,
	process_product_association,
	requirement_for_action_resource,
	resource_property,
	resource_requirement_type,
	styled_item,
	versioned_action_request_relationship);
  END_TYPE; 

  TYPE certification_item_242 = SELECT BASED_ON certification_item;
  END_TYPE; 

  TYPE certified_item = SELECT
    (supplied_part_relationship);
  END_TYPE; 

  TYPE change_request_item = SELECT
    (product_definition_formation);
  END_TYPE; 

  TYPE cc_classified_item = SELECT 
    (assembly_component_usage, 
    product_definition_formation);
  END_TYPE; 

  TYPE contract_item_242 = SELECT BASED_ON contract_item WITH 
    (drawing_revision,
    executed_action, 
    product_definition_formation);
  END_TYPE; 

  TYPE contracted_item = SELECT
    (product_definition_formation);
  END_TYPE; 

  TYPE date_and_time_item_242 = SELECT BASED_ON date_and_time_item WITH 
    (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval_person_organization, 
    certification, 
    contract, 
    organizational_project, 
    product_definition, 
    product_definition_formation, 
    security_classification,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	requirement_for_action_resource,
	resource_property);
  END_TYPE; 

  TYPE date_item_242 = SELECT BASED_ON date_item WITH 
    (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    approval_person_organization, 
    certification, 
    contract, 
    organizational_project, 
    product_definition, 
    product_definition_formation, 
    security_classification,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	requirement_for_action_resource,
	resource_property);
  END_TYPE; 

  TYPE date_time_item = SELECT
    (approval_person_organization, 
    certification, 
    change, 
    change_request, 
    contract, 
    product_definition, 
    security_classification, 
    start_request, 
    start_work);
  END_TYPE; 

  TYPE document_reference_item_242 = SELECT BASED_ON document_reference_item WITH 
    (product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship,
	feature_definition,
	presentation_area,
	process_plan,
	resource_requirement_type,
	retention,
	product_definition_process);
  END_TYPE; 

  TYPE effectivity_item_242 = SELECT BASED_ON effectivity_item WITH 
    (assembly_component_usage_substitute, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	requirement_for_action_resource,
	resource_property);
  END_TYPE; 

  TYPE event_occurrence_item_242 = SELECT BASED_ON event_occurrence_item WITH (
    organizational_project,
	requirement_for_action_resource,
	resource_property,
	presentation_area,
	mechanical_design_geometric_presentation_representation,
	draughting_model,
	drawing_revision);
  END_TYPE; 

  TYPE external_identification_item_242 = SELECT BASED_ON external_identification_item WITH 
    (document_file, 
    product_definition);
  END_TYPE; 

  TYPE groupable_item_242 = SELECT BASED_ON groupable_item WITH 
    (geometric_representation_item,
     shape_representation_relationship, 
     representation_relationship_with_transformation, 
     mapped_item,
     shape_aspect, 
     styled_item, 
     topological_representation_item);
  END_TYPE; 

  TYPE identification_item_242 = SELECT BASED_ON identification_item WITH 
    (approval_status, 
    document_file, 
    general_property, 
    organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    security_classification, 
    security_classification_level, 
    shape_representation,
	draughting_model,
	mechanical_design_geometric_presentation_representation,
	presentation_area);
  END_TYPE; 

  TYPE multi_language_attribute_item_242 = SELECT BASED_ON multi_language_attribute_item WITH 
    (alternate_product_relationship, 
    application_context, 
    applied_certification_assignment, 
    applied_identification_assignment, 
    assembly_component_usage_substitute, 
    attribute_value_assignment, 
    colour, 
    configuration_design, 
    configuration_item, 
    descriptive_representation_item, 
    effectivity, 
    effectivity_relationship, 
    event_occurrence, 
    external_source, 
    general_property, 
    general_property_relationship, 
    geometric_representation_item, 
    geometric_tolerance, 
    make_from_usage_option, 
    mapped_item, 
    organization_role, 
    person_and_organization_role, 
    product_concept, 
    product_concept_relationship, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_shape, 
    product_related_product_category, 
    property_definition, 
    representation, 
    representation_relationship, 
    security_classification, 
    security_classification_assignment, 
    shape_aspect, 
    shape_aspect_relationship, 
    shape_representation, 
    time_interval_role, 
    topological_representation_item, 
    uncertainty_measure_with_unit,
	draughting_title,
	kinematic_pair,
	actuated_kinematic_pair,
	presentation_layer_assignment,
	process_product_association,
	requirement_for_action_resource,
	resource_property,
	resource_requirement_type,
	styled_item,
	versioned_action_request_relationship);
  END_TYPE; 

  TYPE organization_item_242 = SELECT BASED_ON organization_item WITH 
    (alternate_product_relationship, 
    applied_action_assignment, 
    applied_identification_assignment, 
    applied_security_classification_assignment, 
    assembly_component_usage_substitute, 
    certification, 
    document_file, 
    general_property, 
    organizational_project, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    property_definition, 
    shape_representation,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	requirement_for_action_resource,
	resource_property);
  END_TYPE; 

  TYPE organizational_project_item_242 = SELECT BASED_ON project_item WITH 
    (executed_action, 
    product_concept);
  END_TYPE; 

  TYPE person_and_organization_item_242 = SELECT BASED_ON person_and_organization_item WITH 
    (alternate_product_relationship, 
    applied_action_assignment, 
    applied_security_classification_assignment, 
    assembly_component_usage_substitute, 
    certification, 
    document_file, 
    general_property, 
    organizational_project, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    property_definition, 
    shape_representation,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	requirement_for_action_resource,
	resource_property);
  END_TYPE; 
(*
  TYPE property_variable_rep_select_242 = SELECT BASED_ON property_variable_rep_select WITH (
     dimensional_size,
     dimensional_location,
     representation);
  END_TYPE; 
*)  
  TYPE cc_person_organization_item = SELECT
    (change, 
    change_request, 
    configuration_item, 
    contract, 
    product, 
    product_definition, 
    product_definition_formation, 
    security_classification, 
    start_request, 
    start_work);
  END_TYPE; 

  TYPE presented_item_select_242 = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON presented_item_select WITH 
    (action,
    action_method,
    action_relationship,
    product_concept,
    product_concept_feature,
    product_concept_feature_category,
    product_definition,
    product_definition_formation,
    product_definition_relationship);
  END_TYPE;

  TYPE security_classification_item_242 = SELECT BASED_ON security_classification_item WITH 
    (document_file, 
    product_definition, 
    product_definition_formation, 
    product_definition_usage,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	resource_property);
  END_TYPE; 

  TYPE cc_specified_item = SELECT
    (product_definition, 
    shape_aspect);
  END_TYPE; 

  TYPE start_request_item = SELECT
    (product_definition_formation);
  END_TYPE; 

  TYPE time_interval_item_242 = SELECT BASED_ON time_interval_item WITH 
    (time_interval_based_effectivity,
	draughting_model,
	drawing_revision,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	requirement_for_action_resource,
	resource_property);
  END_TYPE; 

TYPE action_items_242 = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH ( 
	executed_action,
	mechanical_design_geometric_presentation_representation,
	presentation_area,
	requirement_for_action_resource,
	resource_property,
	draughting_model,
	drawing_revision);
END_TYPE; 

TYPE classification_item_242 = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH ( 
	feature_definition,
	general_feature,
	plus_minus_tolerance,
	process_operation,
	resource_property);
END_TYPE; 

TYPE configured_effectivity_item_242 = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON configured_effectivity_item WITH ( 
	process_plan,
	product_process_plan);
END_TYPE; 

  TYPE work_item = SELECT
    (product_definition_formation);
  END_TYPE; 

  ENTITY cc_design_approval
    SUBTYPE OF (approval_assignment);
      items : SET[1:?] OF approved_item;
  END_ENTITY;

  ENTITY cc_design_certification
    SUBTYPE OF (certification_assignment);
      items : SET[1:?] OF certified_item;
  END_ENTITY;

  ENTITY cc_design_contract
    SUBTYPE OF (contract_assignment);
      items : SET[1:?] OF contracted_item;
  END_ENTITY;

  ENTITY cc_design_date_and_time_assignment
    SUBTYPE OF (date_and_time_assignment);
      items : SET[1:?] OF date_time_item;
  END_ENTITY;

  ENTITY cc_design_person_and_organization_assignment
    SUBTYPE OF (person_and_organization_assignment);
      items : SET[1:?] OF cc_person_organization_item;
    WHERE
      WR1: cc_design_person_and_organization_correlation(SELF);
  END_ENTITY;

  ENTITY cc_design_security_classification
    SUBTYPE OF (security_classification_assignment);
      items : SET[1:?] OF cc_classified_item; 
  END_ENTITY;

  ENTITY cc_design_specification_reference
    SUBTYPE OF (document_reference);
      items : SET[1:?] OF cc_specified_item; 
  END_ENTITY;

  ENTITY change
    SUBTYPE OF (action_assignment);
      items : SET[1:?] OF work_item;
  END_ENTITY;

  ENTITY change_request
    SUBTYPE OF (action_request_assignment);
      items : SET[1:?] OF change_request_item;
  END_ENTITY;

  ENTITY design_context
    SUBTYPE OF (product_definition_context);
    WHERE
      WR1: SELF.life_cycle_stage = 'design';
  END_ENTITY;

  ENTITY design_make_from_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY mechanical_context
    SUBTYPE OF (product_context);
    WHERE
      WR1: SELF.discipline_type = 'mechanical';
  END_ENTITY;

  ENTITY start_request
    SUBTYPE OF (action_request_assignment);
      items : SET[1:?] OF start_request_item;
  END_ENTITY;

  ENTITY start_work
    SUBTYPE OF (action_assignment);
      items : SET[1:?] OF work_item;
  END_ENTITY;

  ENTITY supplied_part_relationship
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;
  
SUBTYPE_CONSTRAINT ap242_founded_item_subtypes FOR founded_item;
  ABSTRACT SUPERTYPE;
  ONEOF (b_spline_curve_knot_locator,
         b_spline_curve_segment,
         b_spline_surface_knot_locator,
         b_spline_surface_patch,
         b_spline_surface_strip,
         boundary_curve_of_b_spline_or_rectangular_composite_surface,
         box_domain,
         character_glyph_style_outline,
         character_glyph_style_stroke,
         composite_curve_segment,
         composite_curve_transition_locator,
         curve_style,
         curve_style_font,
         curve_style_font_and_scaling,
         curve_style_font_pattern,
         externally_defined_style,
         fill_area_style,
         interpolated_configuration_segment,
         kinematic_path_segment,
         plane_angle_and_length_pair,
         plane_angle_and_ratio_pair,
         point_style,
         presentation_style_assignment,
         rectangular_composite_surface_transition_locator,
         surface_patch,
         surface_side_style,
         surface_style_boundary,
         surface_style_control_grid,
         surface_style_fill_area,
         surface_style_parameter_line,
         surface_style_segmentation_curve,
         surface_style_silhouette,
         surface_style_usage,
         symbol_style,
         text_style,
         view_volume);
END_SUBTYPE_CONSTRAINT;

RULE subtype_mandatory_shape_representation FOR
  (shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
       NOT ((SIZEOF ([
        'AIC_ADVANCED_BREP.ADVANCED_BREP_SHAPE_REPRESENTATION',
        'AIC_FACETED_BREP.FACETED_BREP_SHAPE_REPRESENTATION',
        'AIC_MANIFOLD_SURFACE.MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
        'AIC_MANIFOLD_SUBSURFACE.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION',
        'AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION',
        'AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION',
        'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
        'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION',
        'COMPOSITE_CONSTITUENT_SHAPE_MIM.BEVELED_SHEET_REPRESENTATION',
        'COMPOSITE_CONSTITUENT_SHAPE_MIM.COMPOSITE_SHEET_REPRESENTATION',
        'COMPOUND_SHAPE_REPRESENTATION_MIM.COMPOUND_SHAPE_REPRESENTATION',
        'CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.CSG_2D_SHAPE_REPRESENTATION',
        'AIC_CSG.CSG_SHAPE_REPRESENTATION',
        'AIC_CURVE_SWEPT_SOLID.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION',
        'AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION',
        'AIC_ELEMENTARY_BREP.ELEMENTARY_BREP_SHAPE_REPRESENTATION',
        'AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION',
        'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION',
        'AIC_MACHINING_FEATURE.LOCATION_SHAPE_REPRESENTATION',
        'SKETCH_SCHEMA.NEUTRAL_SKETCH_REPRESENTATION',
        'AIC_NON_MANIFOLD_SURFACE.NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION',
        'AIC_MACHINING_FEATURE.PATH_SHAPE_REPRESENTATION',
        'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION',
        'PROCEDURAL_SHAPE_MODEL_SCHEMA.PROCEDURAL_SHAPE_REPRESENTATION',
        'ASSEMBLY_FEATURE_RELATIONSHIP_SCHEMA.REPRESENTATIVE_SHAPE_REPRESENTATION',
        'SHAPE_DIMENSION_SCHEMA.SHAPE_DIMENSION_REPRESENTATION',
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS',
        'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHAPE_REPRESENTATION'
       ] * TYPEOF (sr)) = 1) OR
       (SIZEOF (QUERY (it <* sr\representation.items |
       NOT ('CONFIG_CONTROL_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF (it))))
       = 0) OR
       (SIZEOF (QUERY (sdr <* QUERY (pdr <* USEDIN (sr,
       'CONFIG_CONTROL_DESIGN.PROPERTY_DEFINITION_REPRESENTATION.' +
       'USED_REPRESENTATION') |
       'CONFIG_CONTROL_DESIGN.SHAPE_DEFINITION_REPRESENTATION' IN
       TYPEOF (pdr)) | 
       NOT (SIZEOF (['CONFIG_CONTROL_DESIGN.SHAPE_ASPECT',
       'CONFIG_CONTROL_DESIGN.SHAPE_ASPECT_RELATIONSHIP'] * TYPEOF
       (sdr.definition)) = 1))) = 0)))) = 0;
END_RULE; -- subtype_mandatory_shape_representation

  RULE dimensioning_data_requires_document FOR (applied_document_reference, product_definition_context_association, role_association);
    LOCAL
      adr : SET OF applied_document_reference := (QUERY(adr <* applied_document_reference |
                         (adr\document_reference.assigned_document\document.kind\document_type.product_data_type = 'Standards Document') AND
                         ((adr\document_reference.assigned_document\document.id = 'ASME Y14.41-2003') OR 
                         (adr\document_reference.assigned_document\document.id = 'ASME Y14.5M-1994') OR 
                         (adr\document_reference.assigned_document\document.id = 'ISO 1101: 2004'))));
      pdca : SET OF product_definition_context_association := (QUERY(pdca <* product_definition_context_association |
                         (pdca\product_definition_context_association.role\product_definition_context_role.name = 'additional context') AND
                         (pdca\product_definition_context_association.frame_of_reference\application_context_element.name = 'Geometric Dimensioning and Tolerancing Product Specification')));
      ra : SET OF role_association := (QUERY(ra <* role_association |
                         ra\role_association.role\object_role.name = 'dimensioning standard'));
      ra1 : SET OF role_association := [];
      pdpdca : SET OF product_definition := [];
      pdadr : SET OF product_definition := [];
      pass : BOOLEAN := TRUE;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(pdca);
       pdpdca := pdpdca + pdca[i]\product_definition_context_association.definition;
    END_REPEAT;
    REPEAT i := 1 TO HIINDEX(adr);
       ra1 := bag_to_set(USEDIN(adr[i],'BASIC_ATTRIBUTE_SCHEMA.ROLE_ASSOCIATION.ITEM_WITH_ROLE'));
       IF (ra1 * ra) <> ra1 THEN 
        pass := FALSE;
       END_IF;
      REPEAT j := 1 to HIINDEX(adr[i]\applied_document_reference.items);
       IF 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(adr[i]\applied_document_reference.items[j]) THEN
        pdadr := pdadr + adr[i]\applied_document_reference.items[j];
       END_IF;
      END_REPEAT;
    END_REPEAT;

    WHERE
     WR1 : pass; 
     WR2 : pdpdca = pdadr;
 
END_RULE;

  RULE application_protocol_definition_required FOR 
      (application_context); 
    WHERE 
      WR1:  SIZEOF( QUERY( ac <* application_context | 
              (SIZEOF (QUERY (apd <* USEDIN(ac,'APPLICATION_CONTEXT_SCHEMA.APPLICATION_PROTOCOL_DEFINITION.APPLICATION') | 
                apd.application_interpreted_model_schema_name = 'ap242_managed_model_based_3d_engineering' 
                )) > 0) 
              )) > 0;    
 
  END_RULE; 

  FUNCTION cc_design_person_and_organization_correlation
   (e : cc_design_person_and_organization_assignment) : BOOLEAN; 
    LOCAL
      po_role : STRING;
    END_LOCAL;
      po_role := e\person_and_organization_assignment.role.name;
    CASE po_role OF
      'request_recipient'      : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF(['AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'CHANGE_REQUEST',
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'START_REQUEST'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
      'initiator'              : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF(['AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'CHANGE_REQUEST',
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'START_REQUEST',
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'START_WORK',
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'CHANGE'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN(FALSE);
                               END_IF;
      'creator'                : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 SIZEOF (['AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'PRODUCT_DEFINITION_FORMATION',
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'PRODUCT_DEFINITION'] *
                                 TYPEOF (x)) = 1))
                                 THEN RETURN (FALSE);
                               END_IF;
      'part_supplier'          : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'design_supplier'        : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'PRODUCT_DEFINITION_FORMATION'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'design_owner'           : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.PRODUCT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'configuration_manager'  : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'CONFIGURATION_ITEM'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'contractor'             : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.CONTRACT'
                                 IN TYPEOF (x)))
                                 THEN RETURN(FALSE);
                               END_IF;
      'classification_officer' : IF SIZEOF (e.items) <>
                                 SIZEOF (QUERY (x <* e.items |
                                 'AP242_MANAGED_MODEL_BASED_3D_ENGINEERING_MIM.' +
                                 'SECURITY_CLASSIFICATION'
                                 IN TYPEOF (x))) THEN
                                 RETURN(FALSE);
                               END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
  END_FUNCTION; 

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6861 - ISO/TS 10303-1001 Appearance assignment - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5282
*) 


SCHEMA Appearance_assignment_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (context_dependent_over_riding_styled_item,
   fill_area_style_colour,
   invisibility,
   over_riding_styled_item,
   presentation_style_assignment,
   presentation_style_by_context,
   externally_defined_style,
   style_context_select,
   styled_item);

USE FROM presentation_resource_schema   -- ISO 10303-46
   (planar_box);

USE FROM representation_schema   -- ISO 10303-43
  (mapped_item); 

  TYPE appearance_representation_identification_item = SELECT BASED_ON identification_item WITH 
    (representation);
  END_TYPE; 

  SUBTYPE_CONSTRAINT aa_representation_item_subtypes FOR representation_item;
    ONEOF (mapped_item,
      styled_item);
  END_SUBTYPE_CONSTRAINT;

  RULE styled_curve FOR (styled_item);
    WHERE
      WR1: SIZEOF( QUERY( si <* styled_item | ('APPEARANCE_ASSIGNMENT_MIM.CURVE' IN TYPEOF (si.item)) AND (SIZEOF (QUERY (psa <* si.styles | (SIZEOF (QUERY (cs <* psa.styles | ('APPEARANCE_ASSIGNMENT_MIM.CURVE_STYLE' IN TYPEOF (cs)) )) > 0) )) <> 1) )) = 0;
  END_RULE; 

END_SCHEMA; 
(*
 ISO TC184/SC4/WG12 N6023 - ISO/TS 10303-1012 Approval - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5285
*)


SCHEMA Approval_mim;

USE FROM approval_schema   -- ISO 10303-41
  (approval,
   approval_date_time,
   approval_person_organization,
   approval_relationship,
   approval_role,
   approval_status); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role,
   role_association,
   role_select); 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM management_resources_schema   -- ISO 10303-41
  (approval_assignment); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011


TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE date_and_time_item_approval = SELECT BASED_ON date_and_time_item WITH 
   (approval_person_organization);
END_TYPE; 

TYPE date_item_approval = SELECT BASED_ON date_item WITH 
   (approval_person_organization);
END_TYPE; 

ENTITY applied_approval_assignment
  SUBTYPE OF (approval_assignment);
  items : SET[1:?] OF approval_item;
END_ENTITY;

END_SCHEMA;  -- Approval_mim
(*
   ISO TC184/SC4/WG12 N6280 - ISO/TS 10303-1631 Area 2d - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3841
*)

SCHEMA Area_2d_mim;
	USE FROM Extended_basic_geometry_mim;	-- ISO/TS 10303-1667
	USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
	USE FROM geometric_model_schema
		(circular_area,
		elliptic_area,
		polygonal_area,
		primitive_2d,
		rectangular_area);
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6283 - ISO/TS 10303-1632 Assembly 2d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5564
*)


SCHEMA Assembly_2d_shape_mim;
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
	USE FROM Physical_unit_2d_design_view_mim;	-- ISO/TS 10303-1724
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6286 - ISO/TS 10303-1633 Assembly 3d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5567
*)


SCHEMA Assembly_3d_shape_mim;
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
    USE FROM Physical_unit_3d_shape_mim; -- ISO/TS 10303-1727
END_SCHEMA;

(*
   N - ISO/CD-TS - 10303- assembly_component - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Assembly_component_mim;

USE FROM Component_grouping_mim;
USE FROM Assembly_shape_mim;

ENTITY assembly_component
  SUBTYPE OF (component_definition, product_definition_shape);
  DERIVE
    SELF\property_definition.definition : assembly_component := SELF;
  WHERE
    WR1: NOT EXISTS(SELF\property_definition.description);
END_ENTITY;

ENTITY component_definition
  SUBTYPE OF (product_definition, product_definition_relationship);
  DERIVE
    SELF\product_definition_relationship.related_product_definition : component_definition := SELF;
  WHERE
    WR1: NOT EXISTS(SELF\product_definition_relationship.description);
    WR2: NOT EXISTS(SELF\property_definition.description);    
    WR3: SELF\product_definition_relationship.id = SELF\product_definition.id;
    WR4: SELF\product_definition_relationship.name = 'definition usage';
    WR5: NOT ('PRODUCT_STRUCTURE_SCHEMA.' + 'PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF));
END_ENTITY;

ENTITY physical_component
  SUBTYPE OF (assembly_component);
END_ENTITY;

ENTITY thermal_component
  SUBTYPE OF (assembly_component);
END_ENTITY;
	
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6942 - ISO/TS 10303-1634 Assembly component placement requirements - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6289
*)
SCHEMA Assembly_component_placement_requirements_mim;

USE FROM Assembly_module_with_interconnect_component_mim;	-- ISO/TS 10303-1643


  SUBTYPE_CONSTRAINT acpr_predefined_requirement_view_definition_subtypes FOR predefined_requirement_view_definition;   
    (ONEOF (assembly_spacing_requirement,
     assembly_group_spacing_requirement,
     item_restricted_requirement));
  END_SUBTYPE_CONSTRAINT;  

  TYPE acpr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (group_product_definition,
     predefined_requirement_view_definition,
     shape_aspect);
  END_TYPE;

  TYPE acpr_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
    (assembly_spacing_requirement,
     shape_aspect,
     predefined_requirement_view_definition);
  END_TYPE;

  ENTITY assembly_group_spacing_requirement
    SUBTYPE OF (predefined_requirement_view_definition);
  END_ENTITY;

  ENTITY assembly_spacing_requirement
    SUBTYPE OF (predefined_requirement_view_definition);
  END_ENTITY;

  ENTITY group_product_definition
    SUBTYPE OF (component_definition);
  END_ENTITY;

  ENTITY item_restricted_requirement
    SUBTYPE OF (group, predefined_requirement_view_definition);
  END_ENTITY;

  ENTITY mounting_restriction_area
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY mounting_restriction_volume
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N1163 - ISO/TS 10303-1049 Activity method - EXPRESS MIM
*)

SCHEMA Assembly_constraints_mim;

USE FROM Assembly_feature_relationship_mim; -- ISO/CD-TS 10303-1af1
USE FROM Geometric_constraints_mim; -- ISO/CD-TS 10303-1pc3
USE FROM Explicit_constraints_mim; -- ISO/CD-TS 10303-1pc2
USE FROM Foundation_representation_mim;  -- ISO/TS 10303-1006
USE FROM Contextual_shape_positioning_mim; -- ISO/TS 10303-1027
USE FROM Assembly_constraint_schema; -- ISO 10303-109
END_SCHEMA;
(*
  ISO TC184/SC4/WG12 N4xxx - ISO/CD-TS 10303-1af1 Assembly feature relationship - EXPRESS MIM
*)

SCHEMA Assembly_feature_relationship_mim;

USE FROM Contextual_shape_positioning_mim;  -- ISO 10303-1pc3

USE FROM Foundation_representation_mim;  -- ISO 10303-1006

USE FROM Kinematic_motion_representation_mim; -- ISO 10303-1xxx
 
USE FROM Kinematic_structure_mim;  -- ISO 10303-1xxy

USE FROM Shape_property_assignment_mim;  -- ISO 10303-1xxy


USE FROM assembly_feature_relationship_schema;  -- ISO 10303-109


END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6292 - ISO/TS 10303-1635 Assembly functional interface requirement - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5573
*)
SCHEMA Assembly_functional_interface_requirement_mim;

USE FROM Altered_part_mim;	-- ISO/TS 10303-1602
	
  TYPE afir_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (protocol_physical_layer_definition);
  END_TYPE;
	
  ENTITY minimally_defined_connector
    SUBTYPE OF (packaged_part);
  END_ENTITY;

  ENTITY protocol_physical_layer_definition 
    SUBTYPE OF (product_definition);
  END_ENTITY;

  ENTITY protocol_physical_layer_definition_with_characterization 
    SUBTYPE OF (protocol_physical_layer_definition);
  END_ENTITY;

  ENTITY protocol_requirement_allocation_to_part_terminal
    SUBTYPE OF (requirement_assignment);
  END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6295 - ISO/TS 10303-1636 Assembly module design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5576
*)
SCHEMA Assembly_module_design_mim;

	USE FROM Altered_package_mim;	-- ISO/TS 10303-1601
	USE FROM Assembly_module_usage_view_mim;	-- ISO/TS 10303-1642
	USE FROM Bare_die_mim;	-- ISO/TS 10303-1650
	USE FROM Physical_component_feature_mim;	-- ISO/TS 10303-1721
	USE FROM Layered_interconnect_simple_template_mim;	-- ISO/TS 10303-1718	

	SUBTYPE_CONSTRAINT amd_physical_component_subtypes FOR physical_component;         
	    ONEOF (packaged_component,
		routed_physical_component);    
	END_SUBTYPE_CONSTRAINT;

ENTITY assembly_module_design_view
  SUPERTYPE OF (ONEOF (layered_assembly_panel_design_view, layered_assembly_module_design_view))
  SUBTYPE OF (physical_unit);
END_ENTITY;

ENTITY bare_die_component
  SUBTYPE OF (physical_component);
END_ENTITY;

ENTITY component_mounting_feature
  SUBTYPE OF (physical_component_feature);
END_ENTITY;

ENTITY layered_assembly_panel_design_view
  SUBTYPE OF (assembly_module_design_view);
END_ENTITY;

ENTITY packaged_component
  SUBTYPE OF (physical_component);
END_ENTITY;

ENTITY layered_assembly_module_design_view
 SUBTYPE OF (assembly_module_design_view);
END_ENTITY;

ENTITY routed_interconnect_component
  SUBTYPE OF (item_identified_representation_usage, physical_component);
END_ENTITY;

ENTITY routed_physical_component
  SUBTYPE OF (item_identified_representation_usage, physical_component);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6298 - ISO/TS 10303-1637 Assembly module macro definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5579
*)


SCHEMA Assembly_module_macro_definition_mim;
	USE FROM Interconnect_module_with_macros_mim;	-- ISO/TS 10303-1687

SUBTYPE_CONSTRAINT assembly_module_terminal_subtypes FOR assembly_module_terminal;         
  (ONEOF (assembly_module_interface_terminal, 
           assembly_module_macro_terminal));
END_SUBTYPE_CONSTRAINT;        

ENTITY assembly_module_macro_terminal
  SUBTYPE OF (assembly_module_terminal);
END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6301 - ISO/TS 10303-1642 Assembly module usage view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5594
*)
SCHEMA Assembly_module_usage_view_mim;

--	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Packaged_connector_model_mim;	-- ISO/TS 10303-1708

ENTITY assembly_module_interface_terminal
  SUBTYPE OF (assembly_module_terminal);
END_ENTITY;

ENTITY assembly_module_terminal
  SUPERTYPE OF (assembly_module_interface_terminal)
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY assembly_module_usage_view
  SUPERTYPE OF (layered_assembly_module_usage_view)
  SUBTYPE OF (physical_unit);
END_ENTITY;

ENTITY layered_assembly_module_usage_view
  SUBTYPE OF (assembly_module_usage_view);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6304 - ISO/TS 10303-1644 Assembly module with cable component - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5600
*)
SCHEMA Assembly_module_with_cable_component_mim;

USE FROM Cable_mim;	-- ISO/TS 10303-1653

  SUBTYPE_CONSTRAINT amwcc_shape_aspect_subtypes FOR shape_aspect; 
    ONEOF (minimally_defined_bare_die_terminal,
          assembly_module_terminal,
          cable_terminal,
          packaged_part_terminal);
  END_SUBTYPE_CONSTRAINT;

  ENTITY cable_component
    SUBTYPE OF (physical_component);
  END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6307 - ISO/TS 10303-1638 Assembly module with cable component 2d - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5582
*)


SCHEMA Assembly_module_with_cable_component_2d_mim;
	USE FROM Assembly_module_with_cable_component_mim;	-- ISO/TS 10303-1644
	USE FROM Physical_unit_2d_design_view_mim;	-- ISO/TS 10303-1724
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6310 - ISO/TS 10303-1639 Assembly module with cable component 3d - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5585
*)


SCHEMA Assembly_module_with_cable_component_3d_mim;

USE FROM Assembly_module_with_cable_component_mim;	-- ISO/TS 10303-1644
USE FROM Physical_unit_3d_design_view_mim;	-- ISO/TS 10303-1725

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6313 - ISO/TS 10303-1643 Assembly module with interconnect component - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5597
*)
SCHEMA Assembly_module_with_interconnect_component_mim;

	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
	USE FROM Interconnect_module_usage_view_mim;	-- ISO/TS 10303-1686
	USE FROM Interface_component_mim;	-- ISO/TS 10303-1691	

ENTITY interconnect_module_component
  SUBTYPE OF (physical_component);
END_ENTITY;

ENTITY interconnect_module_component_surface_feature
  SUBTYPE OF (physical_component_feature);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6316 - ISO/TS 10303-1640 Assembly module with macro component - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5588
*)


SCHEMA Assembly_module_with_macro_component_mim;
	USE FROM Assembly_module_macro_definition_mim;	-- ISO/TS 10303-1637
	USE FROM Assembly_module_with_subassembly_mim;	-- ISO/TS 10303-1641

  ENTITY assembly_module_macro_component
    SUBTYPE OF (physical_component);
  END_ENTITY;
	
ENTITY assembly_module_macro_component_join_terminal
  SUBTYPE OF (physical_component_terminal);
END_ENTITY;
	
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6319 - ISO/TS 10303-1645 Assembly module with packaged connector component - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5603
*)
SCHEMA Assembly_module_with_packaged_connector_component_mim;

	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
	USE FROM Interface_component_mim;	-- ISO/TS 10303-1691

ENTITY interface_mounted_join
 SUBTYPE OF (shape_aspect_relationship,shape_aspect);
END_ENTITY;

ENTITY packaged_connector_component
    SUBTYPE OF (interface_component, packaged_component);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6322 - ISO/TS 10303-1641 Assembly module with subassembly - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5591
*)


SCHEMA Assembly_module_with_subassembly_mim;
	USE FROM Assembly_module_design_mim;	-- ISO/TS 10303-1636
  ENTITY assembly_module_component
    SUBTYPE OF (physical_component);
  END_ENTITY;
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6325 - ISO/TS 10303-1647 Assembly physical interface requirement - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5609
*)


SCHEMA Assembly_physical_interface_requirement_mim;

USE FROM Assembly_functional_interface_requirement_mim;	-- ISO/TS 10303-1635
USE FROM Layered_3d_shape_mim;	-- ISO/TS 10303-1694
USE FROM Printed_physical_layout_template_mim; -- ISO/TS 10303-1737
USE FROM product_structure_schema(specified_higher_usage_occurrence);

  TYPE apir_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (predefined_requirement_view_definition,
    shape_aspect); 
  END_TYPE; 

  TYPE apir_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (protocol_physical_layer_definition); 
  END_TYPE; 

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6328 - ISO/TS 10303-1648 Assembly physical requirement allocation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3892
*)
SCHEMA Assembly_physical_requirement_allocation_mim;

	USE FROM Assembly_physical_interface_requirement_mim;	-- ISO/TS 10303-1647
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
	USE FROM Discrete_shield_mim;	-- ISO/TS 10303-1744

TYPE apra_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (shape_aspect,
     product_definition);
END_TYPE;

TYPE apra_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (product_definition, 
	shape_aspect); 
END_TYPE; 

ENTITY electromagnetic_compatibility_requirement_allocation
  SUPERTYPE OF (assembly_shield_allocation)
  SUBTYPE OF (requirement_assignment);
END_ENTITY;

ENTITY assembly_shield_allocation
  SUBTYPE OF (electromagnetic_compatibility_requirement_allocation);
END_ENTITY;

ENTITY thermal_requirement_allocation
  SUBTYPE OF (requirement_assignment);
END_ENTITY;

END_SCHEMA;

(*
   N - ISO/CD-TS - 10303- assembly_shape - EXPRESS MIM*)

SCHEMA Assembly_shape_mim;

USE FROM Item_definition_structure_mim;  --        ISO/TS 10303-1345
USE FROM Part_shape_mim; 

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6112 - ISO/TS 10303-1026 Assembly structure - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5288
*) 


SCHEMA Assembly_structure_mim;

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

USE FROM product_structure_schema   -- ISO 10303-44
  (assembly_component_usage,
   next_assembly_usage_occurrence,
   promissory_usage_occurrence,
   quantified_assembly_component_usage,
   specified_higher_usage_occurrence); 


END_SCHEMA;  -- Assembly_structure_mim




(*
   ISO TC184/SC4/WG12 N6331 - ISO/TS 10303-1649 Assembly technology - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5612
*)
SCHEMA Assembly_technology_mim;

USE FROM Component_feature_mim;
USE FROM Requirement_assignment_mim;
USE FROM Physical_component_feature_mim;
USE FROM Component_grouping_mim;	-- ISO/TS 10303-1656
USE FROM Product_identification_extension_mim;	-- ISO/TS 10303-1738

REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (acyclic_shape_aspect_relationship);

TYPE at_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (assembly_joint);
END_TYPE;

TYPE at_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (assembly_bond_definition);
END_TYPE;

ENTITY assembly_bond_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
END_ENTITY;

ENTITY assembly_joint
  SUBTYPE OF (component_feature_joint);
WHERE
  WR1: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'ASSEMBLY_TECHNOLOGY_MIM.'+
       'ASSEMBLY_JOINT');
END_ENTITY;

ENTITY component_mating_constraint_condition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
END_ENTITY;

ENTITY connection_zone_based_assembly_joint
  SUBTYPE OF (assembly_joint);
END_ENTITY;

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N6629 - ISO/TS 10303-1311 Associative draughting elements - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5291
*)

SCHEMA Associative_draughting_elements_mim;

USE FROM Shape_property_assignment_mim; -- ISO/CD-TS 10303-1032

USE FROM Draughting_element_mim; -- ISO/CD-TS 10303-1310

USE FROM aic_associative_draughting_elements; --  ISO 10303-520

USE FROM draughting_dimension_schema(dimension_callout); --  ISO 10303-101

USE FROM product_property_definition_schema(shape_definition); -- ISO 10303-41

TYPE draughting_model_item_association_select = SELECT (
  annotation_occurrence,
  draughting_callout);
END_TYPE;

TYPE draughting_model_item_definition = EXTENSIBLE GENERIC_ENTITY SELECT (
  product_definition_shape, 
  shape_aspect, 
  shape_aspect_relationship);
END_TYPE;
  
ENTITY draughting_model_item_association
  SUBTYPE OF(item_identified_representation_usage);
  SELF\item_identified_representation_usage.definition          : draughting_model_item_definition;
  SELF\item_identified_representation_usage.used_representation : annotation_representation_select;
  SELF\item_identified_representation_usage.identified_item     : draughting_model_item_association_select;
END_ENTITY;

END_SCHEMA;  
(*
ISO TC184/SC4/WG12 N6864 - ISO/TS 10303-1132 Associative text - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5294
*) 


SCHEMA Associative_text_mim;

USE FROM Appearance_assignment_mim;    -- ISO/TS 10303-1001

USE FROM Colour_mim;          -- ISO/TS 10303-1002

USE FROM Text_appearance_mim; -- ISO/CD-TS 10303-1136

USE FROM presentation_definition_schema(
	annotation_occurrence,
	annotation_text,
	annotation_text_occurrence,
	annotation_curve_occurrence,
	text_string_representation);
	
USE FROM presentation_organization_schema(
	annotation_representation_select);
	
USE FROM presentation_appearance_schema(   -- ISO 10303-46
    box_height,
	curve_style,
	presentation_style_assignment,
	text_style_for_defined_font,
    text_style_with_box_characteristics,
    text_style_with_mirror);

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N3020 - ISO/TS 10303-1246 Attribute classification - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2256
*) 


SCHEMA Attribute_classification_mim;

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM classification_schema   -- ISO 10303-54
  (class); 

USE FROM management_resources_schema   -- ISO 10303-41
  (attribute_classification_assignment); 


TYPE attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_attribute_classification_assignment
  SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : class;
  items : SET[1:?] OF attribute_classification_item;
END_ENTITY;

END_SCHEMA;  -- Attribute_classification_mim

(*
 ISO TC184/SC4/WG12 N7191 - ISO/TS 10303-1801 B_spline_geometry - EXPRESS MIM
*)

SCHEMA B_spline_geometry_mim;

USE FROM Basic_geometry_mim; -- ISO/TS 10303-1652


USE FROM geometry_schema    -- ISO 10303-42
(b_spline_curve,
 b_spline_surface,
 bezier_curve,
 bezier_surface,
 quasi_uniform_curve,
 quasi_uniform_surface,
 rational_b_spline_curve,
 rational_b_spline_surface, 
 uniform_curve,
 uniform_surface);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6334 - ISO/TS 10303-1650 Bare die - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5615
*)
SCHEMA Bare_die_mim;

--	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051
	USE FROM Non_feature_shape_element_mim; 

	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Part_feature_function_mim;	-- ISO/TS 10303-1712
	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705

ENTITY bare_die
 SUBTYPE OF (physical_unit);
END_ENTITY;

ENTITY bare_die_bottom_surface
 SUBTYPE OF (bare_die_surface);
END_ENTITY;

ENTITY bare_die_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
   SELF\shape_aspect_relationship.relating_shape_aspect : edge_segment_vertex;
   SELF\shape_aspect_relationship.related_shape_aspect  : edge_segment_vertex;
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;

ENTITY bare_die_edge_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SELF\shape_aspect.product_definitional;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\bare_die_edge_surface ||
       SELF\bare_die_surface)) = 0;
END_ENTITY;

ENTITY bare_die_surface
 ABSTRACT SUPERTYPE OF (ONEOF( bare_die_bottom_surface, 
                         bare_die_top_surface, 
                        bare_die_edge_surface))
 SUBTYPE OF (part_mounting_feature);
   SELF\shape_aspect.of_shape : bare_die;
 WHERE
   WR1: SELF\shape_aspect.product_definitional;
END_ENTITY;

ENTITY bare_die_terminal
  SUBTYPE OF (minimally_defined_bare_die_terminal, placed_feature);
END_ENTITY;

ENTITY bare_die_template_terminal
  SUBTYPE OF (part_feature_template_definition, shape_aspect);
END_ENTITY;

ENTITY bare_die_top_surface
 SUBTYPE OF (bare_die_surface);
WHERE
  WR1: SELF\shape_aspect.product_definitional;
  WR2: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_aspect ||
       SELF\part_mounting_feature ||
       SELF\bare_die_top_surface ||
       SELF\bare_die_surface)) = 0;
END_ENTITY;

ENTITY minimally_defined_bare_die_terminal
  SUPERTYPE OF (bare_die_terminal)
  SUBTYPE OF (shape_aspect);
    SELF\shape_aspect.of_shape : bare_die;
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N7230 - ISO/TS 10303-1651 Basic curve - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6867
*)


SCHEMA Basic_curve_mim;
	USE FROM Basic_geometry_mim;	-- ISO/TS 10303-1652
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128

	USE FROM geometry_schema
		(circle,
		trimmed_curve,
		line,
		composite_curve,
		composite_curve_segment,
		pcurve,
		surface_curve);
	
TYPE bc_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (trimmed_curve);
END_TYPE;
	
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6217 - ISO/TS 10303-1773 Basic data representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5297
*)
(* UNDER DEVELOPMENT *)
SCHEMA Basic_data_representation_mim;

USE FROM Extended_date_mim; -- ISO/TS 10303-1776

USE FROM Foundation_representation_mim; -- ISO/TS 10303-1006

USE FROM iso13584_expressions_schema -- ISO 13584-20
  (boolean_literal,
  int_literal,
  slash_expression,
  real_literal); 

USE FROM iso13584_generic_expressions_schema
  (binary_generic_expression);

USE FROM mathematical_functions_schema  -- ISO 10303-50
  (logical_literal);

  ENTITY boolean_representation_item
    SUBTYPE OF (representation_item, boolean_literal);
  END_ENTITY;

  ENTITY date_representation_item
    SUBTYPE OF (representation_item, date);
  END_ENTITY;

  ENTITY date_time_representation_item
    SUBTYPE OF (representation_item, date_and_time);
  END_ENTITY;

  ENTITY integer_representation_item
    SUBTYPE OF (representation_item, int_literal);
  END_ENTITY;

  ENTITY logical_representation_item
    SUBTYPE OF (representation_item, logical_literal);
  END_ENTITY;
 
  ENTITY rational_representation_item
    SUBTYPE OF (representation_item, slash_expression);
    WHERE 
      WR1: SIZEOF( QUERY( operand <* SELF\binary_generic_expression.operands | 
        NOT('ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(operand)))) = 0;
  END_ENTITY;

  ENTITY real_representation_item
    SUBTYPE OF (representation_item, real_literal);
  END_ENTITY;

  SUBTYPE_CONSTRAINT representation_item_subtypes FOR representation_item; 
	(ONEOF (boolean_representation_item,
      date_representation_item,
      date_time_representation_item,
      integer_representation_item,
      logical_representation_item,
      rational_representation_item,
      real_representation_item));
  END_SUBTYPE_CONSTRAINT;

END_SCHEMA;
(*
  ISO TC184/SC4/WG12 N6873 - ISO/TS 10303-1323 Basic geometric topology - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N5300
*)

SCHEMA Basic_geometric_topology_mim;

USE FROM Basic_geometry_mim;  -- ISO/TS 10303-1652

USE FROM Elemental_topology_mim; -- ISO/TS 10303-1005

USE FROM topology_schema  -- ISO 10303-42
      (edge_curve,
      face_surface,
      poly_loop,
      vertex_point); 

END_SCHEMA;

(*
ISO TC184/SC4/WG12 N7194 - ISO/TS 10303-1652 Basic geometry - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6870
*) 


SCHEMA Basic_geometry_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM geometry_schema   -- ISO 10303-42
  (bounded_curve,
  bounded_surface,
  circle,
  conic,
  conical_surface,
  curve,
  cylindrical_surface,
  ellipse,
  hyperbola,
  line,
  oriented_surface,
  parabola,
  plane,
  point_on_curve,
  point_on_surface,
  surface,
  surface_of_linear_extrusion,
  surface_of_revolution,
  swept_surface,
  toroidal_surface); 


END_SCHEMA;  -- Basic_geometry_mim

(*
 ISO TC184/SC4/WG12 N5306 - ISO/TS 10303-1369 Binary representation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4670
*)

SCHEMA Binary_representation_mim; 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM representation_schema
  (binary_representation_item,
  bytes_representation_item);

END_SCHEMA;  

(*
   ISO TC184/SC4/WG12 N6337 - ISO/TS 10303-1653 Cable - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5618
*)
SCHEMA Cable_mim;

	USE FROM Assembly_module_with_packaged_connector_component_mim;	-- ISO/TS 10303-1645

ENTITY cable_terminal
  SUBTYPE OF (shape_aspect);
    SELF\shape_aspect.of_shape : cable_usage_view;
END_ENTITY;

ENTITY cable_usage_view
 SUBTYPE OF (physical_unit);
END_ENTITY;

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N6623 - ISO/TS 10303-1316 Camera view 3d - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5309
*)

SCHEMA Camera_view_3d_mim;

USE FROM Basic_geometry_mim; -- ISO/TS 10303-1652
USE FROM Colour_mim; -- ISO/TS 10303-1002
USE FROM Presentation_hierarchy_mim; -- ISO/CD-TS 10303-1330

USE FROM presentation_organization_schema    --  ISO 10303-46
  (camera_image,
   camera_model_d3,
   camera_model_d3_multi_clipping,
   camera_model_d3_multi_clipping_intersection,
   camera_model_d3_multi_clipping_union,
   camera_model_d3_with_hlhsr,
   camera_model_with_light_sources,
   camera_image_3d_with_scale,
   view_volume);

USE FROM presentation_appearance_schema  -- ISO 10303-46
  (context_dependent_over_riding_styled_item);
  

  ENTITY hidden_element_over_riding_styled_item 
    SUBTYPE OF (context_dependent_over_riding_styled_item);
      SELF\context_dependent_over_riding_styled_item.style_context : LIST [1:1] OF presentation_view; 
      SELF\styled_item.item                                        : camera_image;
    INVERSE
      container : SET[1:?] OF presentation_view FOR items; 
    WHERE
      WR1:  'PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL_D3_WITH_HLHSR' IN TYPEOF
                (SELF.item\mapped_item.mapping_source.mapping_origin);
  END_ENTITY;          


END_SCHEMA;
(*
ISO TC184/SC4/WG12 N1148 - ISO/TS 10303-1044 Certification - EXPRESS MIM
*) 


SCHEMA Certification_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (role_association,
   role_select); 

USE FROM certification_schema   -- ISO 10303-41
  (certification,
   certification_type); 

USE FROM management_resources_schema   -- ISO 10303-41
  (certification_assignment); 


TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_certification_assignment
  SUBTYPE OF (certification_assignment);
  items : SET[1:?] OF certification_item;
END_ENTITY;

END_SCHEMA;  -- Certification_mim
(*
   N - ISO/CD-TS - 10303- change_management - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Change_management_mim;

USE FROM Approval_mim;	-- ISO/TS 10303-1012
USE FROM Basic_data_representation_mim;	-- ISO/TS 10303-1773
USE FROM Product_version_relationship_mim; -- ISO/TS 10303-1020
USE FROM Support_resource_mim;

USE FROM product_definition_schema(product_definition_relationship);
USE FROM group_schema(group, group_relationship);
USE FROM management_resources_schema(group_assignment);
USE FROM representation_schema   -- ISO 10303-43
  (compound_item_definition,
   compound_representation_item,
   representation,
   list_representation_item); 
USE FROM product_property_definition_schema
  (characterized_object);   

TYPE cm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
  (frozen_assignment);
END_TYPE;

TYPE previous_element_assignment_select = SELECT (modify_element, delete_element);
END_TYPE;

TYPE current_element_assignment_select = SELECT (modify_element, add_element);
END_TYPE;

TYPE change_relationship_select = EXTENSIBLE GENERIC_ENTITY SELECT (
	product_definition_formation_relationship);
END_TYPE;

TYPE change_management_object = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

TYPE location_in_aggregate_item = LIST [1:?] OF integer_representation_item;
END_TYPE;

ENTITY change_group
  SUBTYPE OF (group);
END_ENTITY;

ENTITY change_element
  ABSTRACT SUPERTYPE OF (ONEOF
	(modify_element,
     delete_element,
	 add_element))
  SUBTYPE OF (group, characterized_object);
END_ENTITY;

ENTITY modify_element
  SUBTYPE OF (change_element);
END_ENTITY;  

ENTITY delete_element
  SUBTYPE OF (change_element);
END_ENTITY;  

ENTITY add_element
  SUBTYPE OF (change_element);
END_ENTITY;  

ENTITY change_element_sequence
  SUBTYPE OF (group_relationship);
  SELF\group_relationship.relating_group RENAMED previous : change_element;
  SELF\group_relationship.related_group RENAMED next : change_element;
END_ENTITY;

ENTITY change_composition_relationship
  SUBTYPE OF (group_relationship);
  SELF\group_relationship.relating_group RENAMED composition : change_group;
  SELF\group_relationship.related_group RENAMED element : change_element;
END_ENTITY;

ENTITY change_group_assignment 
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : change_group;
  item : change_relationship_select; 
END_ENTITY;

ENTITY current_change_element_assignment 
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : current_element_assignment_select;
  items : SET [1:?] OF change_management_object; 
END_ENTITY;

ENTITY previous_change_element_assignment 
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : previous_element_assignment_select;
  items : SET [1:?] OF change_management_object; 
END_ENTITY;

ENTITY frozen_assignment 
  SUBTYPE OF (approval_assignment); 
  items : SET [1:?] OF change_management_object; 
END_ENTITY;

ENTITY location_in_aggregate_representation_item
  SUBTYPE OF (compound_representation_item);
    SELF\compound_representation_item.item_element : location_in_aggregate_item;
END_ENTITY;

SUBTYPE_CONSTRAINT cm_group_subtypes FOR group;
          ONEOF (change_group, change_element);
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT cm_group_assignment_subtypes FOR group_assignment;
          ONEOF (current_change_element_assignment, previous_change_element_assignment, change_group_assignment);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6945 - ISO/TS 10303-1654 Characteristic - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6220
*)
SCHEMA Characteristic_mim;
  USE FROM Basic_data_representation_mim;  -- ISO/TS 10303-1773
  USE FROM Document_assignment_mim;	-- ISO/TS 10303-1122
  USE FROM Extended_measure_representation_mim;	-- ISO/TS 10303-1106
  USE FROM External_library_mim; -- ISO/TS 10303-1778
  USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
  USE FROM Property_assignment_mim; -- ISO/TS 10303-1030
  USE FROM External_properties_mim;  -- ISO/TS 10303-1129 LK
  USE FROM group_schema(group);

  TYPE c_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (representation);
  END_TYPE;

  ENTITY characteristic_data_table_header
    SUBTYPE OF (general_property);
  END_ENTITY;

  ENTITY characteristic_data_column_header
    SUBTYPE OF (general_property);
  END_ENTITY;

  ENTITY characteristic_data_column_header_link
    SUBTYPE OF (general_property_relationship);
  END_ENTITY;    

  ENTITY characteristic_data_table_header_decomposition
    SUBTYPE OF (general_property_relationship);
  END_ENTITY;    

  ENTITY characteristic_type
    SUBTYPE OF (group);
  END_ENTITY;

  ENTITY null_representation_item
    SUBTYPE OF (representation_item);
  END_ENTITY;

   ENTITY range_characteristic
    SUBTYPE OF (representation, descriptive_representation_item);
    WHERE
      WR1: NOT(SELF\representation.name IN ['tolerance', 'minimum tolerance', 'maximum tolerance', 
        'nominal tolerance', 'plus minus tolerance', 'symmetrical tolerance', 'statistical tolerance']);
  END_ENTITY;

  ENTITY row_representation_item
    SUBTYPE OF(compound_representation_item);
      SELF\compound_representation_item.item_element : list_representation_item;
  END_ENTITY;

  ENTITY table_representation_item
    SUBTYPE OF (compound_representation_item);
    WHERE
      WR1: SIZEOF(QUERY(itet <* SELF\compound_representation_item.item_element |
        NOT('CHARACTERISTIC_MIM.ROW_REPRESENTATION_ITEM' IN TYPEOF(itet))
            )) = 0;
  END_ENTITY; 

  SUBTYPE_CONSTRAINT c_compound_representation_item_subtypes FOR compound_representation_item; 
	(ONEOF (row_representation_item,
	  table_representation_item));
  END_SUBTYPE_CONSTRAINT;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6885 - ISO/TS 10303-1765 Characterizable object - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4297
*)

SCHEMA Characterizable_object_mim;

USE FROM Support_resource_mim;
USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object);

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- characterized_representation - EXPRESS MIM
*)

SCHEMA Characterized_representation_mim;

USE FROM Characterizable_object_mim; -- ISO/TS 10303-1765
USE FROM Elemental_geometric_shape_mim; -- ISO/TS 10303-1004
USE FROM Foundation_representation_mim;  -- ISO/TS 10303-1006
USE FROM Property_assignment_mim; -- ISO/TS 10303-1030
USE FROM product_property_representation_schema(  -- ISO 10303-41
  characterized_item_within_representation,
  characterized_chain_based_item_within_representation);

ENTITY characterized_representation 
  SUBTYPE OF (representation, characterized_object);
DERIVE  
  SELF\characterized_object.name : label := SELF\representation.name;
  SELF\characterized_object.description : text := SELF\representation.description;
END_ENTITY;
 
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6948 - ISO/TS 10303-1655 Chemical substance - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6223
*)


SCHEMA Chemical_substance_mim;
USE FROM Assembly_structure_mim;	-- ISO/TS 10303-1026
USE FROM Generic_material_aspects_mim;	-- ISO/TS 10303-1681		
USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
USE FROM Person_organization_assignment_mim; -- ISO/TS 10303-1013
USE FROM Product_view_definition_relationship_mim; -- ISO/TS 10303-1041
USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 

USE FROM material_property_definition_schema
	(product_material_composition_relationship);

USE FROM product_structure_schema
	(make_from_usage_option);
		
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N3023 - ISO/TS 10303-1070 Class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2259
*) 


SCHEMA Class_mim;

USE FROM classification_schema   -- ISO 10303-54
  (class,
   class_by_extension,
   class_by_intension); 

USE FROM group_schema   -- ISO 10303-41
  (group); 


END_SCHEMA;  -- Class_mim

(* 
 ISO TC184/SC4/WG12 N3249 - ISO/TS 10303-1114 Classification assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2230 
*)

SCHEMA Classification_assignment_mim;

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 


TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_classification_assignment
  SUBTYPE OF (classification_assignment);
  items : SET[1:?] OF classification_item;
END_ENTITY;

END_SCHEMA;  -- Classification_assignment_mim

(*

 ISO TC184/SC4/WG12 N5318 - ISO/CD-TS 10303-1111 Classification with attributes - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4965
*)


SCHEMA Classification_with_attributes_mim;

USE FROM Classification_assignment_mim;

USE FROM Extended_measure_representation_mim;

USE FROM Identification_assignment_mim;

USE FROM Independent_property_mim;

USE FROM Plib_class_reference_mim;

USE FROM Product_view_definition_mim;

USE FROM group_schema(
	group,
      group_relationship);

USE FROM product_property_definition_schema(
      characterized_object,
	general_property,
	general_property_association,
	property_definition);

USE FROM product_property_representation_schema(
	property_definition_representation);

USE FROM representation_schema(
	set_representation_item);

USE FROM management_resources_schema(classification_role); 

TYPE classification_item_extended = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	characterized_class,
    classified_item);
END_TYPE;

TYPE classification_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
  (class);
END_TYPE;

TYPE classification_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
  (class);
END_TYPE;

TYPE classified_item = EXTENSIBLE GENERIC_ENTITY SELECT (product, product_definition_formation, product_definition);
END_TYPE;

TYPE cwa_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (characterized_class);
END_TYPE;

ENTITY characterized_class
SUBTYPE OF (characterized_object, class);
END_ENTITY;

ENTITY class_system 
SUBTYPE OF (group); 
END_ENTITY; 


RULE restrict_classification_assignments FOR (applied_classification_assignment);
WHERE
WR1: SIZEOF(QUERY(aia <* applied_classification_assignment | 
		NOT class_assignment_is_valid(aia)))=0;
END_RULE;

FUNCTION class_assignment_is_valid (aia: applied_classification_assignment): BOOLEAN;
LOCAL
  item: classification_item;
  role: classification_role;
END_LOCAL;

role:= aia\classification_assignment.role;
IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS_SYSTEM' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
  IF(role\classification_role.name <> 'class system membership') THEN
    RETURN(FALSE);
  END_IF;
  REPEAT i:=LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
    item:= aia\applied_classification_assignment.items[i];

    IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.CHARACTERIZED_CLASS'] * TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a class_system
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CHARACTERIZED_CLASS' IN TYPEOF(aia\classification_assignment.assigned_class)) THEN
  IF	NOT(role\classification_role.name IN ['definitional','non-definitional','']) THEN
    RETURN(FALSE); 
  END_IF;


  REPEAT i:=LOINDEX(aia\applied_classification_assignment.items) TO HIINDEX(aia\applied_classification_assignment.items);
    item:= aia\applied_classification_assignment.items[i];

    IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASSIFIED_ITEM'] * TYPEOF(item))=0) THEN
-- item invalid if item does not belong to the types that may have a characterized_class
	RETURN(FALSE);
    END_IF;
  END_REPEAT;
END_IF;

  IF
   (role\classification_role.name = 'definitional')
   THEN
     IF NOT
      (SIZEOF(QUERY(it <* aia\applied_classification_assignment.items | NOT
             (SIZEOF(['PRODUCT_DEFINITION_SCHEMA.PRODUCT', 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION', 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION'] * TYPEOF(it)) = 1)
      )) = 0 )
      THEN
      RETURN(FALSE); 
     END_IF;
  END_IF;

RETURN(TRUE);
END_FUNCTION;

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship); 
WHERE 
WR1: SIZEOF( QUERY( gr <* group_relationship | 
  (gr\group_relationship.name = 'class hierarchy') AND 
  (NOT('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN TYPEOF(gr\group_relationship.related_group)) OR 
  NOT('CLASSIFICATION_WITH_ATTRIBUTES_MIM.CLASS' IN TYPEOF(gr\group_relationship.relating_group))) )) = 0; 
END_RULE; 

END_SCHEMA;

(*
ISO TC184/SC4/WG12 N4243 - ISO/TS 10303-1002 Colour - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N655
*)

SCHEMA Colour_mim;
  USE FROM external_reference_schema -- ISO 10303-41
      (externally_defined_item);
  USE FROM presentation_resource_schema -- ISO 10303-46
      (colour,
       colour_rgb,
       colour_specification,
       draughting_pre_defined_colour,
       pre_defined_colour);
  USE FROM support_resource_schema -- ISO 10303-41
      (identifier);

 ENTITY externally_defined_colour
  SUBTYPE OF (colour_specification,externally_defined_item);
END_ENTITY; -- externally_defined_colour

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6340 - ISO/TS 10303-1657 Component feature - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5624
*)
SCHEMA Component_feature_mim;

USE FROM Assembly_component_mim;
USE FROM Assembly_shape_mim;

TYPE cf_groupable_item = SELECT BASED_ON groupable_item WITH 
   (component_feature);
END_TYPE; 

ENTITY component_feature
  SUBTYPE OF (shape_aspect);
    SELF\shape_aspect.of_shape : assembly_component;
END_ENTITY;

ENTITY component_feature_joint
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
    SELF\shape_aspect_relationship.relating_shape_aspect : component_feature;
    SELF\shape_aspect_relationship.related_shape_aspect  : component_feature;    
END_ENTITY;

ENTITY component_feature_relationship
  SUBTYPE OF (shape_aspect_relationship);
    SELF\shape_aspect_relationship.relating_shape_aspect : component_feature;
    SELF\shape_aspect_relationship.related_shape_aspect  : component_feature;    
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
END_ENTITY; 

ENTITY component_terminal
  SUBTYPE OF (component_feature);
END_ENTITY;

ENTITY make_from_feature_relationship
 SUBTYPE OF (component_feature_relationship);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6954 - ISO/TS 10303-1656 Component grouping - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6343
*)
SCHEMA Component_grouping_mim;

USE FROM Assembly_component_mim;	-- ISO/TS 10303-1691
REFERENCE FROM product_definition_schema
    (acyclic_product_definition_relationship);



ENTITY array_placement_group
  SUPERTYPE OF (ONEOF(linear_array_placement_group_component,
                      rectangular_array_placement_group_component))
  SUBTYPE OF (assembly_group_component);
END_ENTITY;

ENTITY assembly_group_component
  SUBTYPE OF (assembly_component);
END_ENTITY;

ENTITY assembly_group_component_definition_placement_link
  SUBTYPE OF (product_definition,product_definition_relationship);
   SELF\product_definition_relationship.relating_product_definition : assembly_component;  
   SELF\product_definition_relationship.related_product_definition  : assembly_component;
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: acyclic_product_definition_relationship (SELF,
      [SELF\product_definition_relationship.related_product_definition],
      'COMPONENT_GROUPING_MIM.ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK');
END_ENTITY; 

ENTITY interfaced_group_component
  SUBTYPE OF (assembly_group_component);
END_ENTITY;

ENTITY linear_array_component_definition_link
  SUBTYPE OF (product_definition,product_definition_relationship);
    SELF\product_definition_relationship.relating_product_definition : linear_array_placement_group_component;  
    SELF\product_definition_relationship.related_product_definition : linear_array_placement_group_component;
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
  WR2: acyclic_product_definition_relationship (SELF,
      [SELF\product_definition_relationship.related_product_definition],
      'COMPONENT_GROUPING_MIM.LINEAR_ARRAY_COMPONENT_DEFINITION_LINK');       
END_ENTITY; 

ENTITY linear_array_placement_group_component
  SUBTYPE OF (array_placement_group);
END_ENTITY;

ENTITY rectangular_array_placement_group_component
  SUBTYPE OF (array_placement_group);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6882 - ISO/TS 10303-1767 Composite constituent shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5321
*)
SCHEMA Composite_constituent_shape_mim;

USE FROM Advanced_boundary_representation_mim; -- ISO/TS 10303-1514

USE FROM Construction_geometry_mim; -- ISO/TS 10303-1131

USE FROM Constructive_solid_geometry_3d_mim; -- ISO/TS 10303-1068

USE FROM Curve_swept_solid_mim; -- ISO/TS 10303-1659

USE FROM Edge_based_wireframe_mim; -- ISO/TS 10303-1501

USE FROM Elementary_boundary_representation_mim; -- ISO/TS 10303-1329

USE FROM Faceted_boundary_representation_mim; -- ISO/TS 10303-1512

USE FROM Geometrically_bounded_surface_mim; -- ISO/TS 10303-1507

USE FROM Geometrically_bounded_wireframe_mim; -- ISO/TS 10303-1510

USE FROM Manifold_surface_mim; -- ISO/TS 10303-1509

USE FROM Shell_based_wireframe_mim; -- ISO/TS 10303-1502

USE FROM Value_with_unit_extension_mim; -- ISO/TS 10303-1753

USE FROM product_property_representation_schema(shape_representation_relationship);

  ENTITY beveled_sheet_representation
    SUBTYPE OF (shape_representation);
  END_ENTITY;

  ENTITY composite_sheet_representation
    SUBTYPE OF (shape_representation);
    WHERE
      WR1: SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_SURFACE.' +
        'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION',
        'AIC_MANIFOLD_SURFACE.' +
        'MANIFOLD_SURFACE_SHAPE_REPRESENTATION'] * TYPEOF (SELF)) = 1;
  END_ENTITY;

  ENTITY flat_pattern_ply_representation_relationship
    SUBTYPE OF (shape_representation_relationship);
    WHERE
      WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN
        (TYPEOF (SELF\representation_relationship.rep_1) *
         TYPEOF (SELF\representation_relationship.rep_2));
      WR2: SELF\representation_relationship.rep_1.
        context_of_items\geometric_representation_context.
        coordinate_space_dimension = 3;
  END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N6226 - ISO/TS 10303-1768 Composite material aspects - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5324
*)
SCHEMA Composite_material_aspects_mim;

USE FROM Part_and_zone_laminate_tables_mim; -- ISO/TS 10303-1770

  ENTITY composite_material_designation
    SUBTYPE OF (material_designation);
  END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N7233 - ISO/TS 10303-1525 Composite_surface - EXPRESS MIM
*)

SCHEMA Composite_surface_mim;

USE FROM Basic_geometry_mim;  -- ISO 10303-1652

USE FROM B_spline_geometry_mim; -- ISO 10303-1801 

USE FROM geometry_schema    -- ISO 10303-42
(rectangular_composite_surface,
 rectangular_trimmed_surface,
 surface_patch);

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N6762 - ISO/TS 10303-1327 Compound shape representation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5327
*)

SCHEMA Compound_shape_representation_mim;

USE FROM Edge_based_wireframe_mim; -- ISO/TS 10303-1501

USE FROM Non_manifold_surface_mim; -- ISO/CD-TS 10303-1324

  ENTITY compound_shape_representation
    SUBTYPE OF (shape_representation);
    WHERE
      WR1: ( 'GEOMETRY_SCHEMA.'+ 'GEOMETRIC_REPRESENTATION_CONTEXT'
        IN TYPEOF ( SELF.context_of_items ) ) AND (
        SELF.context_of_items\
        geometric_representation_context.coordinate_space_dimension =3 ) ;
      WR2: SIZEOF ( QUERY ( cbsr_i <* SELF.items | SIZEOF (
        ['GEOMETRIC_MODEL_SCHEMA.'+ 'EDGE_BASED_WIREFRAME_MODEL' ,
         'GEOMETRIC_MODEL_SCHEMA.'+ 'FACE_BASED_SURFACE_MODEL' ,
         'REPRESENTATION_SCHEMA.'+ 'MAPPED_ITEM' , 'GEOMETRY_SCHEMA.'+
         'AXIS2_PLACEMENT_3D']* TYPEOF ( cbsr_i ) ) <>1 ) ) =0;
      WR3: SIZEOF ( QUERY ( cbsr_i <* SELF.items | SIZEOF (
        ['GEOMETRIC_MODEL_SCHEMA.'+ 'EDGE_BASED_WIREFRAME_MODEL' ,
         'GEOMETRIC_MODEL_SCHEMA.'+ 'FACE_BASED_SURFACE_MODEL' ,
         'REPRESENTATION_SCHEMA.'+ 'MAPPED_ITEM']* TYPEOF ( cbsr_i ) ) =1 ) ) >0;
      WR4: SIZEOF ( QUERY ( cbsr_i <* SELF.items | (
         'REPRESENTATION_SCHEMA.'+ 'MAPPED_ITEM' IN TYPEOF ( cbsr_i ) )
         AND ( SIZEOF ( ['COMPOUND_SHAPE_REPRESENTATION_MIM.'+
         'COMPOUND_SHAPE_REPRESENTATION' , 'AIC_EDGE_BASED_WIREFRAME.'+
         'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' ,
         'AIC_NON_MANIFOLD_SURFACE.'+
         'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION']* TYPEOF (
         cbsr_i\ mapped_item.mapping_source ) ) <>1 ) ) ) =0;
  END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6957 - ISO/TS 10303-1756 Conductivity material aspects - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4216
*)
SCHEMA Conductivity_material_aspects_mim;

	USE FROM Classification_assignment_mim;	-- ISO/TS 10303-1114
	USE FROM Generic_material_aspects_mim;	-- ISO/TS 10303-1681
	USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
	
	TYPE cma_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
     	(material_designation);
	END_TYPE;

	ENTITY material_designation_with_conductivity_classification
		SUBTYPE OF (material_designation);
	END_ENTITY;
	
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N6118 - ISO/TS 10303-1058 Configuration effectivity - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2950
*)

SCHEMA Configuration_effectivity_mim;

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM Configuration_item_mim;    -- ISO/TS 10303-1056

USE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_effectivity); 

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041


END_SCHEMA;  -- Configuration_effectivity_mim




(*
 ISO TC184/SC4/WG12 N6032 - ISO/TS 10303-1056 Configuration item - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2533
*) 


SCHEMA Configuration_item_mim;

USE FROM configuration_management_schema   -- ISO 10303-44
  (configuration_design,
   configuration_item,
   configuration_item_relationship); 

USE FROM Product_concept_identification_mim;    -- ISO/TS 10303-1060

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


ENTITY configuration_item_hierarchical_relationship
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

ENTITY configuration_item_revision_sequence
  SUBTYPE OF (configuration_item_relationship);
END_ENTITY;

END_SCHEMA;  -- Configuration_item_mim
(*
   ISO TC184/SC4/WG12 N3922 - ISO/TS 10303-1658 Connectivity allocation to physical network - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3376
*)


SCHEMA Connectivity_allocation_to_physical_network_mim;
	USE FROM Functional_decomposition_with_nodal_representation_to_packaged_mapping_mim;	-- ISO/TS 10303-1678
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
END_SCHEMA;

(*
ISO TC184/SC4/WG12 N5330 - ISO/TS 10303-1131 Construction geometry - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4935
*) 

SCHEMA Construction_geometry_mim;

USE FROM Basic_curve_mim;    -- ISO/TS 10303-1651;

USE FROM aic_topologically_bounded_surface;    -- ISO 10303-511

USE FROM geometry_schema   -- ISO 10303-42
  (b_spline_curve,
   b_spline_surface,
   circle,
   composite_curve,
   conical_surface,
   curve,
   curve_bounded_surface,
   curve_replica,
   cylindrical_surface,
   degenerate_pcurve,
   ellipse,
   hyperbola,
   line,
   offset_curve_2d,
   offset_curve_3d,
   offset_surface,
   oriented_surface,
   parabola,
   pcurve,
   placement,
   plane,
   point_on_curve,
   point_on_surface,
   point_replica,
   polyline,
   rectangular_composite_surface,
   rectangular_trimmed_surface,
   spherical_surface,
   surface,
   surface_curve,
   surface_of_linear_extrusion,
   surface_of_revolution,
   surface_replica,
   toroidal_surface,
   trimmed_curve); 

USE FROM representation_schema   -- ISO 10303-43
  (mapped_item,
   representation,
   representation_map,
   representation_relationship); 

USE FROM topology_schema   -- ISO 10303-42
  (edge_curve,
   face_surface,
   vertex_point); 

  TYPE constructive_geometry_representation_or_shape_represenation = SELECT
    (constructive_geometry_representation,
    shape_representation);
  END_TYPE;


  ENTITY constructive_geometry_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: ('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 <= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension <= 3});
      WR2: SIZEOF( QUERY( cgr_i <* SELF.items | SIZEOF(['CONSTRUCTION_GEOMETRY_MIM.PLACEMENT', 'CONSTRUCTION_GEOMETRY_MIM.CURVE', 'CONSTRUCTION_GEOMETRY_MIM.EDGE', 'CONSTRUCTION_GEOMETRY_MIM.FACE', 'CONSTRUCTION_GEOMETRY_MIM.POINT', 'CONSTRUCTION_GEOMETRY_MIM.SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.FACE_SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.VERTEX_POINT'] * TYPEOF(cgr_i)) <> 1 )) = 0;
      WR3: SIZEOF( USEDIN( SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) > 0;
      WR4: SIZEOF( USEDIN( SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0;
  END_ENTITY;

  ENTITY constructive_geometry_representation_relationship
    SUBTYPE OF (representation_relationship);
      SELF\representation_relationship.rep_1 : constructive_geometry_representation_or_shape_represenation;    
      SELF\representation_relationship.rep_2 : constructive_geometry_representation;    
    WHERE
      WR1: (SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items));
      WR2: NOT('CONSTRUCTION_GEOMETRY_MIM.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF));
  END_ENTITY;

END_SCHEMA;  
(*
   ISO TC184/SC4/WG12 N6951 - ISO/TS 10303-1731 Constructive solid geometry 2d - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6346
*) 


SCHEMA Constructive_solid_geometry_2d_mim;

  USE FROM Area_2d_mim;	-- ISO/TS 10303-1631	
  USE FROM Basic_curve_mim; -- ISO/TS 10303-1651
  USE FROM representation_schema (
    compound_representation_item,
    mapped_item,
    set_representation_item);
  USE FROM geometric_model_schema (
    boolean_result,
    bounded_primitive_2d,
    csg_solid,
    half_space_2d,
    area_with_outer_boundary);
  USE FROM geometry_schema (
    composite_curve);

  TYPE csg2d_bounded_primitive_2d = SELECT BASED_ON bounded_primitive_2d WITH (
    path_area_with_parameters);
  END_TYPE;

  TYPE boolean_operand_2d = SELECT (
    bounded_primitive_2d,
    boolean_result_2d);
  END_TYPE; 

  TYPE compound_inner_area_boundary = SELECT (
    set_inner_area_boundary);
  END_TYPE;
  
  TYPE csg_2d_area_select = SELECT (
    axis2_placement_2d, 
    csg_primitive_solid_2d);
  END_TYPE;

  TYPE csg_2d_shape_select = SELECT (
    mapped_item, 
    axis2_placement_2d, 
    csg_solid_2d);
  END_TYPE;

  TYPE csg_select_2d = SELECT (
    bounded_primitive_2d, 
    boolean_result_2d);
  END_TYPE;

  TYPE set_inner_area_boundary = SET [1:?] OF bounded_primitive_2d;
  END_TYPE;

  ENTITY boolean_result_2d
    SUBTYPE OF (boolean_result);
     SELF\boolean_result.first_operand : boolean_operand_2d;
     SELF\boolean_result.second_operand : boolean_operand_2d;
  END_ENTITY;

  ENTITY closed_curve_style_parameters
    SUBTYPE OF(curve_style_parameters_representation);
  END_ENTITY;  

  ENTITY complex_area
    ABSTRACT SUPERTYPE OF (path_area_with_parameters ANDOR primitive_2d_with_inner_boundary)
    SUBTYPE OF (primitive_2d);
  END_ENTITY;

  ENTITY csg_primitive_solid_2d
    SUBTYPE OF (csg_solid_2d);
    SELF\csg_solid.tree_root_expression : bounded_primitive_2d;
  END_ENTITY;  

  ENTITY csg_solid_2d
    SUBTYPE OF (csg_solid);
    SELF\csg_solid.tree_root_expression : csg_select_2d; 
   WHERE
     WR1: valid_csg_2d_primitives(SELF);
  END_ENTITY;
  
  ENTITY csg_2d_shape_representation
    SUBTYPE OF (shape_representation);
      SELF\representation.items : SET[1:?] OF csg_2d_shape_select;  
   WHERE 
     WR1: SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
     WR2: SIZEOF(QUERY ( it <* SELF.items | 
       (SIZEOF(['GEOMETRIC_MODEL_SCHEMA.CSG_SOLID']
  	   * TYPEOF(it)) = 1) 
  	   OR 
	   (('REPRESENTATION_SCHEMA.MAPPED_ITEM' 
	   IN TYPEOF(it)) AND
	   ('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.' +
	   'CSG_2D_SHAPE_REPRESENTATION' 
	   IN TYPEOF(it\mapped_item.mapping_source.mapped_representation))) 
       )) >= 1;
     WR3: SIZEOF(QUERY ( it <* SELF.items | 
       (('REPRESENTATION_SCHEMA.MAPPED_ITEM' 
       IN TYPEOF(it)) AND (NOT (( 
       'CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.' +
       'CSG_2D_SHAPE_REPRESENTATION') 
       IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))) )) = 0;
     -- TODO does not work with the new introduced subtypes  
     -- WR4: SIZEOF(TYPEOF(SELF) - TYPEOF(SELF\shape_representation ||
     --  SELF\csg_2d_shape_representation || SELF\representation)) = 0;
  END_ENTITY;

ENTITY curve_style_parameters_representation
  SUBTYPE OF(representation);
END_ENTITY;  

ENTITY curve_style_parameters_with_ends
  SUBTYPE OF(curve_style_parameters_representation);
END_ENTITY;  

ENTITY path_area_with_parameters
  SUBTYPE OF (complex_area, mapped_item);
  WHERE
    WR1: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF\mapped_item.mapping_target);
      -- the mapping source must be a curve (open or closed)
      -- no the mapping target must be a curve (open or closed)
    --wr2: -- the mapping_source.mapped_representation must be curve_style_parameters_representation;
    WR2: 'CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.CURVE_STYLE_PARAMETERS_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source\representation_map.mapped_representation);
    WR3: SELF\mapped_item.mapping_source\representation_map.mapping_origin\representation_item.name = 'curve width';
              --don't reall care on mapping_source.mapping_origin. Best to make it the line-width
END_ENTITY;

  ENTITY primitive_2d_with_inner_boundary
    SUBTYPE OF (complex_area, compound_representation_item);
      SELF\compound_representation_item.item_element RENAMED inner_boundary : compound_inner_area_boundary;
    WHERE
      WR1: SIZEOF(['GEOMETRIC_MODEL_SCHEMA.CIRCULAR_AREA', 
                   'GEOMETRIC_MODEL_SCHEMA.ELLIPTIC_AREA', 
                   'GEOMETRIC_MODEL_SCHEMA.RECTANGULAR_AREA',
                   'GEOMETRIC_MODEL_SCHEMA.POLYGONAL_AREA', 
                   'GEOMETRIC_MODEL_SCHEMA.AREA_WITH_OUTER_BOUNDARY', 
                   'CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.PATH_AREA_WITH_PARAMETERS'] * TYPEOF(SELF)) > 0;
      WR2: SIZEOF(QUERY(inner <* inner_boundary |
        'CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.PRIMITIVE_2D_WITH_INNER_BOUNDARY' IN TYPEOF(inner))) = 0;
      WR3: open_path_based_inner_boundary(inner_boundary);
  END_ENTITY;

  ENTITY single_area_csg_2d_shape_representation
    SUBTYPE OF (csg_2d_shape_representation);
    SELF\representation.items : SET[1:?] OF csg_2d_area_select;
  WHERE  
    WR1: SIZEOF (QUERY (it <* SELF.items| 
     ('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.MAPPED_ITEM' 
     IN TYPEOF(it)) )) = 0;
    WR2: SIZEOF (QUERY (it <* SELF.items| 
     ('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.CSG_SOLID_2D' 
     IN TYPEOF(it)) )) = 1;
  END_ENTITY;

  ENTITY single_boundary_csg_2d_shape_representation
    SUBTYPE OF (single_area_csg_2d_shape_representation);
    WHERE
      WR1: SIZEOF(QUERY ( it <* SELF.items |
        (('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.CSG_PRIMITIVE_SOLID_2D' IN TYPEOF(it))
        AND (('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.PRIMITIVE_2D_WITH_INNER_BOUNDARY') IN
        TYPEOF(it\csg_primitive_solid_2d.tree_root_expression))) )) = 0;
  END_ENTITY;

FUNCTION valid_csg_2d_primitives (input : csg_solid_2d) : BOOLEAN;
CASE TRUE OF
  ('GEOMETRIC_MODEL_SCHEMA.PRIMITIVE_2D' IN TYPEOF(input\csg_solid_2d.tree_root_expression)) :
  BEGIN
    IF (SIZEOF(['GEOMETRIC_MODEL_SCHEMA.CIRCULAR_AREA', 
       'CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.COMPLEX_AREA',
       'GEOMETRIC_MODEL_SCHEMA.ELLIPTIC_AREA',
       'GEOMETRIC_MODEL_SCHEMA.POLYGONAL_AREA',
       'CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.PRIMITIVE_2D_WITH_INNER_BOUNDARY',
       'GEOMETRIC_MODEL_SCHEMA.RECTANGULAR_AREA'] * TYPEOF(input\csg_solid_2d.tree_root_expression)) > 0)
    THEN 
           RETURN(TRUE);
    ELSE
           RETURN(FALSE);
    END_IF;
  END;

  ('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.BOOLEAN_RESULT_2D' IN TYPEOF(input\csg_solid_2d.tree_root_expression)) : 
    RETURN (valid_csg_2d_primitives(input\csg_solid_2d.tree_root_expression\boolean_result_2d.first_operand) 
        AND valid_csg_2d_primitives(input\csg_solid_2d.tree_root_expression\boolean_result_2d.second_operand));

  ('GEOMETRIC_MODEL_SCHEMA.HALF_SPACE_2D' IN TYPEOF(input\csg_solid_2d.tree_root_expression)) : RETURN(TRUE);

  OTHERWISE : RETURN(FALSE);
END_CASE;
END_FUNCTION;


FUNCTION open_path_based_inner_boundary (input : SET OF primitive_2d) : BOOLEAN;
  LOCAL
   pass : BOOLEAN := TRUE;
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF(input);
      IF ('CONSTRUCTIVE_SOLID_GEOMETRY_2D_MIM.PATH_AREA_WITH_PARAMETERS' IN TYPEOF(input[i]))
        AND ( 
         ('GEOMETRY_SCHEMA.CIRCLE' IN TYPEOF(input[i]\mapped_item.mapping_source\representation_map.mapping_origin))
          OR
          (('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF(input[i]\mapped_item.mapping_source\representation_map.mapping_origin))
           AND
            (input[i]\mapped_item.mapping_source\representation_map.mapping_origin\composite_curve.closed_curve = TRUE) 
          )
        )  
      THEN
       pass := FALSE;
      END_IF;
  END_REPEAT;
  RETURN(pass);                  
END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6879 - ISO/TS 10303-1068 Constructive solid geometry 3d - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6229
*) 


SCHEMA Constructive_solid_geometry_3d_mim;

USE FROM aic_csg;    -- ISO 10303-515
USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004
USE FROM Primitive_solids_mim; -- ISO/TS 10303-1801

END_SCHEMA;  -- Constructive_solid_geometry_3d_mim
(*
 ISO TC184/SC4/WG12 N7087 - ISO/TS 10303-1027 Contextual shape positioning - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6617
*)
SCHEMA Contextual_shape_positioning_mim;

USE FROM Geometric_model_relationship_mim;
USE FROM Shape_property_assignment_mim; --  ISO/TS 10303-1032

USE FROM product_property_representation_schema -- ISO 10303-41
  (context_dependent_shape_representation);

USE FROM representation_schema 	-- ISO 10303-43
      (functionally_defined_transformation,
      representation_relationship_with_transformation);

END_SCHEMA;




(*
ISO TC184/SC4/WG12 N7146 - ISO/TS 10303-1062 Contract - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6035
*) 


SCHEMA Contract_mim;

USE FROM contract_schema   -- ISO 10303-41
  (contract,
   contract_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (contract_assignment); 


TYPE contract_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_contract_assignment
  SUBTYPE OF (contract_assignment);
  items : SET[1:?] OF contract_item;
END_ENTITY;

END_SCHEMA;  -- Contract_mim
(*
   ISO TC184/SC4/WG12 N5336 - ISO/TS 10303-1775 Currency - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4691
*)

SCHEMA Currency_mim;

USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

USE FROM measure_schema;

  ENTITY currency
    ABSTRACT SUPERTYPE
    SUBTYPE OF (context_dependent_unit);
    WHERE 
      WR1: ((SELF\named_unit.dimensions.length_exponent = 0.0) AND
           (SELF\named_unit.dimensions.mass_exponent = 0.0) AND
           (SELF\named_unit.dimensions.time_exponent = 0.0) AND
           (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND
           (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND
           (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND
           (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0));
  END_ENTITY;

  ENTITY currency_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      SELF\measure_with_unit.unit_component : currency; 
  END_ENTITY;

  ENTITY iso4217_currency 
    SUBTYPE OF (currency);
  END_ENTITY; 

END_SCHEMA;
(*
	ISO TC184/SC4/WG12 N7059 - ISO/TS 10303-1003 Curve appearance - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N5339
*) 


SCHEMA Curve_appearance_mim;

USE FROM Styled_curve_mim; -- ISO/TS 10303-1749

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (curve_style,
   curve_style_font,
   draughting_pre_defined_curve_font,
   marker_select,
   marker_type,
   point_style,
   pre_defined_curve_font,
   pre_defined_marker); 

USE FROM presentation_definition_schema   -- ISO 10303-46
  (externally_defined_symbol,
   pre_defined_symbol); 

USE FROM presentation_resource_schema   -- ISO 10303-46
  (externally_defined_text_font);


USE FROM representation_schema   -- ISO 10303-43
  (mapped_item); 


  TYPE terminator = SELECT
    (externally_defined_terminator_symbol, 
     pre_defined_terminator_symbol, 
     user_defined_terminator_symbol);
  END_TYPE; 

  ENTITY externally_defined_marker
    SUBTYPE OF (externally_defined_symbol, pre_defined_marker);
  END_ENTITY;

  ENTITY externally_defined_terminator_symbol
    SUBTYPE OF (externally_defined_symbol);
  END_ENTITY;

  ENTITY pre_defined_point_marker_symbol
    SUBTYPE OF (pre_defined_marker, pre_defined_symbol);
    WHERE
      WR1: SELF.name IN ['asterisk','circle','dot','plus','square','triangle','x'];
  END_ENTITY;

  ENTITY pre_defined_terminator_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      WR1: SELF.name IN ['blanked arrow', 'blanked box', 'blanked dot', 'blanked triangle', 'dimension origin', 'filled arrow', 'filled box', 'filled dot', 'integral symbol', 'open arrow', 'slash', 'unfilled arrow', 'unfilled triangle', 'filled triangle'];
  END_ENTITY;

  ENTITY user_defined_marker
    SUBTYPE OF (mapped_item, pre_defined_marker);
  END_ENTITY;

  ENTITY user_defined_terminator_symbol
    SUBTYPE OF (mapped_item, pre_defined_symbol);
  END_ENTITY;

  ENTITY vector_style
    SUBTYPE OF (curve_style, pre_defined_terminator_symbol);
  END_ENTITY;

END_SCHEMA;  
(*
   ISO TC184/SC4/WG12 N3925 - ISO/TS 10303-1659 Curve swept solid - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3334
 *)
SCHEMA Curve_swept_solid_mim;

USE FROM Aic_curve_swept_solid;
	USE FROM Elemental_geometric_shape_mim;	-- ISO/TS 10303-1004

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1082 - ISO/TS 10303-1010 Date time - EXPRESS MIM
*)       
SCHEMA Date_time_mim;
USE FROM date_time_schema -- ISO 10303-41
  (calendar_date,
   date_and_time,
   coordinated_universal_time_offset);

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N1094 - ISO/TS 10303-1014 Date time assignment - EXPRESS MIM
*)     
SCHEMA Date_time_assignment_mim;

USE FROM Date_time_mim; 	-- 10303-1010

USE FROM date_time_schema 	-- ISO 10303-41
  (date,
   date_role,
   date_time_role);
USE FROM management_resources_schema -- ISO 10303-41
  (date_and_time_assignment,
   date_assignment);

   
TYPE date_item = EXTENSIBLE SELECT; 
END_TYPE;
   
TYPE date_and_time_item = EXTENSIBLE SELECT; 
END_TYPE;
   
ENTITY applied_date_and_time_assignment
  SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;
   
ENTITY applied_date_assignment
  SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6349 - ISO/TS 10303-1660 Datum difference based model - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5627
*)


SCHEMA Datum_difference_based_model_mim;

--	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051

	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705

	SUBTYPE_CONSTRAINT ddbm_model_parameter_subtypes FOR model_parameter; 
		ONEOF (datum_difference_based_model_parameter,
	 	schema_based_model_parameter);
	END_SUBTYPE_CONSTRAINT;
	
ENTITY datum_difference_based_model_parameter
  SUBTYPE OF (model_parameter);
END_ENTITY;

ENTITY datum_difference_functional_unit_usage_view_terminal_assignment
  SUBTYPE OF (shape_aspect_relationship);
    SELF\shape_aspect_relationship.relating_shape_aspect : datum_difference;  
    SELF\shape_aspect_relationship.related_shape_aspect  : functional_unit_terminal_definition;
END_ENTITY;
	
ENTITY datum_difference
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
  SELF\shape_aspect_relationship.relating_shape_aspect : datum;
  SELF\shape_aspect_relationship.related_shape_aspect : datum;    
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;
	
END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- default_setting_association - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Default_setting_association_mim;

USE FROM Shape_property_assignment_mim;
USE FROM Value_with_unit_extension_mim;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N4261 - ISO/TS 10303-1052 Default tolerance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2871
*) 


SCHEMA Default_tolerance_mim;

USE FROM File_identification_mim;  -- ISO/TS 10303-1127
USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006
USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118
USE FROM Default_setting_association_mim;

USE FROM representation_schema   -- ISO 10303-43
  (compound_item_definition,
   compound_representation_item,
   representation,
   set_representation_item); 

ENTITY default_tolerance_table
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF( QUERY( i <* SELF.items | NOT('DEFAULT_TOLERANCE_MIM.DEFAULT_TOLERANCE_TABLE_CELL' IN TYPEOF(i)) )) = 0;
  WR2: (SIZEOF( QUERY( rr <* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | rr.name < 'general tolerance definition' )) = 0) AND (SIZEOF( QUERY( rr <* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1') | (rr.name = 'general tolerance definition') AND (rr.rep_2.name < 'default tolerance') )) = 0) AND (SIZEOF( USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) = 0);
END_ENTITY;

ENTITY default_tolerance_table_cell
  SUBTYPE OF (compound_representation_item);
WHERE
  WR1: SIZEOF(QUERY( x <* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION.ITEMS') | 'DEFAULT_TOLERANCE_MIM.' + 'DEFAULT_TOLERANCE_TABLE' IN TYPEOF(x)))=1 ;
  WR2: default_tolerance_table_cell_wr2(SELF\compound_representation_item.item_element);
  WR3: default_tolerance_table_cell_wr3(SELF\compound_representation_item.item_element);
  WR4: default_tolerance_table_cell_wr4(SELF\compound_representation_item.item_element);
  WR5: default_tolerance_table_cell_wr5(SELF\compound_representation_item.item_element);
END_ENTITY;

FUNCTION default_tolerance_table_cell_wr2
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF SIZEOF(agg) <= 5 THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

FUNCTION default_tolerance_table_cell_wr3
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) 
  AND (i\representation_item.name = 'significant number of digits')) )) = 1) OR 
((SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'lower limit')) )) = 1) AND 
(SIZEOF( QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'upper limit')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

FUNCTION default_tolerance_table_cell_wr4
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'plus minus tolerance value')) )) = 1) OR 
((SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'lower tolerance value')) )) = 1) AND 
(SIZEOF( QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND (
  i\representation_item.name = 'upper tolerance value')) )) = 1)) THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

FUNCTION default_tolerance_table_cell_wr5
 (agg : compound_item_definition) : BOOLEAN; 
BEGIN 
IF (SIZEOF(QUERY ( i <* agg | ('DEFAULT_TOLERANCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) <= 1) AND 
(SIZEOF(QUERY ( i <* agg | ('DEFAULT_TOLERANCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) = 
  SIZEOF(QUERY ( i <* agg | (('DEFAULT_TOLERANCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i\representation_item.name = 'cell description'))) )) 
THEN 
  RETURN(TRUE); 
ELSE 
  RETURN(FALSE); 
END_IF; 
END; 
      END_FUNCTION; 

END_SCHEMA;  -- Default_tolerance_mim
(*
ISO TC184/SC4/WG12 N5345 - ISO/TS 10303-1130 Derived shape element - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4279
*)


SCHEMA Derived_shape_element_mim;

USE FROM Construction_geometry_mim;  -- ISO/TS 10303-1131

USE FROM shape_aspect_definition_schema   -- ISO 10303-47
  (apex,
   centre_of_symmetry,
   derived_shape_aspect,
   extension,
   geometric_alignment,
   geometric_intersection,
   parallel_offset,
   perpendicular_to,
   shape_aspect_deriving_relationship,
   tangent); 

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054

TYPE dse_shape_model = SELECT BASED_ON shape_model WITH (
   constructive_geometry_representation);
END_TYPE;
  
END_SCHEMA;  -- Derived_shape_element_mim
(*
 ISO TC184/SC4/WG12 N3800 - ISO/CD-TS 10303-1232 Design material aspects - EXPRESS MIM
*)

SCHEMA Design_material_aspects_mim;

USE FROM Generic_material_aspects_mim;
USE FROM Product_view_definition_mim;
USE FROM Shape_property_assignment_mim;


END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6888 - ISO/TS 10303-1628 Design product data management - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6232
*)

SCHEMA Design_product_data_management_mim;

USE FROM Characterizable_object_mim;  -- ISO/TS 10303-1765
USE FROM Classification_with_attributes_mim;	-- ISO/TS 10303-1111
USE FROM Design_material_aspects_mim;	-- ISO/TS 10303-1681
USE FROM Information_rights_mim;    -- ISO/TS 10303-1241
USE FROM Item_definition_structure_mim;	-- ISO/TS 10303-1345
USE FROM Pre_defined_product_data_management_specializations_mim; -- ISO/TS 10303-1760
USE FROM Product_data_management_mim;	-- ISO/TS 10303-1231
USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
USE FROM Requirement_view_definition_relationship_mim;	-- ISO/TS 10303-1142
USE FROM Specification_control_mim; -- ISO/CD-TS 10303-1112
USE FROM Test_select_product_mim;	-- ISO/TS 10303-1757
USE FROM Activity_method_assignment_mim;    -- ISO/TS 10303-1249
USE FROM Attribute_classification_mim; -- ISO/TS 10303-1246

USE FROM contract_schema(contract_type);
USE FROM document_schema(document_type);
USE FROM material_property_definition_schema(property_definition_relationship);
USE FROM product_definition_schema(product_definition_formation_with_specified_source);
USE FROM product_structure_schema(make_from_usage_option);
USE FROM representation_schema(parametric_representation_context);

TYPE design_pdm_action_item = SELECT BASED_ON action_items WITH (
	action,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	alternate_product_relationship,
	applied_action_assignment,
	applied_classification_assignment,
	applied_person_and_organization_assignment,
	approval_status,
	assembly_component_usage_substitute,
	certification,
	class,
	class_system,
	configuration_design,
	configuration_item,
	configured_effectivity_assignment,
	contract,
	document_file,
	general_property,
	material_designation,
	organization_relationship,
	organizational_project,
	product,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
    product_definition_formation_relationship,
	product_definition_substitute,
	property_definition,
	security_classification,
	security_classification_level,
	shape_aspect,
	shape_representation,
	versioned_action_request);
END_TYPE; 	
	

  TYPE design_pdm_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
    (product, 
     product_definition_formation);
  END_TYPE; 

  TYPE design_pdm_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_action_request_item WITH (
	action,
	action_method,
	action_property,
	action_relationship,
	alternate_product_relationship,
	assembly_component_usage_substitute,
	configuration_design,
	configuration_effectivity,
	configuration_item,
	configured_effectivity_assignment,
	document_file,
	general_property,
	material_designation,
	organizational_project,
	product,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition_substitute,
	shape_aspect,
	shape_representation,
    versioned_action_request);
  END_TYPE;

  TYPE design_pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_approval_item WITH 
    (action_directive,
     action_property,
     action_request_solution,
     applied_classification_assignment,
     certification,
     class,
     class_system,
     configuration_design,
     configuration_item,
     configured_effectivity_assignment,
     contract,
     date,
     directed_action,
     document,
     effectivity,
     executed_action,
     general_property_relationship,
     group,
     group_relationship,
     product,
     product_definition,
     product_definition_formation_relationship,
     product_definition_relationship,
     product_definition_formation,
     representation,
     requirement_assignment,
     security_classification,
     shape_aspect_relationship,
     general_property,
     material_designation,
	 organizational_project,
	 product_concept,
	 product_concept_feature,
	 product_concept_feature_association,
	 product_concept_feature_category,
	 product_concept_feature_category_usage,
	 product_definition_substitute,
	 property_definition,
	 shape_representation);
  END_TYPE;

  TYPE design_pdm_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH (
	action_directive,
	action_method,
	action_property,
	action_property_representation,
	action_relationship,
	action_request_solution,
	action_request_status,
	alternate_product_relationship,
	applied_action_assignment,
	applied_action_request_assignment,
	applied_approval_assignment,
	applied_certification_assignment,
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_effectivity_assignment,
	applied_event_occurrence_assignment,
	applied_external_identification_assignment,
	applied_identification_assignment,
	applied_person_and_organization_assignment,
	applied_organization_assignment,
	applied_organizational_project_assignment,
	approval,
	approval_person_organization,	
	approval_relationship,
	approval_status,
	certification,
	context_dependent_unit,
	contract,
	date_and_time_assignment,
	date_assignment,
	derived_unit,
	descriptive_representation_item,
	document_file,
	document_relationship,
	effectivity,
	event_occurrence_relationship,
	executed_action,
	general_property,
	general_property_relationship,
	group,
	group_relationship,
	information_right,
	information_usage_right,
	language,
	measure_representation_item,
	measure_with_unit,
	named_unit,
	organizational_address,
	organizational_project_relationship,
	organization_relationship,
	person_and_organization,
	person_and_organization_address,	
	product,
	product_category,
	product_concept,
	product_concept_context,
	product_definition,
	product_definition_context,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	property_definition_representation,
	property_definition_relationship,
	representation,
	representation_context,
	representation_item,
	security_classification,
	time_interval_relationship,
	uncertainty_measure_with_unit,
	usage_association,
	versioned_action_request);
  END_TYPE;

  TYPE design_pdm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
    (information_right,
	 information_usage_right,
     usage_association,
	action,
	data_environment,
	group,
	group_relationship,
	name_assignment,
	product_concept_feature,
	product_concept_feature_association,
	product_definition_substitute,
	property_definition_relationship,
	representation,
	representation_relationship,
	versioned_action_request);
  END_TYPE; 

  TYPE design_pdm_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_certification_item WITH 
    (alternate_product_relationship,
     product_definition_formation,
     make_from_usage_option,
	product_definition,
	product_definition_relationship);
  END_TYPE;

  TYPE design_pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_classification_item WITH 
    (characterized_object,
     information_right,
     information_usage_right,
     usage_association,
	document_type,
	material_designation,
	product_concept_feature,
	product_concept_feature_category,
	security_classification_level,
	shape_aspect);
  END_TYPE;

  TYPE design_pdm_configured_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON configured_effectivity_item WITH (
	action_relationship,
	product_definition);
END_TYPE;

  TYPE design_pdm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
    (action_directive,
     alternate_product_relationship,
     directed_action,
     organization,
     person_and_organization,
     product,
     product_definition_formation);
  END_TYPE;

  TYPE design_pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_date_and_time_item WITH 
    (action_directive,
     approval_person_organization,
     certification,
     contract,
     directed_action,
     document,
     product_definition,
     security_classification,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	alternate_product_relationship,
	applied_classification_assignment,
	approval_status,
	assembly_component_usage_substitute,
	class,
	class_system,
	configuration_design,
	configuration_item,
	configured_effectivity_assignment,
	effectivity,
	general_property,
	material_designation,
	organization_relationship,
	person_and_organization,
	product,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition_formation_relationship,
	product_definition_substitute,
	property_definition,
	security_classification_level,
	shape_representation);
  END_TYPE;

  TYPE design_pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_date_item WITH 
    (action_directive,
     product_definition,
     directed_action,
     approval_person_organization,
     contract,
	 document,
	 executed_action,
     security_classification,
     certification,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	alternate_product_relationship,
	applied_classification_assignment,
	approval_status,
	assembly_component_usage_substitute,
	class,
	class_system,
	configuration_design,
	configuration_item,
	configured_effectivity_assignment,
	effectivity,
	general_property,
	material_designation,
	organization_relationship,
	person_and_organization,
	product,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition_formation_relationship,
	product_definition_substitute,
	property_definition,
	security_classification_level,
	shape_representation);
  END_TYPE;

  TYPE design_pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_document_reference_item WITH 
    (applied_external_identification_assignment,
     assembly_component_usage,
     characterized_class,
     characterized_object,
     configuration_item,
     descriptive_representation_item,
     externally_defined_item,
     group,
     group_relationship,
     information_right,
     information_usage_right,
     material_designation,
     measure_representation_item,
     product,
     product_category,
     product_definition,
     product_definition_formation,
     property_definition,
     representation,
     representation_item,
     usage_association,
	action_directive,
	action_relationship,
	applied_action_assignment,
	approval,
	certification,
	class,
	class_system,
	configuration_design,
	contract,
	general_property,
	organization,
	organizational_project,
	person,
	product_concept,
	product_concept_feature,
	product_concept_feature_category,
	product_definition_substitute,
	product_related_product_category,
	security_classification);
  END_TYPE;

  TYPE design_pdm_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH (
	action,
	action_method,
	action_method_relationship,
	action_property,
	action_relationship,
	class,
	class_system,
	configuration_design,
	configuration_item,
	configured_effectivity_assignment,
	document_file,
	general_property,
	material_designation,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition_formation_relationship,
	product_definition_substitute,
	property_definition,
	security_classification,
	shape_aspect,
	shape_representation);
  END_TYPE;

  TYPE design_pdm_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH ( 
	action,
	action_directive,
	action_method,
	action_property,
	action_request_solution,
	alternate_product_relationship,
	applied_action_assignment,
	applied_classification_assignment,
	assembly_component_usage_substitute,
	certification,
	class,
	class_system,
	configuration_design,
	configuration_effectivity,
	configuration_item,
	configured_effectivity_assignment,
	contract,
	executed_action,
	general_property,
	material_designation,
	organization_relationship,
	organizational_project,
	person_and_organization,
	product,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	product_definition_substitute,
	property_definition,
	security_classification_level,
	shape_representation);
  END_TYPE;

  TYPE design_pdm_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
    (group_relationship,
     product_definition,
     product_definition_formation,
     property_definition_representation,
     representation,
     representation_item,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE;

  TYPE design_pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
    (configuration_item,
     group,
     group_relationship,
     information_right,
     information_usage_right,
     material_designation,
     person_and_organization,
     product,
     product_category,
     product_concept,
     product_definition_formation,
     organization,
     usage_association,
	action,
	action_directive,
	action_method,
	action_property,
	applied_identification_assignment,
	class_system,
	document_type,
	effectivity,
	measure_representation_item,
	organizational_project,
	product_concept_feature_category,
	product_definition_relationship,
	property_definition,
	property_definition_relationship,
	versioned_action_request);
  END_TYPE;

  TYPE design_pdm_ir_usage_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ir_usage_item WITH 
   (action_directive,
    characterized_object,   
    identification_item, 
    requirement_assigned_item, 
    classification_item, 
    certification_item,
    document_reference_item,      
    person_and_organization,
    product_definition_formation,
    organization);  
  END_TYPE;

  TYPE design_pdm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
    (information_right,
	 information_usage_right,
     usage_association,
	action,
	action_directive,
	action_method,
	action_property,
	action_relationship,
	data_environment,
	group,
	group_relationship,
	name_assignment,
	product_concept_feature,
	product_concept_feature_association,
	product_definition_substitute,
	property_definition_relationship,
	uncertainty_qualifier,
	versioned_action_request);
  END_TYPE; 

  TYPE design_pdm_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
    (external_class_library,
     group,
     group_relationship,
     product,
     product_definition);
  END_TYPE; 

  TYPE design_pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_organization_item WITH 
    (action_directive,
     applied_classification_assignment,
     applied_identification_assignment,
     product_definition,
     product_definition_formation_relationship,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	approval_status,
	class_system,
	configuration_design,
	configuration_effectivity,
	configured_effectivity_assignment,
	document_type,
	effectivity,
	event_occurrence,
	material_designation,
	organization,
	organization_relationship,
	person_and_organization,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition_relationship,
	product_definition_substitute,
	security_classification_level);
  END_TYPE;

  TYPE design_pdm_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH (
	assembly_component_usage,
	configuration_item,
	executed_action,
	product,
	product_concept,
	product_definition,
	product_definition_formation);
  END_TYPE;


  TYPE design_pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_person_and_organization_item WITH 
    (action_directive,
     applied_classification_assignment,
     applied_identification_assignment,
     product_definition,
     product_definition_formation_relationship,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	approval_status,
	class,
	class_system,
	configuration_design,
	configuration_effectivity,
	configured_effectivity_assignment,
	document_type,
	event_occurrence,
	material_designation,
	organization,
	organization_relationship,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition_relationship,
	product_definition_substitute,
	security_classification_level);
  END_TYPE;

  TYPE design_pdm_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (descriptive_representation_item, 
     configuration_item, 
     product_definition, 
     product_definition_formation, 
     product, 
     product_class,
     product_definition_relationship,
     shape_aspect, 
     representation); 
  END_TYPE; 

  TYPE design_pdm_requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_source_item WITH 
    (group,
     group_relationship,
     product_definition,
     product_definition_formation,
     product,
     shape_aspect,
     characterized_object,
     product_definition_relationship);
  END_TYPE; 

  TYPE design_pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_security_classification_item WITH 
    (document,
     make_from_usage_option,
     product_definition_formation,
     product_definition,
	action,
	action_directive,
	action_property,
	applied_action_assignment,
	assembly_component_usage_substitute,
	class_system,
	configuration_design,
	configuration_effectivity,
	configured_effectivity_assignment,
	executed_action,
	general_property,
	material_designation,
	organizational_project,
	product_concept,
	product_concept_feature,
	product_concept_feature_category,
	product_definition_relationship,
	property_definition,
	shape_representation,
	versioned_action_request);	
  END_TYPE;

  TYPE promissory_usage_in_product_model_assigned_item = SELECT
    (product_concept,
     product_definition);
  END_TYPE;

  TYPE design_pdm_time_interval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON time_interval_item WITH ( 
	action_directive,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	alternate_product_relationship,
	applied_action_assignment,
	applied_classification_assignment,
	applied_person_and_organization_assignment,
	approval_status,
	assembly_component_usage_substitute,
	certification,
	class,
	class_system,
	configuration_design,
	configuration_effectivity,
	configuration_item,
	configured_effectivity_assignment,
	contract,
	document_file,
	executed_action,
	general_property,
	material_designation,
	organization_relationship,
	organizational_project,
	person_and_organization,
	product,
	product_concept,
	product_concept_feature,
	product_concept_feature_association,
	product_concept_feature_category,
	product_concept_feature_category_usage,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	product_definition_substitute,
	property_definition,
	security_classification,
	security_classification_level,
	shape_representation,
	versioned_action_request);	
  END_TYPE;
  
ENTITY retention
  SUBTYPE OF (action);
WHERE
  WR1:  SIZEOF( QUERY( aa <* USEDIN(SELF,'DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.' +
           'ACTION_ASSIGNMENT.ASSIGNED_ACTION') |
               ('DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.APPLIED_ACTION_ASSIGNMENT' IN
                TYPEOF(aa)) AND
               (aa.role.name = 'retention')
              )) >= 1;   
  WR2:  (SIZEOF( QUERY( atia <* USEDIN(SELF,'DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.' +
     'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
                        (atia.role.name = 'minimum retention period') 
                       )) = 1) AND
                     (SIZEOF( QUERY( atia <* USEDIN(SELF,'DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.' +
     'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
                        (atia.role.name = 'maximum retention period') 
                       )) = 1) AND
                     (SIZEOF( QUERY( atia1 <* USEDIN(SELF,'DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.' +
     'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
                       (atia1.role.name = 'minimum retention period') AND
                       ('DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.TIME_INTERVAL_WITH_BOUNDS' IN
                        TYPEOF(atia1.assigned_time_interval)) AND
                       (EXISTS(atia1.assigned_time_interval\time_interval_with_bounds.secondary_bound) OR
                        EXISTS(atia1.assigned_time_interval\time_interval_with_bounds.duration)) AND
                       (SIZEOF( QUERY( atia2 <* USEDIN(SELF,'DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.' +
       'APPLIED_TIME_INTERVAL_ASSIGNMENT.ITEMS') |
 (atia2.role.name = 'maximum retention period') AND
 ('DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.TIME_INTERVAL_WITH_BOUNDS' IN
  TYPEOF(atia2.assigned_time_interval)) AND
 (EXISTS(atia2.assigned_time_interval\time_interval_with_bounds.secondary_bound) OR
  EXISTS(atia2.assigned_time_interval\time_interval_with_bounds.duration)) AND
 (atia1.assigned_time_interval\time_interval_with_bounds.primary_bound :=: 
  atia2.assigned_time_interval\time_interval_with_bounds.primary_bound)
)) = 1) 
                       )) = 1);
           
  WR3:  SIZEOF( USEDIN(SELF,'DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.' +
                      'ACTION_RELATIONSHIP.RELATING_ACTION')) +
              SIZEOF( USEDIN(SELF,'DESIGN_PRODUCT_DATA_MANAGEMENT_MIM.' +
                      'ACTION_RELATIONSHIP.RELATED_ACTION')) = 0;   
END_ENTITY;
  
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6352 - ISO/TS 10303-1662 Design specific assignment to assembly usage view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5630
*)


SCHEMA Design_specific_assignment_to_assembly_usage_view_mim;
USE FROM Assembly_module_with_interconnect_component_mim;	-- ISO/TS 10303-1643
USE FROM Assembly_module_with_subassembly_mim;	-- ISO/TS 10303-1641

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6355 - ISO/TS 10303-1663 Design specific assignment to interconnect usage view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5633
*)


SCHEMA Design_specific_assignment_to_interconnect_usage_view_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
--	USE FROM Interconnect_module_usage_view_mim;	-- ISO/TS 10303-1686
--	USE FROM Land_mim;	-- ISO/TS 10303-1692
--	USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6358 - ISO/TS 10303-1664 Device marking - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5636
*)

SCHEMA Device_marking_mim;

USE FROM Approval_mim;	-- ISO/TS 10303-1012
USE FROM Layered_interconnect_complex_template_mim;	-- ISO/TS 10303-1716
USE FROM Part_template_non_planar_shape_mim;	-- ISO/TS 10303-1719
	
  TYPE device_marking_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
    (representation);
  END_TYPE;

  TYPE device_marking_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
    (representation);
  END_TYPE;

  TYPE device_marking_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (representation);
  END_TYPE;

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N5351 - ISO/TS 10303-1362 Dimension and tolerance callouts - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4703
*) 

SCHEMA Dimension_and_tolerance_callouts_mim;

USE FROM Associative_draughting_elements_mim; -- ISO/TS 10303-1311
USE FROM Draughting_annotation_mim; -- ISO/TS 10303-1206
USE FROM Draughting_element_specialisations_mim; -- ISO/TS 10303-1312
USE FROM Geometric_tolerance_mim; -- ISO/TS 10303-1051

TYPE datc_draughting_model_item_definition = EXTENSIBLE GENERIC_ENTITY SELECT 
  BASED_ON draughting_model_item_definition WITH (
  dimensional_size,
  geometric_tolerance);
END_TYPE;

TYPE dimensioning_standard_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
  (product_definition);
END_TYPE; 

ENTITY dimension_curve_terminator_to_projection_curve_associativity
  SUBTYPE OF(annotation_occurrence_associativity);
  SELF\annotation_occurrence_relationship.relating_annotation_occurrence : dimension_curve_terminator;
  SELF\annotation_occurrence_relationship.related_annotation_occurrence  : projection_curve;
END_ENTITY;

RULE draughting_model_items_constraint FOR (draughting_model);
WHERE
  -- logic - there should be 0 items, which are annotation_occurrences and which are not draughting_annotation_occurrences
  WR1: SIZEOF(QUERY(dm <* draughting_model |
    NOT(SIZEOF(QUERY(it1 <* dm\representation.items |
    (('DRAUGHTING_ELEMENT_SCHEMA.ANNOTATION_OCCURRENCE' IN TYPEOF(it1))
    AND
    NOT('AIC_DRAUGHTING_ANNOTATION.' + 'DRAUGHTING_ANNOTATION_OCCURRENCE' IN TYPEOF(it1)))
      )) = 0)
    )) = 0;
  WR2: SIZEOF(QUERY(dm <* draughting_model |
    NOT(SIZEOF(QUERY(it1 <* dm\representation.items |
    (('DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT' IN TYPEOF(it1))
    AND
    NOT('AIC_DRAUGHTING_ELEMENTS.DRAUGHTING_ELEMENTS' IN TYPEOF(it1)))
      )) = 0)
    )) = 0;
END_RULE;

END_SCHEMA; 
(*
ISO TC184/SC4/WG12 N6891 - ISO/TS 10303-1050 Dimension tolerance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6677
*) 


SCHEMA Dimension_tolerance_mim;

USE FROM Derived_shape_element_mim;    -- ISO/TS 10303-1130
USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122
USE FROM Extended_measure_representation_mim;    -- ISO/TS 10303-1106
USE FROM Value_with_unit_extension_mim;  -- ISO/TS 10303-1753


USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   externally_defined_item); 
USE FROM geometry_schema   -- ISO 10303-42
  (placement); 
USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021
USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item,
   measure_qualification,
   value_qualifier); 
USE FROM shape_aspect_definition_schema   -- ISO 10303-47
  (shape_aspect_deriving_relationship,
   dimensional_location_with_datum_feature,
   dimensional_size_with_datum_feature); 
USE FROM shape_dimension_schema;    -- ISO 10303-47
USE FROM shape_tolerance_schema   -- ISO 10303-47
  (limits_and_fits,
   plus_minus_tolerance,
   tolerance_method_definition,
   tolerance_value); 

TYPE dimension_identification_item = SELECT BASED_ON identification_item WITH 
   (dimensional_size);
END_TYPE; 

TYPE dimension_tolerance_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (dimensional_size, 
    externally_defined_dimension_definition);
END_TYPE; 

ENTITY externally_defined_dimension_definition
  SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
  WR1: (SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification');
  WR2: 1 >= SIZEOF(QUERY ( adr <* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ));
END_ENTITY;

END_SCHEMA;  -- Dimension_tolerance_mim
(*
   ISO TC184/SC4/WG12 N6361 - ISO/TS 10303-1744 Discrete shield - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5813
*)

SCHEMA Discrete_shield_mim;

USE FROM Assembly_component_placement_requirements_mim;	-- ISO/TS 10303-1634
USE FROM Physical_connectivity_definition_mim; -- ISO/TS 10303-1755

ENTITY physical_shield
  SUBTYPE OF (physical_component);
END_ENTITY;

ENTITY routed_physical_shield
  SUBTYPE OF (physical_shield, routed_physical_component);
END_ENTITY;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6577 - ISO/TS 10303-1121 Document and version identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1187
*) 


SCHEMA Document_and_version_identification_mim;

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_related_product_category); 

END_SCHEMA;  -- Document_and_version_identification_mim

(*
ISO TC184/SC4/WG12 N7107 - ISO/TS 10303-1122 Document assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2959
*)



SCHEMA Document_assignment_mim;

USE FROM Document_and_version_identification_mim;    -- ISO/TS 10303-1121

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM document_schema   -- ISO 10303-41
  (document_product_association); 

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM management_resources_schema   -- ISO 10303-41
  (document_reference,
   document_usage_constraint_assignment); 


TYPE document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_document_reference
  SUBTYPE OF (document_reference);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY applied_document_usage_constraint_assignment
  SUBTYPE OF (document_usage_constraint_assignment);
  items : SET[1:?] OF document_reference_item;
END_ENTITY;

ENTITY document_product_equivalence
  SUBTYPE OF (document_product_association);
WHERE
  WR1: SELF\document_product_association.name = 'equivalence';
  WR2: NOT ('DOCUMENT_ASSIGNMENT_MIM.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR3: NOT ('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
  WR4: NOT ('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
END_ENTITY;


SUBTYPE_CONSTRAINT subtype_mandatory_document_product_association FOR document_product_association;
  ABSTRACT SUPERTYPE;
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- Document_assignment_mim
(*
 ISO TC184/SC4/WG12 N2961 - ISO/TS 10303-1123 Document definition - EXPRESS MIM
*) 


SCHEMA Document_definition_mim;

USE FROM Document_and_version_identification_mim;    -- ISO/TS 10303-1121

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_with_associated_documents); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


TYPE document_location_select = SELECT BASED_ON external_identification_item WITH 
   (product_definition);
END_TYPE; 

END_SCHEMA;  -- Document_definition_mim
(*
 ISO TC184/SC4/WG12 N6121 - ISO/TS 10303-1290 Document management - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3038
*) 


SCHEMA Document_management_mim;

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Document_properties_mim;    -- ISO/TS 10303-1126

USE FROM Document_structure_mim;    -- ISO/TS 10303-1124

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source); 

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288

USE FROM management_resources_schema   -- ISO 10303-41
  (document_usage_role); 


TYPE dm_aliasable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON aliasable_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    object_role, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH 
   (product_definition_formation);
END_TYPE; 

TYPE dm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH 
   (document_file, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH 
   (document_file, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    object_role, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
END_TYPE; 

TYPE dm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE dm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (document_file, 
    product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Document_management_mim

(*
ISO TC184/SC4/WG12 N1202 - ISO/TS 10303-1126 Document properties - EXPRESS MIM
*) 


SCHEMA Document_properties_mim;

USE FROM Document_definition_mim;    -- ISO/TS 10303-1123

USE FROM File_identification_mim;    -- ISO/TS 10303-1127

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition); 


END_SCHEMA;  -- Document_properties_mim
(*
 ISO TC184/SC4/WG12 N1196 - ISO/TS 10303-1124 Document structure - EXPRESS MIM
*)



SCHEMA Document_structure_mim;
USE FROM Document_definition_mim; -- ISO/CD TS 10303-1123
USE FROM File_identification_mim; -- ISO/CD TS 10303-1127
USE FROM document_schema (document_relationship); -- ISO 10303-41
USE FROM product_definition_schema -- ISO 10303-41
	(product_definition_formation_relationship,
         product_definition_relationship);
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N5354 - ISO/TS 10303-1206 Draughting annotation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4706
*)

SCHEMA Draughting_annotation_mim;

USE FROM Draughting_element_mim; -- ISO/CD-TS 10303-1310

USE FROM draughting_element_schema  --  ISO 10303-101
  (dimension_curve_terminator,
  terminator_symbol);
  
USE FROM aic_draughting_annotation;    --  ISO 10303-504

USE FROM presentation_definition_schema  -- ISO 10303-46
  (annotation_symbol_occurrence,
  pre_defined_symbol);

  ENTITY pre_defined_dimension_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      WR1: SELF.name IN [ 'arc length' , 'conical taper' , 'counterbore' , 'countersink' , 'depth' , 'diameter' , 'plus minus' , 'radius' , 'slope' , 'spherical diameter' , 'spherical radius' , 'square'];
  END_ENTITY;

  ENTITY pre_defined_geometrical_tolerance_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      WR1: SELF.name IN ['angularity' , 'basic dimension' , 'blanked datum reference' , 'circular runout' , 'circularity' , 'concentricity' , 'cylindricity' , 'datum target identification' , 'diameter' , 'filled datum reference' , 'flatness' , 'least material condition' , 'maximum material condition' , 'parallelism' , 'perpendicularity' , 'position' , 'profile of a line' , 'profile of a surface' , 'projected tolerance zone' , 'regardless of feature size' , 'straightness' , 'symmetry' , 'total runout' ];
  END_ENTITY;

  ENTITY pre_defined_surface_condition_symbol
    SUBTYPE OF (pre_defined_symbol);
    WHERE
      WR1: SELF.name IN ['000' , '010' , '020' , '030' , '040' , '050' , '060' , '070' , '001' , '011' , '021' , '031' , '041' , '051' , '061' , '071' , '100' , '110' , '120' , '130' , '140' , '150' , '160' , '170' , '101' , '111' , '121' , '131' , '141' , '151' , '161' , '171' , '200' , '210' , '220' , '230' , '240' , '250' , '260' , '270' , '201' , '211' , '221' , '231' , '241' , '251' , '261' , '271'];
  END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7065 - ISO/TS 10303-1310 Draughting element - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5357
*)

SCHEMA Draughting_element_mim;

USE FROM Associative_text_mim; -- ISO/CD-TS 10303-1132

USE FROM Curve_appearance_mim; -- ISO/CD-TS 10303-1003

USE FROM draughting_element_schema    --  ISO 10303-101
  (annotation_plane,
  leader_curve,
  draughting_callout,
  dimension_curve,
  projection_curve);

USE FROM presentation_definition_schema(  
  annotation_fill_area_occurrence);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7075 - ISO/TS 10303-1312 Draughting element specialisations - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5340
*)

SCHEMA Draughting_element_specialisations_mim; 

USE FROM Draughting_element_mim; -- ISO/CD-TS 10303-1310

USE FROM aic_draughting_elements; --  ISO 10303-506

USE FROM presentation_definition_schema (annotation_symbol_occurrence); -- ISO/CD-TS 10303-46
          
  ENTITY surface_condition_callout
    SUBTYPE OF (draughting_callout);
      WHERE
       WR1: SIZEOF ( QUERY ( c <* SELF.contents | SIZEOF (
         ['PRESENTATION_DEFINITION_SCHEMA.'+ 'ANNOTATION_CURVE_OCCURRENCE' ,
         'PRESENTATION_DEFINITION_SCHEMA.'+ 'ANNOTATION_SYMBOL_OCCURRENCE' ,
         'PRESENTATION_DEFINITION_SCHEMA.'+ 'ANNOTATION_TEXT_OCCURRENCE']* TYPEOF
         ( c ) ) <>1 ) ) =0;
  END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6894 - ISO/TS 10303-1309 Drawing definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5363
*)

SCHEMA Drawing_definition_mim;

USE FROM Draughting_annotation_mim;
USE FROM Presentation_hierarchy_mim;

USE FROM drawing_definition_schema;

USE FROM presentation_organization_schema
  (camera_image_2d_with_scale);
  
ENTITY drawing_sheet_layout
  SUBTYPE OF (draughting_symbol_representation);
END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1268 - ISO/TS 10303-1501 Edge based wireframe - EXPRESS MIM
*)


SCHEMA Edge_based_wireframe_mim;

USE FROM Elemental_geometric_shape_mim; 
USE FROM aic_edge_based_wireframe;      -- ISO 10303-501

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N3967 - ISO/TS 10303-1673 Edge shape feature - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3415
*)


SCHEMA Edge_shape_feature_mim;
	USE FROM Layered_2d_shape_mim;	-- ISO/TS 10303-1693
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654	

END_SCHEMA;


(*
 ISO TC184/SC4/WG12 N1169 - ISO/TS 10303-1057 Effectivity - EXPRESS MIM
*)
  
SCHEMA Effectivity_mim;

USE FROM Time_interval_mim; -- ISO 10303-1065
USE FROM Value_with_unit_mim ; -- ISO 10303-1054

USE FROM effectivity_schema -- ISO 10303-41
  (	dated_effectivity,
	effectivity,
   	effectivity_relationship,
	lot_effectivity,
   	serial_numbered_effectivity,
      time_interval_based_effectivity);

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N3224 - ISO/TS 10303-1059 Effectivity application - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1175
*) 


SCHEMA Effectivity_application_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (object_role,
   role_association,
   role_select); 

USE FROM Effectivity_mim;    -- ISO/TS 10303-1057

USE FROM management_resources_schema   -- ISO 10303-41
  (effectivity_assignment); 


TYPE effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_effectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET[1:?] OF effectivity_item;
END_ENTITY;

ENTITY applied_ineffectivity_assignment
  SUBTYPE OF (effectivity_assignment);
  items : SET [1:?] OF effectivity_item;
WHERE
  WR1:  SIZEOF(['EFFECTIVITY_SCHEMA.LOT_EFFECTIVITY',
                'EFFECTIVITY_SCHEMA.SERIAL_NUMBERED_EFFECTIVITY',
                'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_EFFECTIVITY'] *
                     TYPEOF(SELF.assigned_effectivity)
              ) = 0;   
END_ENTITY;

END_SCHEMA;  -- Effectivity_application_mim
(*
   ISO TC184/SC4/WG12 N3943 - ISO/TS 10303-1665 Electrical network definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3337
*)
SCHEMA Electrical_network_definition_mim;

	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704

ENTITY electrical_network
  SUBTYPE OF (functional_unit);
END_ENTITY;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7109 - ISO/TS 10303-1004 Elemental geometric shape - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N7090
*)

   
SCHEMA Elemental_geometric_shape_mim;

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006
USE FROM Elemental_topology_mim; -- ISO/TS 10303-1005

USE FROM geometry_schema   -- ISO 10303-42
  (axis1_placement,
   axis2_placement_2d,
   axis2_placement_3d,
   cartesian_point,
   cartesian_transformation_operator_2d,
   cartesian_transformation_operator_3d,
   direction,
   geometric_representation_context,
   geometric_representation_item); 

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (item_defined_transformation,
   mapped_item,
   representation_map,
   value_representation_item); 


TYPE representation_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (shape_representation);
END_TYPE; 

END_SCHEMA;  -- Elemental_geometric_shape_mim
(*
ISO TC184/SC4/WG12 N6897 - ISO/TS 10303-1005 Elemental topology - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6562
*)
   
SCHEMA Elemental_topology_mim;
  USE FROM Foundation_representation_mim; 
  USE FROM topology_schema -- ISO 10303-42
      (connected_edge_set,
       connected_face_set,
       edge,
       edge_loop,
       face,
       face_bound,
       face_outer_bound,
       loop,
       oriented_edge,
       path,
       topological_representation_item,
       vertex,
       vertex_loop);
END_SCHEMA;

(* Last update -  15 Aug 2001 *)
(*
   ISO TC184/SC4/WG12 N5541 - ISO/TS 10303-1329 Elementary boundary representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4718
*)

SCHEMA Elementary_boundary_representation_mim;

USE FROM Elemental_geometric_shape_mim; -- ISO/CD-TS 10303-1004

USE FROM aic_elementary_brep; -- ISO 10303-513

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N7224 - ISO/TS 10303-1527 Elementary function - EXPRESS MIM
*)

SCHEMA Elementary_function_mim;

USE FROM Numeric_expression_mim;

USE FROM ISO13584_expressions_schema(
	abs_function,
	acos_function,	
	asin_function,
	atan_function,	
	cos_function,
	exp_function,
	integer_defined_function,	
	log_function,
	log10_function,
	log2_function,
	maximum_function,
	minimum_function,	
	minus_function,		
	numeric_defined_function,	
	real_defined_function,	
	sin_function,	
	square_root_function,	
	tan_function,	
	unary_function_call);
	
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N2115 - ISO/TS 10303-1064 Event - EXPRESS MIM
*)

SCHEMA Event_mim; 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM date_time_schema   -- ISO 10303-41
  (event_occurrence,
   event_occurrence_relationship,
   relative_event_occurrence); 

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (event_occurrence);
END_TYPE; 

TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (event_occurrence);
END_TYPE; 

END_SCHEMA;  -- Event_mim

(*
 ISO TC184/SC4/WG12 N2117 - ISO/TS 10303-1364 Event assignment - EXPRESS MIM
*)



SCHEMA Event_assignment_mim; 

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM management_resources_schema   -- ISO 10303-41
  (event_occurrence_assignment); 


TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_event_occurrence_assignment
  SUBTYPE OF (event_occurrence_assignment);
  items : SET[1:?] OF event_occurrence_item;
END_ENTITY;

END_SCHEMA;  -- Event_assignment_mim
(*
  ISO TC184/SC4/WG12 N7203 - ISO/TS 10303-1788 Explicit_constraints - EXPRESS MIM
*)

SCHEMA Explicit_constraints_mim;

USE FROM Expression_mim;  -- ISO 10303-1341

USE FROM Foundation_representation_mim;  -- ISO 10303-1006

USE FROM Parameterization_and_variational_representation_mim; -- ISO 10303-1790
   
USE FROM explicit_constraint_schema;  -- ISO 10303-108


END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7215 - ISO/TS 10303-1342 Expression - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N2556
*)

SCHEMA Expression_mim;

USE FROM Generic_expression_mim;
USE FROM Numeric_expression_mim;

USE FROM iso13584_expressions_schema(
	concat_expression,
	format_function,
	index_expression,
	interval_expression,
	like_expression,
	simple_string_expression,
	SQL_mappable_defined_function,
	string_defined_function,
	string_expression,
	string_literal,
	string_variable,
	substring_expression
);
	
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6620 - ISO/TS 10303-1667 Extended basic geometry - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5366
*)

SCHEMA Extended_basic_geometry_mim;

USE FROM Basic_geometry_mim;	-- ISO/TS 10303-1652
USE FROM Geometric_model_relationship_mim;
	
USE FROM representation_schema(
--  definitional_representation_relationship,
  mapped_item,
  representation_item_relationship,
  representation_map);

USE FROM product_property_representation_schema -- ISO 10303-41
  (shape_representation_relationship);
  	 		
USE FROM geometry_schema(
  vector);	

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set);

  ENTITY geometric_model_element_relationship
    SUBTYPE OF (geometric_representation_item, representation_item_relationship);
      SELF\representation_item_relationship.relating_representation_item : geometric_representation_item;
      SELF\representation_item_relationship.related_representation_item: geometric_representation_item;
    UNIQUE
      UR1: SELF\representation_item_relationship.relating_representation_item, 
        SELF\representation_item_relationship.related_representation_item;
    WHERE
      WR1: SELF\representation_item_relationship.relating_representation_item :<>: 
        SELF\representation_item_relationship.related_representation_item;
  END_ENTITY; 

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N5369 - ISO/TS 10303-1776 Extended date - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4697
*)
SCHEMA Extended_date_mim; 

USE FROM Date_time_mim; 

USE FROM date_time_schema -- ISO 10303-41
	(date,
	day_in_month_number,
	ordinal_date,
	week_of_year_and_day_date,
	year_month);

REFERENCE FROM date_time_schema -- ISO 10303-41
	(leap_year);

END_SCHEMA; 
(*
ISO TC184/SC4/WG12 N5372 - ISO/TS 10303-1106 Extended measure representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4835
*) 


SCHEMA Extended_measure_representation_mim;

USE FROM Qualified_measure_mim; -- ISO/CD-TS 10303-1782

USE FROM representation_schema   -- ISO 10303-43
  (compound_item_definition,
   compound_representation_item,
   list_representation_item,
   set_representation_item); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (type_check_function); 


  ENTITY value_range
    SUBTYPE OF (compound_representation_item);
    WHERE
      WR1: ( 'REPRESENTATION_SCHEMA.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );
      WR2: value_range_wr2 ( item_element );
      WR3: value_range_wr3 ( item_element );
  END_ENTITY;

  RULE subtype_exclusiveness_representation_item FOR 
      (representation_item);
    WHERE
      WR1: SIZEOF(QUERY (cri <* representation_item | 
      NOT (type_check_function(cri,['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
                                    'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM',
                                    'REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM'] , 3)))) = 0;
  END_RULE; 

  FUNCTION value_range_wr1
     (agg : compound_item_definition) : BOOLEAN; 
    BEGIN
      IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
        (i1)))) = 2) OR
        (SIZEOF(QUERY (i2 <* agg | (
        'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF
        (i2)))) = 2)) 
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;
  END_FUNCTION; 

  FUNCTION value_range_wr2
      (agg : compound_item_definition) : BOOLEAN; 
    BEGIN
      IF ((SIZEOF(QUERY (i <* agg | (i\representation_item.name = 'upper limit'))) = 1)
        AND (SIZEOF(QUERY (i <* agg | (i\representation_item.name = 'lower limit'))) = 1))
      THEN
        RETURN(TRUE);
      ELSE
        RETURN(FALSE);
      END_IF;
    END;
  END_FUNCTION; 

  FUNCTION value_range_wr3
      (agg : compound_item_definition) : BOOLEAN; 
    BEGIN
      IF (SIZEOF(QUERY(i1 <* agg |
        ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
        (SIZEOF (QUERY (i2 <* agg |
        ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
        (i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
      THEN
        RETURN (TRUE);
      ELSE
        RETURN (FALSE);
      END_IF;
    END;
  END_FUNCTION; 

END_SCHEMA; 
(*
 ISO TC184/SC4/WG12 N5375 - ISO/TS 10303-1275 External class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4733
*)


SCHEMA External_class_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select); 

USE FROM Class_mim;    -- ISO/TS 10303-1070

USE FROM External_source_mim; -- ISO/CD-TS 10303-1331

USE FROM classification_schema   -- ISO 10303-54
  (class); 

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   externally_defined_item); 

USE FROM Name_assignment_mim;    -- ISO/TS 10303-1340


  TYPE external_class_name_item = SELECT BASED_ON name_item WITH 
    (external_class_library);
  END_TYPE; 

  ENTITY external_class_library
    SUBTYPE OF (external_source);
  END_ENTITY;

  ENTITY externally_defined_class
    SUBTYPE OF (class, externally_defined_item);
  END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N5378 - ISO/TS 10303-1777 External currency - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4736
*)
SCHEMA External_currency_mim;

USE FROM Currency_mim; -- ISO/CD-TS 10303-1775

USE FROM External_unit_mim; -- ISO/CD-TS 10303-1780

  ENTITY externally_defined_currency
    SUBTYPE OF (currency, externally_defined_context_dependent_unit);
  END_ENTITY;

  SUBTYPE_CONSTRAINT currency_subtypes FOR currency; 
	(ONEOF (externally_defined_currency,
	  iso4217_currency));
  END_SUBTYPE_CONSTRAINT;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1208 - ISO/TS 10303-1128 External item identification assignment - EXPRESS MIM
*)


SCHEMA External_item_identification_assignment_mim;

USE FROM management_resources_schema   	-- ISO 10303-41
  (external_identification_assignment); 

USE FROM support_resource_schema		-- ISO 10303-41
  (identifier);

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1 : ?] OF external_identification_item;
END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6235 - ISO/TS 10303-1778 External library - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5381
*)
SCHEMA External_library_mim;

USE FROM External_source_mim;  -- ISO/TS 10303-1331

USE FROM Plib_class_reference_mim; -- ISO/TS 10303-1291

  TYPE el_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
    (external_source);
  END_TYPE;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1229 - ISO/TS 10303-1033 External model - EXPRESS MIM
*)

SCHEMA External_model_mim;
  
USE FROM Elemental_geometric_shape_mim; -- ISO 10303-1004
  
USE FROM File_identification_mim;

USE FROM product_property_definition_schema
  (property_definition);

USE FROM product_property_representation_schema
  (property_definition_representation);

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N6680 - ISO/TS 10303-1129 External properties - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5544
*)

SCHEMA External_properties_mim;

USE FROM External_library_mim; -- ISO/CD-TS 10303-1778

USE FROM Identification_assignment_mim; -- ISO/TS 10303-1021

USE FROM Independent_property_mim; -- ISO/TS 10303-1036

USE FROM Plib_class_reference_mim; -- ISO/CD-TS 10303-1291

USE FROM external_reference_schema(
	externally_defined_item,
	externally_defined_item_relationship);

USE FROM support_resource_schema(
	identifier);

REFERENCE FROM management_resources_schema(identification_role); 

  TYPE external_identification_for_plib_property = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_general_property);
  END_TYPE;

  ENTITY externally_defined_general_property 
    SUBTYPE OF (general_property, externally_defined_item); 
  END_ENTITY; 

  FUNCTION external_version_assignment_is_valid (aia: applied_external_identification_assignment): BOOLEAN;
    LOCAL
      item: external_identification_item;
      role: identification_role;
    END_LOCAL;
      role:= aia.role;
      IF role.name='version' THEN
        REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
          item:= aia.items[i];
          IF (SIZEOF(['EXTERNAL_PROPERTIES_MIM.EXTERNALLY_DEFINED_GENERAL_PROPERTY']*TYPEOF(item))=0) THEN
            -- item invalid if item does not belong to versionable types
	        RETURN(FALSE);
          END_IF;
        END_REPEAT;
        RETURN(TRUE);
      ELSE		-- case where aia does not convey a version id
        RETURN(TRUE);
      END_IF;
  END_FUNCTION;

  RULE external_version_assignments_are_valid FOR (applied_external_identification_assignment);
    WHERE
      WR1: SIZEOF(QUERY(aia <* applied_external_identification_assignment | 
        NOT external_version_assignment_is_valid(aia)))=0;
  END_RULE;

  RULE plib_property_reference_requires_name_scope FOR (
      externally_defined_general_property);
    LOCAL
      known_sourced_properties : SET OF externally_defined_general_property;
    END_LOCAL;
      known_sourced_properties := QUERY( edc <* externally_defined_general_property | 
	    'PLIB_CLASS_REFERENCE_MIM.KNOWN_SOURCE' IN TYPEOF(edc.source) );
    WHERE
      WR1: SIZEOF ( QUERY ( edgp <* known_sourced_properties | 
        ( SIZEOF ( QUERY ( edir <* USEDIN ( edgp, 'EXTERNAL_REFERENCE_SCHEMA.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM' )| 
        ( edir.name =  'name scope' ) AND 
        ('EXTERNAL_CLASS_MIM.EXTERNALLY_DEFINED_CLASS' IN  TYPEOF ( edir.related_item ) ) AND 
        ( 'PLIB_CLASS_REFERENCE_MIM.KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) <>1 ) ) ) =  0;
  END_RULE; 

  RULE plib_property_reference_requires_version FOR (externally_defined_general_property); 
	LOCAL
	  plib_properties : SET OF externally_defined_general_property := [];
	END_LOCAL;
	  plib_properties := QUERY ( edgp <* externally_defined_general_property | 
		( 'EXTERNAL_PROPERTIES_MIM.KNOWN_SOURCE' IN TYPEOF ( edgp.source ) ) AND
		( 'EXTERNAL_PROPERTIES_MIM.KNOWN_SOURCE' + '.NAME' = 'ISO 13584 library' ) ); --tt found real problem here
	WHERE 
	  WR1: SIZEOF( QUERY( edgp <* plib_properties | 
		(SIZEOF( QUERY( edir <* USEDIN(edgp, 'EXTERNAL_ITEM_IDENTIFICATION_ASSIGNMENT_MIM.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
		(edir.role.name = 'version') )) <> 1) )) = 0; 
  END_RULE;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N5384 - ISO/TS 10303-1779 External representation item - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4745
*)

SCHEMA External_representation_item_mim;

USE FROM External_library_mim; -- ISO/CD-TS 10303-1778

USE FROM Foundation_representation_mim; -- ISO/TS 10303-1006

  TYPE eri_external_identification = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_representation_item);
  END_TYPE;

  ENTITY externally_defined_representation_item
    SUBTYPE OF (representation_item, externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_string
    SUBTYPE OF (externally_defined_representation_item);
  END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N5387 - ISO/TS 10303-1331 External source - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5076
*)

SCHEMA External_source_mim;

USE FROM external_reference_schema;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N5390 - ISO/TS 10303-1780 External unit - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4748
*)

SCHEMA External_unit_mim;

USE FROM External_library_mim; -- ISO/CD-TS 10303-1778

USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

USE FROM measure_schema;


  TYPE eu_external_identification_item = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_conversion_based_unit,
    externally_defined_context_dependent_unit);
  END_TYPE;

  ENTITY externally_defined_context_dependent_unit
    SUBTYPE OF (context_dependent_unit,externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_conversion_based_unit
    SUBTYPE OF (conversion_based_unit,externally_defined_item);
  END_ENTITY;

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- externally_conditioned_data_quality_criteria - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Externally_conditioned_data_quality_criteria_mim;

  USE FROM Document_assignment_mim;

  USE FROM Product_data_quality_criteria_mim;

  USE FROM Externally_conditioned_data_quality_inspection_result_mim;

  REFERENCE FROM support_resource_schema
    (bag_to_set);
 
  TYPE ecdq_document_reference_item =  EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (externally_conditioned_data_quality_criterion);
  END_TYPE; 
  
  ENTITY disallowed_assembly_relationship_usage
    SUBTYPE OF(externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF,
     ['PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE']);
  END_ENTITY;

  ENTITY excessive_use_of_groups
    SUBTYPE OF(externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, ['GROUP_SCHEMA.GROUP']);
  END_ENTITY;
  
  ENTITY excessive_use_of_layers
    SUBTYPE OF(Externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF,
    ['PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_LAYER_ASSIGNMENT']);
  END_ENTITY;

  ENTITY externally_conditioned_data_quality_criteria_representation
    SUBTYPE OF(Data_quality_criteria_representation);
    WHERE
      WR1 : SIZEOF( QUERY( q <* SELF\representation.items|
                               'EXTERNALLY_CONDITIONED_DATA_QUALITY_CRITERIA_MIM.' +
                               'EXTERNALLY_CONDITIONED_DATA_QUALITY_CRITERION' IN TYPEOF(q))) > 0;
  END_ENTITY;

  ENTITY externally_conditioned_data_quality_criterion
    SUBTYPE OF(Data_quality_criterion,Data_quality_measurement_requirement);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF,
              'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
              'DATA_QUALITY_CRITERION_ASSESSMENT_ASSOCIATION.'+
              'CRITERION')) = 0;
      WR2 : SIZEOF(QUERY(i1<*bag_to_set( USEDIN(SELF,'REPRESENTATION_SCHEMA.'+ 
                'REPRESENTATION_ITEM_RELATIONSHIP.'+ 'RELATED_REPRESENTATION_ITEM'))|
             'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+ 'DATA_QUALITY_CRITERION_MEASUREMENT_ASSOCIATION'
              IN TYPEOF(i1))) = 0;
      WR3 : SIZEOF(QUERY(i1<*bag_to_set( USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+
                'REPRESENTATION_ITEM_RELATIONSHIP.'+ 'RELATING_REPRESENTATION_ITEM'))|
             'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+ 'DATA_QUALITY_CRITERION_MEASUREMENT_ASSOCIATION'
             IN TYPEOF(i1))) = 0;
  END_ENTITY;

  ENTITY inappropriate_element_visibility
    SUBTYPE OF(Externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, 
      ['PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM']);
  END_ENTITY;

  ENTITY inappropriate_use_of_layer
    SUBTYPE OF(Externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, 
    ['PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_LAYER_ASSIGNMENT']);
  END_ENTITY;

  ENTITY inconsistent_element_reference
    SUBTYPE OF(Externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, 
    ['REPRESENTATION_SCHEMA.REPRESENTATION_ITEM']);
  END_ENTITY;

  ENTITY  non_agreed_accuracy_parameter_usage
    SUBTYPE OF(externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, 
     ['REPRESENTATION_SCHEMA.GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT']);
  END_ENTITY;
  
  ENTITY  non_agreed_scale_usage
    SUBTYPE OF(externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF,
     ['GEOMETRIY_SCHEMA.CARTESIAN_TRANSFORMATION_OPERATOR_3D']);
  END_ENTITY;

  ENTITY non_agreed_unit_usage
    SUBTYPE OF(externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF,
     ['MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT']);
  END_ENTITY;
  
  ENTITY non_referenced_coordinate_system
    SUBTYPE OF(Externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, 
      ['GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D']);
  END_ENTITY;

  ENTITY unused_shape_element
    SUBTYPE OF(Externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, 
    ['REPRESENTATION_SCHEMA.REPRESENTATION_ITEM']);
  END_ENTITY;

  ENTITY wrong_element_name
    SUBTYPE OF(Externally_conditioned_data_quality_criterion);
  WHERE
    WR1: validate_ecdq_inspected_elements_type(SELF, 
    ['REPRESENTATION_SCHEMA.REPRESENTATION_ITEM']);
  END_ENTITY;

  FUNCTION validate_ecdq_inspected_elements_type
      (ei:Externally_conditioned_data_quality_criterion;
       type_list:BAG OF STRING):LOGICAL;
       LOCAL
       sdqir: SET OF
        EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT:=[];
       dir: SET OF
        DATA_QUALITY_INSPECTION_INSTANCE_REPORT:=[];
       sdiri: SET OF
        EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_INSTANCE_REPORT_ITEM:=[];
         t_type_list:BAG OF STRING:=[];
       END_LOCAL;
     -- STEP-1
     -- collect all externally_conditioned_data_quality_inspection_instance_report_item
     -- instances associated with the given externally_conditioned_data_quality_criterion
     -- via externally_conditioned_data_quality_inspection_result and
     -- data_quality_inspection_instance_report

     sdqir := QUERY(q <* bag_to_set(USEDIN(ei,
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_RESULT.'+
                   'CRITERION_INSPECTED'))|
           'EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT'
            IN TYPEOF(q));
     IF(SIZEOF(sdqir) = 0) THEN
       RETURN(TRUE);
     END_IF;
     REPEAT i:= 1 TO SIZEOF(sdqir);
       dir := dir + QUERY(q <* bag_to_set(USEDIN(sdqir[i],
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_REPORT.'+
                   'INSPECTION_RESULT'))|
           'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'DATA_QUALITY_INSPECTION_INSTANCE_REPORT'
            IN TYPEOF(q));
     END_REPEAT;
     IF(SIZEOF(dir) = 0) THEN
       RETURN(TRUE);
     END_IF;

     REPEAT i:= 1 TO SIZEOF(dir);
       sdiri := sdiri + QUERY(q <* dir[i].inspected_instances|
           'EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_INSTANCE_REPORT_ITEM'
            IN TYPEOF(q));
     END_REPEAT;

     -- STEP-2
     -- check if the types of inspected_elements of the collected
     -- instances are exactly coincident with the type names in the 
     -- type list given as an input argument of this function.

     -- If there is no instance_report_item, then this function returns true.
     IF(SIZEOF(sdiri) = 0) THEN
       RETURN(TRUE);
     END_IF;
  
     -- When reports exist, then perform the following checking process.
     REPEAT i:= 1 TO SIZEOF(sdiri);
       -- If the size of inspected_elements is not equal to the size of
       -- type_list, then return false.
       IF(SIZEOF(sdiri[i].inspected_elements) <> 
          SIZEOF(type_list)) THEN
         RETURN(FALSE);
       END_IF;
       -- check all elements in the type_list 
       -- for each element of inspected_elements.
       t_type_list := type_list;
       REPEAT j:= 1 TO SIZEOF(sdiri[i].inspected_elements);
         REPEAT k:= 1 TO SIZEOF(t_type_list);
           IF(t_type_list[k] IN
              TYPEOF(sdiri[i].inspected_elements[j])) THEN
            t_type_list := t_type_list - t_type_list[k];
            ESCAPE;
           END_IF;
         END_REPEAT;
       END_REPEAT;
       IF(SIZEOF(t_type_list) > 0) THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
    
      RETURN(TRUE);
  END_FUNCTION;


END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- externally_conditioned_data_quality_inspection_result - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Externally_conditioned_data_quality_inspection_result_mim;

  USE FROM Appearance_assignment_mim;

  USE FROM Assembly_structure_mim;

  USE FROM Elemental_geometric_shape_mim;

  USE FROM Externally_conditioned_data_quality_criteria_mim;
  
  USE FROM Foundation_representation_mim;

  USE FROM Group_mim;
  
  USE FROM Layer_assignment_mim;

  USE FROM Product_data_quality_inspection_result_mim;

  REFERENCE FROM support_resource_schema(bag_to_set);

  TYPE inspected_ecdq_element_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON inspected_element_select WITH
    (assembly_component_usage,
     axis2_placement_3d,
     cartesian_transformation_operator_3d,
     global_uncertainty_assigned_context,
     global_unit_assigned_context,
     group,
     presentation_layer_assignment,
     representation_item,
     styled_item);
  END_TYPE;


  ENTITY externally_conditioned_data_quality_inspection_result_representation
    SUBTYPE OF(data_quality_inspection_result_representation);
    WHERE
      WR1 : SIZEOF( QUERY( q <* SELF\representation.items|
                               'EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT_MIM.' +
                               'EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT' IN TYPEOF(q))) > 0;
  END_ENTITY;

  ENTITY externally_conditioned_data_quality_inspection_result
    SUBTYPE OF(data_quality_inspection_result);
    WHERE
      WR1 : 'EXTERNALLY_CONDITIONED_DATA_QUALITY_CRITERIA_MIM.'+
            'EXTERNALLY_CONDITIONED_DATA_QUALITY_CRITERION' IN TYPEOF
            (SELF\data_quality_inspection_result.criterion_inspected);
  END_ENTITY;

  ENTITY externally_conditioned_data_quality_inspection_instance_report_item
    SUBTYPE OF(data_quality_inspection_instance_report_item);
      SELF\data_quality_inspection_instance_report_item.inspected_elements : SET [1:?] OF inspected_ecdq_element_select;
      WHERE
        WR1 : SIZEOF(QUERY(i1 <* 
                bag_to_set(USEDIN(SELF, 'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+ 
                'DATA_QUALITY_INSPECTION_INSTANCE_REPORT.'+ 'INSPECTED_INSTANCES'))|
                NOT('EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT_MIM.'+ 
                    'EXTERNALLY_CONDITIONED_DATA_QUALITY_INSPECTION_RESULT' 
                    IN TYPEOF(i1.inspection_result))))=0;
  END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6960 - ISO/TS 10303-1668 Fabrication joint - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6367
*)


SCHEMA Fabrication_joint_mim;

(*REFERENCE FROM*) USE FROM Land_mim;	-- ISO/TS 10303-1692
USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700
	
REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (acyclic_shape_aspect_relationship);
	
	
ENTITY connection_zone_based_fabrication_joint
  SUBTYPE OF (fabrication_joint);
END_ENTITY;

ENTITY fabrication_joint
  SUBTYPE OF (component_feature_joint);
WHERE
  WR1: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'FABRICATION_JOINT_MIM.'+
       'FABRICATION_JOINT');
END_ENTITY;

ENTITY passage_terminal_based_fabrication_joint_link
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6370 - ISO/TS 10303-1669 Fabrication requirement - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5645
*)


SCHEMA Fabrication_requirement_mim;

USE FROM Fabrication_technology_mim;	-- ISO/TS 10303-1670
	
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6963 - ISO/TS 10303-1670 Fabrication technology - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6373
*)


SCHEMA Fabrication_technology_mim;
    USE FROM Constructive_solid_geometry_2d_mim; 	-- ISO/TS 10303-1731
--	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051
USE FROM Requirement_decomposition_mim;

	USE FROM Part_template_mim; -- ISO/TS 10303-1722

TYPE ft_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	stratum_technology_occurrence_relationship);
END_TYPE;

TYPE ft_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
   (stratum_technology);
END_TYPE; 
	
TYPE ft_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (passage_technology,
    stratum_technology);
END_TYPE; 

TYPE ft_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (passage_technology,
     stratum_technology,
     stratum_technology_occurrence,
     stratum_technology_occurrence_relationship);
END_TYPE; 

SUBTYPE_CONSTRAINT ft_property_definition_subtypes FOR property_definition; 
    (ONEOF (stratum_technology_occurrence_relationship,
	 stratum_technology_occurrence));
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT ft_property_definition_relationship_subtypes FOR property_definition_relationship; 
    (ONEOF (stratum_technology_occurrence_relationship,
	 stratum_technology_swap_relationship));
END_SUBTYPE_CONSTRAINT;

ENTITY allocated_passage_minimum_annular_ring
  SUBTYPE OF (characterized_object);
END_ENTITY;    

ENTITY copy_stratum_technology_occurrence_relationship
  SUBTYPE OF (derived_stratum_technology_occurrence_relationship);
END_ENTITY;
  
ENTITY derived_stratum_technology_occurrence_relationship
  ABSTRACT SUPERTYPE OF (ONEOF (
    copy_stratum_technology_occurrence_relationship,
    inverse_copy_stratum_technology_occurrence_relationship))
  SUBTYPE OF (stratum_technology_occurrence_relationship);
END_ENTITY;

ENTITY design_stack_model
  SUBTYPE OF(stratum_stack_model);
END_ENTITY;

ENTITY equivalent_stackup_model_definition
  SUBTYPE OF (product_definition, product_definition_relationship);
    SELF\product_definition_relationship.relating_product_definition RENAMED primary_stackup_model   : stratum_stack_model;
    SELF\product_definition_relationship.related_product_definition RENAMED equivalent_stackup_model : stratum_stack_model;
  WHERE
    WR1 : primary_stackup_model :<>: equivalent_stackup_model;
END_ENTITY;
 
ENTITY equivalent_sub_stack_definition
  SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY footprint_library_stratum_technology
  SUBTYPE OF (stratum_technology);
END_ENTITY;

ENTITY impedance_measurement_setup_requirement
  SUBTYPE OF (predefined_requirement_view_definition);
END_ENTITY;

ENTITY impedance_requirement
  SUBTYPE OF (predefined_requirement_view_definition);
END_ENTITY;
  
ENTITY inverse_copy_stratum_technology_occurrence_relationship
  SUBTYPE OF (derived_stratum_technology_occurrence_relationship);
END_ENTITY;

ENTITY local_linear_stack
  SUBTYPE OF (stratum_sub_stack);
END_ENTITY;

ENTITY passage_deposition_material_identification
  SUBTYPE OF (material_designation);
    SELF\material_designation.definitions : SET [1:?] OF passage_technology;
END_ENTITY;

ENTITY passage_filling_material_identification
  SUBTYPE OF (material_designation);
    SELF\material_designation.definitions : SET [1:?] OF passage_technology;
END_ENTITY;

ENTITY passage_technology
  SUBTYPE OF (characterized_object, product_definition_shape);
  DERIVE
    SELF\property_definition.definition : characterized_definition := SELF;
UNIQUE
  UR1: SELF\characterized_object.name;
END_ENTITY;

ENTITY passage_technology_allocation_to_stack_model
  SUBTYPE OF (stratum_sub_stack);
END_ENTITY;

ENTITY stratum_sub_stack 
  ABSTRACT SUPERTYPE OF (ONEOF(local_linear_stack, 
    passage_technology_allocation_to_stack_model))
  SUBTYPE OF (part_template_definition);
END_ENTITY;      

ENTITY stratum_stack_model
  ABSTRACT SUPERTYPE
  SUBTYPE OF(part_template_definition);
END_ENTITY;

ENTITY stratum_surface_technology
  SUBTYPE OF (shape_aspect);
    SELF\shape_aspect.of_shape RENAMED associated_technology : stratum_technology;
END_ENTITY;
  
ENTITY stratum_technology
  SUBTYPE OF (characterized_object, product_definition_shape);
  DERIVE
    SELF\property_definition.definition : characterized_definition := SELF;
UNIQUE
  UR1: SELF\characterized_object.name;
END_ENTITY;

ENTITY stratum_technology_occurrence
  SUBTYPE OF(property_definition);
END_ENTITY;

ENTITY stratum_technology_occurrence_link
  SUBTYPE OF(stratum_technology_occurrence_relationship);
END_ENTITY;

ENTITY stratum_technology_occurrence_relationship
  ABSTRACT SUPERTYPE OF (ONEOF
    (derived_stratum_technology_occurrence_relationship,
     stratum_technology_occurrence_link,
     stratum_technology_occurrence_feature_constraint,
     stratum_technology_occurrence_swap_relationship))
  SUBTYPE OF(property_definition, property_definition_relationship);         
END_ENTITY;

ENTITY stratum_technology_occurrence_feature_constraint
  SUBTYPE OF (stratum_technology_occurrence_relationship);
END_ENTITY;

ENTITY stratum_technology_occurrence_swap_relationship
  SUBTYPE OF (stratum_technology_occurrence_relationship);
END_ENTITY;

ENTITY stratum_technology_swap_relationship
  SUBTYPE OF(property_definition_relationship);
END_ENTITY;

ENTITY stratum_technology_mapping_relationship
  SUBTYPE OF(property_definition_relationship);
END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1286 - ISO/TS 10303-1512 Faceted boundary representation - EXPRESS MIM
*)


SCHEMA Faceted_boundary_representation_mim;

USE FROM Elemental_geometric_shape_mim;

USE FROM aic_faceted_brep;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6966 - ISO/TS 10303-1671 Feature and connection zone - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6376
*)


SCHEMA Feature_and_connection_zone_mim;
	USE FROM Shape_feature_mim; -- ISO/TS 10303-1764
	USE FROM Surface_conditions_mim; -- ISO/TS 10303-1110
	
ENTITY connection_zone_interface_plane_relationship
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
  UR1: SELF\shape_aspect_relationship.name;
END_ENTITY;

ENTITY feature_definition_with_connection_area
  SUBTYPE OF (shape_feature_definition);
END_ENTITY;

END_SCHEMA;


(*
ISO TC184/SC4/WG12 N7112 - ISO/TS 10303-1127 File identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1205
*)

SCHEMA File_identification_mim;

USE FROM document_schema   -- ISO 10303-41
  (document,
   document_representation_type); 

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 


TYPE file_identification_item = SELECT BASED_ON identification_item WITH 
   (document_file);
END_TYPE; 

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH 
   (document_file);
END_TYPE; 

ENTITY document_file
  SUBTYPE OF (document, characterized_object);
WHERE
  WR1: SELF\characterized_object.name = '';
  WR2: NOT EXISTS(SELF\characterized_object.description);
  WR3: SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN ['digital', 'physical'])) = 1;
END_ENTITY;

END_SCHEMA;  -- File_identification_mim
(*
   ISO TC184/SC4/WG12 N6900 - ISO/TS 10303-1672 Fill area style - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5393
*)

SCHEMA Fill_area_style_mim;
USE FROM Basic_curve_mim;	-- ISO/TS 10303-1651
USE FROM Curve_appearance_mim;	-- ISO/TS 10303-1003
USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
USE FROM Extended_basic_geometry_mim;	-- ISO/TS 10303-1667	

USE FROM presentation_appearance_schema( -- ISO/TS 10303-46	
  externally_defined_hatch_style,
  externally_defined_tile_style,
  fill_area_style_colour,
  fill_area_style_hatching,
  fill_area_style_tiles,
  fill_area_style_tile_symbol_with_style);
	
END_SCHEMA;



(*
   ISO TC184/SC4/WG12 N6969 - ISO/TS 10303-1646 Footprint definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6379
*)

SCHEMA Footprint_definition_mim;

    USE FROM Layered_interconnect_complex_template_mim; -- ISO/TS 10303-1716
	USE FROM Package_mim;	-- ISO/TS 10303-1707

  SUBTYPE_CONSTRAINT multi_stratum_structured_template_subtypes FOR multi_stratum_structured_template;   
 	(ONEOF (padstack_definition, generic_footprint_definition, multi_stratum_special_symbol_template));
  END_SUBTYPE_CONSTRAINT;  

ENTITY breakout_footprint_definition
 SUBTYPE OF (generic_footprint_definition);
END_ENTITY; 
	
ENTITY footprint_definition
 SUBTYPE OF (generic_footprint_definition);
END_ENTITY; 

ENTITY generic_footprint_definition
 ABSTRACT SUPERTYPE OF (ONEOF (footprint_definition, breakout_footprint_definition))
 SUBTYPE OF (multi_stratum_structured_template);
END_ENTITY;

ENTITY package_footprint_relationship_definition
 SUBTYPE OF (part_template_definition);
END_ENTITY; 

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- form_feature_in_panel - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Form_feature_in_panel_mim;

USE FROM Shape_feature_mim;    -- ISO/TS 10303-1764
USE FROM Value_with_unit_extension_mim;    -- ISO/TS 10303-1753
USE FROM Basic_geometry_mim;    -- ISO/TS 10303-1652
USE FROM Machining_features_mim;    -- ISO/CD-TS 10303-xxxx
USE FROM Elemental_topology_mim;    -- ISO/TS 10303-1005
REFERENCE FROM product_property_representation_schema (
  get_property_definition_representations);
REFERENCE FROM Geometric_tolerance_mim (
  get_shape_aspect_property_definition_representations);  
REFERENCE FROM product_property_definition_schema (
  get_shape_aspects);  

ENTITY barring_hole
  SUBTYPE OF (feature_definition);
WHERE
  WR1:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'hole profile') AND
              (sa.description = 'closed profile occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.description = 'profile usage') AND
                (SIZEOF(['AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE',
                  'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
                  'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
                  'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE']
                  * TYPEOF(sar.relating_shape_aspect)
                 ) = 1 )
               )) = 1 )
             )) = 1;   
  WR2:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'barring profile') AND
              (sa.description = 'closed profile occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.description = 'profile usage') 
               )) = 1 )
             )) = 1;   
  WR3:  (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)
             )) = 1) AND
             (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
              {1 <= SIZEOF(pdr.used_representation.items) <= 2}
             )) = 1);   
  WR4:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
               NOT( i.name IN ['orientation','base radius'])
               )) > 0)
             )) = 0;   
  WR5:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='base radius') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) <> 1)
             )) = 0;   
END_ENTITY;


ENTITY bead
  SUBTYPE OF (feature_definition);
WHERE
  WR1:  (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)
             )) <= 1) AND
             (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               (SIZEOF(pdr.used_representation.items) > 2)
             )) = 0);   
  WR2:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
               NOT( i.name IN ['orientation','base radius'])
               )) > 0)
             )) = 0;   
  WR3:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='base radius') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) > 1)
             )) = 0;   
  WR4:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'sweep path') AND
              (sa.description = 'path feature component occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.description = 'path feature component usage') AND
                ('AIC_MACHINING_FEATURE.PATH_FEATURE_COMPONENT' IN
                 TYPEOF(sar.relating_shape_aspect))
               )) = 1 )
             )) = 1;   
  WR5:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'bead profile') AND
              (sa.description = 'open profile occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.description = 'profile usage') AND
                (SIZEOF(['AIC_MACHINING_FEATURE.OPEN_PATH_PROFILE',
                  'AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE',
                  'AIC_MACHINING_FEATURE.ROUNDED_U_PROFILE',
                  'AIC_MACHINING_FEATURE.SQUARE_U_PROFILE',
                  'AIC_MACHINING_FEATURE.TEE_PROFILE',
                  'AIC_MACHINING_FEATURE.VEE_PROFILE']
                  * TYPEOF(sar.relating_shape_aspect)
                 ) = 1 )
               )) = 1 )
             )) = 1;   
  WR6:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'end condition') AND
              (sa.description = 'bead end occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.name = 'bead end usage') AND
                (sar.description = 'starting' 
)  AND
                ('FORM_FEATURE_IN_PANEL_MIM.BEAD_END' IN
                 TYPEOF(sar.relating_shape_aspect))
               )) = 1 )
             )) = 1;   
  WR7:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'end condition') AND
              (sa.description = 'bead end occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.name = 'bead end usage') AND
                (sar.description = 'ending'
)  AND
                ('FORM_FEATURE_IN_PANEL_MIM.BEAD_END' IN
                 TYPEOF(sar.relating_shape_aspect))
               )) = 1 )
             )) = 1;   
END_ENTITY;


ENTITY bead_end
  SUBTYPE OF (shape_aspect);
WHERE
  WR1:  'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' IN
             TYPEOF(SELF.of_shape.definition);   
  WR2:   SELF.description IN ['linear','open','radiused'];
           
  WR3:  (SELF.description <> 'linear') XOR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) 
              )) > 0);   
  WR4:  (SELF.description <> 'linear') OR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               (SIZEOF(pdr.used_representation.items) = 2)
              )) = 1);   
  WR5:  (SELF.description <> 'linear') OR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
               TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='end length') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
              )) = 1);   
  WR6:  (SELF.description <> 'linear') OR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
               TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
               (i.name = 'end shape') AND 
               (i\descriptive_representation_item.description IN ['straight','tapered']) AND
                ('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
                 IN TYPEOF(i))
               )) = 1)
              )) = 1);   
  WR7:  SIZEOF( QUERY( sar <* USEDIN( SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
              'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
              ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' IN
               TYPEOF(sar)) AND
              (sar.name = 'bead end usage') AND
              (sar.description IN ['starting'
,'ending'
]) AND
              ('FORM_FEATURE_IN_PANEL_MIM.BEAD' IN
               TYPEOF(sar.related_shape_aspect.of_shape.definition)) AND
              (sar.related_shape_aspect.of_shape.definition\characterized_object.name = 'end condition') AND
              (sar.related_shape_aspect.of_shape.definition\characterized_object.description = 'bead end occurrence')
             )) = 1;   
END_ENTITY;

ENTITY directed_angle
  SUBTYPE OF (shape_aspect);
WHERE
  WR1:  'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' IN
             TYPEOF(SELF.of_shape.definition);   
  WR2:  SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) 
              )) = 1;   
  WR3:  SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               (SIZEOF(pdr.used_representation.items) = 1)
              )) = 1;   
  WR4:  SELF.description IN ['punch direction','profile normal','surface normal'];   
  WR5:  SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
               TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='angle') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
              )) = 1;   
END_ENTITY;

ENTITY feature_in_panel
  SUBTYPE OF (feature_definition);
WHERE
  WR1:  SELF.description IN ['pocket','boss','stairstep'];   
  WR2:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               NOT ({2 <= SIZEOF(pdr.used_representation.items) <= 3})
             )) = 0;   
  WR3:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
               NOT( i.name IN ['orientation','base radius','target radius'])
               )) > 0)
             )) = 0;   
  WR4:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='base radius') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR5:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='target radius') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR6:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'base boundary') AND
              (sa.description IN ['directed angle occurrence','closed profile occurrence'])
             )) = 1;   
  WR7:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'target boundary') AND
              (sa.description IN ['directed angle occurrence','closed profile occurrence'])
             )) = 1;   
  WR8:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.description = 'directed angle occurrence')
             )) <= 1;   
  WR9:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'directed angle occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 (sar.name = 'directed angle usage')  AND
                 ('FORM_FEATURE_IN_PANEL_MIM.DIRECTED_ANGLE' IN
                  TYPEOF(sar.relating_shape_aspect))
                )) = 1 )
              )) = 
              SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'directed angle occurrence')));   
  WR10: SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'closed profile occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 (sar.description = 'profile usage')  AND
                 (SIZEOF(['AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE',
 'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
 'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
 'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE']
 * TYPEOF(sar.relating_shape_aspect)
                  ) = 1 )
                )) = 1 )
              )) = 
              SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'closed profile occurrence')));   
  WR11: (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              'AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' IN 
              TYPEOF(pdr.used_representation)
             )) <= 1) AND
             (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' IN 
                TYPEOF(pdr.used_representation)) AND
               NOT(pdr.used_representation.name = 'target face')
             )) = 0);   
  WR12: (SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
                (sa.name = 'target boundary') AND
                (sa.description = 'directed angle occurrence')
               )) = 0) OR
              (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' IN 
                TYPEOF(pdr.used_representation)) 
              )) = 1);   
END_ENTITY;

ENTITY hole_in_panel
  SUBTYPE OF (feature_definition);
WHERE
  WR1:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'hole profile') AND
              (sa.description = 'closed profile occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.description = 'profile usage') AND
                (SIZEOF(['AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE',
                  'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
                  'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
                  'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE']
                  * TYPEOF(sar.relating_shape_aspect)
                 ) = 1 )
               )) = 1 )
             )) = 1;   
  WR2:  SIZEOF( get_property_definition_representations(SELF)) =
             SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              SIZEOF( pdr.used_representation.items) = 1));   
END_ENTITY;

ENTITY joggle
  SUBTYPE OF (feature_definition);
WHERE
  WR1:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               NOT({5 <= SIZEOF(pdr.used_representation.items) <= 10})
             )) = 0;   
  WR2:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               (SIZEOF( QUERY( i <* pdr.used_representation.items |
                 NOT(i.name IN ['orientation','base radius 1','base radius 2','direction angle 1',
       'direction angle 2','height','slope angle 1','slope angle 2',
       'top radius 1','top radius 2'])
                )) > 0)
             )) = 0;   
  WR3:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='direction angle 1') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR4:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='direction angle 2') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR5:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='height') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) <= 1;   
  WR6:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='slope angle 1') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR7:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='slope angle 2') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR8:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'defining path') AND
              (sa.description = 'path feature component occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.description = 'path feature component usage')  AND
                ('AIC_MACHINING_FEATURE.PATH_FEATURE_COMPONENT' IN
                 TYPEOF(sar.relating_shape_aspect)) AND
                (sar.relating_shape_aspect.description = 'linear')
               )) = 1 )
             )) = 1;   
  WR9:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
              (sa.name = 'termination') AND
              (sa.description = 'joggle termination occurrence') AND
              (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
                'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' IN
                 TYPEOF(sar)) AND
                (sar.name = 'joggle termination usage')  AND
                ('FORM_FEATURE_IN_PANEL_MIM.JOGGLE_TERMINATION' IN
                 TYPEOF(sar.relating_shape_aspect)) 
               )) = 1 )
             )) = 1;   
  WR10: SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='base radius 1') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) <= 1;   
  WR11: SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='base radius 2') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
              )) <= 1;   
  WR12: SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='top radius 1') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
              )) <= 1;   
  WR13: SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='top radius 2') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
              )) <= 1;   
END_ENTITY;


ENTITY joggle_termination
  SUBTYPE OF (shape_aspect);
WHERE
  WR1:  'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' IN
              TYPEOF(SELF.of_shape.definition);   
  WR2:  SELF.description IN ['value termination','face termination'];   
  WR3:  (SELF.description = 'value termination') XOR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) 
              )) = 0);   
  WR4:  (SELF.description <> 'value termination') OR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               (SIZEOF(pdr.used_representation.items) = 2)
              )) = 1);   
  WR5:  (SELF.description <> 'value termination') OR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
               TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='depth') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
              )) = 1);   
  WR6:  (SELF.description <> 'value termination') OR
             (SIZEOF( QUERY( pdr <* get_shape_aspect_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
               TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='angle') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
              )) = 1);   
  WR7:  SIZEOF( QUERY( sar <* USEDIN( SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' +
               'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
               ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' IN
                TYPEOF(sar)) AND
               (sar.name = 'joggle termination usage') AND
               ('FORM_FEATURE_IN_PANEL_MIM.JOGGLE' IN TYPEOF(sar.related_shape_aspect.of_shape.definition)) AND
               (sar.related_shape_aspect.of_shape.definition\characterized_object.name = 'termination') AND
               (sar.related_shape_aspect.of_shape.definition\characterized_object.description = 'joggle termination occurrence')
              )) = 1;   
END_ENTITY;

ENTITY locator
  SUBTYPE OF (feature_definition);
WHERE
  WR1:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
                TYPEOF(pdr.used_representation)) AND
               NOT ({2 <= SIZEOF(pdr.used_representation.items) <= 5})
             )) = 0;   
  WR2:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='diameter') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR3:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='tip radius') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) <= 1;   
  WR4:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='tip angle') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) = 1;   
  WR5:  SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)) AND
              (SIZEOF( QUERY( i <* pdr.used_representation.items |
                (i.name='base radius') AND
                (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2)
               )) = 1)
             )) <= 1;   
END_ENTITY;


END_SCHEMA;
(* 
ISO TC184/SC4/WG12 N6903 - ISO/TS 10303-1006 Foundation representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4349
*) 


SCHEMA Foundation_representation_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   id_attribute,
   id_attribute_select); 

USE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item); 

USE FROM representation_schema   -- ISO 10303-43
  (global_uncertainty_assigned_context,
   representation,
   representation_context,
   representation_item,
   representation_relationship,
   uncertainty_measure_with_unit); 

USE FROM Support_resource_mim;

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Foundation_representation_mim
(*
   ISO TC184/SC4/WG12 N6382 - ISO/TS 10303-1674 Functional assignment to part - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5654
*)


SCHEMA Functional_assignment_to_part_mim;
	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732
	USE FROM Physical_connectivity_definition_mim;	-- ISO/TS 10303-1755	

TYPE fatp_groupable_item = SELECT BASED_ON groupable_item WITH 
   (part_connected_terminals_definition);
END_TYPE; 

TYPE fatp_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
  (part_connected_terminals_element,
   part_connected_terminals_definition);
END_TYPE; 

ENTITY part_connected_terminals_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name;
END_ENTITY;

ENTITY part_connected_terminals_definition_domain
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY part_connected_terminals_element
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
END_ENTITY;

ENTITY part_connected_terminals_structure_definition
  SUBTYPE OF (part_connected_terminals_definition);
END_ENTITY;

ENTITY part_connected_terminals_layout_topology_requirement_assignment
  SUBTYPE OF(requirement_assignment);
END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N5396 - ISO/TS 10303-1216 Functional breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4938
*) 

SCHEMA Functional_breakdown_mim;

USE FROM Product_breakdown_mim;    -- ISO/TS 10303-1248

  ENTITY functional_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY;

  ENTITY functional_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N3973 - ISO/TS 10303-1675 Functional decomposition to assembly design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3418
*)


SCHEMA Functional_decomposition_to_assembly_design_mim;
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
	USE FROM Functional_decomposition_to_design_mim; -- ISO/TS 10303-1676
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N3976 - ISO/TS 10303-1676 Functional decomposition to design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3421
*)


SCHEMA Functional_decomposition_to_design_mim;

USE FROM Change_management_mim;	-- ISO/TS 10303-1661
USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728
USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704	

TYPE fdtd_change_management_object = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON change_management_object WITH 
	(product_definition_relationship,
	property_definition_relationship);
END_TYPE;

TYPE fdtd_groupable_item = SELECT BASED_ON groupable_item WITH 
   (component_functional_unit);
END_TYPE; 

ENTITY design_composition_path
  SUBTYPE OF (applied_group_assignment, product_definition);
END_ENTITY;

ENTITY reference_composition_path
  SUBTYPE OF (applied_group_assignment, product_definition);
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N3979 - ISO/TS 10303-1677 Functional decomposition to interconnect design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3424
*)


SCHEMA Functional_decomposition_to_interconnect_design_mim;

	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
	USE FROM Functional_decomposition_to_design_mim; -- ISO/TS 10303-1676	

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N3982 - ISO/TS 10303-1678 Functional decomposition with nodal representation to packaged mapping - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3430
*)


SCHEMA Functional_decomposition_with_nodal_representation_to_packaged_mapping_mim;
	USE FROM Functional_decomposition_to_design_mim; -- ISO/TS 10303-1676
	USE FROM Physical_connectivity_definition_mim;	-- ISO/TS 10303-1755

TYPE fdwnrtpm_groupable_item = SELECT BASED_ON groupable_item WITH 
   (network_node_definition);
END_TYPE; 

ENTITY aggregate_connectivity_requirement
  SUBTYPE OF (applied_group_assignment, product_definition);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6385 - ISO/TS 10303-1679 Functional specification - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5657
*)


SCHEMA Functional_specification_mim;
	USE FROM Signal_mim;	-- ISO/TS 10303-1745
	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704	
	
	USE FROM Application_context_schema(application_context_element);	

TYPE fs_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
   (functional_specification);
END_TYPE; 

TYPE fs_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (representation);
END_TYPE; 
	
ENTITY functional_specification
  SUBTYPE OF (representation);
END_ENTITY;
	
ENTITY functional_specification_definition
  SUBTYPE OF (functional_unit);
END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N3988 - ISO/TS 10303-1680 Functional unit requirement allocation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3433
*)


SCHEMA Functional_unit_requirement_allocation_mim;
	USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704
	
TYPE fura_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (component_functional_unit);
END_TYPE; 
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6972 - ISO/TS 10303-1705 Functional usage view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6388
*)
SCHEMA Functional_usage_view_mim;

USE FROM Analytical_model_mim;	-- ISO/TS 10303-1603
USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704
USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032	
USE FROM document_schema(document_type);
USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 

USE FROM product_property_definition_schema
	(shape_aspect,
	shape_aspect_relationship);

USE FROM material_property_definition_schema(property_definition_relationship);

  TYPE fuuv_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
     (functional_unit_terminal_definition);
  END_TYPE; 

  TYPE nfuv_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
    (shape_aspect);
  END_TYPE;

  ENTITY functional_terminal_group
    SUBTYPE OF (group);
    UNIQUE
      UR1: SELF\group.name;
  END_ENTITY;

  ENTITY functional_unit
    SUBTYPE OF (product_definition, product_definition_shape);
    DERIVE
      SELF\property_definition.definition : functional_unit := SELF;
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) = 0;
      WR2: NOT EXISTS(SELF\property_definition.description);
  END_ENTITY;

  ENTITY functional_unit_terminal_definition
    SUBTYPE OF (shape_aspect);
      SELF\shape_aspect.of_shape : functional_unit;
    UNIQUE
      UR1: SELF\shape_aspect.name, of_shape;
    WHERE
      WR1: SELF\shape_aspect.product_definitional = FALSE;
  END_ENTITY;

  ENTITY make_from_functional_unit_terminal_definition_relationship
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    UNIQUE
      UR1: SELF\shape_aspect_relationship.relating_shape_aspect, 
        SELF\shape_aspect_relationship.related_shape_aspect;
    WHERE
      WR1: relating_shape_aspect.of_shape :<>: 
        related_shape_aspect.of_shape;
      WR2: SELF\shape_aspect.product_definitional = FALSE;
  END_ENTITY;

  ENTITY scalar_terminal_definition_link
    SUBTYPE OF (shape_aspect,shape_aspect_relationship);
      SELF\shape_aspect_relationship.relating_shape_aspect : functional_unit_terminal_definition;
    UNIQUE
      UR1: related_shape_aspect, relating_shape_aspect;
    WHERE
      WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
        SELF\shape_aspect_relationship.relating_shape_aspect;
  END_ENTITY; 

END_SCHEMA;

(*
ISO TC184/SC4/WG12 N7068 - ISO/TS 10303-1007 General surface appearance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5399
*)

SCHEMA General_surface_appearance_mim;

USE FROM Curve_appearance_mim; -- ISO/TS 10303-1003

USE FROM presentation_appearance_schema	
 ( fill_area_style_colour, 
   fill_area_style_tile_curve_with_style, 
   fill_area_style_tile_coloured_region, 
   fill_area_style_tile_symbol_with_style, 
   pre_defined_surface_side_style,
   pre_defined_tile, 
   externally_defined_tile, 
   surface_side,
   surface_side_style,
   surface_style_boundary,
   surface_style_control_grid,
   surface_style_rendering,
   surface_style_fill_area,
   surface_style_parameter_line,
   surface_style_segmentation_curve,
   surface_style_silhouette,
   surface_style_usage,
   u_direction_count,
   v_direction_count);

END_SCHEMA;
(* 
 ISO TC184/SC4/WG12 N7218 - ISO/TS 10303-1341 Generic expression - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2553
*)

SCHEMA Generic_expression_mim;

USE FROM iso13584_generic_expressions_schema(
	binary_generic_expression,
	environment,
	generic_expression,
	generic_literal,
	generic_variable,
	multiple_arity_generic_expression,
	simple_generic_expression,
	unary_generic_expression,
	variable_semantics
	);
	
USE FROM iso13584_expressions_schema(
	variable);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N5402 - ISO/TS 10303-1681 Generic material aspects - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4980
*)

SCHEMA Generic_material_aspects_mim;

USE FROM Independent_property_representation_mim;	-- ISO/TS 10303-1038

USE FROM material_property_definition_schema(
  material_designation,
  material_designation_characterization,
  material_property);

USE FROM material_property_representation_schema (
  data_environment,  
  material_property_representation);

  ENTITY general_material_property 
    SUBTYPE OF (general_property); 
    WHERE 
      WR1: SIZEOF( QUERY( gpa <* USEDIN(SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | 
        NOT ('MATERIAL_PROPERTY_DEFINITION_SCHEMA.MATERIAL_PROPERTY' IN TYPEOF(gpa\general_property_association.derived_definition)) )) = 0; 
  END_ENTITY; 

END_SCHEMA;

(*
  ISO TC184/SC4/WG12 N7206 - ISO/TS 10303-1789 Geometric constraints - EXPRESS MIM
*)

SCHEMA Geometric_constraints_mim;

USE FROM Basic_curve_mim;
USE FROM Composite_surface_mim;
USE FROM Explicit_constraints_mim;  -- ISO 10303-1pc2
USE FROM Primitive_solids_mim;  -- ISO 10303-1pc4
USE FROM Swept_solid_mim;  -- ISO 10303-1321

USE FROM explicit_geometric_constraint_schema;  -- ISO 10303-108

USE FROM geometry_schema  -- ISO 10303-42
             (composite_curve_segment,
              surface_patch);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6626 - ISO/TS 10303-1404 Geometric_model_2d_3d_relationship - EXPRESS MIM
*)

SCHEMA Geometric_model_2d_3d_relationship_mim;

USE FROM Contextual_shape_positioning_mim;          -- ISO/TS 10303-1027
USE FROM Geometric_model_relationship_mim;          -- ISO/TS 10303-1403
REFERENCE FROM support_resource_schema (bag_to_set); -- ISO 10303-41
REFERENCE FROM representation_schema (acyclic_representation_relationship); -- ISO 10303-43

ENTITY coordinated_geometric_relationship_with_2d_3d_placement_transformation
 SUBTYPE OF(shape_representation_relationship,
            representation_relationship_with_transformation);
 SELF\representation_relationship_with_transformation.transformation_operator : axis_placement_2d_3d_mapping;          
 WHERE
  WR1: acyclic_representation_relationship(SELF,
       [SELF\representation_relationship.rep_2],
        'REPRESENTATION_SCHEMA.'+'REPRESENTATION');
  WR2: NOT('REPRESENTATION_SCHEMA.DEFINITIONAL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(SELF));
END_ENTITY;

ENTITY axis_placement_2d_3d_mapping
  SUBTYPE OF (item_defined_transformation);
   SELF\item_defined_transformation.transform_item_1 : axis2_placement_2d;
   SELF\item_defined_transformation.transform_item_2 : axis2_placement_3d;
END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6906 - ISO/TS 10303-1403 Geometric model relationship - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6614
*)   
SCHEMA Geometric_model_relationship_mim;

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM representation_schema(
  definitional_representation_relationship
);

USE FROM product_property_representation_schema -- ISO 10303-41
  (shape_representation_relationship);


END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6909 - ISO/TS 10303-1051 Geometric tolerance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6757
*) 


SCHEMA Geometric_tolerance_mim;

USE FROM Derived_shape_element_mim;    -- ISO/TS 10303-1130
USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118
USE FROM Value_with_unit_extension_mim;  -- ISO/TS 10303-1753
USE FROM Support_resource_mim;
USE FROM Shape_composition_mim;         --  ISO/TS 10303-1742
USE FROM Dimension_tolerance_mim;    -- ISO/TS 10303-1050
USE FROM Feature_and_connection_zone_mim;

-- USE FROM aic_geometric_tolerances;    ISO 10303-519
USE FROM shape_aspect_definition_schema ( 
  all_around_shape_aspect,
  apex, 
  between_shape_aspect,
  centre_of_symmetry, 
  continuous_shape_aspect,
  composite_shape_aspect,
  composite_group_shape_aspect, 
  common_datum, 
  common_datum_list,
  contacting_feature,
  datum, 
  datum_feature, 
  datum_reference_modifier_with_value,
  datum_reference, 
  datum_reference_compartment,
  datum_reference_element,
  datum_system,
  datum_target, 
  derived_shape_aspect, 
  extension, 
  general_datum_reference, 
  geometric_alignment, 
  geometric_contact,
  geometric_intersection,
  parallel_offset, 
  perpendicular_to, 
  referenced_modified_datum, 
  simple_datum_reference_modifier,
  shape_aspect_deriving_relationship, 
  symmetric_shape_aspect, 
  tangent);
  
USE FROM shape_tolerance_schema ( 
  dimension_related_tolerance_zone_element, 
  geometric_tolerance, 
  geometric_tolerance_relationship, 
  geometric_tolerance_with_datum_reference, 
  geometric_tolerance_with_defined_unit,
  geometric_tolerance_with_defined_area_unit,
  geometric_tolerance_with_maximum_tolerance,
  geometric_tolerance_with_modifiers, 
  modified_geometric_tolerance,
  non_uniform_zone_definition, 
  projected_zone_definition, 
  projected_zone_definition_with_offset,
  runout_zone_definition, 
  runout_zone_orientation_reference_direction, 
  tolerance_zone, 
  tolerance_zone_definition,
  tolerance_zone_form,
  cylindricity_tolerance,
  flatness_tolerance,
  line_profile_tolerance,
  position_tolerance,
  roundness_tolerance,
  straightness_tolerance,
  surface_profile_tolerance,
  angularity_tolerance,
  circular_runout_tolerance,
  coaxiality_tolerance,
  concentricity_tolerance,
  parallelism_tolerance,
  perpendicularity_tolerance,
  symmetry_tolerance,
  total_runout_tolerance,
  unequally_disposed_geometric_tolerance);

USE FROM product_property_definition_schema     -- ISO 10303-41
  (property_definition);

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation,
   shape_representation); 

USE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_qualification,
   precision_qualifier,
   type_qualifier,
   value_qualifier); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   type_check_function); 

ENTITY feature_for_datum_target_relationship
  SUBTYPE OF (shape_aspect_relationship);
  SELF\shape_aspect_relationship.related_shape_aspect : datum_target;
UNIQUE
  UR1: related_shape_aspect;
WHERE
  WR1: relating_shape_aspect.of_shape :=: related_shape_aspect.of_shape;
  WR2: relating_shape_aspect\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY placed_datum_target_feature
  SUBTYPE OF (datum_target);
DERIVE
  representation_associations : SET[0:?] OF property_definition_representation := get_shape_aspect_property_definition_representations(SELF);
WHERE
  WR1: SELF.description IN ['point','line','rectangle','circle','circular curve'];
  WR2: SIZEOF (QUERY (pdr <* representation_associations | 'GEOMETRIC_TOLERANCE_MIM.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF (pdr.used_representation) )) = 1;
  WR3: valid_datum_target_parameters(SELF);
END_ENTITY;

FUNCTION get_shape_aspect_property_definition_representations
 (s_a_instance : shape_aspect) : SET OF property_definition_representation; 
LOCAL
pd_set : SET OF property_definition := [];
pdr_set : SET OF property_definition_representation := [] ;
END_LOCAL;
pd_set := bag_to_set(USEDIN(s_a_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
IF (SIZEOF(pd_set) < 1) THEN
RETURN (pdr_set);
END_IF;
REPEAT i := 1 TO HIINDEX(pd_set);
pdr_set := pdr_set + (QUERY(pdr <* USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION') |
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
END_REPEAT;
RETURN (pdr_set);      
END_FUNCTION; 

FUNCTION valid_datum_target_parameters (pdf : placed_datum_target_feature) : BOOLEAN; 
  LOCAL
    rep_set : SET OF representation := [] ;
    parameter_representations: SET OF representation;
  END_LOCAL;

  REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
    rep_set := rep_set + pdf.representation_associations[i].used_representation;
  END_REPEAT;
  parameter_representations := QUERY(rep <* rep_set | ('GEOMETRIC_TOLERANCE_MIM.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(rep)));

  IF (SIZEOF( QUERY( srwp <* parameter_representations |
          (SIZEOF( QUERY( i <* srwp.items |
          (i.name='orientation') AND
          ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF(i)))) = 1))) <> 1) THEN
    RETURN(FALSE);
  END_IF;
  CASE pdf\shape_aspect.description OF
    'point': RETURN(SIZEOF(QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 1))) = 1);
    'circle', 'circular curve': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items) = 2))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target diameter') AND
                (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
		   'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1));
    'line': RETURN(SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
		'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2) )) = 1))) = 1);
    'rectangle': RETURN((SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF(srwp.items)= 3))) = 1) AND
             (SIZEOF( QUERY( srwp <* parameter_representations |
              (SIZEOF( QUERY( i <* srwp.items |
                (i.name='target length') AND
                (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
		'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                 ) = 2))) = 1))) = 1) AND
              (SIZEOF( QUERY( srwp <* parameter_representations |
               (SIZEOF( QUERY( i <* srwp.items |
                 (i.name='target width') AND
                 (SIZEOF(['GEOMETRIC_TOLERANCE_MIM.MEASURE_REPRESENTATION_ITEM',
 		'GEOMETRIC_TOLERANCE_MIM.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                  ) = 2))) = 1) )) = 1));
    OTHERWISE : RETURN(FALSE);
  END_CASE;
END_FUNCTION;
 
RULE unique_gdt_element_id_constraint for (
                                          product_definition_shape,
                                          dimensional_location,
                                          dimensional_size,
                                          shape_aspect,
                                          shape_aspect_relationship);
LOCAL
 bss  : BAG OF STRING := [];
 ds   : SET OF dimensional_size := QUERY(ds <* dimensional_size | EXISTS(ds\dimensional_size.id));
 sa   : SET OF shape_aspect := QUERY(sa <* shape_aspect | EXISTS(sa\shape_aspect.id));
 sar  : SET OF shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship | EXISTS(sar\shape_aspect_relationship.id));
 ssa  : SET OF shape_aspect := []; 
 pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT ii := 1 TO SIZEOF (product_definition_shape) WHILE pass;
 bss := [];
 ssa := bag_to_set(USEDIN(product_definition_shape[ii], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT.' + 'OF_SHAPE'));

 REPEAT i := 1 to SIZEOF (ds);
  IF (ds[i]\dimensional_size.applies_to IN ssa) THEN
   bss := bss + ds[i]\dimensional_size.id;
  END_IF;
 END_REPEAT;

 REPEAT i := 1 to SIZEOF (sa);
  IF (sa[i] IN ssa) THEN
   bss := bss + sa[i]\shape_aspect.id;
  END_IF;
 END_REPEAT;

 REPEAT i := 1 to SIZEOF (sar);
  IF (sar[i]\shape_aspect_relationship.relating_shape_aspect IN ssa) THEN
   bss := bss + sar[i]\shape_aspect_relationship.id;
  END_IF;
 END_REPEAT;

 IF (SIZEOF(bag_to_set(bss)) <> SIZEOF(bss)) THEN pass := FALSE;
 END_IF;
END_REPEAT;
WHERE
  WR1 : pass;
END_RULE;

RULE tolerance_zone_form_name_constraint for (tolerance_zone_form);
LOCAL
 names : SET OF STRING :=
  [ 'within a circle',
    'between two concentric circles',
    'between two equidistant curves',
    'within a cylinder',
    'between two coaxial cylinders',
    'between two equidistant surfaces',
    'non uniform',
    'cylindrical or circular',
    'spherical',
    'unknown'];
 pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(tolerance_zone_form) WHILE pass;
 pass := (tolerance_zone_form[i].name IN names);
END_REPEAT;
WHERE
 WR1: pass;
END_RULE;

END_SCHEMA;  -- Geometric_tolerance_mim
(*
 ISO TC184/SC4/WG12 N2131 - ISO/TS 10303-1039 Geometric validation property representation - EXPRESS MIM
*)

SCHEMA Geometric_validation_property_representation_mim; 

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Measure_representation_mim;    -- ISO/TS 10303-1118

USE FROM product_property_definition_schema   -- ISO 10303-41
  (property_definition,
   shape_aspect); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation,
   shape_definition_representation); 


END_SCHEMA;  -- Geometric_validation_property_representation_mim
(*
 ISO TC184/SC4/WG12 N7236 - ISO/TS 10303-1507 Geometrically bounded surface - EXPRESS MIM
*)
SCHEMA Geometrically_bounded_surface_mim;

USE FROM aic_geometrically_bounded_surface;

USE FROM Basic_curve_mim;

USE FROM B_spline_geometry_mim;

USE FROM geometry_schema(boundary_curve, curve_bounded_surface); -- ISO 10303-42

USE FROM geometric_model_schema(geometric_set); -- ISO 10303-42 

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N1280 - ISO/TS 10303-1510 Geometrically bounded wireframe - EXPRESS MIM
*)
SCHEMA Geometrically_bounded_wireframe_mim;

USE FROM aic_geometrically_bounded_wireframe;		-- ISO 10303-510
USE FROM Elemental_geometric_shape_mim;			

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N4276 - ISO/TS 10303-1113 Group - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3246
*) 


SCHEMA Group_mim;

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM Basic_attribute_schema(
	id_attribute, 
	id_attribute_select); -- ISO/IS 10303-41

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT;
WHERE
  WR1: NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF));
END_TYPE; 

ENTITY applied_group_assignment
  SUBTYPE OF (group_assignment);
  items : SET[1:?] OF groupable_item;
END_ENTITY;

END_SCHEMA;  -- Group_mim

(*
ISO TC184/SC4/WG12 N7115 - ISO/TS 10303-1021 Identification assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2915
*)

SCHEMA Identification_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_assignment); 


TYPE identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_identification_assignment
  SUBTYPE OF (identification_assignment);
  items : SET[1:?] OF identification_item;
END_ENTITY;

END_SCHEMA;  -- Identification_assignment_mim
(*  
   ISO TC184/SC4/WG12 N5408 - ISO/TS 10303-1349 Incomplete data reference mechanism - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4941
*)
SCHEMA Incomplete_data_reference_mechanism_mim;

USE FROM Classification_assignment_mim;

USE FROM Document_definition_mim;

USE FROM Part_view_definition_mim;

  TYPE idrm_marked_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH
    (document_file,
     product_definition);
  END_TYPE;

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N1238 - ISO/TS 10303-1036 Independent property - EXPRESS MIM
*)
SCHEMA Independent_property_mim;

USE FROM product_property_definition_schema
(general_property,
 general_property_relationship);

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N4372 - ISO/TS 10303-1038 Independent property representation - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1244
*)
SCHEMA Independent_property_representation_mim;

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N2638 - ISO/TS 10303-1350 Inertia characteristics - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2072
*)
(* Proposed solution to SEDS #1295 is incorporated in this schema. *)

SCHEMA Inertia_characteristics_mim;

USE FROM Elemental_geometric_shape_mim;

USE FROM Shape_property_assignment_mim;

USE FROM Value_with_unit_mim;

USE FROM representation_schema
	(compound_representation_item,
	list_representation_item); 

ENTITY moments_of_inertia_representation 
SUBTYPE OF (representation); 
WHERE 
WR1: (SIZEOF(SELF.items) = 1) AND 
 (SIZEOF( QUERY( i <* SELF.items | ('REPRESENTATION_SCHEMA.' + 'COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  (i.name = 'moments of inertia matrix') )) = 1); 
WR2: SIZEOF( QUERY( i <* SELF.items | ('REPRESENTATION_SCHEMA.' + 'COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
  ('REPRESENTATION_SCHEMA.' + 'LIST_REPRESENTATION_ITEM' IN TYPEOF(i\compound_representation_item.item_element)) AND 
  value_range_aggregate_rep_item (i\compound_representation_item.item_element) )) = 1; 
END_ENTITY; 

RULE restrict_centre_of_mass_representation FOR
    (representation);
WHERE
 WR1: SIZEOF ( QUERY ( r <* representation | 
	( r.name ='centre of mass' ) AND 
	( ( SIZEOF ( r.items ) <>1 ) OR 
	(SIZEOF ( QUERY ( i <* r.items | 
	( 'GEOMETRY_SCHEMA.' + 'POINT' IN TYPEOF ( i ) ) AND 
	( i.name = 'centre point' ) )) <>1 ) ) ) ) 
	=0;
END_RULE;

FUNCTION value_range_aggregate_rep_item (agg : AGGREGATE OF representation_item) : BOOLEAN; 
  BEGIN 
  IF (SIZEOF(QUERY(i1 <* agg | ('QUALIFIED_MEASURE_SCHEMA.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) )) = 6) THEN 
	  RETURN (TRUE); 
   ELSE 
	RETURN (FALSE); 
   END_IF; 
   END; 
END_FUNCTION; 

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6238 - ISO/TS 10303-1761 Information product - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4228
*)

SCHEMA Information_product_mim;

USE FROM Product_view_definition_mim;	--  ISO/TS 10303-1019
USE FROM File_identification_mim;	--  ISO/TS 10303-1127
USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N6124 - ISO/TS 10303-1241 Information rights - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3059
*) 


SCHEMA Information_rights_mim;

USE FROM action_schema   -- ISO 10303-41
  (action_method,
   action_method_relationship); 

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM Management_resource_information_mim;    -- ISO/TS 10303-1288


TYPE ir_approval_item = SELECT BASED_ON mri_approval_item WITH 
   (applied_usage_right, 
    information_usage_right);
END_TYPE; 

TYPE ir_contract_item = SELECT BASED_ON contract_item WITH 
   (information_usage_right);
END_TYPE; 

TYPE ir_date_and_time_item = SELECT BASED_ON mri_date_and_time_item WITH 
   (information_usage_right);
END_TYPE; 

TYPE ir_date_item = SELECT BASED_ON mri_date_item WITH 
   (information_usage_right);
END_TYPE; 

TYPE ir_identification_item = SELECT BASED_ON mri_identification_item WITH 
   (information_right, 
    information_usage_right);
END_TYPE; 

TYPE ir_organization_item = SELECT BASED_ON mri_organization_item WITH 
   (information_usage_right);
END_TYPE; 

TYPE ir_person_and_organization_item = SELECT BASED_ON mri_person_and_organization_item WITH 
   (information_usage_right);
END_TYPE; 

TYPE ir_usage_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items;
END_TYPE; 

ENTITY applied_usage_right
  SUBTYPE OF (applied_action_assignment);
  SELF\applied_action_assignment.items : SET[1:?] OF ir_usage_item;
END_ENTITY;

ENTITY information_right
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY information_usage_right
  SUBTYPE OF (action_method);
END_ENTITY;

ENTITY right_to_usage_association
  SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.relating_method RENAMED right_usage : information_usage_right;
  SELF\action_method_relationship.related_method RENAMED right_applied : information_right;
END_ENTITY;

ENTITY usage_association
  SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.relating_method RENAMED relating : information_usage_right;
  SELF\action_method_relationship.related_method RENAMED related : information_usage_right;
END_ENTITY;

END_SCHEMA;  -- Information_rights_mim



(*
   ISO TC184/SC4/WG12 N6692 - ISO/TS 10303-1763 Integral shield - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4234
*)

SCHEMA Integral_shield_mim;

USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700
USE FROM Requirement_assignment_mim;

ENTITY integral_shield
  SUBTYPE OF (laminate_component);
END_ENTITY;

ENTITY routed_shield 
    SUBTYPE OF (integral_shield);
END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6975 - ISO/TS 10303-1682 Interconnect 2d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6391
*)


SCHEMA Interconnect_2d_shape_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
	USE FROM Physical_unit_2d_design_view_mim;	-- ISO/TS 10303-1724

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6394 - ISO/TS 10303-1684 Interconnect module connection routing - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5663
*)


SCHEMA Interconnect_module_connection_routing_mim;

USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
(*REFERENCE FROM*) USE FROM Interconnect_module_with_macros_mim;	-- ISO/TS 10303-1687

TYPE imcr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (stratum_feature_conductive_join,
     dielectric_crossover_area);
END_TYPE; 

ENTITY dielectric_crossover_area
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
END_ENTITY;

ENTITY direct_stratum_component_join_implementation
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;

ENTITY indirect_stratum_component_join_implementation
  SUBTYPE OF (plated_inter_stratum_feature);
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6397 - ISO/TS 10303-1685 Interconnect module to assembly module relationship - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5666
*)


SCHEMA Interconnect_module_to_assembly_module_relationship_mim;
USE FROM Interconnect_module_connection_routing_mim;	-- ISO/TS 10303-1684

  TYPE imtamr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (shape_aspect_relationship);
  END_TYPE;

  TYPE imtamr_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (assembly_component,
     component_feature,
     descriptive_representation_item,
     representation);
  END_TYPE;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6400 - ISO/TS 10303-1686 Interconnect module usage view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5669
*)


SCHEMA Interconnect_module_usage_view_mim;
--	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051
	USE FROM Non_feature_shape_element_mim;

	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705	

ENTITY interconnect_module_cutout_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    SELF\shape_aspect_relationship.relating_shape_aspect : edge_segment_vertex;  
    SELF\shape_aspect_relationship.related_shape_aspect  : edge_segment_vertex;
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;

ENTITY interconnect_module_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
   SELF\shape_aspect_relationship.relating_shape_aspect : edge_segment_vertex;  
   SELF\shape_aspect_relationship.related_shape_aspect  : edge_segment_vertex;
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;

ENTITY interconnect_module_interface_terminal
  SUBTYPE OF (interconnect_module_terminal);
END_ENTITY;

ENTITY interconnect_module_terminal
  SUPERTYPE OF (interconnect_module_interface_terminal)
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY interconnect_module_usage_view
  SUPERTYPE OF (layered_interconnect_module_usage_view)
  SUBTYPE OF (physical_unit);
END_ENTITY;

ENTITY layered_interconnect_module_usage_view
  SUBTYPE OF (interconnect_module_usage_view);
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6403 - ISO/TS 10303-1687 Interconnect module with macros - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5672
*)


SCHEMA Interconnect_module_with_macros_mim;
USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698

  ENTITY interconnect_module_macro_component
    SUBTYPE OF (physical_component);
  END_ENTITY;
	
  ENTITY interconnect_module_macro_component_join_terminal
    SUBTYPE OF (physical_component_terminal);
  END_ENTITY;
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6406 - ISO/TS 10303-1688 Interconnect non planar shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5675
*)


SCHEMA Interconnect_non_planar_shape_mim;
    USE FROM Physical_unit_3d_shape_mim;	-- ISO/TS 10303-1727	
	USE FROM Physical_unit_non_planar_design_view_mim;	-- ISO/TS 10303-1613
	USE FROM Layered_interconnect_complex_template_mim;	-- ISO/TS 10303-1716

ENTITY manifold_constraining_context_dependent_shape_representation
  SUBTYPE OF (context_dependent_shape_representation, representation_relationship);
END_ENTITY; 

ENTITY component_part_2d_non_planar_geometric_representation_relationship
  SUBTYPE OF (shape_representation_relationship, representation_relationship_with_transformation);
END_ENTITY; 
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6978 - ISO/TS 10303-1689 Interconnect physical requirement allocation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6409
*)

SCHEMA Interconnect_physical_requirement_allocation_mim;
USE FROM Requirement_view_definition_relationship_mim; -- ISO/TS 10303-1142	
USE FROM Integral_shield_mim; -- ISO/TS 10303-1763	

  ENTITY interconnect_shield_allocation
    SUBTYPE OF (requirement_assignment);
  END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6412 - ISO/TS 10303-1690 Interconnect placement requirements - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5681
*)


SCHEMA Interconnect_placement_requirements_mim;

USE FROM Layered_interconnect_module_with_printed_component_design_mim;	-- ISO/TS 10303-1700

  SUBTYPE_CONSTRAINT ipr_non_feature_shape_element_subtypes FOR shape_aspect; 
    (ONEOF (
	 derived_shape_aspect,
--	 positional_boundary,
--	 positional_boundary_member,
--	 tolerance_zone_boundary,
--	 viewing_plane,
	 seating_plane,
	 reference_graphic_registration_mark,
--	 template_material_cross_section_boundary,
	 group_shape_aspect,
	 mounting_restriction_area,
	 mounting_restriction_volume));
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT ipr_predefined_requirement_view_definition_subtypes FOR predefined_requirement_view_definition;   
    (ONEOF (assembly_spacing_requirement,
      assembly_group_spacing_requirement,
      item_restricted_requirement,
      layout_spacing_requirement));
  END_SUBTYPE_CONSTRAINT;  
	
  TYPE ipr_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
    (group_shape_aspect,
     layout_spacing_requirement);
  END_TYPE;
	
  TYPE ipr_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (group_shape_aspect);
  END_TYPE;

  ENTITY area_qualified_layout_spacing_requirement
    SUBTYPE OF (layout_spacing_requirement);
  END_ENTITY;

  ENTITY layout_spacing_contextual_area
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY interconnect_module_design_object_category
    SUBTYPE OF (characterized_object);
  END_ENTITY;

  ENTITY layer_qualified_layout_spacing_requirement
    SUBTYPE OF (layout_spacing_requirement);
  END_ENTITY;

  ENTITY layout_spacing_requirement
    SUBTYPE OF (predefined_requirement_view_definition);
  END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6415 - ISO/TS 10303-1691 Interface component - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5684
*)


SCHEMA Interface_component_mim;
	USE FROM Physical_component_feature_mim;	-- ISO/TS 10303-1721

SUBTYPE_CONSTRAINT physical_component_feature_subtypes FOR physical_component_feature;
	(ONEOF (physical_component_terminal,
 	physical_component_interface_terminal));
END_SUBTYPE_CONSTRAINT;
	
ENTITY physical_component_interface_terminal
 SUBTYPE OF (physical_component_feature);
END_ENTITY;

ENTITY interface_component
  SUBTYPE OF (physical_component);
END_ENTITY;

END_SCHEMA;


(*
 ISO TC184/SC4/WG12 N6912 - ISO/TS 10303-1345 Item definition structure - EXPRESS MIM
*)


SCHEMA Item_definition_structure_mim;

USE FROM Effectivity_application_mim; -- ISO/TS 10303-1059
USE FROM Product_occurrence_mim; -- ISO/TS 10303-1715
USE FROM Product_structure_mim; -- ISO/TS 10303-1134

REFERENCE FROM product_definition_schema
	(categories_of_product);


  TYPE effectivity_item_for_replacement  = SELECT BASED_ON effectivity_item WITH
    (product_definition_relationship);
  END_TYPE;

  RULE product_definition_replacement_requires_effectivity_assignment FOR 
      (product_definition_relationship);
    WHERE 
      WR1: SIZEOF( QUERY( pdr <* product_definition_relationship | 
        (pdr.name = 'definition replacement') AND 
        (SIZEOF( USEDIN(pdr,'ITEM_DEFINITION_STRUCTURE_MIM.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS') ) = 0) ))
        = 0; 
  END_RULE; 

  RULE restrict_assembly_category FOR (product_definition);
    LOCAL
      assembly_definitions: SET OF product_definition := [];
    END_LOCAL;
      assembly_definitions :=  QUERY( pd <* product_definition | 
        SIZEOF( QUERY( pdca <* USEDIN( pd, 'ITEM_DEFINITION_STRUCTURE_MIM.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'assembly definition')) > 0 );
      WHERE
        WR1: SIZEOF( QUERY( pd <* assembly_definitions | 
          NOT ('assembly' IN categories_of_product(pd.formation.of_product)) ))= 0;
  END_RULE;

  RULE restrict_product_definitions_for_part_definition_relationship FOR
    (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr.name IN [ 'geometrical relationship' , 'definition replacement' ] ) AND 
	    ( ( pdr.relating_product_definition.frame_of_reference.name <>'part definition' ) OR 
        ( pdr.related_product_definition.frame_of_reference.name <>'part definition' ) ) ) ) =0;
  END_RULE;

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- kinematic_analysis_control_and_result - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Kinematic_analysis_control_and_result_mim;

USE FROM Kinematic_motion_representation_mim;
USE FROM kinematic_analysis_control_and_result_schema;

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- kinematic_motion_representation - EXPRESS MIM*)

SCHEMA Kinematic_motion_representation_mim;

USE FROM Kinematic_state_mim;
USE FROM B_spline_geometry_mim; --  ISO/TS 10303-1801
USE FROM Geometric_model_relationship_mim; -- ISO/TS 10303-1403
USE FROM Parametric_representation_mim;
USE FROM Contextual_shape_positioning_mim; -- ISO/TS 10303-1027
USE FROM kinematic_motion_representation_schema;

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- kinematic_state - EXPRESS MIM*)

SCHEMA Kinematic_state_mim;
USE FROM Kinematic_structure_mim;
USE FROM kinematic_state_schema;

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- kinematic_structure - EXPRESS MIM*)

SCHEMA Kinematic_structure_mim;

USE FROM Kinematic_topology_mim;
USE FROM Basic_curve_mim;
USE FROM Assembly_structure_mim; -- ISO/TS 10303-1026
USE FROM Geometric_model_relationship_mim; -- ISO/TS 10303-1403
USE FROM Composite_surface_mim; -- ISO/TS 10303-1525
USE FROM Shape_property_assignment_mim; --  ISO/TS 10303-1032
USE FROM kinematic_structure_schema;

USE FROM kinematic_property_schema ( -- ISO/TS 10303-105
	product_definition_relationship_kinematics,
	kinematic_property_mechanism_representation,
	context_dependent_kinematic_link_representation);

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- kinematic_topology - EXPRESS MIM*)

SCHEMA Kinematic_topology_mim;

USE FROM Elemental_topology_mim; -- ISO/TS 10303-1005
USE FROM Foundation_representation_mim; -- ISO/TS 10303-1006
USE FROM Part_view_definition_mim; -- ISO/TS 10303-1023
USE FROM Property_assignment_mim; -- ISO/TS 10303-1030
USE FROM kinematic_topology_schema; -- ISO/TS 10303-105

USE FROM kinematic_property_schema ( -- ISO/TS 10303-105
	product_definition_kinematics,
	kinematic_property_definition_representation,
	kinematic_property_topology_representation);
	
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6981 - ISO/TS 10303-1692 Land - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6418
*)


SCHEMA Land_mim;
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698


SUBTYPE_CONSTRAINT stratum_feature_template_component_subtypes FOR stratum_feature_template_component;   
	(ONEOF (area_component,
	land));
END_SUBTYPE_CONSTRAINT;

ENTITY contact_size_dependent_land
  SUBTYPE OF (land);
END_ENTITY;

ENTITY dependent_electrical_isolation_removal_component
  SUBTYPE OF (electrical_isolation_laminate_component);
END_ENTITY;

ENTITY dependent_thermal_isolation_removal_component
  SUBTYPE OF (thermal_isolation_removal_component);
END_ENTITY;

ENTITY inter_stratum_feature_dependent_land
  ABSTRACT SUPERTYPE OF (ONEOF (plated_passage_dependent_land,
    unsupported_passage_dependent_land))
  SUBTYPE OF (land);
END_ENTITY;
	
ENTITY land
  SUPERTYPE OF (ONEOF (contact_size_dependent_land,
    inter_stratum_feature_dependent_land))
  SUBTYPE OF (stratum_feature_template_component);
END_ENTITY;	

ENTITY land_with_join_terminal
  SUBTYPE OF (land, laminate_component_join_terminal);
  DERIVE
    SELF\shape_aspect.of_shape : land_with_join_terminal := SELF;
END_ENTITY;

ENTITY plated_passage_dependent_land
  SUBTYPE OF (inter_stratum_feature_dependent_land);
END_ENTITY;

ENTITY thermal_isolation_removal_component
  SUBTYPE OF (material_removal_structured_component);
END_ENTITY;

ENTITY unsupported_passage_dependent_land
  SUBTYPE OF (inter_stratum_feature_dependent_land);
END_ENTITY;
	
END_SCHEMA;


(*
	ISO TC184/SC4/WG12 N5414 - ISO/TS 10303-1008 Layer assignment - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N4751
*) 

SCHEMA Layer_assignment_mim; 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Group_mim;	-- ISO/TS 10303-1113

USE FROM presentation_organization_schema   -- ISO 10303-46
  (presentation_layer_assignment); 

USE FROM geometry_schema(geometric_representation_item); -- ISO 10303-42

USE FROM topology_schema(topological_representation_item); -- ISO 10303-42


  ENTITY rep_item_group
    SUBTYPE OF (group, representation_item);
    WHERE
      WR1: SIZEOF(USEDIN(SELF,'LAYER_ASSIGNMENT_MIM.' + 'PRESENTATION_LAYER_ASSIGNMENT.' + 'ASSIGNED_ITEMS')) > 0;
      WR2: SIZEOF(QUERY(r <* USEDIN(SELF,'LAYER_ASSIGNMENT_MIM.' + 'REPRESENTATION.' + 'ITEMS') | r.name = 'group representation')) > 0;
      WR3: SIZEOF(QUERY(ga <* USEDIN(SELF,'LAYER_ASSIGNMENT_MIM.' + 'GROUP_ASSIGNMENT.' + 'ASSIGNED_GROUP') | ga.role.name <> 'group membership')) = 0;
      WR4: SIZEOF(['LAYER_ASSIGNMENT_MIM.' + 'GEOMETRIC_REPRESENTATION_ITEM', 'LAYER_ASSIGNMENT_MIM.' + 'TOPOLOGICAL_REPRESENTATION_ITEM', 'LAYER_ASSIGNMENT_MIM.' + 'MAPPED_ITEM','LAYER_ASSIGNMENT_MIM.' + 'STYLED_ITEM'] * TYPEOF(SELF)) = 1;
  END_ENTITY;

END_SCHEMA; 
(*
   ISO TC184/SC4/WG12 N6421 - ISO/TS 10303-1693 Layered 2d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5690
*)


SCHEMA Layered_2d_shape_mim;
	USE FROM Constructive_solid_geometry_2d_mim;	-- ISO/TS 10303-1731
	USE FROM Wireframe_2d_mim; 	-- ISO/TS 10303-1347	
	USE FROM Shape_feature_mim;	-- ISO/TS 10303-xxxx
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6424 - ISO/TS 10303-1694 Layered 3d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5693
*)

SCHEMA Layered_3d_shape_mim;
USE FROM Layered_2d_shape_mim; -- ISO/TS 10303-1693
USE FROM Physical_unit_3d_shape_mim;	-- ISO/TS 10303-1727
USE FROM Advanced_boundary_representation_mim;	-- ISO/TS 10303-1514
USE FROM Curve_swept_solid_mim;	-- ISO/TS 10303-1659
USE FROM Geometrically_bounded_surface_mim;	-- ISO/TS 10303-1507	
USE FROM Geometric_model_2d_3d_relationship_mim; -- ISO/TS 10303-1404	
	
USE FROM representation_schema(representation_relationship_with_transformation);

  ENTITY shape_definition_3d_intersection
    SUBTYPE OF (representation, 
                shape_representation_relationship, 
                representation_relationship_with_transformation);
      SELF\representation_relationship_with_transformation.transformation_operator : item_defined_transformation;
    UNIQUE
      UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
    WHERE
      WR1: SELF\representation_relationship.rep_1 :<>: SELF\representation_relationship.rep_2;
  END_ENTITY; 
	
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6984 - ISO/TS 10303-1716 Layered interconnect complex template - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6427
*)


SCHEMA Layered_interconnect_complex_template_mim;
USE FROM Layered_interconnect_simple_template_mim;	-- ISO/TS 10303-1718
USE FROM Physical_unit_2d_shape_mim; -- ISO/TS 10303-1726

USE FROM product_property_definition_schema (characterized_definition);

  TYPE ipra_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (thermal_isolation_removal_template);
  END_TYPE; 

  TYPE lict_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (assembly_component_usage,
     structured_template);
  END_TYPE; 

  ENTITY complex_passage_padstack_definition
    SUBTYPE OF (stratum_stack_dependent_template, passage_padstack_definition);
  END_ENTITY;

  ENTITY dependent_electrical_isolation_removal_template
    SUBTYPE OF (electrical_isolation_removal_template);
  END_ENTITY;

  ENTITY dependent_thermal_isolation_removal_template
    SUBTYPE OF (thermal_isolation_removal_template);
  END_ENTITY;
  
  ENTITY design_specific_stratum_technology_mapping_relationship
    SUBTYPE OF(stratum_technology_mapping_relationship, property_definition);
      SELF\property_definition.definition RENAMED scope : library_to_design_stack_model_mapping;
  END_ENTITY;
  
  ENTITY library_stack_model
    SUBTYPE OF(stratum_stack_model);
  END_ENTITY;

  ENTITY library_to_design_stack_model_mapping
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY material_removal_structured_template
    SUBTYPE OF (single_stratum_structured_template);
  END_ENTITY;

  ENTITY multi_stratum_special_symbol_template
    SUBTYPE OF (multi_stratum_structured_template, special_symbol_template);
  END_ENTITY;
  
  ENTITY multi_stratum_structured_template
    ABSTRACT SUPERTYPE OF (ONEOF (padstack_definition, multi_stratum_special_symbol_template)
      ANDOR stratum_stack_dependent_template)  
    SUBTYPE OF (structured_template);
  END_ENTITY;

  ENTITY padstack_definition
    SUPERTYPE OF (passage_padstack_definition)
    SUBTYPE OF (multi_stratum_structured_template);
  END_ENTITY;

  ENTITY part_template_keepout_shape_allocation_to_stratum_stack
    SUBTYPE OF (characterized_object, property_definition);
    DERIVE
      SELF\property_definition.definition : part_template_keepout_shape_allocation_to_stratum_stack := SELF;
  END_ENTITY;

  ENTITY passage_padstack_definition 
    SUBTYPE OF (padstack_definition);
  END_ENTITY; 

  ENTITY physical_unit_keepout_shape_allocation_to_stratum_stack
    SUBTYPE OF (representation, representation_relationship);
  END_ENTITY;

  ENTITY physical_unit_keepout_shape_allocation_to_stratum_technology
    SUBTYPE OF (representation);
  END_ENTITY;

  ENTITY single_stratum_special_symbol_template
    SUBTYPE OF (single_stratum_structured_template, special_symbol_template);
  END_ENTITY;
  
  ENTITY single_stratum_structured_template
    ABSTRACT SUPERTYPE OF (ONEOF (material_removal_structured_template, single_stratum_special_symbol_template))
    SUBTYPE OF (structured_template, single_stratum_template);
  END_ENTITY;

  ENTITY special_symbol_template
    ABSTRACT SUPERTYPE OF (ONEOF (single_stratum_special_symbol_template, multi_stratum_special_symbol_template))
    SUBTYPE OF (part_template_definition);
  END_ENTITY;

  ENTITY stratum_specific_template_location
    SUBTYPE OF (assembly_component_usage, property_definition);
  END_ENTITY;

  ENTITY stratum_stack_dependent_template
    SUBTYPE OF (multi_stratum_structured_template);
  END_ENTITY;

  ENTITY structured_inter_stratum_feature_template
    SUBTYPE OF (inter_stratum_feature_template, stratum_stack_dependent_template);
  END_ENTITY;
  
  ENTITY structured_template
    ABSTRACT SUPERTYPE OF (ONEOF (single_stratum_structured_template, multi_stratum_structured_template))
    SUBTYPE OF (geometric_template);
  END_ENTITY;
  
  ENTITY thermal_isolation_removal_template
    SUBTYPE OF (material_removal_structured_template);
  END_ENTITY;
	
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6430 - ISO/TS 10303-1695 Layered interconnect module 2d design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5696
*)

SCHEMA Layered_interconnect_module_2d_design_mim;

USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6987 - ISO/TS 10303-1696 Layered interconnect module 3d design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6433
*)


SCHEMA Layered_interconnect_module_3d_design_mim;
	USE FROM Physical_unit_3d_design_view_mim;	-- ISO/TS 10303-1727
	USE FROM Stratum_non_planar_shape_mim;	-- ISO/TS 10303-1748

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6990 - ISO/TS 10303-1698 Layered interconnect module design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6436
*)


SCHEMA Layered_interconnect_module_design_mim;
USE FROM Component_grouping_mim;	-- ISO/TS 10303-1656
USE FROM Edge_shape_feature_mim;	-- ISO/TS 10303-1673
USE FROM Footprint_definition_mim;	-- ISO/TS 10303-1646
USE FROM Assembly_component_placement_requirements_mim;	-- ISO/TS 10303-1634	
(*REFERENCE FROM*) USE FROM Land_mim;	-- ISO/TS 10303-1692
(*REFERENCE FROM*) USE FROM Layered_interconnect_module_with_printed_component_design_mim; -- ISO/TS 10303-1700
	
  SUBTYPE_CONSTRAINT array_placement_group_subtypes FOR array_placement_group; 
    (ONEOF (laminate_text_string_component,
     linear_array_placement_group_component,
     rectangular_array_placement_group_component));
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT assembly_component_subtypes FOR assembly_component; 
    (ONEOF (physical_component,
     laminate_component));
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT component_feature_subtypes FOR component_feature; 
    (ONEOF (physical_component_feature,
     laminate_component_feature));
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT limd_component_terminal_subtypes FOR component_terminal; 
    (ONEOF (physical_component_terminal,
     laminate_component_join_terminal));
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT inter_stratum_feature_subtypes FOR Inter_stratum_feature;     
    ONEOF (Cutout,
    Interconnect_module_edge);
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT interconnect_module_terminal_subtypes FOR interconnect_module_terminal;     
    (ONEOF (interconnect_module_interface_terminal,
     interconnect_module_macro_terminal));
  END_SUBTYPE_CONSTRAINT; 

  SUBTYPE_CONSTRAINT limd_product_definition_subtypes FOR product_definition; 
    (ONEOF (physical_unit,
     stratum));
  END_SUBTYPE_CONSTRAINT; 

  SUBTYPE_CONSTRAINT limd_part_template_definition_subtypes FOR part_template_definition; 
    (ONEOF (
       ONEOF(printed_part_template, special_symbol_template) ANDOR  geometric_template, 
         non_conductive_cross_section_template,
         part_string_template, 
         parametric_template,
         part_text_template,
         stratum_stack_model,
         stratum_sub_stack));
  END_SUBTYPE_CONSTRAINT;

  TYPE limd_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (-- stratum_feature_conductive_join,
     -- dielectric_crossover_area,
     layered_interconnect_module_design_view);
  END_TYPE; 

  TYPE limd_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
    (assembly_component,
     externally_defined_physical_network_group,
     externally_defined_physical_network_group_element_relationship,			
     stratum_feature_based_derived_pattern,
     stratum);
  END_TYPE; 

  TYPE limd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (inter_stratum_feature,
     stratum,
     stratum_feature,
     stratum_surface,
     structured_layout_component);
  END_TYPE; 

  TYPE limd_groupable_item = SELECT BASED_ON groupable_item WITH 
    (physical_network,
     stratum);
  END_TYPE; 

  ENTITY additive_laminate_text_component
    SUBTYPE OF (generic_laminate_text_component);
  END_ENTITY;

  ENTITY area_component
    SUPERTYPE OF (connected_area_component)
    SUBTYPE OF (stratum_feature_template_component);
  END_ENTITY;

  ENTITY breakout_occurrence
    SUBTYPE OF (footprint_occurrence);
  END_ENTITY;  

  ENTITY component_termination_passage
    SUBTYPE OF (plated_passage);
  END_ENTITY;

  ENTITY conductive_interconnect_element
    ABSTRACT SUPERTYPE OF (ONEOF (unrouted_conductive_interconnect_element, conductive_interconnect_element_with_pre_defined_transitions))
    SUBTYPE OF (stratum_feature_template_component);
  END_ENTITY;

  ENTITY conductive_interconnect_element_terminal_link
    SUBTYPE OF (shape_aspect,shape_aspect_relationship);
      SELF\shape_aspect_relationship.relating_shape_aspect : laminate_component_feature;  
      SELF\shape_aspect_relationship.related_shape_aspect  : laminate_component_feature;
    WHERE
      WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
        SELF\shape_aspect_relationship.relating_shape_aspect;
  END_ENTITY; 

  ENTITY conductive_interconnect_element_with_pre_defined_transitions
    SUBTYPE OF (conductive_interconnect_element, item_identified_representation_usage);
    DERIVE
      SELF\item_identified_representation_usage.definition : property_definition := SELF;
  END_ENTITY;

  ENTITY connected_area_component
    SUBTYPE OF (area_component);
  END_ENTITY;

  ENTITY cutout
    SUPERTYPE OF (ONEOF (physical_connectivity_interrupting_cutout,
      plated_cutout,
      partially_plated_cutout))
    SUBTYPE OF (inter_stratum_feature);
  END_ENTITY;

  ENTITY cutout_edge_segment
    SUPERTYPE OF (plated_cutout_edge_segment)
    SUBTYPE OF (inter_stratum_feature,shape_aspect_relationship);
      SELF\shape_aspect_relationship.relating_shape_aspect : edge_segment_vertex;
      SELF\shape_aspect_relationship.related_shape_aspect  : edge_segment_vertex;
    WHERE
      WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
        SELF\shape_aspect_relationship.related_shape_aspect;
  END_ENTITY;

  ENTITY derived_stratum
    SUBTYPE OF (stratum);
  END_ENTITY;

  ENTITY design_layer_stratum
    SUBTYPE OF (stratum);
  END_ENTITY;

  ENTITY dielectric_material_passage
    SUBTYPE OF (inter_stratum_feature);
  END_ENTITY;

  ENTITY documentation_layer_stratum
    SUBTYPE OF (stratum);
  END_ENTITY;
  	
  ENTITY electrical_isolation_laminate_component
    SUBTYPE OF (material_removal_laminate_component);
  END_ENTITY;

  ENTITY fiducial
    SUBTYPE OF (laminate_component);
  END_ENTITY;

  ENTITY fiducial_stratum_feature
    SUBTYPE OF (stratum_feature);
  END_ENTITY;

  ENTITY filled_via
    SUBTYPE OF (via);
  END_ENTITY;  

  ENTITY footprint_occurrence
    SUBTYPE OF (structured_layout_component);
  END_ENTITY;

  ENTITY footprint_occurrence_product_definition_relationship
    SUBTYPE OF (structured_layout_component_sub_assembly_relationship);
  END_ENTITY;

  ENTITY inter_stratum_feature
    SUBTYPE OF (laminate_component);
  END_ENTITY;

  ENTITY interconnect_module_design_view
    SUPERTYPE OF (layered_interconnect_module_design_view)
    SUBTYPE OF (physical_unit);
  END_ENTITY; 

  ENTITY interconnect_module_edge
    SUPERTYPE OF (ONEOF (partially_plated_interconnect_module_edge, plated_interconnect_module_edge))
    SUBTYPE OF (inter_stratum_feature);
  END_ENTITY;

  ENTITY interconnect_module_edge_segment
    SUPERTYPE OF (ONEOF(plated_interconnect_module_edge_segment,
                        unplated_interconnect_module_edge_segment))
    SUBTYPE OF (inter_stratum_feature,shape_aspect_relationship);
      SELF\shape_aspect_relationship.relating_shape_aspect : edge_segment_vertex;  
      SELF\shape_aspect_relationship.related_shape_aspect  : edge_segment_vertex;
    WHERE
      WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
        SELF\shape_aspect_relationship.related_shape_aspect;
  END_ENTITY;

  ENTITY interconnect_module_macro_terminal
    SUBTYPE OF (interconnect_module_terminal);
  END_ENTITY;

  ENTITY interface_access_component_definition
    SUBTYPE OF (laminate_component);
  END_ENTITY;

  ENTITY interface_access_material_removal_laminate_component
    SUBTYPE OF (material_removal_laminate_component);
  END_ENTITY;

  ENTITY interface_access_stratum_feature_template_component
    SUBTYPE OF (stratum_feature_template_component);
  END_ENTITY;

  ENTITY internal_probe_access_area
    SUBTYPE OF (probe_access_area);
  END_ENTITY;

  ENTITY join_shape_aspect
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY laminate_component
    SUPERTYPE OF (ONEOF (material_removal_laminate_component,
      stratum_feature_template_component ANDOR probe_access_area,
      inter_stratum_feature,
      generic_laminate_text_component,
      laminate_text_string_component) ANDOR
      fiducial)
    SUBTYPE OF (assembly_component);
  END_ENTITY;

  ENTITY laminate_component_feature
    SUPERTYPE OF (ONEOF (laminate_component_interface_terminal,
      laminate_component_join_terminal))
    SUBTYPE OF (component_feature);
  END_ENTITY;

  ENTITY laminate_component_interface_terminal
    SUBTYPE OF (laminate_component_feature);
  END_ENTITY;

  ENTITY laminate_component_join_terminal
    SUBTYPE OF (laminate_component_feature,
 		component_terminal);
  END_ENTITY;

  ENTITY laminate_group_component_make_from_relationship
    SUBTYPE OF (make_from_usage_option);
      SELF\product_definition_relationship.relating_product_definition : assembly_group_component;
      SELF\product_definition_relationship.related_product_definition  : assembly_group_component;
  END_ENTITY;

  ENTITY generic_laminate_text_component
    ABSTRACT SUPERTYPE OF (ONEOF(additive_laminate_text_component, 
      material_removal_laminate_text_component))
    SUBTYPE OF (laminate_component);
  END_ENTITY;

  ENTITY laminate_text_string_component
    SUBTYPE OF (array_placement_group, laminate_component);
  END_ENTITY;

  ENTITY layer_connection_point
    SUBTYPE OF (shape_aspect);
    UNIQUE
      UR1: SELF\shape_aspect.name, SELF\shape_aspect.of_shape;
  END_ENTITY;

  ENTITY layout_junction
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY layer_stack_region
    SUBTYPE OF (instanced_feature);
  END_ENTITY;

  ENTITY layered_interconnect_module_design_view
  	SUPERTYPE OF (layered_interconnect_panel_design_view)
    SUBTYPE OF (interconnect_module_design_view);
  END_ENTITY;
  
  ENTITY layered_interconnect_panel_design_view
    SUBTYPE OF (layered_interconnect_module_design_view);
  END_ENTITY;

  ENTITY material_removal_laminate_component
    SUBTYPE OF (laminate_component);
  END_ENTITY;

  ENTITY material_removal_structured_component
    SUBTYPE OF (structured_layout_component);
  END_ENTITY;

  ENTITY multi_layer_component_definition
    SUBTYPE OF (laminate_component);
  END_ENTITY;

  ENTITY multi_layer_material_removal_laminate_component
    SUBTYPE OF (material_removal_laminate_component);
  END_ENTITY;

  ENTITY multi_layer_stratum_feature_template_component
    SUBTYPE OF (stratum_feature_template_component);
  END_ENTITY;

  ENTITY multi_stratum_special_symbol_component
    SUBTYPE OF (structured_layout_component);
  END_ENTITY;

  ENTITY material_removal_laminate_text_component
    SUBTYPE OF (generic_laminate_text_component);
  END_ENTITY;

  ENTITY padstack_occurrence
    SUBTYPE OF (structured_layout_component);
  END_ENTITY;

  ENTITY padstack_occurrence_product_definition_relationship
    SUBTYPE OF (property_definition, next_assembly_usage_occurrence_relationship);
    WHERE
      WR1: SELF\product_definition_relationship.related_product_definition :<>:
        SELF\product_definition_relationship.relating_product_definition;
  END_ENTITY; 

  ENTITY partially_plated_cutout
    SUBTYPE OF (cutout);
  END_ENTITY;

  ENTITY partially_plated_interconnect_module_edge
    SUBTYPE OF (interconnect_module_edge);
  END_ENTITY;

  ENTITY physical_connectivity_interrupting_cutout
    SUBTYPE OF (cutout);
  END_ENTITY;

  ENTITY physical_network
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY physical_network_group
    ABSTRACT SUPERTYPE OF (ONEOF (pre_defined_physical_network_group,
                                 externally_defined_physical_network_group))
    SUBTYPE OF (group);
  END_ENTITY;

  ENTITY pre_defined_physical_network_group
    SUBTYPE OF (physical_network_group);
  END_ENTITY;

  ENTITY externally_defined_physical_network_group
    SUBTYPE OF (physical_network_group);
  END_ENTITY; 

  ENTITY physical_network_group_element_relationship
    ABSTRACT SUPERTYPE OF (ONEOF (pre_defined_physical_network_group_element_relationship,
                                 externally_defined_physical_network_group_element_relationship))
    SUBTYPE OF (group_relationship);
  END_ENTITY;

  ENTITY pre_defined_physical_network_group_element_relationship
    SUBTYPE OF (physical_network_group_element_relationship);
  END_ENTITY;

  ENTITY externally_defined_physical_network_group_element_relationship
    SUBTYPE OF (physical_network_group_element_relationship);
  END_ENTITY; 

  ENTITY physical_network_supporting_inter_stratum_feature
    SUBTYPE OF (plated_inter_stratum_feature);
  END_ENTITY; 

  ENTITY plated_cutout
    SUBTYPE OF (cutout, plated_inter_stratum_feature);
  END_ENTITY;

  ENTITY plated_cutout_edge_segment
    SUBTYPE OF (cutout_edge_segment,plated_inter_stratum_feature);
  END_ENTITY;

  ENTITY plated_interconnect_module_edge
    SUBTYPE OF (interconnect_module_edge, plated_inter_stratum_feature);
  END_ENTITY;

  ENTITY plated_interconnect_module_edge_segment
    SUBTYPE OF (interconnect_module_edge_segment,
                plated_inter_stratum_feature);
  END_ENTITY;

  ENTITY plated_inter_stratum_feature
    SUPERTYPE OF (ONEOF (plated_cutout_edge_segment,
      plated_interconnect_module_edge_segment,
      plated_passage))
    SUBTYPE OF (inter_stratum_feature);
  END_ENTITY;

  ENTITY plated_passage 
    SUPERTYPE OF (ONEOF (component_termination_passage,
      via))
    SUBTYPE OF (plated_inter_stratum_feature);
  END_ENTITY;

  ENTITY primary_stratum_indicator_symbol
    SUBTYPE OF (single_stratum_special_symbol_component);
  END_ENTITY;
  
  ENTITY probe_access_area
    SUBTYPE OF (laminate_component, shape_aspect);
    DERIVE
      SELF\shape_aspect.of_shape : probe_access_area := SELF;
  END_ENTITY;

  ENTITY region_based_derived_pattern
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY single_stratum_special_symbol_component
    SUPERTYPE OF (primary_stratum_indicator_symbol)
    SUBTYPE OF (structured_layout_component);
  END_ENTITY;
  
  ENTITY stratum
    SUPERTYPE OF (ONEOF (documentation_layer_stratum, design_layer_stratum))
    SUBTYPE OF (product_definition, product_definition_shape);
    DERIVE
      SELF\property_definition.definition : stratum := SELF;
    UNIQUE
      UR1: SELF\product_definition.id, SELF\product_definition.formation;
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) = 0;
      WR2: NOT EXISTS(SELF\property_definition.description);
  END_ENTITY;	

  ENTITY stratum_feature
    SUPERTYPE OF (fiducial_stratum_feature)
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY stratum_feature_based_derived_pattern
    SUBTYPE OF(characterized_object, property_definition_relationship);
  END_ENTITY;

  ENTITY stratum_feature_conductive_join
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;
	
  ENTITY stratum_feature_template_component
    SUPERTYPE OF (ONEOF (area_component,
            conductive_interconnect_element))
    SUBTYPE OF (laminate_component);
  END_ENTITY;

  ENTITY stratum_feature_template_component_with_stratum_feature
    SUBTYPE OF (stratum_feature_template_component, stratum_feature, shape_aspect_relationship);
    DERIVE
      SELF\shape_aspect_relationship.related_shape_aspect  : stratum_feature_template_component_with_stratum_feature := SELF;
      SELF\shape_aspect_relationship.relating_shape_aspect : stratum_feature_template_component_with_stratum_feature := SELF;
    WHERE
      WR1: SELF\shape_aspect_relationship.name = 'implementation';
  END_ENTITY;

  ENTITY stratum_surface
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY structured_layout_component
    ABSTRACT SUPERTYPE OF (ONEOF (footprint_occurrence, 
            material_removal_structured_component,
			multi_stratum_special_symbol_component,
            padstack_occurrence, 
            single_stratum_special_symbol_component))
    SUBTYPE OF (assembly_group_component);
  END_ENTITY;  

  ENTITY structured_layout_component_sub_assembly_relationship
    SUPERTYPE OF (footprint_occurrence_product_definition_relationship)
    SUBTYPE OF (next_assembly_usage_occurrence_relationship);
    WHERE
      WR1: SELF\product_definition_relationship.related_product_definition :<>:
        SELF\product_definition_relationship.relating_product_definition;
  END_ENTITY;  

  ENTITY structured_layout_component_sub_assembly_relationship_with_component
    SUBTYPE OF (structured_layout_component_sub_assembly_relationship, assembly_component);
    DERIVE
      SELF\product_definition_relationship.related_product_definition : assembly_component := SELF;    
  END_ENTITY;

  ENTITY unplated_cutout_edge_segment
    SUBTYPE OF (cutout_edge_segment);
  END_ENTITY;

  ENTITY unplated_interconnect_module_edge_segment
    SUBTYPE OF (interconnect_module_edge_segment);
  END_ENTITY;

  ENTITY unrouted_conductive_interconnect_element
    SUBTYPE OF (conductive_interconnect_element);
  END_ENTITY;

  ENTITY unsupported_passage
    SUBTYPE OF (inter_stratum_feature);
  END_ENTITY;

  ENTITY via
    ABSTRACT SUPERTYPE OF (filled_via)
    SUBTYPE OF (plated_passage);
  END_ENTITY;    				
  
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6993 - ISO/TS 10303-1700 Layered interconnect module with printed component design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6439
*)


SCHEMA Layered_interconnect_module_with_printed_component_design_mim;

USE FROM Printed_physical_layout_template_mim;	-- ISO/TS 10303-1737
USE FROM Land_mim;	-- ISO/TS 10303-1692
	
	
TYPE limwpcd_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (printed_component);
END_TYPE; 

SUBTYPE_CONSTRAINT limwpcd_assembly_component_subtypes FOR assembly_component; 
    (ONEOF (physical_component,
	 printed_component,
 	laminate_component));
END_SUBTYPE_CONSTRAINT;
	
SUBTYPE_CONSTRAINT limwpcd_structured_layout_component_subtypes FOR structured_layout_component; 
	(ONEOF (footprint_occurrence,
		material_removal_structured_component,
        multi_stratum_printed_component, 
		multi_stratum_special_symbol_component,
		padstack_occurrence,
		single_stratum_printed_component,
		single_stratum_special_symbol_component));
END_SUBTYPE_CONSTRAINT; 

ENTITY basic_multi_stratum_printed_component
  SUBTYPE OF (printed_component);
END_ENTITY;

ENTITY multi_stratum_printed_component
  SUBTYPE OF (printed_component, structured_layout_component);
END_ENTITY;

ENTITY printed_connector_component
  SUBTYPE OF (printed_component);
END_ENTITY;

ENTITY printed_component
   ABSTRACT SUPERTYPE OF (ONEOF (single_stratum_printed_component, 
    basic_multi_stratum_printed_component,
    multi_stratum_printed_component))
    SUBTYPE OF (assembly_component);
END_ENTITY;	

ENTITY routed_transmission_line
 SUBTYPE OF (assembly_component);
END_ENTITY;

ENTITY single_stratum_printed_component
  SUBTYPE OF (printed_component, structured_layout_component);
END_ENTITY;

ENTITY tiebar_printed_component 
  SUBTYPE OF (printed_component, structured_layout_component);
END_ENTITY;	
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6996 - ISO/TS 10303-1718 Layered interconnect simple template - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6442
*)


SCHEMA Layered_interconnect_simple_template_mim;
    USE FROM Layered_2d_shape_mim;	-- ISO/TS 10303-1693
    USE FROM Fill_area_style_mim; -- ISO/TS 10303-1672
	USE FROM Fabrication_technology_mim;	-- ISO/TS 10303-1670
	USE FROM Text_representation_mim;	-- ISO/TS 10303-1750
	USE FROM Part_template_shape_with_parameters_mim;	-- ISO/TS 10303-1720	
	
	USE FROM Presentation_definition_schema(text_literal);

  TYPE list_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
    (land_physical_template);
  END_TYPE; 

 SUBTYPE_CONSTRAINT list_template_definition_subtypes FOR part_template_definition;   
 	(ONEOF (geometric_template,
			parametric_template,
 			part_string_template,
    		part_text_template,    
            single_stratum_template,
            stratum_stack_model));
 END_SUBTYPE_CONSTRAINT;  

ENTITY blind_passage_template
  SUBTYPE OF (unsupported_passage_template);
END_ENTITY;

ENTITY component_termination_passage_template
  SUBTYPE OF (continuous_template, inter_stratum_feature_template);
END_ENTITY;

ENTITY continuous_template
  SUBTYPE OF (geometric_template);
END_ENTITY;

ENTITY counterbore_passage_template
  SUBTYPE OF (unsupported_passage_template);
END_ENTITY;

ENTITY countersunk_passage_template
  SUBTYPE OF (unsupported_passage_template);
END_ENTITY;  

ENTITY default_attachment_size_based_land_physical_template
  SUBTYPE OF (land_physical_template, shape_aspect);
  DERIVE
    SELF\shape_aspect.of_shape : default_attachment_size_based_land_physical_template := SELF;
END_ENTITY;

ENTITY default_passage_based_land_physical_template
  ABSTRACT SUPERTYPE OF (ONEOF (default_plated_passage_based_land_physical_template,
    default_unsupported_passage_based_land_physical_template))
  SUBTYPE OF (land_physical_template);
END_ENTITY;

ENTITY default_plated_passage_based_land_physical_template
  SUBTYPE OF (default_passage_based_land_physical_template);
END_ENTITY;

ENTITY default_trace_template
  SUBTYPE OF (trace_template);
END_ENTITY;

ENTITY default_unsupported_passage_based_land_physical_template
  SUBTYPE OF (default_passage_based_land_physical_template);
END_ENTITY;

ENTITY electrical_isolation_removal_template
  SUBTYPE OF (material_removal_feature_template);
END_ENTITY;

ENTITY inter_stratum_feature_edge_segment_template
  SUBTYPE OF (part_template_definition,shape_aspect_relationship);
    SELF\shape_aspect_relationship.relating_shape_aspect : edge_segment_vertex;
    SELF\shape_aspect_relationship.related_shape_aspect  : edge_segment_vertex;
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;

ENTITY inter_stratum_feature_edge_template
  SUBTYPE OF (part_template_definition);
END_ENTITY;

ENTITY inter_stratum_feature_template
  SUPERTYPE OF (ONEOF(component_termination_passage_template,
    unsupported_passage_template,
    via_template))
    SUBTYPE OF (geometric_template);
END_ENTITY;

ENTITY fill_area_template
  SUBTYPE OF (parametric_template);
END_ENTITY;

ENTITY hatch_area_template
  SUBTYPE OF (fill_area_template);
END_ENTITY;  

ENTITY hatch_line_element
  SUBTYPE OF (geometric_representation_item, representation_item_relationship);
    SELF\representation_item_relationship.relating_representation_item : line;
    SELF\representation_item_relationship.related_representation_item  : measure_representation_item;
END_ENTITY;

ENTITY land_physical_template
  SUPERTYPE OF (ONEOF (default_passage_based_land_physical_template,
    default_attachment_size_based_land_physical_template))
  SUBTYPE OF (stratum_feature_template);
END_ENTITY;

ENTITY land_template_terminal
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY material_removal_feature_template
  SUBTYPE OF (single_stratum_continuous_template);
END_ENTITY;

ENTITY parametric_template
  ABSTRACT SUPERTYPE OF (ONEOF (fill_area_template,
    teardrop_template,
    trace_template))
  SUBTYPE OF (part_template_definition);
END_ENTITY;
  
ENTITY part_string_template
  SUBTYPE OF (part_template_definition);
END_ENTITY;

ENTITY part_text_template
  SUBTYPE OF (part_template_definition);
END_ENTITY;

ENTITY planar_path_shape_representation_with_parameters
  SUBTYPE OF (single_area_csg_2d_shape_representation);
END_ENTITY;

ENTITY planar_closed_path_shape_representation_with_parameters
    SUBTYPE OF (planar_path_shape_representation_with_parameters);
END_ENTITY;

ENTITY single_stratum_continuous_template
  ABSTRACT SUPERTYPE OF (ONEOF (stratum_feature_template, material_removal_feature_template))
  SUBTYPE OF (continuous_template, single_stratum_template);
END_ENTITY;

ENTITY single_stratum_template
  ABSTRACT SUPERTYPE OF (single_stratum_continuous_template)
  SUBTYPE OF (part_template_definition);
END_ENTITY;

ENTITY solid_character_glyph_2d_symbol
  SUBTYPE OF (generic_character_glyph_symbol, csg_2d_shape_representation);
END_ENTITY;
  
ENTITY snowball_template
  SUBTYPE OF (teardrop_template);
END_ENTITY;

ENTITY stratum_feature_template
  SUBTYPE OF (single_stratum_continuous_template);
END_ENTITY;

ENTITY teardrop_by_angle_template
  SUBTYPE OF (teardrop_template);
END_ENTITY;

ENTITY teardrop_by_length_template
  SUBTYPE OF (teardrop_template);
END_ENTITY;

ENTITY teardrop_template
  ABSTRACT SUPERTYPE OF (ONEOF (snowball_template,
    teardrop_by_angle_template,
    teardrop_by_length_template))
  SUBTYPE OF (parametric_template, single_stratum_template);
END_ENTITY;

ENTITY tile_area_template
  SUBTYPE OF (fill_area_template);
END_ENTITY;
  
ENTITY trace_template
  SUPERTYPE OF (default_trace_template)
  SUBTYPE OF (parametric_template);
END_ENTITY;

ENTITY unsupported_passage_template
  SUPERTYPE OF (ONEOF (counterbore_passage_template,
    countersunk_passage_template,
    blind_passage_template))
  SUBTYPE OF (continuous_template, inter_stratum_feature_template);
END_ENTITY;
 
ENTITY via_template
  SUBTYPE OF (continuous_template, inter_stratum_feature_template);
END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6445 - ISO/TS 10303-1701 Layout macro definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5708
*)


SCHEMA Layout_macro_definition_mim;
	USE FROM Fabrication_joint_mim;	-- ISO/TS 10303-1668
	USE FROM Application_context_schema(application_context_element);

ENTITY layout_macro_component
  SUBTYPE OF (printed_component);
END_ENTITY;

ENTITY layout_macro_definition
 SUBTYPE OF (layered_interconnect_module_design_view);
END_ENTITY;

ENTITY layout_macro_definition_terminal_to_usage_terminal_assignment
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    SELF\shape_aspect_relationship.related_shape_aspect : printed_part_template_terminal;
UNIQUE
  UR1: SELF\shape_aspect_relationship.name;
END_ENTITY;

ENTITY layout_macro_floor_plan_template
  SUBTYPE OF (printed_part_template);
END_ENTITY;
	
END_SCHEMA;


(*
   N - ISO/CD-TS - 10303- machining_features - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Machining_features_mim;

USE FROM Elemental_geometric_shape_mim; -- ISO/TS 10303-1004
USE FROM Feature_and_connection_zone_mim; 
USE FROM Measure_representation_mim;
USE FROM Specification_document_mim;
USE FROM Value_with_unit_mim;

USE FROM aic_machining_feature; -- ISO 10303-522

ENTITY face_shape_representation_relationship
  SUBTYPE OF (representation_relationship);
      WHERE
      WR1: ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' 
            IN TYPEOF(SELF.rep_1));
      WR2: ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' 
            IN TYPEOF(SELF.rep_2));
END_ENTITY;

RULE chamfer_requires_faces FOR (chamfer,
property_definition_representation);
WHERE
WR1: (SIZEOF (QUERY (cf <* chamfer |
NOT (1 = SIZEOF (QUERY (pdr <* property_definition_representation |
((pdr\property_definition_representation.definition\property_definition.definition = cf) AND
('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
IN TYPEOF (pdr.used_representation)) AND
(pdr.used_representation.name = 'chamfer face'))
)))
))=0);
END_RULE;

RULE chamfer_offset_requires_faces FOR
(chamfer_offset, property_definition_representation);
WHERE
WR1: (SIZEOF (QUERY (co <* chamfer_offset |
NOT (1 = SIZEOF (QUERY (pdr <* property_definition_representation |
((pdr\property_definition_representation.definition\property_definition.definition = co) AND
('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' IN TYPEOF (pdr.used_representation)) AND
( ((pdr\property_definition_representation.definition\property_definition.definition.description = 'first offset') AND
(pdr.used_representation.name = 'first face shape'))
OR
((pdr\property_definition_representation.definition\property_definition.definition.description = 'second offset') AND
(pdr.used_representation.name = 'second face shape'))
))
)))
))=0);
END_RULE;

RULE edge_round_requires_faces FOR
(edge_round, property_definition_representation);
WHERE
WR1: (0 = SIZEOF (QUERY (er <* edge_round |
NOT (1 = SIZEOF (QUERY (pdr <* property_definition_representation |
((pdr\property_definition_representation.definition\property_definition.definition = er) AND
('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
IN TYPEOF (pdr.used_representation)) AND
(pdr.used_representation.name = 'edge round face'))
)))
)));
WR2: (SIZEOF (QUERY (er <* edge_round |
NOT (1 = SIZEOF (QUERY (pdr <* property_definition_representation |
((pdr\property_definition_representation.definition\property_definition.definition = er) AND
('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
IN TYPEOF (pdr.used_representation)) AND
(pdr.used_representation.name = 'first face shape'))
)))
))=0);
WR3: (SIZEOF (QUERY (er <* edge_round |
NOT (1 = SIZEOF (QUERY (pdr <* property_definition_representation |
((pdr\property_definition_representation.definition\property_definition.definition = er) AND
('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
IN TYPEOF (pdr.used_representation)) AND
(pdr.used_representation.name = 'second face shape'))
)))
))=0);
END_RULE;

RULE machining_feature_life_cycle FOR
(instanced_feature);
WHERE
WR1: SIZEOF (QUERY (mf <* instanced_feature |
NOT (mf.of_shape.definition.frame_of_reference.life_cycle_stage =
'manufacturing planning'))) = 0;
END_RULE;

RULE transition_feature_life_cycle FOR
(transition_feature);
WHERE
WR1: SIZEOF (QUERY (tf <* transition_feature |
NOT (tf.of_shape.definition.frame_of_reference.life_cycle_stage =
'manufacturing planning'))) = 0;
END_RULE;

RULE transition_feature_on_part_boundary FOR
(transition_feature);
WHERE
WR1: SIZEOF (QUERY (tf <* transition_feature |
NOT (tf.product_definitional))) = 0;
END_RULE;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7117 - ISO/TS 10303-1288 Management resource information - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4288
*) 


SCHEMA Management_resource_information_mim;

USE FROM Alias_identification_mim;    -- ISO/TS 10303-1025

USE FROM Approval_mim;    -- ISO/TS 10303-1012

USE FROM Certification_mim;    -- ISO/TS 10303-1044

USE FROM Contract_mim;    -- ISO/TS 10303-1062

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM management_resources_schema   -- ISO 10303-41
  (identification_role); 

USE FROM Multi_linguism_mim;    -- ISO/TS 10303-1105

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM Project_mim;    -- ISO/TS 10303-1061

USE FROM Security_classification_mim;    -- ISO/TS 10303-1015


TYPE mri_aliasable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON aliasable_item WITH 
   (approval_status, 
    contract, 
    organization, 
    security_classification, 
    security_classification_level);
END_TYPE; 

TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (certification, 
    contract);
END_TYPE; 

TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    identification_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization);
END_TYPE; 

TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    certification, 
    contract, 
    security_classification);
END_TYPE; 

TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (applied_organization_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    certification, 
    contract, 
    security_classification);
END_TYPE; 

TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (approval_status, 
    contract, 
    organization, 
    security_classification_level);
END_TYPE; 

TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    identification_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization);
END_TYPE; 

TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (applied_identification_assignment, 
    applied_security_classification_assignment, 
    contract);
END_TYPE; 

TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (applied_identification_assignment, 
    applied_security_classification_assignment, 
    contract);
END_TYPE; 

END_SCHEMA;  -- Management_resource_information_mim
(*
   ISO TC184/SC4/WG12 N5417 - ISO/TS 10303-1702 Manifold subsurface - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4944
*)

SCHEMA Manifold_subsurface_mim;
	USE FROM Manifold_surface_mim;	-- ISO/TS 10303-1509
	USE FROM aic_manifold_subsurface;
END_SCHEMA;

(*
	ISO TC184/SC4/WG12 N7197 - ISO/TS 10303-1509 Manifold surface - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N6244
*)

SCHEMA Manifold_surface_mim;

USE FROM Topologically_bounded_surface_mim; --ISO/TS 10303-1511:2004

USE FROM aic_manifold_surface;              -- ISO 10303-511 

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N2799 - ISO/TS 10303-1091 Maths space - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1880
*)

SCHEMA Maths_space_mim;

USE FROM Maths_value_mim;    -- ISO/TS 10303-1092

USE FROM mathematical_functions_schema    -- ISO 10303-50
  (elementary_space,
  finite_integer_interval,
  finite_real_interval,
  finite_space,
  integer_interval_from_min,
  integer_interval_to_max,
  listed_product_space,
  maths_space,
  product_space,
  real_interval_from_min,
  real_interval_to_max,
  tuple_space,
  uniform_product_space);

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N2802 - ISO/TS 10303-1092 Maths value - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1877
*)

SCHEMA Maths_value_mim;

USE FROM mathematical_functions_schema    -- ISO 10303-50
  (maths_boolean,
  maths_integer,
  maths_real,
  maths_simple_atom,
  atom_based_tuple,
  atom_based_value,
  maths_tuple,
  maths_value);

END_SCHEMA;

(*
   N - ISO/CD-TS - 10303- mating_structure - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Mating_structure_mim;

USE FROM Item_definition_structure_mim;
USE FROM Assembly_technology_mim;

ENTITY mated_part_relationship
  SUBTYPE OF (group, group_assignment, product_definition_shape, product_definition_relationship, shape_aspect);
  items : SET [0:?] OF product_definition;
DERIVE
  SELF\group_assignment.assigned_group : mated_part_relationship := SELF;
  SELF\property_definition.definition : mated_part_relationship := SELF;
  SELF\shape_aspect.of_shape : mated_part_relationship := SELF;
END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1217 - ISO/TS 10303-1118 Measure representation - EXPRESS MIM
*)

SCHEMA Measure_representation_mim;

USE FROM Foundation_representation_mim;

USE FROM qualified_measure_schema
(measure_representation_item);

USE FROM representation_schema
(value_representation_item);

USE FROM Value_with_unit_mim;

END_SCHEMA;

(* 
	ISO TC184/SC4/WG12 N5423 - ISO/TS 10303-1313 Mechanical design geometric presentation - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N4757
*)

SCHEMA Mechanical_design_geometric_presentation_mim;

USE FROM Camera_view_3d_mim; -- ISO/CD-TS 10303-1316

USE FROM Shape_appearance_layers_mim; -- ISO/CD-TS 10303-1009

USE FROM aic_mechanical_design_geometric_presentation; --  ISO 10303-517

USE FROM presentation_organization_schema   -- ISO 10303-46
  (light_source,
   light_source_ambient,
   light_source_directional,
   light_source_positional,
   light_source_spot);

END_SCHEMA;  
(*
   ISO TC184/SC4/WG12 N6683 - ISO/TS 10303-1315 Mechanical design presentation representation with draughting - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5426
*)

SCHEMA Mechanical_design_presentation_representation_with_draughting_mim;

USE FROM Associative_draughting_elements_mim; -- ISO/CD-TS 10303-1311

USE FROM Mechanical_design_geometric_presentation_mim; -- ISO/CD-TS 10303-1313

USE FROM Mechanical_design_shaded_presentation_mim; -- ISO/CD-TS 10303-1314

USE FROM representation_schema(
  definitional_representation_relationship_with_same_context);

  TYPE mechanical_design_and_draughting_relationship_select = EXTENSIBLE GENERIC_ENTITY SELECT ( 
    draughting_model,
    mechanical_design_geometric_presentation_representation,
    mechanical_design_shaded_presentation_representation,
    mechanical_design_presentation_representation_with_draughting,
    shape_representation); 
  END_TYPE; 

  ENTITY mechanical_design_presentation_representation_with_draughting
    SUBTYPE of (representation); 
      SELF\representation.items : SET[1:?] OF camera_model_d3;
  END_ENTITY;  
 
  ENTITY mechanical_design_and_draughting_relationship
    SUBTYPE OF(definitional_representation_relationship_with_same_context); 
      SELF\representation_relationship.rep_1 : mechanical_design_and_draughting_relationship_select; 
      SELF\representation_relationship.rep_2 : mechanical_design_and_draughting_relationship_select; 
    WHERE    
      WR1: NOT('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.'+'DRAUGHTING_MODEL' IN TYPEOF(rep_2)) OR 
       (('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.'+'DRAUGHTING_MODEL' IN TYPEOF(rep_1)) OR
        ('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)));
      WR2: NOT('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.'+'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_2)) OR 
       (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.'+'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_1)) OR
        ('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)));
      WR3: NOT('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_2)) OR 
       (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION' IN TYPEOF(rep_1)) OR
        ('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'SHAPE_REPRESENTATION' IN TYPEOF(rep_1)));
  END_ENTITY;  

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N5429 - ISO/TS 10303-1314 Mechanical design shaded presentation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4763
*)

SCHEMA Mechanical_design_shaded_presentation_mim;

USE FROM Camera_view_3d_mim; -- ISO/CD-TS 10303-1316
 
USE FROM Shape_appearance_layers_mim; -- ISO/CD-TS 10303-1009

USE FROM aic_mechanical_design_shaded_presentation; -- ISO 10303-518

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- model_based_3d_geometrical_dimensioning_and_tolerancing_representation - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Model_based_3d_geometrical_dimensioning_and_tolerancing_representation_mim;

USE FROM Geometric_tolerance_mim; -- ISO/TS 10303-1051
USE FROM Part_shape_mim;
USE FROM Product_and_manufacturing_information_with_nominal_3d_models_mim;

TYPE mb3dgdtr_geometric_model_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON
geometric_model_item WITH (
  connected_face_set,
  edge_loop);
END_TYPE;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7084 - ISO/TS 10303-1703 Model parameter - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6448
*)

SCHEMA Model_parameter_mim;
USE FROM Activity_method_assignment_mim;  -- ISO/TS 10303-1249
USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
USE FROM Classification_with_attributes_mim;	-- ISO/TS 10303-1111
USE FROM Independent_property_representation_mim;	-- ISO/TS 10303-1038
USE FROM Group_mim;	-- ISO/TS 10303-1113	
USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 

USE FROM product_property_definition_schema(characterized_definition);  -- ISO 10303-41

  TYPE mp_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH 
    (test_method_based_parameter_assignment);
  END_TYPE;   

  TYPE mp_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
    (group_relationship);
  END_TYPE; 

  TYPE mp_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (model_parameter);
  END_TYPE; 

  TYPE parameter_assignment_select = EXTENSIBLE GENERIC_ENTITY SELECT
    (model_parameter);
  END_TYPE;

  ENTITY category_model_parameter 
    SUBTYPE OF (model_parameter);
  END_ENTITY;

  ENTITY default_value_property_definition_representation
    SUBTYPE OF (property_definition_representation);
  END_ENTITY;

  ENTITY model_parameter 
    SUBTYPE OF (general_property);
  END_ENTITY;

  ENTITY model_parameter_with_unit 
    SUBTYPE OF (model_parameter);
    WHERE
     WR1 : NOT ('MODEL_PARAMETER_MIM.SCHEMA_BASED_MODEL_PARAMETER' IN TYPEOF(SELF));
  END_ENTITY;

  ENTITY parameter_assignment_override
    SUBTYPE OF (representation, representation_relationship);
      SELF\representation_relationship.rep_1 : parameter_assignment;
      SELF\representation_relationship.rep_2 : parameter_assignment;
    UNIQUE
      UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
    WHERE
      WR1: SELF\representation_relationship.rep_1 <> SELF\representation_relationship.rep_2;
  END_ENTITY;

  ENTITY parameter_assignment
    SUBTYPE OF (property_definition_representation, representation);
      SELF\property_definition_representation.definition : parameter_assignment_select;
  END_ENTITY; 

  ENTITY product_specific_parameter_value_assignment
    SUBTYPE OF (characterized_object,
                product_related_product_category); 
  END_ENTITY;

  ENTITY schema_based_model_parameter 
    SUBTYPE OF (model_parameter);
  END_ENTITY;

  ENTITY valid_range_property_definition_representation
    SUBTYPE OF (property_definition_representation);
  END_ENTITY;

  ENTITY test_method_based_parameter_assignment 
    SUBTYPE OF (parameter_assignment);
  END_ENTITY;

END_SCHEMA;


(*
 ISO TC184/SC4/WG12 N5432 - ISO/TS 10303-1322 Modified swept solid - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4766
*)

SCHEMA Modified_swept_solid_mim;

USE FROM Basic_geometric_topology_mim; -- ISO/CD-TS 10303-1323

USE FROM Swept_solid_mim; -- ISO/CD-TS 10303-1321

USE FROM geometric_model_schema  -- ISO 10303-42 
      (solid_model);
    
USE FROM solid_shape_element_schema  -- ISO 10303-111 
    (revolved_face_solid_with_trim_conditions,
     extruded_face_solid_with_trim_conditions,
     extruded_face_solid_with_draft_angle,
     extruded_face_solid_with_multiple_draft_angles,
     trim_condition_select,
     trim_intent);
    
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N3243 - ISO/TS 10303-1105 Multi linguism - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2224
*) 


SCHEMA Multi_linguism_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (attribute_classification_assignment,
   attribute_value_assignment); 

USE FROM group_schema   -- ISO 10303-41
  (group); 


TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (multi_language_attribute_assignment, 
    attribute_value_assignment);
END_TYPE; 


TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

ENTITY language 
SUBTYPE OF (group); 
WHERE
WR1: SELF\group.name <> '';
END_ENTITY; 

ENTITY attribute_language_assignment 
SUBTYPE OF (attribute_classification_assignment); 
  SELF\attribute_classification_assignment.assigned_class: language;
  items : SET [1:?] OF attribute_language_item; 
WHERE 
WR1: SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']; 
WR2: SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY; 

ENTITY multi_language_attribute_assignment 
SUBTYPE OF (attribute_value_assignment); 
  items : SET [1:?] OF multi_language_attribute_item;

DERIVE
  translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;

INVERSE
  language_indication: SET[1:1] OF attribute_language_assignment FOR items;

WHERE 
WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
WR2: SIZEOF( QUERY( ala <* language_indication |  
   (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
   (ala\attribute_classification_assignment.role.name='translated') )) = 1 ; 
WR3: SELF\attribute_value_assignment.attribute_name <> '' ;
WR4: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
(ata.translation_language :=: translation_language) ))>1 )) =0;
WR5: SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |
 (ata\attribute_classification_assignment.role.name='primary') AND
 (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
 (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
END_ENTITY; 


RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
WR1: SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
	SIZEOF(QUERY( it <* ala1.items |
	   SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 
		( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
		( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
		 )) >1 
	   )) >0 
	)) =0;
END_RULE;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N3086 - ISO/TS 10303-1340 Name assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2283
*) 


SCHEMA Name_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (name_assignment); 


TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_name_assignment
  SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;

END_SCHEMA;  -- Name_assignment_mim




(*
   ISO TC184/SC4/WG12 N6451 - ISO/TS 10303-1704 Network functional design view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5714
*)
SCHEMA Network_functional_design_view_mim;

	USE FROM Assembly_structure_mim;	-- ISO/TS 10303-xxxx
	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233

USE FROM Material_property_definition_schema (property_definition_relationship);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 

TYPE nfdv_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (component_functional_unit);
END_TYPE; 

ENTITY bus_element_link
  SUBTYPE OF (product_definition,product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.related_product_definition,
       SELF\product_definition_relationship.relating_product_definition;
WHERE
  WR1: SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
END_ENTITY; 

ENTITY bus_structural_definition
 SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY component_functional_terminal
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY component_functional_unit
  SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY network_node_definition
  SUBTYPE OF (product_definition);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6454 - ISO/TS 10303-1706 Non feature shape element - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5720
*)

SCHEMA Non_feature_shape_element_mim;
	USE FROM Physical_unit_shape_with_parameters_mim;	-- ISO/TS 10303-1730

	USE FROM material_property_definition_schema(property_definition_relationship);
	
ENTITY group_shape_aspect
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY interface_plane
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY edge_segment_vertex
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY reference_graphic_registration_mark
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = false;
END_ENTITY;

ENTITY seating_plane
  SUBTYPE OF (shape_aspect);
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N5435 - ISO/TS 10303-1324 Non manifold surface - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4769
*)
SCHEMA Non_manifold_surface_mim;

USE FROM Elemental_geometric_shape_mim; -- ISO/CD-TS 10303-1004

USE FROM aic_non_manifold_surface; -- ISO 10303-518

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7221 - ISO/TS 10303-1526 Numeric expression - EXPRESS MIM
*)

SCHEMA Numeric_expression_mim;

USE FROM Generic_expression_mim;
USE FROM Numeric_function_mim;
USE FROM Expression_mim;

USE FROM ISO13584_expressions_schema(
	and_expression,
	binary_boolean_expression,
	binary_function_call,
	binary_numeric_expression,
	boolean_defined_function,
	boolean_expression,
	boolean_literal,
	boolean_variable,
	comparison_equal,
	comparison_expression,
	comparison_greater,
	comparison_greater_equal,
	comparison_less,
	comparison_less_equal,
	comparison_not_equal,
	defined_function,
	div_expression,
	equals_expression,
	expression,
	int_literal,
	int_numeric_variable,
	literal_number,
	minus_expression,
	mod_expression,
	mult_expression,
	multiple_arity_boolean_expression,
	multiple_arity_function_call,
	multiple_arity_numeric_expression,
	not_expression,
	numeric_expression,
	numeric_variable,
	or_expression,
	plus_expression,
	power_expression,
	real_literal,
	real_numeric_variable,
	simple_boolean_expression,
	simple_numeric_expression,
	slash_expression,
	unary_boolean_expression,
	unary_numeric_expression,
	xor_expression
	);
	
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N7227 - ISO/TS 10303-1346 Numeric function - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4508 
*)

SCHEMA Numeric_function_mim;

USE FROM Elementary_function_mim;

USE FROM Expression_mim;

USE FROM iso13584_expressions_schema(
	int_value_function,
	length_function,	
	odd_function,	
	value_function);
	
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N2559 - ISO/TS 10303-1344 Numerical interface - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1800
*)

SCHEMA Numerical_interface_mim;

USE FROM Generic_expression_mim;
USE FROM Expression_mim;
USE FROM Value_with_unit_mim;
USE FROM Measure_representation_mim;

USE FROM iso13584_expressions_schema(
	numeric_expression,
	string_expression
);

TYPE property_variable_rep_select = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE;

TYPE expression_extension_select = SELECT (
    expression_extension_string,
    expression_extension_numeric);
END_TYPE;

ENTITY expression_extension_numeric
    SUBTYPE OF (measure_with_unit, numeric_expression);    
END_ENTITY;

ENTITY expression_extension_string
    SUBTYPE OF (measure_with_unit, string_expression);    
END_ENTITY;

ENTITY expression_extension_to_select;
    type_expression_associated: expression_extension_select;
END_ENTITY;
 
ENTITY variable_expression
    SUBTYPE OF (variable_semantics);
    property_associated: property_variable_rep_select;
END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6999 - ISO/TS 10303-1707 Package - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6457
*)


SCHEMA Package_mim;
--	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051
	USE FROM Non_feature_shape_element_mim;

	USE FROM Part_feature_function_mim;	-- ISO/TS 10303-1712

	SUBTYPE_CONSTRAINT package_part_feature_subtypes FOR shape_aspect; 
		(ONEOF (package_body,
		primary_orientation_feature,
		secondary_orientation_feature,
		tertiary_orientation_feature));
	END_SUBTYPE_CONSTRAINT;

	TYPE p_groupable_item = SELECT BASED_ON groupable_item WITH 
	   (representation_item);
	END_TYPE; 

 	TYPE pa_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
		(package,
		package_terminal_template_definition);
	END_TYPE;

ENTITY visual_orientation_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY guided_wave_terminal
   SUBTYPE OF (package_terminal);
END_ENTITY;

ENTITY package
 SUBTYPE OF (physical_unit);
END_ENTITY;

ENTITY package_body
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY package_body_bottom_surface
 SUBTYPE OF (package_body_surface);
END_ENTITY;

ENTITY package_body_edge_segment_surface
  SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    SELF\shape_aspect_relationship.relating_shape_aspect : edge_segment_vertex;
    SELF\shape_aspect_relationship.related_shape_aspect  : edge_segment_vertex;
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
       SELF\shape_aspect_relationship.related_shape_aspect;
END_ENTITY;

ENTITY package_body_edge_surface
 SUBTYPE OF (package_body_surface);
END_ENTITY;

ENTITY package_body_surface
ABSTRACT SUPERTYPE OF (ONEOF(package_body_top_surface,
                         package_body_edge_surface,
                         package_body_bottom_surface))
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY package_body_top_surface
 SUBTYPE OF (package_body_surface);
END_ENTITY;

ENTITY package_terminal_template_definition
  SUBTYPE OF (part_feature_template_definition);
END_ENTITY;  

ENTITY package_terminal
 SUPERTYPE OF (guided_wave_terminal 
 	ANDOR primary_reference_terminal)
  SUBTYPE OF (placed_feature);
END_ENTITY;

ENTITY primary_orientation_feature
 SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY primary_reference_terminal
  SUBTYPE OF (package_terminal);
END_ENTITY;

ENTITY secondary_orientation_feature
 SUBTYPE OF (shape_aspect);
WHERE
 WR1: SELF.product_definitional = TRUE;
END_ENTITY;

ENTITY tertiary_orientation_feature
 SUBTYPE OF (shape_aspect);
WHERE
 WR1: SELF.product_definitional = TRUE;
END_ENTITY;

ENTITY wire_terminal
   SUBTYPE OF (package_terminal);
END_ENTITY;

ENTITY wire_terminal_template_definition
   SUBTYPE OF (package_terminal_template_definition);
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6460 - ISO/TS 10303-1708 Packaged connector model - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5726
*)


SCHEMA Packaged_connector_model_mim;
	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710

ENTITY packaged_connector
  SUBTYPE OF (packaged_part);
END_ENTITY;

ENTITY packaged_connector_terminal_relationship
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N7002 - ISO/TS 10303-1710 Packaged part black box model - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6463
*)
SCHEMA Packaged_part_black_box_model_mim;

	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705
	USE FROM Package_mim;	-- ISO/TS 10303-1707
	USE FROM Part_external_reference_mim;	-- ISO/TS 10303-1711

ENTITY packaged_part
 SUBTYPE OF (physical_unit);
END_ENTITY;

ENTITY packaged_part_terminal
 SUBTYPE OF (shape_aspect);
END_ENTITY;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6466 - ISO/TS 10303-1709 Packaged part white box model - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5729
*)


SCHEMA Packaged_part_white_box_model_mim;
	USE FROM Bare_die_mim;	-- ISO/TS 10303-1650
	USE FROM Packaged_part_black_box_model_mim;	-- ISO/TS 10303-1710
	USE FROM Physical_unit_2d_shape_mim;	-- ISO/TS 10303-1726
	USE FROM Physical_unit_3d_shape_mim;	-- ISO/TS 10303-1727
	
	
ENTITY device_terminal_map
 SUBTYPE OF (shape_aspect, shape_aspect_relationship);
   SELF\shape_aspect_relationship.relating_shape_aspect : packaged_part_terminal;
UNIQUE
  UR1: SELF\shape_aspect_relationship.related_shape_aspect,
       SELF\shape_aspect_relationship.relating_shape_aspect;
END_ENTITY;
	
END_SCHEMA;


(*
  ISO TC184/SC4/WG12 N7209 - ISO/TS 10303-1790 Parameterization and variational representation - EXPRESS MIM
*)

SCHEMA Parameterization_and_variational_representation_mim;  -- ISO 10303-1pc1

USE FROM Elemental_geometric_shape_mim; -- ISO 10303-1004
USE FROM Maths_space_mim; -- ISO 10303-1091

USE FROM mathematical_functions_schema     -- ISO 10303-50 
            (maths_number,
             maths_variable);
USE FROM parameterization_schema;     -- ISO 10303-108 

USE FROM variational_representation_schema;     -- ISO 10303-108 

USE FROM ISO13584_generic_expressions_schema  -- ISO 13584-20 
      (environment,
      variable_semantics);


END_SCHEMA;

(*
   N - ISO/CD-TS - 10303- parametric_representation - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Parametric_representation_mim;

USE FROM Foundation_representation_mim; --  ISO/TS 10303-1006
USE FROM representation_schema( -- ISO 10303-43
  definitional_representation,
  parametric_representation_context);

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6581 - ISO/TS 10303-1022 Part and version identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5438
*) 


SCHEMA Part_and_version_identification_mim;

USE FROM product_definition_schema   -- ISO 10303-41
  (product_category,
   product_related_product_category); 

USE FROM Product_identification_mim;    -- ISO/CD-TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

END_SCHEMA;  -- Part_and_version_identification_mim

(*
 ISO TC184/SC4/WG12 N6250 - ISO/TS 10303-1770 Part and zone laminate tables - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5441
*)

SCHEMA Part_and_zone_laminate_tables_mim;

USE FROM Composite_constituent_shape_mim; -- ISO/CD-TS 10303-1767

USE FROM Ply_orientation_specification_mim; -- ISO/CD-TS 10303-1772

USE FROM Shape_property_assignment_mim; -- ISO/CD-TS 10303-1032

USE FROM Stock_material_mim; -- ISO/CD-TS 10303-1771

USE FROM product_structure_schema (next_assembly_usage_occurrence);

USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 


  ENTITY composite_assembly_sequence_definition
    SUBTYPE OF (product_definition);
    WHERE
      WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'PRODUCT_DEFINITION_SCHEMA.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'PRODUCT_STRUCTURE_SCHEMA.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) > 0;
  END_ENTITY;

  ENTITY composite_assembly_table
    SUBTYPE OF (part_laminate_table);
  END_ENTITY;

  ENTITY laminate_table
    SUPERTYPE OF (ONEOF(part_laminate_table, zone_structural_makeup))
    SUBTYPE OF (product_definition);
  END_ENTITY;

  ENTITY part_laminate_table
    SUPERTYPE OF (ONEOF(composite_assembly_table, ply_laminate_table))
    SUBTYPE OF (laminate_table);
  END_ENTITY;

  ENTITY percentage_laminate_table
    SUBTYPE OF (zone_structural_makeup);
  END_ENTITY;

  ENTITY ply_laminate_sequence_definition
    SUBTYPE OF (product_definition);
    WHERE
      WR1: SIZEOF (QUERY (pdr <* USEDIN (SELF, 
                             'PRODUCT_DEFINITION_SCHEMA.' +
                             'PRODUCT_DEFINITION_RELATIONSHIP.' +
                             'RELATING_PRODUCT_DEFINITION') |
                             'PRODUCT_STRUCTURE_SCHEMA.' +
                             'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN
                             TYPEOF (pdr))) > 0;
  END_ENTITY;

  ENTITY ply_laminate_table
    SUBTYPE OF (part_laminate_table);
  END_ENTITY;

  ENTITY smeared_material_definition
    SUBTYPE OF (zone_structural_makeup);
  END_ENTITY;

  ENTITY thickness_laminate_table
    SUBTYPE OF (zone_structural_makeup);
  END_ENTITY;

  ENTITY zone_structural_makeup
    SUPERTYPE OF (ONEOF((thickness_laminate_table AND smeared_material_definition), (percentage_laminate_table AND smeared_material_definition), thickness_laminate_table, percentage_laminate_table, smeared_material_definition))
    SUBTYPE OF (laminate_table);
  END_ENTITY;

  SUBTYPE_CONSTRAINT pos_product_definition_subtypes FOR product_definition;
    ONEOF (composite_assembly_sequence_definition,
           laminate_table,
           ply_laminate_sequence_definition);
  END_SUBTYPE_CONSTRAINT;

  RULE component_class_for_assembly_select FOR
     (composite_assembly_sequence_definition,
      next_assembly_usage_occurrence,
      product_related_product_category);
    LOCAL
      i,j,k :  INTEGER :=0;
      dkuhr :  LOGICAL :=TRUE;
      nnauo :  INTEGER :=0;
      nprpc :  INTEGER :=0;
      rp    :  product;
    END_LOCAL;
    REPEAT i:= LOINDEX (composite_assembly_sequence_definition) TO
               HIINDEX (composite_assembly_sequence_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO
                 HIINDEX (next_assembly_usage_occurrence);
        IF (composite_assembly_sequence_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN ['ply',
                 'ply laminate', 'filament laminate', 'processed core',
                 'composite assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nnauo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
    WHERE
      WR1:  dkuhr;
  END_RULE;

  RULE ply_reference FOR
     (ply_laminate_sequence_definition,
      next_assembly_usage_occurrence,
      product_related_product_category);
    LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL := TRUE;
      nnauo :  INTEGER;
      nprpc :  INTEGER := 0;
      rp    :  product;
    END_LOCAL;
    REPEAT i:= LOINDEX (ply_laminate_sequence_definition) TO
               HIINDEX (ply_laminate_sequence_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO 
                 HIINDEX (next_assembly_usage_occurrence);
        IF (ply_laminate_sequence_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((product_related_product_category[k].name = 'ply') AND
                (rp IN product_related_product_category[k].products)) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nnauo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
    WHERE
      WR1:  dkuhr;
  END_RULE;

(*
  RULE stock_material_reference FOR
     (percentage_ply_definition,
      make_from_usage_option,
      product_related_product_category);
    LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL;
      nmfuo :  INTEGER;
      nprpc :  INTEGER;
      rp     :  product;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i:= LOINDEX (percentage_ply_definition) TO
               HIINDEX (percentage_ply_definition);
      nmfuo := 0;  
      REPEAT j:= LOINDEX (make_from_usage_option) TO 
                 HIINDEX (make_from_usage_option);
        IF (percentage_ply_definition[i] = 
          make_from_usage_option[j].relating_product_definition) THEN
          rp := make_from_usage_option[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                ['anisotropic material', 'isotropic material', 'stock core',
                 'filament assembly', 'discontinuous fiber assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nmfuo := nmfuo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nmfuo = 0) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
    WHERE
      WR1:  dkuhr;
  END_RULE;
*)
(*
  RULE thickness_laminate_table_component_select FOR
     (thickness_laminate_definition,
      next_assembly_usage_occurrence,
      product_related_product_category);
    LOCAL
      i,j,k :  INTEGER;
      dkuhr :  LOGICAL;
      nnauo :  INTEGER;
      nprpc :  INTEGER;
      rp    :  product;
    END_LOCAL;
    dkuhr := TRUE;
    REPEAT i:= LOINDEX (thickness_laminate_definition) TO
               HIINDEX (thickness_laminate_definition);
      nnauo := 0;  
      REPEAT j:= LOINDEX (next_assembly_usage_occurrence) TO 
                 HIINDEX (next_assembly_usage_occurrence);
        IF (thickness_laminate_definition[i] = 
          next_assembly_usage_occurrence[j].relating_product_definition) THEN
          rp := next_assembly_usage_occurrence[j].related_product_definition.
                formation.of_product;
          nprpc := 0;
          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);
            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                 ['ply', 'filament laminate', 'processed core'])) THEN
                nprpc := nprpc + 1;
            END_IF;
          END_REPEAT;
          IF (nprpc = 1) THEN
            nnauo := nnauo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;
        END_IF;
      END_REPEAT;
      IF (dkuhr = FALSE) THEN
        ESCAPE;
      END_IF;
      IF (nnauo <> 1) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;
    END_REPEAT;
    WHERE
      WR1:  dkuhr;
  END_RULE;
*)
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N6915 - ISO/TS 10303-1115 Part collection - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6247
*)

SCHEMA Part_collection_mim;

USE FROM Product_occurrence_mim;

REFERENCE FROM product_definition_schema
	(categories_of_product);


  RULE restrict_collection_category FOR (product_definition);
    LOCAL
      collection_definitions: SET OF product_definition := [];
    END_LOCAL;
      collection_definitions :=  QUERY( pd <* product_definition | 
        SIZEOF( QUERY( pdca <* USEDIN( pd, 'PART_COLLECTION_MIM' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') |
        pdca.frame_of_reference.name= 'collection definition')) > 0 );
    WHERE
      WR1: SIZEOF( QUERY( pd <* collection_definitions | 
	    NOT ('collection' IN categories_of_product(pd.formation.of_product)) ))= 0;
  END_RULE;

  RULE restrict_product_definitions_for_collection FOR
      (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
       ( pdr. name = 'collection membership' ) AND 
       ( ( pdr.relating_product_definition.frame_of_reference.name<>'part definition' ) OR 
       ( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' ) OR 
       ( SIZEOF ( QUERY ( pdca <* USEDIN (pdr.relating_product_definition ,
       'PART_COLLECTION_MIM' + '.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION') | 
       ( pdca.role.name = 'part definition type' ) AND 
       ( pdca.frame_of_reference.name = 'collection definition' ) )) =0 ) ) ) ) =0;
  END_RULE;
  
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1327 - ISO/TS 10303-1055 Part definition relationship - EXPRESS MIM
*)
   
SCHEMA Part_definition_relationship_mim;

USE FROM Part_view_definition_mim;
USE FROM Product_view_definition_relationship_mim;
USE FROM Value_with_unit_mim; -- ISO/TS 10303-1054

USE FROM product_structure_schema
	(make_from_usage_option);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6469 - ISO/TS 10303-1711 Part external reference - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5735
*)


SCHEMA Part_external_reference_mim;
	USE FROM Part_template_mim;	-- ISO/TS 10303-1722

  ENTITY part_terminal_external_reference
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6472 - ISO/TS 10303-1712 Part feature function - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5738
*)


SCHEMA Part_feature_function_mim;
	USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732

ENTITY fiducial_part_feature
 SUBTYPE OF (part_tooling_feature);
END_ENTITY;

ENTITY part_interface_access_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY part_mating_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY part_mounting_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY part_tooling_feature
 SUPERTYPE OF (ONEOF(fiducial_part_feature,
               tool_registration_mark) ANDOR 
               test_point_part_feature)
 SUBTYPE OF (shape_aspect);
WHERE
 WR1: SELF\shape_aspect.product_definitional = true;
END_ENTITY;

ENTITY test_point_part_feature
 SUBTYPE OF (part_tooling_feature);
END_ENTITY;

ENTITY thermal_feature
 SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY tool_registration_mark
 SUBTYPE OF (part_tooling_feature);
END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7005 - ISO/TS 10303-1713 Part feature grouping - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6475
*)


SCHEMA Part_feature_grouping_mim;
	USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732
--	USE FROM Value_with_unit_extension_mim;	-- ISO/TS 10303-1753
	USE FROM Shape_aspect_definition_schema(composite_shape_aspect);
	
ENTITY composite_array_shape_aspect
  SUPERTYPE OF (ONEOF( linear_composite_array_shape_aspect,
                 rectangular_composite_array_shape_aspect))
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

ENTITY composite_array_shape_aspect_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
END_ENTITY; 

ENTITY linear_composite_array_shape_aspect
  SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY;

ENTITY linear_composite_array_shape_aspect_link
  SUBTYPE OF (shape_aspect,shape_aspect_relationship);
    SELF\shape_aspect_relationship.relating_shape_aspect : linear_composite_array_shape_aspect;
    SELF\shape_aspect_relationship.related_shape_aspect  : linear_composite_array_shape_aspect;
WHERE
  WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
END_ENTITY; 

ENTITY rectangular_composite_array_shape_aspect
  SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N7081 - ISO/TS 10303-1714 Part feature location - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6478
*)


SCHEMA Part_feature_location_mim;
	USE FROM Shape_feature_mim;	-- ISO/TS 10303-1764
	USE FROM product_property_representation_schema(item_identified_representation_usage);

  ENTITY usage_concept_usage_relationship
    SUBTYPE OF (mapped_item, item_identified_representation_usage);
      SELF\item_identified_representation_usage.used_representation : shape_representation;
      SELF\item_identified_representation_usage.definition          : shape_aspect;
    DERIVE
      SELF\item_identified_representation_usage.identified_item : usage_concept_usage_relationship := SELF;
    WHERE
      WR1: SELF IN SELF\item_identified_representation_usage.used_representation.items;
  END_ENTITY;
	
END_SCHEMA;

(*
   N - ISO/TS 10303-1807 general_part_feature - EXPRESS MIM
*)

SCHEMA Part_shape_mim;

USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032
USE FROM Feature_and_connection_zone_mim; --          ISO/TS 10303-1671

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6481 - ISO/TS 10303-1722 Part template - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5762
*)


SCHEMA Part_template_mim;

USE FROM Analytical_model_mim;	-- ISO/TS 10303-1603
USE FROM Feature_and_connection_zone_mim;	-- ISO/TS 10303-1671
USE FROM Part_shape_mim;

USE FROM Application_context_schema(application_context_element);
USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 

  TYPE plt_groupable_item = SELECT BASED_ON groupable_item WITH 
    (representation_item);
  END_TYPE; 
		
  ENTITY part_template_definition
    SUBTYPE OF (product_definition, product_definition_shape);
    DERIVE
      SELF\property_definition.definition : part_template_definition := SELF;
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) = 0;
      WR2: NOT EXISTS(SELF\property_definition.description);
  END_ENTITY;	
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6484 - ISO/TS 10303-1717 Part template 3d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5750
*)


SCHEMA Part_template_3d_shape_mim;
	USE FROM Edge_shape_feature_mim;	-- ISO/TS 10303-1673
	USE FROM Layered_3d_shape_mim;	-- ISO/TS 10303-1694
	USE FROM Layered_interconnect_simple_template_mim;	-- ISO/TS 10303-1718

ENTITY edge_segment_cross_section
  SUBTYPE OF (shape_definition_3d_intersection);
END_ENTITY; 

ENTITY inter_stratum_feature_edge_segment_template_with_cross_section
  SUBTYPE OF (inter_stratum_feature_edge_segment_template);
END_ENTITY;
  
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6487 - ISO/TS 10303-1719 Part template non planar shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5756
*)


SCHEMA Part_template_non_planar_shape_mim;
    USE FROM Part_template_3d_shape_mim;	-- ISO/TS 10303-1717
	USE FROM Manifold_surface_mim;	-- ISO/TS 10303-1509

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N7008 - ISO/TS 10303-1720 Part template shape with parameters - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6490
*)

SCHEMA Part_template_shape_with_parameters_mim;
USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
USE FROM Part_template_mim;	-- ISO/TS 10303-1722
	
  TYPE ptswp_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
    (shape_representation);
  END_TYPE;
	
  TYPE ptswp_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (shape_representation);
  END_TYPE; 

  ENTITY geometric_template
    ABSTRACT SUPERTYPE
    SUBTYPE OF (part_template_definition);
  END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N2919 - ISO/TS 10303-1023 Part view definition - EXPRESS MIM
*)


SCHEMA Part_view_definition_mim;

USE FROM Part_and_version_identification_mim;    -- ISO/TS 10303-1022

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019


END_SCHEMA;  -- Part_view_definition_mim
(*
ISO TC184/SC4/WG12 N2922 - ISO/TS 10303-1011 Person organization - EXPRESS MIM
*) 


SCHEMA Person_organization_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select,
   name_attribute,
   name_attribute_select); 

USE FROM person_organization_schema   -- ISO 10303-41
  (address,
   organization,
   organization_relationship,
   organizational_address,
   person,
   person_and_organization,
   personal_address); 


ENTITY person_and_organization_address
  SUBTYPE OF (organizational_address, personal_address);
  SELF\organizational_address.organizations : SET[1:1] OF organization;
  SELF\personal_address.people : SET[1:1] OF person;
WHERE
  WR1: SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;
END_ENTITY;

END_SCHEMA;  -- Person_organization_mim
(*
ISO TC184/SC4/WG12 N7123 - ISO/TS 10303-1013 Person organization assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1091
*)
      
SCHEMA Person_organization_assignment_mim;

USE FROM management_resources_schema   -- ISO 10303-41
  (organization_assignment,
   person_and_organization_assignment); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organization_role,
   person_and_organization_role); 


TYPE organization_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_organization_assignment
  SUBTYPE OF (organization_assignment);
  items : SET[1:?] OF organization_item;
END_ENTITY;

ENTITY applied_person_and_organization_assignment
  SUBTYPE OF (person_and_organization_assignment);
  items : SET[1:?] OF person_and_organization_item;
END_ENTITY;

END_SCHEMA;  -- Person_organization_assignment_mim
(*
 ISO TC184/SC4/WG12 N5450 - ISO/TS 10303-1215 Physical breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4947
*) 

SCHEMA Physical_breakdown_mim;

USE FROM Product_breakdown_mim;    -- ISO/TS 10303-1248


  ENTITY physical_breakdown_context
    SUBTYPE OF (breakdown_context);
  END_ENTITY;

  ENTITY physical_element_usage
    SUBTYPE OF (breakdown_element_usage);
  END_ENTITY;

END_SCHEMA;  
(*
   ISO TC184/SC4/WG12 N6493 - ISO/TS 10303-1721 Physical component feature - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4111
*)


SCHEMA Physical_component_feature_mim;
	USE FROM Component_feature_mim;	-- ISO/TS 10303-1657

 ENTITY physical_component_feature
    SUBTYPE OF (component_feature);
  END_ENTITY;

  ENTITY physical_component_terminal
    SUBTYPE OF (component_terminal,
 			physical_component_feature);
  END_ENTITY;
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N7011 - ISO/TS 10303-1755 Physical connectivity definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6496
*)


SCHEMA Physical_connectivity_definition_mim;

USE FROM Part_external_reference_mim;	-- ISO/TS 10303-1711
USE FROM Physical_component_feature_mim;	-- ISO/TS 10303-1721
USE FROM Physical_unit_design_view_mim;
USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740

TYPE pcd_groupable_item = SELECT BASED_ON groupable_item WITH 
   (physical_connectivity_definition,
   group_relationship);
END_TYPE; 

TYPE pcd_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (shape_aspect_relationship,
      physical_connectivity_definition);
END_TYPE; 

TYPE pcd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (physical_connectivity_definition,
      physical_connectivity_element);
END_TYPE; 
	
ENTITY make_from_connectivity_relationship
 SUBTYPE OF (shape_aspect_relationship);
  SELF\shape_aspect_relationship.relating_shape_aspect : physical_connectivity_definition; 
  SELF\shape_aspect_relationship.related_shape_aspect  : physical_connectivity_definition;
END_ENTITY;

ENTITY physical_connectivity_definition
  SUBTYPE OF (shape_aspect);
UNIQUE
  UR1: SELF\shape_aspect.name,SELF\shape_aspect.of_shape;
END_ENTITY;

ENTITY physical_connectivity_definition_domain
  SUBTYPE OF (property_definition);
END_ENTITY;

ENTITY physical_connectivity_element
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
END_ENTITY;

ENTITY physical_unit_network_definition
 SUBTYPE OF (physical_unit);
END_ENTITY;

ENTITY physical_connectivity_layout_topology_link
    SUBTYPE OF(group_relationship);
END_ENTITY;

ENTITY physical_connectivity_layout_topology_node
  SUBTYPE OF(group);
END_ENTITY;

ENTITY physical_connectivity_layout_topology_requirement
  SUBTYPE OF(predefined_requirement_view_definition, group);
END_ENTITY;

ENTITY physical_connectivity_layout_topology_requirement_assignment
  SUBTYPE OF(requirement_assignment);
END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6499 - ISO/TS 10303-1723 Physical node requirement to implementing component allocation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5765
*)


SCHEMA Physical_node_requirement_to_implementing_component_allocation_mim;
	USE FROM Assembly_module_with_packaged_connector_component_mim;	-- ISO/TS 10303-1645
	USE FROM Assembly_technology_mim;	-- ISO/TS 10303-1649
	USE FROM Physical_connectivity_definition_mim;	-- ISO/TS 10303-1755
	
REFERENCE FROM product_property_definition_schema -- ISO 10303-41
  (acyclic_shape_aspect_relationship);

  ENTITY assembly_to_part_connectivity_structure_allocation
    SUBTYPE OF (shape_aspect_relationship, shape_aspect);
	  SELF\shape_aspect_relationship.related_shape_aspect RENAMED assembly_element : physical_connectivity_element;
	  SELF\shape_aspect_relationship.relating_shape_aspect RENAMED part_element    : part_connected_terminals_element;
  END_ENTITY;	
	
  ENTITY physical_node_branch_requirement_to_implementing_component_allocation
    SUBTYPE OF (shape_aspect_relationship, shape_aspect);  
	  SELF\shape_aspect_relationship.related_shape_aspect RENAMED physical_node_branch_requirement : physical_connectivity_element;
      SELF\shape_aspect.of_shape RENAMED implementation_component                                  : assembly_component;
	  SELF\shape_aspect_relationship.relating_shape_aspect RENAMED part_element                    : part_connected_terminals_element;
  END_ENTITY;	
	
ENTITY physical_node_requirement_to_implementing_component_allocation
  SUBTYPE OF (shape_aspect_relationship, shape_aspect);
    SELF\shape_aspect_relationship.relating_shape_aspect : physical_connectivity_definition;
WHERE
  WR1: acyclic_shape_aspect_relationship(SELF,
       [SELF\shape_aspect_relationship.related_shape_aspect],
       'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION_MIM.'+
       'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION');
END_ENTITY;
	
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N7014 - ISO/TS 10303-1724 Physical unit 2d design view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6502
*)


SCHEMA Physical_unit_2d_design_view_mim;
	USE FROM Part_template_shape_with_parameters_mim;  -- ISO/TS 10303-1720	
	USE FROM Physical_unit_2d_shape_mim;	-- ISO/TS 10303-1726
	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728
	
REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 
	
	
ENTITY component_2d_location
  SUBTYPE OF (context_dependent_shape_representation, shape_representation_relationship, representation_relationship_with_transformation, definitional_representation_relationship);
  DERIVE
    SELF\context_dependent_shape_representation.representation_relation : component_2d_location := SELF;   -- NEW
  WHERE
    WR1: SELF\representation_relationship.name = 'component 2d location';
END_ENTITY;

FUNCTION cto2d_determinant_test (cto2d: cartesian_transformation_operator_2d;
                             expected_value: REAL; delta: REAL ) : BOOLEAN;

LOCAL
  det : REAL := 0.0;
  DRs : LIST [4:4] OF REAL := [];
END_LOCAL;
     DRs[1] := cto2d.u[1].direction_ratios[1];
     DRs[2] := cto2d.u[1].direction_ratios[2];
     DRs[3] := cto2d.u[2].direction_ratios[1];
     DRs[4] := cto2d.u[2].direction_ratios[2];
     det  :=  (DRs[1] * DRs[4]) - (DRs[2] * DRs[3]);
IF (Abs(expected_value - det) < Abs(delta) ) THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6505 - ISO/TS 10303-1726 Physical unit 2d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5774
*)


SCHEMA Physical_unit_2d_shape_mim;
USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
USE FROM Layered_2d_shape_mim; -- ISO/TS 10303-1693
	
  TYPE pu2ds_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
    (shape_representation);
  END_TYPE;
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N7017 - ISO/TS 10303-1725 Physical unit 3d design view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6508
*)


SCHEMA Physical_unit_3d_design_view_mim;

USE FROM Layered_3d_shape_mim;	-- ISO/TS 10303-1694
USE FROM Part_template_shape_with_parameters_mim;  -- ISO/TS 10303-1720	
USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728	
USE FROM Solid_model_mim;

USE FROM aic_manifold_surface (manifold_surface_shape_representation); -- ISO 10303-511 
	
ENTITY component_3d_location
  SUBTYPE OF (context_dependent_shape_representation, shape_representation_relationship, representation_relationship_with_transformation, definitional_representation_relationship);
  DERIVE
    SELF\context_dependent_shape_representation.representation_relation : component_3d_location := SELF;   -- NEW
  WHERE
    WR1: SELF\representation_relationship.name = 'component 3d location';
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6511 - ISO/TS 10303-1727 Physical unit 3d shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5777
*)

SCHEMA Physical_unit_3d_shape_mim;
USE FROM Non_feature_shape_element_mim;	-- ISO/TS 10303-1706
USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740

USE FROM geometric_model_schema  -- ISO 10303-42 
      (solid_model);
    	
  TYPE pu3ds_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
    (shape_representation);
  END_TYPE;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N7020 - ISO/TS 10303-1728 Physical unit design view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6514
*)

SCHEMA Physical_unit_design_view_mim;

USE FROM Assembly_component_mim;
USE FROM Interface_component_mim;	-- ISO/TS 10303-1691
USE FROM Part_template_mim; -- ISO/TS 10303-1722
USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732
USE FROM Specification_document_mim;	-- ISO/TS 10303-1747

USE FROM application_context_schema(application_context_element);

  TYPE component_material_relationship_assignment_item = EXTENSIBLE SELECT (* GL fix for XIM *) 
    (assembly_item_number, 
     assembly_component_usage, 
     specification_definition);
  END_TYPE;
 
  TYPE pudv_groupable_item = SELECT BASED_ON groupable_item WITH 
    (assembly_component,
    assembly_component_usage);
  END_TYPE; 
	
  TYPE pudv_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (assembly_component_usage,
     assembly_item_number,
     component_material_relationship);
  END_TYPE; 

  ENTITY assembly_item_number 
    SUBTYPE OF (group, applied_group_assignment);
      SELF\applied_group_assignment.items : SET [1:?] OF assembly_component_usage;
    DERIVE
      SELF\group_assignment.assigned_group : group := SELF;
  END_ENTITY;

  ENTITY component_material_relationship 
    SUBTYPE OF (group, property_definition);
      SELF\property_definition.definition : physical_unit;
  END_ENTITY;

  ENTITY component_material_relationship_assignment 
    SUBTYPE OF (group_assignment, role_association);
      SELF\group_assignment.assigned_group : component_material_relationship;
      items                                : SET [1:1] OF component_material_relationship_assignment_item;
    DERIVE
      SELF\role_association.item_with_role : component_material_relationship_assignment := SELF;
  END_ENTITY; 

  ENTITY next_assembly_usage_occurrence_relationship
    SUBTYPE OF (next_assembly_usage_occurrence,
      product_definition_occurrence_relationship);
    DERIVE
      SELF\product_definition_occurrence_relationship.occurrence_usage : next_assembly_usage_occurrence_relationship := SELF;
  END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6517 - ISO/TS 10303-1729 Physical unit interconnect definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5783
*)


SCHEMA Physical_unit_interconnect_definition_mim;

USE FROM Product_occurrence_mim;

USE FROM date_time_schema
		(date_time_role,
		date_role);
USE FROM document_schema(document_type);
USE FROM person_organization_schema
		(person_and_organization_role,
		 organization_role);	
USE FROM product_definition_schema(product_definition_with_associated_documents);	
USE FROM product_property_definition_schema(property_definition);
			
ENTITY connector_based_interconnect_definition
  SUBTYPE OF (property_definition);
    SELF\property_definition.definition : physical_unit_interconnect_definition;
UNIQUE
  UR1: SELF\property_definition.name,SELF\property_definition.definition;
END_ENTITY;

ENTITY physical_unit_interconnect_definition
 SUBTYPE OF (product_definition);
END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N7023 - ISO/TS 10303-1613 Physical unit non planar design view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6520
*)


SCHEMA Physical_unit_non_planar_design_view_mim;
	USE FROM Manifold_subsurface_mim;	-- ISO/TS 10303-1702
	USE FROM Physical_unit_design_view_mim;	-- ISO/TS 10303-1728
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N7026 - ISO/TS 10303-1730 Physical unit shape with parameters - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6523
*)


SCHEMA Physical_unit_shape_with_parameters_mim;
USE FROM Shape_parameters_mim;	-- ISO/TS 10303-1743
USE FROM Physical_unit_usage_view_mim;	-- ISO/TS 10303-1732
	
  TYPE puswp_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
    (shape_representation);
  END_TYPE;
	
  TYPE puswp_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (shape_representation);
  END_TYPE; 
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N7029 - ISO/TS 10303-1732 Physical unit usage view - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6526
*)


SCHEMA Physical_unit_usage_view_mim;

USE FROM Analytical_model_mim;	-- ISO/TS 10303-1603
USE FROM Feature_and_connection_zone_mim;	-- ISO/TS 10303-1671
USE FROM Item_definition_structure_mim;	-- ISO/TS 10303-1345
USE FROM Part_feature_location_mim;	-- ISO/TS 10303-1714
USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
USE FROM Shape_composition_mim;	-- ISO/TS 10303-1742
USE FROM Part_shape_mim;

USE FROM application_context_schema(application_context_element);
USE FROM material_property_definition_schema(property_definition_relationship);

  TYPE puuv_groupable_item = SELECT BASED_ON groupable_item WITH 
    (shape_aspect);
  END_TYPE; 

  TYPE puuv_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (product_definition,
    shape_aspect);
  END_TYPE;

  TYPE puuv_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (shape_aspect);
  END_TYPE;
	
  ENTITY connection_zone_map_identification
    SUBTYPE OF (shape_aspect,representation_relationship);
      SELF\representation_relationship.rep_1 : usage_view_connection_zone_terminal_shape_relationship;
      SELF\representation_relationship.rep_2 : usage_view_connection_zone_terminal_shape_relationship;
    WHERE
      WR1: SELF\representation_relationship.rep_2 :<>:
        SELF\representation_relationship.rep_1;
  END_ENTITY; 

  ENTITY make_from_part_feature_relationship
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    UNIQUE
      UR1: SELF\shape_aspect_relationship.relating_shape_aspect, 
        SELF\shape_aspect_relationship.related_shape_aspect;
    WHERE
      WR1: SELF\shape_aspect.product_definitional = FALSE;
  END_ENTITY; 

  ENTITY part_feature_template_definition
    SUBTYPE OF (shape_feature_definition, group);
    WHERE
      WR1: SELF\group.name = SELF\characterized_object.name;
      WR2: SELF\group.description = SELF\characterized_object.description;
  END_ENTITY;
	
  ENTITY physical_unit
    SUBTYPE OF (product_definition, product_definition_shape);
    DERIVE
      SELF\property_definition.definition : physical_unit := SELF;
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +'NAME_ATTRIBUTE.NAMED_ITEM')) = 0;
      WR2: NOT EXISTS(SELF\property_definition.description);
  END_ENTITY;

  ENTITY usage_view_connection_zone_terminal_shape_relationship
    SUBTYPE OF (representation, representation_relationship_with_transformation);
      SELF\representation_relationship.rep_1 : shape_representation;
      SELF\representation_relationship.rep_2 : shape_representation;    
    UNIQUE
      UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
    WHERE
      WR1: SELF\representation_relationship.rep_1 <> 
        SELF\representation_relationship.rep_2;
  END_ENTITY; 

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6253 - ISO/TS 10303-1308 Picture representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5453
*)

SCHEMA Picture_representation_mim;

USE FROM Binary_representation_mim; -- ISO/TS 10303-1369
USE FROM External_item_identification_assignment_mim; -- ISO/TS 10303-1128
USE FROM Presentation_hierarchy_mim; -- ISO/TS 10303-1330

USE FROM presentation_organization_schema 
  (presentation_area, 
  presentation_size,
  area_in_set) ;

USE FROM presentation_resource_schema (planar_box);

USE FROM geometry_schema (axis2_placement_2d);
  
  CONSTANT 
    pre_defined_picture_representation_types : SET [0:?] OF STRING := [ 'JPEG', 'PNG', 'TIFF', 'BMP', 'GIF']; 
  END_CONSTANT;  

  TYPE picture_representation_item_select = SELECT (
    styled_item,
    planar_box,
    axis2_placement_2d); 
  END_TYPE; 

  TYPE pr_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH  
    (externally_defined_picture_representation_item);
  END_TYPE;

  ENTITY externally_defined_picture_representation_item 
    SUBTYPE OF (picture_representation_item); 
    INVERSE 
      source : applied_external_identification_assignment FOR items; 
    WHERE 
      WR1: NOT (SELF\representation_item.name IN pre_defined_picture_representation_types); 
  END_ENTITY; 

  ENTITY picture_representation
    SUBTYPE OF (presentation_view);
      SELF\representation.items : SET[2:?] OF picture_representation_item_select;
    INVERSE
      size : presentation_size FOR unit;
  WHERE
    WR1: SIZEOF(QUERY(item <* items | 
        'PICTURE_REPRESENTATION_MIM.STYLED_ITEM' IN TYPEOF(item))) = 1;
    WR2: SIZEOF (QUERY (se <* QUERY (item <* SELF.items 
                   | ('PICTURE_REPRESENTATION_MIM.STYLED_ITEM' IN TYPEOF (item))) 
         | NOT ('PICTURE_REPRESENTATION_MIM.PICTURE_REPRESENTATION_ITEM' 
                IN TYPEOF (se\styled_item.item)) )) = 0;
  END_ENTITY;
 
  ENTITY picture_representation_item 
    ABSTRACT SUPERTYPE OF (ONEOF(externally_defined_picture_representation_item, predefined_picture_representation_item))
    SUBTYPE OF (bytes_representation_item);
  END_ENTITY; 
 
  ENTITY predefined_picture_representation_item 
    SUBTYPE OF (picture_representation_item); 
    WHERE 
      WR1: SELF\representation_item.name IN pre_defined_picture_representation_types; 
  END_ENTITY; 
 
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N4147 - ISO/TS 10303-1733 Planned characteristic - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3544
*)


SCHEMA Planned_characteristic_mim;
	USE FROM Production_rule_mim;	-- ISO/TS 10303-1739
	
	USE FROM Requirement_assignment_mim;	-- ISO/TS 10303-1233
	
	USE FROM Representation_schema(representation_relationship_with_transformation);
	
ENTITY evaluated_characteristic
  SUBTYPE OF (representation, representation_relationship);
UNIQUE
  UR1: SELF\representation_relationship.rep_1, SELF\representation_relationship.rep_2;
WHERE
  WR1: SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
END_ENTITY; 

ENTITY evaluation_product_definition
 SUBTYPE OF (product_definition);
END_ENTITY;
	
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N5456 - ISO/TS 10303-1291 Plib class reference - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4841
*) 


SCHEMA Plib_class_reference_mim;

USE FROM External_class_mim;    -- ISO/TS 10303-1275

USE FROM External_item_identification_assignment_mim;    -- ISO/TS 10303-1128

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM external_reference_schema   -- ISO 10303-41
  (external_source,
   pre_defined_item); 

  TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH 
    (externally_defined_class);
  END_TYPE; 

  TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH 
    (class);
  END_TYPE; 

  ENTITY known_source
    SUBTYPE OF (external_source, pre_defined_item);
  END_ENTITY;

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N5459 - ISO/TS 10303-1772 Ply orientation specification - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4781
*)

SCHEMA Ply_orientation_specification_mim;

USE FROM Part_and_zone_laminate_tables_mim; -- ISO/CD-TS 10303-1770

USE FROM geometry_schema (point);

USE FROM representation_schema(
  compound_representation_item,
  representation_item_relationship);

  TYPE angle_direction_reference_select = SELECT (
    direction,
    curve,
    point_path);
  END_TYPE;

  TYPE angle_direction_reference_with_a2p3d_select = SELECT (
    angle_direction_reference_select,
    axis2_placement_3d);
  END_TYPE;

  TYPE orientation_basis_select = SELECT (
    axis2_placement_3d,
    min_and_major_ply_orientation_basis);
  END_TYPE;

  TYPE point_and_vector_member = SELECT (point, direction);
  END_TYPE;
  
  TYPE point_and_vector_members = LIST [2:3] OF point_and_vector_member;
  END_TYPE;

  TYPE point_path_members = LIST [1:?] OF point_and_vector;
  END_TYPE;

  ENTITY angle_direction_reference
    SUBTYPE OF (representation_item_relationship, geometric_representation_item);
      SELF\representation_item_relationship.relating_representation_item : orientation_basis_select;
      SELF\representation_item_relationship.related_representation_item  : angle_direction_reference_select;
    WHERE
      WR1: ((('PLY_ORIENTATION_SPECIFICATION_MIM.POINT_PATH' IN TYPEOF(related_representation_item)) AND
        ('PLY_ORIENTATION_SPECIFICATION_MIM.MIN_AND_MAJOR_PLY_ORIENTATION_BASIS' IN TYPEOF(relating_representation_item))) 
        OR
		(NOT('PLY_ORIENTATION_SPECIFICATION_MIM.POINT_PATH' IN TYPEOF(related_representation_item)) AND
        ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF(relating_representation_item))));
  END_ENTITY;

  ENTITY draped_defined_transformation
    SUBTYPE OF (transformation_with_derived_angle);
  END_ENTITY;

  ENTITY laid_defined_transformation
    SUBTYPE OF (transformation_with_derived_angle);
  END_ENTITY;

  ENTITY min_and_major_ply_orientation_basis
    SUBTYPE OF (representation_item_relationship, geometric_representation_item);
      SELF\representation_item_relationship.relating_representation_item RENAMED minor_orientation_basis : axis2_placement_3d;
      SELF\representation_item_relationship.related_representation_item RENAMED major_orientation_basis  : axis2_placement_3d;
  END_ENTITY;

  ENTITY point_and_vector
    SUBTYPE OF (compound_representation_item, geometric_representation_item);
      SELF\compound_representation_item.item_element : point_and_vector_members;
  END_ENTITY;

  ENTITY point_path
    SUBTYPE OF (compound_representation_item, geometric_representation_item);
      SELF\compound_representation_item.item_element : point_path_members;
  END_ENTITY;

  ENTITY transformation_with_derived_angle
    SUPERTYPE OF (ONEOF (draped_defined_transformation, 
                         laid_defined_transformation))
    SUBTYPE OF (item_defined_transformation);
      SELF\item_defined_transformation.transform_item_1 : angle_direction_reference_with_a2p3d_select;
      SELF\item_defined_transformation.transform_item_2 : axis2_placement_3d;
    DERIVE
      orientation_angle : plane_angle_measure := derive_angle (
        SELF\item_defined_transformation.transform_item_1,
        SELF\item_defined_transformation.transform_item_2);
    WHERE
      WR1: (SELF\item_defined_transformation.transform_item_1\
            axis2_placement_3d.p[3].direction_ratios[1] =
            SELF\item_defined_transformation.transform_item_2\
            axis2_placement_3d.p[3].direction_ratios[1])
          AND
           (SELF\item_defined_transformation.transform_item_1\
            axis2_placement_3d.p[3].direction_ratios[2] =
            SELF\item_defined_transformation.transform_item_2\
            axis2_placement_3d.p[3].direction_ratios[2])
          AND
           (SELF\item_defined_transformation.transform_item_1\
            axis2_placement_3d.p[3].direction_ratios[3] =
            SELF\item_defined_transformation.transform_item_2\
            axis2_placement_3d.p[3].direction_ratios[3]);  
  END_ENTITY;

  SUBTYPE_CONSTRAINT pos_compound_representation_item_subtypes FOR compound_representation_item;         
    ONEOF (point_and_vector,
	  point_path);    
  END_SUBTYPE_CONSTRAINT;

  FUNCTION derive_angle (placement_1 : axis2_placement_3d;
                         placement_2 : axis2_placement_3d) :
                         plane_angle_measure;
    LOCAL
      v1     : direction;
      v2     : direction;
      mag_v1 : REAL;
      mag_v2 : REAL;
      theta  : plane_angle_measure;
    END_LOCAL;
    v1 := placement_1.p[1];
    v2 := placement_2.p[1];
    mag_v1 := SQRT (v1.direction_ratios[1]*v1.direction_ratios[1] +
                    v1.direction_ratios[2]*v1.direction_ratios[2]);
    mag_v2 := SQRT (v2.direction_ratios[1]*v2.direction_ratios[1] +
                    v2.direction_ratios[2]*v2.direction_ratios[2]);
    IF ((mag_v1 = 0.0) OR (mag_v2 = 0.0)) THEN
      theta := 0.0;
      RETURN (theta);
    END_IF;
    theta := ACOS ((v1.direction_ratios[1]*v2.direction_ratios[1] +
                    v1.direction_ratios[2]*v2.direction_ratios[2]) /
                   (mag_v1*mag_v2));
    RETURN (theta);
  END_FUNCTION; 

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- point_direction_model - EXPRESS MIM
*)

SCHEMA Point_direction_model_mim;

USE FROM Elemental_geometric_shape_mim;
USE FROM representation_schema(compound_representation_item);

TYPE point_placement_shape_representation_item = SELECT (
  compound_representation_item,
  mapped_item,
  axis2_placement_3d);
END_TYPE;  

ENTITY point_placement_shape_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET[1:?] OF point_placement_shape_representation_item;
WHERE
  WR1:  SIZEOF( QUERY( i <* SELF.items |
                SIZEOF(['REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM',
                        'REPRESENTATION_SCHEMA.MAPPED_ITEM']
                       * TYPEOF(i)) = 1
              )) > 0;
END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6529 - ISO/TS 10303-1735 Pre defined datum 2d symbol - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5798
*)


SCHEMA Pre_defined_datum_2d_symbol_mim;
--	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051

	USE FROM Layered_2d_shape_mim;	-- ISO/TS 10303-1693
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6532 - ISO/TS 10303-1736 Pre defined datum 3d symbol - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5801
*)


SCHEMA Pre_defined_datum_3d_symbol_mim;
--	USE FROM Extended_geometric_tolerance_mim;	-- ISO/TS 10303-1666
	USE FROM Geometric_tolerance_mim;	-- ISO/TS 10303-1051

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6535 - ISO/TS 10303-1734 Pre defined datum symbol - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5795
*)


SCHEMA Pre_defined_datum_symbol_mim;
	USE FROM Layered_3d_shape_mim;	-- ISO/TS 10303-1694
	USE FROM Pre_defined_datum_2d_symbol_mim;	-- ISO/TS 10303-1735
	USE FROM Pre_defined_datum_3d_symbol_mim;	-- ISO/TS 10303-1736

SUBTYPE_CONSTRAINT pdds_shape_definition_3d_intersection_subtypes FOR shape_definition_3d_intersection;         
  (ONEOF (pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,
          pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,
          pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship));
END_SUBTYPE_CONSTRAINT;        
	
ENTITY pre_defined_parallel_datum_axis_symbol_3d_2d_relationship
  SUBTYPE OF (shape_definition_3d_intersection);
END_ENTITY; 

ENTITY pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship
  SUBTYPE OF (shape_definition_3d_intersection);
END_ENTITY; 

ENTITY pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship
  SUBTYPE OF (shape_definition_3d_intersection);
END_ENTITY; 
	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N5547 - ISO/TS 10303-1760 Pre defined product data management specializations - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5001
*)
SCHEMA Pre_defined_product_data_management_specializations_mim;

USE FROM Activity_mim; -- ISO/TS 10303-1047
USE FROM Approval_mim; -- ISO/TS 10303-1012
USE FROM External_item_identification_assignment_mim; -- ISO/TS 10303-1128
USE FROM Person_organization_assignment_mim; -- ISO/TS 10303-1013
USE FROM Security_classification_mim; -- ISO/TS 10303-1015
USE FROM Work_request_mim; -- ISO/TS 10303-1042

  TYPE pdpdms_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH
    (person_and_organization);
  END_TYPE;

  TYPE pdpdms_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH
    (action_relationship,
    action_request_status,
    applied_organization_assignment,
    applied_person_and_organization_assignment,
    approval,
    approval_status,
    date_assignment,
    date_and_time_assignment,
    organizational_address,
    security_classification,
    versioned_action_request);
  END_TYPE;

END_SCHEMA;
(*
	ISO TC184/SC4/WG12 N5462 - ISO/TS 10303-1330 Presentation hierarchy - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N4784
*)

SCHEMA Presentation_hierarchy_mim;

USE FROM Appearance_assignment_mim;  -- ISO/CD-TS 10303-1001

USE FROM Contextual_shape_positioning_mim; -- ISO/TS 10303-1027

USE FROM presentation_organization_schema    --  ISO 10303-46
  (area_in_set,
  presentation_view,
  presentation_area,
  presented_item,
  presentation_set,
  presentation_size,  
  presented_item_representation);

USE FROM representation_schema    --  ISO 10303-43
  (representation_relationship);


  TYPE presented_item_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  ENTITY applied_presented_item
    SUBTYPE OF (presented_item);
      items : SET[1:?] OF presented_item_select;
  END_ENTITY;

END_SCHEMA;
(*
  ISO TC184/SC4/WG12 N6918 - ISO/TS 10303-1791 Primitive solids - EXPRESS MIM
*)

SCHEMA Primitive_solids_mim;

USE FROM Basic_geometry_mim; -- ISO/TS 10303-1652

USE FROM geometric_model_schema -- ISO 10303-42
             (block,
              right_circular_cone,
              right_circular_cylinder,
              sphere,
              torus);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7032 - ISO/TS 10303-1737 Printed physical layout template - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6538
*)


SCHEMA Printed_physical_layout_template_mim;
USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705
USE FROM Layered_interconnect_complex_template_mim; -- ISO/TS 10303-1716	

  TYPE pplt_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
    (printed_part_template_terminal);
  END_TYPE;

  SUBTYPE_CONSTRAINT pplt_part_template_definition_subtypes FOR part_template_definition; 
    ONEOF (Printed_part_template,
      Non_conductive_cross_section_template);
  END_SUBTYPE_CONSTRAINT;

  ENTITY basic_multi_stratum_printed_part_template 
    SUBTYPE OF (printed_part_template);
  END_ENTITY;

  ENTITY multi_stratum_printed_part_template
    SUBTYPE OF (structured_printed_part_template, multi_stratum_structured_template);
  END_ENTITY;

  ENTITY non_conductive_cross_section_template
    SUBTYPE OF (part_template_definition);
  END_ENTITY;

  ENTITY printed_connector_template
    SUBTYPE OF (printed_part_template);
  END_ENTITY;
	
  ENTITY printed_connector_template_terminal_relationship
    SUBTYPE OF (shape_aspect, shape_aspect_relationship);
    UNIQUE
      UR1: SELF\shape_aspect_relationship.relating_shape_aspect,
        SELF\shape_aspect_relationship.related_shape_aspect;
    WHERE
      WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>:
        SELF\shape_aspect_relationship.related_shape_aspect;
  END_ENTITY;

  ENTITY printed_part_cross_section_template
    SUBTYPE OF (printed_part_template);
  END_ENTITY;

  ENTITY printed_part_cross_section_template_terminal
    SUBTYPE OF (printed_part_template_terminal);
  END_ENTITY;

  ENTITY printed_part_template
    ABSTRACT SUPERTYPE OF (ONEOF (basic_multi_stratum_printed_part_template,
      structured_printed_part_template) ANDOR printed_connector_template)
    SUBTYPE OF (part_template_definition);
  END_ENTITY;

  ENTITY printed_part_template_connected_terminals_definition
    SUBTYPE OF (shape_aspect);
    UNIQUE
      UR1: SELF\shape_aspect.name;
  END_ENTITY;

  ENTITY printed_part_template_material
    SUBTYPE OF (product_definition);
  END_ENTITY;

  ENTITY printed_part_template_material_link
    SUBTYPE OF (shape_aspect,shape_aspect_relationship);
      SELF\shape_aspect_relationship.relating_shape_aspect : template_material_cross_section_boundary;  
      SELF\shape_aspect_relationship.related_shape_aspect  : template_material_cross_section_boundary;
    UNIQUE
      UR1: SELF\shape_aspect_relationship.related_shape_aspect, 
        SELF\shape_aspect_relationship.relating_shape_aspect;
    WHERE
      WR1: SELF\shape_aspect_relationship.related_shape_aspect :<>:
        SELF\shape_aspect_relationship.relating_shape_aspect;
  END_ENTITY; 

  ENTITY printed_part_template_terminal
    SUPERTYPE OF (printed_part_cross_section_template_terminal ANDOR structured_printed_part_template_terminal)
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY printed_part_template_terminal_connection_zone_category
    SUBTYPE OF (group);
  END_ENTITY;

  ENTITY printed_tiebar_template
    SUBTYPE OF (structured_printed_part_template);
  END_ENTITY;

  ENTITY single_stratum_printed_part_template
    SUBTYPE OF (structured_printed_part_template, single_stratum_structured_template);
  END_ENTITY;
  
  ENTITY structured_printed_part_template
    ABSTRACT SUPERTYPE OF (ONEOF (single_stratum_printed_part_template, 
      multi_stratum_printed_part_template))
    SUBTYPE OF (printed_part_template, structured_template);
  END_ENTITY;  

  ENTITY structured_printed_part_template_terminal
    SUBTYPE OF (printed_part_template_terminal);
  END_ENTITY;  

  ENTITY template_material_cross_section_boundary
    SUBTYPE OF (shape_aspect);
  END_ENTITY;
	
END_SCHEMA;


(*
  ISO TC184/SC4/WG12 N5465 - ISO/TS 10303-1317 Procedural shape model - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4787
*)

SCHEMA Procedural_shape_model_mim;

USE FROM Elemental_geometric_shape_mim; -- ISO/CD-TS 10303-1004

USE FROM Elemental_topology_mim; -- ISO/TS 10303-1005

USE FROM procedural_model_schema  -- ISO 10303-55 
    (explicit_procedural_representation_relationship);

USE FROM procedural_shape_model_schema  -- ISO 10303-55 
    (explicit_procedural_geometric_representation_item_relationship,
    explicit_procedural_shape_representation_relationship,
    indirectly_selected_shape_elements,
    procedural_shape_representation,
    procedural_shape_representation_sequence,
    shape_representation_item,
    user_selected_shape_elements);
        
END_SCHEMA;

(*
  ISO TC184/SC4/WG12 N5468 - ISO/TS 10303-1318 Procedural solid model - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4790
*)

SCHEMA Procedural_solid_model_mim;

USE FROM Procedural_shape_model_mim;  -- ISO/CD-TS 10303-1317

USE FROM geometric_model_schema  -- ISO 10303-42 
      (solid_model,
      csg_primitive,
      boolean_result);

USE FROM solid_shape_element_schema  -- ISO 10303-111 
    (modified_solid,
     base_solid_select);
            
END_SCHEMA;

(*
   N - ISO/CD-TS - 10303- process_plan - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Process_plan_mim;

USE FROM Activity_method_mim; -- ISO/TS 10303-1049
USE FROM Product_view_definition_mim; -- ISO/TS 10303-1019
USE FROM Support_resource_mim; -- ISO/TS 10303-1800
USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032
USE FROM Specification_control_mim; -- ISO/TS 10303-1112
USE FROM Item_definition_structure_mim; -- ISO/TS 10303-1345

USE FROM action_schema (   -- ISO 10303-41
   action,
--   action_method,
   action_method_relationship,
   action_resource);
   
USE FROM process_property_representation_schema   -- ISO 10303-49
  (action_property_representation,
   resource_property_representation);

USE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   action_resource_requirement,
   process_product_association,
   process_property_association,
   product_definition_process,
   property_process,
   requirement_for_action_resource,
   resource_property,
   resource_requirement_type);

ENTITY process_operation
  SUBTYPE OF (action_method);
WHERE
  WR1:  SIZEOF( QUERY( amr <* USEDIN(SELF,'ACTION_SCHEMA.ACTION_METHOD_RELATIONSHIP.' +
                     'RELATING_METHOD') |
               NOT('PROCESS_PLAN_MIM.PROCESS_OPERATION' IN
                   TYPEOF(amr\action_method_relationship.related_method)) OR
               (SELF :=: amr\action_method_relationship.related_method)
              )) = 0;	   
  WR2:  SIZEOF( QUERY( amr <* USEDIN(SELF,'ACTION_SCHEMA.ACTION_METHOD_RELATIONSHIP.' +
                     'RELATED_METHOD') |
               NOT('PROCESS_PLAN_MIM.PROCESS_OPERATION' IN
                   TYPEOF(amr\action_method_relationship.relating_method)) OR
               (SELF :=: amr\action_method_relationship.relating_method)
              )) = 0;   
END_ENTITY;

ENTITY process_plan
  SUBTYPE OF (action);
WHERE
  WR1:  SIZEOF( QUERY( ar <* USEDIN(SELF,'ACTION_SCHEMA.' +
                      'ACTION_RELATIONSHIP.RELATED_ACTION') |
               SIZEOF(['PROCESS_PLAN_MIM.PROCESS_PLAN',
                       'PROCESS_PLAN_MIM.PRODUCT_PROCESS_PLAN'] *
                       TYPEOF(ar.relating_action)) <> 1
              )) = 0;
           
  WR2:  SIZEOF( QUERY( ar <* USEDIN(SELF,'ACTION_SCHEMA.' +
                      'ACTION_RELATIONSHIP.RELATING_ACTION') |
               (SIZEOF(['PROCESS_PLAN_MIM.PROCESS_PLAN',
                        'PROCESS_PLAN_MIM.PRODUCT_PROCESS_PLAN'] *
                        TYPEOF(ar.related_action)) = 1) OR
               ((ar.name = 'process operation occurrence') AND
                ('PROCESS_PLAN_MIM.PROCESS_OPERATION' IN
                 TYPEOF(ar.related_action.chosen_method)))
              )) = 
             SIZEOF(USEDIN(SELF,'ACTION_SCHEMA.' +
                    'ACTION_RELATIONSHIP.RELATING_ACTION'));   
END_ENTITY;

ENTITY product_definition_resource
  SUBTYPE OF (action_resource,product_definition);
WHERE
  WR1:  SIZEOF( USEDIN(SELF,'PROCESS_PROPERTY_SCHEMA.' +
               'REQUIREMENT_FOR_ACTION_RESOURCE.RESOURCES')
               ) > 0;
           
  WR2:  SELF.frame_of_reference.name IN 
        ['part_definition','part occurrence','physical occurrence'];
           
END_ENTITY;

ENTITY product_process_plan
  SUBTYPE OF (product_definition_process);
WHERE
  WR1:  SIZEOF( QUERY( ar <* USEDIN(SELF,'ACTION_SCHEMA.' +
                     'ACTION_RELATIONSHIP.RELATED_ACTION') |
               SIZEOF(['PROCESS_PLAN_MIM.PROCESS_PLAN',
                       'PROCESS_PLAN_MIM.PRODUCT_PROCESS_PLAN'] *
                       TYPEOF(ar.relating_action)
                ) <> 1
              )) = 0;
           
  WR2:  SIZEOF( QUERY( ar <* USEDIN(SELF,'ACTION_SCHEMA.' +
                      'ACTION_RELATIONSHIP.RELATING_ACTION') |
               (SIZEOF(['PROCESS_PLAN_MIM.PROCESS_PLAN',
                        'PROCESS_PLAN_MIM.PRODUCT_PROCESS_PLAN'] *
                        TYPEOF(ar.related_action)) = 1) OR
               ((ar.name = 'process operation occurrence') AND
                ('PROCESS_PLAN_MIM.PROCESS_OPERATION' IN
                 TYPEOF(ar.related_action.chosen_method)))
              )) = 
             SIZEOF(USEDIN(SELF,'ACTION_SCHEMA.' +
                    'ACTION_RELATIONSHIP.RELATING_ACTION'));   
  WR3:  SIZEOF( QUERY( ppa <* USEDIN(SELF,'PROCESS_PROPERTY_SCHEMA.' +
                     'PROCESS_PRODUCT_ASSOCIATION.PROCESS') |
               (ppa.name <> 'produced output') OR
               NOT('PROCESS_PLAN_MIM.PRODUCT_DEFINITION' IN
                   TYPEOF(ppa.defined_product))
              )) = 0;
           
END_ENTITY;


END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N5471 - ISO/TS 10303-1040 Process property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4953
*)

SCHEMA Process_property_assignment_mim; 

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM process_property_representation_schema   -- ISO 10303-49
  (action_property_representation); 

USE FROM process_property_schema   -- ISO 10303-49
  (action_property,
   characterized_action_definition); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (derived_property_select,
   general_property_association); 


END_SCHEMA; 
(*
   N - ISO/CD-TS - 10303- product_and_manufacturing_annotation_presentation - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Product_and_manufacturing_annotation_presentation_mim;

USE FROM Product_and_manufacturing_information_with_nominal_3d_models_mim;

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- product_and_manufacturing_information_view_context - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Product_and_manufacturing_information_view_context_mim;

USE FROM Part_view_definition_mim; -- ISO/TS 10303-1023
USE FROM Document_assignment_mim; -- ISO/TS 10303-1122

TYPE pamivc_document_reference_item = SELECT BASED_ON document_reference_item WITH (
  product_definition_context);
END_TYPE;

RULE valid_product_and_manufacturing_information_view_contexts FOR (product_definition_context);
LOCAL
  design_view_contexts : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.life_cycle_stage = 'design');
  gdt_representation_view_contexts : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.frame_of_reference.application = 'geometrical dimensioning and tolerancing representation');
  machining_feature_view_contexts : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.frame_of_reference.application = 'machining feature');
  material_specification_view_contexts : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.frame_of_reference.application = 'material specification');
  model_based_3d_annotation_presentation_view_contexts  : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.frame_of_reference.application = 'model based 3D annotation presentation');
  model_based_view_contexts : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.frame_of_reference.application = 'model based product geometry');
  process_state_view_contexts : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.frame_of_reference.application = 'process state');
  surface_finish_view_contexts : SET OF product_definition_context :=
    QUERY( pdc <* product_definition_context | pdc.frame_of_reference.application = 'surface finish');
  additional_view_contexts : SET OF product_definition_context :=
         gdt_representation_view_contexts + machining_feature_view_contexts + material_specification_view_contexts +
         model_based_3d_annotation_presentation_view_contexts + process_state_view_contexts + surface_finish_view_contexts;
  need_initial_model_based_view_contexts : SET OF product_definition_context :=
    gdt_representation_view_contexts + model_based_3d_annotation_presentation_view_contexts;
END_LOCAL;

WHERE
  WR1: gdt_representation_view_contexts IN design_view_contexts;
  WR2: machining_feature_view_contexts IN design_view_contexts;
  WR3: material_specification_view_contexts IN design_view_contexts;
  WR4: model_based_3d_annotation_presentation_view_contexts IN design_view_contexts;
  WR5: model_based_view_contexts IN design_view_contexts;
  WR6: process_state_view_contexts IN design_view_contexts;
  WR7: surface_finish_view_contexts IN design_view_contexts;
  WR8: -- not used as additional_contexts
       SIZEOF( USEDIN(model_based_view_contexts, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.FRAME_OF_REFERENCE') = 0);
  WR9: -- not used as initial_context
       SIZEOF( USEDIN(additional_view_contexts, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FRAME_OF_REFERENCE') = 0);
  WR10: -- initial_context shall have a Model_based_view_context
       SIZEOF( QUERY(pdca <* 
          USEDIN(need_initial_model_based_view_contexts, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.FRAME_OF_REFERENCE')
          | NOT(pdca.definition.frame_of_reference IN model_based_view_contexts))) = 0;
  WR11: TRUE; -- gdt_representation_view_contexts must have at least either ISO 1101 or ASME Y14.5 as associated dimension standard document          
  WR12: TRUE; -- model_based_3d_annotation_presentation_view_contexts must have at least either ISO 1101, ISO 16792, ASME Y14.41 or ASME Y14.5 as associated model standard document
END_RULE;

END_SCHEMA;
(*
   N - ISO/CD-TS - 10303- product_and_manufacturing_information_with_nominal_3d_models - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Product_and_manufacturing_information_with_nominal_3d_models_mim;

USE FROM Product_and_manufacturing_information_view_context_mim;
USE FROM Shape_property_assignment_mim; -- ISO/TS 10303-1032
USE FROM Advanced_boundary_representation_mim; -- ISO/TS 10303-1514
USE FROM Manifold_surface_mim; -- ISO/TS 10303-1509
USE FROM Manifold_subsurface_mim; -- ISO/TS 10303-1702
USE FROM Construction_geometry_mim; -- ISO/TS 10303-1131

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7269 - ISO/TS 10303-1164 Product as individual - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6828
*) 


SCHEMA Product_as_individual_mim;

USE FROM Configuration_item_mim; -- ISO/TS 10303-1056

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_definition,
   product_definition_formation,
   product_definition_formation_relationship,
   product_definition_relationship,
   product_related_product_category,
   product_relationship); 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

TYPE product_as_individual_identification_item = SELECT BASED_ON identification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

ENTITY product_design_version_to_individual
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED individual_product : product_definition_formation;
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED product_design_version : product_definition_formation;
END_ENTITY;

ENTITY product_design_to_individual
  SUBTYPE OF (product_relationship);
  SELF\product_relationship.related_product RENAMED individual_product : product;
  SELF\product_relationship.relating_product RENAMED product_design : product;
END_ENTITY;

ENTITY product_planned_to_realized
  SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.relating_product_definition_formation RENAMED planned_product : product_definition_formation;
  SELF\product_definition_formation_relationship.related_product_definition_formation RENAMED realized_product : product_definition_formation;
END_ENTITY;

ENTITY product_as_planned
  SUBTYPE OF (product_definition_formation);
END_ENTITY;

END_SCHEMA;  -- Product_as_individual_mim

(*
   N - ISO/CD-TS - 10303- product_as_individual_assembly_and_test - EXPRESS MIM*)
(* UNDER DEVELOPMENT *)
SCHEMA Product_as_individual_assembly_and_test_mim;
USE FROM Product_as_individual_mim; -- ISO/TS 10303-1164
USE FROM Property_assignment_mim; -- ISO/TS 10303-1030
USE FROM Process_plan_mim;
USE FROM Activity_mim; -- ISO/TS 10303-1047

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N5474 - ISO/TS 10303-1248 Product breakdown - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4799
*) 


SCHEMA Product_breakdown_mim;

USE FROM group_schema(group);    -- ISO 10303-41

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_relationship); 

USE FROM product_property_definition_schema(characterized_object);    -- ISO 10303-41

USE FROM product_structure_schema   -- ISO 10303-44
  (product_definition_usage); 

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030


  TYPE product_definition_or_breakdown_element_usage = EXTENSIBLE GENERIC_ENTITY SELECT
    (product_definition_usage, 
     product_definition);
  END_TYPE; 

  TYPE product_definition_or_product_definition_relationship = EXTENSIBLE GENERIC_ENTITY SELECT
    (product_definition, 
     product_definition_usage);
  END_TYPE; 

  ENTITY breakdown_context
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY breakdown_element_group_assignment
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : product_definition_element_relationship;
      items : SET[1:1] OF product_definition_or_breakdown_element_usage;
  END_ENTITY;

  ENTITY breakdown_element_realization
    SUBTYPE OF (characterized_object, product_definition_element_relationship);
  END_ENTITY;

  ENTITY breakdown_element_usage
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY breakdown_of
    SUBTYPE OF (product_definition_relationship);
  END_ENTITY;

  ENTITY product_definition_element_relationship
    SUBTYPE OF (group);
  END_ENTITY;

  ENTITY product_definition_group_assignment
    SUBTYPE OF (group_assignment);
    SELF\group_assignment.assigned_group : product_definition_element_relationship;
    items : SET[1:1] OF product_definition_or_product_definition_relationship;
  END_ENTITY;

END_SCHEMA; 




(*
 ISO TC184/SC4/WG12 N6256 - ISO/TS 10303-1103 Product class - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5477
*)

SCHEMA Product_class_mim;

USE FROM Identification_assignment_mim;

USE FROM Product_concept_identification_mim;

USE FROM Group_mim;

USE FROM basic_attribute_schema (
  object_role);

USE FROM product_concept_schema(
  conditional_concept_feature,
  product_concept_relationship,
  product_concept_feature,
  product_concept_feature_association,
  concept_feature_operator);

USE FROM product_property_definition_schema(
  characterized_object);

TYPE category_usage_item = SELECT (product_class);
END_TYPE;

TYPE id_for_class = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
  product_class, 
  product_concept_feature);
END_TYPE;

TYPE specification_for_category = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
  package_product_concept_feature,
  product_concept_feature);
END_TYPE;

ENTITY exclusive_product_concept_feature_category
  SUBTYPE OF (product_concept_feature_category);
END_ENTITY;

ENTITY inclusion_product_concept_feature
	SUBTYPE OF (conditional_concept_feature);
	WHERE
		WR1: NOT ( 'PRODUCT_CLASS_MIM.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
		WR2: SIZEOF (QUERY( cfr <* USEDIN( SELF ,'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) | 
						'PRODUCT_CONCEPT_SCHEMA.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) 
			 )) + 
			 SIZEOF(QUERY( cfr <* USEDIN(SELF , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) | 
						'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)
			)) = 0;
		WR3: SELF.condition.conditional_operator.name = 'implication';
END_ENTITY;

ENTITY package_product_concept_feature
	SUBTYPE OF (product_concept_feature);
WHERE
	WR1: NOT ( 'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
	WR2: SIZEOF ( QUERY ( cfr <* USEDIN ( SELF , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) | 
		        ('PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) AND 
			    (SIZEOF ( QUERY (ipcf <* USEDIN ( cfr , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE.' + 'CONDITION' ) | 
				 'PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) 
			     )) = 1)
		)) > 0;
END_ENTITY;
					
ENTITY product_class
  SUBTYPE OF (product_concept,characterized_object);
END_ENTITY;

ENTITY product_concept_feature_category
  SUBTYPE OF (group);
WHERE
	WR1 : SIZEOF(QUERY(aga <* USEDIN( SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) |
           ('GROUP_MIM.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) AND
           (( aga\group_assignment.role\object_role.name <> 'specification category member' ) OR 
            ( SIZEOF(QUERY (i <* aga\applied_group_assignment.items | ('PRODUCT_CONCEPT_SCHEMA.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) AND 
             NOT ('PRODUCT_CONCEPT_SCHEMA.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i)))) <> SIZEOF (aga\applied_group_assignment.items)
              ))
          )) =0;
END_ENTITY;

ENTITY product_concept_feature_category_usage
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_concept_feature_category;
  items : SET [1:?] OF category_usage_item;
WHERE
WR1 : SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ];
END_ENTITY;

RULE restrict_concept_feature_operator FOR (concept_feature_operator);
WHERE
	WR1: SIZEOF ( QUERY ( cfo <* concept_feature_operator | NOT
		( cfo.name IN ['and' , 'or' , 'oneof' , 'not' , 'implication'] ) ) ) = 0;
	WR2: SIZEOF ( QUERY ( cfo <* concept_feature_operator | (cfo.name = 'implication' ) AND
	 ( SIZEOF ( QUERY (cfrwc <* USEDIN ( cfo , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +
	'CONDITIONAL_OPERATOR' ) | 
		SIZEOF ( QUERY ( ccf <* USEDIN( cfrwc , 'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION' ) | 
		NOT ('PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ccf )))) >0 )) >0 ))) = 0;
	WR3: SIZEOF( QUERY (cfo <* concept_feature_operator | (cfo.name = 'not')
	AND (SIZEOF(QUERY(cfrwc <* USEDIN(cfo, 'PRODUCT_CONCEPT_SCHEMA.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR') | 
		cfrwc.related_product_concept_feature :<>: cfrwc.relating_product_concept_feature)) >0 ))) = 0;
END_RULE;	

RULE restrict_group_relationship_for_specification_category FOR (group_relationship); 
WHERE 
WR1 : SIZEOF( QUERY( gr <* group_relationship | 
  (gr.name = 'specification category hierarchy') AND 
  (NOT('PRODUCT_CLASS_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.related_group)) 
  OR NOT('PRODUCT_CLASS_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group))) )) = 0; 
END_RULE; 

RULE product_concept_feature_requires_category FOR (product_concept_feature);
WHERE
WR1: SIZEOF ( QUERY ( pcf <* product_concept_feature |
(SIZEOF(['PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',
'PRODUCT_CONCEPT_SCHEMA.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf)) = 0) AND 
(SIZEOF ( QUERY ( aga <* USEDIN ( pcf , 'GROUP_MIM.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS' ) | 
(aga\group_assignment.role\object_role.name = 'specification category member' ) AND 
('PRODUCT_CLASS_MIM.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF ( aga.assigned_group )))) <>1 ) ) ) = 0;
END_RULE;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1178 - ISO/TS 10303-1060 Product concept identification - EXPRESS MIM
*)
   
SCHEMA Product_concept_identification_mim;

USE FROM product_concept_schema -- ISO 10303-44
  (product_concept);
USE FROM application_context_schema -- ISO 10303-41
  (product_concept_context);

   
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N6750 - ISO/TS 10303-1231 Product data management - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5480
*) 


SCHEMA Product_data_management_mim;

USE FROM Configuration_effectivity_mim;    -- ISO/TS 10303-1058

USE FROM Document_management_mim;    -- ISO/TS 10303-1290

USE FROM Effectivity_application_mim;    -- ISO/TS 10303-1059

USE FROM External_class_mim;    -- ISO/TS 10303-1275

USE FROM Incomplete_data_reference_mechanism_mim;    -- ISO/TS 10303-1349

USE FROM Independent_property_representation_mim;    -- ISO/TS 10303-1038

USE FROM Process_property_assignment_mim;    -- ISO/TS 10303-1040

USE FROM Product_structure_mim;    -- ISO/TS 10303-1134

USE FROM Product_view_definition_properties_mim;    -- ISO/TS 10303-1034

USE FROM Time_interval_assignment_mim;    -- ISO/TS 10303-1365

USE FROM Work_order_mim;    -- ISO/TS 10303-1043


  TYPE pdm_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
   (configuration_effectivity, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
  END_TYPE; 

  TYPE pdm_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_request_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship, 
    property_definition);
  END_TYPE; 

  TYPE pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
   (action, 
    applied_action_assignment, 
    configuration_effectivity, 
    versioned_action_request);
  END_TYPE; 

  TYPE pdm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    identification_role, 
    object_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
  END_TYPE; 

  TYPE pdm_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
   (product_definition_formation_relationship);
  END_TYPE; 

  TYPE pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
   (action, 
    action_directive, 
    action_method, 
    action_property, 
    action_relationship, 
    action_request_solution, 
    action_request_status, 
    address, 
    alternate_product_relationship, 
    applied_action_assignment, 
    applied_action_request_assignment, 
    applied_approval_assignment, 
    applied_certification_assignment, 
    applied_contract_assignment, 
    applied_date_and_time_assignment, 
    applied_date_assignment, 
    applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_effectivity_assignment, 
    applied_event_occurrence_assignment, 
    applied_external_identification_assignment, 
    applied_identification_assignment, 
    applied_organization_assignment, 
    applied_organizational_project_assignment, 
    applied_person_and_organization_assignment, 
    applied_security_classification_assignment, 
    approval, 
    approval_person_organization, 
    approval_relationship, 
    approval_status, 
    assembly_component_usage_substitute, 
    calendar_date, 
    certification, 
    class, 
    configuration_item, 
    context_dependent_unit, 
    contract, 
    conversion_based_unit, 
    date_and_time, 
    date_and_time_assignment, 
    date_assignment, 
    derived_unit, 
    descriptive_representation_item, 
    directed_action, 
    document_file, 
    document_relationship, 
    effectivity, 
    event_occurrence, 
    executed_action, 
    general_property, 
    general_property_relationship, 
    group, 
    identification_assignment, 
    language, 
    measure_representation_item, 
    measure_with_unit, 
    multi_language_attribute_assignment, 
    named_unit, 
    organization, 
    organization_relationship, 
    organizational_address, 
    organizational_project, 
    organizational_project_relationship, 
    person, 
    person_and_organization_address, 
    product, 
    product_concept, 
    product_definition, 
    product_definition_context, 
    product_definition_formation, 
    product_definition_formation_relationship, 
    product_definition_relationship, 
    property_definition, 
    property_definition_representation, 
    representation, 
    representation_context, 
    representation_item, 
    security_classification, 
    uncertainty_measure_with_unit, 
    versioned_action_request);
  END_TYPE; 

  TYPE pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
   (action, 
    applied_action_assignment, 
    executed_action, 
    versioned_action_request);
  END_TYPE; 

  TYPE pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH 
   (action, 
    applied_action_assignment, 
    versioned_action_request);
  END_TYPE; 

  TYPE pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (action_method, 
    executed_action, 
    product_definition_formation_relationship, 
    shape_aspect, 
    shape_aspect_relationship, 
    versioned_action_request);
  END_TYPE; 

  TYPE pdm_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH 
   (product_definition, 
    product_definition_formation, 
    product_definition_relationship);
  END_TYPE; 

  TYPE pdm_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (organizational_project);
  END_TYPE; 

  TYPE pdm_external_class_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH 
   (assembly_component_usage, 
    external_class_library);
  END_TYPE; 

  TYPE pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (shape_aspect_relationship);
  END_TYPE; 

  TYPE pdm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH 
   (applied_document_reference, 
    applied_document_usage_constraint_assignment, 
    applied_external_identification_assignment, 
    applied_organizational_project_assignment, 
    approval, 
    approval_relationship, 
    approval_status, 
    certification, 
    certification_type, 
    contract, 
    date_role, 
    date_time_role, 
    document_relationship, 
    document_usage_role, 
    external_source, 
    identification_role, 
    object_role, 
    organization_relationship, 
    organizational_project, 
    organizational_project_relationship, 
    organizational_project_role, 
    person_and_organization, 
    product, 
    product_definition, 
    product_definition_formation, 
    product_definition_relationship);
  END_TYPE; 

  TYPE pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (action, 
    applied_action_assignment, 
    approval, 
    configuration_item, 
    contract, 
    executed_action, 
    security_classification, 
    versioned_action_request);
  END_TYPE; 

  TYPE pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (action, 
    applied_action_assignment, 
    approval, 
    configuration_item, 
    contract, 
    executed_action, 
    security_classification, 
    versioned_action_request);
  END_TYPE; 

  TYPE pdm_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH 
   (executed_action, 
    product_concept);
  END_TYPE; 

  TYPE pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH 
   (assembly_component_usage);
  END_TYPE; 

  TYPE pdm_time_interval_item = EXTENSIBLE SELECT BASED_ON time_interval_item WITH 
   (action);
  END_TYPE; 

END_SCHEMA;
(*
   WG12N7179 - ISO/TS 10303-1521 product_data_quality_criteria - EXPRESS MIM
*)
SCHEMA Product_data_quality_criteria_mim;

  USE FROM Foundation_representation_mim;

  USE FROM Product_data_quality_inspection_result_mim;

  USE FROM Product_data_quality_criteria_schema;

END_SCHEMA;
(*
   WG12N7176 - ISO/TS 10303-1520 product_data_quality_definition - EXPRESS MIM
*)

SCHEMA Product_data_quality_definition_mim;

  USE FROM Product_data_quality_criteria_mim;

  USE FROM Product_data_quality_inspection_result_mim;

  USE FROM Product_view_definition_mim;

  USE FROM Date_time_assignment_mim;

  USE FROM Person_organization_assignment_mim;

  USE FROM Product_data_quality_definition_schema;

  TYPE pdq_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH
    (data_quality_definition);
  END_TYPE;

  TYPE pdq_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH
    (data_quality_definition);
  END_TYPE;

  TYPE pdq_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH
    (data_quality_definition);
  END_TYPE;

  TYPE pqd_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH
    (data_quality_definition);
  END_TYPE;


END_SCHEMA;
(*
   WG12N7182 - ISO/TS 10303-1522 product_data_quality_inspection_result - EXPRESS MIM
*)
SCHEMA Product_data_quality_inspection_result_mim;

  USE FROM Foundation_representation_mim;

  USE FROM Product_data_quality_criteria_mim;

  USE FROM Product_data_quality_definition_mim;

  USE FROM Product_view_definition_mim;

  USE FROM Product_data_quality_inspection_result_schema;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6066 - ISO/TS 10303-1017 Product identification - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2926
*) 


SCHEMA Product_identification_mim;

USE FROM product_definition_schema   -- ISO 10303-41
  (product); 


END_SCHEMA;  -- Product_identification_mim
(*
   ISO TC184/SC4/WG12 N4162 - ISO/TS 10303-1738 Product identification extension - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3586
*)


SCHEMA Product_identification_extension_mim;
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128
	USE FROM Product_view_definition_mim;	-- ISO/TS 10303-1019
	
	USE FROM External_reference_schema
		(externally_defined_item,
		external_source);
	
TYPE pie_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (externally_defined_product_definition);
END_TYPE; 

ENTITY externally_defined_product_definition
 SUPERTYPE OF (library_defined_product_definition)
 SUBTYPE OF (product_definition, externally_defined_item);
END_ENTITY;

ENTITY library_defined_product_definition
 SUBTYPE OF (externally_defined_product_definition);
DERIVE
  library : external_source := SELF\externally_defined_item.source;
END_ENTITY;
	
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N4267 - ISO/TS 10303-1063 Product occurrence - EXPRESS MIM
*)

SCHEMA Product_occurrence_mim;

  USE FROM Assembly_structure_mim;	-- ISO/TS 10303-1026
  USE FROM Product_view_definition_relationship_mim;	-- ISO/TS 10303-1041
  USE FROM Extended_measure_representation_mim;	-- ISO/TS 10303-1106	
  USE FROM Specified_product_mim;	-- ISO/TS 10303-1104	
  USE FROM Part_view_definition_mim;	-- ISO/TS 10303-1023
  
USE FROM product_definition_schema(
  product_definition_relationship);

USE FROM product_property_definition_schema(
	characterized_product_definition,
	property_definition);

USE FROM product_property_representation_schema(
	property_definition_representation);
	
USE FROM product_structure_schema
	(product_definition_occurrence_relationship,
	quantified_assembly_component_usage);

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set);

  TYPE product_definition_or_assembly_relationship = SELECT (assembly_component_usage, product_definition);
  END_TYPE;
	
  RULE restrict_part_occurrence FOR (product_definition);
    LOCAL
      part_occurrences: SET OF product_definition := QUERY(pd <* product_definition | 
	    ( pd.frame_of_reference.name = 'part occurrence' ));
    END_LOCAL;
    WHERE
      WR1: SIZEOF ( QUERY ( pd <* part_occurrences | 
	    ( NOT( pd.name IN 
        ['single instance' , 'selected instance' ,'quantified instance' , 'specified instance' ] ) ) ) ) = 0;
      WR2: SIZEOF ( QUERY ( pd <* part_occurrences | 
 	    (SIZEOF ( QUERY ( pdr <* USEDIN ( pd ,
        'PART_OCCURRENCE_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
	    pdr.name = 'definition usage' ) ) <>1 ) AND 
        ( SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.' + 'CONFIGURATION_DESIGN.DESIGN' ) | 
        ( cd.name = 'occurrence usage definition' ) AND 
        ( NOT ('PART_OCCURRENCE_MIM.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF( cd.configuration ) ) ) ) ) <>1 ) ) ) = 0;
      WR3: SIZEOF ( QUERY ( pd <* part_occurrences |  
        (SIZEOF ( QUERY ( cd <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
        ( 'PART_OCCURRENCE_MIM.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF ( cd ) ) ) ) = 0 )AND
        ( SIZEOF ( USEDIN ( pd , 'PART_OCCURRENCE_MIM.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) ) = 0 ) ) ) = 0;
      WR4: SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'selected instance' ) AND 
        NOT valid_selected_instance_representation(pd) ))=0;
      WR5: SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'quantified instance' ) AND 
        ( SIZEOF ( QUERY (ppd <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.' +'PROPERTY_DEFINITION.DEFINITION' ) |
        ( ppd.name ='occurrence quantity' ) AND 
        ( SIZEOF ( QUERY ( pdr <*USEDIN ( ppd , 'PART_OCCURRENCE_MIM.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | (
        pdr.used_representation.name = 'quantity' ) AND 
        (SIZEOF ( pdr.used_representation.items ) = 1 ) AND 
        (SIZEOF ( QUERY ( i <* pdr.used_representation.items | 
        ('PART_OCCURRENCE_MIM.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
        ( i.name = 'quantity measure' ) ) ) = 1)))= 1 )))= 0 )))= 0;
      WR6: SIZEOF ( QUERY ( pd <* part_occurrences | 
        ( pd.name = 'specified instance' ) AND 
        ( SIZEOF ( QUERY (
        pdor <* USEDIN ( pd , 'PART_OCCURRENCE_MIM.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE' ) | 
        'PART_OCCURRENCE_MIM.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF ( pdor.occurrence_usage ) ) ) = 0 ) ) ) = 0;
  END_RULE;
	
  RULE restrict_part_occurrence_category FOR (product_definition);
    LOCAL
      part_occurrences: SET OF product_definition := QUERY( pd <* product_definition |(
        pd.frame_of_reference.name = 'part occurrence'));
    END_LOCAL;
    WHERE
      WR1: SIZEOF( QUERY( pd <* part_occurrences | 
        (SIZEOF( QUERY( prpc <* USEDIN(pd.formation.of_product, 'PART_OCCURRENCE_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
        prpc.name IN ['part','raw material','tool'] )) = 0 ) )) = 0;
  END_RULE;
	
  RULE selected_instance_usage_requires_representation FOR (assembly_component_usage);
    LOCAL
      selected_instance_usages: SET OF assembly_component_usage := QUERY( acr <* assembly_component_usage|
        (acr.name = 'selected instance usage'));
    END_LOCAL;
    WHERE
      WR1: SIZEOF ( QUERY ( acr <* selected_instance_usages | 
        NOT valid_selected_instance_representation(acr) ))=0;
  END_RULE;
	
  RULE restrict_product_definitions_for_definition_usage FOR (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr.name = 'definition usage' ) AND 
        ( ( pdr.relating_product_definition.frame_of_reference.name<> 'part definition' ) OR 
        ( pdr.related_product_definition.frame_of_reference.name<>'part occurrence' )))) =0;
  END_RULE;
	
  FUNCTION valid_selected_instance_representation (pd: product_definition_or_assembly_relationship): LOGICAL;
    LOCAL
      properties: SET OF property_definition := bag_to_set(QUERY( prd<* USEDIN ( pd ,'PART_OCCURRENCE_MIM.PROPERTY_DEFINITION.DEFINITION' ) | 
        (prd.name = 'occurrence selection' )));
      property_definition_representations: SET OF property_definition_representation := bag_to_set(QUERY ( pdr <* USEDIN ( properties[1] , 'PART_OCCURRENCE_MIM.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
	    ( pdr.used_representation.name = 'selection criteria' )));
      selected_representation: representation;
    END_LOCAL;
    IF (SIZEOF( properties)<>1) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF(property_definition_representations)<>1) THEN
	  RETURN(FALSE);
    END_IF;
    selected_representation := property_definition_representations[1]\property_definition_representation.used_representation;
    IF (SIZEOF(selected_representation\representation.items) <1) OR (SIZEOF(selected_representation\representation.items) >2) THEN
	  RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	  ( SIZEOF (['PART_OCCURRENCE_MIM.MEASURE_REPRESENTATION_ITEM' ,
      'PART_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
      ( i.name = 'selection quantity' ))) <> 1 ) THEN
      RETURN(FALSE);
    END_IF;
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
	  ( 'PART_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
 	  ( i.name = 'selection control' )))> 1) THEN
	  RETURN(FALSE);
    END_IF; --the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
    IF (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
      ( 'PART_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
      ( i.name = 'selection control' ) ))= 0) AND 
      (SIZEOF ( QUERY ( i <* selected_representation\representation.items |
      ( i.name = 'selection quantity' ) AND  
      ( SIZEOF(['PART_OCCURRENCE_MIM.QUALIFIED_REPRESENTATION_ITEM' ,
      'PART_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) > 0 ) THEN
	  RETURN(FALSE);
    END_IF;
    RETURN(TRUE);
  END_FUNCTION;
	
  

END_SCHEMA;


(*
 ISO TC184/SC4/WG12 N7093 - ISO/TS 10303-1343 Product placement - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N6686
*)

SCHEMA Product_placement_mim;

USE FROM Contextual_shape_positioning_mim;
USE FROM Physical_breakdown_mim;
USE FROM Product_occurrence_mim;


END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N4361 - ISO/TS 10303-1046 Product replacement - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1145
*)
    
SCHEMA Product_replacement_mim;

USE FROM Assembly_structure_mim; -- ISO 10303-1026
USE FROM Product_identification_mim; -- ISO 10303-1017

USE FROM product_structure_schema -- ISO 10303-44
  (alternate_product_relationship,
   assembly_component_usage_substitute);
END_SCHEMA;




(*
ISO TC184/SC4/WG12 N2547 - ISO/TS 10303-1134 Product structure - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N1671
*) 


SCHEMA Product_structure_mim;

USE FROM Assembly_structure_mim;    -- ISO/TS 10303-1026

USE FROM Contextual_shape_positioning_mim;    -- ISO/TS 10303-1027

USE FROM Part_and_version_identification_mim;    -- ISO/TS 10303-1022

USE FROM Part_definition_relationship_mim;    -- ISO/TS 10303-1055

USE FROM Product_replacement_mim;    -- ISO/TS 10303-1046

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Single_part_representation_mim;    -- ISO/TS 10303-1133

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 


END_SCHEMA;  -- Product_structure_mim
(* 
 ISO TC184/SC4/WG12 N2528 - ISO/TS 10303-1018 Product version - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1106
*) 


SCHEMA Product_version_mim; 

USE FROM Product_identification_mim;    -- ISO/TS 10303-1017

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition_formation); 


END_SCHEMA;  -- Product_version_mim

(*
 ISO TC184/SC4/WG12 N4355 - ISO/TS 10303-1020 Product version relationship - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1130
*)
   
SCHEMA Product_version_relationship_mim;

USE FROM Product_version_mim; 	--ISO 10303-1018

USE FROM product_definition_schema 	-- ISO 10303-41
  (product_definition_formation_relationship);
   
END_SCHEMA;


(*
 ISO TC184/SC4/WG12 N4352 - ISO/TS 10303-1019 Product view definition - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2928
*) 


SCHEMA Product_view_definition_mim;

USE FROM application_context_schema   -- ISO 10303-41
  (product_definition_context); 

USE FROM basic_attribute_schema   -- ISO 10303-41
  (name_attribute,
   name_attribute_select); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition,
   product_definition_context_association); 

USE FROM Product_version_mim;    -- ISO/TS 10303-1018

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 


END_SCHEMA;  -- Product_view_definition_mim
(*
ISO TC184/SC4/WG12 N3228 - ISO/TS 10303-1034 Product view definition properties - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N2127
*) 


SCHEMA Product_view_definition_properties_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition); 

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030


END_SCHEMA;  -- Product_view_definition_properties_mim
(*
 ISO TC184/SC4/WG12 N1142 - ISO/TS 10303-1041 Product view definition relationship - EXPRESS MIM
*)

SCHEMA Product_view_definition_relationship_mim;

USE FROM Product_view_definition_mim; -- ISO 10303-1019
USE FROM product_definition_schema -- ISO 10303-41
  (product_definition_relationship);

USE FROM product_structure_schema -- ISO 10303-44
  (product_definition_usage);
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7035 - ISO/TS 10303-1739 Production rule - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6541
*)


SCHEMA Production_rule_mim;
	USE FROM Specification_document_mim;    --  ISO/TS 10303-1747
	USE FROM Software_mim;	-- ISO/TS 10303-1746
	USE FROM Date_time_assignment_mim; -- ISO/TS 10303-1014
    USE FROM Identification_assignment_mim; -- ISO/TS 10303-1021
    USE FROM Product_identification_mim; -- ISO/TS 10303-1017
   	USE FROM Activity_mim; -- ISO/TS 10303-1047
	
	USE FROM product_definition_schema  --  ISO 10303-41
	  (product_definition_relationship,
	   product_related_product_category);
	
	USE FROM representation_schema(representation_item_relationship);
	
	USE FROM product_property_definition_schema(property_definition); 

	USE FROM product_property_representation_schema(property_definition_representation); 
	

TYPE pr_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH 
     (product_definition_formation);
END_TYPE; 

TYPE pr_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
     (rule_action);
END_TYPE; 

TYPE pr_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
   (rule_set);
END_TYPE; 

TYPE pr_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH
  (rule_set);
END_TYPE;  

TYPE pr_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (rule_action);
END_TYPE; 

TYPE pr_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (rule_action);
END_TYPE; 

TYPE rule_superseded_item = SELECT
     (product_definition_formation);
END_TYPE;

ENTITY abstract_variable
  SUBTYPE OF (property_definition, property_definition_representation, representation, representation_item);
END_ENTITY;  

ENTITY atomic_formula
  SUBTYPE OF (compound_representation_item);
END_ENTITY;    

ENTITY attribute_assertion
  SUBTYPE OF (fact_type, property_definition_representation, representation);
END_ENTITY;  

ENTITY back_chaining_rule  
  SUBTYPE OF (rule_definition);
END_ENTITY;  
								  
ENTITY back_chaining_rule_body 
  SUBTYPE OF (property_definition, property_definition_representation, representation);
END_ENTITY;

ENTITY complex_clause
  SUBTYPE OF (compound_representation_item);
END_ENTITY;

ENTITY complex_conjunctive_clause
  SUBTYPE OF (complex_clause);
END_ENTITY;

ENTITY complex_disjunctive_clause
  SUBTYPE OF (complex_clause);
END_ENTITY;

ENTITY entity_assertion
  SUBTYPE OF (fact_type);
END_ENTITY;

ENTITY enum_reference_prefix  
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY extent
  SUBTYPE OF (characterized_object);
END_ENTITY;

ENTITY fact_type
  SUBTYPE OF (property_definition);
END_ENTITY;

ENTITY forward_chaining_rule
  SUBTYPE OF (rule_definition);
END_ENTITY;
				
ENTITY forward_chaining_rule_premise 
  SUBTYPE OF (property_definition, property_definition_representation, representation);
END_ENTITY;

ENTITY func
  SUBTYPE OF (compound_representation_item);
END_ENTITY;

ENTITY global_assignment
  SUBTYPE OF (representation_item_relationship);
END_ENTITY; 

ENTITY ground_fact
  SUBTYPE OF (atomic_formula);
END_ENTITY;

ENTITY literal_conjunction
  SUBTYPE OF (simple_clause);
END_ENTITY;  

ENTITY literal_disjunction
  SUBTYPE OF (simple_clause);
END_ENTITY;  

ENTITY row_value
  SUBTYPE OF (compound_representation_item);
END_ENTITY;

ENTITY row_variable
  SUBTYPE OF (abstract_variable);
END_ENTITY;
																								
ENTITY rule_action
  SUBTYPE OF (action);
END_ENTITY;

ENTITY rule_condition
  SUBTYPE OF (atomic_formula);
END_ENTITY;  
					
ENTITY rule_definition 
 SUBTYPE OF (rule_software_definition);
END_ENTITY;

ENTITY rule_superseded_assignment
 SUBTYPE OF (action_assignment);
     items : SET [1:?] OF rule_superseded_item;
END_ENTITY;

ENTITY rule_set 
 SUBTYPE OF (rule_software_definition);
END_ENTITY;

ENTITY rule_software_definition 
 SUBTYPE OF (product_definition);
END_ENTITY;

ENTITY rule_set_group
SUBTYPE OF (rule_software_definition);
END_ENTITY;

ENTITY rule_supersedence
  SUBTYPE OF (rule_action);
END_ENTITY;

ENTITY scalar_variable
  SUBTYPE OF (abstract_variable);
END_ENTITY;
					
ENTITY simple_clause
  SUBTYPE OF (compound_representation_item);
END_ENTITY;
					
ENTITY symbol
  SUBTYPE OF (representation_item);
END_ENTITY;				
	
END_SCHEMA;


(*
 ISO TC184/SC4/WG12 N4264 - ISO/TS 10303-1061 Project - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2112
*) 


SCHEMA Project_mim; 

USE FROM Date_time_assignment_mim;    -- ISO/TS 10303-1014

USE FROM Date_time_mim;    -- ISO/TS 10303-1010

USE FROM Event_assignment_mim;    -- ISO/TS 10303-1364

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM management_resources_schema   -- ISO 10303-41
  (organizational_project_assignment,
   organizational_project_role); 

USE FROM Person_organization_mim;    -- ISO/TS 10303-1011

USE FROM person_organization_schema   -- ISO 10303-41
  (organizational_project,
   organizational_project_relationship); 


TYPE project_as_date_and_time_item = SELECT BASED_ON date_and_time_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_as_date_item = SELECT BASED_ON date_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH 
   (organizational_project);
END_TYPE; 

TYPE project_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY applied_organizational_project_assignment
  SUBTYPE OF (organizational_project_assignment);
  items : SET[1:?] OF project_item;
END_ENTITY;

END_SCHEMA;  -- Project_mim
(*
 ISO TC184/SC4/WG12 N4375 - ISO/TS 10303-1030 Property assignment - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N2129
*) 


SCHEMA Property_assignment_mim;

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute,
   id_attribute_select); 

USE FROM Foundation_representation_mim;    -- ISO/TS 10303-1006

USE FROM Independent_property_mim;    -- ISO/TS 10303-1036

USE FROM product_property_definition_schema   -- ISO 10303-41
  (general_property_association,
   property_definition); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (property_definition_representation); 


END_SCHEMA;  -- Property_assignment_mim
(*
   ISO TC184/SC4/WG12 N6559 - ISO/TS 10303-1782 Qualified measure - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5483
*)

SCHEMA Qualified_measure_mim;

USE FROM Measure_representation_mim; -- ISO/TS 10303-1118

USE FROM qualified_measure_schema
  (expanded_uncertainty,
  measure_qualification,
  measure_representation_item,
  qualified_representation_item,
  qualitative_uncertainty,
  precision_qualifier,
  standard_uncertainty,
  type_qualifier,
  uncertainty_qualifier);

USE FROM representation_schema
  (uncertainty_assigned_representation);


RULE consistent_uncertainty 
      FOR (global_uncertainty_assigned_context,
           qualified_representation_item,
           uncertainty_assigned_representation);
WHERE
WR1: SIZEOF ( QUERY ( guac <* global_uncertainty_assigned_context | 
    SIZEOF ( QUERY ( u1 <* guac.uncertainty | 
	SIZEOF ( QUERY ( u2 <* guac.uncertainty | u2.name =  u1.name ) ) >1 ) ) >0 ) ) =  0 ;
WR2: SIZEOF ( QUERY ( uar <* uncertainty_assigned_representation | 
	SIZEOF ( QUERY ( u1<* uar.uncertainty | 
	SIZEOF ( QUERY ( u2 <* uar.uncertainty | u2.name =  u1.name ) ) >1 ) ) >0 ) ) =  0;
WR3: SIZEOF ( QUERY ( qri <* qualified_representation_item |
     SIZEOF ( QUERY ( u1 <* qri.qualifiers |
     ('REPRESENTATION_WITH_UNCERTAINTY_MIM' + '.UNCERTAINTY_QUALIFIER' IN TYPEOF ( u1 ) ) AND 
	( SIZEOF ( QUERY ( u2 <* qri.qualifiers |
     ( 'REPRESENTATION_WITH_UNCERTAINTY_MIM' + '.UNCERTAINTY_QUALIFIER' IN TYPEOF ( u2 ) ) AND 
	( u2\uncertainty_qualifier.measure_name =  u1\uncertainty_qualifier.measure_name ) )
     ) >1 ) ) ) >0 ) ) =  0;
END_RULE; 

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6130 - ISO/TS 10303-1233 Requirement assignment - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5486
*) 


SCHEMA Requirement_assignment_mim;

USE FROM group_schema   -- ISO 10303-41
  (group,
   group_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
  (group_assignment); 

USE FROM product_definition_schema   -- ISO 10303-41
  (product_definition); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object); 

USE FROM Requirement_view_definition_mim;    -- ISO/TS 10303-1141


TYPE requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

TYPE requirement_satisfaction_item = EXTENSIBLE GENERIC_ENTITY SELECT
   (requirement_assigned_item);
END_TYPE; 

TYPE requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT;
END_TYPE; 

ENTITY assigned_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET[1:1] OF product_definition;
END_ENTITY;

ENTITY requirement_assigned_object
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET[1:1] OF requirement_assigned_item;
END_ENTITY;

ENTITY requirement_assignment
  SUBTYPE OF (characterized_object, group);
END_ENTITY;

ENTITY requirement_source
  SUBTYPE OF (group);
END_ENTITY;

ENTITY satisfied_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : satisfies_requirement;
  items : SET[1:1] OF product_definition;
END_ENTITY;

ENTITY satisfies_requirement
  SUBTYPE OF (group);
END_ENTITY;

ENTITY satisfying_item
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : satisfies_requirement;
  items : SET[1:1] OF requirement_satisfaction_item;
END_ENTITY;

ENTITY source_for_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET[1:1] OF requirement_source_item;
END_ENTITY;

ENTITY sourced_requirement
  SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET[1:1] OF product_definition;
END_ENTITY;

END_SCHEMA;  -- Requirement_assignment_mim


(*
   ISO TC184/SC4/WG12 N7038 - ISO/TS 10303-1740 Requirement decomposition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6544
*)


SCHEMA Requirement_decomposition_mim;

	USE FROM Conductivity_material_aspects_mim;	-- ISO/TS 10303-1756
	USE FROM Elemental_geometric_shape_mim;	-- ISO/TS 10303-1004
	USE FROM Functional_specification_mim;	-- ISO/TS 10303-1679
	USE FROM Production_rule_mim;	-- ISO/TS 10303-1739
	USE FROM Requirement_view_definition_relationship_mim;  -- ISO/TS 10303-1142
	
	USE FROM Material_property_definition_schema(property_definition_relationship);	

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 

SUBTYPE_CONSTRAINT rd_model_parameter_subtypes FOR model_parameter; 
	 ONEOF (category_model_parameter);
END_SUBTYPE_CONSTRAINT;

TYPE rd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (predefined_requirement_view_definition);
END_TYPE; 

TYPE rd_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (predefined_requirement_view_definition);
END_TYPE;

TYPE rd_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
     (group,
     group_relationship);
END_TYPE; 

ENTITY material_electrical_conductivity_category
  SUBTYPE OF (group);
END_ENTITY;

ENTITY operational_requirement_relationship
  SUBTYPE OF (property_definition, product_definition_relationship);
END_ENTITY;

ENTITY predefined_requirement_view_definition
  SUBTYPE OF (product_definition);
END_ENTITY;

END_SCHEMA;


(*
ISO TC184/SC4/WG12 N6585 - ISO/TS 10303-1140 Requirement identification and version - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N5945
*) 


SCHEMA Requirement_identification_and_version_mim;

USE FROM Identification_assignment_mim;    -- ISO/TS 10303-1021

USE FROM product_definition_schema   -- ISO 10303-41
  (product,
   product_category,
   product_definition_formation,
   product_related_product_category); 

USE FROM Product_version_relationship_mim;    -- ISO/TS 10303-1020


TYPE requirement_identification_and_version_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH 
   (product, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Requirement_identification_and_version_mim

(*
ISO TC184/SC4/WG12 N6843 - ISO/TS 10303-1141 Requirement view definition - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4285
*) 


SCHEMA Requirement_view_definition_mim;

USE FROM Product_view_definition_mim;    -- ISO/TS 10303-1019

USE FROM Requirement_identification_and_version_mim;    -- ISO/TS 10303-1140


END_SCHEMA;  -- Requirement_view_definition_mim
(*
 ISO TC184/SC4/WG12 N6133 - ISO/TS 10303-1142 Requirement view definition relationship - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N3137
*) 


SCHEMA Requirement_view_definition_relationship_mim;

USE FROM Product_view_definition_relationship_mim;    -- ISO/TS 10303-1041
USE FROM Requirement_view_definition_mim;    -- ISO/TS 10303-1141

END_SCHEMA;  -- Requirement_view_definition_relationship_mim

(*
 ISO TC184/SC4/WG12 N1097 - ISO/TS 10303-1015 Security classification - EXPRESS MIM
*)

SCHEMA Security_classification_mim;

USE FROM security_classification_schema -- ISO 10303-41
  (security_classification,
   security_classification_level);
USE FROM management_resources_schema -- ISO 10303-41
  (security_classification_assignment);
  
TYPE security_classification_item = EXTENSIBLE SELECT; 
END_TYPE;

ENTITY applied_security_classification_assignment
  SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;

END_SCHEMA;






(*
   ISO TC184/SC4/WG12 N7072 - ISO/TS 10303-1741 Sequential laminate assembly design - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6547
*)


SCHEMA Sequential_laminate_assembly_design_mim;
USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698


  TYPE slad_groupable_item = SELECT BASED_ON groupable_item WITH 
	(group_relationship,
	assembly_component_usage);
  END_TYPE; 
	
  TYPE slad_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (derived_laminate_assignment,
    assembly_component_usage);
  END_TYPE; 

  ENTITY derived_laminate_assignment
    SUBTYPE OF (property_definition_relationship);
  END_ENTITY;

  ENTITY interconnect_module_stratum_based_terminal
    SUBTYPE OF (interconnect_module_terminal);
  END_ENTITY;

  ENTITY sequential_laminate_passage_based_fabrication_joint
    SUBTYPE OF (shape_aspect);
  END_ENTITY;

  ENTITY sequential_laminate_stackup_component 
    SUBTYPE OF(physical_component);
  END_ENTITY;

  ENTITY sequential_laminate_stackup_definition
    SUBTYPE OF(product_definition);
  END_ENTITY;
	
END_SCHEMA;

(*
	ISO TC184/SC4/WG12 N6927 - ISO/TS 10303-1009 Shape appearance layers - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N6689
*)

SCHEMA Shape_appearance_layers_mim; 

USE FROM Appearance_assignment_mim; -- ISO/CD-TS 10303-1001

USE FROM Fill_area_style_mim; -- ISO/TS 10303-1672

USE FROM General_surface_appearance_mim; -- ISO/CD-TS 10303-1007

USE FROM Layer_assignment_mim; -- ISO/CD-TS 10303-1008

END_SCHEMA; 
(*
   ISO TC184/SC4/WG12 N4174 - ISO/TS 10303-1742 Shape composition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3598
*)

SCHEMA Shape_composition_mim;

USE FROM Shape_property_assignment_mim;	-- ISO/TS 10303-1032
	USE FROM Shape_aspect_definition_schema(composite_shape_aspect, composite_group_shape_aspect);
--	USE FROM Product_property_definition_schema;
	USE FROM Shape_dimension_schema (dimensional_location);
	
ENTITY composite_unit_shape_aspect
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

END_SCHEMA;


(*
   WG12N7185 - ISO/TS 10303-1523 shape_data_quality_criteria - EXPRESS MIM
*)

SCHEMA Shape_data_quality_criteria_mim;
  USE FROM Product_data_quality_criteria_mim;
  USE FROM Qualified_measure_mim;
  USE FROM Shape_data_quality_inspection_result_mim;
  USE FROM Shape_data_quality_criteria_schema;
  USE FROM representation_schema
  (compound_item_definition, 
   representation_item,
   compound_representation_item, 
   list_representation_item, 
   set_representation_item); 
END_SCHEMA;
(*
   WG12N7188 - ISO/TS 10303-1524 shape_data_quality_inspection_result - EXPRESS MIM
*)

SCHEMA Shape_data_quality_inspection_result_mim;
  USE FROM Advanced_boundary_representation_mim;
  USE FROM Basic_curve_mim;
  USE FROM Basic_geometric_topology_mim;
  USE FROM B_spline_geometry_mim;
  USE FROM Composite_surface_mim;
  USE FROM Manifold_surface_mim;
  USE FROM Product_data_quality_inspection_result_mim;
  USE FROM Shape_data_quality_criteria_mim;
  USE FROM Shape_data_quality_inspection_result_schema;
  USE FROM Shape_property_assignment_mim;
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6924 - ISO/TS 10303-1764 Shape feature - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4237
*)

SCHEMA Shape_feature_mim;

USE FROM Characterizable_object_mim;  -- ISO/TS 10303-1765
USE FROM Contextual_shape_positioning_mim;
USE FROM Property_assignment_mim;
USE FROM shape_aspect_definition_schema          -- ISO 10303-47
      (composite_shape_aspect,
       feature_definition,
       instanced_feature);
REFERENCE FROM product_property_representation_schema (
	get_property_definition_representations);       
REFERENCE FROM product_property_definition_schema (
 	get_shape_aspects);
USE FROM aic_machining_feature (shape_defining_relationship, feature_component_relationship);	

ENTITY shape_feature_definition
  SUBTYPE OF (feature_definition);
END_ENTITY;

ENTITY placed_feature
  SUBTYPE OF (shape_aspect);
END_ENTITY;

ENTITY general_feature
  SUBTYPE OF (shape_feature_definition);
WHERE
  WR1:  (SIZEOF(get_property_definition_representations(SELF)) <= 1) AND
             (SIZEOF( QUERY( pdr <* get_property_definition_representations(SELF) |
              'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN 
              TYPEOF(pdr.used_representation)
             )) <= 1);   
  WR2:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               sa.description = 'course of travel occurrence')) =
             SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'course of travel occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 (sar.name = 'course of travel')
                )) = 1 )));   
  WR3:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               sa.description = 'course of travel occurrence')) =
             SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'course of travel occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 ('SHAPE_FEATURE_MIM.PATH_FEATURE_COMPONENT' IN
                  TYPEOF(sar.relating_shape_aspect))
                )) = 1 )));   
  WR4:  SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               sa.description = 'boundary occurrence')) =
             SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               (sa.description = 'boundary occurrence') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
                 ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 (sar.description = 'profile usage')
                )) = 1 )));   
  WR5:  (SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN
                  TYPEOF(sa))
              )) <= 1 ) AND
             (SIZEOF( QUERY( sa <* get_shape_aspects(SELF) |
               ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN
                  TYPEOF(sa)) AND
               (sa.name = 'general compound feature') AND
               (SIZEOF( QUERY( sar <* USEDIN( sa, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
                 ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' IN
                  TYPEOF(sar)) AND
                 ('SHAPE_ASPECT_DEFINITION_SCHEMA.INSTANCED_FEATURE' IN
                  TYPEOF(sar.related_shape_aspect))
                )) >= 2 )
              )) <= 1 );   
END_ENTITY;


END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N4177 - ISO/TS 10303-1743 Shape parameters - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3601
*)


SCHEMA Shape_parameters_mim;
	USE FROM External_item_identification_assignment_mim;	-- ISO/TS 10303-1128
	
	USE FROM Product_property_definition_schema(characterized_object);
	
ENTITY keepout_design_object_category
  SUBTYPE OF (characterized_object);
END_ENTITY;
	
END_SCHEMA;

(*
	ISO TC184/SC4/WG12 N6930 - ISO/TS 10303-1032 Shape property assignment - EXPRESS MIM
	Supersedes ISO TC184/SC4/WG12 N6259
*)


SCHEMA Shape_property_assignment_mim;

USE FROM Property_assignment_mim;
(*REFERENCE FROM*) USE FROM Assembly_structure_mim; -- ISO/TS 10303-1026

(*REFERENCE FROM*) USE FROM External_model_mim; -- ISO/TS 10303-1033

USE FROM Geometric_model_relationship_mim; -- ISO/TS 10303-1403 
USE FROM Product_view_definition_relationship_mim; -- ISO/TS 10303-1041

USE FROM basic_attribute_schema   -- ISO 10303-41
  (id_attribute); 

USE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_product_definition,
   product_definition_shape,
   shape_aspect,
   shape_aspect_relationship); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (item_identified_representation_usage,
   chain_based_item_identified_representation_usage,
   shape_definition_representation); 

TYPE geometric_model_item = EXTENSIBLE GENERIC_ENTITY SELECT (
    geometric_representation_item);
END_TYPE; 

TYPE geometric_item_specific_usage_select = SELECT
   (shape_aspect,
    shape_aspect_relationship);
END_TYPE; 

TYPE shape_model = EXTENSIBLE GENERIC_ENTITY SELECT 
   (shape_representation);
END_TYPE;   

ENTITY geometric_item_specific_usage
  SUBTYPE OF(item_identified_representation_usage);
    SELF\item_identified_representation_usage.definition          : geometric_item_specific_usage_select;
    SELF\item_identified_representation_usage.used_representation : shape_model;
    SELF\item_identified_representation_usage.identified_item     : geometric_model_item;
  UNIQUE
   UR1 : definition;
END_ENTITY;

ENTITY chain_based_geometric_item_specific_usage
  SUBTYPE OF (geometric_item_specific_usage, 
    chain_based_item_identified_representation_usage);
END_ENTITY;

END_SCHEMA; 
(*
 ISO TC184/SC4/WG12 N1271 - ISO/TS 10303-1502 Shell based wireframe - EXPRESS MIM
*)

SCHEMA Shell_based_wireframe_mim;

USE FROM aic_shell_based_wireframe;	     -- ISO 10303-502
USE FROM Elemental_geometric_shape_mim;      -- ISO 10303-1004

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N4183 - ISO/TS 10303-1745 Signal - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3607
*)


SCHEMA Signal_mim;
	USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
	
	USE FROM Product_property_definition_schema
		(characterized_object,
		property_definition);
	USE FROM Material_property_definition_schema(property_definition_relationship);
	USE FROM Group_schema(group);
	USE FROM Document_schema(document_usage_constraint);
	
TYPE s_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH 
     (composite_signal_property_relationship,
      property_definition,
      signal);
END_TYPE; 
	
ENTITY composite_signal_property_relationship
  SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
  WR1: SELF\property_definition_relationship.related_property_definition.definition :<>:
       SELF\property_definition_relationship.relating_property_definition.definition;
END_ENTITY;

ENTITY signal
  SUBTYPE OF (characterized_object);
END_ENTITY;

ENTITY signal_category
  SUBTYPE OF (group);
END_ENTITY;
	
END_SCHEMA;


(*
ISO TC184/SC4/WG12 N7140 - ISO/TS 10303-1133 Single part representation - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N6088
*) 


SCHEMA Single_part_representation_mim;

USE FROM Document_assignment_mim;    -- ISO/TS 10303-1122

USE FROM Extended_measure_representation_mim;    -- ISO/TS 10303-1106

USE FROM Part_view_definition_mim;    -- ISO/TS 10303-1023

USE FROM Person_organization_assignment_mim;    -- ISO/TS 10303-1013

USE FROM Property_assignment_mim;    -- ISO/TS 10303-1030

USE FROM Shape_property_assignment_mim;    -- ISO/TS 10303-1032


TYPE spr_document_reference_item = SELECT BASED_ON document_reference_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

TYPE spr_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
   (product, 
    product_definition, 
    product_definition_formation);
END_TYPE; 

END_SCHEMA;  -- Single_part_representation_mim
(*
  ISO TC184/SC4/WG12 N7212 - ISO/TS 10303-1792 Sketch - EXPRESS MIM
*)

SCHEMA Sketch_mim;

USE FROM Geometric_constraints_mim;
USE FROM Solid_model_mim; -- ISO/TS 10303-1793

USE FROM sketch_schema;  -- ISO 10303-108

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6262 - ISO/TS 10303-1746 Software - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4186
*)


SCHEMA Software_mim;
	USE FROM Document_definition_mim;	-- ISO/TS 10303-1123
	USE FROM Product_identification_mim;	-- ISO/TS 10303-1017
	USE FROM Information_product_mim;	-- ISO/TS 10303-xxxx
    USE FROM product_definition_schema     --  ISO 10303-41
      (product_related_product_category); 
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6933 - ISO/TS 10303-1793 Solid model - EXPRESS MIM
*)
SCHEMA Solid_model_mim;

USE FROM Elemental_geometric_shape_mim; -- ISO/TS 10303-1004
USE FROM geometric_model_schema(solid_model);

END_SCHEMA;
(*
  ISO TC184/SC4/WG12 N5498 - ISO/TS 10303-1319 Solid with local modification - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4811
*)

SCHEMA Solid_with_local_modification_mim;

USE FROM Basic_geometric_topology_mim; -- ISO/CD-TS 10303-1323

USE FROM Procedural_solid_model_mim; -- ISO/CD-TS 10303-131

USE FROM Topologically_bounded_surface_mim; -- ISO/TS 10303-1511

USE FROM geometric_model_schema  -- ISO 10303-42 
      (solid_model);

USE FROM topology_schema  -- ISO 10303-42 
    (edge,
     edge_curve);
    
USE FROM solid_shape_element_schema  -- ISO 10303-111 
    (complex_shelled_solid,
     conical_stepped_hole_transition,
     double_offset_shelled_solid,
     sculptured_solid,
     shelled_solid,
     solid_with_angle_based_chamfer,
     solid_with_chamfered_edges,
     solid_with_circular_pattern,
     solid_with_circular_pocket,
     solid_with_circular_protrusion,
     solid_with_conical_bottom_round_hole,
     solid_with_constant_radius_edge_blend,
     solid_with_curved_slot,
     solid_with_double_offset_chamfer,
     solid_with_flat_bottom_round_hole,
     solid_with_general_pocket,
     solid_with_general_protrusion,
     solid_with_groove,
     solid_with_incomplete_circular_pattern,
     solid_with_incomplete_rectangular_pattern,
     solid_with_rectangular_pattern,
     solid_with_rectangular_pocket,
     solid_with_rectangular_protrusion,
     solid_with_single_offset_chamfer,
     solid_with_spherical_bottom_round_hole,
     solid_with_stepped_round_hole,
     solid_with_stepped_round_hole_and_conical_transitions,
     solid_with_straight_slot,
     solid_with_tee_section_slot,
     solid_with_through_depression,
     solid_with_trapezoidal_section_slot,
     solid_with_variable_radius_edge_blend,
     surfaced_open_shell,
     track_blended_solid,
     track_blended_solid_with_end_conditions,
     blend_radius_variation_type,
     blend_end_condition_select);
    
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N2596 - ISO/TS 10303-1108 Specification based configuration - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1730
*)

SCHEMA Specification_based_configuration_mim;

USE FROM Effectivity_application_mim;

USE FROM Product_class_mim;

USE FROM management_resources_schema(
  effectivity_context_assignment);

USE FROM product_definition_schema(
  product_definition);

TYPE configured_effectivity_context_item = SELECT (product_concept_feature_association);
END_TYPE;

TYPE configured_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT (
  product_definition); 
END_TYPE; 

ENTITY configured_effectivity_context_assignment 
SUBTYPE OF (effectivity_context_assignment);
  SELF\effectivity_context_assignment.assigned_effectivity_assignment: configured_effectivity_assignment;
  items : SET [1:?] OF configured_effectivity_context_item; 
WHERE 
WR1: SIZEOF(SELF.items) = 1; 
END_ENTITY;
 
ENTITY configured_effectivity_assignment 
	SUBTYPE OF (effectivity_assignment);
	  items : SET [1:?] OF configured_effectivity_item; 
	WHERE 
	WR1: (SIZEOF(['EFFECTIVITY_SCHEMA.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity) ) = 1) 
	AND (SELF.assigned_effectivity.id = 'configuration validity'); 
	WR2: SIZEOF(SELF.items) = 1; 
	WR3: SIZEOF( QUERY( i <* SELF.items | NOT ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(i)) 
	OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']) )) = 0; 
	WR4: SELF.role.name IN ['design', 'usage']; 
	WR5: (SELF.role.name <> 'design') 
	OR (SIZEOF( QUERY( i <* SELF.items | ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence') )) = 0); 
	WR6: (SELF.role.name <> 'usage') OR (SIZEOF( QUERY( i <* SELF.items | ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition') )) = 0); 
	WR7: SELF.role.description IN ['exception', 'inherited', 'local']; 
	WR8: SIZEOF( QUERY( x <* USEDIN(SELF,'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'SPECIFICATION_BASED_CONFIGURATION_MIM.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x) )) = 1; 
END_ENTITY;


END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N6674 - ISO/TS 10303-1112 Specification control - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5501
*)

SCHEMA Specification_control_mim;

USE FROM Alternative_solution_mim; -- ISO/TS 10303-1109
USE FROM Part_collection_mim; -- ISO/TS 10303-1115
USE FROM Product_placement_mim; -- ISO/TS 10303-1343
USE FROM Requirement_view_definition_mim; 
USE FROM Specification_based_configuration_mim; -- ISO/TS 10303-1108
USE FROM product_definition_schema (product_definition_substitute);


  TYPE class_usage_effectivity_context_item = SELECT
    (product_definition);
  END_TYPE;

  TYPE effectivity_specification_for_replacement  = SELECT BASED_ON effectivity_item WITH
    (product_definition_substitute);
  END_TYPE;

  TYPE instance_usage_context_select  = EXTENSIBLE GENERIC_ENTITY SELECT 
    (product_definition_relationship,
     product_definition_usage);
  END_TYPE;

  ENTITY class_usage_effectivity_context_assignment 
    SUBTYPE OF (effectivity_context_assignment); 
      items : SET [1:?] OF class_usage_effectivity_context_item; 
    WHERE 
      WR1: SELF.role.name = 'class usage influence'; 
      WR2: SIZEOF( QUERY( i <* SELF.items | NOT ('SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) )) = 0; 
      WR3: ('SPECIFICATION_CONTROL_MIM.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND 
        (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity) ) = 1) AND 
        (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND 
        (SIZEOF( QUERY( i <* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | 
        NOT('SPECIFICATION_CONTROL_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) = 0); 
  END_ENTITY; 

  ENTITY instance_usage_context_assignment 
    SUBTYPE OF (product_definition_context); 
      items : SET [1:?] OF instance_usage_context_select; 
  END_ENTITY; 

  RULE breakdown_element_requires_product_definition FOR 
	  (product_definition_formation);
    WHERE
      WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
        ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
        'SPECIFICATION_CONTROL_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc.name =  'functionality' ) ) =  1 ) AND 
	    ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf ,'SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION.FORMATION') | 
	    pd.frame_of_reference.name =  'functional definition' ) ) <1 ) ) ) =  0;
      WR2: SIZEOF ( QUERY ( pdf <* product_definition_formation | 
        ( SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product , 
	    'SPECIFICATION_CONTROL_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
        prpc.name =  'conceptual design' ) ) =  1 ) AND 
        ( SIZEOF (QUERY ( pd <* USEDIN ( pdf , 'SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION.FORMATION' ) | 
        pd.frame_of_reference.name =  'conceptual definition' ) ) <1) ) ) =  0;
  END_RULE;

  RULE constraint_definition_requires_constraint_category FOR (product_definition);
    LOCAL
      constraint_definitions: SET OF product_definition := [];
    END_LOCAL;
      constraint_definitions :=  QUERY( pd <* product_definition |
      (pd.frame_of_reference.name = 'design constraint definition'));
    WHERE
      WR1: SIZEOF ( QUERY ( pd <* constraint_definitions | 
	    ( SIZEOF ( QUERY ( prpc <* USEDIN ( pd.formation.of_product ,
        'SPECIFICATION_CONTROL_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc. name ='requirement' ) ) =0 ) ) ) =0;
  END_RULE;

  RULE design_constraint_requires_product_definition FOR (product_definition_formation);
    WHERE
      WR1: SIZEOF ( QUERY ( pdf <* product_definition_formation | (
        SIZEOF ( QUERY ( prpc <* USEDIN ( pdf.of_product ,
        'SPECIFICATION_CONTROL_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS' ) | 
	    prpc.name =  'requirement' ) ) >0 ) AND 
        ( SIZEOF ( QUERY ( pd <* USEDIN ( pdf , 'SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION.FORMATION') | 
	    pd.frame_of_reference.name = 'design constraint definition' ) ) <1 ) ) ) =  0;
  END_RULE; 

  RULE restrict_configuration_design_for_class_breakdown_association FOR
      (configuration_design);
    WHERE
      WR1: SIZEOF ( QUERY ( cd <* configuration_design | 
	    ( cd.name ='functionality' ) AND 
        ( NOT ( 'SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION' IN TYPEOF ( cd. design ) ) OR 
        ( cd.design\product_definition.frame_of_reference.name<> 'functional definition' ) ) 
        ) ) =0;
      WR2: SIZEOF ( QUERY ( cd <* configuration_design | 
        ( cd.name='realization' ) AND 
        ( NOT ( 'SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
        ( cd.design\product_definition.frame_of_reference.name<> 'conceptual definition' ) ) 
        ) ) =0;
      WR3: SIZEOF ( QUERY ( cd <* configuration_design | 
        ( cd.name IN ['functionality' , 'realization'] ) AND 
        ( NOT ('SPECIFICATION_CONTROL_MIM.PRODUCT_CLASS' IN TYPEOF ( cd.configuration.item_concept ) ) ) 
        ) ) =0;
  END_RULE;

  RULE restrict_configuration_design_for_design_constraint FOR (configuration_design); 
    WHERE 
      WR1: SIZEOF ( QUERY (cd <* configuration_design | 
	    (cd.name = 'design constraint usage') AND 
        (NOT('SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION' IN TYPEOF ( cd.design ) ) OR 
        (cd.design\product_definition.frame_of_reference.name <> 'design constraint definition')))) = 0; 
  END_RULE;

  RULE restrict_product_definitions_for_design_constraint_association FOR
      (product_definition_relationship);
    WHERE
      WR1: SIZEOF ( QUERY ( pdr <* product_definition_relationship |
        ( pdr. name = 'design constraint association' ) AND 
	    ( (pdr. relating_product_definition.frame_of_reference.name<>'design constraint definition' ) OR 
	    NOT ( pdr.related_product_definition.frame_of_reference.name IN 
	    ['alternative definition' , 'functional definition' ,'conceptual definition' ] ) ) ) ) =0;
  END_RULE;

END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N6936 - ISO/TS 10303-1747 Specification document - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5504
*)

SCHEMA Specification_document_mim;
USE FROM Characteristic_mim;	-- ISO/TS 10303-1654
USE FROM Configuration_item_mim;	-- ISO/TS 10303-1056
USE FROM Tagged_text_representation_mim; -- ISO/TS 10303-1366

USE FROM document_schema (document_type);
USE FROM management_resources_schema(group_assignment);
USE FROM date_time_schema(date_time_role);
USE FROM product_definition_schema(product_definition_formation_relationship);
USE FROM product_property_representation_schema(item_identified_representation_usage);

  TYPE document_identifier_assigned_item = SELECT
    (document);
  END_TYPE;

  TYPE sd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
    (configuration_item,
    product,
    product_definition,
    product_definition_formation);
  END_TYPE;
	
  ENTITY document_identifier
    SUBTYPE OF (group);
    UNIQUE
      UR1: SELF\group.name, SELF\group.description;
  END_ENTITY;

  ENTITY document_identifier_assignment
    SUBTYPE OF (group_assignment);
      SELF\group_assignment.assigned_group : document_identifier;
        items : SET [1:?] OF document_identifier_assigned_item;
  END_ENTITY;

  ENTITY partial_document_with_structured_text_representation_assignment
    SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
  END_ENTITY;  

  ENTITY specification_definition
    SUBTYPE OF (product_definition);
  END_ENTITY;
	
END_SCHEMA;


(*
 ISO TC184/SC4/WG12 N5507 - ISO/TS 10303-1104 Specified product - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N4817
*)

SCHEMA Specified_product_mim;

USE FROM Configuration_item_mim; -- ISO/TS 10303-1056

USE FROM Product_class_mim; -- ISO/TS 10303-1103

USE FROM configuration_management_schema(
	configurable_item);

USE FROM product_property_definition_schema(
	characterized_object);


  TYPE id_for_product_identification = SELECT BASED_ON identification_item WITH (product_identification);
  END_TYPE;

  ENTITY product_identification
    SUBTYPE OF (configuration_item, characterized_object);
	  SELF\configuration_item.item_concept : product_class;
    WHERE
	  WR1 : SIZEOF(QUERY 
		( cd <* USEDIN ( SELF ,'CONFIGURATION_MANAGEMENT_SCHEMA.CONFIGURATION_DESIGN.CONFIGURATION' ) 
		|
     	( 'PRODUCT_DEFINITION_SCHEMA.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) 
     	AND 
    	( SIZEOF ( QUERY 
    	( 
    	prpc <* USEDIN ( cd. design\product_definition_formation.of_product , 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') 
    	| 
        prpc. name IN ['part' , 'raw material' , 'tool'] ) ) >0
     	) 
     	) 
     	) <=1;
	  WR2 : NOT ( 'CONFIGURATION_MANAGEMENT_SCHEMA.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) 
			XOR ( 'SPECIFIED_PRODUCT_MIM.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) ) ;
  END_ENTITY;

  ENTITY product_specification
    SUBTYPE OF (product_identification, configurable_item);
  END_ENTITY;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6265 - ISO/TS 10303-1771 Stock material - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5510
*)

SCHEMA Stock_material_mim;

USE FROM Approval_mim; -- ISO/TS 10303-1012

USE FROM Elemental_geometric_shape_mim; -- ISO/CD-TS 10303-1004

USE FROM Generic_material_aspects_mim; -- ISO/TS 10303-1681

USE FROM Specification_document_mim; -- ISO/TS 10303-1747

USE FROM Part_view_definition_mim; -- ISO/TS 10303-1023

USE FROM product_structure_schema (make_from_usage_option);

USE FROM product_definition_schema     --  ISO 10303-41
    (product_related_product_category); 


  TYPE sm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH
    (product_definition);
  END_TYPE;

  RULE ply_stock_material_select FOR
   (product_related_product_category,
    make_from_usage_option);
  LOCAL
    i,j,k,kp :  INTEGER;
    dkuhr    :  LOGICAL;
    nmfuo    :  INTEGER;
    nprpc    :  INTEGER := 0;
    rp       :  product;
  END_LOCAL;

  dkuhr := TRUE;
  REPEAT kp:= LOINDEX (product_related_product_category) TO
              HIINDEX (product_related_product_category);
 
    IF (product_related_product_category[kp].name = 'ply') THEN
    REPEAT i:= LOINDEX (product_related_product_category[kp].products) TO
               HIINDEX (product_related_product_category[kp].products);

      nmfuo := 0;  
      REPEAT j:= LOINDEX (make_from_usage_option) TO 
                 HIINDEX (make_from_usage_option);

          rp := make_from_usage_option[j].related_product_definition.
                formation.of_product;

        IF (product_related_product_category[kp].products[i] = rp) THEN

          REPEAT k:= LOINDEX (product_related_product_category) TO
                     HIINDEX (product_related_product_category);

            IF ((rp IN product_related_product_category[k].products) AND
                (product_related_product_category[k].name IN 
                 ['isotropic material', 'filament assembly', 
                  'discontinuous fiber assembly'])) THEN
                nprpc := nprpc + 1;
            END_IF;

          END_REPEAT;

          IF (nprpc = 1) THEN
            nmfuo := nmfuo + 1;
          ELSE
            dkuhr := FALSE;
            ESCAPE;
          END_IF;

        END_IF;

      END_REPEAT;

      IF (dkuhr = FALSE) THEN
        ESCAPE; 
      END_IF;
      IF(nmfuo <> 1) THEN
        dkuhr := FALSE;
        ESCAPE;
      END_IF;

    END_REPEAT;
    END_IF;

  END_REPEAT;

  WHERE
    WR1: dkuhr;
  END_RULE;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N6550 - ISO/TS 10303-1748 Stratum non planar shape - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5816
*)


SCHEMA Stratum_non_planar_shape_mim;
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698
	USE FROM Manifold_surface_mim;	-- ISO/TS 10303-1509

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N7062 - ISO/TS 10303-1749 Styled curve - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5513
*)

SCHEMA Styled_curve_mim;
USE FROM Colour_mim;    -- ISO/TS 10303-1002

USE FROM Elemental_geometric_shape_mim;    -- ISO/TS 10303-1004

USE FROM external_reference_schema(pre_defined_item); -- ISO 10303-41

USE FROM representation_schema
		(mapped_item,
		parametric_representation_context);
		
USE FROM presentation_appearance_schema
		(curve_style,
		curve_style_font,
		curve_style_font_pattern,
		curve_style_font_and_scaling,
		draughting_pre_defined_curve_font,
		externally_defined_curve_font,
		fill_area_style_colour,		
		pre_defined_curve_font,
		presentation_style_assignment,
		styled_item);
				
  ENTITY solid_curve_font
    SUBTYPE OF (pre_defined_curve_font);
  END_ENTITY; 

  ENTITY user_defined_curve_font
    SUBTYPE OF (curve_style_font, mapped_item);
  END_ENTITY;
	
END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6939 - ISO/TS 10303-1800 Support resource - EXPRESS MIM
*)
SCHEMA Support_resource_mim;
	USE FROM support_resource_schema;
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N6268 - ISO/TS 10303-1110 Surface conditions - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N5516
*)

SCHEMA Surface_conditions_mim;

USE FROM Dimension_tolerance_mim;

USE FROM Generic_material_aspects_mim;

USE FROM Part_view_definition_mim;

USE FROM Value_with_unit_extension_mim;

USE FROM application_context_schema(
	application_context_element);
	
USE FROM material_property_definition_schema(
	material_designation);

USE FROM product_property_definition_schema(
	property_definition);

USE FROM product_property_representation_schema(
	property_definition_representation);

  ENTITY contact_ratio_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: (SIZEOF ( SELF.items ) =1 ) AND
            (SIZEOF ( QUERY ( i <* SELF.items | 
             (SIZEOF(['QUALIFIED_MEASURE_SCHEMA.'+ 'MEASURE_REPRESENTATION_ITEM' , 'EXTENDED_MEASURE_REPRESENTATION_MIM.' + 'VALUE_RANGE']* TYPEOF(i)) = 1) AND
             (i.name = 'ratio value'))) = 1);
      WR2: (SIZEOF ( QUERY ( pdr <* USEDIN ( SELF ,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+ 'USED_REPRESENTATION' ) |
                   pdr\property_definition_representation.name = 'contact ratio reference' ) ) = 1 ) AND 
           (SIZEOF ( QUERY (pdr <* USEDIN ( SELF ,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+ 'USED_REPRESENTATION' ) |
           (pdr\property_definition_representation.name = 'contact ratio reference' ) AND
           ('PRODUCT_DEFINITION_SCHEMA.'+ 'PRODUCT_DEFINITION' IN TYPEOF ( pdr\property_definition_representation.definition\property_definition.definition))
           )) = 1);
      WR3:(SIZEOF(USEDIN(SELF ,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+ 'USED_REPRESENTATION')) = 1) AND 
          (SIZEOF ( QUERY ( pdr <* USEDIN ( SELF ,
          'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
          'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (pdr.definition ,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+'GENERAL_PROPERTY_ASSOCIATION.'+
          'DERIVED_DEFINITION' ) | ( 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+ 'GENERAL_PROPERTY' IN TYPEOF (gpa\general_property_association.base_definition ) ) AND
          (gpa\general_property_association.base_definition\general_property.name ='surface_condition')
          )) = 1
         )) = 1);
  END_ENTITY;

  ENTITY hardness_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: ( {2<= SIZEOF ( SELF.items ) <=4} ) AND ( SIZEOF ( QUERY (
        i <* items | ( 'QUALIFIED_MEASURE_SCHEMA.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
        i.name IN [ 'measuring method' , 'measuring position' ] ) )
        ) + SIZEOF ( QUERY ( i <* items | ( SIZEOF (
        ['QUALIFIED_MEASURE_SCHEMA.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'EXTENDED_MEASURE_REPRESENTATION_MIM.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )
        AND ( i.name IN ['depth' , 'hardness'] ) ) ) = SIZEOF (
        SELF.items ) ) ;
      WR2: SIZEOF ( QUERY ( i <* SELF.items | i.name =
        'measuring method' ) ) =1;
      WR3: SIZEOF ( QUERY ( i <* SELF.items | i.name ='hardness' ) )
        =1;
      WR4: SIZEOF ( QUERY ( i <* SELF.items | i.name =
        'measuring position' ) ) <=1;
      WR5: SIZEOF ( QUERY ( i <* SELF.items | i.name ='depth' ) )
        <=1;
      WR6: ( SIZEOF ( USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr.definition ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+ 'GENERAL_PROPERTY' IN TYPEOF ( gpa.base_definition ) ) AND
        ( gpa\general_property_association.base_definition\general_property.name ='surface_condition' ) ) ) =1 )
        ) =1 ) ;
  END_ENTITY;

  ENTITY surface_texture_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
        ['QUALIFIED_MEASURE_SCHEMA.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'EXTENDED_MEASURE_REPRESENTATION_MIM.'+ 'VALUE_RANGE' , 'QUALIFIED_MEASURE_SCHEMA.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) <>1 ) )
        =0;
      WR2: ( SIZEOF ( QUERY ( i <* SELF.items | 'QUALIFIED_MEASURE_SCHEMA.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) =1 )
        AND ( SIZEOF ( QUERY ( i <* SELF.items | (
        'QUALIFIED_MEASURE_SCHEMA.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN
        TYPEOF ( i ) ) AND ( i.name = 'measuring method' ) ) ) =1 );
      WR3: SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
        ['QUALIFIED_MEASURE_SCHEMA.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'EXTENDED_MEASURE_REPRESENTATION_MIM.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) )
        >0;
      WR4: ( SIZEOF ( USEDIN ( SELF ,
        'REPRESENTATION_SCHEMA.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_1' ) ) <=1 ) AND ( SIZEOF ( USEDIN ( SELF ,
        'REPRESENTATION_SCHEMA.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_2' ) ) =0 ) AND ( SIZEOF ( QUERY ( rr <* USEDIN ( SELF
        , 'REPRESENTATION_SCHEMA.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_1' ) | rr.rep_2.name = 'measuring direction' ) ) =
        SIZEOF ( USEDIN ( SELF ,
        'REPRESENTATION_SCHEMA.'+'REPRESENTATION_RELATIONSHIP.'+
        'REP_1' ) ) ) ;
      WR5: ( SIZEOF ( USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr.definition ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+ 'GENERAL_PROPERTY' IN TYPEOF ( gpa.base_definition ) ) AND
        ( gpa\general_property_association.base_definition\general_property.name ='surface_condition' ) ) ) =1 )
        ) =1 ) ;
  END_ENTITY;

  ENTITY tactile_appearance_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
        ['QUALIFIED_MEASURE_SCHEMA.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'EXTENDED_MEASURE_REPRESENTATION_MIM.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) <>1 )) =0;
      WR2: SIZEOF ( QUERY ( i <* SELF.items | name ='depth' ) ) <=1;
      WR3: ( SIZEOF ( USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr.definition ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+ 'GENERAL_PROPERTY' IN TYPEOF ( gpa.base_definition ) ) AND
        ( gpa\general_property_association.base_definition\general_property.name ='surface_condition' ) ) ) =1 )) =1 ) ;
  END_ENTITY;

  ENTITY visual_appearance_representation
    SUBTYPE OF (representation);
    WHERE 
      WR1: ( {3<= SIZEOF ( SELF.items ) <=9} ) AND ( SIZEOF ( QUERY (
        i <* items | ( 'QUALIFIED_MEASURE_SCHEMA.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
        i.name IN [ 'colour id' , 'colour name' , 'lustre' , 'pattern' , 'transparency', 'orientation'] ) ) 
        ) + SIZEOF ( QUERY ( i <* items | ( SIZEOF (
        ['QUALIFIED_MEASURE_SCHEMA.'+ 'MEASURE_REPRESENTATION_ITEM' ,
        'EXTENDED_MEASURE_REPRESENTATION_MIM.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )							
        AND ( i.name IN ['refraction index' , 'opacity'] ) ) 
        ) + SIZEOF ( QUERY ( i <* items | ( 
        'FILE_IDENTIFICATION_MIM.'+ 'DOCUMENT_FILE' IN TYPEOF ( i ) ) 
        AND ( i.name IN [ 'texture map' ] ) )	)
        = SIZEOF ( SELF.items ) );                                                  
      WR2: SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour id' )) =1;
      WR3: SIZEOF ( QUERY ( i <* SELF.items | i.name ='lustre' ) )=1;
      WR4: SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour name') ) <=1;
      WR5: SIZEOF ( QUERY ( i <* SELF.items | i.name ='pattern' ) )<=1;
      WR6: SIZEOF ( QUERY ( i <* SELF.items | i.name ='transparency') ) <=1;
      WR7: SIZEOF ( QUERY ( i <* SELF.items | i.name = 'texture map') ) <=1;
      WR8: SIZEOF ( QUERY ( i <* SELF.items | i.name ='refraction index' ) )<=1;
      WR9: SIZEOF ( QUERY ( i <* SELF.items | i.name ='opacity') ) <=1;
      WR10: SIZEOF ( QUERY ( i <* SELF.items | i.name ='orientation') ) <=1;
      WR11: ( SIZEOF ( USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
        <* USEDIN ( SELF ,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
        'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
        pdr.definition ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+'GENERAL_PROPERTY_ASSOCIATION.'+
        'DERIVED_DEFINITION' ) | ( 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.'+ 'GENERAL_PROPERTY' IN TYPEOF ( gpa.base_definition ) ) AND
        ( gpa\general_property_association.base_definition\general_property.name ='surface_condition' ) ) ) =1 )) =1 ) ;
  END_ENTITY;


  RULE restrict_representation_for_surface_condition FOR (property_definition_representation);
    WHERE
      WR1 : SIZEOF(QUERY(pdr <* property_definition_representation | 
        NOT surface_condition_correlation(pdr.definition, pdr.used_representation) ))=0;
  END_RULE;

  RULE restrict_treatment_result FOR (representation);
    LOCAL
      treatment_results: SET OF representation := [];
    END_LOCAL;
    treatment_results:= QUERY( r <* representation | 
	  (r.name = 'treatment result') );
    WHERE 
      WR1: (SIZEOF( QUERY( r <* treatment_results | (SIZEOF(r.items) > 2) )) = 0) AND
        (SIZEOF( QUERY( r <* treatment_results |
        (SIZEOF( QUERY( i <* r.items | 
         NOT ('QUALIFIED_MEASURE_SCHEMA.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i)) )) > 0) )) = 0); 
      WR2: SIZEOF( QUERY( r <* treatment_results | 
        (SIZEOF( QUERY( i <* r.items | i.name = 'result' )) = 0) )) = 0; 
      WR3: SIZEOF( QUERY( r <* treatment_results | 
        (SIZEOF( QUERY( i <* r.items | i.name = 'purpose' )) > 1) )) = 0; 
  END_RULE; 

  FUNCTION surface_condition_correlation (pd: property_definition; rep: representation): LOGICAL;
    CASE pd.name OF
      'visual appearance', 'tactile appearance', 'contact ratio', 'hardness', 'treatment result', 'surface texture' : 
	  RETURN(pd.name = rep.name);
      OTHERWISE : RETURN(UNKNOWN);
    END_CASE;
  END_FUNCTION;

  RULE material_for_coating_layer FOR (shape_aspect);
    LOCAL
      coating_layers: SET OF shape_aspect := [];
    END_LOCAL;
    coating_layers:= QUERY( r <* shape_aspect | 
	  (r.name = 'coating layer') );
    WHERE 
      WR1: SIZEOF( QUERY( r <* coating_layers |
	    SIZEOF(USEDIN(r , 'MATERIAL_PROPERTY_DEFINITION_SCHEMA.MATERIAL_DESIGNATION.DEFINITIONS'))<>1
        )) = 0; 
  END_RULE;

END_SCHEMA;
(*
  ISO TC184/SC4/WG12 N5519 - ISO/TS 10303-1321 Swept solid - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4823
*)

SCHEMA Swept_solid_mim;

USE FROM Topologically_bounded_surface_mim; -- ISO 10303-1511 

USE FROM geometry_schema  -- ISO 10303-42 
      (axis1_placement,
       plane);

USE FROM geometric_model_schema  -- ISO 10303-42 
      (swept_face_solid,
       revolved_face_solid,
       extruded_face_solid);

USE FROM measure_schema  -- ISO 10303-41 
    (plane_angle_measure,
     positive_length_measure);
 
USE FROM topology_schema  -- ISO 10303-42 
    (face_surface);
    
END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N5522 - ISO/TS 10303-1366 Tagged text representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5010
*)

SCHEMA Tagged_text_representation_mim;

USE FROM Foundation_representation_mim;    --  ISO/TS 10303-1006

USE FROM representation_schema(
 compound_representation_item,
 mapped_item);

TYPE string_representation_item_select = SELECT(
    descriptive_representation_item,
    included_text_block,
    structured_text_composition);
END_TYPE; 

ENTITY included_text_block
  SUBTYPE of (mapped_item);
  WHERE
   WR1 : 'TAGGED_TEXT_REPRESENTATION_MIM.STRUCTURED_TEXT_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
END_ENTITY;

ENTITY structured_text_composition
  SUBTYPE OF (compound_representation_item);
END_ENTITY;

ENTITY structured_text_representation
  SUBTYPE OF (representation);
  SELF\Representation.items : SET [1:?] OF string_representation_item_select; 
END_ENTITY;

ENTITY tagged_text_item
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

ENTITY tagged_text_format
  SUBTYPE OF (representation_context);
END_ENTITY;

ENTITY uniform_resource_identifier
  SUBTYPE OF (descriptive_representation_item);
END_ENTITY;

SUBTYPE_CONSTRAINT ttr_descriptive_representation_item_subtypes FOR descriptive_representation_item;
  ONEOF (tagged_text_item,
         uniform_resource_identifier);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7642 - ISO/CD-TS 10303-1819 Tessellated geometry - EXPRESS MIM*)

SCHEMA Tessellated_geometry_mim;

USE FROM Advanced_boundary_representation_mim;
USE FROM Basic_curve_mim;
USE FROM Basic_geometry_mim;
USE FROM Basic_geometric_topology_mim;
USE FROM Draughting_element_mim; -- ISO/TS 10303-1310
USE FROM Elemental_geometric_shape_mim;
USE FROM Elemental_topology_mim;
REFERENCE FROM representation_schema(using_representations);

USE FROM geometric_model_schema (
	edge_or_curve,
	face_or_surface,
	path_or_composite_curve,
	tessellated_edge_or_vertex,
	Tessellated_shape_representation,
	Tessellated_item,
	Repositioned_tessellated_item,
	Tessellated_geometric_set,
	Tessellated_solid,
	Tessellated_shell,
	Tessellated_wire,
	Tessellated_curve_set,
	Tessellated_structured_item,
	Tessellated_edge,
	Tessellated_connecting_edge,
	Tessellated_point_set,
	Tessellated_vertex,
	Tessellated_surface_set,
	Triangulated_surface_set,
	Complex_triangulated_surface_set,
	Tessellated_face,
	Triangulated_face,
	Complex_triangulated_face,
	Coordinates_list);

USE FROM draughting_element_schema (
    tessellated_annotation_occurrence);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N4201 - ISO/TS 10303-1751 Test requirement allocation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3625
*)


SCHEMA Test_requirement_allocation_mim;
	USE FROM Functional_assignment_to_part_mim;	-- ISO/TS 10303-1674
	USE FROM Requirement_decomposition_mim;	-- ISO/TS 10303-1740
	USE FROM Functional_usage_view_mim;	-- ISO/TS 10303-1705

TYPE tra_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH 
     (property_definition_representation,
     shape_aspect_relationship);
END_TYPE;

TYPE tra_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
   (product_definition_formation);
END_TYPE; 

	
END_SCHEMA;

(*
   ISO TC184/SC4/WG12 N4219 - ISO/TS 10303-1757 Test select product - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N3680
*)
SCHEMA Test_select_product_mim;

	USE FROM Product_replacement_mim;	-- ISO/TS 10303-1046

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N5525 - ISO/TS 10303-1136 Text appearance - EXPRESS MIM
Supersedes ISO TC184/SC4/WG12 N4775
*) 


SCHEMA Text_appearance_mim;

USE FROM Basic_geometry_mim;   -- ISO/TS 10303-1652

USE FROM presentation_appearance_schema   -- ISO 10303-46
  (box_height,
   box_width,
   box_slant_angle,
   box_rotate_angle,
   character_glyph_style_stroke,
   character_glyph_style_outline,
   text_style,
   text_style_with_spacing); 

USE FROM presentation_definition_schema (   -- ISO 10303-46
   composite_text_with_extent,
   composite_text_with_delineation,
   composite_text_with_blanking_box,
   defined_character_glyph,
   pre_defined_character_glyph,
   externally_defined_character_glyph,
   text_literal,
   text_literal_with_extent,
   text_literal_with_delineation,
   text_literal_with_blanking_box); 

USE FROM presentation_resource_schema   -- ISO 10303-46
  (colour_rgb,
   draughting_pre_defined_text_font,
   externally_defined_text_font,
   font_select,
   pre_defined_colour,
   pre_defined_text_font); 

  RULE text_font_usage FOR 
      (externally_defined_text_font,pre_defined_text_font);
    WHERE
      WR1: SIZEOF (QUERY (pdtf <* pre_defined_text_font | SIZEOF (USEDIN (pdtf, 'PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL.FONT')) = 0 )) = 0;
      WR2: SIZEOF (QUERY (edtf <* externally_defined_text_font | SIZEOF (USEDIN (edtf, 'PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL.FONT')) = 0 )) = 0;
  END_RULE; 

END_SCHEMA;  
(*
   ISO TC184/SC4/WG12 N7078 - ISO/TS 10303-1750 Text representation - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5528
*)

SCHEMA Text_representation_mim;

USE FROM Text_appearance_mim; -- ISO/TS 10303-1136
USE FROM Associative_text_mim; -- ISO/TS 10303-1132 
	
USE FROM presentation_definition_schema(
	annotation_text_character,
	text_literal);
		
USE FROM presentation_resource_schema(
    character_glyph_font_usage,
    character_glyph_symbol,
    character_glyph_symbol_outline,
    character_glyph_symbol_stroke,
    generic_character_glyph_symbol,
	text_font,
	text_font_family,
	text_font_in_family);	

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7041 - ISO/TS 10303-1752 Thermal network definition - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N6553
*)


SCHEMA Thermal_network_definition_mim;
  USE FROM Component_feature_mim; -- ISO/TS 10303-1657
  USE FROM Network_functional_design_view_mim;	-- ISO/TS 10303-1704
  USE FROM Non_feature_shape_element_mim; -- ISO/TS 10303-1706

ENTITY thermal_network
  SUBTYPE OF (functional_unit);
END_ENTITY;

ENTITY thermal_network_node_definition
  SUBTYPE OF (network_node_definition);
END_ENTITY;
	
END_SCHEMA;

(*
  ISO TC184/SC4/WG12 N5531 - ISO/TS 10303-1320 Thickened face solid - EXPRESS MIM
  Supersedes ISO TC184/SC4/WG12 N4826
*)

SCHEMA Thickened_face_solid_mim;

USE FROM Topologically_bounded_surface_mim; -- ISO/TS 10303-1511

USE FROM solid_shape_element_schema  -- ISO 10303-111
      (thickened_face_solid); 
    
END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N2119 - ISO/TS 10303-1065 Time interval - EXPRESS MIM
*)

SCHEMA Time_interval_mim; 

USE FROM date_time_schema   -- ISO 10303-41
  (time_interval,
   time_interval_relationship,
   time_interval_with_bounds); 

USE FROM Event_mim;    -- ISO/TS 10303-1064

USE FROM Value_with_unit_mim;    -- ISO/TS 10303-1054


END_SCHEMA;  -- Time_interval_mim

(*
 ISO TC184/SC4/WG12 N2121 - ISO/TS 10303-1365 Time interval assignment - EXPRESS MIM
*) 


SCHEMA Time_interval_assignment_mim; 

USE FROM date_time_schema   -- ISO 10303-41
  (time_interval_role); 

USE FROM management_resources_schema   -- ISO 10303-41
  (time_interval_assignment); 

USE FROM Time_interval_mim;    -- ISO/TS 10303-1065


TYPE time_interval_item = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY applied_time_interval_assignment
  SUBTYPE OF (time_interval_assignment);
  items : SET[0:?] OF time_interval_item;
END_ENTITY;

END_SCHEMA;  -- Time_interval_assignment_mim

(*
 ISO TC184/SC4/WG12 N7200 - ISO/TS 10303-1511 Topologically bounded surface - EXPRESS MIM
*)

SCHEMA Topologically_bounded_surface_mim;

USE FROM Basic_geometric_topology_mim;
USE FROM B_spline_geometry_mim;
USE FROM aic_topologically_bounded_surface;

END_SCHEMA;

(*
 ISO TC184/SC4/WG12 N7239 - ISO/TS 10303-1054 Value with unit - EXPRESS MIM
*)

SCHEMA Value_with_unit_mim;

USE FROM measure_schema;

USE FROM representation_schema
 (uncertainty_measure_with_unit);

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N5534 - ISO/TS 10303-1753 Value with unit extension - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N4977
*)


SCHEMA Value_with_unit_extension_mim;
	USE FROM Value_with_unit_mim;	-- ISO/TS 10303-1054

	USE FROM iso13584_generic_expressions_schema
		(environment,
		generic_literal,
		variable_semantics);

	REFERENCE FROM measure_schema(derive_dimensional_exponents); -- ISO/TS 10303-41 

ENTITY expression_conversion_based_unit
  SUBTYPE OF (context_dependent_unit, variable_semantics); 
INVERSE
  associated_variable_environment: environment FOR semantics; 
END_ENTITY;

ENTITY dielectric_constant_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

ENTITY loss_tangent_measure_with_unit
  SUBTYPE OF (ratio_measure_with_unit);
END_ENTITY;

ENTITY thermal_resistance_measure_with_unit
  SUBTYPE OF (measure_with_unit);
WHERE
  WR1: 'VALUE_WITH_UNIT_EXTENSION_MIM.THERMAL_RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY thermal_resistance_unit
  SUBTYPE OF (derived_unit);
 WHERE
   WR1: derive_dimensional_exponents(SELF) = 
        dimensional_exponents ( -1.0, -1.0, -3.0, 0.0, 1.0, 0.0, 0.0 );
END_ENTITY;

ENTITY polar_complex_number_literal
  SUBTYPE OF (generic_literal);
  radius    : REAL;
  angle     : REAL;
WHERE
  WR1: radius >= 0;
  WR2: { 0 <= angle < 2*PI };
END_ENTITY;

ENTITY scattering_parameter
 SUBTYPE OF (polar_complex_number_literal);
WHERE
  WR1: SIZEOF(TYPEOF(SELF) - (TYPEOF(SELF\polar_complex_number_literal ||
       SELF\scattering_parameter))) = 0;
END_ENTITY;

END_SCHEMA;


(*
   ISO TC184/SC4/WG12 N6556 - ISO/TS 10303-1754 Via component - EXPRESS MIM
   Supersedes ISO TC184/SC4/WG12 N5822
*)


SCHEMA Via_component_mim;
	USE FROM Interconnect_module_connection_routing_mim;	-- ISO/TS 10303-1684
	USE FROM Layered_interconnect_module_design_mim;	-- ISO/TS 10303-1698

  ENTITY blind_via
    ABSTRACT SUPERTYPE OF (ONEOF (non_conductive_base_blind_via,
                                  plated_conductive_base_blind_via))
    SUBTYPE OF (via);
  END_ENTITY;

  ENTITY buried_via
    SUBTYPE OF (via);
  END_ENTITY;
  
  ENTITY interfacial_connection
    SUBTYPE OF (via);
  END_ENTITY;

  ENTITY non_conductive_base_blind_via
    SUBTYPE OF (blind_via);
  END_ENTITY;

  ENTITY plated_conductive_base_blind_via
    SUBTYPE OF (blind_via);
  END_ENTITY;

 SUBTYPE_CONSTRAINT via_subtypes FOR via;   
 	(ONEOF (blind_via,
 	buried_via,
 	interfacial_connection));
 END_SUBTYPE_CONSTRAINT;  
	
END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N2626 - ISO/TS 10303-1347 Wireframe 2d - EXPRESS MIM
 Supersedes ISO TC184/SC4/WG12 N1776
*)

SCHEMA Wireframe_2d_mim;

USE FROM Elemental_geometric_shape_mim;

USE FROM aic_geometrically_bounded_2d_wireframe;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N1154 - ISO/TS 10303-1043 Work order - EXPRESS MIM
*)

SCHEMA Work_order_mim; 

USE FROM Activity_mim;    -- ISO/TS 10303-1047

USE FROM Work_request_mim;    -- ISO/TS 10303-1042

USE FROM action_schema   -- ISO 10303-41
  (action_directive,
   directed_action); 

END_SCHEMA; 
(*
 ISO TC184/SC4/WG12 N1151 - ISO/TS 10303-1042 Work request - EXPRESS MIM
*)

SCHEMA Work_request_mim;

USE FROM Activity_method_mim;    -- ISO/TS 10303-1049

USE FROM action_schema   -- ISO 10303-41
  (action_request_solution,
   action_request_status,
   versioned_action_request,
   versioned_action_request_relationship); 

USE FROM management_resources_schema   -- ISO 10303-41
   (action_request_assignment);


TYPE action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE;

ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1 : ?] OF action_request_item;
END_ENTITY;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA action_schema;
  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    get_name_value, 
    id_attribute, 
    id_attribute_select,
    name_attribute,
    name_attribute_select);
    
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  
  TYPE as_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    action_request_solution);
  END_TYPE;
  TYPE as_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    action);
  END_TYPE;
  TYPE as_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    action_request_solution);
  END_TYPE;
  
  TYPE supported_item = SELECT (action_directive, action, action_method);
  END_TYPE;

  ENTITY action;
    name : label;
    description : OPTIONAL text;
    chosen_method : action_method;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_directive;
    name : label;
    description : OPTIONAL text;
    analysis : text;
    comment : text;
    requests : SET [1:?] OF versioned_action_request;
  END_ENTITY;

  ENTITY action_method;
    name : label;
    description : OPTIONAL text;
    consequence : text;
    purpose : text;
  END_ENTITY;

  ENTITY action_method_relationship;
    name : label;
    description : OPTIONAL text;
    relating_method : action_method;
    related_method : action_method;
  END_ENTITY;

  ENTITY action_relationship;
    name : label;
    description : OPTIONAL text;
    relating_action : action;
    related_action : action;
  END_ENTITY;

  ENTITY action_request_solution;
    method : action_method;
    request : versioned_action_request;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_request_status;
    status : label;
    assigned_request : versioned_action_request;
  END_ENTITY;

  ENTITY action_resource;
    name : label;
    description : OPTIONAL text;
    usage : SET [1:?] OF supported_item;
    kind : action_resource_type;
  END_ENTITY;

  ENTITY action_resource_relationship;
    name : label;
    description : OPTIONAL text;
    relating_resource : action_resource;
    related_resource : action_resource;
  END_ENTITY;

  ENTITY action_resource_type;
    name : label;
  END_ENTITY;

  ENTITY action_status;
    status : label;
    assigned_action : executed_action;
  END_ENTITY;

  ENTITY directed_action
    SUBTYPE OF (executed_action);
    directive : action_directive;
  END_ENTITY;

  ENTITY executed_action
    SUBTYPE OF (action);
  END_ENTITY;

  ENTITY versioned_action_request;
    id : identifier;
    version : OPTIONAL label;
    purpose : text;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY versioned_action_request_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_versioned_action_request : versioned_action_request;
    related_versioned_action_request : versioned_action_request;
  END_ENTITY;

  FUNCTION acyclic_action_method_relationship (relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_method_relationship;
    END_LOCAL;

    IF relation.relating_method IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'ACTION_SCHEMA.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_relationship (relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_relationship;
    END_LOCAL;

    IF relation.relating_action IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'ACTION_SCHEMA.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_action_resource_relationship (relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF action_resource_relationship;
    END_LOCAL;

    IF relation.relating_resource IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'ACTION_SCHEMA.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_versioned_action_request_relationship (relation : versioned_action_request_relationship; relatives : SET OF versioned_action_request; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF versioned_action_request_relationship;
    END_LOCAL;

    IF relation.relating_versioned_action_request IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'ACTION_SCHEMA.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
SCHEMA aic_advanced_brep;
  
USE FROM aic_topologically_bounded_surface;
 USE FROM geometry_schema ( cartesian_transformation_operator_3d);
 USE FROM geometric_model_schema ( manifold_solid_brep, brep_with_voids);
 REFERENCE FROM geometric_model_schema ( msb_shells);
 USE FROM topology_schema ( closed_shell, connected_face_set, oriented_closed_shell);
 USE FROM representation_schema ( mapped_item);
 USE FROM product_property_representation_schema ( shape_representation);
  
ENTITY advanced_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP', 'AIC_ADVANCED_BREP.FACETED_BREP', 'AIC_ADVANCED_BREP.MAPPED_ITEM', 'AIC_ADVANCED_BREP.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP', 'AIC_ADVANCED_BREP.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* SELF.items| ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(msb)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ('AIC_ADVANCED_BREP.ADVANCED_FACE' IN TYPEOF (fcs)) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AIC_ADVANCED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AIC_ADVANCED_BREP.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_ADVANCED_BREP.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
END_SCHEMA;
 
(*
ISO TC184/SC4/WG12 N6195 - ISO 10303-520 Associative draughting elements - EXPRESS
*) 

SCHEMA aic_associative_draughting_elements;

 USE FROM measure_schema                            -- ISO 10303-41
  (derived_unit,
  named_unit);

 USE FROM product_property_definition_schema        -- ISO 10303-41
  (property_definition,
  shape_aspect, 
  shape_aspect_relationship);

 USE FROM product_property_representation_schema    -- ISO 10303-41
   (shape_definition_representation);

 REFERENCE FROM support_resource_schema             -- ISO 10303-41
  (bag_to_set);

 USE FROM geometry_schema             -- ISO 10303-42
  (axis2_placement);

 USE FROM representation_schema                     -- ISO 10303-43
  (mapped_item,
  representation,
  representation_item,
  representation_map);

 REFERENCE FROM representation_schema               -- ISO 10303-43
  (using_representations);

 USE FROM qualified_measure_schema                  -- ISO 10303-45
  (measure_representation_item);

 USE FROM presentation_appearance_schema            -- ISO 10303-46
  (curve_style,
  styled_item,
  invisibility_context);
 
 USE FROM presentation_definition_schema            -- ISO 10303-46
  (annotation_curve_occurrence,
  annotation_fill_area_occurrence,
  annotation_occurrence,
  annotation_occurrence_relationship,
  annotation_symbol_occurrence,
  annotation_text_occurrence,
  text_literal);

 USE FROM presentation_organization_schema            -- ISO 10303-46
  (camera_model,
  annotation_representation_select); 

 USE FROM shape_dimension_schema                    -- ISO 10303-47
  (dimensional_characteristic_representation,
  shape_dimension_representation);

 USE FROM draughting_element_schema                 -- ISO 10303-101
  (annotation_plane,
  draughting_callout,
  leader_curve,
  projection_curve);

  TYPE aade_annotation_representation_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON annotation_representation_select WITH
    (draughting_model); 
  END_TYPE;
  
  TYPE aade_invisibility_context = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON invisibility_context WITH
    (draughting_model); 
  END_TYPE;

  TYPE draughting_model_item_select = SELECT
    (mapped_item,
     styled_item,
     axis2_placement,
     camera_model,
     draughting_callout);
  END_TYPE;  

  ENTITY annotation_occurrence_associativity
    SUBTYPE OF (annotation_occurrence_relationship);
      WHERE
        WR1:  SIZEOF (TYPEOF (SELF.related_annotation_occurrence) *
          ['AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.ANNOTATION_FILL_AREA_OCCURRENCE',
           'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.PROJECTION_CURVE',
           'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.LEADER_CURVE']) = 1;
  END_ENTITY;

  ENTITY dimension_text_associativity
    SUBTYPE OF (text_literal, mapped_item);
      WHERE
        WR1:  ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_DIMENSION_REPRESENTATION'
          IN TYPEOF (SELF\mapped_item.
                          mapping_source.mapped_representation));
        WR2:  ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_CALLOUT'
          IN TYPEOF (SELF\mapped_item.mapping_target));
        WR3:  SIZEOF (QUERY (ato <* QUERY (si <* 
          USEDIN (SELF, 'PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM.ITEM') |
            ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
              IN TYPEOF(si))) |
          NOT (SIZEOF( QUERY (dc <*
             USEDIN (ato, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                          'DRAUGHTING_CALLOUT.CONTENTS') |
               ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_CALLOUT'
             IN TYPEOF (dc)))
            * [SELF\mapped_item.mapping_target]) = 1)
          )) = 0;
  END_ENTITY;

  ENTITY draughting_model
    SUBTYPE OF (representation);
      SELF\representation.items : SET[1:?] OF draughting_model_item_select;
    UNIQUE
      UR1:  SELF\representation.name;
    WHERE
      WR1:  SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
         ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.MAPPED_ITEM' IN TYPEOF(it))) |
         NOT (
           SIZEOF (['AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_REPRESENTATION',
                    'AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_MODEL'] *
              TYPEOF (mi\mapped_item.mapping_source.
                      mapped_representation)) = 1
        ))) = 0;
     WR2:  SIZEOF (QUERY (smi <* QUERY (si <* QUERY (it <* SELF.items |
        ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.STYLED_ITEM' IN TYPEOF(it))) |
        ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.MAPPED_ITEM' IN
            TYPEOF(si\styled_item.item))) |
        (NOT (('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.SHAPE_REPRESENTATION' IN
                 TYPEOF(smi\styled_item.item\mapped_item.
                        mapping_source.mapped_representation))
            AND
             (SIZEOF (QUERY (sty <* smi\styled_item.styles |
               (NOT (SIZEOF (QUERY (psa <* sty.styles |
                       (NOT ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.CURVE_STYLE' IN TYPEOF(psa))))) = 1
             )))) = 1)))
        )) = 0;
  END_ENTITY;

  ENTITY shape_aspect_associativity
    SUBTYPE OF (shape_aspect_relationship);
    WHERE
      WR1:  SELF.relating_shape_aspect.product_definitional;
      WR2:  NOT (SELF.related_shape_aspect.product_definitional);
  END_ENTITY;

  FUNCTION check_associative_shape_aspects
    (sdr : shape_definition_representation) : BOOLEAN;
    LOCAL
      sr1, sr2 : SET OF representation;
      dm, pv   : SET OF representation;
    END_LOCAL;
    -- Check if the representation contains only two items
    IF (SIZEOF (sdr.used_representation.items) <> 2) THEN
      RETURN (FALSE);
    END_IF;
    -- Find the representations that use each item
    sr1 := using_representations(sdr.used_representation.items[1]);
    sr2 := using_representations(sdr.used_representation.items[2]);
    -- Find the representations in which item 1 representations are mapped
    REPEAT i := 1 TO HIINDEX(sr1);
      dm := representations_mapped_into(sr1[i]);
      REPEAT j := 1 TO HIINDEX(dm);
        IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_MODEL' IN TYPEOF(dm[j]))
        THEN
          IF (dm[j] IN sr2) THEN RETURN (TRUE);
          END_IF;
          -- Find the views that the draughting model is mapped into
          pv := representations_mapped_into(dm[j]);
          REPEAT k := 1 TO HIINDEX(pv);
            IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.PRESENTATION_VIEW' IN TYPEOF(pv[k]))
            THEN
              IF (pv[k] IN sr2) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    -- Find the representations in which item 2 representations are mapped
    REPEAT i := 1 TO HIINDEX(sr2);
      dm := representations_mapped_into(sr2[i]);
      REPEAT j := 1 TO HIINDEX(dm);
        IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.DRAUGHTING_MODEL' IN TYPEOF(dm[j]))
        THEN
          IF (dm[j] IN sr1) THEN RETURN (TRUE);
          END_IF;
          -- Find the views that the draughting model is mapped into
          pv := representations_mapped_into(dm[j]);
          REPEAT k := 1 TO HIINDEX(pv);
            IF ('AIC_ASSOCIATIVE_DRAUGHTING_ELEMENTS.PRESENTATION_VIEW' IN TYPEOF(pv[k]))
            THEN
              IF (pv[k] IN sr1) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION;

  FUNCTION representations_mapped_into 
    (rep : representation) : SET of representation;
    LOCAL
      results : SET OF representation := [];
      rm      : SET OF representation_map;
      mi      : SET OF mapped_item := [];
    END_LOCAL;
    -- Find set of representation_maps which specify the representation
    rm := bag_to_set(USEDIN(rep, 'REPRESENTATION_SCHEMA.' +
                      'REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
    -- Find the set of mapped_items that use each representation_map
    REPEAT i := 1 TO HIINDEX(rm);
      mi := mi + rm[i].map_usage;
    END_REPEAT;
    -- Find the set of representations that use each mapped_item
    REPEAT j := 1 TO HIINDEX(mi);
      results := results + USEDIN(mi[j],'REPRESENTATION_SCHEMA.' +
                                        'REPRESENTATION.ITEMS');
    END_REPEAT;
    RETURN(results);
  END_FUNCTION;

END_SCHEMA;  
SCHEMA aic_csg;
  
USE FROM aic_advanced_brep;
 USE FROM aic_faceted_brep;
 USE FROM geometric_model_schema ( block, boolean_operand, boolean_operator, boolean_result, box_domain, boxed_half_space, csg_primitive, csg_select, csg_solid, extruded_face_solid, half_space_solid, revolved_face_solid, right_angular_wedge, right_circular_cone, right_circular_cylinder, solid_replica, sphere, torus);
  
ENTITY csg_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_CSG.CSG_SOLID', 'AIC_CSG.MAPPED_ITEM', 'AIC_CSG.AXIS2_PLACEMENT_3D', 'AIC_CSG.SOLID_REPLICA', 'AIC_CSG.REVOLVED_FACE_SOLID', 'AIC_CSG.EXTRUDED_FACE_SOLID' ] * TYPEOF (it)) <> 1) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_CSG.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_CSG.CSG_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( sr <* 
QUERY ( it <* SELF.items| ('AIC_CSG.SOLID_REPLICA' IN TYPEOF (it)) )| ( SIZEOF ([ 'AIC_CSG.CSG_SOLID', 'AIC_CSG.REVOLVED_FACE_SOLID', 'AIC_CSG.EXTRUDED_FACE_SOLID' ] * TYPEOF (sr\solid_replica.parent_solid)) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ('AIC_CSG.AXIS2_PLACEMENT_3D' IN TYPEOF (it)) )) > 0;
 END_ENTITY ;
END_SCHEMA;
 
(*
ISO TC184/SC4/WG12 N6207 - ISO 10303-523 Curve swept solid - EXPRESS
Supersedes ISO TC184/SC4/WG12 N5260
*)

 SCHEMA aic_curve_swept_solid;
 
  USE FROM measure_schema; -- ISO 10303-41

  USE FROM geometry_schema  -- ISO 10303-42
	(axis2_placement_2d,
    axis2_placement_3d,
    bezier_curve,
    bezier_surface,
    b_spline_curve_with_knots,
    b_spline_curve,
    b_spline_surface,
    b_spline_surface_with_knots,
	cartesian_point,
    circle,
    composite_curve_on_surface,
    conical_surface,
    cylindrical_surface,
    degenerate_toroidal_surface,
    direction,
    ellipse,
    geometric_representation_context,
    hyperbola,
    line,
    parabola,
    pcurve,
    plane,
    polyline,
    quasi_uniform_curve,
    quasi_uniform_surface,
	rational_b_spline_curve,
    rational_b_spline_surface,
    spherical_surface,
    surface_curve,
    surface_of_linear_extrusion,
    surface_of_revolution,
    swept_surface,
	trimmed_curve,		
    toroidal_surface,
    uniform_curve,
    uniform_surface,
    vector);

  USE FROM geometric_model_schema  -- ISO  10303-42
      (extruded_area_solid,
       revolved_area_solid,
       surface_curve_swept_area_solid,
       swept_disk_solid);

  USE FROM representation_schema(mapped_item);   -- ISO  10303-43

  USE FROM product_property_representation_schema   -- ISO  10303-41
      (shape_representation);

  ENTITY curve_swept_solid_shape_representation
    SUBTYPE OF (shape_representation);
  WHERE
  WR1: SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_CURVE_SWEPT_SOLID.SWEPT_AREA_SOLID',
                'AIC_CURVE_SWEPT_SOLID.SWEPT_DISK_SOLID',
                'AIC_CURVE_SWEPT_SOLID.MAPPED_ITEM',
                'AIC_CURVE_SWEPT_SOLID.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_CURVE_SWEPT_SOLID.SWEPT_AREA_SOLID',
                'AIC_CURVE_SWEPT_SOLID.SWEPT_DISK_SOLID',
          'AIC_CURVE_SWEPT_SOLID.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3: SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AIC_CURVE_SWEPT_SOLID.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('AIC_CURVE_SWEPT_SOLID.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR4: SIZEOF (QUERY (scsas <* QUERY (it <* SELF.items |
        'AIC_CURVE_SWEPT_SOLID.SURFACE_CURVE_SWEPT_AREA_SOLID' IN
              TYPEOF(it)) |
          NOT(('AIC_CURVE_SWEPT_SOLID.SURFACE_CURVE' IN
                 TYPEOF(scsas\surface_curve_swept_area_solid.directrix)) OR
                   ('AIC_CURVE_SWEPT_SOLID.PCURVE' IN
                   TYPEOF(scsas\surface_curve_swept_area_solid.directrix))))) = 0;
  END_ENTITY;

  ENTITY ruled_surface_swept_area_solid
    SUBTYPE OF(surface_curve_swept_area_solid);
  WHERE
  WR1: ('AIC_CURVE_SWEPT_SOLID.B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface)) AND
         (SELF.reference_surface\b_spline_surface.u_degree = 1);         
  WR2: ('AIC_CURVE_SWEPT_SOLID.PCURVE' IN TYPEOF(SELF.directrix)) OR
        (('AIC_CURVE_SWEPT_SOLID.B_SPLINE_CURVE' IN TYPEOF(SELF.directrix\surface_curve.curve_3d))
         AND
         (SELF.directrix\surface_curve.curve_3d\b_spline_curve.degree =
         SELF.reference_surface\b_spline_surface.v_degree));
  END_ENTITY;

END_SCHEMA; -- end AIC_CURVE_SWEPT_SOLID SCHEMA
(*
ISO TC184/SC4/WG12 N6165 - ISO 10303-504 Draughting annotation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N5248
*)

SCHEMA aic_draughting_annotation;

USE FROM draughting_element_schema	-- ISO 10303-101
  (draughting_callout,
   terminator_symbol);

USE FROM geometry_schema	-- ISO 10303-42
  (axis2_placement_2d,
   geometric_representation_context);

REFERENCE FROM geometry_schema	-- ISO 10303-42
  (axis2_placement);

USE FROM measure_schema	-- ISO 10303-41
  (conversion_based_unit,
   derived_unit,
   global_unit_assigned_context,
   length_measure_with_unit,
   length_unit,
   measure_with_unit,
   named_unit,
   plane_angle_unit,
   plane_angle_measure_with_unit,
   si_unit);
USE FROM presentation_appearance_schema	-- ISO 10303-46
  (box_height,
   box_rotate_angle,
   box_slant_angle,
   box_width,
   context_dependent_invisibility,
   curve_style,
   curve_style_font,
   externally_defined_curve_font,
   externally_defined_hatch_style,
   externally_defined_tile_style,
   fill_area_style,
   fill_area_style_colour,
   fill_area_style_hatching,
   fill_area_style_tile_symbol_with_style,
   fill_area_style_tiles,
   null_style,
   pre_defined_curve_font,
   presentation_style_by_context,
   symbol_colour,
   symbol_style,
   text_style,
   text_style_for_defined_font,
   text_style_with_box_characteristics,
   text_style_with_mirror,
   text_style_with_spacing);

USE FROM presentation_definition_schema	-- ISO 10303-46
  (annotation_curve_occurrence,
   annotation_fill_area,
   annotation_fill_area_occurrence,
   annotation_occurrence,
   annotation_symbol,
   annotation_symbol_occurrence,
   annotation_text_occurrence,
   composite_text,
   composite_text_with_associated_curves,
   composite_text_with_blanking_box,
   composite_text_with_extent,
   defined_symbol,
   externally_defined_symbol,
   pre_defined_symbol,
   symbol_representation,
   symbol_representation_map,
   text_alignment,
   text_literal,
   text_literal_with_associated_curves,
   text_literal_with_blanking_box,
   text_literal_with_delineation,
   text_literal_with_extent);

USE FROM presentation_resource_schema	-- ISO 10303-46
  (colour_rgb,
   externally_defined_text_font,
   font_select,
   pre_defined_colour,
   pre_defined_text_font);

USE FROM representation_schema	-- ISO 10303-43
  (mapped_item,
   representation,
   representation_item);

TYPE draughting_subfigure_representation_item = SELECT (
	annotation_occurrence,
	draughting_callout,
	axis2_placement);
END_TYPE;

TYPE draughting_symbol_representation_item = SELECT (
	annotation_curve_occurrence,
	annotation_symbol_occurrence,
	annotation_fill_area_occurrence,
	annotation_text_occurrence,
	axis2_placement);
END_TYPE;

ENTITY annotation_subfigure_occurrence
  SUBTYPE OF (annotation_symbol_occurrence);
WHERE
  WR1: SIZEOF (QUERY (sty <* SELF.styles |
         NOT (SIZEOF (sty.styles) = 1)
       )) = 0;
  WR2: SIZEOF (QUERY (sty <* SELF.styles |
         NOT ('AIC_DRAUGHTING_ANNOTATION.NULL_STYLE'
               IN TYPEOF (sty.styles[1]))       ))=0;
  WR3: ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL'
           IN TYPEOF (SELF.item));
  WR4: ('AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_SUBFIGURE_REPRESENTATION'
           IN TYPEOF
           (SELF.item\mapped_item.mapping_source.mapped_representation));
END_ENTITY;

ENTITY draughting_annotation_occurrence
  SUBTYPE OF (annotation_occurrence);
WHERE
  WR1:	-- curve_has_curve_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
         AND ('AIC_DRAUGHTING_ANNOTATION.CURVE_STYLE'
                 IN TYPEOF (sty.styles[1]))) )) = 0);
  WR2:	-- fill_area_has_fill_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
      NOT ((SIZEOF (sty.styles) = 1)
        AND ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
  WR3:	-- styled_fill_boundaries:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (bound <*
                     SELF.item\annotation_fill_area.boundaries |
       NOT (SIZEOF (QUERY (si <*
                   USEDIN (bound, 'PRESENTATION_APPEARANCE_SCHEMA.' +
                                  'STYLED_ITEM.ITEM') |
         ('AIC_DRAUGHTING_ANNOTATION.' +
             'ANNOTATION_CURVE_OCCURRENCE' IN TYPEOF (si)))) > 0))) = 0);
  WR4:	-- symbol_has_symbol_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
            IN TYPEOF (SELF))) OR    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)           AND
            (SIZEOF (TYPEOF (sty.styles[1]) *
                ['AIC_DRAUGHTING_ANNOTATION.SYMBOL_STYLE',
                 'AIC_DRAUGHTING_ANNOTATION.NULL_STYLE']) = 1)) )) = 0);
  WR5:	-- allowable_symbol_representations:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL'
             IN TYPEOF(SELF.item)))) OR
         (SIZEOF (['AIC_DRAUGHTING_ANNOTATION.' +
                   'DRAUGHTING_SYMBOL_REPRESENTATION',
                  'AIC_DRAUGHTING_ANNOTATION.' +
                  'DRAUGHTING_SUBFIGURE_REPRESENTATION'] *
          TYPEOF (SELF.item\mapped_item.mapping_source.
                  mapped_representation)) = 1);
  WR6:	-- text_has_text_style:
    (NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
            IN TYPEOF (SELF))) OR
    (SIZEOF (QUERY (sty <* SELF.styles |
       NOT ((SIZEOF (sty.styles) = 1)
        AND ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE'
                IN TYPEOF (sty.styles[1]))) )) = 0);
  WR7:	-- allowable_text:
     (NOT('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF))) OR
         (SIZEOF (TYPEOF(SELF.item) *
             ['AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT',
              'AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL']) = 1);
  WR8:	-- text_not_nested:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR    (SIZEOF (QUERY (tl <*
                   SELF.item\composite_text.collected_text |
             NOT ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' 
             IN TYPEOF (tl)) )) = 0);
  WR9:	-- text_alignment_literals:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL'
             IN TYPEOF (SELF.item)))) OR (SELF.item\text_literal.alignment 
             IN ['baseline left', 'baseline centre', 'baseline right']);
  WR10:	-- text_alignment_composites:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <* SELF.
                  item\composite_text.collected_text
             |('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF(text))) |
          NOT (tl\text_literal.alignment IN
         ['baseline left', 'baseline centre', 'baseline right']) )) = 0);
  WR11:	-- single_text_alignment:
    NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_alignment(SELF.item);
  WR12:	-- single_text_font:
    NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
             IN TYPEOF (SELF.item))) OR check_text_font(SELF.item);
  WR13:	-- allowable_text_literals:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT'
               IN TYPEOF (SELF.item)))) OR
         (SIZEOF (QUERY (tl <* QUERY (text <*
            SELF.item\composite_text.collected_text |
            ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL' IN TYPEOF (text))) |
             NOT (SIZEOF (TYPEOF(tl) *
                  ['AIC_DRAUGHTING_ANNOTATION.' +
                   'TEXT_LITERAL_WITH_BLANKING_BOX',
                   'AIC_DRAUGHTING_ANNOTATION.' +
                   'TEXT_LITERAL_WITH_ASSOCIATED_CURVES']) = 0) )) = 0);
  WR14:	-- styled_text_literal_curves:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_LITERAL_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
    (SIZEOF (QUERY (crv <*
                   SELF.item\text_literal_with_associated_curves.
                   associated_curves |
      NOT (SIZEOF (QUERY (si <*  USEDIN (crv, 
             'PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM.ITEM') |
        ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
            IN TYPEOF (si)) )) > 0) )) = 0);
  WR15:	-- styled_composite_text_curves:
    (NOT (('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (SELF)) AND
         ('AIC_DRAUGHTING_ANNOTATION.COMPOSITE_TEXT_WITH_ASSOCIATED_CURVES'
             IN TYPEOF (SELF.item)))) OR
          (SIZEOF (QUERY (crv <*
                SELF.item\composite_text_with_associated_curves.
                associated_curves |
           NOT (SIZEOF (QUERY (si <*  USEDIN (crv,
                'PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM.ITEM') |
               ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE'
           IN TYPEOF (si)) )) > 0) )) = 0);
WR16:	-- curve_style_has_width:
    SIZEOF (QUERY (cs <* QUERY (sty <* SELF.styles |
      ('AIC_DRAUGHTING_ANNOTATION.CURVE_STYLE' IN TYPEOF (sty.styles[1])))
      | NOT (('AIC_DRAUGHTING_ANNOTATION.LENGTH_MEASURE_WITH_UNIT'
        IN TYPEOF (cs.styles[1]\curve_style.curve_width)) AND
       ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (cs.styles[1]\curve_style.
        curve_width\measure_with_unit.value_component))))) = 0;
WR17:	-- tiling_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
      ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE'
          IN TYPEOF (sty.styles[1]))) |
      NOT ((SIZEOF (QUERY (fs <* fas.styles[1]\fill_area_style.fill_styles
                    | ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_TILES'
                       IN TYPEOF (fs)))) <= 1)
       AND (SIZEOF (QUERY (fst <* QUERY (fs <*
                           fas.styles[1]\fill_area_style.fill_styles |
              ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_TILES'
                  IN TYPEOF (fs))) |
                 NOT (SIZEOF (fst\fill_area_style_tiles.tiles) = 1)
           )) = 0))
    )) = 0;
  WR18:	-- hatching_constraints:
    SIZEOF (QUERY (fas <* QUERY (sty <* SELF.styles |
           ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE' 
            IN TYPEOF (sty.styles[1]))) |
             NOT (SIZEOF (QUERY (fsh <* QUERY (fs <*
                          fas.styles[1]\fill_area_style.fill_styles |
             ('AIC_DRAUGHTING_ANNOTATION.FILL_AREA_STYLE_HATCHING'
               IN TYPEOF (fs))) |
        NOT (fsh\fill_area_style_hatching.point_of_reference_hatch_line :=:
             fsh\fill_area_style_hatching.pattern_start)  )) = 0)  )) = 0;
  WR19:	-- text_style_constraint:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE' 
         IN TYPEOF(sty.styles[1]))) |
             NOT ('AIC_DRAUGHTING_ANNOTATION.' +
                  'TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (ts.styles[1])))) = 0;
  WR20:	-- text_style_characteristics:
    SIZEOF (QUERY (ts <* QUERY (sty <* SELF.styles |
         ('AIC_DRAUGHTING_ANNOTATION.TEXT_STYLE_WITH_BOX_CHARACTERISTICS'
             IN TYPEOF (sty.styles[1]))) |
           NOT (SIZEOF (ts.styles[1]\text_style_with_box_characteristics.
                characteristics) = 4) )) = 0;
END_ENTITY;

ENTITY draughting_subfigure_representation
  SUBTYPE OF (symbol_representation);
  SELF\representation.items : SET[1:?] OF draughting_subfigure_representation_item;
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items |
         SIZEOF (['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_OCCURRENCE',
                  'AIC_DRAUGHTING_ANNOTATION.DRAUGHTING_CALLOUT'] *
           TYPEOF (item)) = 1)) >= 1;
  WR2: SIZEOF (QUERY (srm <* QUERY (rm <*
          USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          ('AIC_DRAUGHTING_ANNOTATION.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm))) | 
            NOT (SIZEOF (QUERY (a_s <* QUERY (mi <* srm.map_usage |
            ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL' IN TYPEOF(mi)))
          | NOT (SIZEOF (QUERY (aso <*
            USEDIN (a_s, 'PRESENTATION_APPEARANCE_SCHEMA.' + 
                         'STYLED_ITEM.ITEM') |
          NOT ('AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SUBFIGURE_OCCURRENCE'
            IN TYPEOF(aso)))) = 0))) = 0))) > 0;
  WR3: SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_symbol_representation
  SUBTYPE of (symbol_representation);
  SELF\representation.items : SET[1:?] OF draughting_symbol_representation_item;
UNIQUE
  UR1: SELF\representation.name;
WHERE
  WR1: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         (SIZEOF (TYPEOF (item) *
            ['AIC_DRAUGHTING_ANNOTATION.ANNOTATION_CURVE_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SYMBOL_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_FILL_AREA_OCCURRENCE',
             'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_TEXT_OCCURRENCE']) = 1)
       )) >= 1;
  WR2: 
    SIZEOF (QUERY (item <* SELF\representation.items |
         'AIC_DRAUGHTING_ANNOTATION.ANNOTATION_SUBFIGURE_OCCURRENCE'
          IN TYPEOF (item))) = 0;
  WR3: 
    SIZEOF ( QUERY (rm <*
          USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                        'REPRESENTATION_MAP.MAPPED_REPRESENTATION') |
          NOT ('REPRESENTATION_SCHEMA.SYMBOL_REPRESENTATION_MAP'
             IN TYPEOF(rm)))) = 0; 
  WR4: 
    SIZEOF (SELF.context_of_items.representations_in_context) = 1;
END_ENTITY;

ENTITY draughting_text_literal_with_delineation
  SUBTYPE OF (text_literal_with_delineation);
WHERE
  WR1: SELF.delineation IN ['underline', 'overline'];
END_ENTITY;

FUNCTION check_text_alignment (ct : composite_text) : BOOLEAN;

  LOCAL
    a : SET OF text_alignment := [];
  END_LOCAL;

  -- create a set of all the alignments
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    a := a + [ct.collected_text[i]\text_literal.alignment];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all alignments were the same
  RETURN (SIZEOF(a) = 1);
END_FUNCTION;

FUNCTION check_text_font (ct : composite_text) : BOOLEAN;

  LOCAL
    f : SET OF font_select := [];
  END_LOCAL;

  -- build a set of all the fonts
  REPEAT i := 1 TO HIINDEX (ct.collected_text);
    f := f + [ct.collected_text[i]\text_literal.font];
  END_REPEAT;

  -- if there is more than one element in the set
  -- then not all fonts were the same
  RETURN (SIZEOF(f) <= 1);
END_FUNCTION;

END_SCHEMA; -- aic_draughting_annotation
(*
ISO TC184/SC4/WG12 N6171 - ISO 10303-506 Draughting elements - EXPRESS
Supersedes ISO TC184/SC4/WG12 N5250
*)

SCHEMA aic_draughting_elements;

USE FROM draughting_element_schema	-- ISO 10303-101
  (dimension_curve,
   dimension_curve_directed_callout,
   dimension_curve_terminator,
   draughting_callout,
   draughting_callout_relationship,
   leader_curve,
   leader_directed_callout,
   leader_terminator,
   projection_curve,
   projection_directed_callout);

USE FROM presentation_definition_schema	-- ISO 10303-46
  (annotation_text_occurrence);

ENTITY angular_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY curve_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY datum_feature_callout
  SUBTYPE OF (draughting_callout);
END_ENTITY;

ENTITY datum_target_callout
  SUBTYPE OF (draughting_callout);
END_ENTITY;

ENTITY diameter_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY dimension_callout_component_relationship
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['prefix', 'suffix'];
  WR2: 'AIC_DRAUGHTING_ELEMENTS.STRUCTURED_DIMENSION_CALLOUT'
           IN TYPEOF (SELF.relating_draughting_callout);
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.STRUCTURED_DIMENSION_CALLOUT']) = 0;
  WR4: SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
  WR5: ((SELF.name = 'prefix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'prefix text')
       )) = 0));
 
  WR6: ((SELF.name = 'suffix') AND
       (SIZEOF (QUERY (ato <* QUERY (con <*
                 SELF.related_draughting_callout.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         NOT (ato.name = 'suffix text')
       )) = 0));
END_ENTITY;

ENTITY dimension_callout_relationship
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['primary', 'secondary'];
  WR2: SIZEOF (TYPEOF (SELF.relating_draughting_callout) * 
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])>=1;
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT']) = 0;
  WR4: SELF.related_draughting_callout.contents *
       SELF.relating_draughting_callout.contents =
       SELF.related_draughting_callout.contents;
END_ENTITY;

ENTITY dimension_pair
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: SELF.name IN ['chained', 'parallel'];
  WR2: SIZEOF (TYPEOF (SELF.relating_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])=1;
  WR3: SIZEOF (TYPEOF (SELF.related_draughting_callout) *
       ['AIC_DRAUGHTING_ELEMENTS.ANGULAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.CURVE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.DIAMETER_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.LINEAR_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.ORDINATE_DIMENSION',
        'AIC_DRAUGHTING_ELEMENTS.RADIUS_DIMENSION'])=1;
END_ENTITY;

ENTITY draughting_elements
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF (QUERY (l_c <* QUERY (con <* SELF.contents |
              ('AIC_DRAUGHTING_ELEMENTS.LEADER_CURVE' IN TYPEOF(con))) |
              NOT (SIZEOF (QUERY (ldc <* USEDIN (l_c,
               'DRAUGHTING_ELEMENT_SCHEMA.' + 'DRAUGHTING_CALLOUT.CONTENTS') |
              ('AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT'
              IN TYPEOF (ldc)))) <= 1)))=0;
  WR2: NOT    ('DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE_DIRECTED_CALLOUT'
              IN TYPEOF(SELF)) OR
              (SIZEOF (QUERY (con <* SELF.contents |
              ('AIC_DRAUGHTING_ELEMENTS.PROJECTION_CURVE' IN
               TYPEOF (con)))) <= 2);
  WR3: SIZEOF (QUERY (rc <* USEDIN (SELF,
              'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
              ('AIC_DRAUGHTING_ELEMENTS.' +
               'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND
              (rc.name = 'primary') )) <= 1;
  WR4: SIZEOF (QUERY (rc <* USEDIN (SELF,
              'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
              'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AIC_DRAUGHTING_ELEMENTS.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND
                (rc.name = 'secondary') )) <= 1;
  WR5: SIZEOF (QUERY (sec <* QUERY (rc <* USEDIN (SELF,
               'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AIC_DRAUGHTING_ELEMENTS.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (rc)) AND         
                (rc.name = 'secondary') ) |
         NOT (SIZEOF (QUERY (prim <* USEDIN (SELF,
               'DRAUGHTING_ELEMENT_SCHEMA.DRAUGHTING_CALLOUT_' +
               'RELATIONSHIP.RELATING_DRAUGHTING_CALLOUT') |
               ('AIC_DRAUGHTING_ELEMENTS.' +
                'DIMENSION_CALLOUT_RELATIONSHIP' IN TYPEOF (prim)) AND         
                (prim.name = 'primary') )) = 1))) = 0;  
END_ENTITY;

ENTITY geometrical_tolerance_callout
  SUBTYPE OF (draughting_callout);
END_ENTITY;

ENTITY leader_directed_dimension
  SUBTYPE OF (leader_directed_callout);
WHERE
  WR1: SIZEOF (QUERY (con <* SELF.contents |
       'AIC_DRAUGHTING_ELEMENTS.LEADER_CURVE' IN TYPEOF (con)))=1;
END_ENTITY;

ENTITY linear_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
END_ENTITY;

ENTITY ordinate_dimension
   SUBTYPE OF (projection_directed_callout);
END_ENTITY;

ENTITY radius_dimension
  SUBTYPE OF (dimension_curve_directed_callout);
WHERE
  WR1: SIZEOF (QUERY (con <* SELF.contents |
       'AIC_DRAUGHTING_ELEMENTS.PROJECTION_CURVE' IN TYPEOF (con)))<=1;
END_ENTITY;

ENTITY structured_dimension_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: SIZEOF (TYPEOF (SELF) *
       ['AIC_DRAUGHTING_ELEMENTS.DATUM_FEATURE_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DATUM_TARGET_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.GEOMETRICAL_TOLERANCE_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.LEADER_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.PROJECTION_DIRECTED_CALLOUT',
        'AIC_DRAUGHTING_ELEMENTS.DIMENSION_CURVE_DIRECTED_CALLOUT']) = 0;
  WR2: SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         NOT (ato.name IN
             ['dimension value', 'tolerance value', 'unit text',
              'prefix text', 'suffix text']))) = 0;
  WR3: SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF (con))) |
         (ato.name = 'dimension value')
       )) >= 1;
  WR4: SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
         'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND 
         (dcr.name = 'prefix') )) <= 1;
  WR5: SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
         'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
         'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND 
         (dcr.name = 'suffix') )) <= 1;
  WR6: NOT((SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con)) ) |
         (ato.name = 'prefix text')
       )) > 0)) OR
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND  
         (dcr.name = 'prefix') )) = 1);
  WR7: NOT(SIZEOF (QUERY (ato <* QUERY (con <* SELF.contents |
         ('AIC_DRAUGHTING_ELEMENTS.ANNOTATION_TEXT_OCCURRENCE'
             IN TYPEOF(con))) |
         (ato.name = 'suffix text')
       )) > 0) OR
       (SIZEOF (QUERY (dcr <* USEDIN (SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                               'DRAUGHTING_CALLOUT_RELATIONSHIP.' +
                               'RELATING_DRAUGHTING_CALLOUT') |
         ('AIC_DRAUGHTING_ELEMENTS.' +
          'DIMENSION_CALLOUT_COMPONENT_RELATIONSHIP' IN TYPEOF (dcr)) AND    
            (dcr.name = 'suffix') )) = 1);
END_ENTITY;

END_SCHEMA;
SCHEMA aic_edge_based_wireframe;
  
USE FROM geometric_model_schema ( edge_based_wireframe_model);
 USE FROM geometry_schema ( axis2_placement_3d, b_spline_curve_with_knots, bezier_curve, cartesian_transformation_operator_3d, circle, conic, curve, curve_replica, ellipse, geometric_representation_context, hyperbola, line, offset_curve_3d, parabola, point, point_replica, polyline, quasi_uniform_curve, rational_b_spline_curve, uniform_curve);
 USE FROM product_property_representation_schema ( shape_representation);
 USE FROM representation_schema ( mapped_item);
 USE FROM topology_schema ( edge_curve, vertex_point);
  
ENTITY edge_based_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL', 'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM', 'AIC_EDGE_BASED_WIREFRAME.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL', 'AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT ('AIC_EDGE_BASED_WIREFRAME.EDGE_CURVE' IN TYPEOF (edges)) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( pline_edges <* 
QUERY ( edges <* eb.ces_edges| ('AIC_EDGE_BASED_WIREFRAME.POLYLINE' IN TYPEOF (edges\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_edges\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (edges.edge_start)) AND ('AIC_EDGE_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (edges.edge_end))) )) = 0) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT valid_wireframe_edge_curve(edges\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( ebwm <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( eb <* ebwm\edge_based_wireframe_model.ebwm_boundary| NOT ( SIZEOF ( 
QUERY ( edges <* eb.ces_edges| NOT (valid_wireframe_vertex_point(edges.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(edges.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_EDGE_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_EDGE_BASED_WIREFRAME.' + 'EDGE_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR9 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
 END_ENTITY ;
  
FUNCTION valid_wireframe_edge_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'AIC_EDGE_BASED_WIREFRAME.LINE', 'AIC_EDGE_BASED_WIREFRAME.CONIC', 'AIC_EDGE_BASED_WIREFRAME.B_SPLINE_CURVE', 'AIC_EDGE_BASED_WIREFRAME.POLYLINE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_EDGE_BASED_WIREFRAME.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AIC_EDGE_BASED_WIREFRAME.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
FUNCTION valid_wireframe_vertex_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'AIC_EDGE_BASED_WIREFRAME.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_EDGE_BASED_WIREFRAME.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
END_SCHEMA;
 
(*
  This is ISO 10303-513
  This is WG12 N476
*)
 SCHEMA aic_elementary_brep;
  USE FROM geometry_schema(axis2_placement_3d,
                           cartesian_point,
                           cartesian_transformation_operator_3d,
                           circle,
                           conical_surface,
                           cylindrical_surface,
                           degenerate_toroidal_surface,
                           direction,
                           ellipse,
                           hyperbola,
                           line,
                           parabola,
                           plane,
                           polyline,
                           spherical_surface,
                           toroidal_surface,
                           vector);
  USE FROM geometric_model_schema(manifold_solid_brep,
                                  brep_with_voids);

REFERENCE FROM geometric_model_schema(msb_shells);

USE FROM topology_schema(closed_shell,
                           connected_face_set,
                           edge_curve,
                           edge_loop,
                           face_bound,
                           face_outer_bound,
                           face_surface,
                           oriented_closed_shell,
                           oriented_edge,
                           path,
                           vertex_loop,
                           vertex_point);


  USE FROM representation_schema(mapped_item);

  USE FROM product_property_representation_schema(shape_representation);

 ENTITY elementary_brep_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
   WR1 : SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP',
                'AIC_ELEMENTARY_BREP.FACETED_BREP',
                'AIC_ELEMENTARY_BREP.MAPPED_ITEM',
                'AIC_ELEMENTARY_BREP.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2 : SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP',
         'AIC_ELEMENTARY_BREP.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh.cfs_faces |
              NOT('AIC_ELEMENTARY_BREP.FACE_SURFACE' IN TYPEOF(fcs)))) = 0
                 ))) = 0
                   ))) = 0;
   WR4 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
            NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
              NOT(('AIC_ELEMENTARY_BREP.ELEMENTARY_SURFACE' IN
                   TYPEOF(fcs\face_surface.face_geometry))
             ))) = 0
                 ))) = 0
                   ))) = 0;
   WR5 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT('AIC_ELEMENTARY_BREP.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)))) = 0
                   ))) = 0
                 ))) = 0
               ))) = 0
             ))) = 0;
   WR6 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AIC_ELEMENTARY_BREP.LINE',
                         'AIC_ELEMENTARY_BREP.CONIC',
                         'AIC_ELEMENTARY_BREP.POLYLINE'] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR7 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
            NOT(('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0;
   WR8 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
           'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
           NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
             NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_ELEMENTARY_BREP.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                 ))) = 0
                   ))) = 0
                    ))) = 0;
   WR9 : SIZEOF (QUERY (msb <* QUERY (it <* items |
          'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
          'AIC_ELEMENTARY_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF
              (msb\manifold_solid_brep.outer)))
             = 0;
   WR10 : SIZEOF (QUERY (brv <* QUERY (it <* items |
          'AIC_ELEMENTARY_BREP.BREP_WITH_VOIDS' IN TYPEOF(it)) |
          NOT (SIZEOF (QUERY (csh <* brv\brep_with_voids.voids |
           csh\oriented_closed_shell.orientation)) = 0))) = 0;
   WR11 : SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AIC_ELEMENTARY_BREP.MAPPED_ITEM' IN TYPEOF(it)) |
          NOT ('AIC_ELEMENTARY_BREP.ELEMENTARY_BREP_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR12 : SIZEOF (QUERY (msb <* QUERY (it <* SELF.items |
            'AIC_ELEMENTARY_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF(it)) |
            NOT (SIZEOF (QUERY (csh <* msb_shells(msb) |
              NOT (SIZEOF (QUERY(fcs <* csh\connected_face_set.cfs_faces |
               NOT (SIZEOF(QUERY (vlp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_ELEMENTARY_BREP.VERTEX_LOOP' IN TYPEOF(bnds.bound)) |
           NOT(('AIC_ELEMENTARY_BREP.VERTEX_POINT' IN
               TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND
                ('AIC_ELEMENTARY_BREP.CARTESIAN_POINT' IN
                   TYPEOF(vlp_fbnds\face_bound.bound\vertex_loop.
                     loop_vertex\vertex_point.vertex_geometry))
            ))) = 0))) = 0))) = 0))) =0;
 END_ENTITY;

END_SCHEMA; -- end AIC_ELEMENTARY_BREP SCHEMA

SCHEMA aic_faceted_brep;
  
USE FROM geometry_schema ( axis2_placement_3d, cartesian_point, cartesian_transformation_operator_3d, elementary_surface, plane);
 USE FROM geometric_model_schema ( brep_with_voids, faceted_brep, manifold_solid_brep);
 REFERENCE FROM geometric_model_schema ( msb_shells);
 USE FROM topology_schema ( closed_shell, connected_face_set, face_bound, face_outer_bound, face_surface, oriented_closed_shell, poly_loop);
 USE FROM representation_schema ( mapped_item);
 USE FROM product_property_representation_schema ( shape_representation);
  
ENTITY faceted_brep_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* items| NOT ( SIZEOF ([ 'AIC_FACETED_BREP.FACETED_BREP', 'AIC_FACETED_BREP.MAPPED_ITEM', 'AIC_FACETED_BREP.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* items| ( SIZEOF ([ 'AIC_FACETED_BREP.FACETED_BREP', 'AIC_FACETED_BREP.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) > 0;
WR3 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT (('AIC_FACETED_BREP.FACE_SURFACE' IN TYPEOF (fcs)) AND (('AIC_FACETED_BREP.PLANE' IN TYPEOF (fcs\face_surface.face_geometry)) AND ('AIC_FACETED_BREP.CARTESIAN_POINT' IN TYPEOF (fcs\face_surface.face_geometry\elementary_surface.position.location)))) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( fbrep <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.FACETED_BREP' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* msb_shells(fbrep)| NOT ( SIZEOF ( 
QUERY ( fcs <* csh\connected_face_set.cfs_faces| NOT ( SIZEOF ( 
QUERY ( bnds <* fcs.bounds| ('AIC_FACETED_BREP.FACE_OUTER_BOUND' IN TYPEOF (bnds)) )) = 1) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( msb <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.MANIFOLD_SOLID_BREP' IN TYPEOF (it)) )| ('AIC_FACETED_BREP.ORIENTED_CLOSED_SHELL' IN TYPEOF (msb\manifold_solid_brep.outer)) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( brv <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.BREP_WITH_VOIDS' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( csh <* brv\brep_with_voids.voids| csh\oriented_closed_shell.orientation )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* items| ('AIC_FACETED_BREP.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_FACETED_BREP.FACETED_BREP_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
END_SCHEMA;
 
(*
ISO TC184/SC4/WG12 N6159 - ISO 10303-503 Geometrically bounded 2d wireframe - EXPRESS
Supersedes ISO TC184/SC4/WG12 N5246
*)

SCHEMA aic_geometrically_bounded_2d_wireframe; -- as modified by TC1 WG12 N4397
USE FROM geometric_model_schema    -- ISO 10303-42
    (geometric_curve_set,
     geometric_set);
USE FROM geometry_schema -- ISO 10303-42
   (axis2_placement_2d,
    b_spline_curve_with_knots,
    bezier_curve,
    circle,
    composite_curve,
    composite_curve_segment,
    curve,
    curve_replica,
    ellipse,
    geometric_representation_context,
    hyperbola,
    line,
    offset_curve_2d,
    parabola,
    point_on_curve,
    polyline,
    quasi_uniform_curve,
    rational_b_spline_curve,
    trimmed_curve,
    uniform_curve);
USE FROM product_property_representation_schema -- ISO 10303-41
   (shape_representation);
USE FROM representation_schema -- ISO 10303-43
   (mapped_item);
ENTITY geometrically_bounded_2d_wireframe_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
  WR2: SIZEOF (QUERY (item <* SELF.items |
         NOT (SIZEOF (TYPEOF (item) *
['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',          
'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.AXIS2_PLACEMENT_2D',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1)
       )) = 0;
  WR3: SIZEOF (QUERY (item <* SELF.items |
         SIZEOF (TYPEOF (item) *          
['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1
       )) >= 1;
  WR4: SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM'
           IN TYPEOF (item))) |
         NOT ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.' +
              'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
           IN TYPEOF
              (mi\mapped_item.mapping_source.mapped_representation))
       )) = 0;
  WR5: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
           NOT (SIZEOF (TYPEOF (elem) *
             ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
              'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE']) =
               1)
         )) = 0)
       )) = 0;
  WR6: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
     ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (crv <* 
           QUERY (elem <* gcs\geometric_set.elements |
              ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE'
                   IN TYPEOF (elem))) |
           NOT (valid_basis_curve_in_2d_wireframe
              (crv))
         )) = 0)
       )) = 0;
  WR7: SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |         
       ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
                IN TYPEOF (item))) |
         NOT (SIZEOF (QUERY (pnt <*
           QUERY (elem <* gcs\geometric_set.elements |
             ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT'
                  IN TYPEOF(elem))) |
             NOT (SIZEOF (TYPEOF (pnt) *
               ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CARTESIAN_POINT',
                'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT_ON_CURVE'])
          = 1)
         )) = 0)
       )) = 0;
END_ENTITY;
FUNCTION valid_basis_curve_in_2d_wireframe
   (crv: curve) : BOOLEAN;
   -- check for valid basic curve types
  IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
               'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE'] * 
               TYPEOF (crv)) = 1
    THEN RETURN (TRUE);
  ELSE
    -- if the curve is a trimmed_curve
    IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE') 
    IN TYPEOF (crv)) THEN
      -- if a line, parabola, or hyperbola is being trimmed, then valid
      IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.LINE',
                   'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.PARABOLA',
                   'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.HYPERBOLA'] *
           TYPEOF(crv\trimmed_curve.basis_curve)) = 1
        THEN RETURN (TRUE);
      -- otherwise, recursively check basis_curve
      ELSE RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\trimmed_curve.basis_curve));
      END_IF;
    ELSE
      -- recursively check the offset_curve basis curve
      IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D') 
      IN TYPEOF (crv))
        THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\offset_curve_2d.basis_curve));
      ELSE
        -- recursively check the curve_replica parent curve
        IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE_REPLICA') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                         (crv\curve_replica.parent_curve));
        ELSE
          -- recursively check the composite_curve segments
          IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE') 
          IN TYPEOF (crv)) THEN
            RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                      NOT (valid_basis_curve_in_2d_wireframe
                             (ccs.parent_curve)))) = 0);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
END_SCHEMA;  --aic_geometrically_bounded_2d_wireframe
(* ISO 10303-507, TC 184/SC4/WG12 N564 *)

SCHEMA aic_geometrically_bounded_surface;

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set); 

USE FROM geometric_model_schema   -- ISO 10303-42
  (geometric_set); 

USE FROM geometry_schema   -- ISO 10303-42
  (axis1_placement,
   axis2_placement_2d,
   axis2_placement_3d,
   b_spline_curve,
   b_spline_curve_with_knots,
   b_spline_surface,
   b_spline_surface_with_knots,
   bezier_curve,
   bezier_surface,
   boundary_curve,
   bounded_pcurve,
   bounded_surface_curve,
   cartesian_point,
   cartesian_transformation_operator_3d,
   circle,
   composite_curve,
   composite_curve_on_surface,
   composite_curve_segment,
   conical_surface,
   curve,
   curve_bounded_surface,
   curve_replica,
   cylindrical_surface,
   degenerate_pcurve,
   degenerate_toroidal_surface,
   direction,
   ellipse,
   evaluated_degenerate_pcurve,
   geometric_representation_context,
   hyperbola,
   intersection_curve,
   line,
   offset_curve_3d,
   offset_surface,
   outer_boundary_curve,
   parabola,
   pcurve,
   plane,
   point,
   point_on_curve,
   point_on_surface,
   polyline,
   quasi_uniform_curve,
   quasi_uniform_surface,
   rational_b_spline_curve,
   rational_b_spline_surface,
   rectangular_composite_surface,
   rectangular_trimmed_surface,
   reparametrised_composite_curve_segment,
   seam_curve,
   spherical_surface,
   surface,
   surface_curve,
   surface_of_linear_extrusion,
   surface_of_revolution,
   surface_patch,
   surface_replica,
   swept_surface,
   toroidal_surface,
   trimmed_curve,
   uniform_curve,
   uniform_surface,
   vector); 

USE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 

USE FROM representation_schema   -- ISO 10303-43
  (definitional_representation,
   mapped_item,
   parametric_representation_context,
   representation,
   representation_item,
   representation_map); 


ENTITY geometrically_bounded_surface_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(it <* SELF.items | NOT (SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF(it)) = 1))) = 0;
  WR2: SIZEOF(QUERY(it <* SELF.items | SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM'] * TYPEOF(it)) = 1)) > 0;
  WR3: SIZEOF(QUERY(mi <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.MAPPED_ITEM' IN TYPEOF(it)) | NOT (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi\mapped_item.mapping_source.mapped_representation)) AND (SIZEOF(QUERY(mr_it <* mi\mapped_item.mapping_source.mapped_representation.items | ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(mr_it)))) > 0)))) = 0;
  WR4: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(pnt <* QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT' IN TYPEOF(gsel)) | NOT (gbsf_check_point(pnt)))) = 0))) = 0;
  WR5: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(cv <* QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE' IN TYPEOF(gsel)) | NOT (gbsf_check_curve(cv)))) = 0))) = 0;
  WR6: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | NOT (SIZEOF(QUERY(sf <* QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF(gsel)) | NOT (gbsf_check_surface(sf)))) = 0))) = 0;
  WR7: SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.GEOMETRIC_SET' IN TYPEOF(it)) | SIZEOF(QUERY(gsel <* gs\geometric_set.elements | 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF(gsel))) > 0)) > 0;
END_ENTITY;

FUNCTION gbsf_check_point
 (pnt : point) : BOOLEAN; 
  IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF(pnt) THEN
    RETURN (TRUE);
  ELSE
    IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_CURVE' IN TYPEOF(pnt) THEN
      RETURN (gbsf_check_curve(pnt\point_on_curve.basis_curve));
    ELSE
      IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POINT_ON_SURFACE' IN TYPEOF(pnt) THEN
        RETURN (gbsf_check_surface(pnt\point_on_surface.basis_surface));
      ELSE
        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.DEGENERATE_PCURVE' IN TYPEOF(pnt) THEN
          RETURN ((gbsf_check_curve(pnt\degenerate_pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(pnt\degenerate_pcurve.basis_surface)));
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

FUNCTION gbsf_check_curve
 (cv : representation_item) : BOOLEAN; 
  IF SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.BOUNDED_CURVE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CONIC', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.LINE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
    RETURN (FALSE);
  END_IF;
  IF SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.CIRCLE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.ELLIPSE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.TRIMMED_CURVE'] * TYPEOF(cv)) = 1 THEN
    RETURN (TRUE);
  ELSE
    IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' IN TYPEOF(cv)) AND (cv\b_spline_curve.self_intersect = FALSE) OR (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
      RETURN (TRUE);
    ELSE
      IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.COMPOSITE_CURVE' IN TYPEOF(cv)) AND (cv\composite_curve.self_intersect = FALSE) OR (cv\composite_curve.self_intersect = UNKNOWN)) THEN
        RETURN (SIZEOF(QUERY(seg <* cv\composite_curve.segments | NOT (gbsf_check_curve(seg.parent_curve)))) = 0);
      ELSE
        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_REPLICA' IN TYPEOF(cv) THEN
          RETURN (gbsf_check_curve(cv\curve_replica.parent_curve));
        ELSE
          IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_CURVE_3D' IN TYPEOF(cv)) AND ((cv\offset_curve_3d.self_intersect = FALSE) OR (cv\offset_curve_3d.self_intersect = UNKNOWN)) AND (NOT ('AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF(cv\offset_curve_3d.basis_curve)))) THEN
            RETURN (gbsf_check_curve(cv\offset_curve_3d.basis_curve));
          ELSE
            IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF(cv) THEN
              RETURN ((gbsf_check_curve(cv\pcurve.reference_to_curve\representation.items[1])) AND (gbsf_check_surface(cv\pcurve.basis_surface)));
            ELSE
              IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF(cv\polyline.points) >= 3) THEN
                  RETURN (TRUE);
                END_IF;
              ELSE
                IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF(cv) THEN
                  IF gbsf_check_curve(cv\surface_curve.curve_3d) THEN
                    REPEAT i := 1 TO SIZEOF(cv\surface_curve.associated_geometry);
                      IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                        IF NOT gbsf_check_surface(cv\surface_curve.associated_geometry[i]) THEN
                          RETURN (FALSE);
                        END_IF;
                      ELSE
                        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF(cv\surface_curve.associated_geometry[i]) THEN
                          IF NOT gbsf_check_curve(cv\surface_curve.associated_geometry[i]) THEN
                            RETURN (FALSE);
                          END_IF;
                        END_IF;
                      END_IF;
                    END_REPEAT;
                    RETURN (TRUE);
                  END_IF;
                END_IF;
              END_IF;
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

FUNCTION gbsf_check_surface
 (sf : surface) : BOOLEAN; 
  IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE' IN TYPEOF(sf)) AND (sf\b_spline_surface.self_intersect = FALSE) OR (sf\b_spline_surface.self_intersect = UNKNOWN)) THEN
    RETURN (TRUE);
  ELSE
    IF SIZEOF(['AIC_GEOMETRICALLY_BOUNDED_SURFACE.SPHERICAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.TOROIDAL_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.CURVE_BOUNDED_SURFACE', 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_TRIMMED_SURFACE'] * TYPEOF(sf)) = 1 THEN
      RETURN (TRUE);
    ELSE
      IF (('AIC_GEOMETRICALLY_BOUNDED_SURFACE.OFFSET_SURFACE' IN TYPEOF(sf)) AND (sf\offset_surface.self_intersect = FALSE) OR (sf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (gbsf_check_surface(sf\offset_surface.basis_surface));
      ELSE
        IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.RECTANGULAR_COMPOSITE_SURFACE' IN TYPEOF(sf) THEN
          REPEAT i := 1 TO SIZEOF(sf\rectangular_composite_surface.segments);
            REPEAT j := 1 TO SIZEOF(sf\rectangular_composite_surface.segments[i]);
              IF NOT (gbsf_check_surface(sf\rectangular_composite_surface.segments[i][j].parent_surface)) THEN
                RETURN (FALSE);
              END_IF;
            END_REPEAT;
          END_REPEAT;
          RETURN (TRUE);
        ELSE
          IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_REPLICA' IN TYPEOF(sf) THEN
            RETURN (gbsf_check_surface(sf\surface_replica.parent_surface));
          ELSE
            IF 'AIC_GEOMETRICALLY_BOUNDED_SURFACE.SURFACE_OF_REVOLUTION' IN TYPEOF(sf) THEN
              RETURN (gbsf_check_curve(sf\swept_surface.swept_curve));
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
      END_FUNCTION; 

END_SCHEMA;  -- aic_geometrically_bounded_surface
SCHEMA aic_geometrically_bounded_wireframe;
  
USE FROM geometric_model_schema ( geometric_curve_set, geometric_set);
 USE FROM geometry_schema ( axis1_placement, axis2_placement_3d, b_spline_curve_with_knots, bezier_curve, cartesian_transformation_operator_3d, circle, composite_curve, conic, curve, curve_replica, ellipse, geometric_representation_context, hyperbola, line, offset_curve_3d, parabola, point, point_on_curve, point_replica, polyline, quasi_uniform_curve, rational_b_spline_curve, reparametrised_composite_curve_segment, trimmed_curve, uniform_curve);
 USE FROM product_property_representation_schema ( shape_representation);
 USE FROM representation_schema ( mapped_item);
  
ENTITY geometrically_bounded_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ( TYPEOF (it) * [ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM' ]) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ( TYPEOF (it) * [ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM' ]) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( crv <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CURVE' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_curve(crv) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pnts <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT' IN TYPEOF (elem)) )| NOT valid_geometrically_bounded_wf_point(pnts) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( cnc <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CONIC' IN TYPEOF (elem)) )| NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.AXIS2_PLACEMENT_3D' IN TYPEOF (cnc\conic.position)) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( gcs <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.GEOMETRIC_CURVE_SET' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( pline <* 
QUERY ( elem <* gcs\geometric_set.elements| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POLYLINE' IN TYPEOF (elem)) )| NOT ( SIZEOF (pline\polyline.points) > 2) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.' + 'GEOMETRICALLY_BOUNDED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
 END_ENTITY ;
  
FUNCTION valid_geometrically_bounded_wf_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POLYLINE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.B_SPLINE_CURVE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.ELLIPSE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CIRCLE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.TRIMMED_CURVE' IN TYPEOF (crv) THEN 
 IF SIZEOF ([ 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.LINE', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.PARABOLA', 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.HYPERBOLA' ] * TYPEOF (crv\trimmed_curve.basis_curve)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 RETURN (valid_geometrically_bounded_wf_curve(crv\trimmed_curve.basis_curve));
 END_IF ;
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\offset_curve_3d.basis_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.COMPOSITE_CURVE' IN TYPEOF (crv) THEN 
 RETURN ( SIZEOF ( 
QUERY ( ccs <* crv\composite_curve.segments| NOT valid_geometrically_bounded_wf_curve(ccs.parent_curve) )) = 0);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
FUNCTION valid_geometrically_bounded_wf_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT_ON_CURVE' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_curve(pnt\point_on_curve.basis_curve));
 ELSE 
 IF 'AIC_GEOMETRICALLY_BOUNDED_WIREFRAME.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_geometrically_bounded_wf_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
END_SCHEMA;
 
(*
ISO TC184/SC4/WG3 N7300 - ISO/IS 10303-522e3
*) 

SCHEMA aic_machining_feature;
  
  USE FROM external_reference_schema              -- ISO 10303-41	
      (externally_defined_item);   
      
  USE FROM geometry_schema		              -- ISO 10303-42
      (bounded_curve,
       direction,
       plane,
       placement,
       point);
      
  USE FROM measure_schema                         -- ISO 10303-41
      (count_measure,
       length_measure_with_unit,
       measure_with_unit,
       named_unit,
       plane_angle_measure_with_unit,
       ratio_measure_with_unit); 
       
  USE FROM product_definition_schema              -- ISO 10303-41
      (product_definition);
       
  USE FROM product_property_definition_schema     -- ISO 10303-41
      (characterized_object,
       product_definition_shape, 
       property_definition,
       shape_aspect,
       shape_aspect_relationship);
       
  USE FROM product_property_representation_schema  -- ISO 10303-41
      (property_definition_representation,
      shape_representation);
      
  REFERENCE FROM product_property_representation_schema  -- ISO 10303-41
      (get_property_definition_representations);    
      
    
  USE FROM qualified_measure_schema                -- ISO 10303-45
      (descriptive_representation_item,
       measure_representation_item);
       
  USE FROM shape_aspect_definition_schema          -- ISO 10303-47
      (composite_shape_aspect,
       feature_definition,
       instanced_feature,
       shape_representation_with_parameters);
       
  USE FROM topology_schema                         -- ISO 10303-42
      (edge_curve,
       face_surface,
       oriented_face,
       path);

TYPE machining_feature_definition = SELECT (
  boss,
  compound_feature,
  externally_defined_feature_definition,
  flat_face,
  gear,
  marking,
  outer_round,
  outside_profile,
  pocket,
  protrusion,
  removal_volume,
  replicate_feature,
  revolved_profile,
  rib_top,
  round_hole,
  rounded_end,
  spherical_cap,
  step,
  slot,
  thread,
  turned_knurl);
END_TYPE;  

ENTITY applied_area
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE'
         IN TYPEOF(SELF.of_shape));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
         used_representation)) ) |  
         (NOT({2 <= SIZEOF(impl_rep.used_representation.items) <= 3} )
          ) )) = 0)) )) = 0);
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         (SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         NOT (srwp_i.name IN ['orientation','effective length', 
         'maximum length']) )) > 0 ) )) = 0 )   )) = 0;
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'effective length')) )) = 1)) )) 
         = 0)) )) <= 1);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'maximum length')) )) <= 1)) )) 
         = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it))  AND (it.name = 'orientation')) )) = 1)) )) 
         = 0)) )) = 0);
END_ENTITY; -- applied_area

ENTITY boss
  SUBTYPE OF (feature_definition);
   WHERE   
    WR1: SELF\characterized_object.description IN 
         ['circular', 'complex', 'rectangular'];
    WR2: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
         TYPEOF (pd)) |
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'boss height occurrence') AND
         (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'path feature component usage') AND 
         ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN TYPEOF (sar))) |
         ('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' IN
         TYPEOF (sdr.relating_shape_aspect)) AND
         (sdr.relating_shape_aspect.description = 'linear') AND
         (sdr.name = 'boss height'))) = 1))) = 1))) = 0; 
    WR3: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         ({1 <= SIZEOF(pdr.used_representation.items) <= 2} ) )) = 1 )) = 1;
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
         TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         (srwp_i.name = 'orientation') OR
         (srwp_i.name = 'fillet radius'))) 
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF (
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'fillet radius'))) <= 1))) 
         = 0))) = 0;
    WR6: (NOT (SELF\characterized_object.description = 'circular')) OR
         (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF (pd)) |
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'circular profile occurrence') AND
         (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'profile usage') AND 
         ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
         IN TYPEOF (sar))) |
         'AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE' 
         IN TYPEOF (sdr.relating_shape_aspect))) = 1))) = 1))) = 0);        
    WR7: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'top condition occurrence') AND 
       (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
   'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
       ((sar.description = 'boss top usage') AND 
       ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
       IN TYPEOF(sar))) ) | (('AIC_MACHINING_FEATURE.BOSS_TOP' 
       IN TYPEOF(fcr.relating_shape_aspect)) ) )) = 1)) )) = 1)) )) = 0;       
    WR8: (NOT (SELF\characterized_object.description = 'circular')) OR
         (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
         TYPEOF (pd)) | 
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'change in diameter occurrence') AND
         (SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (sa_occ, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'taper usage') AND
         ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF (sar))) | 
       (('AIC_MACHINING_FEATURE.TAPER' IN TYPEOF (fcr.related_shape_aspect)) 
         AND
         ('AIC_MACHINING_FEATURE.BOSS' IN TYPEOF (fcr.relating_shape_aspect)))
         ) )= 1))) <= 1))) = 0);
    WR9: (NOT (SELF\characterized_object.description = 'complex')) OR
         (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
          TYPEOF (pd)) | 
          NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
          (sa_occ.description = 'enclosed boundary occurrence') AND
          (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
          (sar.description = 'profile usage') AND
          ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
          IN TYPEOF (sar))) |
          SIZEOF (['AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
          'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE'] *  
          TYPEOF (sdr.relating_shape_aspect)) = 1)) = 1)))= 1))) = 0);
    WR10: (NOT (SELF\characterized_object.description 
          IN ['complex','rectangular'])) OR
          (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
          IN TYPEOF (pd)) | 
          NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
          (sa_occ.description = 'change in boundary occurrence') AND
          (SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (sa_occ, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
          (sar.description = 'taper usage') AND
          ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
          IN TYPEOF (sar))) |
       (('AIC_MACHINING_FEATURE.TAPER' IN TYPEOF (fcr.related_shape_aspect)) 
          AND
        ('AIC_MACHINING_FEATURE.BOSS' IN TYPEOF (fcr.relating_shape_aspect)) 
          AND
          (fcr.related_shape_aspect.description IN 
          ['angle taper','directed taper']))
          )) = 1))) <= 1))) = 0);
    WR11: (NOT (SELF\characterized_object.description = 'rectangular')) OR
          (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
          IN TYPEOF (pd)) |
          NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
          (sa_occ.description = 'rectangular profile occurrence') AND
          (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ, 
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
          (sar.description = 'profile usage') AND 
          ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
          IN TYPEOF (sar))) |
          'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE' 
          IN TYPEOF (sdr.relating_shape_aspect))) = 1))) = 1))) = 0);
  
 WR12: SIZEOF (QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0;
END_ENTITY;  -- Boss


ENTITY boss_top
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['planar','complex']);
    WR3: ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR4: ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('AIC_MACHINING_FEATURE.LOCATION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR5: (NOT (SELF.description = 'complex')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation) )) = 1)) )) = 0);
    WR6: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.'  + 
         'RELATING_SHAPE_ASPECT') | 
         ((sar.description = 'boss top usage') AND
         (sar.name  IN ['boss height start','boss height end']))AND
         ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)))  | 
        ((fcr.related_shape_aspect.description = 'top condition occurrence') 
         AND 
         ('AIC_MACHINING_FEATURE.BOSS' 
         IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND 
         ('AIC_MACHINING_FEATURE.BOSS_TOP' 
         IN TYPEOF(fcr.relating_shape_aspect)) ) 
         )) >= 1);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |  
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) <= 1)) )) = 0);
    WR8: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
   WR9: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF (
        ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF (it)) = 2) AND (it.name = 'top radius'))) <= 1))) 
        = 0))) = 0;
END_ENTITY; -- boss_top  

ENTITY chamfer
  SUBTYPE OF (transition_feature);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'chamfer face')) )) <= 1)) )) = 0);
    WR2: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) ) | 
         (('AIC_MACHINING_FEATURE.CHAMFER_OFFSET' 
         IN TYPEOF(fcr.related_shape_aspect))AND 
         ('AIC_MACHINING_FEATURE.CHAMFER' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         (fcr.related_shape_aspect.description = 'first offset') ) 
          )) = 1);
    WR3: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
         ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) ) | 
         (('AIC_MACHINING_FEATURE.CHAMFER_OFFSET' 
         IN TYPEOF(fcr.related_shape_aspect))  AND 
         ('AIC_MACHINING_FEATURE.CHAMFER' 
         IN TYPEOF(fcr.relating_shape_aspect))AND 
         (fcr.related_shape_aspect.description = 'second offset')) 
         )) = 1);
END_ENTITY; -- chamfer

ENTITY chamfer_offset
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: (SELF.description IN ['first offset','second offset']);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
    WR4: ((NOT (SELF.description = 'first offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'offset amount')) )) = 1)) )) 
         = 0)) )) = 0));
    WR5: ((NOT (SELF.description = 'first offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |  
         (('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'first face shape')) )) <= 1)) )) 
         = 0));
    WR6: ((NOT (SELF.description = 'second offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'offset amount')) OR 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] 
         * TYPEOF(it)) = 2) AND (it.name = 'offset angle'))) )) = 1)) )) 
         = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'second offset')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |        
         (('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'second face shape')) )) <= 1)) )) 
         = 0));
    WR8: (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar)) ) | 
         (('AIC_MACHINING_FEATURE.CHAMFER' 
         IN TYPEOF(sdr.relating_shape_aspect))AND 
        ('AIC_MACHINING_FEATURE.CHAMFER_OFFSET' 
         IN TYPEOF(sdr.related_shape_aspect)))
         )) = 1);
END_ENTITY; -- chamfer_offset

ENTITY circular_pattern
  SUBTYPE OF (replicate_feature);
   WHERE
    WR1: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
         (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         ((('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
         IN TYPEOF(sdr.related_shape_aspect)) )) = 1)) )) <= 3)) )) = 0);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT ((SIZEOF (impl_rep.used_representation.items) >= 3)  
         AND (SIZEOF(impl_rep.used_representation.items) <= 5))) )) 
         = 0)) )) = 0);
     WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF(
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'diameter')) )) <= 1)) )) 
         = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF(
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] * 
         TYPEOF(it)) = 2) AND (it.name = 'base feature rotation')) )) 
         <= 1)) )) = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'number of features')) )) = 1)) )) = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF(
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] * 
         TYPEOF(it)) = 2) AND (it.name = 'angular spacing'))))= 1)) )) 
         = 0)) )) = 0);
    WR8: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
         = 0)) )) = 0);
END_ENTITY; -- circular_pattern

ENTITY circular_closed_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS')
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         NOT(SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) 
         AND (it.name = 'orientation')) )) = 1) )) = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'diameter')) )) = 1)) )) 
         =  0)) )) = 0);
END_ENTITY; -- circular_closed_profile

ENTITY closed_path_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
         = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('TOPOLOGY_SCHEMA.PATH_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
END_ENTITY; -- closed_path_profile

ENTITY composite_hole
  SUBTYPE OF (compound_feature);
   WHERE
    WR1: (SELF\characterized_object.description IN ['counterbore',
         'countersunk']);
    WR2:  SIZEOF(QUERY ( pds <* USEDIN(SELF,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
           (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
           IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
           IN TYPEOF(csa)) AND 
           (SIZEOF(QUERY ( sar <* csa.component_relationships | 
           ((('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar)) AND ('AIC_MACHINING_FEATURE.ROUND_HOLE' 
           IN TYPEOF(sar.related_shape_aspect))) 
           ))) = 2)) )) = 1)) )) = 1; 
  WR3: (NOT (SELF\characterized_object.description = 'countersunk')) OR 
       (SIZEOF(QUERY ( pds <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pds)) AND 
       (SIZEOF(QUERY ( csa <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT'  
       IN TYPEOF(csa)) AND 
       (SIZEOF(QUERY ( sar <* csa.component_relationships | 
       (('AIC_MACHINING_FEATURE.ROUND_HOLE' 
       IN TYPEOF(sar.related_shape_aspect)) AND 
       (NOT (SIZEOF(QUERY ( pds <* QUERY ( pd <* 
       USEDIN(sar.related_shape_aspect,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'change in diameter occurrence') AND
       (SIZEOF(QUERY ( fcr2 <* QUERY ( sar2 <* USEDIN(sa_occ,
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
       ((sar2.description = 'taper usage') AND 
       ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
       IN TYPEOF(sar2))) ) | 
      ('AIC_MACHINING_FEATURE.TAPER' IN TYPEOF(fcr2.related_shape_aspect))  
       )) = 1)) )) = 0)) )) = 0))) )) = 1)) )) = 1)) )) = 1);
END_ENTITY; -- composite_hole

ENTITY compound_feature
  SUBTYPE OF (feature_definition);
     WHERE 
    WR1:  SIZEOF( QUERY( pds <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pds))  AND
        (SIZEOF( QUERY( csa <* USEDIN( pds, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        ((csa.name='compound feature in solid') AND
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
        IN TYPEOF(csa))) )) = 1)  )) = 1;
    WR2: SIZEOF( QUERY( pds <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pds))  AND
       (SIZEOF( QUERY( csa <* USEDIN( pds, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF(csa) )) = 1)  )) = 1; 
    WR3: (SIZEOF(QUERY ( pds <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF(csa)) AND 
       (SIZEOF(QUERY ( fcr <* csa.component_relationships | 
       (NOT ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
       IN TYPEOF(fcr))) )) = 0)) )) = 1)) )) = 1);             
   WR4: SIZEOF (QUERY (pds <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF (pds)) AND 
       (SIZEOF (QUERY (csa <* USEDIN (pds, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE')| 
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF (csa))   )) = 1) )) = 1; 
    WR5: (SIZEOF(QUERY ( pds <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pds)) AND 
       (SIZEOF(QUERY ( csa <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF(csa)) AND 
       (SIZEOF(QUERY ( sar <* csa.component_relationships | 
       ('AIC_MACHINING_FEATURE.THREAD' 
       IN TYPEOF(sar.related_shape_aspect)) )) = 0)
       ) )) = 1)) )) = 1);  
    WR6: (SIZEOF (QUERY (pds <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF (pds)) AND   (SIZEOF (QUERY (csa <* USEDIN (pds, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE')|
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
       IN TYPEOF (csa))  AND 
       (SIZEOF (QUERY (sar <*  csa.component_relationships |
       (('AIC_MACHINING_FEATURE.COMPOUND_FEATURE' 
       IN TYPEOF (sar.related_shape_aspect))  AND
       (sar.related_shape_aspect\characterized_object.name <> 
       SELF\characterized_object.name)) )) = 0)  )) = 1) )) = 1); 
END_ENTITY;  -- compound_feature
 
ENTITY direction_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE
    WR1: (SIZEOF(SELF.items) = 1);
    WR2: (SIZEOF(QUERY ( it <* SELF.items | 
         (NOT (
         'AIC_MACHINING_FEATURE.DIRECTION' IN TYPEOF(it))) )) 
         = 0);
END_ENTITY; -- direction_shape_representation

ENTITY edge_round
  SUBTYPE OF (transition_feature);
WHERE
    WR1: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <*  USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF (pdr.used_representation))) = 1))) = 0);
    WR2: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
         AND  (SIZEOF (impl_rep.used_representation.items) <= 3)))) 
         = 0))) = 0); 
    WR3: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'radius'))) = 1))) = 0))) = 0);
    WR4: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'first offset'))) <= 1))) 
         = 0))) = 0);
    WR5: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'second offset'))) <= 1))) 
         = 0))) = 0);
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'edge round face'))) <= 1))) = 0; 
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'first face shape'))) <= 1))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'second face shape'))) <= 1))) = 0;
END_ENTITY; -- edge_round


ENTITY externally_defined_feature_definition
  SUBTYPE OF (feature_definition, externally_defined_item);
   WHERE
    WR1: (((SELF\characterized_object.description = 'thread') AND 
         (SELF\externally_defined_item.item_id='external thread') AND 
         (SELF\externally_defined_item.source.source_id=
         'external feature specification') ) OR 
         ((SELF\characterized_object.description = 'gear') AND 
         (SELF\externally_defined_item.item_id='external gear') AND 
         (SELF\externally_defined_item.source.source_id=
         'external feature specification')) OR 
         ((SELF\characterized_object.description = 'marking') AND 
         (SELF\externally_defined_item.item_id='external marking') AND 
         (SELF\externally_defined_item.source.source_id=
         'external feature specification')) OR 
         ((SELF\characterized_object.description = 'knurl') AND 
         (SELF\externally_defined_item.item_id='external knurl') AND  
         (SELF\externally_defined_item.source.source_id=
         'external feature specification')));
    WR2: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         ({5 <= SIZEOF(pdr.used_representation.items) <= 10} ) )) 
         = 1  )) = 1));
    WR3: ((NOT (SELF\characterized_object.description = 'marking')) OR 
         (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF(pdr.used_representation.items) = 2)  )) = 1  )) = 1));
    WR4: ((NOT (SELF\characterized_object.description = 'knurl')) OR 
         (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF(pdr.used_representation.items) = 1)   )) = 1  )) = 1));
    WR5: (NOT (SELF\characterized_object.description IN [ 'knurl',
         'thread'])) OR
         (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
         (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'partial area occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'applied area usage') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         ('AIC_MACHINING_FEATURE.APPLIED_AREA' 
         IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) <= 1)) )) = 0); 

    WR6: ((NOT (SELF\characterized_object.description = 'marking')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'marking text')) )) = 1)) )) 
         = 0)) )) = 0));
    WR7: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'removal direction') AND 
         ((it.description = 'internal') OR 
         (it.description = 'external'))) )) = 1)) )) = 0)) )) = 0));
     WR8: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'qualifier')) ))<= 1)) ))= 0)) )) 
         = 0));
    WR9: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <*  USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'hand')) )) = 1)) )) = 0)) )) 
         = 0));
     WR10: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'fit class')) )) = 1)) )) = 
         0)) )) = 0));
     WR11: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND (it.name = 'form')) )) = 1)) )) = 0)) )) 
         = 0));
    WR12: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'major diameter')) )) <= 1)) )) 
         = 0)) )) = 0));
     WR13: ((NOT (SELF\characterized_object.description = 'thread')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
         (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'number of threads')) )) = 1)) )) 
         = 0)) )) = 0));
     WR14 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'fit class 2')) )) <= 1)) )) = 0)) )) 
        = 0);   
        
     WR15 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'nominal size')) )) 
        <= 1)) )) = 0)) )) = 0); 

    WR16: (NOT (SELF\characterized_object.description IN [ 'knurl',
         'gear', 'thread'])) OR
         (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
         (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'applied shape') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
         IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) <= 1)) )) = 0);
     WR17: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR 
          (SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          SIZEOF( QUERY( pdr <* USEDIN( pd, 
          'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
          ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
          IN TYPEOF(pdr.used_representation)) AND 
          (10 <= SIZEOF(pdr.used_representation.items)) AND 
          (SIZEOF(pdr.used_representation.items) >= 11)    
          )) = 1  )) = 1));

 WR18: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'number of teeth')) )) = 1)) )) 
       = 0)) )) = 0));

 WR19: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
    TYPEOF(it)) = 2) AND (it.name = 'reference pressure angle')) )) = 1)) )) 
       = 0)) )) = 0));

 WR20: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'rake shift factor')) )) = 1)) )) 
       = 0)) )) = 0));

 WR21: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'nominal tooth depth')) )) = 1)) )) 
       = 0)) )) = 0));

 WR22: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'face width')) )) = 1)) )) 
       = 0)) )) = 0));

 WR23: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'tip diameter')) )) = 1)) )) 
       = 0)) )) = 0));

  WR24: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR 
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND (it.name = 'module or diametral pitch') AND 
       ((it.description = 'module') OR 
       (it.description = 'diametral pitch'))) )) = 1)) )) = 0)) )) = 0));

 WR25: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'normal attribute')) )) = 1)) )) 
       = 0)) )) = 0));

  WR26: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR 
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND (it.name = 'internal or external gear') AND 
       ((it.description = 'internal') OR 
       (it.description = 'external'))) )) = 1)) )) = 0)) )) = 0));

 WR27: ((NOT (SELF\characterized_object.description 
          IN ['gear'])) OR  
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN
       (pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
    TYPEOF(it)) = 2) AND (it.name = 'root fillet radius')) )) <= 1)) )) 
       = 0)) )) = 0));

END_ENTITY; -- externally_defined_feature_definition

ENTITY face_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE
    WR1: (SIZEOF(SELF.items) >= 1);
    WR2: (SIZEOF(QUERY ( it <* SELF.items | (NOT (
         ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF(it)) OR
         ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF(it)) ))
          )) = 0);
END_ENTITY; -- face_shape_representation 
   
ENTITY feature_component_definition
  SUBTYPE OF (characterized_object);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(USEDIN(pd,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE')) = 1)) )) 
        = 0);
END_ENTITY; -- feature_component_definition

ENTITY feature_component_relationship
  SUPERTYPE OF (ONEOF (pattern_omit_membership,pattern_offset_membership))
  SUBTYPE OF (shape_aspect_relationship);
   WHERE
    WR1: ((SIZEOF([
         'SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT',
         'AIC_MACHINING_FEATURE.REPLICATE_FEATURE',
         'AIC_MACHINING_FEATURE.TRANSITION_FEATURE',
         'AIC_MACHINING_FEATURE.MODIFIED_PATTERN'] * TYPEOF
         (SELF.relating_shape_aspect)) = 1) OR 
         ('AIC_MACHINING_FEATURE.MACHINING_FEATURE_DEFINITION' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition)) OR 
         ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition)));
END_ENTITY; -- feature_component_relationship

ENTITY feature_pattern
  SUBTYPE OF (replicate_feature);
   WHERE
    WR1: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         NOT ('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(srwp_i)) )) > 0 ) ))   > 0  )) = 0;
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         ('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF (it)) AND (it.name = 'base feature placement'))) > 1))) 
         = 0))) = 0;
END_ENTITY; -- feature_pattern

ENTITY fillet
  SUBTYPE OF (transition_feature);
  WHERE
    WR1: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <*  USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF (pdr.used_representation))) = 1))) = 0);
    WR2: (NOT (SELF\shape_aspect.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
         AND(SIZEOF (impl_rep.used_representation.items) <= 3)))) 
         = 0))) = 0); 
    WR3: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'radius'))) = 1))) = 0))) = 0);
    WR4: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'first offset'))) <= 1))) 
         = 0))) = 0);
    WR5: (NOT (SELF.description = 'constant radius')) OR
         (SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'second offset'))) <= 1))) 
         = 0))) = 0); 
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'fillet face'))) = 1))) = 0; 
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'first face shape'))) = 1))) = 0; 
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation)) AND 
         (pdr.used_representation.name = 'second face shape'))) = 1))) = 0;  
END_ENTITY;

ENTITY flat_face
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         (('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'removal direction')) )) = 1)) )) 
         = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'course of travel occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'path feature component usage') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         (sdr.relating_shape_aspect.description = 'linear') AND 
         (sdr.name = 'course of travel')) )) = 1)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'removal boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'profile usage') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('AIC_MACHINING_FEATURE.LINEAR_PROFILE' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         (sdr.name = 'removal boundary')) )) = 1)) )) = 1)) )) = 0);
    WR4: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF (pd)) | 
         NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
         (sa_occ.description = 'enclosed boundary occurrence') AND
         (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (sar.description = 'profile usage') AND
         ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
         IN TYPEOF (sar))) |
         (SIZEOF 
         (['AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE', 
         'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
         'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
         'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE'] *
         TYPEOF (sdr.relating_shape_aspect)) = 1) AND
         (sdr.relating_shape_aspect.description = 'boundary'))) 
         = 1))) <= 1))) = 0;
  WR5: SIZEOF(QUERY( pdr <* get_property_definition_representations (SELF) | 
        ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0;
   WR6: SIZEOF(QUERY ( pds <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN 
        TYPEOF(csa)) AND 
        (csa.name='uncut volume') AND 
        (SIZEOF(QUERY ( sar <* csa.component_relationships | 
        (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (SIZEOF([
        'AIC_MACHINING_FEATURE.BOSS',
        'AIC_MACHINING_FEATURE.PROTRUSION'] * TYPEOF(sar.
        related_shape_aspect)) = 1)) )) = 1)) )) <= 1)) )) = 1;            
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF (
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'removal depth'))) <= 1))) 
         = 0))) = 0;     
        
END_ENTITY; -- flat_face  


ENTITY gear
  SUBTYPE OF (feature_definition);
WHERE
  WR1 : SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    SIZEOF(QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) 
    AND (10 <= SIZEOF(pdr.used_representation.items)) AND 
    (SIZEOF(pdr.used_representation.items) <= 13))) = 1)) = 1;
    
  WR2 : NOT (SELF\characterized_object.description 
      IN ['straight bevel gear', 'helical bevel gear', 
          'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
     (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND 
    (it.name = 'number of teeth'))) = 1))) = 0))) = 0);
    
  WR3 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
            'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF,  
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
   'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'reference pressure angle'))) = 1))) = 0))) = 0);
     
  WR4 : NOT (SELF\characterized_object.description 
      IN ['straight bevel gear', 'helical bevel gear', 
      'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
   'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) = 2) AND 
    (it.name = 'rake shift factor'))) = 1))) = 0))) = 0);
    
  WR5 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'nominal tooth depth'))) = 1))) = 0))) = 0);
    
  WR6 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'face width'))) = 1))) = 0))) = 0);
    
  WR7 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'tip diameter'))) = 1))) = 0))) = 0);
    
  WR8 : NOT (SELF\characterized_object.description 
       IN ['straight bevel gear', 'helical bevel gear', 
       'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND 
    (it.name = 'module or diametral pitch') AND 
    ((it.description ='module') OR (it.description = 'diametral pitch')))) 
    = 1))) = 0))) = 0);
    
  WR9 : NOT (SELF\characterized_object.description 
       IN ['straight bevel gear', 'helical bevel gear', 
       'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it)) AND 
    (it.name = 'internal or external gear') AND 
    ((it.description ='internal') OR (it.description = 'external')))) 
    = 1))) = 0))) = 0);   
     
  WR10: NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'normal attribute'))) = 1))) = 0))) = 0);
    
  WR11 : NOT (SELF\characterized_object.description 
        IN ['straight bevel gear', 'helical bevel gear', 
        'spur gear', 'helical gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
    'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT']* TYPEOF(it)) = 2) AND 
    (it.name = 'root fillet radius'))) <= 1))) = 0))) = 0);
    
  WR12 : NOT (SELF\characterized_object.description 
    IN ['helix gear','helical bevel gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    NOT (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'reference helix angle'))) = 1))) = 0))) =  0);
    
  WR13 : NOT (SELF\characterized_object.description 
       IN ['helix gear','helical bevel gear']) OR 
       (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | NOT 
    (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation))| NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | 
     ('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
     IN TYPEOF(it)) AND (it.name = 'gear tooth') AND 
     ((it.description = 'left hand tooth') OR 
     (it.description = 'right hand tooth')))) = 1))) = 0))) = 0);
    
  WR14 : NOT (SELF\characterized_object.description 
    IN ['straight bevel gear','helical bevel gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    NOT (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'tip angle'))) = 1))) = 0))) =   0);
    
  WR15 : NOT (SELF\characterized_object.description 
    IN ['straight bevel gear','helical bevel gear']) OR 
    (SIZEOF(QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    NOT (SIZEOF(QUERY(impl_rep <* QUERY(pdr <* USEDIN(pd, 
   'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
    'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
    IN TYPEOF(pdr.used_representation)) | NOT 
     (SIZEOF(QUERY(it <* impl_rep.used_representation.items | (SIZEOF([
    'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 
'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT']* TYPEOF(it))= 2) AND 
    (it.name = 'root angle'))) = 1))) = 0))) =  0);
    
  WR16 : SIZEOF(QUERY(pds <* QUERY(pd <* USEDIN(SELF, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) | NOT 
    (SIZEOF(QUERY(sa_occ <* USEDIN(pds, 
    'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
    SIZEOF( QUERY(sdr <* QUERY(sar <* USEDIN(sa_occ, 
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
    (sar.description = 'applied shape') AND 
    ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
    IN TYPEOF(sar))) | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
    IN TYPEOF(sdr.relating_shape_aspect))) = 1)) = 1))) = 0;
    
END_ENTITY;

ENTITY hole_bottom
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['through', 'flat', 'flat with radius',
         'flat with taper','spherical', 'conical']);
    WR3: ((NOT (SELF.description = 'through')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 0)) )) 
          = 0));
    WR4: ((NOT (SELF.description IN ['flat with radius', 
         'flat with taper', 'spherical','conical'])) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
   WR5: ((NOT (SELF.description = 'flat')) OR 
        (SIZEOF(QUERY ( pd <*  USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 0)) )) 
         = 0)) )) = 0));
    WR6: ((NOT (SELF.description IN ['flat with radius','spherical'])) 
        OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'flat with taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
        = 0)) )) = 0));
    WR8: ((NOT (SELF.description = 'conical')) OR (SIZEOF(
        QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 2)) )) 
        = 0)) )) = 0));
    WR9: ((SELF.description = 'through') OR 
        (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        ((sar.description = 'hole bottom usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar))) ) | 
        ((fcr.name IN ['hole depth start','hole depth end'])) )) >= 1));
   WR10: ((NOT (SELF.description = 'flat with radius')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF(it)) = 2) AND (it.name = 'corner radius')))) = 1)) )) 
        = 0)) )) = 0));
    WR11: ((NOT (SELF.description = 'spherical')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)) )) = 
        0)) )) = 0));
    WR12: ((NOT (SELF.description = 'conical')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'tip radius')) )) <= 1)) )) 
        = 0)) )) = 0));
    WR13: ((NOT (SELF.description = 'conical')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'tip angle')) )) = 1)) )) 
        = 0)) )) = 0));
    WR14: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        ((sar.description = 'hole bottom usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar))) ) | 
      ((fcr.related_shape_aspect.description ='bottom condition occurrence') 
        AND ('AIC_MACHINING_FEATURE.ROUND_HOLE' 
        IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND 
        ('AIC_MACHINING_FEATURE.HOLE_BOTTOM' 
        IN TYPEOF(fcr.relating_shape_aspect))) 
        )) >= 1);
    WR15: ((NOT (SELF.description = 'flat with taper')) OR (SIZEOF(
        QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |  
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'final diameter')))) = 1)) )) 
        = 0)) )) = 0));
    WR16: ((NOT (SELF.description = 'flat with taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name =  'taper diameter')) )) = 1)) )) 
        = 0)) )) = 0));
 END_ENTITY; -- hole_bottom

ENTITY linear_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF(it)) AND 
         (it.name = 'orientation')) )) = 1)) )) = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'profile length')) )) = 1)) )) 
         = 0)) )) = 0);
END_ENTITY; -- linear_profile
 
ENTITY location_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
   WR1: (SIZEOF(SELF.items) = 1);
   WR2: (SIZEOF(QUERY ( it <* SELF.items | 
        (NOT ('GEOMETRY_SCHEMA.POINT' 
        IN TYPEOF(it))) )) = 0);
END_ENTITY; -- location_shape_representation

ENTITY marking
  SUBTYPE OF (feature_definition);
WHERE
    WR1: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
        TYPEOF(pdr.used_representation)) AND
        ({2 <= SIZEOF(pdr.used_representation.items) <=6} ) )) 
        = 1 )) = 1;
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* 
        QUERY ( pdr <* USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'marking text')) )) = 1)) )) 
        = 0)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'special instructions')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'font name')))) <= 1)))) 
        = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'character height')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'character spacing')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
        + 'RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'applied shape') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
        IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
END_ENTITY; -- marking

ENTITY modified_pattern
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: SIZEOF( QUERY (fcr <* QUERY(sar <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar)) |
        (SIZEOF( 
        ['AIC_MACHINING_FEATURE.REPLICATE_FEATURE',
        'SHAPE_ASPECT_DEFINITION_SCHEMA.INSTANCED_FEATURE'] * 
        TYPEOF (fcr.related_shape_aspect.of_shape.definition)) >= 1)  AND
        (fcr.description = 'base shape')) ) = 1;
   WR2: SIZEOF( QUERY (fcr <* QUERY(sar <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
        'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar)) |
        (SIZEOF( 
        ['AIC_MACHINING_FEATURE.CIRCULAR_PATTERN', 
        'AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN'] * 
        TYPEOF(fcr.related_shape_aspect.of_shape.definition)) = 1) AND 
        (fcr.description = 'base pattern')) ) = 1;
   WR3: SIZEOF(QUERY ( sar <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (SIZEOF(QUERY ( msar <* USEDIN(sar.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        (SIZEOF([
        'AIC_MACHINING_FEATURE.PATTERN_OFFSET_MEMBERSHIP',
        'AIC_MACHINING_FEATURE.PATTERN_OMIT_MEMBERSHIP'] * 
        TYPEOF(sar)) = 1) AND (sar.description='modified pattern') 
        AND (sar :<>: msar) )) >= 1) )) = 0;
END_ENTITY; -- modified_pattern

ENTITY ngon_closed_profile
  SUBTYPE OF (shape_aspect);
WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT ((SIZEOF (impl_rep.used_representation.items) >= 3)  
         AND (SIZEOF(impl_rep.used_representation.items) <= 4)))) = 0))) = 0;
    WR4:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         (srwp_i.name = 'orientation') OR
         (srwp_i.name = 'number of sides') OR
         (srwp_i.name = 'circumscribed diameter') OR
         (srwp_i.name = 'corner radius') OR
         (srwp_i.name = 'diameter across flats'))) 
         = SIZEOF(pdr.used_representation.items))  )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
         (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF (it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF (it\measure_with_unit.value_component)) AND 
         (it.name = 'number of sides'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
         TYPEOF (it)) = 2) AND 
         (it.name IN ['circumscribed diameter','diameter across flats']) )) 
         = 1) )) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF 
         (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
         TYPEOF (it)) = 2) AND 
         (it.name = 'corner radius'))) <= 1))) = 0))) = 0;
  END_ENTITY;

ENTITY open_path_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
         IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF (impl_rep.used_representation.items) = 1)) )) 
         = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' 
         IN TYPEOF(it)) AND 
         (it.name = 'orientation')) )) = 1)) )) = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         ('TOPOLOGY_SCHEMA.PATH_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
         IN TYPEOF (pdr.used_representation))AND
         (pdr.used_representation.name = 'profile limit') )) <= 1))) = 0;
END_ENTITY;

ENTITY outer_round
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: ((NOT (SELF\characterized_object.description = 'outer diameter')) OR 
        (SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF (pdr.used_representation.items) = 3) )) = 1 )) = 1));
    WR2: ((NOT (SELF\characterized_object.description 
        = 'outer diameter to shoulder')) OR 
        (SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
       ( {2 <= SIZEOF(pdr.used_representation.items) <= 3}) )) = 1 )) = 1));
    WR3: (SELF\characterized_object.description IN 
        ['outer diameter', 'outer diameter to shoulder']);
  WR4: ((NOT (SELF\characterized_object.description = 'outer diameter')) OR 
        (SIZEOF( QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'length')) )) = 1)) ))
        = 0)) )) = 0));
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'diameter')) )) = 1)) )) 
        = 0)) )) = 0);
    WR6: ((NOT (SELF\characterized_object.description 
        = 'outer diameter to shoulder')) OR (
        SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'v-shape boundary occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('AIC_MACHINING_FEATURE.VEE_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'v-shape')) )) = 1)) )) 
        = 1)) )) = 0));
  WR7: ((NOT (SELF\characterized_object.description = 'outer diameter')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'reduced size occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'taper usage') AND 
        (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('AIC_MACHINING_FEATURE.TAPER' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        ('AIC_MACHINING_FEATURE.OUTER_ROUND' 
        IN TYPEOF(sdr.related_shape_aspect.of_shape.definition)) AND 
        (sdr.name = 'reduced size')) 
        ))  = 1)) ))
        <= 1)) )) = 0));
    WR8: ((NOT (SELF\characterized_object.description = 
         'outer diameter to shoulder')) OR 
        (SIZEOF( QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'length')) )) <= 1)) ))
        = 0)) )) = 0));  
     WR9: ((NOT (SELF\characterized_object.description = 
         'outer diameter to shoulder')) OR 
        (SIZEOF( QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'feature length')) )) <= 1)) ))
        = 0)) )) = 0));         
END_ENTITY; -- outer_round

ENTITY outside_profile
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF (pdr.used_representation.items) = 1) )) = 1 )) = 1;
    WR2: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['boundary occurrence',
        'non-planar boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) )) =1)  ))=0;
    WR3: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'boundary occurrence') )) =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN TYPEOF (sar))) |
        (SIZEOF (['AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE', 
        'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
        'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
        'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE',
        'AIC_MACHINING_FEATURE.SQUARE_U_PROFILE',
        'AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE',
        'AIC_MACHINING_FEATURE.ROUNDED_U_PROFILE',
        'AIC_MACHINING_FEATURE.LINEAR_PROFILE',
        'AIC_MACHINING_FEATURE.VEE_PROFILE',
        'AIC_MACHINING_FEATURE.TEE_PROFILE',
        'AIC_MACHINING_FEATURE.OPEN_PATH_PROFILE'] *
        TYPEOF (sdr.relating_shape_aspect)) = 1) AND
        (sdr.relating_shape_aspect.description = 'outside boundary'))) 
        = 1))) = 1))) = 0);  
    WR4: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['complex boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) ))=1)   ))=0)) OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        NOT(SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile floor usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('AIC_MACHINING_FEATURE.PROFILE_FLOOR' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('AIC_MACHINING_FEATURE.OUTSIDE_PROFILE' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition)))
        )) = 1))) = 0))) = 0);
    WR5: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['outside boundary',
        'complex boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) ))=1)   ))=0)) OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'path feature component usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' IN TYPEOF (sar))) |
        (SIZEOF (['TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT'] *
        TYPEOF (sdr.relating_shape_aspect)) = 1) AND
        (sdr.name = 'profile swept shape') AND
        (sdr.relating_shape_aspect.description='linear') ))  = 1))) 
        = 1))) = 0);
    WR6: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'complex boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (SIZEOF (['AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE',
        'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
        'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
        'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE',
        'AIC_MACHINING_FEATURE.SQUARE_U_PROFILE',
        'AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE',
        'AIC_MACHINING_FEATURE.ROUNDED_U_PROFILE',
        'AIC_MACHINING_FEATURE.VEE_PROFILE',
        'AIC_MACHINING_FEATURE.TEE_PROFILE',
        'AIC_MACHINING_FEATURE.LINEAR_PROFILE',
        'AIC_MACHINING_FEATURE.OPEN_PATH_PROFILE'] *  
        TYPEOF (sdr.relating_shape_aspect)) =1))  ) 
        = 1)))= 1))) = 0);
    WR7: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'partial circular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)))) 
        = 1)))= 1))) = 0);
    WR8: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'closed circular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)))) 
        = 1)))= 1))) = 0);
    WR9: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'open rectangular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('AIC_MACHINING_FEATURE.SQUARE_U_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)))) 
        = 1)))= 1))) = 0);
    WR10: (NOT(SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'closed rectangular boundary occurrence') )) 
        =1)  ))=0))  OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE' IN  
        TYPEOF (sdr.relating_shape_aspect)) )) = 1)))
        = 1))) = 0);
    WR11: (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description IN ['boundary occurrence',
        'complex boundary occurrence',
        'partial circular boundary occurrence',
        'closed circular boundary occurrence',
        'open rectangular boundary occurrence',
        'closed rectangular boundary occurrence']) )) =1)  ))=0) OR
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        (('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'removal direction')) )) = 1)) )) 
        = 0);
  WR12: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY; -- outside_profile

ENTITY partial_circular_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 3)) )) 
        = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        (('GEOMETRY_SCHEMA.PLACEMENT' 
        IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
        = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')))) = 1)) )) 
        = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'sweep angle')) )) = 1)) )) 
        = 0)) )) = 0);
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
END_ENTITY; -- partial_circular_profile
      
ENTITY path_feature_component
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['partial circular','complete circular',
        'linear','complex']);
    WR3: ((NOT (SELF.description = 'complex')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR4: ((SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        (('GEOMETRY_SCHEMA.PLACEMENT' 
        IN TYPEOF(it)) AND (it.name = 'orientation')) )) = 1)) )) 
        = 0)) )) = 0));
    WR5: ((NOT (SELF.description = 'partial circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 3)) )) 
        = 0)) )) = 0));
    WR6: ((NOT (SELF.description = 'partial circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)) )) 
        = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'partial circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'sweep angle')) )) = 1)) )) 
        = 0)) )) = 0));
    WR8: ((NOT (SELF.description = 'complete circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
        = 0)) )) = 0));
    WR9: ((NOT (SELF.description = 'complete circular')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)) )) 
        = 0)) )) = 0));
    WR10: ((NOT (SELF.description = 'linear')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
         = 0)) )) = 0));
   WR11: ((NOT (SELF.description = 'linear')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'distance')) )) = 1)) )) 
        = 0)) )) = 0));
   WR12: ((NOT (SELF.description = 'linear')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0));
    WR13: ((NOT (SELF.description = 'complex')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('TOPOLOGY_SCHEMA.PATH_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'sweep path')AND                 
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'profile shape') )) = 1)
        ) )) = 1)) )) = 0));
END_ENTITY; -- path_feature_component
     
ENTITY path_shape_representation
  SUBTYPE OF (shape_representation);
   WHERE
    WR1: (SIZEOF(SELF.items) >= 1);
    WR2: (SIZEOF(QUERY ( i <* SELF.items | (SIZEOF([
         'AIC_MACHINING_FEATURE.BOUNDED_CURVE',
         'TOPOLOGY_SCHEMA.EDGE_CURVE',
         'TOPOLOGY_SCHEMA.PATH'] * TYPEOF(i)) = 
         1) )) >= 1);
END_ENTITY; -- path_shape_representation 

ENTITY pattern_offset_membership
  SUBTYPE OF (feature_component_relationship);
   WHERE
    WR1 : (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
         SELF.relating_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
         ((SIZEOF (QUERY( pdr <*(QUERY(pd <* USEDIN
         (fcr.related_shape_aspect.of_shape,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd))) |
         SIZEOF (['AIC_MACHINING_FEATURE.CIRCULAR_PATTERN',
         'AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN']
         * TYPEOF(pdr.definition))  =1 )) = 0 )) )) = 0);    
    WR2 : (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
         SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
         (fcr.description='modified pattern') AND
         ('AIC_MACHINING_FEATURE.MODIFIED_PATTERN' 
         IN TYPEOF(fcr.relating_shape_aspect)) )) >= 1);
    WR3 : (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
         SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
         (('AIC_MACHINING_FEATURE.MODIFIED_PATTERN' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         (NOT (SIZEOF(QUERY ( modfcr <* QUERY ( modsar <* USEDIN(
         fcr.relating_shape_aspect,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
         ((SIZEOF(['AIC_MACHINING_FEATURE.CIRCULAR_PATTERN',
         'AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN'] * 
         TYPEOF(modsar.related_shape_aspect.of_shape.definition)) = 1) AND 
         (modsar :<>: fcr)) ) | 
         (NOT (modfcr.related_shape_aspect.of_shape.definition :=: 
         SELF.relating_shape_aspect.of_shape.definition)) )) 
         = 0))) )) = 0);
    WR4 : ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 2)) )) = 0));
    WR5 : ((NOT ('AIC_MACHINING_FEATURE.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1)) )) = 0));
    WR6 : ((NOT ('AIC_MACHINING_FEATURE.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (NOT (SIZEOF(pdr.used_representation.items) = 2)) )) = 0)) )) 
         = 0));
    WR7 : ((NOT ('AIC_MACHINING_FEATURE.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'index number')) )) = 1)) )) = 0)) )) = 0));
    WR8 : ((NOT ('AIC_MACHINING_FEATURE.CIRCULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' 
         IN TYPEOF(it)) AND (it.name = 'offset')) )) = 1)) )) = 0)) )) 
         = 0));
    WR9:  ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items ) = 3)) )) 
         = 0)) )) = 0));
    WR10: ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'row index')) )) = 1)) )) = 0)) )) = 0));
    WR11: ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'column index')) )) = 1)) )) = 0)) )) = 0));
    WR12: ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
         IN TYPEOF(it)) AND (it.name = 'offset distance')) )) = 1)) )) 
         = 0)) )) = 0));
    WR13: ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
         IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         (('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'offset direction')) )) = 1)) )) 
         = 0));
END_ENTITY; -- pattern_offset_membership 

ENTITY pattern_omit_membership
  SUBTYPE OF (feature_component_relationship);
   WHERE
    WR1: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
        SELF.relating_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
        + 'RELATING_SHAPE_ASPECT') | 
        (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
        ((SIZEOF (QUERY( pdr <*(QUERY(pd <* USEDIN
        (fcr.related_shape_aspect.of_shape,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd))) |
        SIZEOF (['AIC_MACHINING_FEATURE.CIRCULAR_PATTERN',
        'AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN']
        * TYPEOF(pdr.definition))  =1 )) = 0 )) )) = 0);   
    WR2: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
        SELF.related_shape_aspect,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
        (fcr.description='modified pattern') AND
        ('AIC_MACHINING_FEATURE.MODIFIED_PATTERN' 
        IN TYPEOF(fcr.relating_shape_aspect)) )) >= 1);
    WR3: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(
        SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (sar :<>: SELF)) ) | 
        (('AIC_MACHINING_FEATURE.MODIFIED_PATTERN' 
        IN TYPEOF(fcr.relating_shape_aspect)) AND 
        (NOT (SIZEOF(QUERY ( modfcr <* QUERY ( modsar <* USEDIN(
        fcr.relating_shape_aspect,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        ((SIZEOF(['AIC_MACHINING_FEATURE.CIRCULAR_PATTERN',
        'AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN'] * 
        TYPEOF(modsar.related_shape_aspect.of_shape.definition)) = 1) AND 
        (modsar :<>: fcr)) ) | 
        (NOT (modfcr.related_shape_aspect.of_shape.definition :=: 
        SELF.relating_shape_aspect.of_shape.definition)) ))
         = 0))) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) = 1)) )) = 0);
    WR5: ((NOT ('AIC_MACHINING_FEATURE.CIRCULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (NOT (SIZEOF(pdr.used_representation.items) = 1)) )) = 0)) )) = 0));
    WR6: ((NOT ('AIC_MACHINING_FEATURE.CIRCULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND 
        ('MEASURE_SCHEMA.COUNT_MEASURE' 
        IN TYPEOF(it\measure_with_unit.value_component)) AND 
        (it.name = 'index number')) )) = 1)) )) = 0)) )) = 0));
    WR7: ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (NOT (SIZEOF(pdr.used_representation.items) = 2)) )) = 0)) )) = 0));
    WR8: ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND ('MEASURE_SCHEMA.COUNT_MEASURE' 
        IN TYPEOF(it\measure_with_unit.value_component)) AND 
        (it.name = 'row index')) )) = 1)) )) = 0)) )) = 0));
    WR9: ((NOT ('AIC_MACHINING_FEATURE.RECTANGULAR_PATTERN' 
        IN TYPEOF(SELF.relating_shape_aspect.of_shape.definition))) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF.related_shape_aspect,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND ('MEASURE_SCHEMA.COUNT_MEASURE' 
        IN TYPEOF(it\measure_with_unit.value_component)) AND 
        (it.name = 'column index')) )) = 1)) )) = 0)) )) = 0));
END_ENTITY; -- pattern_omit_membership
 
ENTITY planar_shape_representation
  SUBTYPE OF (shape_representation);
WHERE
    WR1: SIZEOF (SELF.items) = 1;
    WR2: SIZEOF (QUERY (it <* SELF.items |
        ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF (it)))) = 1 ;
END_ENTITY; 

ENTITY pocket
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SELF\characterized_object.description IN 
         ['closed rectangular','open rectangular', 'complex', 
         'circular cutout', 'complex cutout', 'recess']);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'pocket depth occurrence') AND
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'path feature component usage')  AND 
         (sar.name = 'pocket depth') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         (sdr.relating_shape_aspect.description ='linear')) )) 
         = 1)) )) = 1)) )) = 0);
   WR3: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF ( pdr.used_representation ) ) )) =1; 
    WR4:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
          SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         ({1 <= SIZEOF(pdr.used_representation.items) <= 2} ) )) = 1 )) = 1;
    WR5:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
         TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         (srwp_i.name = 'orientation') OR
         (srwp_i.name = 'fillet radius'))) 
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
         IN TYPEOF (pdr.used_representation)) |
         NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
         (SIZEOF (
         ['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
         TYPEOF (it)) = 2) AND (it.name = 'fillet radius'))) <= 1))) 
         = 0))) = 0;
    WR7: ((NOT (SELF\characterized_object.description IN ['complex',
         'non-circular cutout','recess'])) OR 
         (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
         ((sar.description = 'profile usage') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | ((SIZEOF([
         'AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE',
         'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
         'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
         'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE',
         'AIC_MACHINING_FEATURE.SQUARE_U_PROFILE',
         'AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE',
         'AIC_MACHINING_FEATURE.ROUNDED_U_PROFILE',
         'AIC_MACHINING_FEATURE.VEE_PROFILE',
         'AIC_MACHINING_FEATURE.TEE_PROFILE',
         'AIC_MACHINING_FEATURE.OPEN_PATH_PROFILE'] * 
         TYPEOF(sdr.relating_shape_aspect)) = 1)) )) = 1)) )) 
         = 1)) )) = 0));
    WR8: ((NOT (SELF\characterized_object.description = 
         'closed rectangular')) 
         OR (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'closed boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'profile usage') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE' 
         IN TYPEOF(sdr.relating_shape_aspect))) )) = 1)) )) 
         = 1)) )) = 0));
    WR9: ((NOT (SELF\characterized_object.description = 'open rectangular')) 
         OR (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |  
         ((sa_occ.description = 'open boundary occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'profile usage') AND 
         (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('AIC_MACHINING_FEATURE.SQUARE_U_PROFILE' 
         IN TYPEOF(sdr.relating_shape_aspect))) )) = 1)) )) 
         = 1)) )) = 0));
    WR10: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'bottom condition occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
         ((sar.description = 'pocket bottom usage') AND 
         (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('AIC_MACHINING_FEATURE.POCKET_BOTTOM' 
         IN TYPEOF(sdr.relating_shape_aspect)) AND 
         ('AIC_MACHINING_FEATURE.POCKET' 
         IN TYPEOF(sdr.related_shape_aspect.of_shape.definition)))
         )) = 1)) )) = 1)) )) = 0);
    WR11: ((NOT (SELF\characterized_object.description IN ['complex',
         'non-circular cutout','recess'])) OR 
          (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'change in boundary occurrence') AND 
         (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
         ((sar.description = 'taper usage') AND 
         (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('AIC_MACHINING_FEATURE.TAPER' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         ('AIC_MACHINING_FEATURE.POCKET' 
         IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND
         (fcr.related_shape_aspect.description 
         IN ['angle taper','directed taper'])) 
         )) = 1)) ))  <= 1)) )) = 0));       
   WR12: (NOT (SELF\characterized_object.description = 'circular cutout')) OR 
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF (pd)) | NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'enclosed boundary occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        ('AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE' 
        IN TYPEOF (sdr.relating_shape_aspect)))) 
        = 1))) = 1))) = 0);
   WR13: (NOT (SELF\characterized_object.description IN 
        ['circular cutout','complex cutout'])) OR 
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF (pd)) | NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'bottom condition occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'pocket bottom usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('AIC_MACHINING_FEATURE.POCKET_BOTTOM' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('AIC_MACHINING_FEATURE.POCKET' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition))AND
        (sdr.relating_shape_aspect.description = 'through') )
        )) = 1))) = 1))) = 0);
    WR14: (NOT (SELF\characterized_object.description = 'recess')) OR 
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
        TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'bottom condition occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'pocket bottom usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('AIC_MACHINING_FEATURE.POCKET_BOTTOM' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('AIC_MACHINING_FEATURE.POCKET' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition)) AND
        (sdr.relating_shape_aspect.description IN ['planar','complex']) )
        )) = 1))) = 1))) = 0); 
  WR15: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
        ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
           
    WR16:  ((NOT (SELF\characterized_object.description IN 
           ['closed rectangular','open rectangular', 'complex', 
            'recess'])) OR 
            (SIZEOF(QUERY ( pds <* USEDIN(SELF,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
           (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
           IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' 
           IN TYPEOF(csa)) AND 
           (csa.name='uncut volume') AND 
           (SIZEOF(QUERY ( sar <* csa.component_relationships | 
           ((('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar)) AND 
     (SIZEOF(['AIC_MACHINING_FEATURE.BOSS','AIC_MACHINING_FEATURE.PROTRUSION']
           * TYPEOF(sar.related_shape_aspect))=1) 
           ) ))) = 1)) )) <= 1)) )) = 1));      
               
    WR17: ((NOT (SELF\characterized_object.description IN 
          ['closed rectangular','open rectangular'])) OR 
          (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
         IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
         ((sa_occ.description = 'change in boundary occurrence') AND 
         (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
         ((sar.description = 'taper usage') AND 
         (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
         IN TYPEOF(sar))) ) | 
         (('AIC_MACHINING_FEATURE.TAPER' 
         IN TYPEOF(fcr.relating_shape_aspect)) AND 
         ('AIC_MACHINING_FEATURE.POCKET' 
         IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND
         (fcr.related_shape_aspect.description 
         IN ['angle taper','directed taper'])) 
         )) >= 1)) ))  <=1)) )) = 0));             
           
END_ENTITY; -- pocket  

ENTITY pocket_bottom
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SELF.description IN ['planar', 'complex', 'through'];
    WR3: ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
          (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation))  AND 
         (pdr.used_representation.name = 'floor normal') )) = 1)) )) = 0));
    WR4 : ((NOT (SELF.description = 'planar')) OR 
         (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('AIC_MACHINING_FEATURE.LOCATION_SHAPE_REPRESENTATION') 
         IN TYPEOF(pdr.used_representation))  AND 
         (pdr.used_representation.name = 'floor location'))) = 1)) )) = 0));
    WR5 : ((NOT (SELF.description = 'complex')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'floor face') )) = 1)) )) = 0));
    WR6: (NOT (SELF.description IN  ['planar', 'complex']) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0));
    WR7: (NOT (SELF.description IN  ['planar', 'complex']) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (impl_rep.used_representation.items) 
        <= 1) )) = 0))) = 0)); 
    WR8: (NOT (SELF.description = 'through') OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 0))) = 0));
    WR9: (NOT (SELF.description IN ['planar', 'complex'])) OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF (it)) = 2) AND (it.name = 'radius'))) <= 1))) = 0))) = 0);
    WR10: SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'pocket bottom usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
      ((fcr.related_shape_aspect.description = 'bottom condition occurrence') 
        AND
        ('AIC_MACHINING_FEATURE.POCKET' 
        IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) AND
        ('AIC_MACHINING_FEATURE.POCKET_BOTTOM' 
        IN TYPEOF(fcr.relating_shape_aspect)) )
        )) >= 1;
   WR11: ((NOT (SELF.description IN ['planar','complex'])) OR
         (SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'pocket bottom usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
      (fcr.related_shape_aspect.description = 'bottom condition occurrence')
       AND
      (fcr.related_shape_aspect.name IN 
       ['pocket depth start', 'pocket depth end'])
       )) = 0));
END_ENTITY;  -- Pocket_bottom

ENTITY profile_floor
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SELF.description IN ['planar', 'complex', 'through'];
    WR3: (NOT (SELF.description IN ['planar', 'complex']) OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0));
    WR4: (NOT (SELF.description IN  ['planar', 'complex'])) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (impl_rep.used_representation.items) >= 1)AND
       (SIZEOF (impl_rep.used_representation.items) <= 2))) = 0))) = 0); 
    WR5: (NOT (SELF.description = 'through') OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 0))) = 0));
    WR6: (NOT (SELF.description IN ['planar', 'complex'])) OR 
        (SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * 
        TYPEOF (it)) = 2) AND (it.name = 'radius'))) = 1))) = 0))) = 0); 
    WR7: SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'profile floor usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' IN
        TYPEOF (sar))) |
        (('AIC_MACHINING_FEATURE.OUTSIDE_PROFILE' IN TYPEOF
        (fcr.related_shape_aspect.of_shape.definition))AND
        ('AIC_MACHINING_FEATURE.PROFILE_FLOOR' IN TYPEOF
        (fcr.relating_shape_aspect)))
        )) >= 1;      
    WR8: ((NOT (SELF.description IN ['planar','complex'])) OR
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
        | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
        used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
        impl_rep.used_representation.items | 
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
        IN TYPEOF(it)) AND (it.name = 'shape profile floor orientation') 
        AND (it.description IN ['shape profile start','shape profile end']))
        )) =  1)) )) = 0)) )) = 0));
   WR9: (NOT (SELF.description = 'complex')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))  AND 
        (pdr.used_representation.name='floor'))) = 1))) = 1);
   WR10: (NOT (SELF.description = 'planar')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))  AND 
        (pdr.used_representation.name='floor'))) = 1))) = 1);
END_ENTITY;   -- profile_floor

ENTITY protrusion
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'shape volume occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'volume shape usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (sdr.relating_shape_aspect.description = 'volume shape') )) = 1)) )) 
        = 1)) )) = 0);
   WR3: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY; -- protrusion

ENTITY rectangular_closed_profile
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT ((SIZEOF (impl_rep.used_representation.items) >= 3)  
        AND (SIZEOF(impl_rep.used_representation.items) <= 4)))) = 0))) = 0;
    WR4:  SIZEOF( QUERY( pd <* 
        USEDIN( SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'orientation') OR
        (srwp_i.name = 'length') OR
        (srwp_i.name = 'width') OR
        (srwp_i.name = 'corner radius') )) =
        SIZEOF(pdr.used_representation.items))
         )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
        (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'width'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'length'))) = 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'corner radius'))) <= 1))) = 0))) = 0;
END_ENTITY;  -- rectangular_closed_profile

ENTITY rectangular_pattern
  SUBTYPE OF (replicate_feature);
   WHERE
    WR1: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
          ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
          IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN
          (pds,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
          ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
          'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
          + 'RELATING_SHAPE_ASPECT') | 
          ((('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
          IN TYPEOF(sar))) ) | 
          ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
          IN TYPEOF(sdr.related_shape_aspect)) )) = 1)) )) <= 5)) )) = 0);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         (('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'row layout direction') ) )) 
         = 1)) ))  = 0);
    WR3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
         IN TYPEOF(pdr.used_representation)) AND 
         (pdr.used_representation.name = 'column layout direction')) )) 
         = 1)) )) = 0);
    WR4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR5 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(impl_rep.used_representation.items) = 5)) )) 
         = 0)) )) = 0);
    WR6 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'number of rows')) )) = 1)) )) = 0)) )) = 0);
   WR7 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
         (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
         IN TYPEOF(it)) AND 
         ('MEASURE_SCHEMA.COUNT_MEASURE' 
         IN TYPEOF(it\measure_with_unit.value_component)) AND 
         (it.name = 'number of columns')) )) = 1)) )) = 0)) )) = 0);
    WR8 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'row spacing')) )) = 1)) )) 
         = 0)) )) = 0);
    WR9: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'column spacing'))))= 1)) )) 
         = 0)) )) = 0);
    WR10: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         (('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF(it)) AND 
         (it.name = 'orientation')) )) = 1)) )) = 0)) )) = 0);
END_ENTITY; -- rectangular_pattern

ENTITY removal_volume
  SUBTYPE OF (feature_definition);
   WHERE
 
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'shape volume occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
        + 'RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'volume shape usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (sdr.relating_shape_aspect.description = 'volume shape') )) = 1)) )) 
        = 1)) )) = 0);
END_ENTITY; -- removal_volume

ENTITY replicate_feature
    SUPERTYPE OF (ONEOF (circular_pattern, rectangular_pattern, 
      feature_pattern))
  SUBTYPE OF (feature_definition);
  WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
         | (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
         used_representation)) ))  = 1)) )) = 0);
    WR2: (SIZEOF(QUERY ( fcr <* QUERY ( sar <* 
         USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar)) ) | 
         ((SIZEOF(['AIC_MACHINING_FEATURE.REPLICATE_FEATURE',
         'SHAPE_ASPECT_DEFINITION_SCHEMA.INSTANCED_FEATURE'] * 
         TYPEOF(fcr.related_shape_aspect)) >= 1) AND 
         (fcr.name = 'pattern basis')) )) = 1);
    WR3: ((SIZEOF(QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATING_SHAPE_ASPECT') | 
         (NOT
          ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar))) )) + 
         SIZEOF(QUERY ( sar <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
         + 'RELATED_SHAPE_ASPECT') | 
         (NOT
         ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
         IN TYPEOF(sar))) ))) = 0);
END_ENTITY;  -- replicate_feature

ENTITY revolved_profile
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SELF\characterized_object.description IN 
        ['groove','flat','round','open profile']);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) 
        = 0)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')))) = 1)) )) 
        = 0)) )) = 0);
  WR4:  SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='removal direction'))) =1; 
    WR5: ((NOT (SELF\characterized_object.description = 'open profile')) OR
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'outer edge shape occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('AIC_MACHINING_FEATURE.OPEN_PATH_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
       (sdr.relating_shape_aspect.description = 'outer edge shape')) )) 
        = 1)) )) = 1)) )) = 0));
    WR6: (NOT (SELF\characterized_object.description = 'flat')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        (( sa_occ.description = 'flat edge shape occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('AIC_MACHINING_FEATURE.LINEAR_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'flat edge shape')) )) 
        = 1)) )) = 1)) )) = 0);
    WR7: ((NOT (SELF\characterized_object.description = 'round')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'rounded edge shape occurrence') AND 
         (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'rounded edge shape')) )) 
        = 1)) )) = 1)) )) = 0));
    WR8: ((NOT (SELF\characterized_object.description = 'groove')) OR 
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'sweep occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        ((SIZEOF(['AIC_MACHINING_FEATURE.SQUARE_U_PROFILE',
         'AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE',
        'AIC_MACHINING_FEATURE.ROUNDED_U_PROFILE',
        'AIC_MACHINING_FEATURE.VEE_PROFILE',
        'AIC_MACHINING_FEATURE.TEE_PROFILE',
        'AIC_MACHINING_FEATURE.OPEN_PATH_PROFILE'] * 
        TYPEOF(sdr.relating_shape_aspect)) = 1) AND 
        (sdr.relating_shape_aspect.description = 'sweep')) )) = 1)) )) 
        = 1)) )) = 0));
   WR9: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY; -- revolved_profile

ENTITY rib_top
   SUBTYPE OF (feature_definition);
  WHERE
    WR1: SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'rib top condition occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'rib top usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (('AIC_MACHINING_FEATURE.RIB_TOP_FLOOR' 
        IN TYPEOF (sdr.relating_shape_aspect)) AND
        ('AIC_MACHINING_FEATURE.RIB_TOP' 
        IN TYPEOF (sdr.related_shape_aspect.of_shape.definition)) )
        )) = 1))) = 1))) = 0;     
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'removal direction'))) = 1))) = 1;  
   WR3: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
        ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
END_ENTITY;    -- rib_top

ENTITY rib_top_floor
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' IN
        TYPEOF (SELF.of_shape.definition);
    WR2: SELF.description IN ['planar', 'complex'];
    WR3: SIZEOF (QUERY (fcr <* QUERY (sar <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | 
        (sar.description = 'rib top usage') AND
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF (sar))) |
     ((fcr.related_shape_aspect.description = 'rib top condition occurrence') 
        AND
        ('AIC_MACHINING_FEATURE.RIB_TOP' IN TYPEOF
        (fcr.related_shape_aspect.of_shape.definition)) AND
        ('AIC_MACHINING_FEATURE.RIB_TOP_FLOOR' IN TYPEOF
        (fcr.relating_shape_aspect)) )
        )) >= 1;
    WR4: (NOT (SELF.description = 'complex')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.FACE_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'rib top face'))) = 1))) = 0);
    WR5: (NOT (SELF.description = 'planar')) OR
        (SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'rib top face'))) = 1))) = 0);
    WR6: (NOT (SELF.description = 'planar')) OR
        (SIZEOF (QUERY (pds <* QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF (pd)) | 
        NOT (SIZEOF (QUERY (sa_occ <* USEDIN (pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') |
        (sa_occ.description = 'boundary occurrence') AND
        (SIZEOF (QUERY (sdr <* QUERY (sar <* USEDIN (sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar.description = 'profile usage') AND
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF (sar))) |
        (SIZEOF (['AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE', 
        'AIC_MACHINING_FEATURE.NGON_CLOSED_PROFILE',
        'AIC_MACHINING_FEATURE.RECTANGULAR_CLOSED_PROFILE',
         'AIC_MACHINING_FEATURE.CLOSED_PATH_PROFILE'] *
        TYPEOF (sdr.relating_shape_aspect)) = 1) AND
        (sdr.relating_shape_aspect.description = 'rib top floor boundary'))) 
        = 1))) = 1))) = 0);
END_ENTITY;  -- rib_top_floor

ENTITY round_hole
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')|
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'diameter occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'profile usage') AND 
       (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('AIC_MACHINING_FEATURE.CIRCULAR_CLOSED_PROFILE' 
       IN TYPEOF(sdr.relating_shape_aspect)) AND 
       (sdr.name = 'diameter'))  )) = 1)) )) = 1)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'hole depth occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'path feature component usage') AND 
       (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
       IN TYPEOF(sdr.relating_shape_aspect)) AND 
       (sdr.name = 'hole depth') AND 
       (sdr.relating_shape_aspect.description = 'linear')) )) = 1)) )) 
       = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'bottom condition occurrence') AND 
       (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'hole bottom usage') AND 
       (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('AIC_MACHINING_FEATURE.HOLE_BOTTOM' 
       IN TYPEOF(fcr.relating_shape_aspect)) AND 
       ('AIC_MACHINING_FEATURE.ROUND_HOLE' 
       IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)))
       )) = 1)) )) = 1)) )) = 0);
    WR4: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'change in diameter occurrence') AND 
       (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'taper usage') AND 
       (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       (('AIC_MACHINING_FEATURE.TAPER' 
       IN TYPEOF(fcr.relating_shape_aspect)) AND 
       ('AIC_MACHINING_FEATURE.ROUND_HOLE' 
       IN TYPEOF(fcr.related_shape_aspect.of_shape.definition)) )
       )) = 1)) )) <= 1)) )) = 0);
   WR5: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
     IN TYPEOF ( pdr.used_representation ) ) )) =1; 
END_ENTITY; -- round_hole

ENTITY rounded_end
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'partial circular boundary occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) ) )) = 1)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'course of travel occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'path feature component usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'linear')) )) = 1)) )) 
        = 1)) )) = 0);
   WR4: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
        ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0;
END_ENTITY; -- rounded_end

ENTITY rounded_u_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 1)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 2)))) 
        = 0))) = 0; 
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'orientation') OR
        (srwp_i.name = 'depth')  )) 
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'width'))))= 1))))= 0))))= 0);
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
   WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'depth'))) <= 1))) = 0))) = 0;
END_ENTITY; -- rounded_u_profile

ENTITY shape_defining_relationship
  SUBTYPE OF (shape_aspect_relationship);
END_ENTITY;

ENTITY spherical_cap
  SUBTYPE OF (feature_definition);
   WHERE
  
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 3)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'radius')) )) = 1)))) 
        = 0)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'internal angle')))) = 1)) )) 
        = 0)) )) = 0);
END_ENTITY; -- spherical_cap

ENTITY square_u_profile
  SUBTYPE OF (shape_aspect);
  WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 4)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 7)))) 
        = 0))) = 0; 
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        SIZEOF( QUERY( pdr <* USEDIN( pd, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
        IN TYPEOF(pdr.used_representation)) AND
        (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
        (srwp_i.name = 'orientation') OR
        (srwp_i.name = 'width') OR
        (srwp_i.name = 'first angle') OR
        (srwp_i.name = 'second angle') OR
        (srwp_i.name = 'first radius') OR
        (srwp_i.name = 'second radius') OR
        (srwp_i.name = 'profile limit') OR 
        (srwp_i.name = 'depth')  ))
         = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
        (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'width'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'first radius'))) <= 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'second radius'))) <= 1))) = 0))) = 0;
    WR9: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'first angle'))) = 1))) = 0))) = 0;
    WR10: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'second angle'))) = 1))) = 0))) = 0;
    WR11: SIZEOF (QUERY (pd <* USEDIN (SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
        IN TYPEOF (pdr.used_representation))AND
        (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
        
   WR12: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        (SIZEOF 
        (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
        TYPEOF (it)) = 2) AND 
        (it.name = 'depth'))) <= 1))) = 0))) = 0;
END_ENTITY; -- Square_U_profile

ENTITY step
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR2: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'course of travel occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'path feature component usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description = 'linear')) )) = 1)) )) 
        = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'removal boundary occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'profile usage') AND 
        (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
        IN TYPEOF(sar))) ) | 
        ('AIC_MACHINING_FEATURE.VEE_PROFILE' 
        IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
   WR4: SIZEOF(QUERY(pdr <* get_property_definition_representations (SELF) | 
       ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
       IN TYPEOF ( pdr.used_representation ) ) AND 
       ( pdr.used_representation.name ='maximum feature limit'))) >=0; 
   WR5: SIZEOF(QUERY ( pds <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
        IN TYPEOF(pds)) AND (SIZEOF(QUERY ( csa <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.COMPOSITE_SHAPE_ASPECT' IN 
        TYPEOF(csa)) AND 
        (csa.name='uncut volume') AND 
        (SIZEOF(QUERY ( sar <* csa.component_relationships | 
        (('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar)) AND (SIZEOF([
        'AIC_MACHINING_FEATURE.BOSS',
        'AIC_MACHINING_FEATURE.PROTRUSION'] * TYPEOF(sar.
        related_shape_aspect)) = 1)) )) = 1)) )) <= 1)) )) = 1;        
END_ENTITY; -- step

  ENTITY slot
    SUBTYPE OF (feature_definition);
    WHERE
      WR1: SIZEOF(QUERY ( pd <* USEDIN(SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
                | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
               'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
               'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
               used_representation)) ) | (NOT (SIZEOF(impl_rep.
               used_representation.items) = 1)) )) = 0)) )) = 0;
      WR2: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
                | (
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
                TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | ((
               sa_occ.description = 'swept shape occurrence') AND (SIZEOF(
               QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
               + 'RELATED_SHAPE_ASPECT') | ((sar.description = 
               'profile usage') AND ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
               IN TYPEOF(sar))) ) | (SIZEOF([
               'AIC_MACHINING_FEATURE.SQUARE_U_PROFILE',
               'AIC_MACHINING_FEATURE.PARTIAL_CIRCULAR_PROFILE',
               'AIC_MACHINING_FEATURE.ROUNDED_U_PROFILE',
               'AIC_MACHINING_FEATURE.VEE_PROFILE',
               'AIC_MACHINING_FEATURE.TEE_PROFILE',
               'AIC_MACHINING_FEATURE.OPEN_PATH_PROFILE'] * 
               TYPEOF(sdr.relating_shape_aspect)) = 1) )) = 1)) )) = 1)) )) 
               = 0;
      WR3: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
                | (
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
                TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | ((
               sa_occ.description = 'course of travel occurrence') AND (
               SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
               'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
               + 'RELATED_SHAPE_ASPECT') | ((sar.description = 
               'path feature component usage') AND ((sar.name = 
               'course of travel') AND ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
               IN TYPEOF(sar)))) ) | (
               'TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' IN 
               TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0;
               
      WR4: SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
           ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
           IN TYPEOF(pd)) ) | 
           (NOT((SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           ((sa_occ.description = 'end condition occurrence') AND 
           (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
           (((sar.description = 'slot end usage') AND 
           (sar.name IN ['course of travel start','course of travel end'])) AND 
           ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar))) ) | 
           ((('AIC_MACHINING_FEATURE.SLOT_END' 
           IN TYPEOF(fcr.relating_shape_aspect)) AND 
           (fcr.relating_shape_aspect.description 
           IN ['open','radiused','flat','woodruff'])) AND 
           ('AIC_MACHINING_FEATURE.SLOT' 
           IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) 
            )) = 1) ) )) = 2) 
            OR 
           (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
           ((sa_occ.description = 'end condition occurrence') AND 
           (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
           'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
           (((sar.description = 'slot end usage') AND 
           (sar.name IN ['course of travel start','course of travel end'])) AND 
           ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
           IN TYPEOF(sar))) ) | 
           ((('AIC_MACHINING_FEATURE.SLOT_END' 
           IN TYPEOF(fcr.relating_shape_aspect)) AND 
           (fcr.relating_shape_aspect.description IN ['loop'])) AND 
           ('AIC_MACHINING_FEATURE.SLOT' 
           IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) 
            )) = 1) ) )) = 1))) )) =0; 
               
      WR5: (NOT (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'end condition occurrence') AND 
        (SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        (((sar.description = 'slot end usage') AND 
        (sar.name IN ['course of travel start','course of travel end'])) AND 
        ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
        IN TYPEOF(sar))) ) | 
        ((('AIC_MACHINING_FEATURE.SLOT_END' 
        IN TYPEOF(fcr.relating_shape_aspect)) AND 
        (fcr.relating_shape_aspect.description IN ['loop'])) AND 
        ('AIC_MACHINING_FEATURE.SLOT' 
        IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) 
        )) = 1)) )) = 1)) )) =0)
           OR  
        (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| 
        ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)) ) | 
        (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
        ((sa_occ.description = 'course of travel occurrence') AND 
        (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
        ((sar.description = 'path feature component usage') AND 
        ((sar.name = 'course of travel') AND 
        ('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP' 
        IN TYPEOF(sar)))) ) | 
        (('TOPOLOGY_SCHEMA.PATH_FEATURE_COMPONENT' 
        IN TYPEOF(sdr.relating_shape_aspect)) AND 
        (sdr.relating_shape_aspect.description 
        IN ['complex','complete circular'])) 
        )) = 1)) )) = 1)) )) = 0));
                
      WR6: SIZEOF(QUERY ( pdr <* get_property_definition_representations(
           SELF) | ((
           'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
           IN TYPEOF(pdr.used_representation)) AND (pdr.
           used_representation.name = 'maximum feature limit')) )) >= 0;       
  END_ENTITY; -- slot 

ENTITY slot_end
  SUBTYPE OF (shape_aspect);
   WHERE
WR1 : 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
      IN TYPEOF(SELF.of_shape.definition);
      
WR2 : SELF.description IN ['open','radiused','flat','woodruff',
      'loop'];
      
WR3: (NOT (SELF.description IN ['open','radiused','loop'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')| 
     (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) )) = 0)) )) = 0);
     
WR4: (NOT (SELF.description IN ['flat','woodruff'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
     
WR5: (NOT (SELF.description IN ['flat'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(impl_rep.used_representation.items) = 2)) )) = 0)) )) = 0);
     
WR6: (NOT (SELF.description = 'flat')) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
     ((SIZEOF([
     'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
     'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) 
     = 2) AND 
     (it.name = 'first radius')) )) = 1)) )) = 0)) )) = 0);
     
WR7: (NOT (SELF.description = 'flat')) OR (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
     ((SIZEOF([
     'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
     'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] * TYPEOF(it)) 
     = 2) AND (it.name = 'second radius')) )) = 1)) ))  = 0)) )) = 0);
     
WR8: (NOT (SELF.description = 'woodruff')) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
     (('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
     IN TYPEOF(it)) AND 
     (it.name = 'radius')) )) = 1)) )) = 0)) )) = 0);
     
WR9: (NOT (SELF.description IN ['woodruff'])) OR 
     (SIZEOF(QUERY ( pd <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
     (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
     (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
     IN TYPEOF(pdr.used_representation)) ) | 
     (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) = 0)) )) = 0);
     
WR10: SIZEOF(QUERY ( fcr <* QUERY ( sar <* USEDIN(SELF,
     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' 
     + 'RELATING_SHAPE_ASPECT') | 
     (((sar.description = 'slot end usage') AND 
     (sar.name IN ['course of travel start','course of travel end'])) AND 
     ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_RELATIONSHIP' 
     IN TYPEOF(sar))) ) | 
     (((fcr.related_shape_aspect.description = 'end condition occurrence') AND 
     ('AIC_MACHINING_FEATURE.SLOT' 
     IN TYPEOF(fcr.related_shape_aspect.of_shape.definition))) AND 
     ('AIC_MACHINING_FEATURE.SLOT_END' 
     IN TYPEOF(fcr.relating_shape_aspect))) )) >= 1;
     
END_ENTITY; -- slot_end

ENTITY taper
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF(SELF.of_shape.definition));
    WR2: (SELF.description IN ['angle taper','diameter taper',
        'directed taper']);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(impl_rep.used_representation.items) = 1)) )) 
        = 0)) )) = 0);
    WR5: ((NOT (SELF.description = 'angle taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'taper angle')) )) = 1)) )) 
        = 0)) )) = 0));
    WR6: ((NOT (SELF.description = 'diameter taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'final diameter')) )) = 1)) )) 
        = 0)) )) = 0));
    WR7: ((NOT (SELF.description = 'directed taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'angle')) )) = 1)) )) 
        = 0)) )) = 0));   
   WR8: ((NOT (SELF.description = 'directed taper')) OR 
        (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('AIC_MACHINING_FEATURE.DIRECTION_SHAPE_REPRESENTATION' 
        IN TYPEOF(pdr.used_representation)) AND 
        (pdr.used_representation.name = 'direction') )) 
        = 1)) )) = 0));
END_ENTITY; -- taper

ENTITY tee_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
        IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        (NOT (SIZEOF (impl_rep.used_representation.items) >= 9)
        AND  (SIZEOF (impl_rep.used_representation.items) <= 10)))) 
        = 0))) = 0; 
    WR4:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF( QUERY( pdr <* USEDIN( pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
       IN TYPEOF(pdr.used_representation)) AND
       (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
       (srwp_i.name = 'orientation') OR
       (srwp_i.name = 'width') OR
       (srwp_i.name = 'depth') OR
       (srwp_i.name = 'cross bar width') OR
       (srwp_i.name = 'cross bar depth') OR
       (srwp_i.name = 'first offset') OR
       (srwp_i.name = 'second offset') OR
       (srwp_i.name = 'first angle') OR
       (srwp_i.name = 'second angle') OR
       (srwp_i.name = 'radius') )) 
       = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
       (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND  (it.name = 'width'))) = 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'depth'))) = 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'cross bar width'))) = 1))) 
       = 0))) = 0;
    WR9: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'cross bar depth'))) = 1))) 
       = 0))) = 0;
   WR10: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'first offset'))) = 1))) 
       = 0))) = 0;
   WR11: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'second offset'))) = 1))) 
       = 0))) = 0;
   WR12: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'first angle'))) = 1))) 
       = 0))) = 0;
   WR13: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'second angle'))) = 1))) 
       = 0))) = 0;
   WR14: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND (it.name = 'radius'))) <= 1))) = 0))) = 0;
   WR15: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation))AND
       (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
END_ENTITY;   -- tee_profile

ENTITY thread
  SUBTYPE OF (feature_definition);
   WHERE
    WR1 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (SIZEOF(QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        ((('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) AND 
        (8 <= SIZEOF(pdr.used_representation.items)) AND 
        (SIZEOF(pdr.used_representation.items) <= 11)) )) = 1) )) = 1);
    WR2 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |     
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'major diameter')) )) = 1)) )) 
        = 0)) )) = 0);
    WR3 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'minor diameter')) )) 
        <= 1)) )) = 0)) )) = 0);
    WR4 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'pitch diameter')) )) <= 1)) )) 
        = 0)) )) = 0);
    WR5 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.RATIO_MEASURE_WITH_UNIT'] *
        TYPEOF(it)) = 2) AND (it.name = 'number of threads')) )) 
        = 1)) )) = 0)) )) = 0);
    WR6 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'fit class')) )) = 1)) )) = 0)) )) 
        = 0);
    WR7 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'form')) )) = 1)) )) = 0)) )) 
        = 0);
    WR8 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'hand')AND 
        (it.description IN ['left', 'right']) ) )) = 1)) )) = 0)) )) 
        = 0);
    WR9 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'qualifier')) )) <= 1)) )) 
        = 0)) )) = 0);
   WR10: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND (it.name = 'thread side') AND 
       ((it.description = 'internal') OR (it.description = 'external'))) )) 
       = 1)) )) = 0)) )) = 0);
   WR11: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'crest')) )) <= 1)) )) 
       = 0)) )) = 0);
   WR12: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'partial area occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied area usage') AND 
       (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('AIC_MACHINING_FEATURE.APPLIED_AREA' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
   WR13: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied shape') AND 
       (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
     WR14 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN( pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'fit class 2')) )) <= 1)) )) = 0)) )) 
        = 0);   
     WR15 : (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
        (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
        (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
        IN TYPEOF(pdr.used_representation)) ) | 
        (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
        ((SIZEOF([
        'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
        'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
        * TYPEOF(it)) = 2) AND (it.name = 'nominal size')) )) 
        <= 1)) )) = 0)) )) = 0);   

   WR16: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'thread runout') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'thread runout usage') AND 
       (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('AIC_MACHINING_FEATURE.THREAD_RUNOUT' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) <= 1)) )) = 1)) )) = 0);        
 END_ENTITY;   -- thread


ENTITY thread_runout
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE'
         IN TYPEOF(SELF.of_shape));
    WR2: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) )) = 1)) )) = 0);
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF (impl_rep.used_representation.items) = 3)) )) 
         = 0)) )) = 0);
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
         (SIZEOF( QUERY( pdr <* USEDIN( pd, 
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
         ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
         IN TYPEOF(pdr.used_representation)) AND
         (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
         NOT (srwp_i.name IN ['length of runout','pitch or dimension',
         'included or extra']) )) > 0 ) )) = 0 )   )) = 0;
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
         'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
         (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
         (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
         IN TYPEOF(pdr.used_representation)) ) | 
         (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
         ((SIZEOF([
         'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
         'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
         TYPEOF(it)) = 2) AND (it.name = 'length of runout')) )) = 1)) )) 
         = 0)) )) <= 1);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
        | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
        used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
        impl_rep.used_representation.items | 
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
        IN TYPEOF(it)) AND (it.name = 'pitch or dimension') 
        AND (it.description IN ['pitch','pitch or dimension']))
        )) =  1)) )) = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
        | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
        used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
        impl_rep.used_representation.items | 
        (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM'
        IN TYPEOF(it)) AND (it.name = 'included or extra') 
        AND (it.description IN ['included','extra']))
        )) =  1)) )) = 0)) )) = 0);        
END_ENTITY; -- thread_runout

ENTITY transition_feature
    SUPERTYPE OF (ONEOF (chamfer,edge_round,fillet))
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: SIZEOF(['PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION',
         'AIC_MACHINING_FEATURE.COMPOUND_FEATURE']
         * TYPEOF(SELF.of_shape.definition)) = 1;
    WR2: SIZEOF(['AIC_MACHINING_FEATURE.CHAMFER',
        'AIC_MACHINING_FEATURE.EDGE_ROUND', 
        'AIC_MACHINING_FEATURE.FILLET'] *
        TYPEOF(SELF)) = 1;
END_ENTITY; -- transition_feature

ENTITY turned_knurl
  SUBTYPE OF (feature_definition);
   WHERE
    WR1: (SELF\characterized_object.description IN
        ['diamond','diagonal','straight']);
    WR2:  SIZEOF( QUERY( pd <* USEDIN( SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF( QUERY( pdr <* USEDIN( pd, 
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
       TYPEOF(pdr.used_representation)) AND
       ({6 <= SIZEOF(pdr.used_representation.items) <= 9}) )) = 1 )) = 1;
    WR3: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF(it)) AND 
       ('MEASURE_SCHEMA.COUNT_MEASURE' 
       IN TYPEOF(it\measure_with_unit.value_component)) AND 
       (it.name = 'number of teeth')) )) <= 1)) )) = 0)) )) = 0);
    WR4: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'major diameter'))))= 1)) )) 
       = 0)) )) = 0);
    WR5: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'nominal diameter')) )) = 1)) )) 
       = 0)) )) = 0);
    WR6: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | (NOT (SIZEOF(QUERY ( impl_rep <* 
       QUERY ( pdr <* USEDIN(pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
       used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
       impl_rep.used_representation.items | ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'tooth depth')) )) <= 1)) )) 
       = 0)) )) = 0);
    WR7: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'root fillet')) )) <= 1)) )) 
       = 0)) )) = 0);
    WR8: (SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items | 
       ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT'] *
       TYPEOF(it)) = 2) AND (it.name = 'diametral pitch')) )) = 1)) )) 
       = 0)) )) = 0);
    WR9: ((NOT (SELF\characterized_object.description IN
       ['diamond','diagonal'])) OR (
       SIZEOF(QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION')
       | (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(
       pd,'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | ((
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') IN TYPEOF(pdr.
       used_representation)) ) | (NOT (SIZEOF(QUERY ( it <* 
       impl_rep.used_representation.items | ((SIZEOF([
       'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] 
       * TYPEOF(it)) = 2) AND (it.name = 'helix angle')) )) = 1)) )) 
       = 0)) )) = 0));
    WR10: ((NOT (SELF\characterized_object.description = 'diagonal')) OR 
       (SIZEOF(QUERY ( pd <* USEDIN(SELF,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       (NOT (SIZEOF(QUERY ( impl_rep <* QUERY ( pdr <* USEDIN(pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
       (('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS') 
       IN TYPEOF(pdr.used_representation)) ) | 
       (NOT (SIZEOF(QUERY ( it <* impl_rep.used_representation.items |
       (('QUALIFIED_MEASURE_SCHEMA.DESCRIPTIVE_REPRESENTATION_ITEM' 
        IN TYPEOF(it)) AND (it.name = 'helix hand')) )) = 1)) )) 
       = 0)) )) = 0));
    WR11: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((sa_occ.description = 'partial area occurrence') AND 
       (SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied area usage') AND 
       (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') IN TYPEOF(sar))) ) | 
       ('AIC_MACHINING_FEATURE.APPLIED_AREA' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
   WR12: (SIZEOF(QUERY ( pds <* QUERY ( pd <* USEDIN(SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' 
       IN TYPEOF(pd)) ) | 
       (NOT (SIZEOF(QUERY ( sa_occ <* USEDIN(pds,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE') | 
       ((SIZEOF(QUERY ( sdr <* QUERY ( sar <* USEDIN(sa_occ,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
       ((sar.description = 'applied shape') AND 
       (('AIC_MACHINING_FEATURE.SHAPE_DEFINING_RELATIONSHIP') 
       IN TYPEOF(sar))) ) | 
       ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' 
       IN TYPEOF(sdr.relating_shape_aspect)) )) = 1)) )) = 1)) )) = 0);
END_ENTITY; -- turned_knurl

ENTITY vee_profile
  SUBTYPE OF (shape_aspect);
   WHERE
    WR1: 'AIC_MACHINING_FEATURE.FEATURE_COMPONENT_DEFINITION' 
       IN TYPEOF (SELF.of_shape.definition);
    WR2: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation))) = 1))) = 0;
    WR3: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       (NOT (SIZEOF (impl_rep.used_representation.items) >= 3)
       AND  (SIZEOF (impl_rep.used_representation.items) <= 6)))) 
       = 0))) = 0;
    WR4: SIZEOF( QUERY( pd <* USEDIN( SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       SIZEOF( QUERY( pdr <* USEDIN( pd, 
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
       IN TYPEOF(pdr.used_representation)) AND
       (SIZEOF( QUERY( srwp_i <* pdr.used_representation.items |
       (srwp_i.name = 'orientation') OR
       (srwp_i.name = 'profile angle') OR
       (srwp_i.name = 'tilt angle') OR
       (srwp_i.name = 'profile radius')  OR 
       (srwp_i.name = 'first length') OR
       (srwp_i.name = 'second length') )) 
       = SIZEOF(pdr.used_representation.items)) )) = 1 )) = 1;
    WR5: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('GEOMETRY_SCHEMA.PLACEMENT' IN TYPEOF (it)) AND 
       (it.name = 'orientation'))) = 1))) = 0))) = 0;
    WR6: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (it)) AND 
       ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
       IN TYPEOF (it\measure_with_unit.value_component)) AND 
       (it.name = 'profile radius'))) <= 1))) = 0))) = 0;
    WR7: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND 
       (it.name = 'profile angle'))) = 1))) = 0))) = 0;
    WR8: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       (SIZEOF 
       (['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM',
       'GEOMETRY_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT'] *    
       TYPEOF (it)) = 2) AND 
       (it.name = 'tilt angle'))) = 1))) = 0))) = 0;
    WR9: SIZEOF (QUERY (pd <* USEDIN (SELF,
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       ('AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION'
       IN TYPEOF (pdr.used_representation))AND
       (pdr.used_representation.name = 'profile limit'))) <= 1))) = 0;
    WR10: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (it)) AND 
       ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
       IN TYPEOF (it\measure_with_unit.value_component)) AND 
       (it.name = 'first length'))) <= 1))) = 0))) = 0;
    WR11: SIZEOF (QUERY (pd <* USEDIN (SELF, 
       'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
       NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
       'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
       IN TYPEOF (pdr.used_representation)) |
       NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
       ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
       IN TYPEOF (it)) AND 
       ('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' 
       IN TYPEOF (it\measure_with_unit.value_component)) AND 
       (it.name = 'second length'))) <= 1))) = 0))) = 0;
END_ENTITY; -- vee_profile


RULE machining_feature_definition_constraints FOR (feature_definition);
LOCAL
  mfds : SET OF feature_definition := [];
END_LOCAL;
  mfds := QUERY(temp <* feature_definition | 'AIC_MACHINING_FEATURE.MACHINING_FEATURE_DEFINITION' IN TYPEOF (temp) );
WHERE
  WR1: SIZEOF(QUERY( mfd <* mfds | NOT (SIZEOF(QUERY( pdr <*
       get_property_definition_representations (mfd) |
         'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS' 
       IN TYPEOF ( pdr.used_representation ) ) ) <=1 ) ) ) = 0;
  WR2: SIZEOF(QUERY( mfd <* mfds | NOT (SIZEOF (QUERY (pd <* USEDIN (mfd, 
        'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
        NOT (SIZEOF (QUERY (impl_rep <* QUERY (pdr <* USEDIN (pd,
        'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        'SHAPE_ASPECT_DEFINITION_SCHEMA.SHAPE_REPRESENTATION_WITH_PARAMETERS'
        IN TYPEOF (pdr.used_representation)) |
        NOT (SIZEOF (QUERY (it <* impl_rep.used_representation.items |
        ('GEOMETRY_SCHEMA.PLACEMENT' 
        IN TYPEOF (it)) AND (it.name = 'orientation'))) = 1))) = 0))) = 0 ) ) ) = 0;
  WR3: SIZEOF(QUERY( mfd <* mfds | NOT ((NOT (SIZEOF(['AIC_MACHINING_FEATURE.ROUND_HOLE',
        'AIC_MACHINING_FEATURE.BOSS',
        'AIC_MACHINING_FEATURE.OUTSIDE_PROFILE',
        'AIC_MACHINING_FEATURE.REMOVAL_VOLUME',
        'AIC_MACHINING_FEATURE.FLAT_FACE',
        'AIC_MACHINING_FEATURE.POCKET',
        'AIC_MACHINING_FEATURE.PROTRUSION',
        'AIC_MACHINING_FEATURE.RIB_TOP',
        'AIC_MACHINING_FEATURE.ROUNDED_END',
        'AIC_MACHINING_FEATURE.SLOT',
        'AIC_MACHINING_FEATURE.STEP'] * TYPEOF(mfds)) = 1))   OR 
     ((SIZEOF(QUERY(pdr <* get_property_definition_representations (mfd) | 
        ( 'AIC_MACHINING_FEATURE.PLANAR_SHAPE_REPRESENTATION' 
        IN TYPEOF ( pdr.used_representation ) ) AND 
        ( pdr.used_representation.name ='maximum feature limit'))) >=0)) ) ) ) = 0; 
END_RULE; 

SUBTYPE_CONSTRAINT machining_feature_definition_subtypes FOR feature_definition;
  ONEOF (  
    boss,
    compound_feature,
    externally_defined_feature_definition,
    flat_face,
    gear,
    marking,
    outer_round,
    outside_profile,
    pocket,
    protrusion,
    removal_volume,
    replicate_feature,
    revolved_profile,
    rib_top,
    round_hole,
    rounded_end,
    spherical_cap,
    step,
    slot,
    thread,
    turned_knurl);
END_SUBTYPE_CONSTRAINT;


END_SCHEMA;   -- AIC_MACHINING_FEATURE
(*
ISO TC184/SC4/WG12 N6201 - ISO 10303-521 Manifold subsurface - EXPRESS
Supersedes ISO TC184/SC4/WG12 N5258
*)

 SCHEMA aic_manifold_subsurface;  --- as modified by TC1 WG12 N4503
  USE FROM aic_topologically_bounded_surface; -- ISO 10303-511

  USE FROM geometry_schema    -- ISO  10303-42
      (cartesian_transformation_operator_3d);
  USE FROM topology_schema  -- ISO  10303-42
      (closed_shell,
       connected_face_set,
       connected_face_sub_set,
       face,
       open_shell,
       subedge,
       subface);

  USE FROM representation_schema(mapped_item);   -- ISO  10303-43

  USE FROM product_property_representation_schema   -- ISO  10303-41
      (shape_representation);

 ENTITY manifold_subsurface_shape_representation
 SUBTYPE OF (shape_representation);
 WHERE
   WR1: SIZEOF (QUERY (it <* SELF.items |
          NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET',
                'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM',
                'AIC_MANIFOLD_SUBSURFACE.AXIS2_PLACEMENT_3D'] *
                   TYPEOF(it)) = 1))) = 0;
   WR2: SIZEOF (QUERY (it <* SELF.items |
         SIZEOF(['AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET',
         'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM'] * TYPEOF(it)) =1 )) > 0;
   WR3: SIZEOF (QUERY (mi <*  QUERY (it <* items |
                 'AIC_MANIFOLD_SUBSURFACE.MAPPED_ITEM' IN TYPEOF(it)) |
   NOT ('AIC_MANIFOLD_SUBSURFACE.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN
             TYPEOF(mi\mapped_item.mapping_source.
                           mapped_representation)))) = 0;
   WR4: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT('AIC_MANIFOLD_SUBSURFACE.OPEN_SHELL' IN TYPEOF(cfss)))) = 0;
   WR5: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          NOT( (('AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN
                   TYPEOF(cfss\connected_face_sub_set.parent_face_set))AND
           (SIZEOF(QUERY(fac <* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT
                 advanced_face_properties(fac))) = 0)) OR
            (SIZEOF(QUERY(fac <* cfss\connected_face_sub_set.parent_face_set\connected_face_set.cfs_faces | NOT
              ('AIC_MANIFOLD_SUBSURFACE.ADVANCED_FACE' IN TYPEOF(fac)))) = 0)
                    ))) = 0;
   WR6: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
          ( SIZEOF (QUERY (fac <* cfss\connected_face_set.cfs_faces  | NOT
              advanced_face_properties(fac))) = 0))) = 0;
   WR7: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
          'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
               ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
            NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                  NOT(('AIC_MANIFOLD_SUBSURFACE.EDGE_CURVE' IN
            TYPEOF(oe.edge_element)) OR
           ('AIC_MANIFOLD_SUBSURFACE.SUBEDGE' IN
            TYPEOF(oe.edge_element)) ))) = 0
                   ))) = 0
                 ))) = 0
             ))) = 0;
   WR8: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
           ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
          NOT(('AIC_MANIFOLD_SUBSURFACE.VERTEX_POINT' IN TYPEOF(oe.edge_start))
                AND ('AIC_MANIFOLD_SUBSURFACE.VERTEX_POINT' IN
                 TYPEOF(oe.edge_end))
            ))) = 0
              ))) = 0
               ))) = 0
                   ))) = 0;
   WR9: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY  (bnds <* fcs.bounds |
         NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP',
                'AIC_MANIFOLD_SUBSURFACE.VERTEX_LOOP'] *
                   TYPEOF(bnds.bound)) = 1 )
                   )) = 0)
                 ))) = 0
             ))) = 0;
   WR10: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
              ( NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                 NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   NOT (SIZEOF (['AIC_MANIFOLD_SUBSURFACE.LINE',
                         'AIC_MANIFOLD_SUBSURFACE.CONIC',
                         'AIC_MANIFOLD_SUBSURFACE.POLYLINE',
                         'AIC_MANIFOLD_SUBSURFACE.SURFACE_CURVE',
                         'AIC_MANIFOLD_SUBSURFACE.B_SPLINE_CURVE' ] *
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) = 1 )
               )) = 0
               ))) = 0
                 )))) = 0
                    ))) = 0;
   WR11: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_MANIFOLD_SUBSURFACE.SURFACE_CURVE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT ((SIZEOF (QUERY (sc_ag <*
            oe.edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry |
            NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN
            TYPEOF(sc_ag)))) = 0)))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
   WR12: SIZEOF (QUERY (cfss <* QUERY (it <* SELF.items |
           'AIC_MANIFOLD_SUBSURFACE.CONNECTED_FACE_SUB_SET' IN TYPEOF(it)) |
             NOT (SIZEOF (QUERY(fcs <* cfss\connected_face_set.cfs_faces |
              ( 'AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(fcs)) AND
               (NOT (SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* fcs.bounds |
         'AIC_MANIFOLD_SUBSURFACE.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
                NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list |
                   ('AIC_MANIFOLD_SUBSURFACE.POLYLINE' IN
            TYPEOF(oe.edge_element\edge_curve.edge_geometry)) AND
            (NOT (SIZEOF (oe\oriented_edge.edge_element\
                  edge_curve.edge_geometry\polyline.points) >= 3))
               )) = 0
               ))) = 0
                   )))) = 0
                    ))) = 0;
 END_ENTITY;

FUNCTION advanced_face_properties (testface : face) : BOOLEAN;
(* return TRUE if testface is of type advanced_face *)
IF 'AIC_MANIFOLD_SUBSURFACE.ADVANCED_FACE' IN TYPEOF(testface) THEN
    RETURN (TRUE);
END_IF;
(* if testface is a subface recursively test the parent_face,
return FALSE for all other types of face *)
IF  ('AIC_MANIFOLD_SUBSURFACE.SUBFACE' IN TYPEOF(testface)) THEN
     RETURN(advanced_face_properties(testface\subface.parent_face));
   ELSE RETURN (FALSE);
END_IF;
END_FUNCTION;

 END_SCHEMA; -- end AIC_MANIFOLD_SUBSURFACE SCHEMA
(* ISO 10303-509, TC 184/SC4/WG12 N578 *)
SCHEMA aic_manifold_surface; 
 
  USE FROM aic_topologically_bounded_surface;       -- ISO 10303-511
 
  USE FROM geometric_model_schema (                 -- ISO 10303-42
      shell_based_surface_model); 
 
  USE FROM geometry_schema (                        -- ISO 10303-42
      b_spline_curve,
      b_spline_surface,
      bounded_pcurve,
      bounded_surface_curve,
      cartesian_transformation_operator_3d,
      curve, 
      curve_replica, 
      degenerate_pcurve, 
      evaluated_degenerate_pcurve, 
      intersection_curve, 
      offset_curve_3d, 
      offset_surface, 
      point_on_curve, 
      point_on_surface, 
      seam_curve, 
      surface, 
      surface_replica); 

  USE FROM product_property_representation_schema ( -- ISO 10303-41 
      shape_representation); 
 
  USE FROM representation_schema (                  -- ISO 10303-43
      mapped_item,
      representation,
      representation_item,
      representation_map);
 
  USE FROM topology_schema (                        -- ISO 10303-42
      closed_shell,
      connected_face_set, 
      face,
      open_shell, 
      oriented_closed_shell);

ENTITY manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation); 
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM',
       'AIC_MANIFOLD_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1))) = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL',
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('AIC_MANIFOLD_SURFACE.MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR4: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (sh <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.OPEN_SHELL',
       'AIC_MANIFOLD_SURFACE.ORIENTED_CLOSED_SHELL',
       'AIC_MANIFOLD_SURFACE.CLOSED_SHELL']
       * TYPEOF (sh)) = 1))) = 0))) = 0;
  WR5: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT ('AIC_MANIFOLD_SURFACE.FACE_SURFACE' IN TYPEOF (fa)) )) = 0)))
       = 0))) = 0;
  WR6: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (msf_surface_check(fa\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR7: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.EDGE_LOOP',
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items|
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'AIC_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.B_SPLINE_CURVE',
       'AIC_MANIFOLD_SURFACE.CONIC',
       'AIC_MANIFOLD_SURFACE.CURVE_REPLICA',
       'AIC_MANIFOLD_SURFACE.LINE',
       'AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D',
       'AIC_MANIFOLD_SURFACE.PCURVE',
       'AIC_MANIFOLD_SURFACE.POLYLINE',
       'AIC_MANIFOLD_SURFACE.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (msf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY(sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AIC_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR14: SIZEOF (QUERY (sbsm <* QUERY (it <* SELF.items |
       'AIC_MANIFOLD_SURFACE.SHELL_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       sbsm\shell_based_surface_model.sbsm_boundary |
       NOT (SIZEOF (QUERY (fa <* cfs\connected_face_set.cfs_faces |
       NOT (('AIC_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AIC_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;

FUNCTION msf_curve_check (cv : representation_item) : BOOLEAN;  
 
(* This function varifies the validity of a curve in the context of a
   manifold surface model. Representation_items are
   valid input, however, they are supposed to be curves; otherwise
   this function will return false.
*)

(* complex subtypes of curve that are both bounded_curve and
   oneof conic, curve_replica, line, or offset_curve_3d are not
   valid
*)
IF SIZEOF (['AIC_MANIFOLD_SURFACE.BOUNDED_CURVE',
  'AIC_MANIFOLD_SURFACE.CONIC',
  'AIC_MANIFOLD_SURFACE.CURVE_REPLICA', 'AIC_MANIFOLD_SURFACE.LINE',
  'AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1 THEN
  RETURN(FALSE);
END_IF;

(* b_spline_curves shall not self-intersect
 *)
IF (('AIC_MANIFOLD_SURFACE.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
  (cv\b_spline_curve.self_intersect = FALSE)OR
  (cv\b_spline_curve.self_intersect = UNKNOWN)) THEN
  RETURN(TRUE);
ELSE

  (* conics and lines are valid curve types
   *)
  IF SIZEOF (['AIC_MANIFOLD_SURFACE.CONIC', 'AIC_MANIFOLD_SURFACE.LINE'] 
    * TYPEOF (cv)) = 1 THEN
    RETURN(TRUE);
  ELSE

    (* a curve_replica shall reference a valid curve
     *)
    IF 'AIC_MANIFOLD_SURFACE.CURVE_REPLICA' IN TYPEOF(cv) THEN
      RETURN (msf_curve_check(cv\curve_replica.parent_curve)); 
    ELSE 
 
      (* an offset_curve_3d shall not self-intersect and
         shall reference a valid curve; a polyline is not a
         valid basis_curve
       *)
      IF (('AIC_MANIFOLD_SURFACE.OFFSET_CURVE_3D' IN TYPEOF (cv))
        AND
        ((cv\offset_curve_3d.self_intersect = FALSE) OR
        (cv\offset_curve_3d.self_intersect = UNKNOWN))
        AND
        (NOT ('AIC_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF
        (cv\offset_curve_3d.basis_curve)))) THEN
        RETURN (msf_curve_check(cv\offset_curve_3d.basis_curve)); 
      ELSE 
 
        (* a pcurve shall reference a valid curve and a valid
           basis_surface
         *)
        IF 'AIC_MANIFOLD_SURFACE.PCURVE' IN TYPEOF(cv) THEN 
          RETURN ((msf_curve_check
          (cv\pcurve.reference_to_curve\representation.items[1])) AND
          (msf_surface_check(cv\pcurve.basis_surface)));
        ELSE 
 
          (* a surface_curve references a curve_3d and one or
             two pcurves or one or two surfaces or one of
             each; all of these references shall be valid
           *)
          IF 'AIC_MANIFOLD_SURFACE.SURFACE_CURVE' IN TYPEOF(cv) THEN 

            (* if the curve reference is correct, check also the rest
             *)
            IF msf_curve_check(cv\surface_curve.curve_3d) THEN
              REPEAT i := 1 TO SIZEOF
              (cv\surface_curve.associated_geometry);

                (* do for one or two associated_geometrys:
                 *)
                IF 'AIC_MANIFOLD_SURFACE.SURFACE' IN 
                  TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                  IF NOT msf_surface_check
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    RETURN(FALSE);  
                  END_IF;  
                ELSE  
                  IF 'AIC_MANIFOLD_SURFACE.PCURVE' IN TYPEOF 
                    (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT msf_curve_check
                      (cv\surface_curve.associated_geometry[i]) THEN 
                      RETURN(FALSE);  
                    END_IF;  
                  END_IF;  
                END_IF; 
              END_REPEAT;  
              RETURN(TRUE);
            END_IF; 
          ELSE

            (* a polyline shall have at least 3 points
             *)
            IF 'AIC_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF(cv) THEN
              IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
              END_IF;
            END_IF;
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
END_IF; 
(* FALSE is returned if the input parameter cv is not a valid curve.
 *)
RETURN (FALSE); 
END_FUNCTION;

FUNCTION msf_surface_check (surf : surface) : BOOLEAN;

(* This function varifies the validity of a surface in the
   context of a manifold surface model.
*)

  (* elementary_surfaces are valid surface types
   *)
  IF 'AIC_MANIFOLD_SURFACE.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AIC_MANIFOLD_SURFACE.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (msf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AIC_MANIFOLD_SURFACE.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (msf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AIC_MANIFOLD_SURFACE.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(msf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AIC_MANIFOLD_SURFACE.B_SPLINE_SURFACE' IN TYPEOF(surf)) AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE); 
END_FUNCTION;

END_SCHEMA; (* aic_manifold_surface *)
(*
ISO TC184/SC4/WG12 N6177 - ISO 10303-517 Mechanical design geometric presentation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N5252
*)

SCHEMA aic_mechanical_design_geometric_presentation;

    USE FROM geometry_schema                          -- ISO 10303-42
     (axis2_placement,
      axis2_placement_2d,
      axis2_placement_3d); 

    USE FROM presentation_appearance_schema           -- ISO 10303-46
       (curve_style,
        curve_style_font, 
        curve_style_font_pattern,
        draughting_pre_defined_curve_font,
        fill_area_style_colour,
        invisibility,
        marker_type,
        over_riding_styled_item,
        point_style,
        presentation_style_by_context,
        styled_item,
        surface_side_style,
        surface_style_boundary,
        surface_style_control_grid, 
        surface_style_fill_area,
        surface_style_parameter_line,
        surface_style_segmentation_curve, 
        surface_style_silhouette, 
        surface_style_usage,
        u_direction_count,        
        v_direction_count);

    REFERENCE FROM presentation_organization_schema    -- ISO 10303-46
       (aspect_ratio,
       camera_model_d3);

    USE FROM presentation_organization_schema          -- ISO 10303-46
       (background_colour,
        camera_image_3d_with_scale,
        camera_usage,
        presentation_area,        
        presentation_representation,
        presentation_size,
        presentation_view);

    USE FROM presentation_resource_schema              -- ISO 10303-46
       (colour_rgb,
        draughting_pre_defined_colour,
        planar_box,
        planar_extent);

    USE FROM product_property_representation_schema    -- ISO 10303-41
     (shape_representation);

    USE FROM representation_schema                     -- ISO 10303-43
       (mapped_item,
        representation); 

  TYPE mechanical_design_geometric_presentation_area_items = SELECT(
    axis2_placement,
    mapped_item);
  END_TYPE;

  TYPE mechanical_design_geometric_presentation_representation_items = SELECT(
    axis2_placement,
    camera_model_d3,
    mapped_item,
    styled_item);
  END_TYPE;

  ENTITY mechanical_design_geometric_presentation_area
    SUBTYPE OF (presentation_area);
      SELF\representation.items : SET[1:?] OF mechanical_design_geometric_presentation_area_items;
    WHERE
     WR1:  -- only presentation_views or axis2_placements in
        -- mechanical_design_geometric_presentation_area
       SIZEOF(QUERY(it1 <* SELF.items |
        NOT ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it1))
        OR
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it1\mapped_item.mapping_source.mapped_representation)))) = 0;
  WR2:  -- only mechanical_design_geometric_presentation_representation
        -- via camera_image_3d_with_scale or axis2_placements in
        -- presentation_views
        SIZEOF(QUERY(pv <* QUERY(mi1 <* QUERY(it1 <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it1)) |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        -- search in all presentation_views for axis2_placements and
        -- mapped_items and for the subtype of mapped_item
        -- camera_image_3d_with_scale; the latter shall reference
        -- a mechanical_design_geometric_presentation_representation;
        -- the supertype mapped_item shall reference presentation_view.
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION'
        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))
        ))) = 0))) = 0;
      WR3:  (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ((ps\presentation_size.size.size_in_x <= 0)
         OR
         (ps\presentation_size.size.size_in_y <= 0)))) = 0)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ((ps\presentation_size.size.size_in_x <= 0)
        OR
        (ps\presentation_size.size.size_in_y <= 0)))) > 0))) = 0);
      WR4:  (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1)
        AND
        (SIZEOF(QUERY(ps <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') | 
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0)
        OR
        ((SIZEOF(QUERY(ais <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('GEOMETRY_SCHEMA.' +
        'AXIS2_PLACEMENT_2D' IN TYPEOF (ps.size.placement)))) = 1))) = 1)
        AND
        (SIZEOF(QUERY(ais <* USEDIN (SELF,
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'AREA_IN_SET.AREA') |
        (SIZEOF(QUERY(ps <* USEDIN (ais, 
        'PRESENTATION_ORGANIZATION_SCHEMA.' +
        'PRESENTATION_SIZE.UNIT') |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'AXIS2_PLACEMENT_3D' IN TYPEOF (ps.size.placement)))) = 0))) = 1));
  END_ENTITY;

  ENTITY mechanical_design_geometric_presentation_representation
    SUBTYPE OF (representation);
      SELF\representation.items : SET[1:?] OF mechanical_design_geometric_presentation_representation_items;
    WHERE
      WR1: SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SHAPE_REPRESENTATION',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION_REPRESENTATION']
        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
      WR2: SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
        item\mapped_item.mapping_source.mapped_representation))) )) = 0;
      WR3: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(pss <* psa.styles | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.POINT_STYLE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE']
        * TYPEOF(pss)) = 1))) = 0))) = 0))) = 0;
      WR4: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psbc <* QUERY(psa <* si\styled_item.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(psa)) | NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'REPRESENTATION_ITEM',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.REPRESENTATION']
        * TYPEOF(psbc\presentation_style_by_context.style_context))
        = 1))) = 0))) = 0;
      WR5: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ps <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.POINT_STYLE'
        IN TYPEOF(pss)) | NOT
        (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ps\point_style.marker_size))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ps\point_style.marker_colour))
        = 1)))) = 0))) = 0))) = 0;
      WR6: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(cs <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF(pss)) | NOT((SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(cs\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (cs\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0;
      WR7: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) |
        NOT ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_SIDE_STYLE' IN TYPEOF
        (ssu\surface_style_usage.style)))) = 0))) = 0))) = 0;
      WR8: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_PARAMETER_LINE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_CONTROL_GRID',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SILHOUETTE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_FILL_AREA',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_BOUNDARY']
        * TYPEOF(sses)) = 1))) = 0))) = 0))) = 0))) = 0;
      WR9: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sspl <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND (
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR10: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sscg <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF 
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR11: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) |
        NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssh <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\curve_style.
        curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR12: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(sssc <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1))))
        = 0))) = 0))) = 0))) = 0;
      WR13: SIZEOF(QUERY(si <* QUERY(it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it)) | NOT (SIZEOF(QUERY(psa <* si\styled_item.styles |
        NOT (SIZEOF(QUERY(ssu <* QUERY(pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF(pss)) | NOT (SIZEOF(QUERY(ssbd <* QUERY(sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF(sses)) |
        NOT (('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_COLOUR']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'POSITIVE_LENGTH_MEASURE' IN TYPEOF (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND (SIZEOF(
        ['AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.CURVE_STYLE_FONT',
        'AIC_MECHANICAL_DESIGN_GEOMETRIC_PRESENTATION.' +
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT']
        * TYPEOF(ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)))) = 0)))
        = 0))) = 0))) = 0;
  END_ENTITY;

END_SCHEMA;  
(*
ISO TC184/SC4/WG12 N6183 - ISO 10303-518 Mechanical design shaded presentation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N5254
*)

SCHEMA aic_mechanical_design_shaded_presentation;

    USE FROM geometry_schema                          -- ISO 10303-42
     (axis2_placement,
      axis2_placement_2d,
      axis2_placement_3d); 

    USE FROM measure_schema                           -- ISO 10303-41
    (positive_ratio_measure);

    USE FROM presentation_appearance_schema           -- ISO 10303-46
     (curve_style, 
      curve_style_font, 
      curve_style_font_pattern, 
      curve_style_rendering,
      draughting_pre_defined_curve_font,
      fill_area_style_colour,
      invisibility,
      marker_type,
      over_riding_styled_item,
      point_style,
      presentation_style_by_context,
      styled_item,
      surface_rendering_properties,
      surface_side_style,
      surface_style_boundary,
      surface_style_control_grid,
      surface_style_fill_area,
      surface_style_parameter_line,
      surface_style_reflectance_ambient,
      surface_style_reflectance_ambient_diffuse,
      surface_style_reflectance_ambient_diffuse_specular,
      surface_style_rendering,
      surface_style_rendering_with_properties,
      surface_style_segmentation_curve,
      surface_style_silhouette,
      surface_style_transparent,
      surface_style_usage,
      u_direction_count,
      v_direction_count);

    REFERENCE FROM presentation_organization_schema   -- ISO 10303-46
     (aspect_ratio);

    USE FROM presentation_organization_schema         -- ISO 10303-46
     (area_in_set,
      background_colour,
      camera_image_3d_with_scale,
      camera_model_d3,
      camera_model_d3_with_hlhsr,
      camera_model_with_light_sources,
      camera_usage,
      light_source_ambient,
      light_source_directional,
      light_source_positional,
      light_source_spot,
      presentation_area,        
      presentation_representation,
      presentation_size,
      presentation_view);

    USE FROM presentation_resource_schema             -- ISO 10303-46
     (colour_rgb,
      draughting_pre_defined_colour,
      planar_box,   
      planar_extent);
      
	USE FROM product_property_representation_schema -- ISO/IS 10303-41
	(shape_representation);
	
    USE FROM representation_schema                    -- ISO 10303-43
     (mapped_item,
      representation); 

  TYPE mechanical_design_shaded_presentation_area_items = SELECT(
    axis2_placement,
    mapped_item);
  END_TYPE;

  TYPE mechanical_design_shaded_presentation_representation_items = SELECT(
    axis2_placement,
    camera_model_d3,
    mapped_item,
    styled_item);
  END_TYPE;

  ENTITY mechanical_design_shaded_presentation_area
    SUBTYPE OF (presentation_area);
      SELF\representation.items : SET[1:?] OF mechanical_design_shaded_presentation_area_items;
  WHERE
  WR1 : (* only presentation_views or axis2_placements in
           mechanical_design_shaded_presentation_area *)
        SIZEOF (QUERY (it1 <* SELF.items |
        NOT (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.AXIS2_PLACEMENT'
        IN TYPEOF (it1))
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF (it1)) AND
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it1\mapped_item.mapping_source.mapped_representation)))))) = 0;
  WR2 : (* only mechanical_design_shaded_presentation_representation
           via camera_image_3d_with_scale or axis2_placements in 
           presentation_views *)
        SIZEOF (QUERY (pv <* QUERY (mi1 <* QUERY (it1 <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF (it1)) |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        (* search in all presentation_views for axis2_placements and
           mapped_items and for the subtype of mapped_item,
           camera_image_3d_with_scale; the latter shall reference
           a mechanical_design_geometric_presentation_representation;
           the supertype mapped_item shall reference presentation_view. *)
        NOT (SIZEOF(QUERY(it2 <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        NOT (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.AXIS2_PLACEMENT'
        IN TYPEOF(it2))
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it2)) AND NOT
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))) AND NOT (
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.PRESENTATION_VIEW'
        IN TYPEOF
        (it2\mapped_item.mapping_source.mapped_representation)))
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(it2))
        AND NOT (
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION'
        IN TYPEOF (it2\mapped_item.mapping_source.mapped_representation) ))
        ))) = 0))) = 0;
  WR3:  (* Presentation_size shall be a positive rectangle for area and set.
           Check for this presentation_area subtype first. *)
        (SIZEOF (QUERY(ps <* USEDIN (SELF, 
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' + 
        'PRESENTATION_SIZE.UNIT') |
        NOT ((ps\presentation_size.size.size_in_x > 0) 
        AND (ps\presentation_size.size.size_in_y > 0)) )) = 0)
        AND
        (* check secondly for presentation_set, via area_in_set *)
        (SIZEOF (QUERY(pset <* QUERY(ais <* 
        USEDIN (SELF, 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' + 
        'AREA_IN_SET.AREA') 
        | 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |
        (* after having collected all presentation_set, check their sizes *)
        SIZEOF (QUERY(ps <* USEDIN(pset, 
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' + 
        'PRESENTATION_SIZE.UNIT')
        | NOT ((ps\presentation_size.size.size_in_x > 0) 
        AND (ps\presentation_size.size.size_in_y > 0)) )) = 0)) = 0);
  WR4:  (* Drawing space shall be defined in 2D.
           Check for this presentation_area subtype first. *)
        (SIZEOF(QUERY( psize <* USEDIN (SELF, 
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' + 
        'PRESENTATION_SIZE.UNIT') 
        | 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'AXIS2_PLACEMENT_2D' 
        IN TYPEOF (psize.size.placement))) = 1)
        AND
        (* check secondly for presentation_set, via area_in_set *)
        (SIZEOF (QUERY(pset <* QUERY(ais <* 
        USEDIN (SELF, 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'AREA_IN_SET.AREA')
        | 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'PRESENTATION_SET' IN TYPEOF (ais.in_set)) |
        (* after having collected all presentation_set, check their 
           dimension *)
        SIZEOF (QUERY(psize <* USEDIN(pset, 
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' + 
        'PRESENTATION_SIZE.UNIT')
        | NOT ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' + 
        'AXIS2_PLACEMENT_2D' 
        IN TYPEOF (psize.size.placement)) )) = 0)) = 0);
  WR5 : (* valid types of camera_models
           get for all presentation_areas their presentation_views *)
        SIZEOF (QUERY (pv <* QUERY (mi1 <* QUERY (it1 <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.MAPPED_ITEM' 
        IN TYPEOF (it1)) |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.PRESENTATION_VIEW' 
        IN TYPEOF 
        (mi1\mapped_item.mapping_source.mapped_representation)) |
        (* search in all presentation_views for 
           mapped_items and for the subtype of mapped_item,
           camera_image_3d_with_scale; the latter shall reference
           a camera_usage that shall have as its mapping_origin either
           camera_model_d3, camera_model_d3_with_hlhsr, or
           camera_model_with_light_sources. *)
        NOT (SIZEOF(QUERY(ci <* pv\mapped_item.mapping_source.
        mapped_representation\representation.items |
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
         'CAMERA_IMAGE_3D_WITH_SCALE' IN TYPEOF(ci))
        AND
        (SIZEOF(['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CAMERA_MODEL_D3',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CAMERA_MODEL_D3_WITH_HLHSR',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CAMERA_MODEL_WITH_LIGHT_SOURCES'] * TYPEOF
        (ci\mapped_item.mapping_source.mapping_origin))
        = 1))) = 0))) = 0;
  END_ENTITY; (* mechanical_design_shaded_presentation_area *)


ENTITY mechanical_design_shaded_presentation_representation
   SUBTYPE OF (representation);
      SELF\representation.items : SET[1:?] OF mechanical_design_shaded_presentation_representation_items;
WHERE
  WR1:  (* for all mapped_items check that only
           shape_representations and
           mechanical_design_shaded_presentation_representations
           are referenced *)
        SIZEOF(QUERY(mi <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(it))) | NOT (SIZEOF(
        ['PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
        'SHAPE_REPRESENTATION',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.' +
        'MECHANICAL_DESIGN_SHADED_PRESENTATION_REPRESENTATION']
        * TYPEOF(mi\mapped_item.mapping_source.mapped_representation))
        = 1))) = 0;
  WR2:  (* for all styled_item.item check that in case they are
           mapped_items that they are shape_representations *)
        SIZEOF(QUERY(smi <* QUERY(si <* QUERY(it <* SELF.items |
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF(it))) |
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.MAPPED_ITEM'
        IN TYPEOF(si\styled_item.item))) | NOT (
        ('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
        'SHAPE_REPRESENTATION' IN TYPEOF (smi\styled_item.
        item\mapped_item.mapping_source.mapped_representation))) )) = 0;
  WR3: (* for all styled_items get their styles via
           presentation_style_assignment.styles and check for valid
           style types *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (pss <* psa.styles |
        NOT (SIZEOF (
        ['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.POINT_STYLE',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE']
        *  TYPEOF (pss)) = 1))) = 0))) = 0))) = 0;
  WR4: (* for all styled_items get those assigned styles that 
           are presentation_style_by_contexts and ensure that
           these reference only representation_items and 
           representations as valid contexts *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psbc <* QUERY (psa <* si\styled_item.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF (psa))  |
        NOT (SIZEOF (
        ['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.REPRESENTATION_ITEM',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.REPRESENTATION']
        * TYPEOF (psbc\presentation_style_by_context.style_context)) = 1)))
        = 0))) = 0;
  WR5: (* for all styled_items get all assigned point_styles  
           and ensure that marker_select, marker_size and
           marker_colour are valid *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ps <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.POINT_STYLE'
        IN TYPEOF (pss)) |
        NOT (
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.MARKER_TYPE'
        IN TYPEOF (ps\point_style.marker))
        AND
        ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (ps\point_style.marker_size))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ps\point_style.marker_colour)) = 1)))) = 0))) = 0))) = 0;
  WR6: (* for all styled_items get all assigned curve_styles  
           and ensure that curve_width, curve_font and
           curve_colour are valid *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (cs <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (pss)) |
        NOT (
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (cs\curve_style.curve_colour)) = 1)
        AND
        ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (cs\curve_style.curve_width))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CURVE_STYLE_FONT', 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (cs\curve_style.curve_font)) = 1)))) = 0))) = 0))) = 0;
  WR7: (* for all styled_items get all assigned surface_style_usages
           and ensure that its style is a surface_side_style *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_SIDE_STYLE'
        IN TYPEOF (ssu\surface_style_usage.style)) )) = 0))) = 0 ))) = 0;
  WR8: (* for all styled_items get all assigned surface_style_usages
           and the surface_side_styles that they reference, and ensure
           that the styles referenced by those surface_side_styles
           are among the valid subset *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        NOT (SIZEOF (
        ['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_PARAMETER_LINE',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_CONTROL_GRID',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_SILHOUETTE',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_SEGMENTATION_CURVE',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_BOUNDARY',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_FILL_AREA',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_RENDERING'] * TYPEOF (sses)) = 1))) = 0))) = 0)))
        = 0))) = 0;
  WR9: (* for all surface_style_fill_areas that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to their colour representation *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssfa <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_FILL_AREA'
        IN TYPEOF (sses)) |
        NOT (SIZEOF (QUERY (fss <*
        ssfa\surface_style_fill_area.fill_area.fill_styles |
        NOT (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'FILL_AREA_STYLE_COLOUR' IN TYPEOF (fss))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (fss\fill_area_style_colour.fill_colour)) = 1)))) = 0))) = 0)))
        = 0))) = 0))) = 0;
  WR10: (* for all surface_style_parameter_lines that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sspl <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_PARAMETER_LINE' IN TYPEOF (sses)) |
        NOT ((
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE' IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_colour)) = 1)
        AND
        ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_width))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CURVE_STYLE_FONT', 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sspl\surface_style_parameter_line.
        style_of_parameter_lines\curve_style.curve_font)) = 1))
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE_RENDERING'
        IN TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sspl\surface_style_parameter_line.style_of_parameter_lines\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR11: (* for all surface_style_control_grids that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sscg <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_CONTROL_GRID' IN TYPEOF (sses)) |
        NOT ((
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_colour)) = 1)
        AND
        ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_width))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CURVE_STYLE_FONT', 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sscg\surface_style_control_grid.
        style_of_control_grid\curve_style.curve_font)) = 1))
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE_RENDERING'
        IN TYPEOF (sscg\surface_style_control_grid.style_of_control_grid))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sscg\surface_style_control_grid.style_of_control_grid\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR12: (* for all surface_style_silhouettes that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sssh <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_SILHOUETTE' IN TYPEOF (sses)) |
        NOT ((
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_colour)) = 1)
        AND
        ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_width))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CURVE_STYLE_FONT', 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sssh\surface_style_silhouette.
        style_of_silhouette\curve_style.curve_font)) = 1)) 
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE_RENDERING'
        IN TYPEOF (sssh\surface_style_silhouette.style_of_silhouette))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssh\surface_style_silhouette.style_of_silhouette\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR13: (* for all surface_style_segmentation_curves that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (sssc <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_SEGMENTATION_CURVE' IN TYPEOF (sses)) |
        NOT ((
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE'
        IN TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_colour)) = 1)
        AND
        ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_width))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CURVE_STYLE_FONT', 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve\curve_style.curve_font)) = 1)) 
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE_RENDERING'
        IN TYPEOF (sssc\surface_style_segmentation_curve.
        style_of_segmentation_curve))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (sssc\surface_style_segmentation_curve.style_of_segmentation_curve\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR14: (* for all surface_style_boundaries that are referenced by
           any surface_side_styles ensure that they are valid 
           with respect to the applied curve_style, which may include
           rendering *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssbd <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_BOUNDARY' IN TYPEOF (sses)) |
        NOT ((
        ('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_colour)) = 1)
        AND
        ('MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_width))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'CURVE_STYLE_FONT', 'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_CURVE_FONT'] * TYPEOF
        (ssbd\surface_style_boundary.
        style_of_boundary\curve_style.curve_font)) = 1)) 
        OR
        (('AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.CURVE_STYLE_RENDERING'
        IN TYPEOF (ssbd\surface_style_boundary.style_of_boundary))
        AND
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssbd\surface_style_boundary.style_of_boundary\
        curve_style_rendering.rendering_properties.rendered_colour))
        = 1))) )) = 0))) = 0))) = 0))) = 0;
  WR15: (* for all surface_style_renderings that are referenced by
           any surface_side_styles ensure that the colour
           representation is valid *)
        SIZEOF (QUERY (si <* QUERY (it <* SELF.items |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.STYLED_ITEM'
        IN TYPEOF (it)) |
        NOT (SIZEOF (QUERY (psa <* si\styled_item.styles |
        NOT (SIZEOF (QUERY (ssu <* QUERY (pss <* psa.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.SURFACE_STYLE_USAGE'
        IN TYPEOF (pss)) |
        NOT (SIZEOF (QUERY (ssre <* QUERY (sses <*
        ssu\surface_style_usage.style\surface_side_style.styles |
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'SURFACE_STYLE_RENDERING' IN TYPEOF (sses)) |
        NOT
        (SIZEOF (['AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.COLOUR_RGB',
        'AIC_MECHANICAL_DESIGN_SHADED_PRESENTATION.'+
        'DRAUGHTING_PRE_DEFINED_COLOUR'] * TYPEOF
        (ssre\surface_style_rendering.surface_colour)) = 1)))
        = 0))) = 0))) = 0))) = 0;

END_ENTITY;


END_SCHEMA; -- aic_mechanical_design_shaded_presentation
(* ISO 10303-508, TC 184/SC4/WG12 N571 *)
SCHEMA aic_non_manifold_surface; 
 
  USE FROM aic_topologically_bounded_surface;       -- ISO 10303-511
 
  USE FROM geometric_model_schema (                 -- ISO 10303-42
      face_based_surface_model); 
 
  USE FROM geometry_schema (                        -- ISO 10303-42
      b_spline_curve,
      b_spline_surface,
      bounded_pcurve,
      bounded_surface_curve,
      cartesian_transformation_operator_3d,
      curve, 
      curve_replica, 
      degenerate_pcurve, 
      evaluated_degenerate_pcurve, 
      intersection_curve, 
      offset_curve_3d, 
      offset_surface, 
      point_on_curve, 
      point_on_surface, 
      seam_curve, 
      surface, 
      surface_replica); 

  USE FROM product_property_representation_schema ( -- ISO 10303-41
      shape_representation); 
 
  USE FROM representation_schema (                  -- ISO 10303-43
      mapped_item,
      representation,
      representation_item,
      representation_map);
 
  USE FROM topology_schema (                        -- ISO 10303-42
      closed_shell,
      connected_face_set, 
      face,
      open_shell, 
      oriented_face);
 

ENTITY non_manifold_surface_shape_representation 
   SUBTYPE OF (shape_representation); 
WHERE 
  WR1: SIZEOF (QUERY (it <* SELF.items |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL',
       'AIC_NON_MANIFOLD_SURFACE.MAPPED_ITEM',
       'AIC_NON_MANIFOLD_SURFACE.AXIS2_PLACEMENT_3D'] * TYPEOF (it)) = 1)))
       = 0;
  WR2: SIZEOF (QUERY (it <* SELF.items |
       SIZEOF (['AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL',
       'AIC_NON_MANIFOLD_SURFACE.MAPPED_ITEM'] * TYPEOF (it)) = 1)) > 0;
  WR3: SIZEOF (QUERY (mi <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.MAPPED_ITEM' IN TYPEOF (it)) |
       NOT (('AIC_NON_MANIFOLD_SURFACE.'+
       'NON_MANIFOLD_SURFACE_SHAPE_REPRESENTATION'
       IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation))
       AND
       (SIZEOF(QUERY (mr_it <*
       mi\mapped_item.mapping_source.mapped_representation.items |
       ('AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL'
       IN TYPEOF (mr_it)))) > 0 )))) = 0;
  WR4: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.FACE_SURFACE',
       'AIC_NON_MANIFOLD_SURFACE.ORIENTED_FACE'] * TYPEOF (fa)) = 1)))
       = 0))) = 0))) = 0;
  WR5: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (f_sf <* QUERY (fa <* cfs.cfs_faces |
       ('AIC_NON_MANIFOLD_SURFACE.FACE_SURFACE' IN TYPEOF (fa))) |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (f_sf))
       OR
       (nmsf_surface_check(f_sf\face_surface.face_geometry))))) = 0))) 
       = 0))) = 0;
  WR6: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (o_fa <* QUERY (fa <* cfs.cfs_faces |
       ('AIC_NON_MANIFOLD_SURFACE.ORIENTED_FACE' IN TYPEOF (fa))) |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF 
       (o_fa\oriented_face.face_element))
       OR
       (nmsf_surface_check
       (o_fa\oriented_face.face_element\face_surface.face_geometry)))))
       = 0))) = 0))) = 0;
  WR7: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (bnds <* fa.bounds |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP',
       'AIC_NON_MANIFOLD_SURFACE.VERTEX_LOOP']
       * TYPEOF (bnds.bound)) = 1))) = 0)))) = 0))) = 0))) = 0;
  WR8: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items|
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ('AIC_NON_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF 
       (oe.edge_element)))) = 0))) = 0)))) = 0))) = 0))) = 0;
  WR9: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe_cv <* QUERY (oe <* 
       elp_fbnds\path.edge_list |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_CURVE' IN TYPEOF (oe.edge_element)) |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.B_SPLINE_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.CONIC',
       'AIC_NON_MANIFOLD_SURFACE.CURVE_REPLICA',
       'AIC_NON_MANIFOLD_SURFACE.LINE',
       'AIC_NON_MANIFOLD_SURFACE.OFFSET_CURVE_3D',
       'AIC_NON_MANIFOLD_SURFACE.PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POLYLINE',
       'AIC_NON_MANIFOLD_SURFACE.SURFACE_CURVE'] * 
       TYPEOF (oe_cv.edge_element\edge_curve.edge_geometry)) 
       = 1))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR10: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT (nmsf_curve_check (oe.edge_element\edge_curve.edge_geometry)))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR11: SIZEOF (QUERY(fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list|
       NOT (('AIC_NON_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (oe.edge_element.edge_start))
       AND
       ('AIC_NON_MANIFOLD_SURFACE.VERTEX_POINT' IN
       TYPEOF (oe.edge_element.edge_end))))) 
       = 0))) = 0)))) = 0))) = 0))) = 0;
 WR12: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <*
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (elp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (QUERY (oe <* elp_fbnds\path.edge_list |
       NOT ((SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_NON_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_start\vertex_point.vertex_geometry)) = 1)
       AND
       (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_NON_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (oe.edge_element.edge_end\vertex_point.vertex_geometry)) = 1
       )))) = 0))) = 0)))) = 0))) = 0))) = 0;
 WR13: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT ('AIC_NON_MANIFOLD_SURFACE.VERTEX_POINT' IN TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex)))) = 0)))) = 0))) 
       = 0))) = 0;
 WR14: SIZEOF (QUERY (fbsm <* QUERY (it <* SELF.items |
       'AIC_NON_MANIFOLD_SURFACE.FACE_BASED_SURFACE_MODEL' IN TYPEOF (it)) |
       NOT (SIZEOF (QUERY (cfs <* 
       fbsm\face_based_surface_model.fbsm_faces |
       NOT (SIZEOF (QUERY (fa <* cfs.cfs_faces |
       NOT (('AIC_NON_MANIFOLD_SURFACE.ADVANCED_FACE' IN TYPEOF (fa))
       OR
       (SIZEOF (QUERY (vlp_fbnds <* QUERY (bnds <* fa.bounds |
       'AIC_NON_MANIFOLD_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) |
       NOT (SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CARTESIAN_POINT',
       'AIC_NON_MANIFOLD_SURFACE.DEGENERATE_PCURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_CURVE',
       'AIC_NON_MANIFOLD_SURFACE.POINT_ON_SURFACE'] * TYPEOF
       (vlp_fbnds\vertex_loop.loop_vertex\vertex_point.vertex_geometry)) 
       = 1))) = 0)))) = 0))) = 0))) = 0;
END_ENTITY;

FUNCTION nmsf_curve_check (cv : representation_item) : BOOLEAN;  
 
(* This function varifies the validity of a curve in the context of a
   non-manifold surface model. Representation_items are
   valid input, however, they are supposed to be curves; otherwise
   this function will return false.
*)

 (* complex subtypes of curve that are both bounded_curve and
    oneof conic, curve_replica, line, or offset_curve_3d are not
    valid
 *)
 IF SIZEOF (['AIC_NON_MANIFOLD_SURFACE.BOUNDED_CURVE',
   'AIC_NON_MANIFOLD_SURFACE.CONIC',
   'AIC_NON_MANIFOLD_SURFACE.CURVE_REPLICA',
   'AIC_NON_MANIFOLD_SURFACE.LINE',
   'AIC_NON_MANIFOLD_SURFACE.OFFSET_CURVE_3D'] * TYPEOF(cv)) > 1
 THEN RETURN(FALSE);
 ELSE

  (* b_spline_curves shall not self-intersect
   *)
  IF (('AIC_NON_MANIFOLD_SURFACE.B_SPLINE_CURVE' IN TYPEOF (cv)) AND
    (cv\b_spline_curve.self_intersect = FALSE) OR
    (cv\b_spline_curve.self_intersect = UNKNOWN))
  THEN RETURN(TRUE);
  ELSE

    (* conics and lines are valid curve types
     *)
    IF SIZEOF (['AIC_NON_MANIFOLD_SURFACE.CONIC',
    'AIC_NON_MANIFOLD_SURFACE.LINE'] * TYPEOF (cv)) = 1 THEN
      RETURN(TRUE);
    ELSE

      (* a curve_replica shall reference a valid curve
       *)
      IF 'AIC_NON_MANIFOLD_SURFACE.CURVE_REPLICA' IN TYPEOF(cv) THEN
        RETURN (nmsf_curve_check(cv\curve_replica.parent_curve)); 
      ELSE 
 
        (* an offset_curve_3d shall not self-intersect and
           shall reference a valid curve; a polyline is not a
           valid basis_curve
         *)
        IF (('AIC_NON_MANIFOLD_SURFACE.OFFSET_CURVE_3D' IN TYPEOF (cv)) 
          AND
          ((cv\offset_curve_3d.self_intersect = FALSE) OR
          (cv\offset_curve_3d.self_intersect = UNKNOWN))
          AND
          (NOT ('AIC_NON_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF
          (cv\offset_curve_3d.basis_curve)))) THEN
          RETURN (nmsf_curve_check(cv\offset_curve_3d.basis_curve)); 
        ELSE 
 
          (* a pcurve shall reference a valid curve and a valid
             basis_surface
           *)
          IF 'AIC_NON_MANIFOLD_SURFACE.PCURVE' IN TYPEOF(cv) THEN 
            RETURN ((nmsf_curve_check
            (cv\pcurve.reference_to_curve\representation.items[1]))
            AND
            (nmsf_surface_check(cv\pcurve.basis_surface)));
          ELSE 
 
            (* a surface_curve references a curve_3d and one or
               two pcurves or one or two surfaces or one of
               each; all of these references shall be valid
             *)
            IF 'AIC_NON_MANIFOLD_SURFACE.SURFACE_CURVE' IN TYPEOF(cv) THEN 

              (* if the curve reference is correct, check also the rest
               *)
              IF nmsf_curve_check(cv\surface_curve.curve_3d) THEN
                REPEAT i := 1 TO SIZEOF
                (cv\surface_curve.associated_geometry);

                  (* do for one or two associated_geometrys:
                   *)
                  IF 'AIC_NON_MANIFOLD_SURFACE.SURFACE' IN 
                    TYPEOF (cv\surface_curve.associated_geometry[i]) THEN  
                    IF NOT nmsf_surface_check
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      RETURN(FALSE);  
                    END_IF;  
                  ELSE  
                    IF 'AIC_NON_MANIFOLD_SURFACE.PCURVE' IN TYPEOF 
                      (cv\surface_curve.associated_geometry[i]) THEN  
                      IF NOT nmsf_curve_check
                        (cv\surface_curve.associated_geometry[i]) THEN 
                        RETURN(FALSE);  
                      END_IF;  
                    END_IF;  
                  END_IF; 
                END_REPEAT;  
                RETURN(TRUE);
              END_IF; 
            ELSE

              (* a polyline shall have at least 3 points 
               *)
              IF 'AIC_NON_MANIFOLD_SURFACE.POLYLINE' IN TYPEOF(cv) THEN
                IF (SIZEOF (cv\polyline.points) >= 3) THEN RETURN (TRUE);
                END_IF;
              END_IF;
            END_IF; 
          END_IF; 
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
 END_IF; 
 (* FALSE is returned if the input parameter cv is not a valid curve.
  *)
 RETURN (FALSE); 
END_FUNCTION;

FUNCTION nmsf_surface_check (surf : surface) : BOOLEAN;

(* This function varifies the validity of a surface in the
   context of a non-manifold surface model.
*)

  (* elementary_surfaces are valid surface types
   *)
  IF 'AIC_NON_MANIFOLD_SURFACE.ELEMENTARY_SURFACE' IN TYPEOF(surf) THEN
    RETURN(TRUE);
  ELSE 

    (* a swept_surface shall have a valid sweeping curve
     *)
    IF 'AIC_NON_MANIFOLD_SURFACE.SWEPT_SURFACE' IN TYPEOF (surf) THEN 
      RETURN (nmsf_curve_check(surf\swept_surface.swept_curve));  
    ELSE 
 
      (* an offset_surface shall not self-intersect and shall
         reference a valid surface
       *)
      IF (('AIC_NON_MANIFOLD_SURFACE.OFFSET_SURFACE' IN TYPEOF (surf)) AND
        (surf\offset_surface.self_intersect = FALSE) OR 
        (surf\offset_surface.self_intersect = UNKNOWN)) THEN
        RETURN (nmsf_surface_check(surf\offset_surface.basis_surface));
      ELSE 
 
        (* a surface_replica shall have a valid parent surface
         *)
        IF 'AIC_NON_MANIFOLD_SURFACE.SURFACE_REPLICA' IN TYPEOF(surf) THEN 
          RETURN(nmsf_surface_check(surf\surface_replica.parent_surface)); 
        ELSE

          (* a b_spline_surface shall not self-intersect
           *)
          IF (('AIC_NON_MANIFOLD_SURFACE.B_SPLINE_SURFACE' IN TYPEOF(surf))
            AND
            (surf\b_spline_surface.self_intersect = FALSE) OR
            (surf\b_spline_surface.self_intersect = UNKNOWN)) THEN
            RETURN(TRUE);
          END_IF;
        END_IF; 
      END_IF; 
    END_IF; 
  END_IF; 
  RETURN(FALSE); 
END_FUNCTION;

END_SCHEMA; (* aic_non_manifold_surface *)
SCHEMA aic_shell_based_wireframe;
  
USE FROM geometric_model_schema ( shell_based_wireframe_model);
 USE FROM geometry_schema ( axis2_placement_3d, b_spline_curve_with_knots, bezier_curve, cartesian_transformation_operator_3d, circle, conic, curve, curve_replica, ellipse, geometric_representation_context, hyperbola, line, offset_curve_3d, parabola, point, point_replica, polyline, quasi_uniform_curve, rational_b_spline_curve, uniform_curve);
 USE FROM product_property_representation_schema ( shape_representation);
 USE FROM representation_schema ( mapped_item);
 USE FROM topology_schema ( edge_curve, edge_loop, path, vertex_loop, vertex_point, vertex_shell, wire_shell);
  
ENTITY shell_based_wireframe_shape_representation 
 SUBTYPE OF ( shape_representation );
 WHERE 
WR1 : 
SIZEOF ( 
QUERY ( it <* SELF.items| NOT ( SIZEOF ([ 'AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL', 'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM', 'AIC_SHELL_BASED_WIREFRAME.AXIS2_PLACEMENT_3D' ] * TYPEOF (it)) = 1) )) = 0;
WR2 : 
SIZEOF ( 
QUERY ( it <* SELF.items| ( SIZEOF ([ 'AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL', 'AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM' ] * TYPEOF (it)) = 1) )) >= 1;
WR3 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT ('AIC_SHELL_BASED_WIREFRAME.EDGE_CURVE' IN TYPEOF (el.edge_element)) )) = 0) )) = 0) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( pline_el <* 
QUERY ( el <* eloop\path.edge_list| ('AIC_SHELL_BASED_WIREFRAME.POLYLINE' IN TYPEOF (el.edge_element\edge_curve.edge_geometry)) )| NOT ( SIZEOF (pline_el.edge_element\edge_curve.edge_geometry\polyline.points) > 2) )) = 0) )) = 0) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT valid_wireframe_edge_curve(el.edge_element\edge_curve.edge_geometry) )) = 0) )) = 0) )) = 0) )) = 0;
WR6 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_start)) AND ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (el.edge_element.edge_end))) )) = 0) )) = 0) )) = 0) )) = 0;
WR7 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( eloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.EDGE_LOOP' IN TYPEOF (wsb)) )| NOT ( SIZEOF ( 
QUERY ( el <* eloop\path.edge_list| NOT (valid_wireframe_vertex_point(el.edge_element.edge_start\vertex_point.vertex_geometry) AND valid_wireframe_vertex_point(el.edge_element.edge_end\vertex_point.vertex_geometry)) )) = 0) )) = 0) )) = 0) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (vloop\vertex_loop.loop_vertex)) )) = 0) )) = 0) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( ws <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.WIRE_SHELL' IN TYPEOF (sb)) )| NOT ( SIZEOF ( 
QUERY ( vloop <* 
QUERY ( wsb <* ws\wire_shell.wire_shell_extent| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_LOOP' IN TYPEOF (wsb)) )| NOT valid_wireframe_vertex_point(vloop\vertex_loop.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0) )) = 0;
WR10 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT ('AIC_SHELL_BASED_WIREFRAME.VERTEX_POINT' IN TYPEOF (vs\vertex_shell.vertex_shell_extent.loop_vertex)) )) = 0) )) = 0;
WR11 : 
SIZEOF ( 
QUERY ( sbwm <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF (it)) )| NOT ( SIZEOF ( 
QUERY ( vs <* 
QUERY ( sb <* sbwm\shell_based_wireframe_model.sbwm_boundary| ('AIC_SHELL_BASED_WIREFRAME.VERTEX_SHELL' IN TYPEOF (sb)) )| NOT valid_wireframe_vertex_point(vs\vertex_shell.vertex_shell_extent.loop_vertex\vertex_point.vertex_geometry) )) = 0) )) = 0;
WR12 : 
SIZEOF ( 
QUERY ( mi <* 
QUERY ( it <* SELF.items| ('AIC_SHELL_BASED_WIREFRAME.MAPPED_ITEM' IN TYPEOF (it)) )| NOT ('AIC_SHELL_BASED_WIREFRAME.' + 'SHELL_BASED_WIREFRAME_SHAPE_REPRESENTATION' IN TYPEOF (mi\mapped_item.mapping_source.mapped_representation)) )) = 0;
WR13 : SELF.context_of_items\geometric_representation_context.coordinate_space_dimension = 3;
 END_ENTITY ;
  
FUNCTION valid_wireframe_edge_curve 
( 
crv : curve ) : BOOLEAN ;
 IF SIZEOF ([ 'AIC_SHELL_BASED_WIREFRAME.LINE', 'AIC_SHELL_BASED_WIREFRAME.CONIC', 'AIC_SHELL_BASED_WIREFRAME.B_SPLINE_CURVE', 'AIC_SHELL_BASED_WIREFRAME.POLYLINE' ] * TYPEOF (crv)) = 1 THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_SHELL_BASED_WIREFRAME.CURVE_REPLICA' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\curve_replica.parent_curve));
 ELSE 
 IF 'AIC_SHELL_BASED_WIREFRAME.OFFSET_CURVE_3D' IN TYPEOF (crv) THEN 
 RETURN (valid_wireframe_edge_curve(crv\offset_curve_3d.basis_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
FUNCTION valid_wireframe_vertex_point 
( 
pnt : point ) : BOOLEAN ;
 IF 'AIC_SHELL_BASED_WIREFRAME.CARTESIAN_POINT' IN TYPEOF (pnt) THEN 
 RETURN (TRUE);
 ELSE 
 IF 'AIC_SHELL_BASED_WIREFRAME.POINT_REPLICA' IN TYPEOF (pnt) THEN 
 RETURN (valid_wireframe_vertex_point(pnt\point_replica.parent_pt));
 END_IF ;
 END_IF ;
 RETURN (FALSE);
 END_FUNCTION ;
END_SCHEMA;
 
SCHEMA aic_topologically_bounded_surface;
  
USE FROM geometry_schema ( axis2_placement_2d, axis2_placement_3d, bezier_curve, bezier_surface, b_spline_curve_with_knots, b_spline_surface_with_knots, cartesian_point, circle, composite_curve_on_surface, conical_surface, cylindrical_surface, degenerate_toroidal_surface, direction, ellipse, geometric_representation_context, hyperbola, line, parabola, pcurve, plane, polyline, quasi_uniform_curve, quasi_uniform_surface, rational_b_spline_curve, rational_b_spline_surface, spherical_surface, surface_curve, surface_of_linear_extrusion, surface_of_revolution, swept_surface, toroidal_surface, uniform_curve, uniform_surface, vector);
 USE FROM topology_schema ( edge, edge_curve, edge_loop, face_bound, face_outer_bound, face_surface, oriented_edge, path, vertex_loop, vertex_point);
 USE FROM representation_schema ( definitional_representation, parametric_representation_context);
 USE FROM measure_schema ( parameter_value);
  
ENTITY advanced_face 
 SUBTYPE OF ( face_surface );
 WHERE 
WR1 : 
SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1;
WR2 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;
WR3 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;
WR4 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;
WR5 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;
WR6 : NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
WR7 : 
SIZEOF ( 
QUERY ( vlp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;
WR8 : 
SIZEOF ( 
QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;
WR9 : 
SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( 
QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;
WR10 : (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF ( 
QUERY ( elp_fbnds <* 
QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
 END_ENTITY ;
END_SCHEMA;
 
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA application_context_schema;

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    id_attribute,
    id_attribute_select);
  REFERENCE FROM date_time_schema (
    year_number);
  REFERENCE FROM support_resource_schema (
    identifier, 
    label, 
    text);

  TYPE acs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    application_context);
  END_TYPE;
  
  TYPE acs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    application_context);
  END_TYPE;

  ENTITY application_context;
    application : label;
  DERIVE
    description : text := get_description_value(SELF);
    id : identifier := get_id_value(SELF);
  INVERSE
    context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF(library_context, product_concept_context, product_context, product_definition_context));
    name : label;
    frame_of_reference : application_context;
  END_ENTITY;

  ENTITY application_context_relationship;
    name : label;
    description : OPTIONAL text;
    relating_context : application_context;
    related_context : application_context;
  END_ENTITY;

  ENTITY application_protocol_definition;
    status : label;
    application_interpreted_model_schema_name : label;
    application_protocol_year : year_number;
    application : application_context;
  END_ENTITY;

  ENTITY library_context
    SUBTYPE OF (application_context_element);
    library_reference : label;
  END_ENTITY;

  ENTITY product_concept_context
    SUBTYPE OF (application_context_element);
    market_segment_type : label;
  END_ENTITY;

  ENTITY product_context
    SUBTYPE OF (application_context_element);
    discipline_type : label;
  END_ENTITY;

  ENTITY product_definition_context
    SUBTYPE OF (application_context_element);
    life_cycle_stage : label;
  END_ENTITY;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA approval_schema;
  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_role, 
    object_role, 
    role_association,
    role_select);
  REFERENCE FROM date_time_schema (
    date_time_select);
  REFERENCE FROM person_organization_schema (
    person_organization_select);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    label, 
    text);
    
  TYPE apps_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    approval_role);
  END_TYPE;
  
  TYPE apps_role_select = SELECT BASED_ON role_select WITH (
    approval_date_time);
  END_TYPE;
  
    
  ENTITY approval;
    status : approval_status;
    level : label;
  END_ENTITY;

  ENTITY approval_date_time;
    date_time : date_time_select;
    dated_approval : approval;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_person_organization;
    person_organization : person_organization_select;
    authorized_approval : approval;
    role : approval_role;
  END_ENTITY;

  ENTITY approval_relationship;
    name : label;
    description : OPTIONAL text;
    relating_approval : approval;
    related_approval : approval;
  END_ENTITY;

  ENTITY approval_role;
    role : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY approval_status;
    name : label;
  END_ENTITY;

  FUNCTION acyclic_approval_relationship (relation : approval_relationship; relatives : SET [1:?] OF approval; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF approval_relationship;
    END_LOCAL;

    IF relation.relating_approval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'APPROVAL_SCHEMA.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(* Copied from  TC184/SC4/WG12 N2649 *)


SCHEMA assembly_constraint_schema;

REFERENCE FROM shape_data_quality_inspection_result_schema
    (using_product_definition_of_shape_representation);
REFERENCE FROM assembly_feature_relationship_schema; -- ISO 10303-109
REFERENCE FROM explicit_constraint_schema; -- ISO 10303-108
REFERENCE FROM explicit_geometric_constraint_schema; -- ISO 10303-108
REFERENCE FROM geometry_schema; -- ISO 10303-42
REFERENCE FROM geometric_model_schema; -- ISO 10303-42
REFERENCE FROM parameterization_schema; -- ISO 10303-108
REFERENCE FROM product_definition_schema; -- 10303-41
REFERENCE FROM product_structure_schema; -- ISO 10303-44
REFERENCE FROM representation_schema; -- ISO 10303-43
REFERENCE FROM support_resource_schema; -- 10303-41

    
ENTITY assembly_geometric_constraint
  ABSTRACT SUPERTYPE OF (ONEOF
           (binary_assembly_constraint,
           fixed_constituent_assembly_constraint))
  SUBTYPE OF (explicit_constraint);

END_ENTITY;-- assembly_geometric_constraint

ENTITY binary_assembly_constraint
  ABSTRACT SUPERTYPE OF (ONEOF
           (parallel_assembly_constraint,
            surface_distance_assembly_constraint_with_dimension,
             angle_assembly_constraint_with_dimension,
            perpendicular_assembly_constraint,
            incidence_assembly_constraint,
            coaxial_assembly_constraint,
            tangent_assembly_constraint))
  SUBTYPE OF (assembly_geometric_constraint,
            representation_relationship_with_transformation);
SELF\representation_relationship.rep_1: representative_shape_representation;
SELF\representation_relationship.rep_2: representative_shape_representation;
WHERE
WR1: (SELF\explicit_constraint.constrained_elements[1]
      \geometric_representation_item.dim = 3) AND
     (SELF\explicit_constraint.reference_elements[1]
      \geometric_representation_item.dim = 3);
WR2: (SELF\representation_relationship.rep_1 IN (using_representations 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1))) AND
     (SELF\representation_relationship.rep_2 IN (using_representations 
     (SELF\representation_relationship_with_transformation.
       transformation_operator\item_defined_transformation.transform_item_2) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2)));
WR3: (SIZEOF(SELF\explicit_constraint.constrained_elements)=1) AND
     (SIZEOF(SELF\explicit_constraint.reference_elements)=1);
WR4: (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1 =  
      SELF\explicit_constraint.reference_elements[1]) AND
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2 =  
      SELF\explicit_constraint.constrained_elements[1]);

END_ENTITY;-- binary_assembly_constraint

ENTITY fixed_constituent_assembly_constraint
SUBTYPE OF (assembly_geometric_constraint,
            fixed_element_geometric_constraint);
    fixed_constituent: representative_shape_representation;
WHERE
WR1: SELF\explicit_constraint.constrained_elements[1]
     \geometric_representation_item.dim = 3;
WR2: (assembly_leaf (using_product_definition_of_shape_representation
     (fixed_constituent)[1]));
WR3: (SIZEOF(SELF\explicit_constraint.constrained_elements) = 1) AND
     (SIZEOF(SELF\explicit_constraint.reference_elements) = 0);
WR4: fixed_constituent IN (using_representations(SELF\explicit_constraint.constrained_elements[1]) + 
     using_representation_with_mapping(SELF\explicit_constraint.constrained_elements[1]));
END_ENTITY;-- fixed_constituent_assembly_constraint


ENTITY parallel_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              parallel_geometric_constraint);
END_ENTITY;-- parallel_assembly_constraint

ENTITY  parallel_assembly_constraint_with_dimension
  SUBTYPE OF (parallel_assembly_constraint,
              pgc_with_dimension);
END_ENTITY;-- parallel_assembly_constraint_with_dimension

ENTITY surface_distance_assembly_constraint_with_dimension
  SUBTYPE OF (binary_assembly_constraint,
              sdgc_with_dimension);
END_ENTITY;-- surface_distance_assembly_constraint_with_dimension

ENTITY angle_assembly_constraint_with_dimension
  SUBTYPE OF (binary_assembly_constraint,
              agc_with_dimension);
END_ENTITY;-- angle_assembly_constraint_with_dimension

ENTITY perpendicular_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              perpendicular_geometric_constraint);
END_ENTITY;-- perpendicular_assembly_constraint

ENTITY incidence_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              incidence_geometric_constraint);
END_ENTITY;-- incidence_assembly_constraint

ENTITY coaxial_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              coaxial_geometric_constraint);
END_ENTITY;-- coaxial_assembly_constraint

ENTITY tangent_assembly_constraint
  SUBTYPE OF (binary_assembly_constraint,
              tangent_geometric_constraint);
END_ENTITY;-- tangent_assembly_constraint

FUNCTION assembly_leaf
  (item: product_definition) : BOOLEAN;
LOCAL
  local_relation: SET OF assembly_component_usage := [];
  local_relation2: BAG OF assembly_component_usage := [];
END_LOCAL;
-- extraction of related assembly_component_relationships --
local_relation2 := local_relation2 + QUERY(pdr <* USEDIN (item, 
    'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') |
    'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE' IN
      TYPEOF(pdr));
local_relation := bag_to_set (local_relation2);
IF (SIZEOF (local_relation) = 0) THEN RETURN (TRUE);
  ELSE RETURN (FALSE);
END_IF;
END_FUNCTION;


END_SCHEMA; -- assembly_constraint
(* Copied from  TC184/SC4/WG12 N2649 *)
--2011-10-03 fixed syntax error in using_shape_aspect_of_shape_representation TT
SCHEMA assembly_feature_relationship_schema;

REFERENCE FROM assembly_constraint_schema; -- 10303-109
REFERENCE FROM geometry_schema; -- 10303-41
REFERENCE FROM kinematic_motion_representation_schema; -- 10303-105
REFERENCE FROM kinematic_structure_schema; -- 10303-105
REFERENCE FROM product_definition_schema; -- 10303-41
REFERENCE FROM product_property_definition_schema; -- 10303-41
REFERENCE FROM product_property_representation_schema; -- 10303-41
REFERENCE FROM product_structure_schema; -- 10303-44
REFERENCE FROM representation_schema; -- 10303-43
REFERENCE FROM support_resource_schema; -- 10303-41
REFERENCE FROM shape_data_quality_inspection_result_schema; -- ISO 10303-59

TYPE representing_relationship = SELECT
(binary_assembly_constraint,
constrained_kinematic_motion_representation,
free_kinematic_motion_representation);
END_TYPE;-- representing_relationship

ENTITY shape_aspect_relationship_representation_association;
  represented_shape_aspect_relationship: shape_aspect_relationship;
  representing_representation_relationship : representation_relationship;
WHERE
WR1: ('ASSEMBLY_FEATURE_RELATIONSHIP_SCHEMA.REPRESENTATIVE_SHAPE_REPRESENTATION' IN 
      TYPEOF(representing_representation_relationship\
      representation_relationship.rep_1)) AND
     ('ASSEMBLY_FEATURE_RELATIONSHIP_SCHEMA.REPRESENTATIVE_SHAPE_REPRESENTATION' IN 
      TYPEOF(representing_representation_relationship\
      representation_relationship.rep_2));
WR2: (represented_shape_aspect_relationship.relating_shape_aspect IN 
      using_shape_aspect_of_shape_representation 
      (representing_representation_relationship.rep_1)) AND
     (represented_shape_aspect_relationship.related_shape_aspect IN 
      using_shape_aspect_of_shape_representation 
      (representing_representation_relationship.rep_2));
WR3: ((find_representative_shape_representation_of_product_definition 
     (using_product_definition_of_shape_aspect
     (represented_shape_aspect_relationship.relating_shape_aspect)).
      context_of_items) :=:
     (find_representative_shape_representation_of_shape_aspect 
     (represented_shape_aspect_relationship.relating_shape_aspect).
      context_of_items)) AND
     ((find_representative_shape_representation_of_product_definition 
     (using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect)).
      context_of_items) :=:
     (find_representative_shape_representation_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect).
      context_of_items));
WR4: using_product_definition_of_shape_aspect
     (represented_shape_aspect_relationship.relating_shape_aspect) :<>: 
     using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect);
WR5: find_assembly_root ([using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.relating_shape_aspect)]) :=: 
     find_assembly_root ([using_product_definition_of_shape_aspect 
     (represented_shape_aspect_relationship.related_shape_aspect)]);
END_ENTITY; -- shape_aspect_relationship_representation_association

ENTITY representative_shape_representation
  SUBTYPE OF (shape_representation);
WHERE 
WR1: unique_in_product_definition (SELF) OR unique_in_shape_aspect (SELF);
END_ENTITY; -- representative_shape_representation

ENTITY free_kinematic_motion_representation
  SUBTYPE OF (representation_relationship_with_transformation);
SELF\representation_relationship.rep_1: 
   representative_shape_representation;
SELF\representation_relationship.rep_2: 
   representative_shape_representation;
  motion : kinematic_path;
WHERE
WR1: 'REPRESENTATION_SCHEMA.ITEM_DEFINED_TRANSFORMATION' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator);
WR2: ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1)) AND
     ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2));
WR3: ((dimension_of
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.
      transform_item_1) = 3 ) AND
     (dimension_of 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.
      transform_item_2) = 3 ));
WR4:(SELF\representation_relationship.rep_1 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_1))) AND
     (SELF\representation_relationship.rep_2 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2) +
      using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
      transformation_operator\item_defined_transformation.transform_item_2)));
END_ENTITY; -- free_kinematic_motion_representation

ENTITY constrained_kinematic_motion_representation
  SUBTYPE OF (representation_relationship_with_transformation);
SELF\representation_relationship.rep_1: 
    representative_shape_representation;
SELF\representation_relationship.rep_2: 
    representative_shape_representation;
WHERE
WR1: ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_1)) AND
     ('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_2));
WR2: ((dimension_of
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.
     transform_item_1) = 3 ) AND
     (dimension_of 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.
     transform_item_2) = 3 ));
WR3:(SELF\representation_relationship.rep_1 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_1) +
     using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_1))) AND
     (SELF\representation_relationship.rep_2 IN 
     (using_representations 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_2) +
     using_representation_with_mapping 
     (SELF\representation_relationship_with_transformation.
     transformation_operator\item_defined_transformation.transform_item_2)));
WR4: 'KINEMATIC_STRUCTURE_SCHEMA.KINEMATIC_PAIR' IN TYPEOF
     (SELF\representation_relationship_with_transformation.
      transformation_operator);
END_ENTITY; -- constrained_kinematic_motion_representation

FUNCTION assembly_root
  (item: product_definition) : BOOLEAN;
-- extraction of related assembly_component_relationships --
IF (SIZEOF(QUERY(pdr <* USEDIN (item, 
   'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 
   'RELATED_PRODUCT_DEFINITION') |
    'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE' IN
    TYPEOF(pdr)))
    = 0) THEN RETURN(TRUE);
ELSE RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION find_assembly_root
  (constituent: SET OF product_definition) : SET OF product_definition;
LOCAL
  local_relation: SET OF assembly_component_usage := [];
  local_relation2: BAG OF assembly_component_usage := [];
  local_parent: SET OF product_definition := [];
  root : SET OF product_definition;
  i : INTEGER := 0;
  j : INTEGER := 0;
END_LOCAL;

-- Is constituent root ? --
IF ((SIZEOF (constituent) = 1) AND assembly_root (constituent[1]))
  THEN RETURN ([constituent [1]]);
-- ERROR constituent is vacant --
  ELSE IF (SIZEOF (constituent) = 0 ) THEN RETURN ([]);

-- extraction of related assembly_component_relationships --
    ELSE
      REPEAT j:= 1 TO HIINDEX(constituent);
        local_relation2 := local_relation2 + QUERY(pdr <* USEDIN (constituent[j], 
                    'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' 
                    +'RELATED_PRODUCT_DEFINITION') |
                   'PRODUCT_STRUCTURE_SCHEMA.ASSEMBLY_COMPONENT_USAGE' IN
                   TYPEOF(pdr));
      END_REPEAT;
      local_relation := bag_to_set (local_relation2);
      IF (SIZEOF(local_relation) = 0) THEN
        IF (SIZEOF(constituent) = 1) THEN RETURN ([constituent[1]]);
          ELSE RETURN ([]);
        END_IF;
      ELSE
-- extraction of a set of parents --
        REPEAT i :=1 TO HIINDEX(local_relation);
          REPEAT j := 1 TO HIINDEX(constituent);
          IF (local_relation[i].relating_product_definition <> 
              constituent[j]) THEN
            local_parent := local_parent + 
                            local_relation[i].relating_product_definition;
          END_IF;
          END_REPEAT;
        END_REPEAT;
        IF ((SIZEOF (local_parent) = 1 ) AND 
             assembly_root (local_parent[1])) 
          THEN RETURN ([local_parent[1]]); 
          ELSE IF (SIZEOF (local_parent) = 0) THEN RETURN ([]);
-- try again --
            ELSE 
              root := find_assembly_root(local_parent);
              IF (SIZEOF (root) =1) THEN RETURN (root);
                ELSE IF (SIZEOF (root) = 0) THEN RETURN ([]);
                END_IF;
              END_IF;
          END_IF;
        END_IF;
      END_IF;
  END_IF;
END_IF;
RETURN ([]);
END_FUNCTION;
 
FUNCTION find_shape_representation_of_product_definition
    (item:product_definition) : SET OF shape_representation;
LOCAL
  local_p_d_s: SET OF product_definition_shape := [];
  local_p_d_s2: BAG OF product_definition_shape := [];
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
END_LOCAL;
-- find product_definition_shape representing the product_definiton
  local_p_d_s2 := local_p_d_s2 + QUERY(pd <* USEDIN (item, 
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') |
  'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
    TYPEOF(pd));
  local_p_d_s := bag_to_set(local_p_d_s2);
-- find shape_definition_representations refereing to the local_p_d_s
  REPEAT i := 1 to HIINDEX (local_p_d_s);
    local_s_d_r2 := local_s_d_r2 + QUERY(pdr <* USEDIN (local_p_d_s[i], 
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN
      TYPEOF(pdr)); 
  END_REPEAT;
  local_s_d_r := bag_to_set (local_s_d_r2);
  REPEAT i := 1 to HIINDEX (local_s_d_r);
    IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' 
        IN TYPEOF (local_s_d_r[i].used_representation)) THEN
        local_s_r := local_s_r + local_s_d_r[i].used_representation;
    END_IF;
  END_REPEAT;
  RETURN (local_s_r);
END_FUNCTION;

FUNCTION find_shape_representation_of_shape_aspect
    (item:shape_aspect) : SET OF shape_representation;
LOCAL
  local_p_d: SET OF property_definition:= [];
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
END_LOCAL;
-- find property_definition representing the shape_aspect
  local_p_d := bag_to_set (USEDIN (item, 
   'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
-- find shape_definition_representations refereing to the local_p_d
  REPEAT i := 1 to HIINDEX (local_p_d);
    local_s_d_r2 := local_s_d_r2 + QUERY(pdr <* USEDIN (local_p_d[i], 
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN
      TYPEOF(pdr)); 
  END_REPEAT;
    local_s_d_r := bag_to_set (local_s_d_r2);
  REPEAT i := 1 to HIINDEX (local_s_d_r);
    IF('PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION'
        IN TYPEOF (local_s_d_r[i].used_representation)) THEN
        local_s_r := local_s_r + local_s_d_r[i].used_representation;
    END_IF;
  END_REPEAT;
  RETURN (local_s_r);
END_FUNCTION;
 
FUNCTION find_representative_shape_representation_of_product_definition
    (item:product_definition) : shape_representation;
LOCAL
  local_s_r: SET OF shape_representation := [];
END_LOCAL;
-- find representative_shape_representation of the product_definition
  local_s_r := QUERY 
    ( z <* find_shape_representation_of_product_definition (item)|
      'ASSEMBLY_FEATURE_RELATIONSHIP_SCHEMA.REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
  IF (SIZEOF (local_s_r) = 1) 
    THEN RETURN (local_s_r[1]); 
    ELSE RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION find_representative_shape_representation_of_shape_aspect
    (item:shape_aspect) : shape_representation;
LOCAL
  local_s_r: SET OF shape_representation := [];
END_LOCAL;
-- find representative_shape_representation of the shape_aspect
  local_s_r := QUERY ( z <* find_shape_representation_of_shape_aspect (item)|
               'ASSEMBLY_FEATURE_RELATIONSHIP_SCHEMA.REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF(z));
  IF (SIZEOF (local_s_r) = 1) 
    THEN RETURN (local_s_r[1]); 
    ELSE RETURN(?);
  END_IF;
END_FUNCTION;

FUNCTION unique_in_product_definition
    (item:representative_shape_representation) : BOOLEAN;
LOCAL
  local_p_d: SET OF product_definition := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find product_definitions represented by the input 
-- representative_shape_representation
  local_p_d := using_product_definition_of_shape_representation (item);
-- ERROR
  IF (SIZEOF (local_p_d) <> 1) THEN RETURN (FALSE);
    ELSE
-- find shape_representation representing the product_definitions
    REPEAT i := 1 to HIINDEX (local_p_d);
      local_s_r := find_shape_representation_of_product_definition 
                   (local_p_d[i]);
      REPEAT j := 1 to HIINDEX (local_s_r);
        IF (('ASSEMBLY_FEATURE_RELATIONSHIP_SCHEMA.REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF (local_s_r[j])) 
             AND (local_s_r[j] :<>: item)) THEN RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION unique_in_shape_aspect
    (item:representative_shape_representation) : BOOLEAN;
LOCAL
  local_s_a: SET OF shape_aspect := [];
  local_s_r: SET OF shape_representation := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find shape_aspects represented by the input 
-- representative_shape_representation
  local_s_a := using_shape_aspect_of_shape_representation (item);
-- ERROR
  IF (SIZEOF (local_s_a) <> 1) THEN RETURN (FALSE);
    ELSE
-- find shape_representation representing the shape_aspect
    REPEAT i := 1 to HIINDEX (local_s_a);
      local_s_r := find_shape_representation_of_shape_aspect 
                   (local_s_a[i]);
      REPEAT j := 1 to HIINDEX (local_s_r);
        IF (('ASSEMBLY_FEATURE_RELATIONSHIP_SCHEMA.REPRESENTATIVE_SHAPE_REPRESENTATION' IN TYPEOF (local_s_r[j])) 
           AND (local_s_r[j] :<>: item)) THEN RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION using_product_definition_of_shape_aspect
    (item:shape_aspect) : product_definition ;
  IF ('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF 
    (item.of_shape.definition)) THEN
    RETURN (item.of_shape.definition);
  ELSE
    RETURN (?);    
  END_IF;
END_FUNCTION;

FUNCTION using_shape_aspect_of_shape_representation
    (item: shape_representation) : SET OF shape_aspect;
LOCAL
  local_s_d_r: SET OF shape_definition_representation := [];
  local_s_d_r2: BAG OF shape_definition_representation := [];
  local_s_a: SET OF shape_aspect := [];
  i : INTEGER;
END_LOCAL;
-- find shape_definition_representations 
  local_s_d_r2  := local_s_d_r2 + QUERY(pdr <* USEDIN (item, 
  'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
  'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN
      TYPEOF(pdr)); 
  local_s_d_r := bag_to_set (local_s_d_r2);
-- find shape_aspects
REPEAT i := 1 TO HIINDEX (local_s_d_r);
   IF ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' IN TYPEOF 
      (local_s_d_r[i]\property_definition_representation.definition\property_definition.definition))
   THEN local_s_a := local_s_a + local_s_d_r[i]\property_definition_representation.definition\property_definition.definition;
   END_IF;
END_REPEAT;
RETURN (local_s_a);
END_FUNCTION;

FUNCTION using_representation_with_mapping (item : representation_item)
         : SET OF representation;
LOCAL 
  results: SET OF representation := [];
  local_results : SET OF representation := [];
  local_representation_map : SET OF representation_map := [];
  intermediate_items : SET OF representation_item := [];
  i : INTEGER;
  j : INTEGER;
END_LOCAL;
-- find the representations in which the item is used
-- and which is referenced from the representation_map
   local_results := QUERY (z <* using_representations (item)|
           SIZEOF (USEDIN (z, 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.' +
                              'MAPPED_REPRESENTATION')) > 0 );
  IF (SIZEOF (local_results) = 0) THEN RETURN ([]);
  ELSE 
-- find the set of representation_map in which the local_results are used
  REPEAT i := 1 TO HIINDEX(local_results);
  local_representation_map := local_representation_map +
      bag_to_set (USEDIN (local_results[i], 
                 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
  END_REPEAT;
-- find the set of mapped_item
  REPEAT i := 1 TO HIINDEX(local_representation_map);
  intermediate_items := intermediate_items + 
          bag_to_set (USEDIN (local_representation_map[i], 
                 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
  END_REPEAT;
-- repeat same manner
  REPEAT j := 1 to HIINDEX(intermediate_items);
        results := results + bag_to_set (using_representation_with_mapping 
                             (intermediate_items[j]));
    END_REPEAT;
  END_IF;
  RETURN (results);
END_FUNCTION; 

END_SCHEMA;  -- assembly_feature_relationship_schema 
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA basic_attribute_schema;

  REFERENCE FROM support_resource_schema (identifier, label, text);
 
  TYPE description_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE id_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE name_attribute_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;
-- property_definition_representati
 
  TYPE role_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  ENTITY description_attribute;
    attribute_value : text;
    described_item : description_attribute_select;
  END_ENTITY;

  ENTITY id_attribute;
    attribute_value : identifier;
    identified_item : id_attribute_select;
  END_ENTITY;

  ENTITY name_attribute;
    attribute_value : label;
    named_item : name_attribute_select;
  END_ENTITY;

  ENTITY object_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY role_association;
    role : object_role;
    item_with_role : role_select;
  END_ENTITY;

  FUNCTION get_description_value (obj : description_attribute_select):text;
    LOCAL
      description_bag : BAG OF description_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
    END_LOCAL;

    IF SIZEOF(description_bag) = 1 THEN
      RETURN (description_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_id_value (obj : id_attribute_select):identifier;
    LOCAL
      id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
    END_LOCAL;

    IF SIZEOF(id_bag) = 1 THEN
      RETURN (id_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_name_value (obj : name_attribute_select):label;
    LOCAL
      name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
    END_LOCAL;

    IF SIZEOF(name_bag) = 1 THEN
      RETURN (name_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

  FUNCTION get_role (obj : role_select):object_role;
    LOCAL
      role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
    END_LOCAL;

    IF SIZEOF(role_bag) = 1 THEN
      RETURN (role_bag[1].role);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION;

END_SCHEMA;
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)



SCHEMA certification_schema;
  REFERENCE FROM support_resource_schema (label, text);
  ENTITY certification;
    name : label;
    purpose : text;
    kind : certification_type;
  END_ENTITY;

  ENTITY certification_type;
    description : label;
  END_ENTITY;

END_SCHEMA;
(* 
$Id: concatenated_mim.exp,v 1.8 2012/09/13 21:21:24 thomasrthurman Exp $
ISO TC184/SC4/WG12 N3213 - ISO/IS 10303-54 Classification and set theory - EXPRESS
Supersedes ISO TC184/SC4/WG12 N1510
*) 


SCHEMA classification_schema;

REFERENCE FROM group_schema   -- ISO 10303-41
  (group); 

REFERENCE FROM management_resources_schema   -- ISO 10303-41
  (classification_assignment); 


TYPE classification_select = EXTENSIBLE SELECT;
END_TYPE; 

TYPE complete_membership_select = EXTENSIBLE SELECT;
END_TYPE; 

ENTITY class
  SUBTYPE OF (group);
END_ENTITY;

ENTITY class_by_extension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY class_by_intension
  SUBTYPE OF (class);
END_ENTITY;

ENTITY classification
  SUBTYPE OF (classification_assignment);
  classified : classification_select;
DERIVE
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership
  SUBTYPE OF (classification_assignment);
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;

ENTITY complete_membership_of_empty_set
  SUBTYPE OF (complete_membership);
END_ENTITY;

ENTITY complete_membership_of_non_empty_set
  SUBTYPE OF (complete_membership);
  members : SET[1:?] OF complete_membership_select;
END_ENTITY;

SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
  ONEOF (classification,
         complete_membership);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;  -- classification_schema
(*
$Id: concatenated_mim.exp,v 1.8 2012/09/13 21:21:24 thomasrthurman Exp $
ISO TC184/SC4/WG12 N7xxx - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA configuration_management_schema;

  REFERENCE FROM effectivity_schema (
    effectivity);
   
  REFERENCE FROM product_definition_schema
    (product_definition,
     product_definition_formation,
     product_definition_effectivity);

  REFERENCE FROM product_structure_schema
    (product_definition_usage);

  REFERENCE FROM product_concept_schema
    (product_concept,
     product_concept_feature_association);

  REFERENCE FROM basic_attribute_schema
    (get_description_value,
     description_attribute_select,
     get_name_value,
     name_attribute_select);

  REFERENCE FROM support_resource_schema
    (text, label, identifier, bag_to_set);
    
  TYPE cms_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    configuration_design);
  END_TYPE;
  TYPE cms_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    configuration_design);
  END_TYPE;

TYPE configuration_design_item = SELECT
   (product_definition,
    product_definition_formation);
END_TYPE;

ENTITY configurable_item
  SUBTYPE OF (configuration_item);
  item_concept_feature : SET[1:?] OF product_concept_feature_association;
END_ENTITY;

ENTITY configuration_design;
  configuration : configuration_item;
  design        : configuration_design_item;
DERIVE
  name          : label := get_name_value (SELF);
  description   : text := get_description_value (SELF);
UNIQUE
  UR1: configuration, design;
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY configuration_effectivity
  SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  UR1: configuration,
       SELF\product_definition_effectivity.usage,
       SELF\effectivity.id;
WHERE
  WR1: 'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF (SELF\product_definition_effectivity.usage);
END_ENTITY;

ENTITY configuration_item;
   id                  :  identifier;
   name                :  label;
   description         :  OPTIONAL text;
   item_concept        :  product_concept;
   purpose             :  OPTIONAL label;
END_ENTITY;

ENTITY configuration_item_relationship;
  name                        : label;
  description                 : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item  : configuration_item;
END_ENTITY;

END_SCHEMA; -- configuration_management_schema
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)


SCHEMA contract_schema;
  REFERENCE FROM support_resource_schema (bag_to_set, identifier, label, text);
  ENTITY contract;
    name : label;
    purpose : text;
    kind : contract_type;
  END_ENTITY;

  ENTITY contract_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_contract : contract;
    related_contract : contract;
  END_ENTITY;

  ENTITY contract_type;
    description : label;
  END_ENTITY;

  FUNCTION acyclic_contract_relationship (relation : contract_relationship; relatives : SET [1:?] OF contract; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF contract_relationship;
    END_LOCAL;

    IF relation.relating_contract IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'CONTRACT_SCHEMA.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA date_time_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (description_attribute,
   description_attribute_select,
   get_description_value); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (time_measure_with_unit); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   identifier,
   label,
   text); 

  TYPE dts_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    date_role,
    date_time_role,
    time_role);
  END_TYPE;

TYPE ahead_or_behind = ENUMERATION OF 
   (ahead,
    exact,
    behind);
END_TYPE; 

TYPE date_time_or_event_occurrence = SELECT
   (date_time_select, 
    event_occurrence);
END_TYPE; 

TYPE date_time_select = SELECT
   (date, 
    date_and_time, 
    local_time);
END_TYPE; 

TYPE day_in_month_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 31};
END_TYPE; 

TYPE day_in_week_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 7 };
END_TYPE; 

TYPE day_in_year_number = INTEGER;
WHERE
  WR1: {1 <= SELF <= 366};
END_TYPE; 

TYPE hour_in_day = INTEGER;
WHERE
  WR1: { 0 <= SELF < 24 };
END_TYPE; 

TYPE minute_in_hour = INTEGER;
WHERE
  WR1: { 0 <= SELF <= 59 };
END_TYPE; 

TYPE month_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 12 };
END_TYPE; 

TYPE second_in_minute = REAL;
WHERE
  WR1: { 0 <= SELF <= 60.0 };
END_TYPE; 

TYPE week_in_year_number = INTEGER;
WHERE
  WR1: { 1 <= SELF <= 53 };
END_TYPE; 

TYPE year_number = INTEGER;
END_TYPE; 

ENTITY calendar_date
  SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  WR1: valid_calendar_date (SELF);
END_ENTITY;

ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
  WR1: { 0 <= hour_offset < 24 };
  WR2: { 0 <= actual_minute_offset <= 59 };
  WR3: NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
END_ENTITY;

ENTITY date
  SUPERTYPE OF (ONEOF (calendar_date,
                       ordinal_date,
                       week_of_year_and_day_date,
                       year_month));
  year_component : year_number;
END_ENTITY;

ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;

ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;

ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  WR1: valid_time (SELF);
END_ENTITY;

ENTITY ordinal_date
  SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  WR1: (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
END_ENTITY;

ENTITY relative_event_occurrence
  SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;

ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;

ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY time_interval_with_bounds
  SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  WR2: EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;

ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value (SELF);
WHERE
  WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
END_ENTITY;

ENTITY week_of_year_and_day_date
  SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component : OPTIONAL day_in_week_number;
END_ENTITY;

ENTITY year_month 
  SUBTYPE OF (date);
  month_component : month_in_year_number;
END_ENTITY;

FUNCTION acyclic_event_occurrence_relationship
 (relation : event_occurrence_relationship; relatives : SET[1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN; 
 LOCAL
      x : SET OF event_occurrence_relationship;
    END_LOCAL;

    IF relation.relating_event IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'DATE_TIME_SCHEMA.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION acyclic_time_interval_relationship
 (relation : time_interval_relationship; relatives : SET[1:?] OF time_interval; specific_relation : STRING) : BOOLEAN; 
  LOCAL
      x : SET OF time_interval_relationship;
    END_LOCAL;

    IF relation.relating_time_interval IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'DATE_TIME_SCHEMA.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
END_FUNCTION; 

FUNCTION leap_year
 (year : year_number) : BOOLEAN; 
  IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION; 

FUNCTION valid_calendar_date
 (date : calendar_date) : LOGICAL; 
  CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });
    2  : BEGIN
           IF (leap_year(date.year_component)) THEN
             RETURN({ 1 <= date.day_component <= 29 });
           ELSE
             RETURN({ 1 <= date.day_component <= 28 });
           END_IF;
         END;
    3  : RETURN({ 1 <= date.day_component <= 31 });
    4  : RETURN({ 1 <= date.day_component <= 30 });
    5  : RETURN({ 1 <= date.day_component <= 31 });
    6  : RETURN({ 1 <= date.day_component <= 30 });
    7  : RETURN({ 1 <= date.day_component <= 31 });
    8  : RETURN({ 1 <= date.day_component <= 31 });
    9  : RETURN({ 1 <= date.day_component <= 30 });
    10 : RETURN({ 1 <= date.day_component <= 31 });
    11 : RETURN({ 1 <= date.day_component <= 30 });
    12 : RETURN({ 1 <= date.day_component <= 31 });
  END_CASE;
  RETURN (FALSE);
END_FUNCTION; 

FUNCTION valid_time
 (time : local_time) : BOOLEAN; 
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION; 

END_SCHEMA;
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)


SCHEMA document_schema;
  REFERENCE FROM product_definition_schema (product, product_definition, product_definition_formation);
  REFERENCE FROM support_resource_schema (bag_to_set, identifier, label, text);
  TYPE product_or_formation_or_definition = SELECT (product, product_definition_formation, product_definition);
  END_TYPE;

  ENTITY document;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    kind : document_type;
  INVERSE
    representation_types : SET [0:?] OF document_representation_type FOR represented_document;
  END_ENTITY;

  ENTITY document_product_association;
    name : label;
    description : OPTIONAL text;
    relating_document : document;
    related_product : product_or_formation_or_definition;
  END_ENTITY;

  ENTITY document_relationship;
    name : label;
    description : OPTIONAL text;
    relating_document : document;
    related_document : document;
  END_ENTITY;

  ENTITY document_representation_type;
    name : label;
    represented_document : document;
  END_ENTITY;

  ENTITY document_type;
    product_data_type : label;
  END_ENTITY;

  ENTITY document_usage_constraint;
    source : document;
    subject_element : label;
    subject_element_value : text;
  END_ENTITY;

  ENTITY document_with_class
    SUBTYPE OF (document);
    class : identifier;
  END_ENTITY;

  FUNCTION acyclic_document_relationship (relation : document_relationship; relatives : SET [1:?] OF document; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF document_relationship;
    END_LOCAL;

    IF relation.relating_document IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'DOCUMENT_SCHEMA.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6153 - ISO/IS 10303-101 Draughting - EXPRESS
Supersedes ISO TC184/SC4/WG12 N4832
*)

SCHEMA draughting_dimension_schema;

REFERENCE FROM draughting_element_schema
    (dimension_curve,
     leader_curve,
     projection_curve,
     draughting_callout,
     draughting_callout_relationship,
     dimension_curve_directed_callout,
     leader_directed_callout,
     projection_directed_callout,
     dimension_extent_usage);

ENTITY dimension_callout
  SUBTYPE OF (draughting_callout);
WHERE
  WR1: ('DRAUGHTING_ELEMENT_SCHEMA.LEADER_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('DRAUGHTING_ELEMENT_SCHEMA.LEADER_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
  WR2: ('DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
  WR3:
('DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE_DIRECTED_CALLOUT'
        IN (TYPEOF (SELF))) XOR
       (SIZEOF (QUERY(dce_1 <* SELF\draughting_callout.contents |
       ('DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE'
        IN (TYPEOF(dce_1))))) = 0);
END_ENTITY;

ENTITY dimension_graph
  SUBTYPE OF (dimension_curve_directed_callout);
WHERE
  WR1: SIZEOF(USEDIN(SELF,'DRAUGHTING_DIMENSION_SCHEMA.'+
       'DIMENSION_GRAPH_PROJECTION_CURVE_USAGE.GRAPH')) <= 2;
  WR2: SIZEOF(QUERY(dce <* SELF\draughting_callout.contents |
       'DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_CURVE'
       IN (TYPEOF(dce)))) = 0;
  WR3: 'DRAUGHTING_DIMENSION_SCHEMA.DIMENSION_CALLOUT' 
       IN (TYPEOF(SELF));
END_ENTITY;

ENTITY dimension_graph_projection_curve_usage;
  graph           : dimension_graph;
  projection_line : projection_curve;
  role            : dimension_extent_usage;
UNIQUE
  UR1: graph, projection_line;
  UR2: graph, role;
END_ENTITY;

ENTITY dimension_graph_sequence
  SUBTYPE OF (draughting_callout_relationship);
WHERE
  WR1: 'DRAUGHTING_DIMENSION_SCHEMA.DIMENSION_GRAPH' IN
       TYPEOF (SELF\draughting_callout_relationship.
                    relating_draughting_callout);
  WR2: 'DRAUGHTING_DIMENSION_SCHEMA.DIMENSION_GRAPH' IN
       TYPEOF (SELF\draughting_callout_relationship.
                    related_draughting_callout);
END_ENTITY;

END_SCHEMA; -- draughting_dimension_schema
(*
ISO TC184/SC4/WG12 N6153 - ISO/IS 10303-101 Draughting - EXPRESS
Supersedes ISO TC184/SC4/WG12 N4832
*)
(* This file updated to implement proposal for SEDS #1288  *)

SCHEMA draughting_element_schema;

REFERENCE FROM geometry_schema
    (plane,
     geometric_representation_item);
     
REFERENCE FROM geometric_model_schema(tessellated_geometric_set);     
     
REFERENCE FROM support_resource_schema
    (label,
     text);

REFERENCE FROM presentation_definition_schema
    (annotation_occurrence,
     annotation_curve_occurrence,
     annotation_fill_area_occurrence, 
     annotation_point_occurrence, 
     annotation_text_occurrence, 
     annotation_symbol_occurrence);
     
REFERENCE FROM presentation_appearance_schema
    (invisible_item,
    presentation_style_assignment,
    styled_item);

REFERENCE FROM presentation_resource_schema
    (planar_box);

  TYPE annotation_plane_element = SELECT 
    (draughting_callout, 
     styled_item); 
  END_TYPE;

  TYPE draughting_callout_element = SELECT
    (annotation_curve_occurrence,
     annotation_fill_area_occurrence,
     annotation_symbol_occurrence,
     annotation_text_occurrence,
     tessellated_annotation_occurrence);
  END_TYPE;

  TYPE dimension_extent_usage = ENUMERATION OF
    (origin,
     target);
  END_TYPE;

  TYPE des_invisible_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON invisible_item WITH
    (draughting_callout);
  END_TYPE;

  TYPE plane_or_planar_box = SELECT 
    (plane, 
     planar_box) ;
  END_TYPE; 
   
  ENTITY annotation_plane 
    SUBTYPE OF (annotation_occurrence, geometric_representation_item);
      elements : OPTIONAL SET[1:?] OF annotation_plane_element;
      SELF\styled_item.item : plane_or_planar_box;
    WHERE
      WR1: SELF\geometric_representation_item.dim = 3;
      WR2: NOT('PRESENTATION_RESOURCE_SCHEMA.'+'PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) OR
        ('GEOMETRY_SCHEMA.'+'AXIS2_PLACEMENT_3D' IN TYPEOF(SELF\styled_item.item\planar_box.placement));
      WR3: (('PRESENTATION_RESOURCE_SCHEMA.'+'PLANAR_BOX' IN TYPEOF(SELF\styled_item.item)) AND
        ('PRESENTATION_APPEARANCE_SCHEMA.'+'CURVE_STYLE' IN TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1]))) OR
        (('GEOMETRY_SCHEMA.'+'PLANE' IN TYPEOF(SELF\styled_item.item)) AND
        ('PRESENTATION_APPEARANCE_SCHEMA.'+'FILL_AREA_STYLE' IN TYPEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles[1])));
      WR4: (SIZEOF(SELF\styled_item.styles) = 1) AND
        (SIZEOF(SELF\styled_item.styles[1]\presentation_style_assignment.styles) = 1);
  END_ENTITY;

  ENTITY dimension_curve
    SUBTYPE OF (annotation_curve_occurrence);
    WHERE
      WR1: (SIZEOF(
          QUERY(dct <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.' +
                'TERMINATOR_SYMBOL.ANNOTATED_CURVE')
               | (('DRAUGHTING_ELEMENT_SCHEMA.'+
                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct))
                  ))
          ) <= 2);
      WR2:  SIZEOF(
            QUERY( dcdc <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.' +
                   'DRAUGHTING_CALLOUT.CONTENTS') |
                   ('DRAUGHTING_ELEMENT_SCHEMA.'+
                    'DIMENSION_CURVE_DIRECTED_CALLOUT' IN TYPEOF(dcdc)))
          )>= 1;
     WR3: (SIZEOF(
            QUERY(dct1 <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.' +
                  'TERMINATOR_SYMBOL.ANNOTATED_CURVE') 
               | (('DRAUGHTING_ELEMENT_SCHEMA.'+
                  'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct1)) 
                  AND (dct1\dimension_curve_terminator.role = dimension_extent_usage.origin)))
          ) <= 1)
        AND 
        (SIZEOF(
            QUERY (dct2 <* USEDIN(SELF,'DRAUGHTING_ELEMENT_SCHEMA.'+
                   'TERMINATOR_SYMBOL.ANNOTATED_CURVE') 
                 | (('DRAUGHTING_ELEMENT_SCHEMA.'+
                   'DIMENSION_CURVE_TERMINATOR' IN TYPEOF(dct2))
                   AND (dct2\dimension_curve_terminator.role = dimension_extent_usage.target)))
         ) <= 1);
  END_ENTITY;

  ENTITY leader_curve
    SUBTYPE OF (annotation_curve_occurrence);
    WHERE
      WR1: SIZEOF( 
          QUERY(ldc <* USEDIN( SELF, 'DRAUGHTING_ELEMENT_SCHEMA.' +
                       'DRAUGHTING_CALLOUT.CONTENTS')
                   |   'DRAUGHTING_ELEMENT_SCHEMA.' +
                       'LEADER_DIRECTED_CALLOUT'  IN TYPEOF(ldc))) >= 1;
  END_ENTITY;

  ENTITY projection_curve
    SUBTYPE OF (annotation_curve_occurrence);
  END_ENTITY;

  ENTITY terminator_symbol
    SUBTYPE OF (annotation_symbol_occurrence);
      annotated_curve : annotation_curve_occurrence;
  END_ENTITY;

  ENTITY dimension_curve_terminator
    SUBTYPE OF (terminator_symbol);
      role  : dimension_extent_usage;
    WHERE
      WR1: 'DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE' IN TYPEOF
        (SELF\terminator_symbol.annotated_curve);
  END_ENTITY;

  ENTITY leader_terminator
    SUBTYPE OF (terminator_symbol);
    WHERE
      WR1: 'DRAUGHTING_ELEMENT_SCHEMA.LEADER_CURVE' IN TYPEOF
        (SELF\terminator_symbol.annotated_curve);
  END_ENTITY;

  ENTITY draughting_callout
    SUBTYPE OF (geometric_representation_item);
      contents : SET [1:?] OF draughting_callout_element; 
    WHERE
      WR1: (SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'DRAUGHTING_ELEMENT_SCHEMA.LEADER_CURVE' IN (TYPEOF(l_1)))) = 0) OR
        ('DRAUGHTING_ELEMENT_SCHEMA.LEADER_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND
        (SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_CURVE' IN (TYPEOF(l_1)))) = 0) OR
        ('DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_DIRECTED_CALLOUT' IN (TYPEOF(SELF))) AND  
        (SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE' IN (TYPEOF(l_1)))) = 0) OR
        ('DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE_DIRECTED_CALLOUT' IN (TYPEOF(SELF)));
  END_ENTITY;

  ENTITY draughting_callout_relationship;
    name : label;
    description : text;
    relating_draughting_callout : draughting_callout;
    related_draughting_callout : draughting_callout;
  END_ENTITY;

  ENTITY leader_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      WR1: SIZEOF (QUERY (l_1 <* SELF\draughting_callout.contents |
        'DRAUGHTING_ELEMENT_SCHEMA.LEADER_CURVE' IN (TYPEOF(l_1)))) >= 1;
      WR2: SIZEOF(SELF\draughting_callout.contents) >=2;
  END_ENTITY;

  ENTITY projection_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      WR1: SIZEOF(QUERY(p_1<*SELF\draughting_callout.contents | 
        'DRAUGHTING_ELEMENT_SCHEMA.PROJECTION_CURVE' IN (TYPEOF(p_1))))<=2;
      WR2: SIZEOF(SELF\draughting_callout.contents) >=2;
  END_ENTITY;

  ENTITY dimension_curve_directed_callout
    SUBTYPE OF (draughting_callout);
    WHERE
      WR1: SIZEOF(QUERY(d_c<*SELF\draughting_callout.contents | 
        'DRAUGHTING_ELEMENT_SCHEMA.DIMENSION_CURVE' IN (TYPEOF(d_c))))<=2;
      WR2: SIZEOF(SELF\draughting_callout.contents) >= 2;
  END_ENTITY;
  
  ENTITY tessellated_annotation_occurrence
    SUBTYPE OF (annotation_occurrence);
    SELF\styled_item.item : tessellated_geometric_set; 
  END_ENTITY;   

  SUBTYPE_CONSTRAINT annotation_curve_subtypes FOR annotation_curve_occurrence;
    (ONEOF(dimension_curve,
    leader_curve,
    projection_curve));
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT annotation_occurrence_subtypes FOR annotation_occurrence;
  ONEOF (annotation_curve_occurrence,
         annotation_fill_area_occurrence,
         annotation_plane,
         annotation_point_occurrence,
         annotation_symbol_occurrence,
         annotation_text_occurrence,
         tessellated_annotation_occurrence);
  END_SUBTYPE_CONSTRAINT;

END_SCHEMA; 
(*
ISO TC184/SC4/WG12 N6153 - ISO/IS 10303-101 Draughting - EXPRESS
Supersedes ISO TC184/SC4/WG12 N4832
*)

SCHEMA drawing_definition_schema;

REFERENCE FROM support_resource_schema
    (label,
     text,
     identifier,
     bag_to_set);

REFERENCE FROM representation_schema
    (mapped_item,
     representation_relationship,
     representation);

REFERENCE FROM presentation_organization_schema
    (area_in_set,
     presentation_area,
     presentation_set,
     presentation_representation_relationship);

TYPE draughting_titled_item = SELECT 
  (drawing_revision,
   drawing_sheet_revision);
END_TYPE;

ENTITY drawing_definition;
  drawing_number : identifier;
  drawing_type   : OPTIONAL label;
END_ENTITY;

ENTITY drawing_revision
  SUBTYPE OF (presentation_set);
  revision_identifier : identifier;
  drawing_identifier  : drawing_definition;
  intended_scale      : OPTIONAL text;
UNIQUE
  UR1: revision_identifier, drawing_identifier;
END_ENTITY;

ENTITY drawing_revision_sequence;
  predecessor : drawing_revision;
  successor   : drawing_revision;
WHERE
  WR1: predecessor :<>: successor;
END_ENTITY;

ENTITY drawing_sheet_revision
  SUBTYPE OF (presentation_area);
  revision_identifier : identifier;
WHERE
  WR1: SIZEOF( QUERY(item <* SELF\representation.items |
       ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN (TYPEOF(item)))
       AND
       ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION' IN
       (TYPEOF(item\mapped_item.mapping_source.mapped_representation)))))=0;
END_ENTITY;

ENTITY drawing_sheet_revision_sequence
  SUBTYPE OF (representation_relationship);
WHERE
  WR1: SELF\representation_relationship.rep_1 :<>:                            
       SELF\representation_relationship.rep_2;
  WR2: 'DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION'
       IN TYPEOF (SELF\representation_relationship.rep_1);
  WR3: 'DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION'
       IN TYPEOF (SELF\representation_relationship.rep_2);
END_ENTITY;

ENTITY drawing_sheet_revision_usage
  SUBTYPE OF (area_in_set);
  sheet_number : identifier;
UNIQUE
  UR1: sheet_number, SELF\area_in_set.in_set;
WHERE
  WR1: ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION' IN 
                  TYPEOF(SELF\area_in_set.area)) 
              AND
              ('DRAWING_DEFINITION_SCHEMA.DRAWING_REVISION' 
               IN TYPEOF (SELF\area_in_set.in_set));
END_ENTITY;

ENTITY draughting_title;
  items    : SET [1:?] OF draughting_titled_item;
  language : label;
  contents : text;
END_ENTITY;

RULE drawing_sheets_not_nested FOR (presentation_representation_relationship);
WHERE
  WR1: SIZEOF( QUERY(p_r_r <* presentation_representation_relationship |      
         ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION' 
        IN (TYPEOF(p_r_r.rep_1))) AND
        ('DRAWING_DEFINITION_SCHEMA.DRAWING_SHEET_REVISION'
        IN (TYPEOF( p_r_r.rep_2))))) = 0;
END_RULE;

END_SCHEMA; -- drawing_definition_schema
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA effectivity_schema;

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_name_value, 
    name_attribute,
    name_attribute_select);
  REFERENCE FROM date_time_schema (
    date_time_or_event_occurrence, 
    time_interval);
  REFERENCE FROM measure_schema (
    measure_with_unit);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
    
  TYPE effs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    effectivity);
  END_TYPE;

  TYPE effs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    effectivity);
  END_TYPE;
    
  ENTITY dated_effectivity
    SUBTYPE OF (effectivity);
    effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
    effectivity_start_date : OPTIONAL date_time_or_event_occurrence;
  WHERE
    WR1: EXISTS(effectivity_end_date) OR EXISTS(effectivity_start_date);
  END_ENTITY;

  ENTITY effectivity
    SUPERTYPE OF (ONEOF(serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity));
    id : identifier;
  DERIVE
    name : label := get_name_value(SELF);
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY effectivity_relationship;
    name : label;
    description : OPTIONAL text;
    related_effectivity : effectivity;
    relating_effectivity : effectivity;
  END_ENTITY;

  ENTITY lot_effectivity
    SUBTYPE OF (effectivity);
    effectivity_lot_id : identifier;
    effectivity_lot_size : measure_with_unit;
  END_ENTITY;

  ENTITY serial_numbered_effectivity
    SUBTYPE OF (effectivity);
    effectivity_start_id : identifier;
    effectivity_end_id : OPTIONAL identifier;
  END_ENTITY;

  ENTITY time_interval_based_effectivity
    SUBTYPE OF (effectivity);
    effectivity_period : time_interval;
  END_ENTITY;

  FUNCTION acyclic_effectivity_relationship (relation : effectivity_relationship; relatives : SET [1:?] OF effectivity; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF effectivity_relationship;
    END_LOCAL;

    IF relation.relating_effectivity IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'EFFECTIVITY_SCHEMA.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)

SCHEMA experience_schema;
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY experience;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_experience : experience;
    related_experience : experience;
  END_ENTITY;

  ENTITY experience_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_experience_type : experience_type;
    related_experience_type : experience_type;
  END_ENTITY;

  FUNCTION acyclic_experience_relationship (relation : experience_relationship; relatives : SET OF experience; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_relationship;
    END_LOCAL;

    IF relation.relating_experience IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_experience_type_relationship (relation : experience_type_relationship; relatives : SET OF experience_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF experience_type_relationship;
    END_LOCAL;

    IF relation.relating_experience_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N4852 - ISO 10303-108 paramaterization_schema - EXPRESS
THIS IS DOCUMENT I CONTAINING REVISED EXPRESS FOR 'PARAMETERIZATION AND CONSTRAINTS FOR EXPLICIT GEOMETRIC  
PRODUCT MODELS' TO TAKE INTO ACCOUNT TC1 FOR THAT DOCUMENT -- 2008-03-17  *)                                          


SCHEMA explicit_constraint_schema;

REFERENCE FROM support_resource_schema             -- ISO 10303-41
  (text);

REFERENCE FROM representation_schema               -- ISO 10303-43
  (item_in_context,
   representation_item,
   using_representations);

REFERENCE FROM mathematical_functions_schema       -- ISO 10303-50
  (compatible_spaces,
   maths_variable,
   values_space_of);

REFERENCE FROM parameterization_schema             -- ISO 10303-108
  (bound_variational_parameter,
   variational_parameter,
   unbound_variational_parameter);

REFERENCE FROM variational_representation_schema   -- ISO 10303-108
  (variational_representation_item);

REFERENCE FROM iso13584_generic_expressions_schema -- ISO 13584-20
  (used_variables);

REFERENCE FROM iso13584_expressions_schema         -- ISO 13584-20
  (boolean_expression,
   expression);

TYPE constraint_group_member = SELECT
  (explicit_constraint,
   simultaneous_constraint_group);
END_TYPE;

ENTITY explicit_constraint
  ABSTRACT SUPERTYPE OF (ONEOF(defined_constraint,
                               free_form_constraint))
  SUBTYPE OF (variational_representation_item); 
  description : OPTIONAL text;
  constrained_elements : SET[1:?] OF representation_item;
  reference_elements   : SET[0:?] OF representation_item;
WHERE
  WR1: SIZEOF(constrained_elements * reference_elements) = 0;
END_ENTITY;

ENTITY defined_constraint 
  ABSTRACT SUPERTYPE OF (equal_parameter_constraint)
  SUBTYPE OF (explicit_constraint);
END_ENTITY; 

ENTITY equal_parameter_constraint
  SUBTYPE OF (defined_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF variational_parameter;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF variational_parameter;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.constrained_elements +
    SELF\explicit_constraint.reference_elements) >= 2;
END_ENTITY;

ENTITY free_form_constraint 
  ABSTRACT SUPERTYPE OF (ONEOF(free_form_assignment, free_form_relation))
  SUBTYPE OF (explicit_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF variational_parameter;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:?] OF variational_parameter;
  constraining_expression : expression;
END_ENTITY; 

ENTITY free_form_assignment 
  SUBTYPE OF (free_form_constraint);
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\free_form_constraint.constrained_elements | 
    q IN used_variables
    (SELF\free_form_constraint.constraining_expression))) = 0; 
  WR2: SIZEOF(QUERY(q <* SELF\free_form_constraint.reference_elements | 
    NOT (q IN used_variables(
    SELF\free_form_constraint.constraining_expression)))) = 0; 
  WR3: SIZEOF(SELF\free_form_constraint.reference_elements) >= 1;
  WR4: SIZEOF(QUERY(q <* SELF\free_form_constraint.constrained_elements |
    NOT (compatible_spaces(values_space_of(
    SELF\free_form_constraint.constraining_expression),
    q\maths_variable.values_space)))) = 0;
END_ENTITY; 

ENTITY free_form_relation 
  SUBTYPE OF (free_form_constraint);
WHERE 
  WR1: 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' IN TYPEOF
    (SELF\free_form_constraint.constraining_expression); 
  WR2: SIZEOF(QUERY(q <* (SELF\free_form_constraint.constrained_elements + 
    SELF\free_form_constraint.reference_elements) | 
    NOT (q IN used_variables
    (SELF\free_form_constraint.constraining_expression)))) = 0; 
END_ENTITY; 

ENTITY simultaneous_constraint_group
  SUBTYPE OF (variational_representation_item);
  constraint_group : SET[2:?] OF constraint_group_member;
WHERE
  WR1: SIZEOF(QUERY(q <* using_representations(SELF) |
    SIZEOF(QUERY(r <* q.items | 
    ('EXPLICIT_CONSTRAINT_SCHEMA.SIMULTANEOUS_CONSTRAINT_GROUP'
    IN TYPEOF(r)) AND (SIZEOF(QUERY(s <* constraint_group | 
    (s IN r\simultaneous_constraint_group.constraint_group) AND NOT (r :=: SELF))) > 0))) > 0)) = 0;
  WR2: SIZEOF(QUERY(q <* using_representations(constraint_group[1]) | 
    (SIZEOF(QUERY(r <* constraint_group | 
    item_in_context(r,q.context_of_items)))
    = SIZEOF(constraint_group)))) > 0;
  WR3: SIZEOF(QUERY(q <* constraint_group |
    (('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(q)) 
    AND (SIZEOF(QUERY(r <* q.constrained_elements |
    SIZEOF(QUERY(s <* constraint_group | 
    r IN s.reference_elements)) > 0)) > 0)))) = 0;
END_ENTITY;

END_SCHEMA; -- explicit_constraint_schema
(* THIS IS DOCUMENT ISO TC184/SC4/WG12 N4852, CONTAINING REVISED EXPRESS FOR *)
(* ISO 10303-108, 'PARAMETERIZATION AND CONSTRAINTS FOR EXPLICIT GEOMETRIC   *)
(* PRODUCT MODELS' TO TAKE INTO ACCOUNT TC1 FOR THAT DOCUMENT -- 2007-09-30  *)                                          


SCHEMA explicit_geometric_constraint_schema;

REFERENCE FROM measure_schema             -- ISO 10303-41
  (length_measure,
   non_negative_length_measure,
   plane_angle_measure,
   positive_length_measure);

REFERENCE FROM geometry_schema;           -- ISO 10303-42

REFERENCE FROM geometric_model_schema     -- ISO 10303-42
  (extruded_area_solid,
   extruded_face_solid,
   revolved_area_solid,
   revolved_face_solid,
   right_circular_cone,
   right_circular_cylinder,
   sphere,
   swept_area_solid,
   swept_face_solid,
   torus);

REFERENCE FROM representation_schema      -- ISO 10303-43
  (representation_item_relationship);

REFERENCE FROM explicit_constraint_schema -- ISO 10303-108
  (defined_constraint,
   explicit_constraint);

TYPE geometric_constraint_element = SELECT
  (point,
   curve,
   surface,
   vector,
   direction);
END_TYPE;

TYPE point_curve_or_surface_constraint_element = SELECT
  (point,
   curve,
   surface);
END_TYPE;

TYPE curve_or_surface_constraint_element = SELECT
  (curve,
   surface);
END_TYPE;

TYPE linear_geometry_constraint_element = SELECT
  (line,
   plane,
   direction,
   vector);
END_TYPE;

TYPE radial_geometry_constraint_element = SELECT
  (circle,
   cylindrical_surface,
   conical_surface,
   spherical_surface,
   right_circular_cylinder,
   right_circular_cone,
   sphere);
END_TYPE;

TYPE axial_geometry_constraint_element = SELECT
  (point,
   line,
   circle,
   plane,
   cylindrical_surface,
   conical_surface,
   spherical_surface,
   toroidal_surface,
   surface_of_revolution,
   sphere,
   right_circular_cone,
   right_circular_cylinder,
   torus,
   revolved_face_solid,
   revolved_area_solid);
END_TYPE;

TYPE swept_surface_or_solid = SELECT
  (swept_surface,
   swept_face_solid,
   swept_area_solid);
END_TYPE;

TYPE tangent_contact_type = ENUMERATION OF
  (point_contact,
   curve_contact,
   surface_contact);
END_TYPE;

TYPE parallel_offset_type = ENUMERATION OF
  (curve_2d_offset,
   curve_3d_offset,
   surface_offset);
END_TYPE;

ENTITY explicit_geometric_constraint
  ABSTRACT SUPERTYPE OF (ONEOF
    (fixed_element_geometric_constraint,
     parallel_geometric_constraint,
     point_distance_geometric_constraint,
     skew_line_distance_geometric_constraint,
     curve_distance_geometric_constraint,
     surface_distance_geometric_constraint,
     radius_geometric_constraint,
     curve_length_geometric_constraint,
     parallel_offset_geometric_constraint,
     angle_geometric_constraint,
     perpendicular_geometric_constraint,
     incidence_geometric_constraint,
     coaxial_geometric_constraint,
     tangent_geometric_constraint,
     symmetry_geometric_constraint,
     swept_point_curve_geometric_constraint,
     swept_curve_surface_geometric_constraint,
     curve_smoothness_geometric_constraint,
     surface_smoothness_geometric_constraint))
  SUBTYPE OF (defined_constraint, geometric_representation_item);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF geometric_representation_item;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:?] OF geometric_representation_item;
END_ENTITY;

ENTITY fixed_element_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF geometric_constraint_element;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY; 

ENTITY parallel_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF linear_geometry_constraint_element; 
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF linear_geometry_constraint_element;
END_ENTITY; 

ENTITY pgc_with_dimension
  SUBTYPE OF (parallel_geometric_constraint);
  distance_value : non_negative_length_measure;
  negative_direction : BOOLEAN;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) = 1)
    OR (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: SIZEOF(QUERY(q <* (SELF\explicit_constraint.reference_elements +
    SELF\explicit_constraint.constrained_elements) | SIZEOF(TYPEOF(q) *
    ['GEOMETRY_SCHEMA.DIRECTION', 'GEOMETRY_SCHEMA.VECTOR']) > 0)) = 0;
END_ENTITY; 

ENTITY point_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:?] OF point;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:4] OF point_curve_or_surface_constraint_element;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.PDGC_WITH_DIMENSION' 
    IN TYPEOF(SELF)) AND 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
END_ENTITY;

ENTITY pdgc_with_dimension
  SUBTYPE OF (point_distance_geometric_constraint);
  distance_value : non_negative_length_measure;
END_ENTITY;

ENTITY skew_line_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:2] OF line;
  SELF\explicit_constraint.reference_elements   : SET[0:1] OF line;
  distance_value : non_negative_length_measure;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.constrained_elements +
    SELF\explicit_constraint.reference_elements) = 2;
END_ENTITY;

ENTITY near_point_relationship
  SUBTYPE OF (representation_item_relationship);
  SELF\representation_item_relationship.relating_representation_item :
    curve_or_surface_constraint_element;
  SELF\representation_item_relationship.related_representation_item : 
    point;
END_ENTITY;

ENTITY curve_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:2] OF curve;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:4] OF point_curve_or_surface_constraint_element;
  near_points : SET[0:4] OF near_point_relationship;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.CDGC_WITH_DIMENSION'
    IN TYPEOF(SELF)) 
    AND (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
  WR2: SIZEOF(near_points) <= 
    SIZEOF(SELF\explicit_constraint.reference_elements);
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY cdgc_with_dimension
  SUBTYPE OF (curve_distance_geometric_constraint);
  distance_value : non_negative_length_measure;
END_ENTITY;

ENTITY surface_distance_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:2] OF surface;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:4] OF point_curve_or_surface_constraint_element;
  near_points : SET[0:4] OF near_point_relationship;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR 
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.SDGC_WITH_DIMENSION' 
    IN TYPEOF(SELF)) 
    AND (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
  WR2: SIZEOF(near_points) <= 
    SIZEOF(SELF\explicit_constraint.reference_elements);
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY sdgc_with_dimension
  SUBTYPE OF (surface_distance_geometric_constraint);
  distance_value : non_negative_length_measure;
END_ENTITY;

ENTITY radius_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF radial_geometry_constraint_element;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

ENTITY rgc_with_dimension
  SUBTYPE OF (radius_geometric_constraint);
  radius_value : positive_length_measure;
END_ENTITY;

ENTITY curve_length_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF bounded_curve;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

ENTITY clgc_with_dimension
  SUBTYPE OF (curve_length_geometric_constraint);
  length_value : positive_length_measure;
END_ENTITY;

ENTITY parallel_offset_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF curve_or_surface_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF curve_or_surface_constraint_element;
  offset_type : parallel_offset_type;   
WHERE
  WR1: NOT(((offset_type = curve_2d_offset) 
    OR (offset_type = curve_3d_offset)) AND 
    (SIZEOF(QUERY( q <* (SELF\explicit_constraint.constrained_elements 
    + SELF\explicit_constraint.reference_elements) |
    'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(q))) > 0));
  WR2: NOT((offset_type = surface_offset) AND (SIZEOF(QUERY( q <* 
    (SELF\explicit_constraint.constrained_elements +
    SELF\explicit_constraint.reference_elements) | 
    'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(q))) > 0));
END_ENTITY;

ENTITY pogc_with_dimension 
  SUBTYPE OF (parallel_offset_geometric_constraint); 
  offset_value : positive_length_measure; 
  offset_direction_constrained : BOOLEAN; 
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) = 1)
    OR (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: (NOT (offset_direction_constrained = TRUE)
    AND ((offset_type = curve_2d_offset) 
    OR (offset_type = surface_offset))); 
END_ENTITY; 

ENTITY angle_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF linear_geometry_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF linear_geometry_constraint_element;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) = 1) OR
    (('EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.AGC_WITH_DIMENSION' 
    IN TYPEOF(SELF)) AND 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2));
END_ENTITY;

ENTITY agc_with_dimension
  SUBTYPE OF (angle_geometric_constraint);
  angle_value : plane_angle_measure;
END_ENTITY;

ENTITY perpendicular_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF linear_geometry_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:2] OF linear_geometry_constraint_element;
WHERE   
  WR1: NOT ((SIZEOF(SELF\explicit_constraint.reference_elements) = 2) AND 
    NOT ((SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements + 
    SELF\explicit_constraint.reference_elements | 
    'GEOMETRY_SCHEMA.LINE' IN TYPEOF(q))) =
    SIZEOF(SELF\explicit_constraint.reference_elements + 
    SELF\explicit_constraint.constrained_elements)) XOR 
    (SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements + 
    SELF\explicit_constraint.reference_elements | 
    'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(q))) =
    SIZEOF(SELF\explicit_constraint.reference_elements + 
    SELF\explicit_constraint.constrained_elements))));
  WR2: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR
    (SIZEOF(SELF\explicit_constraint.constrained_elements) IN [2,3]);
  WR3: NOT ((SIZEOF(SELF\explicit_constraint.reference_elements) = 0) AND 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 3)) AND NOT  
    ((SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements | 
    'GEOMETRY_SCHEMA.LINE' IN TYPEOF(q))) = 3) XOR
    (SIZEOF(QUERY(q <* SELF\explicit_constraint.constrained_elements | 
    'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(q))) = 3));
END_ENTITY; 

ENTITY incidence_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF geometric_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET [0:?] OF geometric_constraint_element;
  near_points : SET[0:?] OF near_point_relationship;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0)
    OR (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: SIZEOF(near_points) <= 
    SIZEOF(SELF\explicit_constraint.reference_elements); 
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY coaxial_geometric_constraint 
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF axial_geometry_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:1] OF axial_geometry_constraint_element;
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\explicit_constraint.reference_elements | 
    SIZEOF(TYPEOF(q) * ['GEOMETRY_SCHEMA.POINT','GEOMETRY_SCHEMA.PLANE',
    'GEOMETRY_SCHEMA.SPHERICAL_SURFACE','GEOMETRY_SCHEMA.SPHERE']) 
    > 0)) = 0;
END_ENTITY; 

ENTITY tangent_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:?] OF curve_or_surface_constraint_element;
  SELF\explicit_constraint.reference_elements   : 
    SET[0:?] OF curve_or_surface_constraint_element;
  near_points         : SET[0:?] OF near_point_relationship;
  tangent_contact     : tangent_contact_type;
WHERE
  WR1: (SIZEOF(SELF\explicit_constraint.reference_elements) > 0) OR 
    (SIZEOF(SELF\explicit_constraint.constrained_elements) = 2);
  WR2: NOT ((SELF\geometric_representation_item.dim = 2)
    AND (tangent_contact = surface_contact));
  WR3: SIZEOF(QUERY(q <* near_points | NOT
    (q\representation_item_relationship.relating_representation_item
    IN SELF\explicit_constraint.reference_elements))) = 0;
END_ENTITY;

ENTITY symmetry_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[2:2] OF geometric_representation_item;
  mirror_element : linear_geometry_constraint_element;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
  WR2: SIZEOF(TYPEOF(mirror_element) * 
    ['GEOMETRY_SCHEMA.DIRECTION','GEOMETRY_SCHEMA.VECTOR']) = 0;
  WR3: NOT ((SELF\geometric_representation_item.dim = 2) AND 
    ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(mirror_element)));
END_ENTITY;

ENTITY swept_point_curve_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:?] OF curve;
  SELF\explicit_constraint.reference_elements   : 
    SET[1:1] OF swept_face_solid;
END_ENTITY;

ENTITY swept_curve_surface_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : SET[1:?] OF surface;
  SELF\explicit_constraint.reference_elements   : 
    SET[1:1] OF swept_surface_or_solid;
END_ENTITY;

ENTITY curve_segment_set
  SUBTYPE OF (geometric_representation_item);
  segments : SET[1:?] OF composite_curve_segment;
END_ENTITY;

ENTITY curve_smoothness_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET[1:1] OF curve_segment_set;
  smoothness : transition_code;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

ENTITY surface_patch_set
  SUBTYPE OF (geometric_representation_item);
  patches : SET[1:?] OF surface_patch;
END_ENTITY;

ENTITY surface_smoothness_geometric_constraint
  SUBTYPE OF (explicit_geometric_constraint);
  SELF\explicit_constraint.constrained_elements : 
    SET [1:1] OF surface_patch_set;
  u_smoothness : transition_code;
  v_smoothness : transition_code;
WHERE
  WR1: SIZEOF(SELF\explicit_constraint.reference_elements) = 0;
END_ENTITY;

END_SCHEMA; -- explicit_geometric_constraint_schema

(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA external_reference_schema;

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value);
  REFERENCE FROM support_resource_schema (
    label, 
    text, 
    identifier, 
    bag_to_set);
    
  TYPE ers_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    external_source);
  END_TYPE;
    
  TYPE message = STRING;
  END_TYPE;

  TYPE source_item = SELECT (identifier, message);
  END_TYPE;

  ENTITY external_source;
    source_id : source_item;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY external_source_relationship;
    name : label;
    description : OPTIONAL text;
    relating_source : external_source;
    related_source : external_source;
  END_ENTITY;

  ENTITY externally_defined_item;
    item_id : source_item;
    source : external_source;
  END_ENTITY;

  ENTITY externally_defined_item_relationship;
    name : label;
    description : OPTIONAL text;
    relating_item : externally_defined_item;
    related_item : externally_defined_item;
  END_ENTITY;
  
  ENTITY externally_defined_item_with_multiple_references
    SUBTYPE OF (externally_defined_item);
    references : LIST[1:?] OF UNIQUE source_item;
  UNIQUE
    UR1: references;
  WHERE
    WR1: NOT(SELF\externally_defined_item.item_id IN references);
  END_ENTITY;  

  ENTITY pre_defined_item;
    name : label;
  END_ENTITY;

  FUNCTION acyclic_external_source_relationship (relation : external_source_relationship; relatives : SET [1:?] OF external_source; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF external_source_relationship;
    END_LOCAL;

    IF relation.relating_source IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_externally_defined_item_relationship (relation : externally_defined_item_relationship; relatives : SET [1:?] OF externally_defined_item; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF externally_defined_item_relationship;
    END_LOCAL;

    IF relation.relating_item IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7627 - ISO/DIS 10303-42 Geometric and topological representation - EXPRESS
*) 


SCHEMA geometric_model_schema;

REFERENCE FROM geometry_schema;    -- ISO 10303-42

REFERENCE FROM topology_schema;    -- ISO 10303-42

REFERENCE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (founded_item,
   representation,
   representation_item,
   using_representations); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 


TYPE boolean_operand = SELECT
   (boolean_result, 
    csg_primitive, 
    half_space_2d, 
    half_space_solid, 
    solid_model);
END_TYPE; 

TYPE boolean_operator = ENUMERATION OF 
   (union,
    intersection,
    difference);
END_TYPE; 

TYPE bounded_primitive_2d = EXTENSIBLE GENERIC_ENTITY SELECT
   (area_with_outer_boundary, 
    circular_area, 
    elliptic_area, 
    polygonal_area, 
    rectangular_area);
END_TYPE; 

TYPE csg_primitive = SELECT
   (block, 
    bounded_primitive_2d, 
    cyclide_segment_solid, 
    eccentric_cone, 
    ellipsoid, 
    faceted_primitive, 
    rectangular_pyramid, 
    right_angular_wedge, 
    right_circular_cone, 
    right_circular_cylinder, 
    sphere, 
    torus);
END_TYPE; 

TYPE csg_select = SELECT
   (boolean_result, 
    csg_primitive);
END_TYPE; 

TYPE edge_or_curve = SELECT
   (curve, 
    edge);
END_TYPE; 

TYPE face_or_surface = SELECT
   (face, 
    surface);
END_TYPE; 

TYPE geometric_set_select = SELECT
   (curve, 
    point, 
    surface);
END_TYPE; 

TYPE path_or_composite_curve = SELECT
   (composite_curve, 
    path);
END_TYPE; 

TYPE surface_model = SELECT
   (face_based_surface_model, 
    shell_based_surface_model);
END_TYPE; 

TYPE tessellated_edge_or_vertex = SELECT
   (tessellated_edge, 
    tessellated_vertex);
END_TYPE; 

TYPE wireframe_model = SELECT
   (edge_based_wireframe_model, 
    shell_based_wireframe_model);
END_TYPE; 

ENTITY solid_model
  SUPERTYPE OF (ONEOF (csg_solid,
                       manifold_solid_brep,
                       swept_face_solid,
                       swept_area_solid,
                       swept_disk_solid,
                       solid_replica,
                       brep_2d,
                       trimmed_volume))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY manifold_solid_brep
  SUBTYPE OF (solid_model);
  outer : closed_shell;
END_ENTITY;

ENTITY brep_with_voids
  SUBTYPE OF (manifold_solid_brep);
  voids : SET[1:?] OF oriented_closed_shell;
END_ENTITY;

ENTITY faceted_brep
  SUBTYPE OF (manifold_solid_brep);
END_ENTITY;

ENTITY brep_2d
  SUBTYPE OF (solid_model);
  extent : face;
WHERE
  WR1: SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE', 'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] * TYPEOF (SELF.extent)) = 0;
  WR2: SIZEOF (QUERY (bnds <* extent.bounds | NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) ) = 0;
  WR3: SIZEOF (QUERY (bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
  WR4: SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) | NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list | NOT (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND (oe.edge_element\geometric_representation_item.dim = 2)))) = 0))) = 0;
END_ENTITY;

ENTITY csg_solid
  SUBTYPE OF (solid_model);
  tree_root_expression : csg_select;
END_ENTITY;

ENTITY boolean_result
  SUBTYPE OF (geometric_representation_item);
  operator : boolean_operator;
  first_operand : boolean_operand;
  second_operand : boolean_operand;
END_ENTITY;

ENTITY block
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;

ENTITY right_angular_wedge
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

ENTITY rectangular_pyramid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY faceted_primitive
  SUPERTYPE OF (ONEOF (tetrahedron,
                       convex_hexahedron))
  SUBTYPE OF (geometric_representation_item);
  points : LIST[4:?] OF UNIQUE cartesian_point;
WHERE
  WR1: points[1].dim = 3;
END_ENTITY;

ENTITY tetrahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 4;
  WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
END_ENTITY;

ENTITY convex_hexahedron
  SUBTYPE OF (faceted_primitive);
WHERE
  WR1: SIZEOF(points) = 8;
  WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR8: same_side([points[1], points[2], points[3]], [points[5], points[6], points[7], points[8]]);
  WR9: same_side([points[1], points[4], points[8]], [points[3], points[7], points[6], points[2]]);
  WR10: same_side([points[1], points[2], points[5]], [points[3], points[7], points[8], points[4]]);
  WR11: same_side([points[5], points[6], points[7]], [points[1], points[2], points[3], points[4]]);
  WR12: same_side([points[3], points[7], points[6]], [points[1], points[4], points[8], points[5]]);
  WR13: same_side([points[3], points[7], points[8]], [points[1], points[5], points[6], points[2]]);
END_ENTITY;

ENTITY sphere
  SUBTYPE OF (geometric_representation_item);
  radius : positive_length_measure;
  centre : point;
END_ENTITY;

ENTITY right_circular_cone
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

ENTITY right_circular_cylinder
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : positive_length_measure;
END_ENTITY;

ENTITY eccentric_cone
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY torus
  SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: major_radius > minor_radius;
END_ENTITY;

ENTITY ellipsoid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY cyclide_segment_solid
  SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  radius1 : positive_length_measure;
  radius2 : positive_length_measure;
  cone_angle1 : plane_angle_measure;
  cone_angle2 : plane_angle_measure;
  turn_angle : plane_angle_measure;
END_ENTITY;

ENTITY half_space_solid
  SUBTYPE OF (geometric_representation_item);
  base_surface : surface;
  agreement_flag : BOOLEAN;
END_ENTITY;

ENTITY boxed_half_space
  SUBTYPE OF (half_space_solid);
  enclosure : box_domain;
END_ENTITY;

ENTITY box_domain
  SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  zlength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF,'')| NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE' IN TYPEOF(item)))) = 0;
END_ENTITY;

ENTITY primitive_2d
  SUPERTYPE OF (ONEOF (circular_area,
                       elliptic_area,
                       rectangular_area,
                       polygonal_area,
                       half_space_2d))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY circular_area
  SUBTYPE OF (primitive_2d);
  centre : cartesian_point;
  radius : positive_length_measure;
END_ENTITY;

ENTITY elliptic_area
  SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY rectangular_area
  SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  x : positive_length_measure;
  y : positive_length_measure;
END_ENTITY;

ENTITY polygonal_area
  SUBTYPE OF (primitive_2d);
  bounds : LIST[3:?] OF UNIQUE cartesian_point;
END_ENTITY;

ENTITY area_with_outer_boundary
  SUBTYPE OF (half_space_2d);
  SELF\half_space_2d.base_curve : composite_curve;
WHERE
  WR1: base_curve\composite_curve.closed_curve = TRUE;
END_ENTITY;

ENTITY half_space_2d
  SUBTYPE OF (primitive_2d);
  base_curve : curve;
  agreement_flag : BOOLEAN;
END_ENTITY;

ENTITY rectangled_half_space
  SUBTYPE OF (half_space_2d);
  enclosure : rectangle_domain;
END_ENTITY;

ENTITY rectangle_domain
  SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
WHERE
  WR1: SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT ('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
END_ENTITY;

ENTITY swept_face_solid
  SUPERTYPE OF (ONEOF (extruded_face_solid,
                       revolved_face_solid,
                       surface_curve_swept_face_solid))
  SUBTYPE OF (solid_model);
  swept_face : face_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY;

ENTITY extruded_face_solid
  SUBTYPE OF (swept_face_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  WR1: dot_product( (SELF\swept_face_solid.swept_face.face_geometry\ elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;

ENTITY revolved_face_solid
  SUBTYPE OF (swept_face_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY;

ENTITY surface_curve_swept_face_solid
  SUBTYPE OF (swept_face_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY swept_area_solid
  SUPERTYPE OF (ONEOF (revolved_area_solid,
                       extruded_area_solid,
                       surface_curve_swept_area_solid))
  SUBTYPE OF (solid_model);
  swept_area : curve_bounded_surface;
WHERE
  WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY;

ENTITY extruded_area_solid
  SUBTYPE OF (swept_area_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  WR1: dot_product( (SELF\swept_area_solid.swept_area.basis_surface\ elementary_surface.position.p[3]), extruded_direction) <> 0.0;
END_ENTITY;

ENTITY revolved_area_solid
  SUBTYPE OF (swept_area_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY;

ENTITY surface_curve_swept_area_solid
  SUBTYPE OF (swept_area_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY swept_disk_solid
  SUBTYPE OF (solid_model);
  directrix : curve;
  radius : positive_length_measure;
  inner_radius : OPTIONAL positive_length_measure;
  start_param : REAL;
  end_param : REAL;
WHERE
  WR1: directrix.dim = 3;
  WR2: (NOT EXISTS(inner_radius)) OR (radius > inner_radius);
END_ENTITY;

ENTITY trimmed_volume
  SUBTYPE OF (solid_model);
  basis_volume : volume;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  w1 : parameter_value;
  w2 : parameter_value;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: w1 <> w2;
END_ENTITY;

ENTITY solid_replica
  SUBTYPE OF (solid_model);
  parent_solid : solid_model;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_solid_replica(SELF, parent_solid);
  WR2: parent_solid\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY shell_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  sbsm_boundary : SET[1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY;

ENTITY face_based_surface_model
  SUBTYPE OF (geometric_representation_item);
  fbsm_faces : SET[1:?] OF connected_face_set;
END_ENTITY;

ENTITY shell_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  sbwm_boundary : SET[1:?] OF shell;
WHERE
  WR1: constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY;

ENTITY edge_based_wireframe_model
  SUBTYPE OF (geometric_representation_item);
  ebwm_boundary : SET[1:?] OF connected_edge_set;
END_ENTITY;

ENTITY geometric_set
  SUPERTYPE OF (ONEOF (geometric_curve_set,
                       geometric_set_replica))
  SUBTYPE OF (geometric_representation_item);
  elements : SET[1:?] OF geometric_set_select;
END_ENTITY;

ENTITY geometric_curve_set
  SUBTYPE OF (geometric_set);
WHERE
  WR1: SIZEOF(QUERY(temp <* SELF\geometric_set.elements | 'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp))) = 0;
END_ENTITY;

ENTITY sectioned_spine
  SUBTYPE OF (geometric_curve_set);
  cross_sections : LIST[2:?] OF curve;
  spine_points : LIST[2:?] OF point;
WHERE
  WR1: SIZEOF(SELF\geometric_set.elements) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF\geometric_set.elements[1]);
  WR3: SIZEOF(cross_sections) = SIZEOF(spine_points);
  WR4: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY geometric_set_replica
  SUBTYPE OF (geometric_set);
  parent_set : geometric_set;
  transformation : cartesian_transformation_operator;
DERIVE
  SELF\geometric_set.elements : SET[1:?] OF geometric_set_select := build_transformed_set(transformation, parent_set);
WHERE
  WR1: acyclic_set_replica(SELF, parent_set);
END_ENTITY;

ENTITY tessellated_shape_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET[1:?] OF tessellated_item;
WHERE
  WR1: 'REPRESENTATION_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(SELF\representation.context_of_items);
END_ENTITY;

ENTITY tessellated_item
  ABSTRACT SUPERTYPE OF (ONEOF (coordinates_list,
                                tessellated_solid,
                                tessellated_shell,
                                tessellated_wire,
                                tessellated_geometric_set,
                                tessellated_curve_set,
                                tessellated_point_set,
                                tessellated_surface_set,
                                tessellated_structured_item))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) | NOT ('GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHAPE_REPRESENTATION' IN TYPEOF(using_rep)))) = 0;
END_ENTITY;

ENTITY repositioned_tessellated_item
  SUBTYPE OF (tessellated_item);
  location : axis2_placement_3d;
WHERE
  WR1: NOT (SIZEOF (['GEOMETRIC_MODEL_SCHEMA.TESSELLATED_CURVE_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_GEOMETRIC_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_POINT_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SURFACE_SET', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SHELL', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_SOLID', 'GEOMETRIC_MODEL_SCHEMA.TESSELLATED_WIRE'] * TYPEOF(SELF)) = 0);
END_ENTITY;

ENTITY tessellated_structured_item
  SUPERTYPE OF (ONEOF (tessellated_face,
                       tessellated_edge,
                       tessellated_vertex))
  SUBTYPE OF (tessellated_item);
END_ENTITY;

ENTITY coordinates_list
  SUBTYPE OF (tessellated_item);
  npoints : INTEGER;
  position_coords : LIST[1:?] OF LIST[3:3] OF REAL;
WHERE
  WR1: npoints = SIZEOF(position_coords);
  WR2: SIZEOF (['GEOMETRIC_MODEL_SCHEMA.REPOSITIONED_TESSELLATED_ITEM'] * TYPEOF(SELF)) = 0;
END_ENTITY;

ENTITY tessellated_vertex
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  topological_link : OPTIONAL vertex_point;
  point_index : INTEGER;
END_ENTITY;

ENTITY tessellated_edge
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  geometric_link : OPTIONAL edge_or_curve;
  line_strip : LIST[2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_connecting_edge
  SUBTYPE OF (tessellated_edge);
  smooth : LOGICAL;
  face1 : tessellated_face;
  face2 : tessellated_face;
  line_strip_face1 : LIST[2:?] OF INTEGER;
  line_strip_face2 : LIST[2:?] OF INTEGER;
WHERE
  WR1: SIZEOF(line_strip_face1) = SIZEOF(line_strip_face2);
  WR2: SIZEOF(line_strip_face1) = SIZEOF(SELF\tessellated_edge.line_strip);
END_ENTITY;

ENTITY tessellated_face
  ABSTRACT SUPERTYPE OF (ONEOF (triangulated_face,
                                complex_triangulated_face))
  SUBTYPE OF (tessellated_structured_item);
  coordinates : coordinates_list;
  pnmax : INTEGER;
  normals : LIST[0:?] OF LIST[3:3] OF REAL;
  geometric_link : OPTIONAL face_or_surface;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex : LIST[0:?] OF INTEGER;
  triangles : LIST[1:?] OF LIST[3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY complex_triangulated_face
  SUBTYPE OF (tessellated_face);
  pnindex : LIST[0:?] OF INTEGER;
  triangle_strips : LIST[0:?] OF LIST[3:?] OF INTEGER;
  triangle_fans : LIST[0:?] OF LIST[3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_face.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_face.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY tessellated_solid
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_structured_item;
  geometric_link : OPTIONAL manifold_solid_brep;
END_ENTITY;

ENTITY tessellated_shell
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_structured_item;
  topological_link : OPTIONAL connected_face_set;
END_ENTITY;

ENTITY tessellated_wire
  SUBTYPE OF (tessellated_item);
  items : SET[1:?] OF tessellated_edge_or_vertex;
  geometric_model_link : OPTIONAL path_or_composite_curve;
END_ENTITY;

ENTITY tessellated_surface_set
  ABSTRACT SUPERTYPE OF (ONEOF (triangulated_surface_set,
                                complex_triangulated_surface_set))
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  pnmax : INTEGER;
  normals : LIST[0:?] OF LIST[3:3] OF REAL;
WHERE
  WR1: ((SIZEOF(normals) = 0) OR (SIZEOF(normals) = 1) OR (SIZEOF(normals) = pnmax));
END_ENTITY;

ENTITY triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex : LIST[0:?] OF INTEGER;
  triangles : LIST[1:?] OF LIST[3:3] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
END_ENTITY;

ENTITY complex_triangulated_surface_set
  SUBTYPE OF (tessellated_surface_set);
  pnindex : LIST[0:?] OF INTEGER;
  triangle_strips : LIST[0:?] OF LIST[3:?] OF INTEGER;
  triangle_fans : LIST[0:?] OF LIST[3:?] OF INTEGER;
WHERE
  WR1: ((SIZEOF(pnindex) = 0) OR (SIZEOF(pnindex) = SELF\tessellated_surface_set.pnmax));
  WR2: NOT((SIZEOF(pnindex) = 0) AND (SELF\tessellated_surface_set.pnmax <> coordinates.npoints));
  WR3: NOT ((SIZEOF(triangle_strips) = 0) AND (SIZEOF(triangle_fans) = 0));
END_ENTITY;

ENTITY tessellated_curve_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  line_strips : LIST[1:?] OF LIST[2:?] OF INTEGER;
END_ENTITY;

ENTITY tessellated_geometric_set
  SUBTYPE OF (tessellated_item);
  children : SET[1:?] OF tessellated_item;
END_ENTITY;

ENTITY tessellated_point_set
  SUBTYPE OF (tessellated_item);
  coordinates : coordinates_list;
  point_list : LIST[1:?] OF INTEGER;
END_ENTITY;

FUNCTION acyclic_set_replica
 (rep : geometric_set_replica; parent : geometric_set) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
        THEN  RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type geometric_set_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same geometric_set_replica,
     otherwise, call function again with the parents own parent_set.  *)
    ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));
    END_IF;END_FUNCTION; 

FUNCTION acyclic_solid_replica
 (rep : solid_replica; parent : solid_model) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type solid_replica. *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same solid_replica, otherwise,
   call function again with the parents own parent_solid.     *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));
    END_IF;END_FUNCTION; 

FUNCTION build_transformed_set
 (tr : cartesian_transformation_operator; gset : geometric_set) : SET[0:?] OF geometric_set_select; 
LOCAL
   s          : SET [1:?] OF geometric_set_select := gset.elements;
   trset      : SET [0:?] OF geometric_set_select := [];
  END_LOCAL;
  REPEAT j := 1 TO SIZEOF(s);
    IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j])) THEN
     trset := trset + dummy_gri || curve() ||curve_replica(s[j],tr); ELSE
     IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j])) THEN
       trset := trset + dummy_gri || point() || point_replica(s[j],tr);
       ELSE
       IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j])) THEN
         trset := trset + dummy_gri || surface()  || surface_replica(s[j],
           tr || cartesian_transformation_operator_3d (?));
       END_IF;
     END_IF;
    END_IF;
  END_REPEAT;
  RETURN(trset);END_FUNCTION; 

FUNCTION constraints_geometry_shell_based_surface_model
 (m : shell_based_surface_model) : BOOLEAN; 
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION constraints_geometry_shell_based_wireframe_model
 (m : shell_based_wireframe_model) : BOOLEAN; 
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
     IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j])) AND
        (NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;
       RETURN(result);
       (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION msb_shells
 (brep : manifold_solid_brep) : SET[1:?] OF closed_shell; 
LOCAL   
      return_set: SET[1:?] OF closed_shell := [brep.outer];   
    END_LOCAL;   

    IF SIZEOF(QUERY(msbtype <* TYPEOF(brep) |   
                 msbtype LIKE '*BREP_WITH_VOIDS'))  >= 1    
          THEN   
       return_set := return_set + brep\brep_with_voids.voids;   
    END_IF;   
   RETURN(return_set);END_FUNCTION; 

END_SCHEMA;  -- geometric_model_schema



(*
ISO TC184/SC4/WG12 N7627 - ISO/DIS 10303-42 Geometric and topological representation - EXPRESS
*) 


SCHEMA geometry_schema;

REFERENCE FROM representation_schema   -- ISO 10303-43
  (definitional_representation,
   founded_item,
   functionally_defined_transformation,
   item_in_context,
   representation,
   representation_context,
   representation_item,
   using_representations); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (global_unit_assigned_context,
   length_measure,
   parameter_value,
   plane_angle_measure,
   plane_angle_unit,
   positive_length_measure,
   positive_plane_angle_measure); 

REFERENCE FROM topology_schema   -- ISO 10303-42
  (edge_curve,
   face_surface,
   poly_loop,
   vertex_point); 

REFERENCE FROM geometric_model_schema   -- ISO 10303-42
  (block,
   boolean_result,
   cyclide_segment_solid,
   eccentric_cone,
   edge_based_wireframe_model,
   ellipsoid,
   face_based_surface_model,
   faceted_primitive,
   geometric_set,
   half_space_solid,
   primitive_2d,
   rectangular_pyramid,
   right_angular_wedge,
   right_circular_cone,
   right_circular_cylinder,
   shell_based_surface_model,
   shell_based_wireframe_model,
   solid_model,
   sphere,
   tessellated_item,
   torus); 


CONSTANT
  dummy_gri : geometric_representation_item := representation_item('')|| geometric_representation_item(); 
END_CONSTANT; 

TYPE axis2_placement = SELECT
   (axis2_placement_2d, 
    axis2_placement_3d);
END_TYPE; 

TYPE b_spline_curve_form = ENUMERATION OF 
   (polyline_form,
    circular_arc,
    elliptic_arc,
    parabolic_arc,
    hyperbolic_arc,
    unspecified);
END_TYPE; 

TYPE b_spline_surface_form = ENUMERATION OF 
   (plane_surf,
    cylindrical_surf,
    conical_surf,
    spherical_surf,
    toroidal_surf,
    surf_of_revolution,
    ruled_surf,
    generalised_cone,
    quadric_surf,
    surf_of_linear_extrusion,
    unspecified);
END_TYPE; 

TYPE curve_on_surface = SELECT
   (composite_curve_on_surface, 
    pcurve, 
    surface_curve);
END_TYPE; 

TYPE dimension_count = INTEGER;
WHERE
  WR1: SELF > 0;
END_TYPE; 

TYPE extent_enumeration = ENUMERATION OF 
   (invalid,
    zero,
    finite_non_zero,
    infinite);
END_TYPE; 

TYPE knot_type = ENUMERATION OF 
   (uniform_knots,
    quasi_uniform_knots,
    piecewise_bezier_knots,
    unspecified);
END_TYPE; 

TYPE pcurve_or_surface = SELECT
   (pcurve, 
    surface);
END_TYPE; 

TYPE preferred_surface_curve_representation = ENUMERATION OF 
   (curve_3d,
    pcurve_s1,
    pcurve_s2);
END_TYPE; 

TYPE surface_boundary = SELECT
   (boundary_curve, 
    degenerate_pcurve);
END_TYPE; 

TYPE transition_code = ENUMERATION OF 
   (discontinuous,
    continuous,
    cont_same_gradient,
    cont_same_gradient_same_curvature);
END_TYPE; 

TYPE trimming_preference = ENUMERATION OF 
   (cartesian,
    parameter,
    unspecified);
END_TYPE; 

TYPE trimming_select = SELECT
   (cartesian_point, 
    parameter_value);
END_TYPE; 

TYPE vector_or_direction = SELECT
   (direction, 
    vector);
END_TYPE; 

ENTITY geometric_representation_context
  SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;

ENTITY geometric_representation_item
  SUPERTYPE OF (ONEOF (point,
                       direction,
                       vector,
                       placement,
                       cartesian_transformation_operator,
                       curve,
                       surface,
                       edge_curve,
                       face_surface,
                       poly_loop,
                       vertex_point,
                       solid_model,
                       boolean_result,
                       sphere,
                       right_circular_cone,
                       right_circular_cylinder,
                       torus,
                       block,
                       primitive_2d,
                       right_angular_wedge,
                       ellipsoid,
                       faceted_primitive,
                       rectangular_pyramid,
                       cyclide_segment_solid,
                       volume,
                       half_space_solid,
                       shell_based_surface_model,
                       face_based_surface_model,
                       shell_based_wireframe_model,
                       edge_based_wireframe_model,
                       geometric_set,
                       tessellated_item))
  SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  WR1: SIZEOF (QUERY (using_rep <* using_representations (SELF) | NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (using_rep.context_of_items)))) = 0;
END_ENTITY;

ENTITY point
  SUPERTYPE OF (ONEOF (cartesian_point,
                       point_on_curve,
                       point_on_surface,
                       point_in_volume,
                       point_replica,
                       degenerate_pcurve))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY cartesian_point
  SUPERTYPE OF (ONEOF (cylindrical_point,
                       polar_point,
                       spherical_point))
  SUBTYPE OF (point);
  coordinates : LIST[1:3] OF length_measure;
END_ENTITY;

ENTITY cylindrical_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  z : length_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[1:3] OF length_measure := [r*cos(theta), r*sin(theta), z];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY spherical_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  phi : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[1:3] OF length_measure := [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY polar_point
  SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates : LIST[1:3] OF length_measure := [r*cos(theta), r*sin(theta)];
WHERE
  WR1: r >= 0.0;
END_ENTITY;

ENTITY point_on_curve
  SUBTYPE OF (point);
  basis_curve : curve;
  point_parameter : parameter_value;
END_ENTITY;

ENTITY point_on_surface
  SUBTYPE OF (point);
  basis_surface : surface;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
END_ENTITY;

ENTITY point_in_volume
  SUBTYPE OF (point);
  basis_volume : volume;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
  point_parameter_w : parameter_value;
END_ENTITY;

ENTITY point_replica
  SUBTYPE OF (point);
  parent_pt : point;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_pt.dim;
  WR2: acyclic_point_replica (SELF,parent_pt);
END_ENTITY;

ENTITY degenerate_pcurve
  SUBTYPE OF (point);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation. items[1]\geometric_representation_item.dim =2;
END_ENTITY;

ENTITY evaluated_degenerate_pcurve
  SUBTYPE OF (degenerate_pcurve);
  equivalent_point : cartesian_point;
END_ENTITY;

ENTITY direction
  SUBTYPE OF (geometric_representation_item);
  direction_ratios : LIST[2:3] OF REAL;
WHERE
  WR1: SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;

ENTITY vector
  SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude : length_measure;
WHERE
  WR1: magnitude >= 0.0;
END_ENTITY;

ENTITY placement
  SUPERTYPE OF (ONEOF (axis1_placement,
                       axis2_placement_2d,
                       axis2_placement_3d))
  SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;

ENTITY axis1_placement
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY axis2_placement_2d
  SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST[2:2] OF direction := build_2axes(ref_direction);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY axis2_placement_3d
  SUBTYPE OF (placement);
  axis : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p : LIST[3:3] OF direction := build_axes(axis,ref_direction);
WHERE
  WR1: SELF\placement.location.dim = 3;
  WR2: (NOT (EXISTS (axis))) OR (axis.dim = 3);
  WR3: (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
  WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR (cross_product(axis,ref_direction).magnitude > 0.0);
END_ENTITY;

ENTITY cartesian_transformation_operator
  SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d,
                       cartesian_transformation_operator_3d))
  SUBTYPE OF (functionally_defined_transformation, geometric_representation_item);
  axis1 : OPTIONAL direction;
  axis2 : OPTIONAL direction;
  local_origin : cartesian_point;
  scale : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  WR1: scl > 0.0;
END_ENTITY;

ENTITY cartesian_transformation_operator_3d
  SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u : LIST[3:3] OF direction := base_axis(3,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,axis3);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY cartesian_transformation_operator_2d
  SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u : LIST[2:2] OF direction := base_axis(2,SELF\cartesian_transformation_operator.axis1, SELF\cartesian_transformation_operator.axis2,?);
WHERE
  WR1: SELF\geometric_representation_item.dim = 2;
END_ENTITY;

ENTITY curve
  SUPERTYPE OF (ONEOF (line,
                       conic,
                       clothoid,
                       circular_involute,
                       pcurve,
                       surface_curve,
                       offset_curve_2d,
                       offset_curve_3d,
                       curve_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY line
  SUBTYPE OF (curve);
  pnt : cartesian_point;
  dir : vector;
WHERE
  WR1: dir.dim = pnt.dim;
END_ENTITY;

ENTITY conic
  SUPERTYPE OF (ONEOF (circle,
                       ellipse,
                       hyperbola,
                       parabola))
  SUBTYPE OF (curve);
  position : axis2_placement;
END_ENTITY;

ENTITY circle
  SUBTYPE OF (conic);
  radius : positive_length_measure;
END_ENTITY;

ENTITY ellipse
  SUBTYPE OF (conic);
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;

ENTITY hyperbola
  SUBTYPE OF (conic);
  semi_axis : positive_length_measure;
  semi_imag_axis : positive_length_measure;
END_ENTITY;

ENTITY parabola
  SUBTYPE OF (conic);
  focal_dist : length_measure;
WHERE
  WR1: focal_dist <> 0.0;
END_ENTITY;

ENTITY clothoid
  SUBTYPE OF (curve);
  position : axis2_placement;
  clothoid_constant : length_measure;
END_ENTITY;

ENTITY circular_involute
  SUBTYPE OF (curve);
  position : axis2_placement;
  base_radius : positive_length_measure;
END_ENTITY;

ENTITY bounded_curve
  SUPERTYPE OF (ONEOF (polyline,
                       b_spline_curve,
                       trimmed_curve,
                       bounded_pcurve,
                       bounded_surface_curve,
                       composite_curve))
  SUBTYPE OF (curve);
END_ENTITY;

ENTITY polyline
  SUBTYPE OF (bounded_curve);
  points : LIST[2:?] OF cartesian_point;
END_ENTITY;

ENTITY b_spline_curve
  SUPERTYPE OF (ONEOF (uniform_curve,
                       b_spline_curve_with_knots,
                       quasi_uniform_curve,
                       bezier_curve)
               ANDOR rational_b_spline_curve)
  SUBTYPE OF (bounded_curve);
  degree : INTEGER;
  control_points_list : LIST[2:?] OF cartesian_point;
  curve_form : b_spline_curve_form;
  closed_curve : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list) - 1);
  control_points : ARRAY[0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,0, upper_index_on_control_points);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
END_ENTITY;

ENTITY b_spline_curve_with_knots
  SUBTYPE OF (b_spline_curve);
  knot_multiplicities : LIST[2:?] OF INTEGER;
  knots : LIST[2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
  WR1: constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots);
  WR2: SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;

ENTITY uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY quasi_uniform_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY bezier_curve
  SUBTYPE OF (b_spline_curve);
END_ENTITY;

ENTITY rational_b_spline_curve
  SUBTYPE OF (b_spline_curve);
  weights_data : LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:upper_index_on_control_points] OF REAL := list_to_array(weights_data,0, upper_index_on_control_points);
WHERE
  WR1: SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve. control_points_list);
  WR2: curve_weights_positive(SELF);
END_ENTITY;

ENTITY trimmed_curve
  SUBTYPE OF (bounded_curve);
  basis_curve : curve;
  trim_1 : SET[1:2] OF trimming_select;
  trim_2 : SET[1:2] OF trimming_select;
  sense_agreement : BOOLEAN;
  master_representation : trimming_preference;
WHERE
  WR1: (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
  WR2: (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
END_ENTITY;

ENTITY composite_curve
  SUBTYPE OF (bounded_curve);
  segments : LIST[1:?] OF composite_curve_segment;
  self_intersect : LOGICAL;
DERIVE
  n_segments : INTEGER := SIZEOF(segments);
  closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
WHERE
  WR1: ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 1)) OR ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous)) = 0));
END_ENTITY;

ENTITY composite_curve_segment
  SUBTYPE OF (founded_item);
  transition : transition_code;
  same_sense : BOOLEAN;
  parent_curve : curve;
INVERSE
  using_curves : BAG[1:?] OF composite_curve FOR segments;
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY;

ENTITY reparametrised_composite_curve_segment
  SUBTYPE OF (composite_curve_segment);
  param_length : parameter_value;
WHERE
  WR1: param_length > 0.0;
END_ENTITY;

ENTITY pcurve
  SUBTYPE OF (curve);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  WR1: SIZEOF(reference_to_curve\representation.items) = 1;
  WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF (reference_to_curve\representation.items[1]);
  WR3: reference_to_curve\representation.items[1]\ geometric_representation_item.dim =2;
END_ENTITY;

ENTITY bounded_pcurve
  SUBTYPE OF (bounded_curve, pcurve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
END_ENTITY;

ENTITY surface_curve
  SUPERTYPE OF (ONEOF (intersection_curve,
                       seam_curve)
               ANDOR bounded_surface_curve)
  SUBTYPE OF (curve);
  curve_3d : curve;
  associated_geometry : LIST[1:2] OF pcurve_or_surface;
  master_representation : preferred_surface_curve_representation;
DERIVE
  basis_surface : SET[1:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: curve_3d.dim = 3;
  WR2: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR (master_representation <> pcurve_s1);
  WR3: ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR (master_representation <> pcurve_s2);
  WR4: NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY;

ENTITY intersection_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) <> associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY seam_curve
  SUBTYPE OF (surface_curve);
WHERE
  WR1: SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  WR2: associated_surface(SELF\surface_curve.associated_geometry[1]) = associated_surface(SELF\surface_curve.associated_geometry[2]);
  WR3: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[1]);
  WR4: 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;

ENTITY bounded_surface_curve
  SUBTYPE OF (bounded_curve, surface_curve);
WHERE
  WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(SELF\surface_curve.curve_3d));
END_ENTITY;

ENTITY composite_curve_on_surface
  SUPERTYPE OF (boundary_curve)
  SUBTYPE OF (composite_curve);
DERIVE
  basis_surface : SET[0:2] OF surface := get_basis_surface(SELF);
WHERE
  WR1: SIZEOF(basis_surface) > 0;
  WR2: constraints_composite_curve_on_surface(SELF);
END_ENTITY;

ENTITY offset_curve_2d
  SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
WHERE
  WR1: basis_curve.dim = 2;
END_ENTITY;

ENTITY offset_curve_3d
  SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
  ref_direction : direction;
WHERE
  WR1: (basis_curve.dim = 3) AND (ref_direction.dim = 3);
END_ENTITY;

ENTITY curve_replica
  SUBTYPE OF (curve);
  parent_curve : curve;
  transformation : cartesian_transformation_operator;
WHERE
  WR1: transformation.dim = parent_curve.dim;
  WR2: acyclic_curve_replica (SELF, parent_curve);
END_ENTITY;

ENTITY surface
  SUPERTYPE OF (ONEOF (elementary_surface,
                       swept_surface,
                       bounded_surface,
                       offset_surface,
                       surface_replica))
  SUBTYPE OF (geometric_representation_item);
END_ENTITY;

ENTITY elementary_surface
  SUPERTYPE OF (ONEOF (plane,
                       cylindrical_surface,
                       conical_surface,
                       spherical_surface,
                       toroidal_surface))
  SUBTYPE OF (surface);
  position : axis2_placement_3d;
END_ENTITY;

ENTITY plane
  SUBTYPE OF (elementary_surface);
END_ENTITY;

ENTITY cylindrical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY conical_surface
  SUBTYPE OF (elementary_surface);
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  WR1: radius >= 0.0;
END_ENTITY;

ENTITY spherical_surface
  SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;

ENTITY toroidal_surface
  SUBTYPE OF (elementary_surface);
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
END_ENTITY;

ENTITY degenerate_toroidal_surface
  SUBTYPE OF (toroidal_surface);
  select_outer : BOOLEAN;
WHERE
  WR1: major_radius < minor_radius;
END_ENTITY;

ENTITY dupin_cyclide_surface
  SUBTYPE OF (elementary_surface);
  generalised_major_radius : positive_length_measure;
  generalised_minor_radius : positive_length_measure;
  skewness : length_measure;
WHERE
  WR1: skewness >= 0.0;
END_ENTITY;

ENTITY swept_surface
  SUPERTYPE OF (ONEOF (surface_of_linear_extrusion,
                       surface_of_revolution,
                       surface_curve_swept_surface,
                       fixed_reference_swept_surface))
  SUBTYPE OF (surface);
  swept_curve : curve;
END_ENTITY;

ENTITY surface_of_linear_extrusion
  SUBTYPE OF (swept_surface);
  extrusion_axis : vector;
END_ENTITY;

ENTITY surface_of_revolution
  SUBTYPE OF (swept_surface);
  axis_position : axis1_placement;
DERIVE
  axis_line : line := representation_item('')|| geometric_representation_item()|| curve()|| line(axis_position.location, representation_item('')|| geometric_representation_item()|| vector(axis_position.z, 1.0));
END_ENTITY;

ENTITY surface_curve_swept_surface
  SUBTYPE OF (swept_surface);
  directrix : curve;
  reference_surface : surface;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR (reference_surface IN (directrix\surface_curve.basis_surface));
END_ENTITY;

ENTITY fixed_reference_swept_surface
  SUBTYPE OF (swept_surface);
  directrix : curve;
  fixed_reference : direction;
END_ENTITY;

ENTITY bounded_surface
  SUPERTYPE OF (ONEOF (b_spline_surface,
                       rectangular_trimmed_surface,
                       curve_bounded_surface,
                       rectangular_composite_surface))
  SUBTYPE OF (surface);
END_ENTITY;

ENTITY b_spline_surface
  SUPERTYPE OF (ONEOF (b_spline_surface_with_knots,
                       uniform_surface,
                       quasi_uniform_surface,
                       bezier_surface)
               ANDOR rational_b_spline_surface)
  SUBTYPE OF (bounded_surface);
  u_degree : INTEGER;
  v_degree : INTEGER;
  control_points_list : LIST[2:?] OF LIST[2:?] OF cartesian_point;
  surface_form : b_spline_surface_form;
  u_closed : LOGICAL;
  v_closed : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  control_points : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF cartesian_point := make_array_of_array(control_points_list, 0,u_upper,0,v_upper);
WHERE
  WR1: ('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_surface_with_knots
  SUBTYPE OF (b_spline_surface);
  u_multiplicities : LIST[2:?] OF INTEGER;
  v_multiplicities : LIST[2:?] OF INTEGER;
  u_knots : LIST[2:?] OF parameter_value;
  v_knots : LIST[2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper, SELF\b_spline_surface.u_upper, u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper, SELF\b_spline_surface.v_upper, v_multiplicities, v_knots);
  WR3: SIZEOF(u_multiplicities) = knot_u_upper;
  WR4: SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY;

ENTITY uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY quasi_uniform_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY bezier_surface
  SUBTYPE OF (b_spline_surface);
END_ENTITY;

ENTITY rational_b_spline_surface
  SUBTYPE OF (b_spline_surface);
  weights_data : LIST[2:?] OF LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF REAL := make_array_of_array(weights_data,0,u_upper,0,v_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_surface.control_points_list[1]));
  WR2: surface_weights_positive(SELF);
END_ENTITY;

ENTITY rectangular_trimmed_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  usense : BOOLEAN;
  vsense : BOOLEAN;
WHERE
  WR1: u1 <> u2;
  WR2: v1 <> v2;
  WR3: (('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface)) AND (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface)) OR (usense = (u2 > u1));
  WR4: (('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface)) OR ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface))) OR (vsense = (v2 > v1));
END_ENTITY;

ENTITY curve_bounded_surface
  SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  boundaries : SET[1:?] OF boundary_curve;
  implicit_outer : BOOLEAN;
WHERE
  WR1: (NOT implicit_outer) OR (SIZEOF (QUERY (temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
  WR2: (NOT(implicit_outer)) OR ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
  WR3: SIZEOF(QUERY(temp <* boundaries | 'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) <= 1;
  WR4: SIZEOF(QUERY(temp <* boundaries | (temp\composite_curve_on_surface.basis_surface [1] <> SELF.basis_surface))) = 0;
END_ENTITY;

ENTITY boundary_curve
  SUBTYPE OF (composite_curve_on_surface);
WHERE
  WR1: SELF\composite_curve.closed_curve;
END_ENTITY;

ENTITY outer_boundary_curve
  SUBTYPE OF (boundary_curve);
END_ENTITY;

ENTITY rectangular_composite_surface
  SUBTYPE OF (bounded_surface);
  segments : LIST[1:?] OF LIST[1:?] OF surface_patch;
DERIVE
  n_u : INTEGER := SIZEOF(segments);
  n_v : INTEGER := SIZEOF(segments[1]);
WHERE
  WR1: SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
  WR2: constraints_rectangular_composite_surface(SELF);
END_ENTITY;

ENTITY surface_patch
  SUBTYPE OF (founded_item);
  parent_surface : bounded_surface;
  u_transition : transition_code;
  v_transition : transition_code;
  u_sense : BOOLEAN;
  v_sense : BOOLEAN;
INVERSE
  using_surfaces : BAG[1:?] OF rectangular_composite_surface FOR segments;
WHERE
  WR1: (NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)));
END_ENTITY;

ENTITY offset_surface
  SUBTYPE OF (surface);
  basis_surface : surface;
  distance : length_measure;
  self_intersect : LOGICAL;
END_ENTITY;

ENTITY oriented_surface
  SUBTYPE OF (surface);
  orientation : BOOLEAN;
END_ENTITY;

ENTITY surface_replica
  SUBTYPE OF (surface);
  parent_surface : surface;
  transformation : cartesian_transformation_operator_3d;
WHERE
  WR1: acyclic_surface_replica(SELF, parent_surface);
END_ENTITY;

ENTITY volume
  SUPERTYPE OF (ONEOF (block_volume,
                       wedge_volume,
                       spherical_volume,
                       cylindrical_volume,
                       eccentric_conical_volume,
                       toroidal_volume,
                       pyramid_volume,
                       b_spline_volume,
                       ellipsoid_volume,
                       tetrahedron_volume,
                       hexahedron_volume))
  SUBTYPE OF (geometric_representation_item);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
END_ENTITY;

ENTITY block_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;

ENTITY wedge_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  WR1: ((0.0 <= ltx) AND (ltx < x));
END_ENTITY;

ENTITY pyramid_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY tetrahedron_volume
  SUBTYPE OF (volume);
  point_1 : cartesian_point;
  point_2 : cartesian_point;
  point_3 : cartesian_point;
  point_4 : cartesian_point;
WHERE
  WR1: point_1.dim = 3;
  WR2: above_plane(point_1, point_2, point_3, point_4) <> 0.0;
END_ENTITY;

ENTITY hexahedron_volume
  SUBTYPE OF (volume);
  points : LIST[8:8] OF cartesian_point;
WHERE
  WR1: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  WR2: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  WR3: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  WR4: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  WR5: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  WR6: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  WR7: same_side([points[1], points[2], points[3]], [points[5], points[6], points[7], points[8]]);
  WR8: same_side([points[1], points[4], points[8]], [points[3], points[7], points[6], points[2]]);
  WR9: same_side([points[1], points[2], points[5]], [points[3], points[7], points[8], points[4]]);
  WR10: same_side([points[5], points[6], points[7]], [points[1], points[2], points[3], points[4]]);
  WR11: same_side([points[3], points[7], points[6]], [points[1], points[4], points[8], points[5]]);
  WR12: same_side([points[3], points[7], points[8]], [points[1], points[5], points[6], points[2]]);
  WR13: points[1].dim = 3;
END_ENTITY;

ENTITY spherical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
END_ENTITY;

ENTITY cylindrical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;

ENTITY eccentric_conical_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  WR1: ratio >= 0.0;
END_ENTITY;

ENTITY toroidal_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  WR1: minor_radius < major_radius;
END_ENTITY;

ENTITY ellipsoid_volume
  SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;

ENTITY b_spline_volume
  SUPERTYPE OF (ONEOF (b_spline_volume_with_knots,
                       uniform_volume,
                       quasi_uniform_volume,
                       bezier_volume)
               ANDOR rational_b_spline_volume)
  SUBTYPE OF (volume);
  u_degree : INTEGER;
  v_degree : INTEGER;
  w_degree : INTEGER;
  control_points_list : LIST[2:?] OF LIST[2:?] OF LIST[2:?] OF cartesian_point;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  w_upper : INTEGER := SIZEOF(control_points_list[1][1]) - 1;
  control_points : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF ARRAY[0:w_upper] OF cartesian_point := make_array_of_array_of_array (control_points_list, 0,u_upper,0,v_upper, 0,w_upper );
WHERE
  WR1: ('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY;

ENTITY b_spline_volume_with_knots
  SUBTYPE OF (b_spline_volume);
  u_multiplicities : LIST[2:?] OF INTEGER;
  v_multiplicities : LIST[2:?] OF INTEGER;
  w_multiplicities : LIST[2:?] OF INTEGER;
  u_knots : LIST[2:?] OF parameter_value;
  v_knots : LIST[2:?] OF parameter_value;
  w_knots : LIST[2:?] OF parameter_value;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
  knot_w_upper : INTEGER := SIZEOF(w_knots);
WHERE
  WR1: constraints_param_b_spline(SELF\b_spline_volume.u_degree, knot_u_upper, SELF\b_spline_volume.u_upper, u_multiplicities, u_knots);
  WR2: constraints_param_b_spline(SELF\b_spline_volume.v_degree, knot_v_upper, SELF\b_spline_volume.v_upper, v_multiplicities, v_knots);
  WR3: constraints_param_b_spline(SELF\b_spline_volume.w_degree, knot_w_upper, SELF\b_spline_volume.w_upper, w_multiplicities, w_knots);
  WR4: SIZEOF(u_multiplicities) = knot_u_upper;
  WR5: SIZEOF(v_multiplicities) = knot_v_upper;
  WR6: SIZEOF(w_multiplicities) = knot_w_upper;
END_ENTITY;

ENTITY bezier_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY quasi_uniform_volume
  SUBTYPE OF (b_spline_volume);
END_ENTITY;

ENTITY rational_b_spline_volume
  SUBTYPE OF (b_spline_volume);
  weights_data : LIST[2:?] OF LIST[2:?] OF LIST[2:?] OF REAL;
DERIVE
  weights : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF ARRAY[0:w_upper] OF REAL := make_array_of_array_of_array (weights_data,0,u_upper,0,v_upper,0,w_upper);
WHERE
  WR1: (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_volume.control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1])) AND (SIZEOF(weights_data[1][1]) = SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
  WR2: volume_weights_positive(SELF);
END_ENTITY;

RULE compatible_dimension FOR 
(cartesian_point,direction,representation_context,geometric_representation_context);
WHERE
  WR1: SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY (y <* geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;
  WR2: SIZEOF(QUERY(x <* direction | SIZEOF( QUERY (y <* geometric_representation_context | item_in_context(x,y) AND (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension))) > 0 )) = 0;
END_RULE; 

FUNCTION above_plane
 (p1 : cartesian_point; p2 : cartesian_point; p3 : cartesian_point; p4 : cartesian_point) : REAL; 
LOCAL
     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);
     val, mag         : REAL;
   END_LOCAL;

   IF (p1.dim <> 3) THEN
     RETURN(?);
   END_IF;
   REPEAT i := 1 TO 3;
     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
  END_REPEAT;
  mag := sqrt(mag);
  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN(val);END_FUNCTION; 

FUNCTION acyclic_curve_replica
 (rep : curve_replica; parent : curve) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type curve_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same curve_replica, otherwise,
   call function again with the parents own parent_curve.     *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));
    END_IF;END_FUNCTION; 

FUNCTION acyclic_point_replica
 (rep : point_replica; parent : point) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type point_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same point_replica, otherwise,
   call function again with the parents own parent_pt.     *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
    END_IF;END_FUNCTION; 

FUNCTION acyclic_surface_replica
 (rep : surface_replica; parent : surface) : BOOLEAN; 
IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
      RETURN (TRUE);
   END_IF;
 (* Return TRUE if the parent is not of type surface_replica *)
   IF (parent :=: rep) THEN
      RETURN (FALSE);
  (* Return FALSE if the parent is the same surface_replica, otherwise,
   call function again with the parents own parent_surface.     *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));
    END_IF;END_FUNCTION; 

FUNCTION associated_surface
 (arg : pcurve_or_surface) : surface; 
LOCAL
     surf : surface;
   END_LOCAL;
   
   IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
     surf := arg\pcurve.basis_surface;
   ELSE
     surf := arg;
   END_IF;
   RETURN(surf);END_FUNCTION; 

FUNCTION base_axis
 (dim : INTEGER; axis1 : direction; axis2 : direction; axis3 : direction) : LIST[2:3] OF direction; 
LOCAL
    u      : LIST [2:3] OF direction;
    factor : REAL;
    d1, d2 : direction;
  END_LOCAL;
  
  IF (dim = 3) THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1,axis1);
    u := [d2, second_proj_axis(d1,d2,axis2), d1];
  ELSE
     IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2,u[2]);
        IF (factor < 0.0) THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1]; 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];
      END_IF;
    END_IF;
  END_IF;
  RETURN(u);END_FUNCTION; 

FUNCTION build_2axes
 (ref_direction : direction) : LIST[2:2] OF direction; 
LOCAL
     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));
   END_LOCAL;

   RETURN([d, orthogonal_complement(d)]);END_FUNCTION; 

FUNCTION build_axes
 (axis : direction; ref_direction : direction) : LIST[3:3] OF direction; 
LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2))\vector.orientation, d1]);END_FUNCTION; 

FUNCTION constraints_composite_curve_on_surface
 (c : composite_curve_on_surface) : BOOLEAN; 
LOCAL
     n_segments : INTEGER := SIZEOF(c.segments);
   END_LOCAL;
        
   REPEAT k := 1 TO n_segments;
     IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
        (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
       RETURN (FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);END_FUNCTION; 

FUNCTION constraints_param_b_spline
 (degree : INTEGER; up_knots : INTEGER; up_cp : INTEGER; knot_mult : LIST[0:?] OF INTEGER; knots : LIST[0:?] OF parameter_value) : BOOLEAN; 
LOCAL
     result  : BOOLEAN := TRUE;
     k, sum  : INTEGER;
   END_LOCAL;
   
   (* Find sum of knot multiplicities. *)
   sum := knot_mult[1];
   
   REPEAT i := 2 TO up_knots;
     sum := sum + knot_mult[i];
   END_REPEAT;
   
   (* Check limits holding for all B-spline parametrisations *)
   IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
         (sum <> (degree + up_cp + 2)) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
   
   k := knot_mult[1];
   
   IF (k < 1) OR (k > degree + 1) THEN
     result := FALSE;
     RETURN(result);
   END_IF;
      
   REPEAT i := 2 TO up_knots;
     IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     k := knot_mult[i];
     
     IF (i < up_knots) AND (k > degree) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     IF (i = up_knots) AND (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION constraints_rectangular_composite_surface
 (s : rectangular_composite_surface) : BOOLEAN; 
REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v;
         IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface)) OR
                 ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                    (s.segments[i][j].parent_surface))) THEN
           RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;

   (* Check the transition codes, omitting the last row or column *)
   REPEAT i := 1 TO s.n_u-1;
     REPEAT j := 1 TO s.n_v;
       IF s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   
   REPEAT i := 1 TO s.n_u;
     REPEAT j := 1 TO s.n_v-1;
       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(TRUE);END_FUNCTION; 

FUNCTION cross_product
 (arg1 : direction; arg2 : direction) : vector; 
LOCAL
    mag    : REAL;
    res    : direction;
    v1,v2  : LIST[3:3] OF REAL;
    result : vector;
  END_LOCAL;
  
  IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
     ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
    RETURN(?);
  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;
      v2  := normalise(arg2).direction_ratios;
      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
            (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
      mag := 0.0;
      REPEAT i := 1 TO 3;
        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
      END_REPEAT;
      IF (mag > 0.0) THEN
        result := dummy_gri || vector(res, SQRT(mag));
      ELSE
        result := dummy_gri || vector(arg1, 0.0);
      END_IF;
      RETURN(result);
    END;
  END_IF;END_FUNCTION; 

FUNCTION curve_weights_positive
 (b : rational_b_spline_curve) : BOOLEAN; 
LOCAL
     result : BOOLEAN := TRUE;
   END_LOCAL;

   REPEAT i := 0 TO b.upper_index_on_control_points;
     IF b.weights[i] <= 0.0  THEN
       result := FALSE;
       RETURN(result);
     END_IF;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION default_b_spline_curve_weights
 (up_cp : INTEGER) : ARRAY[0:up_cp] OF REAL; 
RETURN([1:up_cp + 1]);END_FUNCTION; 

FUNCTION default_b_spline_knot_mult
 (degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST[2:?] OF INTEGER; 
LOCAL
     knot_mult : LIST [1:up_knots] OF INTEGER;
   END_LOCAL;
        
   IF uniform = uniform_knots THEN
     knot_mult := [1:up_knots];
   ELSE
     IF uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];
       knot_mult[1] := degree + 1;
       knot_mult[up_knots] := degree + 1;
     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         knot_mult := [0:up_knots];
       END_IF;
     END_IF;
   END_IF;
   RETURN(knot_mult);END_FUNCTION; 

FUNCTION default_b_spline_knots
 (degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST[2:?] OF parameter_value; 
LOCAL
    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
    ishift : INTEGER := 1;
  END_LOCAL;

  IF (uniform = uniform_knots) THEN
     ishift := degree + 1;
  END_if;
  IF (uniform = uniform_knots) OR 
     (uniform = quasi_uniform_knots) OR
     (uniform = piecewise_bezier_knots) THEN
    
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN(knots);END_FUNCTION; 

FUNCTION default_b_spline_surface_weights
 (u_upper : INTEGER; v_upper : INTEGER) : ARRAY[0:u_upper] OF ARRAY[0:v_upper] OF REAL; 
RETURN([[1:v_upper + 1]:u_upper +1]);END_FUNCTION; 

FUNCTION dimension_of
 (item : geometric_representation_item) : dimension_count; 
LOCAL
    x   : SET OF representation;
    y   : representation_context;
    dim : dimension_count;
  END_LOCAL;
  -- For cartesian_point, direction, or vector dimension is determined by
  -- counting components.
    IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
       dim := SIZEOF(item\cartesian_point.coordinates);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
       dim := SIZEOF(item\direction.direction_ratios);
       RETURN(dim);
    END_IF;
    IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
       RETURN(dim);
    END_IF;
  -- For all other types of geometric_representation_item dim is obtained
  -- via context.
  -- Find the set of representation in which the item is used. 

  x := using_representations(item);

  -- Determines the dimension_count of the 
  -- geometric_representation_context. Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is of type geometric_representation_context and has
  -- the same dimension_count for all values of x.
  -- The SET x is non-empty for legal instances since this is required by WR1 of
  -- representation_item.
    IF (SIZEOF(x) > 0) THEN
       y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
    RETURN (dim);
    ELSE
      RETURN(?);
    -- mark error by returning indeterminate result
   END_IF;END_FUNCTION; 

FUNCTION dot_product
 (arg1 : direction; arg2 : direction) : REAL; 
LOCAL
     scalar : REAL;
     vec1, vec2: direction;
     ndim : INTEGER;
   END_LOCAL;
   
   IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
     scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
   ELSE
     IF (arg1.dim <> arg2.dim) THEN
       scalar := ?;
     (* When function is called with invalid data an indeterminate result
     is returned *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);
         vec2   := normalise(arg2);
         ndim   := arg1.dim;
         scalar := 0.0;
         REPEAT  i := 1 TO ndim;
           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];
         END_REPEAT;
       END;
     END_IF;
   END_IF;
   RETURN (scalar);END_FUNCTION; 

FUNCTION first_proj_axis
 (z_axis : direction; arg : direction) : direction; 
LOCAL
    x_axis : direction;
    v      : direction;
    z      : direction;
    x_vec  : vector;
  END_LOCAL;
  
  IF (NOT EXISTS(z_axis)) THEN
    RETURN (?) ;
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
          (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);
      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);
      END_IF;
    ELSE
      IF  (arg.dim <> 3) THEN
        RETURN (?) ;
      END_IF;
      IF ((cross_product(arg,z).magnitude) = 0.0) THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN(x_axis);END_FUNCTION; 

FUNCTION get_basis_surface
 (c : curve_on_surface) : SET[0:2] OF surface; 
LOCAL
    surfs  : SET[0:2] OF surface;
    n      : INTEGER;
  END_LOCAL;
  surfs := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
   (* For a composite_curve_on_surface the basis_surface is the intersection
    of the basis_surfaces of all the segments. *)
     n := SIZEOF(c\composite_curve.segments);
     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);
     IF n > 1 THEN
       REPEAT i := 2 TO n;
         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);
       END_REPEAT;
     END_IF;

  END_IF;
  RETURN(surfs);END_FUNCTION; 

FUNCTION list_to_array
 (lis : LIST[0:?] OF GENERIC : T; low : INTEGER; u : INTEGER) : ARRAY[low:u] OF GENERIC : T; 
LOCAL
     n   : INTEGER;
     res : ARRAY [low:u] OF GENERIC : T;
   END_LOCAL;
      
   n := SIZEOF(lis);
   IF (n <> (u-low +1)) THEN
     RETURN(?);
   ELSE
     res := [lis[1] : n];
     REPEAT i := 2 TO n;
       res[low+i-1] := lis[i];
     END_REPEAT;
     RETURN(res);
   END_IF;END_FUNCTION; 

FUNCTION make_array_of_array
 (lis : LIST[1:?] OF LIST[1:?] OF GENERIC : T; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER) : ARRAY[low1:u1] OF ARRAY[low2:u2] OF GENERIC : T; 
LOCAL
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
   END_LOCAL;

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
     RETURN (?) ;
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);
   END_REPEAT; 
   
   RETURN (res);END_FUNCTION; 

FUNCTION make_array_of_array_of_array
 (lis : LIST[1:?] OF LIST[1:?] OF LIST[1:?] OF GENERIC : T; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER; low3 : INTEGER; u3 : INTEGER) : ARRAY[low1:u1] OF ARRAY[low2:u2] OF ARRAY[low3:u3] OF GENERIC : T; 
LOCAL 
   res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;
 END_LOCAL;                

(* Check input dimensions for consistency *)
   IF (u1-low1+1) <> SIZEOF(lis) THEN
     RETURN (?);
   END_IF;
   IF (u2-low2+1) <> SIZEOF(lis[1]) THEN
     RETURN (?);
   END_IF;
(* Initialise res with values from lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
   REPEAT i := 2 TO HIINDEX(lis);
     IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
       RETURN (?);
     END_IF;  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
   END_REPEAT; 
   RETURN (res);END_FUNCTION; 

FUNCTION normalise
 (arg : vector_or_direction) : vector_or_direction; 
LOCAL
      ndim   : INTEGER;
      v      : direction := dummy_gri || direction ([1.0,0.0,0.0]);
      result : vector_or_direction;
      vec    : vector := dummy_gri || vector (v, 1.0);
      mag    : REAL;
    END_LOCAL;
    
    IF NOT EXISTS (arg) THEN
      result := ?;
  (* When function is called with invalid data a NULL result is returned *)
    ELSE
      ndim := arg.dim;
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
        BEGIN
              v := dummy_gri || direction(arg\vector.orientation.direction_ratios);
          IF arg\vector.magnitude = 0.0 THEN
            RETURN(?);
          ELSE
           vec := dummy_gri || vector (v, 1.0);
          END_IF;
        END;
      ELSE
        v := dummy_gri || direction (arg.direction_ratios);
      END_IF;
      mag := 0.0;
      REPEAT  i := 1 TO ndim;
        mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
      END_REPEAT;
      IF mag > 0.0 THEN
        mag := SQRT(mag);
        REPEAT  i := 1 TO ndim;
          v.direction_ratios[i] := v.direction_ratios[i]/mag;
        END_REPEAT;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
          vec.orientation := v;
          result := vec;
        ELSE
          result := v;
        END_IF;
      ELSE
        RETURN(?);
      END_IF;
    END_IF;
    RETURN (result);END_FUNCTION; 

FUNCTION orthogonal_complement
 (vec : direction) : direction; 
LOCAL
     result :  direction ;
   END_LOCAL;

   IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
     RETURN(?);
   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);
     RETURN(result);
   END_IF;END_FUNCTION; 

FUNCTION same_side
 (plane_pts : LIST[3:3] OF cartesian_point; test_points : LIST[2:?] OF cartesian_point) : BOOLEAN; 
LOCAL
     val1, val2 : REAL;
     n          : INTEGER;
   END_LOCAL;

   IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
     RETURN(?);
   END_IF;
   n := SIZEOF(test_points);
   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1] );
   REPEAT i := 2 TO n;
     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i] );
     IF (val1*val2 <= 0.0) THEN
       RETURN(FALSE);
     END_IF;
   END_REPEAT;
   RETURN(TRUE);END_FUNCTION; 

FUNCTION scalar_times_vector
 (scalar : REAL; vec : vector_or_direction) : vector; 
LOCAL
      v      : direction;
      mag    : REAL;
      result : vector;
    END_LOCAL;
 
    IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
      RETURN (?) ;
     ELSE
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
        v   := dummy_gri || direction(vec\vector.orientation.direction_ratios);
        mag := scalar * vec\vector.magnitude;
      ELSE
        v   := dummy_gri || direction(vec.direction_ratios);
        mag := scalar;
      END_IF;
      IF (mag < 0.0 ) THEN
        REPEAT i := 1 TO SIZEOF(v.direction_ratios);
          v.direction_ratios[i] := -v.direction_ratios[i];
        END_REPEAT;
        mag := -mag;
      END_IF;
      result := dummy_gri || vector(normalise(v), mag);
    END_IF;
    RETURN (result);END_FUNCTION; 

FUNCTION second_proj_axis
 (z_axis : direction; x_axis : direction; arg : direction) : direction; 
LOCAL
     y_axis : vector;
     v      : direction;
     temp   : vector;
   END_LOCAL;
   
   IF NOT EXISTS(arg) THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);
   ELSE
     v := arg;
   END_IF;
   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
   y_axis := vector_difference(v, temp);
   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
   y_axis := vector_difference(y_axis, temp);
   y_axis := normalise(y_axis);
   RETURN(y_axis.orientation);END_FUNCTION; 

FUNCTION surface_weights_positive
 (b : rational_b_spline_surface) : BOOLEAN; 
LOCAL
     result        : BOOLEAN := TRUE;
   END_LOCAL;
   
   REPEAT i := 0 TO b.u_upper;
     REPEAT j := 0 TO b.v_upper;
       IF (b.weights[i][j] <= 0.0)  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
   END_REPEAT;
   RETURN(result);END_FUNCTION; 

FUNCTION vector_difference
 (arg1 : vector_or_direction; arg2 : vector_or_direction) : vector; 
LOCAL
      result          : vector;
      res, vec1, vec2 : direction;
      mag, mag1, mag2 : REAL;
      ndim            : INTEGER;
    END_LOCAL;
 
    IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
        THEN
      RETURN (?) ;
     ELSE
      BEGIN
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
          mag1 := arg1\vector.magnitude;
          vec1 := arg1\vector.orientation;
        ELSE
          mag1 := 1.0;
          vec1 := arg1;
        END_IF;
        IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
          mag2 := arg2\vector.magnitude;
          vec2 := arg2\vector.orientation;
        ELSE
          mag2 := 1.0;
          vec2 := arg2;
        END_IF;
        vec1 := normalise (vec1);
        vec2 := normalise (vec2);
        ndim := SIZEOF(vec1.direction_ratios);
        mag := 0.0;
        res := dummy_gri || direction(vec1.direction_ratios);
        REPEAT i := 1 TO ndim;
          res.direction_ratios[i] := mag1*vec1.direction_ratios[i] -
                                      mag2*vec2.direction_ratios[i];
          mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
        END_REPEAT;
        IF (mag > 0.0 ) THEN
        result := dummy_gri || vector( res, SQRT(mag));
        ELSE
          result := dummy_gri || vector( vec1,  0.0);
        END_IF;
      END;
    END_IF;
    RETURN (result);END_FUNCTION; 

FUNCTION vector_sum
 (arg1 : vector_or_direction; arg2 : vector_or_direction) : vector; 
LOCAL
     result          : vector;
     res, vec1, vec2 : direction;
     mag, mag1, mag2 : REAL;
     ndim            : INTEGER;
   END_LOCAL;

   IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
       THEN
     RETURN (?) ;

   ELSE
     BEGIN
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
         mag1 := arg1\vector.magnitude;
         vec1 := arg1\vector.orientation;
       ELSE
         mag1 := 1.0;
         vec1 := arg1;
       END_IF;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
         mag2 := arg2\vector.magnitude;
         vec2 := arg2\vector.orientation;
       ELSE
         mag2 := 1.0;
         vec2 := arg2;
       END_IF;
       vec1 := normalise (vec1);
       vec2 := normalise (vec2);
       ndim := SIZEOF(vec1.direction_ratios);
       mag := 0.0;
       res := dummy_gri || direction(vec1.direction_ratios);
       REPEAT i := 1 TO ndim;
         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];
         mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
       END_REPEAT;
       IF (mag > 0.0 ) THEN
       result := dummy_gri || vector( res, SQRT(mag));
       ELSE
         result := dummy_gri || vector( vec1,  0.0);
       END_IF;
     END;
   END_IF;
   RETURN (result);END_FUNCTION; 

FUNCTION volume_weights_positive
 (b : rational_b_spline_volume) : BOOLEAN; 
LOCAL
       result   : BOOLEAN := TRUE;
     END_LOCAL;

     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         REPEAT k := 0 TO b.w_upper;
           IF (b.weights[i][j][k] <= 0.0)  THEN
             result := FALSE;
             RETURN(result);
           END_IF;
         END_REPEAT;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);END_FUNCTION; 

END_SCHEMA;  -- geometry_schema

(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA group_schema;

  REFERENCE FROM support_resource_schema (
    label, 
    bag_to_set, 
    identifier, 
    text);
  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    id_attribute,
    id_attribute_select);
    
  TYPE gs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    group);
  END_TYPE;
    
  ENTITY group;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY group_relationship;
    name : label;
    description : OPTIONAL text;
    relating_group : group;
    related_group : group;
  END_ENTITY;

  FUNCTION acyclic_group_relationship (relation : group_relationship; relatives : SET [1:?] OF group; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF group_relationship;
    END_LOCAL;

    IF relation.relating_group IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'GROUP_SCHEMA.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(* Genenerated from: ISO.exp *)
(* This schema incorporates proposed solution in SEDS #1294, #1299.  *)

SCHEMA iso13584_expressions_schema;

REFERENCE FROM iso13584_generic_expressions_schema(
			generic_expression,
			simple_generic_expression,
			generic_variable,
			generic_literal,
			unary_generic_expression,
			binary_generic_expression,
			multiple_arity_generic_expression);

ENTITY expression
ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression,
				boolean_expression,
				string_expression))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY variable
ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable,
				boolean_variable,
					string_variable))
SUBTYPE OF(generic_variable);
END_ENTITY;

ENTITY defined_function
ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function,
				string_defined_function,
				boolean_defined_function)
				)
				ANDOR SQL_mappable_defined_function);
END_ENTITY;

ENTITY SQL_mappable_defined_function
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function);
END_ENTITY;

ENTITY numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression,
								unary_numeric_expression,
								binary_numeric_expression,
								multiple_arity_numeric_expression,
								length_function,
								value_function,
								numeric_defined_function))
SUBTYPE OF (expression);
DERIVE
	is_int: LOGICAL := is_int_expr (SELF);
	sql_mappable: LOGICAL := is_SQL_mappable (SELF);
END_ENTITY;

ENTITY simple_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY;

ENTITY literal_number 
ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value: NUMBER;
END_ENTITY;

ENTITY int_literal
SUBTYPE OF (literal_number);
	SELF\literal_number.the_value: INTEGER;
END_ENTITY;

ENTITY real_literal
SUBTYPE OF (literal_number); 
	SELF\literal_number.the_value: REAL;
END_ENTITY;

ENTITY numeric_variable
SUPERTYPE OF (ONEOF (int_numeric_variable,
			          real_numeric_variable))
SUBTYPE OF (simple_numeric_expression, variable);
WHERE 
	WR1:	('ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) ) OR
			('ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' 
			IN TYPEOF(SELF) );
END_ENTITY;

ENTITY int_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY real_numeric_variable
SUBTYPE OF (numeric_variable);
END_ENTITY;

ENTITY unary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (unary_function_call))
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand	: numeric_expression;
END_ENTITY;

ENTITY binary_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (minus_expression,
				div_expression,
				mod_expression,
				slash_expression,
				power_expression,
				binary_function_call))
SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF 
						numeric_expression;
END_ENTITY;

ENTITY multiple_arity_numeric_expression
ABSTRACT SUPERTYPE OF (ONEOF (plus_expression,
				mult_expression,
				multiple_arity_function_call))
SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: LIST [2:?] OF 						numeric_expression;
END_ENTITY;

ENTITY length_function
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY value_function
SUPERTYPE OF (int_value_function)
SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand: string_expression;
END_ENTITY;

ENTITY int_value_function
SUBTYPE OF (value_function);
END_ENTITY;

ENTITY numeric_defined_function
ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function,
				real_defined_function))
SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY;

ENTITY plus_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY minus_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mult_expression
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY div_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY mod_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY slash_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY power_expression
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY unary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (abs_function,
				minus_function,
				sin_function,
				cos_function,
				tan_function,
				asin_function,
				acos_function,
				exp_function,
				log_function,
				log2_function,
				log10_function,
				square_root_function))
SUBTYPE OF (unary_numeric_expression);
END_ENTITY;

ENTITY binary_function_call
ABSTRACT SUPERTYPE OF (ONEOF (atan_function))
SUBTYPE OF (binary_numeric_expression);
END_ENTITY;

ENTITY multiple_arity_function_call
ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, 
				minimum_function))
SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY;

ENTITY abs_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY minus_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY sin_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY cos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY tan_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY acos_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY exp_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log2_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY log10_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY square_root_function
SUBTYPE OF (unary_function_call);
END_ENTITY;

ENTITY atan_function
SUBTYPE OF (binary_function_call);
END_ENTITY;

ENTITY maximum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY minimum_function
SUBTYPE OF (multiple_arity_function_call);
END_ENTITY;

ENTITY integer_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY real_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (numeric_defined_function);
END_ENTITY ;

ENTITY boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression,
				unary_boolean_expression,
				binary_boolean_expression,
				multiple_arity_Boolean_expression,
				comparison_expression,
				interval_expression,
				boolean_defined_function))
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal,
				boolean_variable))
SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY;

ENTITY boolean_literal
SUBTYPE OF (simple_Boolean_expression, generic_literal);
	the_value: BOOLEAN;
END_ENTITY;

ENTITY boolean_variable
SUBTYPE OF (simple_Boolean_expression, variable);
END_ENTITY;

ENTITY unary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY;

ENTITY not_expression
SUBTYPE OF (unary_Boolean_expression);
SELF\unary_generic_expression.operand: boolean_expression;
END_ENTITY;

ENTITY odd_function
SUBTYPE OF (unary_Boolean_expression);
	SELF\unary_generic_expression.operand: numeric_expression;
WHERE
	WR1: is_int_expr(operand);
END_ENTITY;

ENTITY binary_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY;

ENTITY multiple_arity_boolean_expression
ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands	: 
LIST [2:?] OF boolean_expression;
END_ENTITY;

ENTITY xor_expression
SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands: 
				LIST [2:2] OF boolean_expression;
END_ENTITY;

ENTITY equals_expression
SUBTYPE OF (binary_boolean_expression);
END_ENTITY;

ENTITY and_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

ENTITY or_expression
SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY comparison_expression
ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal,
				comparison_greater,
				comparison_greater_equal,
				comparison_less,
				comparison_less_equal,
				comparison_not_equal,
				like_expression))
SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands	: LIST [2:2] OF expression; 
WHERE 
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) 
OR
 (('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_EXPRESSION' 
	IN TYPEOF(SELF\binary_generic_expression.operands[2])))
OR
(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[1]))
		AND 
		 	('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
IN TYPEOF(SELF\binary_generic_expression.operands[2]))) ;
END_ENTITY;

ENTITY comparison_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_greater_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_less_equal
SUBTYPE OF (comparison_expression);
END_ENTITY;

ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY;

(* Entity below modified by David Leal 2003-12-14 *)

ENTITY like_expression
SUBTYPE OF (comparison_expression);
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[1])) AND 
		('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
		IN TYPEOF(SELF\binary_generic_expression.operands[2]));
END_ENTITY;

ENTITY interval_expression
SUBTYPE OF (boolean_expression, multiple_arity_generic_expression) ;
DERIVE
	interval_low: generic_expression
			:= SELF\multiple_arity_generic_expression.operands[1];
	interval_item:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[2];
	interval_high:generic_expression
			:= SELF\multiple_arity_generic_expression.operands[3];
WHERE
	WR1:('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_low))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_item) )
		AND ('ISO13584_EXPRESSIONS_SCHEMA.EXPRESSION' 
				IN TYPEOF(interval_high));
	WR2:(('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION'  
				IN TYPEOF (SELF.interval_high)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
				IN TYPEOF (SELF.interval_item))) 
		OR
		(('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_low)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_item)) 
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
				IN TYPEOF(SELF.interval_high)));
END_ENTITY; 

ENTITY boolean_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY ;

ENTITY string_expression
ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression,
				index_expression,
				substring_expression,
				concat_expression,
				format_function,
				string_defined_function)) 
SUBTYPE OF (expression);
END_ENTITY;

ENTITY simple_string_expression
ABSTRACT SUPERTYPE OF (ONEOF (string_literal,
				string_variable))
SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY;

ENTITY string_literal
SUBTYPE OF (simple_string_expression, generic_literal);
	the_value: STRING;
END_ENTITY;

ENTITY string_variable
SUBTYPE OF (simple_string_expression, variable);
END_ENTITY;

ENTITY index_expression
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	operand:generic_expression:=
SELF\binary_generic_expression.operands[1];
	index:generic_expression:= 
SELF\binary_generic_expression.operands[2];
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
			IN TYPEOF(operand))
		AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
			IN TYPEOF(index));
	WR2: is_int_expr (index);
END_ENTITY;

ENTITY substring_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	operand:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[1];
	index1:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[2];
	index2:generic_expression:=
			SELF\multiple_arity_generic_expression.operands[3]; 
WHERE
	WR1: ('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION' 
					IN TYPEOF(operand))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index1))
			AND ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION' 
					IN TYPEOF(index2));
	WR2: SIZEOF(SELF\multiple_arity_generic_expression.operands)=3;
	WR3: is_int_expr (index1);
	WR4: is_int_expr (index2);
END_ENTITY;

ENTITY concat_expression
SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands: 
				LIST [2 : ?] OF string_expression;
END_ENTITY;

ENTITY format_function
SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	value_to_format: generic_expression:=
			SELF\binary_generic_expression.operands[1];
	format_string:generic_expression:=
			SELF\binary_generic_expression.operands[2];
WHERE
	WR1: (('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_EXPRESSION') 
					IN TYPEOF(value_to_format)) 
			AND (('ISO13584_EXPRESSIONS_SCHEMA.STRING_EXPRESSION') 
					IN TYPEOF(format_string));
END_ENTITY;

ENTITY string_defined_function 
ABSTRACT SUPERTYPE
SUBTYPE OF (defined_function, string_expression);
END_ENTITY ;

FUNCTION is_int_expr (arg: numeric_expression) : LOGICAL;

LOCAL
	i: INTEGER := 0;
END_LOCAL;

IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_LITERAL' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.REAL_NUMERIC_VARIABLE' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_int_expr(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION'
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION'
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
	IF NOT 
		is_int_expr(arg\multiple_arity_numeric_expression.operands[i]) 
	THEN 
		RETURN (FALSE);
	END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (is_int_expr(arg\binary_numeric_expression.operands[1])
		AND is_int_expr(arg\binary_numeric_expression.operands[2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg))
THEN 
	RETURN(TRUE);	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (TRUE); 
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg) 
THEN 
	IF 'ISO13584_EXPRESSIONS_SCHEMA.INT_VALUE_FUNCTION' 
								IN TYPEOF(arg) 
	THEN 
		RETURN (TRUE); 
	ELSE 
		RETURN (FALSE); 
	END_IF;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTEGER_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(TRUE) ;
END_IF;
IF'ISO13584_EXPRESSIONS_SCHEMA.REAL_DEFINED_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN(FALSE) ;
END_IF ;
IF 'ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg)
THEN 
	RETURN (FALSE) ;
END_IF ;

RETURN (FALSE);

END_FUNCTION; -- is_int_expr

FUNCTION is_SQL_mappable (arg: expression) : LOGICAL;

LOCAL
	i: INTEGER;
END_LOCAL;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_NUMERIC_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SQL_MAPPABLE_DEFINED_FUNCTION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MINUS_FUNCTION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\unary_numeric_expression.operand)); 
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ABS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.TAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ASIN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ACOS_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.ATAN_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.EXP_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG2_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LOG10_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SQUARE_ROOT_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.VALUE_FUNCTION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LENGTH_FUNCTION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.PLUS_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MULT_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MAXIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.MINIMUM_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	REPEAT i :=1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		IF NOT is_SQL_mappable(
			arg\multiple_arity_numeric_expression.operands[i])
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
RETURN (TRUE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.MINUS_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SLASH_EXPRESSION' IN 
								TYPEOF(arg))
THEN
		RETURN (is_SQL_mappable(
			arg\binary_numeric_expression.operands[1])
		AND is_SQL_mappable(arg\binary_numeric_expression.operands[2]));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.DIV_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.MOD_EXPRESSION' IN TYPEOF(arg)) 
		OR('ISO13584_EXPRESSIONS_SCHEMA.POWER_EXPRESSION' 
								IN TYPEOF(arg))
THEN 
	RETURN (FALSE); 	
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN 
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.NOT_EXPRESSION' IN TYPEOF (arg) 
THEN 
	RETURN (is_SQL_mappable (arg\UNARY_GENERIC_EXPRESSION.OPERAND));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.ODD_FUNCTION'IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.XOR_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN	
	RETURN (FALSE);
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.AND_EXPRESSION' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.OR_EXPRESSION' IN TYPEOF (arg)) 
THEN
	REPEAT i:=1 TO SIZEOF (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
		IF NOT is_SQL_mappable (
			arg\MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS[i]) 
		THEN 
			RETURN (FALSE);
		END_IF;
	END_REPEAT;
	RETURN (TRUE);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.EQUALS_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN(is_SQL_mappable (
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [1])
		AND is_SQL_mappable(
			arg\BINARY_GENERIC_EXPRESSION.OPERANDS [2]));
END_IF;
IF	('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EQUAL' IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_GREATER_EQUAL'
								IN TYPEOF (arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_LESS_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_NOT_EQUAL' 
								IN TYPEOF (arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' 
								IN TYPEOF (arg)) 
THEN
	RETURN (is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[1])
		AND is_SQL_mappable (arg\COMPARISON_EXPRESSION.OPERANDS[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (is_SQL_mappable(arg\interval_expression.interval_low) 
		AND is_SQL_mappable(arg\interval_expression.interval_high)
		AND is_SQL_mappable(arg\interval_expression.interval_item));
END_IF;
IF ('ISO13584_EXPRESSIONS_SCHEMA.NUMERIC_DEFINED_FUNCTION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.BOOLEAN_DEFINED_FUNCTION' 
								IN TYPEOF(arg))
		OR ('ISO13584_EXPRESSIONS_SCHEMA.STRING_DEFINED_FUNCTION' 
								IN TYPEOF(arg))  
THEN 
		RETURN (FALSE) ;
END_IF;

IF 'ISO13584_EXPRESSIONS_SCHEMA.SIMPLE_STRING_EXPRESSION' 
								IN TYPEOF(ARG) 
THEN 
	RETURN (TRUE);
END_IF;
IF 	('ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' 
								IN TYPEOF(arg)) 
		OR ('ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' 
								IN TYPEOF(arg)) 
THEN 
	RETURN (FALSE);
END_IF;

	RETURN (FALSE);
END_FUNCTION; -- is_SQL_mappable

FUNCTION used_functions (arg : expression) : SET OF defined_function;

LOCAL
	result : SET OF defined_function := [];
END_LOCAL;

IF ('ISO13584_EXPRESSIONS_SCHEMA.DEFINED_FUNCTION' IN TYPEOF(arg))  
THEN 
	RETURN ( [arg] ) ;
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_NUMERIC_EXPRESSION' IN 
	TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_numeric_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_NUMERIC_EXPRESSION' IN 
		TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_numeric_expression.operands[1])
		+ used_functions (arg\binary_numeric_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN 		TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (
			arg\multiple_arity_numeric_expression.operands);
		result := result + used_functions (
			arg\multiple_arity_numeric_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
		IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\unary_generic_expression.operand));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.BINARY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\binary_generic_expression.operands[1])
		+ used_functions (
			arg\binary_generic_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO 
		SIZEOF (arg\multiple_arity_Boolean_expression.operands);
		result := result + used_functions(
			arg\multiple_arity_Boolean_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.COMPARISON_EXPRESSION' 
								IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
			+ used_functions (arg\comparison_expression.operands[2]));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INTERVAL_EXPRESSION' IN TYPEOF(arg) 
THEN 
	RETURN (used_functions(arg\interval_expression.interval_low)
		+ used_functions(arg\interval_expression.interval_high)
		+ used_functions(arg\interval_expression.interval_item));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.INDEX_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\index_expression.operand)
		+ used_functions (arg\index_expression.index));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.SUBSTRING_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\substring_expression.operand)
		+ used_functions (arg\substring_expression.index1)
		+ used_functions (arg\substring_expression.index2));
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.CONCAT_EXPRESSION' IN TYPEOF (arg) 
THEN
	REPEAT i := 1 TO SIZEOF (arg\concat_expression.operands);
		result := result + used_functions (
			arg\concat_expression.operands[i]);
	END_REPEAT;
	RETURN (result);
END_IF;
IF 'ISO13584_EXPRESSIONS_SCHEMA.FORMAT_FUNCTION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\format_function.value_to_format)
		+ used_functions (arg\format_function.format_string));
END_IF;
(*
IF 'ISO13584_EXPRESSIONS_SCHEMA.LIKE_EXPRESSION' IN TYPEOF (arg) 
THEN
	RETURN (used_functions (arg\comparison_expression.operands[1])
		+ used_functions (arg\comparison_expression.operands[2]));
END_IF;
*)
RETURN ([ ]);

END_FUNCTION; -- used_functions

END_SCHEMA;
(* includes proposed solution in SEDS #1293 against ISO 13584-20 *)
SCHEMA iso13584_generic_expressions_schema;

ENTITY generic_expression
ABSTRACT SUPERTYPE OF(ONEOF(simple_generic_expression,
								unary_generic_expression,
								binary_generic_expression,
								multiple_arity_generic_expression));
WHERE 
	WR1: is_acyclic(SELF);
END_ENTITY;

ENTITY simple_generic_expression
ABSTRACT SUPERTYPE OF (ONEOF(generic_literal, generic_variable))
SUBTYPE OF (generic_expression);
END_ENTITY;

ENTITY generic_literal
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
END_ENTITY; 

ENTITY generic_variable
ABSTRACT SUPERTYPE
SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation :
			environment FOR syntactic_representation;
END_ENTITY;

ENTITY variable_semantics
ABSTRACT SUPERTYPE;
END_ENTITY;

ENTITY environment;
	syntactic_representation: generic_variable;
	semantics: variable_semantics;
END_ENTITY;

ENTITY unary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operand: generic_expression;
END_ENTITY;

ENTITY binary_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:2] OF generic_expression;
END_ENTITY;

ENTITY multiple_arity_generic_expression
ABSTRACT SUPERTYPE
SUBTYPE OF(generic_expression);
	operands: LIST [2:?] OF generic_expression;
END_ENTITY;

FUNCTION is_acyclic (arg: generic_expression): BOOLEAN;
RETURN (acyclic (arg, []));
END_FUNCTION ; -- is_acyclic

FUNCTION acyclic (arg1: generic_expression; 
			arg2: SET OF generic_expression): BOOLEAN;

LOCAL
	result: BOOLEAN := TRUE;
END_LOCAL;

IF ('ISO13584_GENERIC_EXPRESSIONS_SCHEMA.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1)) 
THEN
	RETURN (TRUE);
END_IF;

IF arg1 IN arg2 
THEN 
	RETURN (FALSE);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));
END_IF;

IF 
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1) 
THEN 
	result := TRUE;
	REPEAT i := 1 TO 
			SIZEOF (arg1\multiple_arity_generic_expression.operands);
		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);
	END_REPEAT;

	RETURN (result);
END_IF;
	RETURN (result);
END_FUNCTION; -- acyclic

FUNCTION used_variables (arg : generic_expression) : 
			SET OF generic_variable;

LOCAL
	result : SET OF generic_variable := [];
END_LOCAL;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_VARIABLE' 
	IN TYPEOF (arg) 
THEN 
	RETURN ([arg]);
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN 
	RETURN (used_variables (arg\unary_generic_expression.operand));
END_IF;

IF 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables (arg\binary_generic_expression.operands[2]));
END_IF;

IF
'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);
		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);
	END_REPEAT;
	
	RETURN (result);
END_IF;
RETURN ([ ]);      -- in this case the subtype shall not contain
			            -- any variable (see IP1 in generic_expression)
END_FUNCTION; -- used_variables

END_SCHEMA; 
(*
ISO TC184/SC4/WG12 N7302 - ISO/IS 10303-105 Kinematics - EXPRESS
*)

SCHEMA kinematic_analysis_control_and_result_schema;

REFERENCE FROM kinematic_motion_representation_schema
    (link_motion_representation_along_path,
     interpolated_configuration_sequence);

REFERENCE FROM kinematic_topology_schema (
	kinematic_joint);

REFERENCE FROM kinematic_structure_schema
    (kinematic_link_representation,
     mechanism_representation,
     rigid_placement);

REFERENCE FROM geometry_schema
    (geometric_representation_context);

REFERENCE FROM representation_schema
    (representation,
     representation_relationship);

REFERENCE FROM measure_schema
    (measure_with_unit,
     parameter_value);

REFERENCE FROM product_property_representation_schema
    (shape_representation);     

TYPE kinematic_analysis_definition = SELECT
  (interpolated_configuration_sequence,
   prescribed_path);
END_TYPE;

TYPE kinematic_result = SELECT
  (interpolated_configuration_sequence,
   resulting_path);
END_TYPE;

ENTITY kinematic_control;
  controlled_mechanism : mechanism_representation; 
  contained_kinematic_programs : kinematic_analysis_definition;
END_ENTITY;

ENTITY prescribed_path
  SUBTYPE OF (link_motion_representation_along_path);
  controlling_joints : OPTIONAL SET [1 : 6] OF kinematic_joint;
END_ENTITY;

ENTITY kinematic_analysis_result;
  analysed_mechanism : mechanism_representation; -- LK
  result : kinematic_result;
(*  
WHERE
WR1: ('KINEMATIC_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.RESULTING_PATH' IN TYPEOF (result))
     XOR
     (SIZEOF (QUERY (result <* contained_kinematic_results |
       (('KINEMATIC_ANALYSIS_CONTROL_AND_RESULT_SCHEMA.'+
         'INTERPOLATED_CONFIGURATION_SEQUENCE' IN TYPEOF (result))
              AND
       (SIZEOF (QUERY (sequence <* result\
                interpolated_configuration_sequence.interpolation |
                (sequence.interpolation <> undefined ))) > 0)))) = 0);
*)                
END_ENTITY;

ENTITY kinematic_analysis_consistency;
  control : kinematic_control;
  result  : kinematic_analysis_result;
WHERE
  WR1: control.controlled_mechanism :=: result.analysed_mechanism;
END_ENTITY;

ENTITY resulting_path
  SUBTYPE OF (link_motion_representation_along_path);
  controlling_joints : SET [1 : ?] OF kinematic_joint;
END_ENTITY;

SUBTYPE_CONSTRAINT link_motion_representation_along_path_subtypes FOR link_motion_representation_along_path;
          ONEOF (prescribed_path, resulting_path);
END_SUBTYPE_CONSTRAINT; 

END_SCHEMA;              -- end kinematic_analysis_control_and_result_schema
(*
ISO TC184/SC4/WG12 N7302 - ISO/IS 10303-105 Kinematics - EXPRESS
*)

SCHEMA kinematic_motion_representation_schema;

REFERENCE FROM geometry_schema
    (axis2_placement,
     b_spline_curve,
     b_spline_surface,
     bounded_curve,
     cartesian_point,
     curve,
     geometric_representation_context,
     geometric_representation_item,
     placement,
     transition_code);

REFERENCE FROM measure_schema
    (length_measure,
     measure_with_unit,
     parameter_value,
     plane_angle_measure,
     unit);

REFERENCE FROM representation_schema
    (definitional_representation,
     founded_item,
     functionally_defined_transformation,
     item_defined_transformation,
     item_in_context,
     parametric_representation_context,
     representation,
     representation_item,
     representation_relationship,
     definitional_representation_relationship,
     representation_relationship_with_transformation,
     using_representations);
     
REFERENCE FROM kinematic_structure_schema
	(kinematic_link_representation,
	 mechanism_representation,
	 rigid_placement);     

REFERENCE FROM kinematic_state_schema
    (rotation_about_direction,
     spatial_rotation,
     ypr_rotation,
     mechanism_state_representation);


REFERENCE FROM product_property_representation_schema
    (shape_representation);     

TYPE link_or_shape_representation = SELECT(
  kinematic_link_representation,
  shape_representation);
END_TYPE;

TYPE interpolation_type = ENUMERATION OF
  (undefined_interpolation_type,
   discontinuous_interpolation_type,
   synchronous_interpolation_type,
   linear_interpolation_type);
END_TYPE;

ENTITY interpolated_configuration_representation
  SUBTYPE OF (representation);
  SELF\representation.context_of_items : geometric_representation_context_with_parameter;
  SELF\representation.items : SET[1:?] OF interpolated_configuration_sequence;
END_ENTITY;

ENTITY interpolated_configuration_sequence
  SUBTYPE OF (representation_item);
  segments : LIST[2:?] OF interpolated_configuration_segment;
DERIVE
  n_segments : INTEGER := SIZEOF(segments);
  closed_interpolation : LOGICAL := segments[n_segments].interpolation <> discontinuous_interpolation_type;
  configured_mechanism : mechanism_representation := segments[1].state.represented_mechanism;
WHERE
  WR1: SIZEOF( QUERY(ics <* segments | ics.state.represented_mechanism :<>: configured_mechanism)) = 0;
END_ENTITY;  

ENTITY interpolated_configuration_segment
  SUBTYPE OF (founded_item);
  state : mechanism_state_representation;
  t_parameter : parameter_value;
  interpolation : interpolation_type;
END_ENTITY;

ENTITY link_motion_relationship
  SUBTYPE OF (definitional_representation_relationship, representation_relationship_with_transformation);
  SELF\representation_relationship.rep_1 : link_or_shape_representation;
  SELF\representation_relationship.rep_2 : link_motion_representation_along_path;
  SELF\representation_relationship_with_transformation.transformation_operator : link_motion_transformation;
WHERE
  WR1: transformation_operator\item_defined_transformation.transform_item_1 IN rep_1.items;
  WR2: transformation_operator\item_defined_transformation.transform_item_2 IN rep_2.items;
END_ENTITY;

ENTITY item_link_motion_relationship
  SUBTYPE OF (link_motion_relationship);
  SELF\representation_relationship.rep_1 : shape_representation;
  item : geometric_representation_item;
END_ENTITY;  

ENTITY link_motion_transformation
  SUBTYPE OF (item_defined_transformation);
  SELF\item_defined_transformation.transform_item_1 : rigid_placement;
  SELF\item_defined_transformation.transform_item_2 : kinematic_path;
END_ENTITY;

ENTITY link_motion_representation_along_path
  SUBTYPE OF (representation);
  SELF\representation.items : SET [1:?] OF kinematic_path;
  SELF\representation.context_of_items : geometric_representation_context_with_parameter;
END_ENTITY;

ENTITY geometric_representation_context_with_parameter 
  SUBTYPE OF (geometric_representation_context);
  parameter_unit : OPTIONAL unit;
END_ENTITY;

ENTITY kinematic_path
  ABSTRACT SUPERTYPE OF (ONEOF (kinematic_path_defined_by_nodes, kinematic_path_defined_by_curves))
  SUBTYPE OF (geometric_representation_item);
  segments : LIST [1:?] OF kinematic_path_segment;
  t_start : parameter_value;
DERIVE
  n_segments : INTEGER := SIZEOF(segments);
  closed_path : LOGICAL := segments[n_segments].transition <> discontinuous;
WHERE
  WR1: SIZEOF(QUERY(using_rep <* using_representations(SELF)| 
        NOT('KINEMATIC_MOTION_REPRESENTATION_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT_WITH_PARAMETER' IN TYPEOF(using_rep.context_of_items))))= 0;
  -- WR2 - parameters are increasing
  -- WR3 - different end positions
END_ENTITY;

ENTITY kinematic_path_defined_by_nodes
  SUBTYPE OF (kinematic_path);
  SELF\kinematic_path.segments : LIST [1:?] OF path_node;
  placement_start : placement;
END_ENTITY;  

ENTITY kinematic_path_defined_by_curves
  SUBTYPE OF (kinematic_path);
  SELF\kinematic_path.segments : LIST [1:?] OF curve_based_path_with_orientation;
END_ENTITY;  

ENTITY kinematic_path_segment
  ABSTRACT SUPERTYPE OF (ONEOF (
    path_node,
    curve_based_path_with_orientation) )
  SUBTYPE OF (founded_item);
  t_end : parameter_value;
  transition : transition_code;
END_ENTITY;

ENTITY path_parameter_representation
  SUBTYPE OF (definitional_representation);
  SELF\representation.context_of_items : path_parameter_representation_context;
  SELF\representation.items : SET[1:?] OF bounded_curve;
WHERE
  WR1: SELF\representation.context_of_items\geometric_representation_context.coordinate_space_dimension = 2;
END_ENTITY;

ENTITY path_parameter_representation_context
  SUBTYPE OF (geometric_representation_context, parametric_representation_context);
END_ENTITY;  

ENTITY path_node
  ABSTRACT SUPERTYPE OF (ONEOF (
    point_to_point_path,
    circular_path,
    linear_path,
    curve_based_path))
  SUBTYPE OF (kinematic_path_segment);
  placement_end : placement;
END_ENTITY;

ENTITY point_to_point_path
  SUBTYPE OF (path_node);
DERIVE
  SELF\kinematic_path_segment.transition : transition_code := discontinuous;
END_ENTITY;

ENTITY circular_path
  SUBTYPE OF (path_node);
  via_point : cartesian_point;
END_ENTITY;

ENTITY linear_path
  SUBTYPE OF (path_node);
DERIVE
  SELF\kinematic_path_segment.transition : transition_code := continuous;
END_ENTITY;

ENTITY curve_based_path
  SUBTYPE OF (path_node);
  path_curve : curve;
END_ENTITY;
-- IP1 : start and end point shall be on the curve

ENTITY curve_based_path_with_orientation
  SUBTYPE OF (kinematic_path_segment);
  position_curve : bounded_curve;
  orientation_curve : bounded_curve;
WHERE
  WR1: TYPEOF(position_curve) = TYPEOF(orientation_curve);
END_ENTITY;

ENTITY curve_based_path_with_orientation_and_parameters
  SUBTYPE OF (curve_based_path_with_orientation);
  parameters : path_parameter_representation;
END_ENTITY;  

SUBTYPE_CONSTRAINT kmr_representation_subtypes FOR representation;
  ONEOF (interpolated_configuration_representation, link_motion_representation_along_path);
END_SUBTYPE_CONSTRAINT; 

SUBTYPE_CONSTRAINT kmr_geometric_representation_item_subtypes FOR geometric_representation_item;
  ONEOF (
    kinematic_path,
    placement);
END_SUBTYPE_CONSTRAINT; 

SUBTYPE_CONSTRAINT kmr_geometric_representation_context_subtypes FOR geometric_representation_context;
  ONEOF (geometric_representation_context_with_parameter, path_parameter_representation_context);
END_SUBTYPE_CONSTRAINT; 

END_SCHEMA;   -- end kinematic_motion_representation_schema
(*
ISO TC184/SC4/WG12 N7302 - ISO/IS 10303-105 Kinematics - EXPRESS
*)

SCHEMA kinematic_property_schema;

REFERENCE FROM kinematic_structure_schema (
  kinematic_link_representation,
  kinematic_link_representation_association,
  mechanism_representation
);

REFERENCE FROM kinematic_topology_schema (
  kinematic_link,
  kinematic_topology_representation_select
);

REFERENCE FROM product_property_definition_schema (
  property_definition,
  product_definition_shape
);

REFERENCE FROM product_definition_schema (
  product_definition,
  product_definition_relationship
);

REFERENCE FROM product_property_representation_schema (
  property_definition_representation
);

REFERENCE FROM representation_schema (
    representation_relationship,
    using_representations);
     
ENTITY product_definition_kinematics
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : product_definition;
INVERSE
  representation_relation : kinematic_property_definition_representation FOR definition;
UNIQUE
  UR1 : definition;   
END_ENTITY;

ENTITY product_definition_relationship_kinematics
  SUBTYPE OF (property_definition);
  SELF\property_definition.definition : product_definition_relationship;
UNIQUE
  UR1 : definition;   
END_ENTITY;

ENTITY kinematic_property_definition_representation
  ABSTRACT SUPERTYPE OF ( ONEOF (kinematic_property_topology_representation, kinematic_property_mechanism_representation))
  SUBTYPE OF (property_definition_representation);
  SELF\property_definition_representation.definition : product_definition_kinematics; -- LK
END_ENTITY;

ENTITY kinematic_property_topology_representation
  SUBTYPE OF (kinematic_property_definition_representation);
  SELF\property_definition_representation.used_representation  : kinematic_topology_representation_select; 
  base : kinematic_link;
WHERE
  WR1: used_representation IN using_representations(base);
END_ENTITY;

ENTITY kinematic_property_mechanism_representation
  SUBTYPE OF (kinematic_property_definition_representation);
  SELF\property_definition_representation.used_representation  : mechanism_representation; 
  base : kinematic_link_representation;
WHERE
  WR1: SIZEOF( QUERY( i <* used_representation.items |
	(base :=: i\representation_relationship.rep_1) OR
	(base :=: i\representation_relationship.rep_2))) > 0;
END_ENTITY;

ENTITY context_dependent_kinematic_link_representation;
  representation_relation : kinematic_link_representation_association;
  represented_product_relation : product_definition_relationship_kinematics;
END_ENTITY; 

SUBTYPE_CONSTRAINT kps_property_definition_subtypes FOR property_definition;
  ONEOF (product_definition_kinematics,
         product_definition_relationship_kinematics,
         product_definition_shape);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;

(*
ISO TC184/SC4/WG12 N7302 - ISO/IS 10303-105 Kinematics - EXPRESS
*)

SCHEMA kinematic_state_schema;

REFERENCE FROM kinematic_structure_schema;

REFERENCE FROM geometry_schema
    (axis2_placement_3d,
     cartesian_transformation_operator_3d,
     curve,
     direction,
     geometric_representation_context,
     geometric_representation_item,
     normalise,
     point,
     point_on_curve,
     point_on_surface,
     surface,
     rectangular_trimmed_surface,
     trimmed_curve);

REFERENCE FROM measure_schema
    (conversion_based_unit,
     global_unit_assigned_context,
     length_measure,
     plane_angle_measure,
     si_prefix,
     si_unit,
     si_unit_name,
     unit);

REFERENCE FROM representation_schema
    (functionally_defined_transformation,
     item_defined_transformation,
     representation,
     representation_context,
     representation_item,
     representation_relationship,
     representation_relationship_with_transformation);

TYPE spatial_rotation = SELECT
  (ypr_rotation,
   rotation_about_direction);
END_TYPE;

TYPE ypr_rotation = ARRAY [ypr_index(yaw) : ypr_index(roll)]
                    OF plane_angle_measure;
END_TYPE;

TYPE ypr_enumeration = ENUMERATION OF
  (yaw,
   pitch,
   roll);
END_TYPE;

ENTITY mechanism_state_representation 
  SUBTYPE OF (representation);
  SELF\representation.items : SET[1:?] OF pair_value; 
  represented_mechanism : mechanism_representation;
DERIVE
  SELF\representation.context_of_items : geometric_representation_context := represented_mechanism.context_of_items;
END_ENTITY;

ENTITY pair_value
  ABSTRACT SUPERTYPE OF ( ONEOF (
	sliding_surface_pair_value,
	rolling_surface_pair_value,
	revolute_pair_value,
	prismatic_pair_value,
	screw_pair_value,
	cylindrical_pair_value,
	spherical_pair_value,
	sliding_curve_pair_value,
	rolling_curve_pair_value,
	gear_pair_value,
	rack_and_pinion_pair_value,
	universal_pair_value,
	planar_pair_value,
	unconstrained_pair_value,
	point_on_surface_pair_value,
	point_on_planar_curve_pair_value,
	low_order_kinematic_pair_value
  ))
  SUBTYPE OF (geometric_representation_item);
  applies_to_pair : kinematic_pair;
END_ENTITY;

ENTITY sliding_surface_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : sliding_surface_pair;
  actual_point_on_surface_1       : point_on_surface;
  actual_point_on_surface_2       : point_on_surface;
  actual_rotation                 : plane_angle_measure;
WHERE
  WR1: SELF\pair_value.applies_to_pair\surface_pair.surface_1 :=:
       actual_point_on_surface_1.basis_surface;
  WR2: SELF\pair_value.applies_to_pair\surface_pair.surface_2 :=:
       actual_point_on_surface_2.basis_surface;
END_ENTITY;

ENTITY rolling_surface_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : rolling_surface_pair;
  actual_point_on_surface         : point_on_surface;
  actual_rotation                 : plane_angle_measure;
WHERE
  WR1: SELF\pair_value.applies_to_pair\surface_pair.surface_1 :=:
       actual_point_on_surface.basis_surface;
END_ENTITY;

ENTITY revolute_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : revolute_pair;
  actual_rotation                 : plane_angle_measure ;
END_ENTITY;

ENTITY prismatic_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : prismatic_pair;
  actual_translation              : length_measure;
END_ENTITY;

ENTITY screw_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : screw_pair;
  actual_rotation                 : plane_angle_measure;
DERIVE
  actual_translation              : length_measure
                                  := SELF\pair_value.applies_to_pair\
                                     screw_pair.pitch *
                                     plane_angle_for_pair_in_radian
                                      (SELF\pair_value.applies_to_pair,
                                       actual_rotation) / (2 * PI);
END_ENTITY;

ENTITY cylindrical_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : cylindrical_pair;
  actual_translation              : length_measure;
  actual_rotation                 : plane_angle_measure;
END_ENTITY;

ENTITY low_order_kinematic_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : low_order_kinematic_pair;
  actual_translation_x            : length_measure;
  actual_translation_y            : length_measure;
  actual_translation_z            : length_measure;
  actual_rotation_x               : plane_angle_measure;
  actual_rotation_y               : plane_angle_measure;
  actual_rotation_z               : plane_angle_measure;
END_ENTITY;

TYPE spherical_pair_select = SELECT (
  spherical_pair,
  spherical_pair_with_pin);
END_TYPE;  

ENTITY spherical_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : spherical_pair_select;
  input_orientation               : spatial_rotation;
DERIVE
  actual_orientation              : ypr_rotation
                                  := convert_spatial_to_ypr_rotation
                                     (SELF\pair_value.applies_to_pair,
                                      input_orientation);
END_ENTITY;

ENTITY sliding_curve_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : sliding_curve_pair;
  actual_point_on_curve_1         : point_on_curve;
  actual_point_on_curve_2         : point_on_curve;
WHERE
  WR1: SELF\pair_value.applies_to_pair\planar_curve_pair.curve_1 :=:
       actual_point_on_curve_1.basis_curve;
  WR2: SELF\pair_value.applies_to_pair\planar_curve_pair.curve_2 :=:
       actual_point_on_curve_2.basis_curve;
END_ENTITY;

ENTITY rolling_curve_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : rolling_curve_pair;
  actual_point_on_curve_1         : point_on_curve;
WHERE
  WR1: SELF\pair_value.applies_to_pair\planar_curve_pair.curve_1 :=:
       actual_point_on_curve_1.basis_curve;
END_ENTITY;

ENTITY gear_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : gear_pair;
  actual_rotation_1               : plane_angle_measure;
DERIVE
  actual_rotation_2               : plane_angle_measure
                                  := - actual_rotation_1 *
                                     SELF\pair_value.applies_to_pair\
                                     gear_pair.gear_ratio;
END_ENTITY;

ENTITY rack_and_pinion_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : rack_and_pinion_pair;
  actual_displacement             : length_measure;
DERIVE
  actual_rotation : plane_angle_measure
   := 0.0; (*
                  := convert_plane_angle_for_pair_from_radian
                     (SELF\pair_value.applies_to_pair,
                      (- actual_displacement /
                       SELF\pair_value.applies_to_pair\
                       rack_and_pinion_pair.pinion_radius)); *)
END_ENTITY;

ENTITY universal_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : universal_pair;
  first_rotation_angle            : plane_angle_measure;
  second_rotation_angle           : plane_angle_measure;
END_ENTITY;

ENTITY planar_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : planar_pair;
  actual_rotation                 : plane_angle_measure;
  actual_translation_x            : length_measure;
  actual_translation_y            : length_measure;
END_ENTITY;

ENTITY unconstrained_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : unconstrained_pair;
  actual_placement                : axis2_placement_3d;
END_ENTITY;

ENTITY point_on_surface_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : point_on_surface_pair;
  actual_point_on_surface         : point_on_surface;
  input_orientation               : spatial_rotation;
DERIVE
  actual_orientation              : ypr_rotation
                                  := convert_spatial_to_ypr_rotation
                                     (SELF\pair_value.applies_to_pair,
                                      input_orientation);
WHERE
  WR1: SELF\pair_value.applies_to_pair\point_on_surface_pair.pair_surface :=:
       actual_point_on_surface.basis_surface;
END_ENTITY;

ENTITY point_on_planar_curve_pair_value
  SUBTYPE OF (pair_value);
  SELF\pair_value.applies_to_pair : point_on_planar_curve_pair;
  actual_point_on_curve           : point_on_curve;
  input_orientation               : spatial_rotation;
DERIVE
  actual_orientation              : ypr_rotation
                                  := convert_spatial_to_ypr_rotation
                                     (SELF\pair_value.applies_to_pair,
                                      input_orientation);
WHERE
  WR1: SELF\pair_value.applies_to_pair\point_on_planar_curve_pair.pair_curve
       :=: actual_point_on_curve.basis_curve;
END_ENTITY;

ENTITY rotation_about_direction
  SUBTYPE OF (geometric_representation_item); -- LK
  direction_of_axis : direction;
  rotation_angle    : plane_angle_measure;
WHERE
  WR1: SIZEOF (direction_of_axis.direction_ratios) = 3;
END_ENTITY;

FUNCTION convert_spatial_to_ypr_rotation (pair     : kinematic_pair;
                                          rotation : spatial_rotation)
                                                   : ypr_rotation;
  LOCAL
    axis       : direction;
    angle      : plane_angle_measure;   -- rotation angle in application
                                        -- specific units
    conv_angle : plane_angle_measure;   -- rotation angle in radians
    ya, pa, ra : plane_angle_measure;   -- yaw, pitch, and roll angle
    ucf        : REAL;                  -- unit conversion factor
    dx, dy, dz : REAL;                  -- components of direction vector
    s_a, c_a   : REAL;                  -- sine and cosine of rotation angle
    rotmat     : ARRAY [1 : 3] OF
                 ARRAY [1 : 3] OF REAL; -- rotation matrix
    cm1        : REAL;
    s_y, c_y   : REAL;
    s_r, c_r   : REAL;
  END_LOCAL;

  -- If rotation is already a ypr_rotation, return it immediately
  IF 'KINEMATIC_STRUCTURE_SCHEMA.YPR_ROTATION' IN TYPEOF (rotation) THEN
    RETURN (rotation);
  END_IF;

  -- rotation is a rotation_about_direction

  axis  := normalise (rotation\rotation_about_direction.direction_of_axis);
  angle := rotation\rotation_about_direction.rotation_angle;

  -- a zero rotation is converted trivially
  IF (angle = 0.0) THEN
    RETURN ([0.0, 0.0, 0.0]);
  END_IF;

  dx := axis.direction_ratios[1];
  dy := axis.direction_ratios[2];
  dz := axis.direction_ratios[3];

  -- provide angle measured in radian

  conv_angle := plane_angle_for_pair_in_radian (pair, angle);

  IF NOT('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(conv_angle)) THEN
    RETURN (?);
  END_IF;

  ucf := angle / conv_angle;
  s_a := SIN (conv_angle);
  c_a := COS (conv_angle);

  -- axis parallel either to x-axis or to z-axis?
  IF (dy = 0.0) AND (dx * dz = 0.0) THEN
    REPEAT WHILE (conv_angle <= - PI);
      conv_angle := conv_angle + 2.0 * PI;
    END_REPEAT;
    REPEAT WHILE (conv_angle > PI);
      conv_angle := conv_angle - 2.0 * PI;
    END_REPEAT;

    ya := ucf * conv_angle;
    IF (conv_angle <> PI) THEN
      ra := - ya;
    ELSE
      ra := ya;
    END_IF;

    IF (dx <> 0.0) THEN
      -- axis parallel to x-axis - use x-axis as roll axis
      IF (dx > 0.0) THEN
        RETURN ([0.0, 0.0, ya]);
      ELSE
        RETURN ([0.0, 0.0, ra]);
      END_IF;
    ELSE
      -- axis parallel to z-axis - use z-axis as yaw axis
      IF (dz > 0.0) THEN
        RETURN ([ya, 0.0, 0.0]);
      ELSE
        RETURN ([ra, 0.0, 0.0]);
      END_IF;
    END_IF;
  END_IF;

  -- axis parallel to y-axis - use y-axis as pitch axis
  IF ((dy <> 0.0) AND (dx = 0.0) AND (dz = 0.0)) THEN
    IF (c_a >= 0.0) THEN
      ya := 0.0;
      ra := 0.0;
    ELSE
      ya := ucf * PI;
      ra := ya;
    END_IF;

    pa := ucf * ATAN (s_a, ABS (c_a));
    IF (dy < 0.0) THEN
      pa := - pa;
    END_IF;

    RETURN ([ya, pa, ra]);
  END_IF;

  -- axis not parallel to any axis of coordinate system
  -- compute rotation matrix

  cm1 := 1.0 - c_a;

  rotmat := [ [ dx * dx * cm1 + c_a,
                dx * dy * cm1 - dz * s_a,
                dx * dz * cm1 + dy * s_a ],
              [ dx * dy * cm1 + dz * s_a,
                dy * dy * cm1 + c_a,
                dy * dz * cm1 - dx * s_a ],
              [ dx * dz * cm1 - dy * s_a,
                dy * dz * cm1 + dx * s_a,
                dz * dz * cm1 + c_a ] ];

  -- rotmat[1][3] equals SIN (pitch_angle)
  IF (ABS (rotmat[1][3]) = 1.0) THEN
    -- |pa| = PI/2
    BEGIN
      IF (rotmat[1][3] = 1.0) THEN
        pa := 0.5 * PI;
      ELSE
        pa := -0.5 * PI;
      END_IF;

      -- In this case, only the sum or difference of roll and yaw angles
      -- is relevant and can be evaluated from the matrix.
      -- According to IP `rectangular pitch angle' for ypr_rotation,
      -- the roll angle is set to zero.

      ra := 0.0;
      ya := ATAN (rotmat[2][1], rotmat[2][2]);

      -- result of ATAN is in the range [-PI/2, PI/2].
      -- Here all four quadrants are needed.

      IF (rotmat[2][2] < 0.0) THEN
        IF ya <= 0.0 THEN
          ya := ya + PI;
        ELSE
          ya := ya - PI;
        END_IF;
      END_IF;
    END;
  ELSE
    -- COS (pitch_angle) not equal to zero
    BEGIN
      ya := ATAN (- rotmat[1][2], rotmat[1][1]);

      IF (rotmat[1][1] < 0.0) THEN
        IF (ya <= 0.0) THEN
          ya := ya + PI;
        ELSE
          ya := ya - PI;
        END_IF;
      END_IF;

      ra := ATAN (-rotmat[2][3], rotmat[3][3]);

      IF (rotmat[3][3] < 0.0) THEN
        IF (ra <= 0.0) THEN
          ra := ra + PI;
        ELSE
          ra := ra - PI;
        END_IF;
      END_IF;

      s_y := SIN (ya);
      c_y := COS (ya);
      s_r := SIN (ra);
      c_r := COS (ra);

      IF ((ABS (s_y) > ABS (c_y)) AND
          (ABS (s_y) > ABS (s_r)) AND
          (ABS (s_y) > ABS (c_r))) THEN
        cm1 := - rotmat[1][2] / s_y;
      ELSE
        IF ((ABS (c_y) > ABS (s_r)) AND (ABS (c_y) > ABS (c_r))) THEN
          cm1 := rotmat[1][1] / c_y;
        ELSE
          IF (ABS (s_r) > ABS (c_r)) THEN
            cm1 := - rotmat[2][3] / s_r;
          ELSE
            cm1 := rotmat[3][3] / c_r;
          END_IF;
        END_IF;
      END_IF;

      pa := ATAN (rotmat[1][3], cm1);

    END;
  END_IF;

  ya := ya * ucf;
  pa := pa * ucf;
  ra := ra * ucf;

  RETURN ([ya, pa, ra]);

END_FUNCTION;

FUNCTION ypr_index (ypr : ypr_enumeration) : INTEGER;
  CASE ypr OF
    yaw    : RETURN (1);
    pitch  : RETURN (2);
    roll   : RETURN (3);
  END_CASE;
  RETURN (?);
END_FUNCTION;


SUBTYPE_CONSTRAINT kss_geometric_representation_item_subtypes FOR geometric_representation_item;
  ONEOF (
         rotation_about_direction,
         su_parameters);
END_SUBTYPE_CONSTRAINT;


END_SCHEMA;

(*
ISO TC184/SC4/WG12 N7302 - ISO/IS 10303-105 Kinematics - EXPRESS
*)

SCHEMA kinematic_structure_schema;

REFERENCE FROM kinematic_topology_schema; 

REFERENCE FROM geometry_schema
    (axis2_placement_3d,
     cartesian_transformation_operator_3d,
     curve,
     direction,
     geometric_representation_context,
     geometric_representation_item,
     normalise,
     point,
     point_on_curve,
     point_on_surface,
     surface,
     rectangular_trimmed_surface,
     trimmed_curve);

REFERENCE FROM measure_schema
    (conversion_based_unit,
     global_unit_assigned_context,
     length_measure,
     plane_angle_measure,
     si_prefix,
     si_unit,
     si_unit_name,
     unit);

REFERENCE FROM product_property_definition_schema
    (characterized_definition,
     property_definition);

REFERENCE FROM product_property_representation_schema
    (property_definition_representation,
     shape_representation);

REFERENCE FROM representation_schema
    (definitional_representation_relationship,
     functionally_defined_transformation,
     item_defined_transformation,
     representation,
     representation_context,
     representation_item,
     representation_relationship,
     representation_relationship_with_transformation,
     using_representations);

REFERENCE FROM support_resource_schema
    (bag_to_set,
     label);

TYPE rigid_placement = SELECT
  (axis2_placement_3d,
   su_parameters);
END_TYPE;

ENTITY mechanism_representation 
  SUBTYPE OF (representation);
  SELF\representation.context_of_items : geometric_representation_context;
  SELF\representation.items : SET[1:?] OF pair_representation_relationship;
  represented_topology : kinematic_topology_representation_select;
DERIVE
  represented_joints : SET[1:?] OF kinematic_joint := collect_joints(items); 
WHERE  
  WR1: (('KINEMATIC_TOPOLOGY_SCHEMA.KINEMATIC_TOPOLOGY_STRUCTURE' IN TYPEOF(represented_topology))
         AND (represented_joints :=: represented_topology.items)) OR
       (('KINEMATIC_TOPOLOGY_SCHEMA.KINEMATIC_TOPOLOGY_DIRECTED_STRUCTURE' IN TYPEOF(represented_topology))
         AND (represented_joints :=: get_kinematic_joints_from_oriented_joints(represented_topology.items))) OR
       (('KINEMATIC_TOPOLOGY_SCHEMA.KINEMATIC_TOPOLOGY_NETWORK_STRUCTURE' IN TYPEOF(represented_topology))
         AND (represented_joints :=: get_kinematic_joints_from_kinematic_loops(represented_topology.items)));          
END_ENTITY;

ENTITY pair_representation_relationship
  SUBTYPE OF (geometric_representation_item, representation_relationship_with_transformation);
  SELF\representation_relationship.rep_1 : kinematic_link_representation;
  SELF\representation_relationship.rep_2 : kinematic_link_representation;
  SELF\representation_relationship_with_transformation.transformation_operator : kinematic_pair;
WHERE
  WR1: transformation_operator\item_defined_transformation.transform_item_1 IN rep_1.items;
  WR2: transformation_operator\item_defined_transformation.transform_item_2 IN rep_2.items;
  WR3: rep_1\kinematic_link_representation.represented_link = transformation_operator\kinematic_pair.joint.edge_start; 
  WR4: rep_2\kinematic_link_representation.represented_link = transformation_operator\kinematic_pair.joint.edge_end; 
END_ENTITY;

TYPE kinematic_link_representation_items = SELECT (
  curve,
  point,
  rigid_placement,
  surface);
END_TYPE;
  
ENTITY kinematic_link_representation
  ABSTRACT SUPERTYPE OF ( ONEOF (linear_flexible_link_representation, rigid_link_representation))
  SUBTYPE OF (representation);
  SELF\representation.context_of_items : geometric_representation_context;
  SELF\representation.items : SET[1:?] OF kinematic_link_representation_items;
  represented_link : kinematic_link;
INVERSE
  associated_shape_representation : SET[0:1] OF -- LK       
        kinematic_link_representation_association FOR rep_1;
END_ENTITY;

ENTITY linear_flexible_link_representation
  SUBTYPE OF (kinematic_link_representation);
END_ENTITY;

ENTITY rigid_link_representation
  SUBTYPE OF (kinematic_link_representation);
END_ENTITY;

ENTITY kinematic_link_representation_association
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 : kinematic_link_representation;
  SELF\representation_relationship.rep_2 : shape_representation; 
WHERE
  WR1: (SELF\representation_relationship.rep_2.context_of_items :=:
        SELF\representation_relationship.rep_1.context_of_items) OR
       ('REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF)); 
END_ENTITY;

ENTITY su_parameters
  SUBTYPE OF (geometric_representation_item);
  a     : length_measure;
  alpha : plane_angle_measure;
  b     : length_measure;
  beta  : plane_angle_measure;
  c     : length_measure;
  gamma : plane_angle_measure;
WHERE
  WR1: SELF\geometric_representation_item.dim=3;
END_ENTITY;

ENTITY kinematic_pair
  ABSTRACT SUPERTYPE OF( ONEOF (
      high_order_kinematic_pair, 
      low_order_kinematic_pair_with_motion_coupling, 
      low_order_kinematic_pair) 
    ANDOR actuated_kinematic_pair)  
  SUBTYPE OF (geometric_representation_item, item_defined_transformation);
  joint : kinematic_joint;
  SELF\item_defined_transformation.transform_item_1 : rigid_placement;
  SELF\item_defined_transformation.transform_item_2 : rigid_placement;
DERIVE
  associated_link_representations_1 : SET[1:?] OF kinematic_link_representation :=
    sort_link_associations(link_representation_associations, TRUE);
  associated_link_representations_2 : SET[1:?] OF kinematic_link_representation :=
    sort_link_associations(link_representation_associations, FALSE);
  SELF\item_defined_transformation.name : label := SELF\representation_item.name;
INVERSE
  link_representation_associations : SET[1:?] OF pair_representation_relationship FOR transformation_operator; 
END_ENTITY;

ENTITY high_order_kinematic_pair
  ABSTRACT SUPERTYPE OF( ONEOF (
    linear_flexible_and_planar_curve_pair,
    point_on_surface_pair,
    point_on_planar_curve_pair,
    planar_curve_pair,
    surface_pair
  ))
  SUBTYPE OF (kinematic_pair);
WHERE
  WR1: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_2 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY low_order_kinematic_pair_with_motion_coupling
  ABSTRACT SUPERTYPE OF( ONEOF (
    gear_pair,
    linear_flexible_and_pinion_pair,
    rack_and_pinion_pair,
    screw_pair
  ))
  SUBTYPE OF (kinematic_pair);
WHERE
  WR1: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_2 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY low_order_kinematic_pair
  SUPERTYPE OF( ONEOF (
    revolute_pair,
    cylindrical_pair,
    spherical_pair,
    spherical_pair_with_pin,
    planar_pair,
    unconstrained_pair,
    fully_constrained_pair,
    prismatic_pair,
    universal_pair,
    low_order_kinematic_pair_with_range
    ))  
  SUBTYPE OF (kinematic_pair);
  t_x : BOOLEAN;
  t_y : BOOLEAN;
  t_z : BOOLEAN;
  r_x : BOOLEAN;
  r_y : BOOLEAN;
  r_z : BOOLEAN;
WHERE
  WR1: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
  WR2: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_2 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY low_order_kinematic_pair_with_range
  SUBTYPE OF (low_order_kinematic_pair);
  lower_limit_actual_rotation_x          : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation_x          : OPTIONAL plane_angle_measure;
  lower_limit_actual_rotation_y          : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation_y          : OPTIONAL plane_angle_measure;
  lower_limit_actual_rotation_z          : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation_z          : OPTIONAL plane_angle_measure;
  lower_limit_actual_translation_x       : OPTIONAL length_measure;
  upper_limit_actual_translation_x       : OPTIONAL length_measure;
  lower_limit_actual_translation_y       : OPTIONAL length_measure;
  upper_limit_actual_translation_y       : OPTIONAL length_measure;
  lower_limit_actual_translation_z       : OPTIONAL length_measure;
  upper_limit_actual_translation_z       : OPTIONAL length_measure;
END_ENTITY;

TYPE actuated_direction = ENUMERATION OF (
	bidirectional,
	positive_only,
	negative_only,
	not_actuated);
END_TYPE;
   
ENTITY actuated_kinematic_pair
  SUBTYPE OF (kinematic_pair);
  t_x : OPTIONAL actuated_direction;
  t_y : OPTIONAL actuated_direction;
  t_z : OPTIONAL actuated_direction;
  r_x : OPTIONAL actuated_direction;
  r_y : OPTIONAL actuated_direction;
  r_z : OPTIONAL actuated_direction;
END_ENTITY;

ENTITY revolute_pair_with_range
  SUBTYPE OF (revolute_pair);
  lower_limit_actual_rotation            : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation            : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_actual_rotation)
        OR
        NOT EXISTS(upper_limit_actual_rotation))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
END_ENTITY;

ENTITY prismatic_pair_with_range
  SUBTYPE OF (prismatic_pair);
  lower_limit_actual_translation         : OPTIONAL length_measure;
  upper_limit_actual_translation         : OPTIONAL length_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_actual_translation)
        OR
        NOT EXISTS(upper_limit_actual_translation))
       XOR
       (lower_limit_actual_translation < upper_limit_actual_translation);
END_ENTITY;

ENTITY revolute_pair
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := TRUE;
END_ENTITY;

ENTITY prismatic_pair
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := FALSE;
END_ENTITY;

ENTITY screw_pair
  SUBTYPE OF (low_order_kinematic_pair_with_motion_coupling);
  pitch : length_measure;
WHERE
  WR1: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY screw_pair_with_range
  SUBTYPE OF (screw_pair);
  lower_limit_actual_rotation            : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation            : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_actual_rotation)
        OR
        NOT EXISTS(upper_limit_actual_rotation))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
END_ENTITY;

ENTITY cylindrical_pair
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := TRUE;
END_ENTITY;

ENTITY cylindrical_pair_with_range
  SUBTYPE OF (cylindrical_pair);
  lower_limit_actual_translation         : OPTIONAL length_measure;
  upper_limit_actual_translation         : OPTIONAL length_measure;
  lower_limit_actual_rotation            : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation            : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_actual_translation)
        OR
        NOT EXISTS(upper_limit_actual_translation))
       XOR
       (lower_limit_actual_translation < upper_limit_actual_translation);
  WR2: (NOT EXISTS(lower_limit_actual_rotation)
        OR
        NOT EXISTS(upper_limit_actual_rotation))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
END_ENTITY;

ENTITY spherical_pair
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := TRUE;
END_ENTITY;

ENTITY spherical_pair_with_range
  SUBTYPE OF (spherical_pair);
  lower_limit_yaw                        : OPTIONAL plane_angle_measure;
  upper_limit_yaw                        : OPTIONAL plane_angle_measure;
  lower_limit_pitch                      : OPTIONAL plane_angle_measure;
  upper_limit_pitch                      : OPTIONAL plane_angle_measure;
  lower_limit_roll                       : OPTIONAL plane_angle_measure;
  upper_limit_roll                       : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_yaw)
        OR
        NOT EXISTS(upper_limit_yaw))
       XOR
       (lower_limit_yaw < upper_limit_yaw);
  WR2: (NOT EXISTS(lower_limit_pitch)
        OR
        NOT EXISTS(upper_limit_pitch))
       XOR
       (lower_limit_pitch < upper_limit_pitch);
  WR3: (NOT EXISTS(lower_limit_roll)
        OR
        NOT EXISTS(upper_limit_roll))
       XOR
       (lower_limit_roll < upper_limit_roll);
END_ENTITY;

ENTITY spherical_pair_with_pin
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := TRUE;
END_ENTITY;

ENTITY spherical_pair_with_pin_and_range
  SUBTYPE OF (spherical_pair_with_pin);
  lower_limit_yaw                        : OPTIONAL plane_angle_measure;
  upper_limit_yaw                        : OPTIONAL plane_angle_measure;
  lower_limit_roll                       : OPTIONAL plane_angle_measure;
  upper_limit_roll                       : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_yaw)
        OR
        NOT EXISTS(upper_limit_yaw))
       XOR
       (lower_limit_yaw < upper_limit_yaw);
  WR2: (NOT EXISTS(lower_limit_roll)
        OR
        NOT EXISTS(upper_limit_roll))
       XOR
       (lower_limit_roll < upper_limit_roll);
END_ENTITY;

ENTITY universal_pair
  SUBTYPE OF (low_order_kinematic_pair);
  input_skew_angle : OPTIONAL plane_angle_measure;
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := TRUE;     
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := TRUE;
  skew_angle : plane_angle_measure := NVL (input_skew_angle, 0.0);
WHERE
  WR1: COS (plane_angle_for_pair_in_radian (SELF, skew_angle))
       > 0.0;
END_ENTITY;

ENTITY universal_pair_with_range
  SUBTYPE OF (universal_pair);
  lower_limit_first_rotation             : OPTIONAL plane_angle_measure;
  upper_limit_first_rotation             : OPTIONAL plane_angle_measure;
  lower_limit_second_rotation            : OPTIONAL plane_angle_measure;
  upper_limit_second_rotation            : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_first_rotation)
        OR
        NOT EXISTS(upper_limit_first_rotation))
       XOR
       (lower_limit_first_rotation < upper_limit_first_rotation);
  WR2: (NOT EXISTS(lower_limit_second_rotation)
        OR
        NOT EXISTS(upper_limit_second_rotation))
       XOR
       (lower_limit_second_rotation < upper_limit_second_rotation);
END_ENTITY;

ENTITY homokinetic_pair
  SUBTYPE OF (universal_pair);
WHERE
  WR1:  NOT EXISTS(SELF.input_skew_angle);       
END_ENTITY;

ENTITY planar_pair
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := TRUE;
END_ENTITY;

ENTITY planar_pair_with_range
  SUBTYPE OF (planar_pair);
  lower_limit_actual_rotation            : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation            : OPTIONAL plane_angle_measure;
  lower_limit_actual_translation_x       : OPTIONAL length_measure;
  upper_limit_actual_translation_x       : OPTIONAL length_measure;
  lower_limit_actual_translation_y       : OPTIONAL length_measure;
  upper_limit_actual_translation_y       : OPTIONAL length_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_actual_rotation)
        OR
        NOT EXISTS(upper_limit_actual_rotation))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
  WR2: (NOT EXISTS(lower_limit_actual_translation_x)
        OR
        NOT EXISTS(upper_limit_actual_translation_x))
       XOR
       (lower_limit_actual_translation_x < upper_limit_actual_translation_x);
  WR3: (NOT EXISTS(lower_limit_actual_translation_y)
        OR
        NOT EXISTS(upper_limit_actual_translation_y))
       XOR
       (lower_limit_actual_translation_y < upper_limit_actual_translation_y);
END_ENTITY;

ENTITY unconstrained_pair
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := TRUE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := TRUE;
END_ENTITY;

ENTITY fully_constrained_pair
  SUBTYPE OF (low_order_kinematic_pair);
DERIVE  
  SELF\low_order_kinematic_pair.t_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.t_z : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_x : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_y : BOOLEAN := FALSE;
  SELF\low_order_kinematic_pair.r_z : BOOLEAN := FALSE;
END_ENTITY;

ENTITY point_on_surface_pair
  SUBTYPE OF (high_order_kinematic_pair);
  pair_surface : surface;
WHERE
  WR1: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(pair_surface IN r.items))) = 0;
  WR2: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY point_on_surface_pair_with_range
  SUBTYPE OF (point_on_surface_pair);
  range_on_pair_surface                  : rectangular_trimmed_surface;
  lower_limit_yaw                        : OPTIONAL plane_angle_measure;
  upper_limit_yaw                        : OPTIONAL plane_angle_measure;
  lower_limit_pitch                      : OPTIONAL plane_angle_measure;
  upper_limit_pitch                      : OPTIONAL plane_angle_measure;
  lower_limit_roll                       : OPTIONAL plane_angle_measure;
  upper_limit_roll                       : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_pitch)
        OR
        NOT EXISTS(upper_limit_pitch))
       XOR
       (lower_limit_pitch < upper_limit_pitch);
  WR2: (NOT EXISTS(lower_limit_yaw)
        OR
        NOT EXISTS(upper_limit_yaw))
       XOR
       (lower_limit_yaw < upper_limit_yaw);
  WR3: (NOT EXISTS(lower_limit_roll)
        OR
        NOT EXISTS(upper_limit_roll))
       XOR
       (lower_limit_roll < upper_limit_roll);
  WR4: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(range_on_pair_surface IN r.items))) = 0;
END_ENTITY;

ENTITY surface_pair
  ABSTRACT SUPERTYPE OF ( ONEOF (sliding_surface_pair, rolling_surface_pair) ANDOR surface_pair_with_range)
  SUBTYPE OF (high_order_kinematic_pair);
  surface_1   : surface;
  surface_2   : surface;
  orientation : BOOLEAN;
WHERE
  WR1: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(surface_1 IN r.items))) = 0;
  WR2: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_2 | NOT(surface_2 IN r.items))) = 0;
  WR3: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY surface_pair_with_range
  SUBTYPE OF (surface_pair);
  range_on_surface_1                     : rectangular_trimmed_surface;
  range_on_surface_2                     : rectangular_trimmed_surface;
  lower_limit_actual_rotation            : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation            : OPTIONAL plane_angle_measure;
WHERE
  WR1: SELF\surface_pair.surface_1 :=: range_on_surface_1.basis_surface;
  WR2: SELF\surface_pair.surface_2 :=: range_on_surface_2.basis_surface;
  WR3: (NOT EXISTS(lower_limit_actual_rotation)
        OR
        NOT EXISTS(upper_limit_actual_rotation))
       XOR
       (lower_limit_actual_rotation < upper_limit_actual_rotation);
  WR4: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(range_on_surface_1 IN r.items))) = 0;
  WR5: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_2 | NOT(range_on_surface_2 IN r.items))) = 0;
END_ENTITY;

ENTITY sliding_surface_pair
  SUBTYPE OF (surface_pair);
END_ENTITY;

ENTITY rolling_surface_pair
  SUBTYPE OF (surface_pair);
END_ENTITY;

ENTITY linear_flexible_and_planar_curve_pair
  SUBTYPE OF (high_order_kinematic_pair);
  pair_curve  : curve;
  orientation : BOOLEAN;
WHERE
  WR1: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(pair_curve IN r.items))) = 0;
  WR2: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.LINEAR_FLEXIBLE_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY point_on_planar_curve_pair
  SUBTYPE OF (high_order_kinematic_pair);
  pair_curve  : curve;
  orientation : BOOLEAN;
WHERE
  WR1: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(pair_curve IN r.items))) = 0;
  WR2: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY point_on_planar_curve_pair_with_range
  SUBTYPE OF (point_on_planar_curve_pair);
  range_on_pair_curve                    : trimmed_curve;
  lower_limit_yaw                        : OPTIONAL plane_angle_measure;
  upper_limit_yaw                        : OPTIONAL plane_angle_measure;
  lower_limit_pitch                      : OPTIONAL plane_angle_measure;
  upper_limit_pitch                      : OPTIONAL plane_angle_measure;
  lower_limit_roll                       : OPTIONAL plane_angle_measure;
  upper_limit_roll                       : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_pitch)
        OR
        NOT EXISTS(upper_limit_pitch))
       XOR
       (lower_limit_pitch < upper_limit_pitch);
  WR2: (NOT EXISTS(lower_limit_yaw)
        OR
        NOT EXISTS(upper_limit_yaw))
       XOR
       (lower_limit_yaw < upper_limit_yaw);
  WR3: (NOT EXISTS(lower_limit_roll)
        OR
        NOT EXISTS(upper_limit_roll))
       XOR
       (lower_limit_roll < upper_limit_roll);
  WR4: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(range_on_pair_curve IN r.items))) = 0;
END_ENTITY;

ENTITY planar_curve_pair
  SUPERTYPE OF ( ONEOF(sliding_curve_pair, rolling_curve_pair) ANDOR planar_curve_pair_range)
  SUBTYPE OF (high_order_kinematic_pair);
  curve_1     : curve;
  curve_2     : curve;
  orientation : BOOLEAN;
WHERE
  WR1: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(curve_1 IN r.items))) = 0;
  WR2: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_2 | NOT(curve_2 IN r.items))) = 0;
  WR3: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY planar_curve_pair_range
  SUBTYPE OF (planar_curve_pair);
  range_on_curve_1                       : trimmed_curve;
  range_on_curve_2                       : trimmed_curve;
WHERE
  WR1: SELF\planar_curve_pair.curve_1 :=: range_on_curve_1.basis_curve;
  WR2: SELF\planar_curve_pair.curve_2 :=: range_on_curve_2.basis_curve;
  WR3: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_1 | NOT(range_on_curve_1 IN r.items))) = 0;
  WR4: SIZEOF( QUERY(r <* SELF\kinematic_pair.associated_link_representations_2 | NOT(range_on_curve_2 IN r.items))) = 0;
END_ENTITY;

ENTITY sliding_curve_pair
  SUBTYPE OF (planar_curve_pair);
END_ENTITY;

ENTITY rolling_curve_pair
  SUBTYPE OF (planar_curve_pair);
END_ENTITY;

ENTITY gear_pair
  SUBTYPE OF (low_order_kinematic_pair_with_motion_coupling);
  radius_first_link  : length_measure;
  radius_second_link : length_measure;
  bevel              : plane_angle_measure;
  helical_angle      : plane_angle_measure;
  gear_ratio         : REAL;
WHERE
  WR1: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY gear_pair_with_range
  SUBTYPE OF (gear_pair);
  lower_limit_actual_rotation_1          : OPTIONAL plane_angle_measure;
  upper_limit_actual_rotation_1          : OPTIONAL plane_angle_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_actual_rotation_1)
        OR
        NOT EXISTS(upper_limit_actual_rotation_1))
       XOR
       (lower_limit_actual_rotation_1 < upper_limit_actual_rotation_1);
END_ENTITY;

ENTITY rack_and_pinion_pair
  SUBTYPE OF (low_order_kinematic_pair_with_motion_coupling);
  pinion_radius : length_measure;
WHERE
  WR1: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.RIGID_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

ENTITY rack_and_pinion_pair_with_range
  SUBTYPE OF (rack_and_pinion_pair);
  lower_limit_rack_displacement          : OPTIONAL length_measure;
  upper_limit_rack_displacement          : OPTIONAL length_measure;
WHERE
  WR1: (NOT EXISTS(lower_limit_rack_displacement)
        OR
        NOT EXISTS(upper_limit_rack_displacement))
       XOR
       (lower_limit_rack_displacement < upper_limit_rack_displacement);
END_ENTITY;

ENTITY linear_flexible_and_pinion_pair
  SUBTYPE OF (low_order_kinematic_pair_with_motion_coupling);
  pinion_radius : length_measure;
WHERE
  WR1: SIZEOF( QUERY(lr <* SELF\kinematic_pair.associated_link_representations_1 | 
    NOT('KINEMATIC_STRUCTURE_SCHEMA.LINEAR_FLEXIBLE_LINK_REPRESENTATION' IN TYPEOF(lr)))) = 0;
END_ENTITY;

FUNCTION representation_of_link (link : kinematic_link)
    : kinematic_link_representation;
(*
  LOCAL
    link_rep_rel : BAG OF kinematic_link_representation_relation;
  END_LOCAL;

  link_rep_rel := USEDIN (link, 'KINEMATIC_STRUCTURE_SCHEMA.'+
                                'KINEMATIC_LINK_REPRESENTATION_RELATION.'+
                                'TOPOLOGICAL_ASPECTS');
  IF (SIZEOF (link_rep_rel) = 0) THEN
    RETURN (?);
  ELSE
    RETURN (link_rep_rel[1].geometric_aspects);
  END_IF;
*)
  RETURN (?);
END_FUNCTION;


FUNCTION plane_angle_for_pair_in_radian
         (pair  : kinematic_pair;
          angle : plane_angle_measure) : plane_angle_measure;
  LOCAL
    converted_angle : plane_angle_measure := angle;
    link_rep        : kinematic_link_representation
                    := representation_of_link (pair.joint.edge_start);
    link_cntxt      : representation_context;
    pa_units        : SET OF unit := [];
    pau             : unit;
  END_LOCAL;

  link_cntxt := link_rep\representation.context_of_items;

  IF NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
          IN TYPEOF (link_cntxt)) THEN
    RETURN (?);
  END_IF;

  pa_units := QUERY (unit <* link_cntxt\global_unit_assigned_context.units |
                     'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (unit));

  IF SIZEOF (pa_units) <> 1 THEN
    RETURN (?);
  END_IF;

  pau := pa_units[1];

  IF (NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
      NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) THEN
    RETURN (?);
  END_IF;

  REPEAT WHILE ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau));
    converted_angle := converted_angle *
                       pau\conversion_based_unit.conversion_factor.
                       value_component;
    pau := pau\conversion_based_unit.conversion_factor.unit_component;

    IF ((NOT ('MEASURE_SCHEMA.SI_UNIT' IN TYPEOF (pau)) AND
         NOT ('MEASURE_SCHEMA.CONVERSION_BASED_UNIT' IN TYPEOF (pau))) OR
        (NOT ('MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (pau)))) THEN
      RETURN (?);
    END_IF;
  END_REPEAT;

  IF (pau\si_unit.name <> si_unit_name.radian) THEN
    RETURN (?);
  END_IF;

  CASE pau\si_unit.prefix OF
    si_prefix.exa     : RETURN (1.E18 * converted_angle);
    si_prefix.peta    : RETURN (1.E15 * converted_angle);
    si_prefix.tera    : RETURN (1.E12 * converted_angle);
    si_prefix.giga    : RETURN (1.E9 * converted_angle);
    si_prefix.mega    : RETURN (1.E6 * converted_angle);
    si_prefix.kilo    : RETURN (1.E3 * converted_angle);
    si_prefix.hecto   : RETURN (1.E2 * converted_angle);
    si_prefix.deca    : RETURN (1.E1 * converted_angle);
    si_prefix.deci    : RETURN (1.E-1 * converted_angle);
    si_prefix.centi   : RETURN (1.E-2 * converted_angle);
    si_prefix.milli   : RETURN (1.E-3 * converted_angle);
    si_prefix.micro   : RETURN (1.E-6 * converted_angle);
    si_prefix.nano    : RETURN (1.E-9 * converted_angle);
    si_prefix.pico    : RETURN (1.E-12 * converted_angle);
    si_prefix.femto   : RETURN (1.E-15 * converted_angle);
    si_prefix.atto    : RETURN (1.E-18 * converted_angle);
  OTHERWISE           : RETURN (converted_angle);
  END_CASE;

END_FUNCTION;

FUNCTION sort_link_associations 
  (aprr : SET[1:?] OF pair_representation_relationship; one_not_two : boolean) : SET OF kinematic_link_representation;
LOCAL
  result : SET OF kinematic_link_representation := [];
END_LOCAL;
  IF one_not_two THEN
    REPEAT i := 1 TO HIINDEX(aprr);
      result := result + aprr[i].rep_1;
    END_REPEAT;
  ELSE  
    REPEAT i := 1 TO HIINDEX(aprr);
      result := result + aprr[i].rep_2;
    END_REPEAT;
  END_IF;
  RETURN(result);
END_FUNCTION;

FUNCTION collect_joints 
  (items : SET[1:?] OF pair_representation_relationship) : SET OF kinematic_joint;
LOCAL
  result : SET OF kinematic_joint := [];
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(items);
    result := result + items[i].transformation_operator.joint;
  END_REPEAT;
  RETURN(result);
END_FUNCTION;

SUBTYPE_CONSTRAINT kss_representation_subtypes FOR representation;
  ONEOF (kinematic_link_representation,
         kinematic_topology_structure,
         kinematic_topology_directed_structure,
         kinematic_topology_network_structure,
         mechanism_representation,
         shape_representation);
END_SUBTYPE_CONSTRAINT;

END_SCHEMA;         -- end kinematic_structure_schema
(*
ISO TC184/SC4/WG12 N7302 - ISO/IS 10303-105 Kinematics - EXPRESS
*)

SCHEMA kinematic_topology_schema;

REFERENCE FROM representation_schema (
	representation
);

REFERENCE FROM topology_schema -- LK
    (connected_edge_set,
     edge,
     edge_loop,
     oriented_edge,
     path,
     vertex);

TYPE kinematic_topology_representation_select = SELECT (
  kinematic_topology_structure,
  kinematic_topology_directed_structure,
  kinematic_topology_network_structure
);
END_TYPE;

ENTITY kinematic_topology_structure
  SUBTYPE OF (representation);
  SELF\representation.items : SET[1:?] OF kinematic_joint; 
WHERE
  WR1: SIZEOF (QUERY (item <* items | 'TOPOLOGY_SCHEMA.ORIENTED_EDGE' in TYPEOF(item))) = 0;
END_ENTITY;
(* WR1: None of the items shall be an oriented_edge *)

ENTITY kinematic_topology_substructure
  SUBTYPE OF (kinematic_topology_structure);
  parent : kinematic_topology_structure;
WHERE
  WR1: context_of_items :=: parent.context_of_items;
  WR2: SELF\kinematic_topology_structure.items <= parent\kinematic_topology_structure.items;
END_ENTITY;
(* WR1: A kinematic_topology_substructure shall have the same context as the parent *)  
(* WR2: The items of a kinematic_topology_substructure shall also be items of the parent *)

ENTITY kinematic_topology_directed_structure
  SUBTYPE OF (representation);
  SELF\representation.items : SET[1:?] OF oriented_joint; 
  parent : kinematic_topology_structure;
WHERE
  WR1: context_of_items :=: parent.context_of_items;
  WR2: get_kinematic_joints_from_oriented_joints(items) <= parent.items;
END_ENTITY;
(* WR1: A kinematic_topology_substructure shall have the same context as the parent *)  

ENTITY kinematic_topology_tree_structure
  SUBTYPE OF (kinematic_topology_directed_structure);
END_ENTITY;

ENTITY kinematic_topology_network_structure
  SUBTYPE OF (representation);
  SELF\representation.items : SET[1:?] OF kinematic_loop; 
  parent : kinematic_topology_structure;
WHERE
  WR1: context_of_items :=: parent.context_of_items;
  WR2: get_kinematic_joints_from_kinematic_loops(items) <= parent.items;
END_ENTITY;

ENTITY kinematic_joint 
  SUBTYPE OF (edge); 
  SELF\edge.edge_start : kinematic_link;
  SELF\edge.edge_end : kinematic_link;
UNIQUE
  UR1: edge_start, edge_end; 
WHERE
  WR1: edge_start :<>: edge_end;
END_ENTITY;
(* WR1: Edge_start and edge_end shall be different instances. *)
(* UR1: There shall be at most one kinematic_joint for any two kinematic_links *)

ENTITY kinematic_link
  SUBTYPE OF (vertex); 
END_ENTITY;

ENTITY kinematic_loop
  SUBTYPE OF (edge_loop);
  SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_joint; 
END_ENTITY;

ENTITY oriented_joint
  SUBTYPE OF (oriented_edge);
  SELF\oriented_edge.edge_element : kinematic_joint;
END_ENTITY;

FUNCTION get_kinematic_joints_from_oriented_joints(ors : SET OF oriented_joint) : SET OF kinematic_joint;
  LOCAL
    result : SET OF kinematic_joint := [];
  END_LOCAL;
  IF SIZEOF(ors) > 0 THEN
    REPEAT i := 1 TO HIINDEX(ors);
      result := result + ors[i].edge_element;
    END_REPEAT;
  END_IF;
  RETURN (result);
END_FUNCTION;

FUNCTION get_kinematic_joints_from_kinematic_loops(kls : SET OF kinematic_loop) : SET OF kinematic_joint;
  LOCAL
    result : SET OF oriented_joint := [];
  END_LOCAL;
  IF SIZEOF(kls) > 0 THEN
    REPEAT i := 1 TO HIINDEX(kls);
      result := result + kls[i].edge_list;
    END_REPEAT;
  END_IF;
  RETURN (get_kinematic_joints_from_oriented_joints(result));
END_FUNCTION;

SUBTYPE_CONSTRAINT kts_representation_subtypes FOR representation;
  ONEOF (
  kinematic_topology_structure,
  kinematic_topology_directed_structure,
  kinematic_topology_network_structure
  );
END_SUBTYPE_CONSTRAINT; 

END_SCHEMA;
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)



SCHEMA location_schema;
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY location;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY location_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_location : location;
    related_location : location;
  END_ENTITY;

  FUNCTION acyclic_location_relationship (relation : location_relationship; relatives : SET OF location; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF location_relationship;
    END_LOCAL;

    IF relation.relating_location IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'LOCATION_SCHEMA.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA management_resources_schema;
  REFERENCE FROM action_schema;
  REFERENCE FROM application_context_schema (library_context);
  REFERENCE FROM approval_schema;
  REFERENCE FROM basic_attribute_schema (
    get_role, 
    object_role, 
    role_association,
    role_select);
  REFERENCE FROM certification_schema;
  REFERENCE FROM contract_schema;
  REFERENCE FROM date_time_schema;
  REFERENCE FROM document_schema;
  REFERENCE FROM effectivity_schema;
  REFERENCE FROM experience_schema;
  REFERENCE FROM external_reference_schema (external_source);
  REFERENCE FROM group_schema;
  REFERENCE FROM location_schema;
  REFERENCE FROM person_organization_schema;
  REFERENCE FROM qualifications_schema;
  REFERENCE FROM security_classification_schema;
  REFERENCE FROM support_resource_schema;

  TYPE mrs_role_select = SELECT BASED_ON role_select WITH (
    action_assignment,
    action_request_assignment,
    approval_assignment,
    certification_assignment,
    contract_assignment,
    document_reference,
    effectivity_assignment,
    external_referent_assignment,
    group_assignment,
    name_assignment,
    security_classification_assignment);
  END_TYPE;

  TYPE attribute_type = SELECT (label, text);
  END_TYPE;

  ENTITY action_assignment
    ABSTRACT SUPERTYPE;
    assigned_action : action;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY action_method_assignment
    ABSTRACT SUPERTYPE;
    assigned_action_method : action_method;
    role : action_method_role;
  END_ENTITY;

  ENTITY action_method_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY action_request_assignment
    ABSTRACT SUPERTYPE;
    assigned_action_request : versioned_action_request;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_assignment
    ABSTRACT SUPERTYPE;
    assigned_approval : approval;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY attribute_classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_class : group;
    attribute_name : label;
    role : classification_role;
  END_ENTITY;

  ENTITY attribute_value_assignment
    ABSTRACT SUPERTYPE;
    attribute_name : label;
    attribute_value : attribute_type;
    role : attribute_value_role;
  END_ENTITY;

  ENTITY attribute_value_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY certification_assignment
    ABSTRACT SUPERTYPE;
    assigned_certification : certification;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_class : group;
    role : classification_role;
  END_ENTITY;

  ENTITY classification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY contract_assignment
    ABSTRACT SUPERTYPE;
    assigned_contract : contract;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY date_and_time_assignment
    ABSTRACT SUPERTYPE;
    assigned_date_and_time : date_and_time;
    role : date_time_role;
  END_ENTITY;

  ENTITY date_assignment
    ABSTRACT SUPERTYPE;
    assigned_date : date;
    role : date_role;
  END_ENTITY;

  ENTITY document_reference
    ABSTRACT SUPERTYPE;
    assigned_document : document;
    source : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY document_usage_constraint_assignment
    ABSTRACT SUPERTYPE;
    assigned_document_usage : document_usage_constraint;
    role : document_usage_role;
  END_ENTITY;

  ENTITY document_usage_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY effectivity_assignment
    ABSTRACT SUPERTYPE;
    assigned_effectivity : effectivity;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY effectivity_context_assignment
    ABSTRACT SUPERTYPE;
    assigned_effectivity_assignment : effectivity_assignment;
    role : effectivity_context_role;
  END_ENTITY;

  ENTITY effectivity_context_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY event_occurrence_assignment
    ABSTRACT SUPERTYPE;
    assigned_event_occurrence : event_occurrence;
    role : event_occurrence_role;
  END_ENTITY;

  ENTITY event_occurrence_context_assignment
    ABSTRACT SUPERTYPE;
    assigned_event_occurrence_assignment : event_occurrence_assignment;
    role : event_occurrence_context_role;
  END_ENTITY;

  ENTITY experience_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_experience : experience;
    role : experience_role;
  END_ENTITY;

  ENTITY experience_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_experience_type : experience_type;
    role : experience_type_role;
  END_ENTITY;

  ENTITY experience_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY external_identification_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (identification_assignment);
    source : external_source;
  END_ENTITY;

  ENTITY external_referent_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  UNIQUE
    UR1: assigned_name;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY group_assignment
    ABSTRACT SUPERTYPE;
    assigned_group : group;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY identification_assignment
    ABSTRACT SUPERTYPE;
    assigned_id : identifier;
    role : identification_role;
  END_ENTITY;

  ENTITY identification_assignment_relationship;
    name : label;
    description : OPTIONAL text;
    relating_identification_assignment : identification_assignment;
    related_identification_assignment : identification_assignment;
  END_ENTITY;

  ENTITY identification_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY library_assignment
    ABSTRACT SUPERTYPE
    SUBTYPE OF (external_referent_assignment);
    frame_of_reference : library_context;
  UNIQUE
    UR1: frame_of_reference;
  END_ENTITY;

  ENTITY location_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_location : location;
    role : location_role;
  END_ENTITY;

  ENTITY location_representation_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    represented_location : location;
    role : location_representation_role;
  END_ENTITY;

  ENTITY location_representation_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY location_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY name_assignment
    ABSTRACT SUPERTYPE;
    assigned_name : label;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY organization_assignment
    ABSTRACT SUPERTYPE;
    assigned_organization : organization;
    role : organization_role;
  END_ENTITY;

  ENTITY organization_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_organization_type : organization_type;
    role : organization_type_role;
  END_ENTITY;

  ENTITY organization_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organizational_project_assignment
    ABSTRACT SUPERTYPE;
    assigned_organizational_project : organizational_project;
    role : organizational_project_role;
  END_ENTITY;

  ENTITY organizational_project_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_and_organization_assignment
    ABSTRACT SUPERTYPE;
    assigned_person_and_organization : person_and_organization;
    role : person_and_organization_role;
  END_ENTITY;

  ENTITY person_assignment
    ABSTRACT SUPERTYPE;
    assigned_person : person;
    role : person_role;
  END_ENTITY;

  ENTITY person_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_person_type : person_type;
    role : person_type_role;
  END_ENTITY;

  ENTITY person_type_definition_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_person_type_definition : person_type_definition;
    role : person_type_definition_role;
  END_ENTITY;

  ENTITY person_type_definition_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_position_in_organization : position_in_organization;
    role : position_in_organization_role;
  END_ENTITY;

  ENTITY position_in_organization_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_position_in_organization_type : position_in_organization_type;
    role : position_in_organization_type_role;
  END_ENTITY;

  ENTITY position_in_organization_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_qualification : qualification;
    role : qualification_role;
  END_ENTITY;

  ENTITY qualification_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_type_assignment
    ABSTRACT SUPERTYPE;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    assigned_qualification_type : qualification_type;
    role : qualification_type_role;
  END_ENTITY;

  ENTITY qualification_type_role;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY security_classification_assignment
    ABSTRACT SUPERTYPE;
    assigned_security_classification : security_classification;
  DERIVE
    role : object_role := get_role(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY time_assignment
    ABSTRACT SUPERTYPE;
    assigned_time : local_time;
    role : time_role;
  END_ENTITY;

  ENTITY time_interval_assignment
    ABSTRACT SUPERTYPE;
    assigned_time_interval : time_interval;
    role : time_interval_role;
  END_ENTITY;

  FUNCTION acyclic_identification_assignment_relationship (relation : identification_assignment_relationship; relatives : SET [1:?] OF identification_assignment; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF identification_assignment_relationship;
    END_LOCAL;

    IF relation.relating_identification_assignment IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6751 - ISO/IS 10303-45 Material properties - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N5100 - ISO/IS 10303-45 Material properties - EXPRESS
changes to material_designation as per SEDS #1423.
*)

SCHEMA material_property_definition_schema;

REFERENCE FROM material_property_representation_schema
     (material_property_representation);

REFERENCE FROM measure_schema
     (measure_with_unit);

REFERENCE FROM product_definition_schema
      (product_definition_relationship);

REFERENCE FROM product_property_definition_schema
      (characterized_definition,
      property_definition);

REFERENCE FROM qualified_measure_schema
     (maths_value_with_unit);

REFERENCE FROM support_resource_schema
     (label,
      text,
      bag_to_set);

TYPE characterized_material_property = SELECT
  (material_property_representation,
   product_material_composition_relationship);
END_TYPE;

TYPE characterized_product_composition_value = SELECT
  (maths_value_with_unit,
   measure_with_unit);
END_TYPE;

ENTITY material_designation; 
  name       		: label;
  definitions 	: SET [1:?] OF characterized_definition;
END_ENTITY;

ENTITY material_designation_characterization;
  name       		: label;
  description 	: text;
  designation 	: material_designation;
  property    	: characterized_material_property;
END_ENTITY;
ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  UR1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition)) OR
       (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
                       ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp)))) = 0);
END_ENTITY;

ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class        	       : label;
  constituent_amount  	: SET [1:?] OF characterized_product_composition_value;
  composition_basis    : label;
  determination_method : text;
END_ENTITY;

ENTITY property_definition_relationship;
  name                       		: label;
  description                 	: text;
  relating_property_definition 	: property_definition;
  related_property_definition  	: property_definition;
END_ENTITY;

FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
   relatives         : SET [1:?] OF property_definition;
   specific_relation : STRING) : LOGICAL;
  LOCAL
    x                : SET OF property_definition_relationship;
  END_LOCAL;
  IF relation.relating_property_definition IN 
            relatives THEN
    RETURN (FALSE);
  END_IF;             -- IN is based in instance equality
  x := QUERY (pd <* bag_to_set (USEDIN
       (relation.relating_property_definition,
        'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION')) |
         specific_relation IN TYPEOF (pd));
  REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
      (x[i],
       relatives + relation.relating_property_definition,
       specific_relation) THEN
      RETURN(FALSE);
    END_IF;
  END_REPEAT;
  RETURN(TRUE);
END_FUNCTION;  -- acyclic_property_definition_relationship

END_SCHEMA;    -- material_property_definition_schema
(*
ISO TC184/SC4/WG12 N5100 - ISO/IS 10303-45 Material properties - EXPRESS
*)


SCHEMA material_property_representation_schema;

REFERENCE FROM product_property_representation_schema
     (property_definition_representation);

REFERENCE FROM support_resource_schema
     (label,
      text);

ENTITY data_environment;
  name       		: label;
  description 	: text;
  elements    	: SET [1:?] OF property_definition_representation;
END_ENTITY;

ENTITY data_environment_relationship;
  name                    		: label;
  description              	: text;
  relating_data_environment 	: data_environment;
  related_data_environment  	: data_environment;
END_ENTITY;

ENTITY material_property_representation
  SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;
END_SCHEMA;		-- material_property_representation_schema
(* WG12 N4886 Part 50 EXPRESS as modified by TC1 2007-07-25 (WG12 N4885) *)

(* Genenerated from: ../../irs/wg12n921.exp *)
(* modified to fix problem in *)
(* derive_function_range having to do with return value assignment in dimension_of function. *)
(* SEDS is #1299  *)

SCHEMA mathematical_functions_schema;
-- This file constitutes document WG12 N921
-- Master document: ISO 10303-50:2001
-- EXPRESS last modified: 2001-09-07

REFERENCE FROM iso13584_generic_expressions_schema     -- ISO 13584-20
  (binary_generic_expression,
   environment,
   generic_expression,
   generic_literal,
   generic_variable,
   multiple_arity_generic_expression,
   simple_generic_expression,
   unary_generic_expression,
   variable_semantics);

REFERENCE FROM iso13584_expressions_schema             -- ISO 13584-20
  (abs_function                   AS abs_expression,
   acos_function                  AS acos_expression,
   and_expression,
   asin_function                  AS asin_expression,
   atan_function                  AS atan_expression,
   binary_boolean_expression,
   binary_function_call           AS binary_numeric_call_expression,
   binary_numeric_expression,
   boolean_defined_function       AS boolean_defined_expression,
   boolean_expression,
   boolean_literal,
   boolean_variable,
   comparison_equal,
   comparison_expression,
   comparison_greater,
   comparison_greater_equal,
   comparison_less,
   comparison_less_equal,
   comparison_not_equal,
   concat_expression,
   cos_function                   AS cos_expression,
   defined_function               AS defined_expression,
   div_expression,
   equals_expression,
   exp_function                   AS exp_expression,
   expression,
   format_function                AS format_expression,
   index_expression,
   int_literal,
   int_numeric_variable,
   int_value_function             AS int_value_expression,
   integer_defined_function       AS integer_defined_expression,
   interval_expression,
   length_function                AS length_expression,
   like_expression,
   literal_number,
   log_function                   AS log_expression,
   log10_function                 AS log10_expression,
   log2_function                  AS log2_expression,
   maximum_function               AS maximum_expression,
   minimum_function               AS minimum_expression,
   minus_expression,
   minus_function                 AS unary_minus_expression,
   mod_expression,
   mult_expression,
   multiple_arity_boolean_expression,
   multiple_arity_function_call   AS multiple_arity_numeric_call_expression,
   multiple_arity_numeric_expression,
   not_expression,
   numeric_defined_function       AS numeric_defined_expression,
   numeric_expression,
   numeric_variable,
   odd_function                   AS odd_expression,
   or_expression,
   plus_expression,
   power_expression,
   real_defined_function          AS real_defined_expression,
   real_literal,
   real_numeric_variable,
   simple_boolean_expression,
   simple_numeric_expression,
   simple_string_expression,
   sin_function                   AS sin_expression,
   slash_expression,
   sql_mappable_defined_function  AS sql_mappable_defined_expression,
   square_root_function           AS square_root_expression,
   string_defined_function        AS string_defined_expression,
   string_expression,
   string_literal,
   string_variable,
   substring_expression,
   tan_function                   AS tan_expression,
   unary_boolean_expression,
   unary_function_call            AS unary_numeric_call_expression,
   unary_numeric_expression,
   value_function                 AS value_expression,
   variable,
   xor_expression);

REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (label,
   text);

REFERENCE FROM external_reference_schema               -- ISO 10303-41
  (externally_defined_item);

REFERENCE FROM geometry_schema                         -- ISO 10303-42
  (curve,
   dimension_of,
   point,
   surface,
   volume);

CONSTANT
  schema_prefix : STRING := 'MATHEMATICAL_FUNCTIONS_SCHEMA.';
  the_integers        : elementary_space := make_elementary_space(es_integers);
  the_reals           : elementary_space := make_elementary_space(es_reals);
  the_complex_numbers : elementary_space := make_elementary_space(es_complex_numbers);
  the_numbers         : elementary_space := make_elementary_space(es_numbers);
  the_logicals        : elementary_space := make_elementary_space(es_logicals);
  the_booleans        : elementary_space := make_elementary_space(es_booleans);
  the_strings         : elementary_space := make_elementary_space(es_strings);
  the_binarys         : elementary_space := make_elementary_space(es_binarys);
  the_maths_spaces    : elementary_space := make_elementary_space(es_maths_spaces);
  the_generics        : elementary_space := make_elementary_space(es_generics);
  the_empty_space : finite_space := make_finite_space([]);
  the_nonnegative_reals         : real_interval_from_min :=
    make_real_interval_from_min(0.0, closed);
  the_zero_one_interval         : finite_real_interval := make_finite_real_interval(
    0.0, closed, 1.0, closed);
  the_zero_pi_interval          : finite_real_interval := make_finite_real_interval(
    0.0, closed, pi, closed);
  the_neg1_one_interval         : finite_real_interval := make_finite_real_interval(
    -1.0, closed, 1.0, closed);
  the_neghalfpi_halfpi_interval : finite_real_interval := make_finite_real_interval(
    -0.5*pi, closed, 0.5*pi, closed);
  the_negpi_pi_interval         : finite_real_interval := make_finite_real_interval(
    -pi, open, pi, closed);
  the_zero_tuple_space : listed_product_space := make_listed_product_space([]);
  the_tuples           : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_generics);
  the_integer_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_integers);
  the_real_tuples      : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_reals);
  the_complex_tuples   : extended_tuple_space := make_extended_tuple_space(
    the_zero_tuple_space, the_complex_numbers);
  the_empty_maths_tuple      : maths_tuple := [];
  the_empty_maths_value      : maths_value := the_empty_maths_tuple;
  the_empty_atom_based_tuple : atom_based_tuple := [];
  the_empty_atom_based_value : atom_based_value := the_empty_atom_based_tuple;
END_CONSTANT;
TYPE nonnegative_integer = INTEGER;
WHERE 
nonnegativity: SELF >= 0;
END_TYPE;
TYPE positive_integer = nonnegative_integer;
WHERE positivity: SELF > 0;
END_TYPE;
TYPE zero_or_one = nonnegative_integer;
WHERE in_range: (SELF = 0) OR (SELF = 1);
END_TYPE;
TYPE one_or_two = positive_integer;
WHERE in_range: (SELF = 1) OR (SELF = 2);
END_TYPE;
TYPE maths_number = NUMBER;
END_TYPE;
TYPE maths_real = REAL;
END_TYPE;
TYPE maths_integer = INTEGER;
END_TYPE;
TYPE maths_logical = LOGICAL;
END_TYPE;
TYPE maths_boolean = BOOLEAN;
END_TYPE;
TYPE maths_string = STRING;
END_TYPE;
TYPE maths_binary = BINARY;
END_TYPE;

TYPE maths_simple_atom = SELECT
  (maths_number,
   maths_real,
   maths_integer,
   maths_logical,
   maths_boolean,
   maths_string,
   maths_binary);
END_TYPE;
TYPE maths_atom = SELECT
  (maths_simple_atom,
   maths_enum_atom);
END_TYPE;
TYPE atom_based_tuple = LIST OF atom_based_value;
END_TYPE;
TYPE atom_based_value = SELECT
  (maths_atom,
   atom_based_tuple);
END_TYPE;
TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE;
TYPE maths_value = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
WHERE
  constancy: NOT ('GENERIC_EXPRESSION' IN stripped_typeof(SELF)) OR
             expression_is_constant(SELF);
END_TYPE;
TYPE maths_expression = SELECT
  (atom_based_value,
   maths_tuple,
   generic_expression);
END_TYPE;
TYPE maths_function_select = SELECT
  (maths_function,
   elementary_function_enumerators);
END_TYPE;
TYPE input_selector = positive_integer;
END_TYPE;
TYPE elementary_space_enumerators = ENUMERATION OF
  (es_numbers,
   es_complex_numbers,
   es_reals,
   es_integers,
   es_logicals,
   es_booleans,
   es_strings,
   es_binarys,
   es_maths_spaces,
   es_maths_functions,
   es_generics);
END_TYPE;
TYPE ordering_type = ENUMERATION OF
  (by_rows,
   by_columns);
END_TYPE;
TYPE lower_upper = ENUMERATION OF
  (lower,
   upper);
END_TYPE;
TYPE symmetry_type = ENUMERATION OF
  (identity,
   skew,
   hermitian,
   skew_hermitian);
END_TYPE;
TYPE elementary_function_enumerators = ENUMERATION OF
  (ef_and, ef_or, ef_not, ef_xor,
   ef_negate_i, ef_add_i, ef_subtract_i, ef_multiply_i, ef_divide_i, ef_mod_i,
   ef_exponentiate_i, ef_eq_i, ef_ne_i, ef_gt_i, ef_lt_i, ef_ge_i, ef_le_i,
   ef_abs_i, ef_max_i, ef_min_i, ef_if_i,
   ef_negate_r, ef_reciprocal_r, ef_add_r, ef_subtract_r, ef_multiply_r,
   ef_divide_r, ef_mod_r, ef_exponentiate_r, ef_exponentiate_ri,
   ef_eq_r, ef_ne_r, ef_gt_r, ef_lt_r, ef_ge_r, ef_le_r, ef_abs_r,
   ef_max_r, ef_min_r, ef_acos_r, ef_asin_r, ef_atan2_r, ef_cos_r, ef_exp_r,
   ef_ln_r, ef_log2_r, ef_log10_r, ef_sin_r, ef_sqrt_r, ef_tan_r, ef_if_r,
   ef_form_c, ef_rpart_c, ef_ipart_c,
   ef_negate_c, ef_reciprocal_c, ef_add_c, ef_subtract_c, ef_multiply_c,
   ef_divide_c, ef_exponentiate_c, ef_exponentiate_ci, ef_eq_c, ef_ne_c,
   ef_conjugate_c, ef_abs_c, ef_arg_c, ef_cos_c, ef_exp_c, ef_ln_c, ef_sin_c,
   ef_sqrt_c, ef_tan_c, ef_if_c,
   ef_subscript_s, ef_eq_s, ef_ne_s, ef_gt_s, ef_lt_s, ef_ge_s, ef_le_s,
   ef_subsequence_s, ef_concat_s, ef_size_s, ef_format, ef_value, ef_like, ef_if_s,
   ef_subscript_b, ef_eq_b, ef_ne_b, ef_gt_b, ef_lt_b, ef_ge_b, ef_le_b,
   ef_subsequence_b, ef_concat_b, ef_size_b, ef_if_b,
   ef_subscript_t, ef_eq_t, ef_ne_t, ef_concat_t, ef_size_t,
   ef_entuple, ef_detuple, ef_insert, ef_remove, ef_if_t,
   ef_sum_it, ef_product_it,
   ef_add_it, ef_subtract_it, ef_scalar_mult_it, ef_dot_prod_it,
   ef_sum_rt, ef_product_rt,
   ef_add_rt, ef_subtract_rt, ef_scalar_mult_rt, ef_dot_prod_rt, ef_norm_rt,
   ef_sum_ct, ef_product_ct,
   ef_add_ct, ef_subtract_ct, ef_scalar_mult_ct, ef_dot_prod_ct, ef_norm_ct,
   ef_if, ef_ensemble, ef_member_of);
END_TYPE;
TYPE open_closed = ENUMERATION OF
  (open,
   closed);
END_TYPE;
TYPE space_constraint_type = ENUMERATION OF
  (sc_equal,
   sc_subspace,
   sc_member);
END_TYPE;
TYPE repackage_options = ENUMERATION OF
  (ro_nochange,
   ro_wrap_as_tuple,
   ro_unwrap_tuple);
END_TYPE;
TYPE extension_options = ENUMERATION OF
  (eo_none,
   eo_cont,
   eo_cont_right,
   eo_cont_left);
END_TYPE;
TYPE maths_enum_atom = SELECT
  (elementary_space_enumerators,
   ordering_type,
   lower_upper,
   symmetry_type,
   elementary_function_enumerators,
   open_closed,
   space_constraint_type,
   repackage_options,
   extension_options);
END_TYPE;
TYPE dotted_express_identifier = STRING;
WHERE syntax: dotted_identifiers_syntax(SELF);
END_TYPE;
TYPE express_identifier = dotted_express_identifier;
WHERE syntax: dot_count(SELF) = 0;
END_TYPE;
TYPE product_space = SELECT
  (uniform_product_space,
   listed_product_space);
END_TYPE;
TYPE tuple_space = SELECT
  (product_space,
   extended_tuple_space);
END_TYPE;
TYPE maths_space_or_function = SELECT
  (maths_space,
   maths_function);
END_TYPE;
TYPE real_interval = SELECT
  (real_interval_from_min,
   real_interval_to_max,
   finite_real_interval,
   elementary_space);
WHERE
  WR1: NOT ('ELEMENTARY_SPACE' IN stripped_typeof(SELF)) OR
    (SELF\elementary_space.space_id = es_reals);
END_TYPE;
ENTITY quantifier_expression
  ABSTRACT SUPERTYPE
  SUBTYPE OF (multiple_arity_generic_expression);
  variables : LIST [1:?] OF UNIQUE generic_variable;
WHERE
  WR1: SIZEOF (QUERY (vrbl <* variables | NOT (vrbl IN
       SELF\multiple_arity_generic_expression.operands))) = 0;
  WR2: SIZEOF (QUERY (vrbl <* variables | NOT ((schema_prefix +
       'BOUND_VARIABLE_SEMANTICS') IN TYPEOF (vrbl.interpretation.semantics)))) = 0;
END_ENTITY;
ENTITY dependent_variable_definition
  SUBTYPE OF (unary_generic_expression);
  name        : label;
  description : text;
END_ENTITY;
ENTITY bound_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY free_variable_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;
ENTITY complex_number_literal
  SUBTYPE OF (generic_literal);
  real_part : REAL;
  imag_part : REAL;
END_ENTITY;
ENTITY logical_literal
  SUBTYPE OF (generic_literal);
  lit_value : LOGICAL;
END_ENTITY;
ENTITY binary_literal
  SUBTYPE OF (generic_literal);
  lit_value : BINARY;
END_ENTITY;
ENTITY maths_enum_literal
  SUBTYPE OF (generic_literal);
  lit_value : maths_enum_atom;
END_ENTITY;
ENTITY real_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF REAL;
END_ENTITY;
ENTITY integer_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST [1:?] OF INTEGER;
END_ENTITY;
ENTITY atom_based_literal
  SUBTYPE OF (generic_literal);
  lit_value : atom_based_value;
END_ENTITY;
ENTITY maths_tuple_literal
  SUBTYPE OF (generic_literal);
  lit_value : LIST OF maths_value;
END_ENTITY;
ENTITY maths_variable
  SUBTYPE OF (generic_variable);
  values_space : maths_space;
  name         : label;
WHERE
  WR1: expression_is_constant(values_space);
END_ENTITY;
ENTITY maths_real_variable
  SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_reals);
END_ENTITY;
ENTITY maths_integer_variable
  SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_integers);
END_ENTITY;
ENTITY maths_boolean_variable
  SUBTYPE OF (maths_variable, boolean_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_booleans);
END_ENTITY;
ENTITY maths_string_variable
  SUBTYPE OF (maths_variable, string_variable);
WHERE
  WR1: subspace_of_es(SELF\maths_variable.values_space,es_strings);
END_ENTITY;
ENTITY function_application
  SUBTYPE OF (multiple_arity_generic_expression);
  func      : maths_function_select;
  arguments : LIST [1:?] OF maths_expression;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression
    := [convert_to_maths_function(func)] + convert_to_operands(arguments);
WHERE
  WR1: function_applicability(func, arguments);
END_ENTITY;
ENTITY maths_space
  ABSTRACT SUPERTYPE OF (ONEOF (elementary_space,
                                finite_integer_interval,
                                integer_interval_from_min,
                                integer_interval_to_max,
                                finite_real_interval,
                                real_interval_from_min,
                                real_interval_to_max,
                                cartesian_complex_number_region,
                                polar_complex_number_region,
                                finite_space,
                                uniform_product_space,
                                listed_product_space,
                                extended_tuple_space,
                                function_space))
  SUBTYPE OF (generic_expression);
END_ENTITY;
ENTITY elementary_space
  SUBTYPE OF (maths_space, generic_literal);
  space_id : elementary_space_enumerators;
END_ENTITY;
ENTITY finite_integer_interval
  SUBTYPE OF (maths_space, generic_literal);
  min  : INTEGER;
  max  : INTEGER;
DERIVE
  size : positive_integer := max - min + 1;
WHERE
  WR1: min <= max;
END_ENTITY;
ENTITY integer_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min : INTEGER;
END_ENTITY;
ENTITY integer_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max : INTEGER;
END_ENTITY;
ENTITY finite_real_interval
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
  max         : REAL;
  max_closure : open_closed;
WHERE
  WR1: min < max;
END_ENTITY;
ENTITY real_interval_from_min
  SUBTYPE OF (maths_space, generic_literal);
  min         : REAL;
  min_closure : open_closed;
END_ENTITY;
ENTITY real_interval_to_max
  SUBTYPE OF (maths_space, generic_literal);
  max         : REAL;
  max_closure : open_closed;
END_ENTITY;
ENTITY cartesian_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  real_constraint : real_interval;
  imag_constraint : real_interval;
WHERE
  WR1: min_exists(real_constraint) OR max_exists(real_constraint) OR
       min_exists(imag_constraint) OR max_exists(imag_constraint);
END_ENTITY;
ENTITY polar_complex_number_region
  SUBTYPE OF (maths_space, generic_literal);
  centre               : complex_number_literal;
  distance_constraint  : real_interval;
  direction_constraint : finite_real_interval;
WHERE
  WR1: min_exists(distance_constraint) AND (real_min(distance_constraint) >= 0.0);
  WR2: {-PI <= direction_constraint.min < PI};
  WR3: direction_constraint.max - direction_constraint.min <= 2.0*PI;
  WR4: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.min_closure = open);
  WR5: (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open) OR
       (direction_constraint.min = -PI);
  WR6: (real_min(distance_constraint) > 0.0) OR max_exists(distance_constraint) OR
       (direction_constraint.max - direction_constraint.min < 2.0*PI) OR
       (direction_constraint.max_closure = open);
END_ENTITY;
ENTITY finite_space
  SUBTYPE OF (maths_space, generic_literal);
  members : SET OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(members);
  WR2: SIZEOF (QUERY (expr <* QUERY (member <* members |
       'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN TYPEOF (member))
       | NOT expression_is_constant(expr))) = 0;
  WR3: no_cyclic_space_reference(SELF, []);
END_ENTITY;
ENTITY uniform_product_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : maths_space;
  exponent : positive_integer;
WHERE
  WR1: expression_is_constant(base);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: base <> the_empty_space;
END_ENTITY;
ENTITY listed_product_space
  SUBTYPE OF (maths_space, generic_literal);
  factors : LIST OF maths_space;
WHERE
  WR1: SIZEOF (QUERY (space <* factors |
       NOT (expression_is_constant(space)))) = 0;
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: NOT (the_empty_space IN factors);
END_ENTITY;
ENTITY extended_tuple_space
  SUBTYPE OF (maths_space, generic_literal);
  base     : product_space;
  extender : maths_space;
WHERE
  WR1: expression_is_constant(base) AND
       expression_is_constant(extender);
  WR2: no_cyclic_space_reference(SELF, []);
  WR3: extender <> the_empty_space;
END_ENTITY;
ENTITY function_space
  SUBTYPE OF (maths_space, generic_literal);
  domain_constraint : space_constraint_type;
  domain_argument  : maths_space;
  range_constraint : space_constraint_type;
  range_argument   : maths_space;
WHERE
  WR1: expression_is_constant(domain_argument) AND
       expression_is_constant(range_argument);
  WR2: (domain_argument <> the_empty_space) AND
       (range_argument <> the_empty_space);
  WR3: (domain_constraint <> sc_member) OR NOT
       member_of(the_empty_space,domain_argument);
  WR4: (range_constraint <> sc_member) OR NOT
       member_of(the_empty_space,range_argument);
  WR5: NOT (any_space_satisfies(domain_constraint,domain_argument) AND
       any_space_satisfies(range_constraint,range_argument));
END_ENTITY;
ENTITY maths_function
  ABSTRACT SUPERTYPE OF (ONEOF (finite_function,
                                constant_function,
                                selector_function,
                                elementary_function,
                                restriction_function,
                                repackaging_function,
                                reindexed_array_function,
                                series_composed_function,
                                parallel_composed_function,
                                explicit_table_function,
                                homogeneous_linear_function,
                                general_linear_function,
                                b_spline_basis,
                                b_spline_function,
                                rationalize_function,
                                partial_derivative_function,
                                definite_integral_function,
                                abstracted_expression_function,
                                expression_denoted_function,
                                imported_point_function,
                                imported_curve_function,
                                imported_surface_function,
                                imported_volume_function,
                                application_defined_function))
  SUBTYPE OF (generic_expression);
DERIVE
  domain : tuple_space := derive_function_domain(SELF);
  range : tuple_space := derive_function_range(SELF);
END_ENTITY;
ENTITY finite_function
  SUBTYPE OF (maths_function, generic_literal);
  pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
  WR1: VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY;
ENTITY constant_function
  SUBTYPE OF (maths_function, generic_literal);
  sole_output      : maths_value;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY selector_function
  SUBTYPE OF (maths_function, generic_literal);
  selector : input_selector;
  source_of_domain : maths_space_or_function;
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
END_ENTITY;
ENTITY elementary_function
  SUBTYPE OF (maths_function, generic_literal);
  func_id : elementary_function_enumerators;
END_ENTITY;
ENTITY restriction_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_space;
END_ENTITY;
ENTITY repackaging_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  input_repack    : repackage_options;
  output_repack   : repackage_options;
  selected_output : nonnegative_integer;
WHERE
  WR1: (input_repack <> ro_wrap_as_tuple) OR
       ((space_dimension(operand.domain) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.domain))));
  WR2: (output_repack <> ro_unwrap_tuple) OR
       ((space_dimension(operand.range) = 1) AND
         ((schema_prefix + 'TUPLE_SPACE') IN TYPEOF (factor1(operand.range))));
  WR3: selected_output <= space_dimension( repackage(
       operand.range, output_repack));
END_ENTITY;
ENTITY reindexed_array_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  starting_indices : LIST [1:?] OF INTEGER;
WHERE
  WR1: function_is_array(SELF\unary_generic_expression.operand);
  WR2: SIZEOF(starting_indices) = SIZEOF(shape_of_array(
       SELF\unary_generic_expression.operand));
END_ENTITY;
ENTITY series_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of maths_function;
WHERE
  WR1: composable_sequence(SELF\multiple_arity_generic_expression.operands);
END_ENTITY;
ENTITY parallel_composed_function
  SUBTYPE OF (maths_function, multiple_arity_generic_expression);
  source_of_domain  : maths_space_or_function;
  prep_functions : LIST [1:?] OF maths_function;
  final_function : maths_function_select;
DERIVE
  SELF\multiple_arity_generic_expression.operands : LIST [2:?] of generic_expression
    := convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function);
WHERE
  WR1: no_cyclic_domain_reference(source_of_domain, [SELF]);
  WR2: expression_is_constant(domain_from(source_of_domain));
  WR3: parallel_composed_function_domain_check(domain_from(source_of_domain),
       prep_functions);
  WR4: parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY;
ENTITY explicit_table_function
  ABSTRACT SUPERTYPE OF (ONEOF (listed_real_data,
                                listed_integer_data,
                                listed_logical_data,
                                listed_string_data,
                                listed_complex_number_data,
                                listed_data,
                                externally_listed_data,
                                linearized_table_function,
                                basic_sparse_matrix))
  SUBTYPE OF (maths_function);
  index_base : zero_or_one;
  shape      : LIST [1:?] OF positive_integer;
END_ENTITY;
ENTITY listed_real_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF REAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_integer_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF INTEGER;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_logical_data
  SUBTYPE OF(explicit_table_function, generic_literal);
  values : LIST [1:?] OF LOGICAL;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_string_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [1:?] OF STRING;
DERIVE
  self\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
END_ENTITY;
ENTITY listed_complex_number_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values : LIST [2:?] OF REAL;
DERIVE
      SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer := [ SIZEOF(values) DIV 2 ];
WHERE
      WR1:
         NOT ODD(SIZEOF(values));
END_ENTITY;
ENTITY listed_data
  SUBTYPE OF (explicit_table_function, generic_literal);
  values      : LIST [1:?] OF maths_value;
  value_range : maths_space;
DERIVE
  SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=
    [SIZEOF (values)];
WHERE
  WR1: expression_is_constant(value_range);
  WR2: SIZEOF (QUERY (val <* values | NOT (member_of( val, value_range)))) = 0;
END_ENTITY;
ENTITY externally_listed_data
  SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
  value_range : maths_space;
WHERE
  WR1: expression_is_constant(value_range);
END_ENTITY;
ENTITY linearized_table_function
  SUPERTYPE OF (ONEOF (standard_table_function,
                       regular_table_function,
                       triangular_matrix,
                       symmetric_matrix,
                       banded_matrix))
  SUBTYPE OF (explicit_table_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  first  : integer;
DERIVE
  source : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_1d_array(source);
  WR2: member_of(first, source\maths_function.domain);
END_ENTITY;
ENTITY standard_table_function
  SUBTYPE OF (linearized_table_function);
  order : ordering_type;
WHERE
  WR1: extremal_position_check(SELF);
END_ENTITY;
ENTITY regular_table_function
  SUBTYPE OF (linearized_table_function);
  increments : LIST [1:?] OF INTEGER;
WHERE
  WR1: SIZEOF (increments) = SIZEOF (self\explicit_table_function.shape);
  WR2: extremal_position_check(self);
END_ENTITY;
ENTITY triangular_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  lo_up         : lower_upper;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: member_of(default_entry, SELF\maths_function.range);
END_ENTITY;
ENTITY strict_triangular_matrix
  SUBTYPE OF (triangular_matrix);
  main_diagonal_value : maths_value;
END_ENTITY;
ENTITY symmetric_matrix
  SUBTYPE OF (linearized_table_function);
  symmetry : symmetry_type;
  triangle : lower_upper;
  order    : ordering_type;
WHERE
  WR1: SIZEOF (SELF\explicit_table_function.shape) = 2;
  WR2: SELF\explicit_table_function.shape[1] =
       SELF\explicit_table_function.shape[2];
  WR3: NOT (symmetry = skew) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_numbers));
  WR4: NOT ((symmetry = hermitian) OR (symmetry = skew_hermitian)) OR (
       (space_dimension(SELF\linearized_table_function.source.range) = 1) AND
        subspace_of_es(factor1(SELF\linearized_table_function.source.range),
        es_complex_numbers));
END_ENTITY;
ENTITY symmetric_banded_matrix
  SUBTYPE OF (symmetric_matrix);
  default_entry : maths_value;
  above         : nonnegative_integer;
WHERE
  WR1: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY banded_matrix
  SUBTYPE OF (linearized_table_function);
  default_entry : maths_value;
  below         : integer;
  above         : integer;
  order         : ordering_type;
WHERE
  WR1: SIZEOF (self\explicit_table_function.shape) = 2;
  WR2: -below <= above;
  WR3: member_of(default_entry,
       factor1(SELF\linearized_table_function.source.range));
END_ENTITY;
ENTITY basic_sparse_matrix
  SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
  SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
  default_entry : maths_value;
  order : ordering_type;
DERIVE
  index : maths_function := SELF\multiple_arity_generic_expression.operands[1];
  loc   : maths_function := SELF\multiple_arity_generic_expression.operands[2];
  val   : maths_function := SELF\multiple_arity_generic_expression.operands[3];
WHERE
  WR1: function_is_1d_table(index);
  WR2: function_is_1d_table(loc);
  WR3: function_is_1d_table(val);
  WR4: check_sparse_index_domain(index.domain, index_base, shape, order);
  WR5: check_sparse_index_to_loc(index.range, loc.domain);
  WR6: loc.domain = val.domain;
  WR7: check_sparse_loc_range(loc.range, index_base, shape, order);
  WR8: member_of(default_entry, val.range);
END_ENTITY;
ENTITY homogeneous_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY general_linear_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  sum_index : one_or_two;
DERIVE
  mat       : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_2d_table(mat);
  WR2: (space_dimension(mat.range) = 1) AND
       subspace_of_es(factor1(mat.range),es_numbers);
END_ENTITY;
ENTITY b_spline_basis
  SUBTYPE OF (maths_function, generic_literal);
  degree         : nonnegative_integer;
  repeated_knots : LIST [2:?] OF REAL;
DERIVE
  order          : positive_integer := degree + 1;
  num_basis      : positive_integer := SIZEOF (repeated_knots) - order;
WHERE
  WR1: num_basis >= order;
  WR2: nondecreasing(repeated_knots);
  WR3: repeated_knots[order] < repeated_knots[num_basis+1];
END_ENTITY;
ENTITY b_spline_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  basis : LIST [1:?] OF b_spline_basis;
DERIVE
  coef  : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: function_is_table(coef);
  WR2: (space_dimension(coef.range) = 1) AND
       (number_superspace_of(factor1(coef.range)) = the_reals);
  WR3: SIZEOF (basis) <=
       SIZEOF (shape_of_array(coef));
  WR4: compare_basis_and_coef(basis, coef);
END_ENTITY;
ENTITY rationalize_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
DERIVE
  fun : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: (space_dimension(fun.domain) = 1) AND (space_dimension(fun.range) = 1);
  WR2: number_tuple_subspace_check(factor1(fun.range));
  WR3: space_dimension(factor1(fun.range)) > 1;
END_ENTITY;
ENTITY partial_derivative_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  d_variables : LIST [1:?] OF input_selector;
  extension : extension_options;
DERIVE
  derivand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (derivand.range);
  WR2: partial_derivative_check (derivand.domain, d_variables);
END_ENTITY;
ENTITY partial_derivative_expression
  SUBTYPE OF (unary_generic_expression);
  d_variables : LIST [1:?] OF maths_variable;
  extension : extension_options;
DERIVE
  derivand : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: has_values_space (derivand);
  WR2: space_is_continuum (values_space_of (derivand));
  WR3: SIZEOF (QUERY (vbl <* d_variables | (NOT subspace_of (values_space_of (vbl),
    the_reals)) AND (NOT subspace_of (values_space_of (vbl), the_complex_numbers))
    )) = 0;
END_ENTITY;
ENTITY definite_integral_function
  SUBTYPE OF (maths_function, unary_generic_expression);
  SELF\unary_generic_expression.operand : maths_function;
  variable_of_integration : input_selector;
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : maths_function := SELF\unary_generic_expression.operand;
WHERE
  WR1: space_is_continuum (integrand.range);
  WR2: definite_integral_check (integrand.domain, variable_of_integration,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY definite_integral_expression
  SUBTYPE OF (quantifier_expression);
  lower_limit_neg_infinity : BOOLEAN;
  upper_limit_pos_infinity : BOOLEAN;
DERIVE
  integrand : generic_expression
    := SELF\multiple_arity_generic_expression.operands[1];
  variable_of_integration : maths_variable
    := SELF\multiple_arity_generic_expression.operands[2];
  SELF\quantifier_expression.variables : LIST [1:1] OF UNIQUE generic_variable
    := [variable_of_integration];
WHERE
  WR1: has_values_space (integrand);
  WR2: space_is_continuum (values_space_of (integrand));
  WR3: definite_integral_expr_check (SELF\multiple_arity_generic_expression.operands,
    lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY;
ENTITY abstracted_expression_function
  SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
  SELF\quantifier_expression.variables : LIST [1:?] OF UNIQUE generic_variable :=
    remove_first(SELF\multiple_arity_generic_expression.operands);
  expr : generic_expression := SELF\multiple_arity_generic_expression.operands[1];
WHERE
  WR1: SIZEOF (QUERY ( operand <*
       SELF\multiple_arity_generic_expression.operands | NOT (
       has_values_space( operand)))) = 0;
END_ENTITY;
ENTITY expression_denoted_function
  SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
  expr : generic_expression := SELF\unary_generic_expression.operand;
WHERE
  WR1: (schema_prefix + 'FUNCTION_SPACE') IN TYPEOF (values_space_of(expr));
END_ENTITY;
ENTITY imported_point_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry : point;
END_ENTITY;
ENTITY imported_curve_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : curve;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_surface_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : surface;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY imported_volume_function
  SUBTYPE OF (maths_function, generic_literal);
  geometry          : volume;
  parametric_domain : tuple_space;
WHERE
  WR1: expression_is_constant(parametric_domain);
END_ENTITY;
ENTITY application_defined_function
  SUBTYPE OF (maths_function);
  explicit_domain : tuple_space;
  explicit_range  : tuple_space;
  parameters      : LIST OF maths_value;
WHERE
  WR1: expression_is_constant(explicit_domain);
  WR2: expression_is_constant(explicit_range);
END_ENTITY;
ENTITY mathematical_description;
  described  : maths_expression;
  describing : STRING;
  encoding   : label;
END_ENTITY;
FUNCTION all_members_of_es(sv : SET OF maths_value;
                           es : elementary_space_enumerators) : LOGICAL;
  CONSTANT
    base_types : SET OF STRING := ['NUMBER','COMPLEX_NUMBER_LITERAL','REAL',
      'INTEGER','LOGICAL','BOOLEAN','STRING','BINARY','MATHS_SPACE',
      'MATHS_FUNCTION','LIST','ELEMENTARY_SPACE_ENUMERATORS','ORDERING_TYPE',
      'LOWER_UPPER','SYMMETRY_TYPE','ELEMENTARY_FUNCTION_ENUMERATORS',
      'OPEN_CLOSED','SPACE_CONSTRAINT_TYPE','REPACKAGE_OPTIONS',
      'EXTENSION_OPTIONS'];
  END_CONSTANT;
  LOCAL
    v : maths_value;
    key_type : STRING := '';
    types : SET OF STRING;
    ge : generic_expression;
    cum : LOGICAL := TRUE;
    vspc : maths_space;
  END_LOCAL;
  IF NOT EXISTS (sv) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  CASE es OF
  es_numbers :         key_type := 'NUMBER';
  es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
  es_reals :           key_type := 'REAL';
  es_integers :        key_type := 'INTEGER';
  es_logicals :        key_type := 'LOGICAL';
  es_booleans :        key_type := 'BOOLEAN';
  es_strings :         key_type := 'STRING';
  es_binarys :         key_type := 'BINARY';
  es_maths_spaces :    key_type := 'MATHS_SPACE';
  es_maths_functions : key_type := 'MATHS_FUNCTION';
  es_generics :        RETURN (TRUE);
  END_CASE;
  REPEAT i := 1 TO SIZEOF (sv);
    IF NOT EXISTS (sv[i]) THEN  RETURN (FALSE);  END_IF;
    v := simplify_maths_value(sv[i]);
    types := stripped_typeof(v);
    IF key_type IN types THEN  SKIP;  END_IF;
    IF (es = es_numbers) AND ('COMPLEX_NUMBER_LITERAL' IN types) THEN  SKIP;  END_IF;
    IF SIZEOF (base_types * types) > 0 THEN  RETURN (FALSE);  END_IF;
    -- Must be a generic_expression which doesn't simplify and which is not a
    -- complex_number_literal, maths_space, or maths_function.
    ge := v;
    IF has_values_space(ge) THEN
      vspc := values_space_of(ge);
      IF NOT subspace_of_es(vspc,es) THEN
        IF NOT compatible_spaces(vspc,make_elementary_space(es)) THEN
          RETURN (FALSE);
        END_IF;
        cum := UNKNOWN;
      END_IF;
    ELSE
      cum := UNKNOWN;
    END_IF;
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (cum);
END_FUNCTION;  -- all_members_of_es
FUNCTION any_space_satisfies(sc  : space_constraint_type;
                             spc : maths_space) : BOOLEAN;
  LOCAL
    spc_id : elementary_space_enumerators;
  END_LOCAL;
  IF (sc = sc_equal) OR NOT ('ELEMENTARY_SPACE' IN stripped_typeof(spc)) THEN
    RETURN (FALSE);
  END_IF;
  spc_id := spc\elementary_space.space_id;
  IF sc = sc_subspace THEN
    RETURN (bool(spc_id = es_generics));
  END_IF;
  IF sc = sc_member THEN
    RETURN (bool((spc_id = es_generics) OR (spc_id = es_maths_spaces)));
  END_IF;
  -- Should be unreachable.
  RETURN (?);
END_FUNCTION;  -- any_space_satisfies
FUNCTION assoc_product_space(ts1, ts2 : tuple_space) : tuple_space;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (ts1);
    types2 : SET OF STRING := stripped_typeof (ts2);
    up1, up2 : uniform_product_space := make_uniform_product_space(the_reals,1);
    lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
    et1, et2, ets : extended_tuple_space := the_tuples;
    use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
    factors : LIST OF maths_space := [];
    tspace : tuple_space;
  END_LOCAL;
  -- Identify type of first operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    up1 := ts1;  use_up1 := true;  use_lp1 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
      lp1 := ts1;  use_up1 := false;  use_lp1 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types1) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et1 := ts1;  use_up1 := false;  use_lp1 := false;
    END_IF;
  END_IF;
  -- Identify type of second operand
  IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
    up2 := ts2;  use_up2 := true;  use_lp2 := false;
  ELSE
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      lp2 := ts2;  use_up2 := false;  use_lp2 := true;
    ELSE
      IF NOT ('EXTENDED_TUPLE_SPACE' IN types2) THEN
        -- Unreachable when this function was written.
        RETURN (?);
      END_IF;
      et2 := ts2;  use_up2 := false;  use_lp2 := false;
    END_IF;
  END_IF;
  -- Construction for each combination of cases
  IF use_up1 THEN
    IF use_up2 THEN
      IF up1.base = up2.base THEN
        tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
      ELSE
        factors := [up1.base : up1.exponent, up2.base : up2.exponent];
        tspace := make_listed_product_space(factors);
      END_IF;
    ELSE
      IF use_lp2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up1.base : up1.exponent];
        factors := factors + lp2.factors;
        tspace := make_listed_product_space(factors);
      ELSE
        tspace := assoc_product_space(up1, et2.base);
        tspace := make_extended_tuple_space(tspace, et2.extender);
      END_IF;
    END_IF;
  ELSE
    IF use_lp1 THEN
      IF use_up2 THEN
        -- Avoid compiler confusion by breaking into two lines.
        factors := [up2.base : up2.exponent];
        factors := lp1.factors + factors;
        tspace := make_listed_product_space(factors);
      ELSE
        IF use_lp2 THEN
          tspace := make_listed_product_space(lp1.factors + lp2.factors);
        ELSE
          tspace := assoc_product_space(lp1, et2.base);
          tspace := make_extended_tuple_space(tspace, et2.extender);
        END_IF;
      END_IF;
    ELSE
      IF use_up2 THEN
        IF et1.extender = up2.base THEN
          tspace := assoc_product_space(et1.base, up2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          -- No subtype is available to represent this cartesian product.
          RETURN (?);
        END_IF;
      ELSE
        IF use_lp2 THEN
          factors := lp2.factors;
          REPEAT i := 1 TO SIZEOF (factors);
            IF et1.extender <> factors[i] THEN
              -- No subtype available to represent this cartesian product.
              RETURN (?);
            END_IF;
          END_REPEAT;
          tspace := assoc_product_space(et1.base, lp2);
          tspace := make_extended_tuple_space(tspace, et1.extender);
        ELSE
          IF et1.extender = et2.extender THEN
            -- Next line may assign indeterminate (?) to tspace.
            tspace := assoc_product_space(et1, et2.base);
          ELSE
            -- No subtype available to represent this cartesian product.
            RETURN (?);
          END_IF;
        END_IF;
      END_IF;
    END_IF;
  END_IF;
  RETURN (tspace);
END_FUNCTION;  -- assoc_product_space
FUNCTION atan2(y, x : REAL) : REAL;
  LOCAL
    r : REAL;
  END_LOCAL;
  IF (y = 0.0) AND (x = 0.0) THEN  RETURN (?);  END_IF;
  r := atan(y,x);
  IF x < 0.0 THEN
    IF y < 0.0 THEN  r := r - PI;
    ELSE             r := r + PI;  END_IF;
  END_IF;
  RETURN (r);
END_FUNCTION;  -- atan2
FUNCTION bool(lgcl: LOGICAL) : BOOLEAN;
  IF NOT EXISTS (lgcl) THEN  RETURN (FALSE);  END_IF;
  IF lgcl <> TRUE      THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- bool
FUNCTION check_sparse_index_domain(idxdom : tuple_space;
                                   base   : zero_or_one;
                                   shape  : LIST [1:?] OF positive_integer;
                                   order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  mthspc := factor1(idxdom);
  -- A consequence of WR1 of basic_sparse_matrix is that here we need only
  -- consider the case that mthspc is a finite integer interval and is the only
  -- factor space of idxdom.
  interval := mthspc;
  IF order = by_rows THEN  i := 1;  ELSE  i := 2;  END_IF;
  RETURN (bool((interval.min <= base) AND (interval.max >= base + shape[i])));
  -- The index function is evaluated at (base+shape[i]) when determining the
  -- upper search bound for entries of the last row or column, respectively.
END_FUNCTION;  -- check_sparse_index_domain;
FUNCTION check_sparse_loc_range(locrng : tuple_space;
                                base   : zero_or_one;
                                shape  : LIST [1:?] OF positive_integer;
                                order  : ordering_type) : BOOLEAN;
  LOCAL
    mthspc : maths_space;
    interval : finite_integer_interval;
    i : INTEGER;
  END_LOCAL;
  IF space_dimension(locrng) <> 1 THEN  RETURN (FALSE);  END_IF;
  mthspc := factor1(locrng);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (mthspc)) THEN
    RETURN (FALSE);
  END_IF;
  interval := mthspc;
  IF order = by_rows THEN  i := 2;  ELSE  i := 1;  END_IF;
  RETURN (bool((interval.min >= base) AND (interval.max <= base + shape[i] - 1)));
END_FUNCTION;  -- check_sparse_loc_range;
FUNCTION check_sparse_index_to_loc(index_range, loc_domain : tuple_space) : BOOLEAN;
  LOCAL
    temp : maths_space;
    idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
  END_LOCAL;
  temp := factor1 (index_range);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  idx_rng_itvl := temp;
  temp := factor1 (loc_domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (temp) THEN
    temp := factor1 (temp);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  loc_dmn_itvl := temp;
  RETURN (bool((loc_dmn_itvl.min <= idx_rng_itvl.min) AND
    (idx_rng_itvl.max <= loc_dmn_itvl.max+1)));
END_FUNCTION;  -- check_sparse_index_to_loc
FUNCTION compare_basis_and_coef(basis : LIST [1:?] OF b_spline_basis;
                                coef  : maths_function) : BOOLEAN;
  LOCAL
    shape : LIST OF positive_integer;
  END_LOCAL;
  IF NOT EXISTS (basis) OR NOT EXISTS (coef) THEN  RETURN (FALSE);  END_IF;
  shape := shape_of_array(coef);
  IF NOT EXISTS (shape) THEN  RETURN (FALSE);  END_IF;
  IF SIZEOF (shape) < SIZEOF (basis) THEN  RETURN (FALSE);  END_IF;
  REPEAT i := 1 TO SIZEOF (basis);
    IF (basis[i].num_basis = shape[i]) <> TRUE THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_basis_and_coef
FUNCTION compare_list_and_value(lv : LIST OF GENERIC:G;
                                op : elementary_function_enumerators;
                                v  : GENERIC:G) : BOOLEAN;
  IF NOT EXISTS (lv) OR NOT EXISTS (op) OR NOT EXISTS (v) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO SIZEOF (lv);
    IF NOT compare_values(lv[i], op, v) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- compare_list_and_value
FUNCTION compare_values(v1 : GENERIC:G;
                        op : elementary_function_enumerators;
                        v2 : GENERIC:G) : BOOLEAN;
  -- This algorithm assumes a comparison between "incompatible" types will
  -- produce the indeterminate value (or UNKNOWN?).
  LOCAL
    logl : LOGICAL := UNKNOWN;
  END_LOCAL;
  IF NOT EXISTS (v1) OR NOT EXISTS (op) OR NOT EXISTS (v2) THEN
    RETURN (FALSE);
  END_IF;
  CASE op OF
  ef_eq_i : logl := (v1 = v2);
  ef_ne_i : logl := (v1 <> v2);
  ef_gt_i : logl := (v1 > v2);
  ef_lt_i : logl := (v1 < v2);
  ef_ge_i : logl := (v1 >= v2);
  ef_le_i : logl := (v1 <= v2);
  END_CASE;
  IF EXISTS (logl) THEN
    IF logl = TRUE THEN  RETURN (TRUE);  END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- compare_values
FUNCTION compatible_complex_number_regions(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF string := stripped_typeof (sp1);
    crgn1, crgn2 : cartesian_complex_number_region;
    prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
    sp1_is_crgn, sp2_is_crgn : BOOLEAN;
  END_LOCAL;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp1_is_crgn := TRUE;
    crgn1 := sp1;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp1_is_crgn := FALSE;
      prgn1 := sp1;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  typenames := stripped_typeof (sp2);
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN typenames THEN
    sp2_is_crgn := TRUE;
    crgn2 := sp2;
  ELSE
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN
      sp2_is_crgn := FALSE;
      prgn2 := sp2;
    ELSE
      -- Improper usage: Default response is to assume compatibility.
      RETURN (TRUE);
    END_IF;
  END_IF;
  IF sp1_is_crgn AND sp2_is_crgn THEN
    -- two cartesian regions
    RETURN (compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)
      AND compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
  END_IF;
  IF NOT sp1_is_crgn AND NOT sp2_is_crgn AND
    (prgn1.centre.real_part = prgn2.centre.real_part) AND
    (prgn1.centre.imag_part = prgn2.centre.imag_part) THEN
    -- two polar regions with common centre
    IF NOT compatible_intervals(prgn1.distance_constraint,
      prgn2.distance_constraint) THEN
      RETURN (FALSE);
    END_IF;
    IF compatible_intervals(prgn1.direction_constraint,
      prgn2.direction_constraint) THEN
      RETURN (TRUE);
    END_IF;
    -- Deal with direction ambiguity by 2 pi.
    IF (prgn1.direction_constraint.max > PI) AND (prgn2.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn2.direction_constraint,
        make_finite_real_interval(-PI,open,prgn1.direction_constraint.max-2.0*PI,
        prgn1.direction_constraint.max_closure)));
    END_IF;
    IF (prgn2.direction_constraint.max > PI) AND (prgn1.direction_constraint.max < PI)
      THEN
      RETURN (compatible_intervals(prgn1.direction_constraint,
        make_finite_real_interval(-PI,open,prgn2.direction_constraint.max-2.0*PI,
        prgn2.direction_constraint.max_closure)));
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Make do with imperfect tests for remaining cases.
  IF sp1_is_crgn AND NOT sp2_is_crgn THEN
    crgn2 := enclose_pregion_in_cregion(prgn2);
    prgn1 := enclose_cregion_in_pregion(crgn1,prgn2.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  IF NOT sp1_is_crgn AND sp2_is_crgn THEN
    crgn1 := enclose_pregion_in_cregion(prgn1);
    prgn2 := enclose_cregion_in_pregion(crgn2,prgn1.centre);
    RETURN (compatible_complex_number_regions(crgn1,crgn2)
      AND compatible_complex_number_regions(prgn1,prgn2));
  END_IF;
  -- Two polar regions with different centres
  prgn1c2 := enclose_pregion_in_pregion(prgn1,prgn2.centre);
  prgn2c1 := enclose_pregion_in_pregion(prgn2,prgn1.centre);
  RETURN (compatible_complex_number_regions(prgn1,prgn2c1)
    AND compatible_complex_number_regions(prgn1c2,prgn2));
END_FUNCTION;  -- compatible_complex_number_regions
FUNCTION compatible_es_values(esval1, esval2 : elementary_space_enumerators) : BOOLEAN;
  LOCAL
    esval1_is_numeric, esval2_is_numeric : LOGICAL;
  END_LOCAL;
  IF (esval1 = esval2) OR (esval1 = es_generics) OR (esval2 = es_generics) THEN
    RETURN (TRUE);
  END_IF;
  esval1_is_numeric := (esval1 >= es_numbers) AND (esval1 <= es_integers);
  esval2_is_numeric := (esval2 >= es_numbers) AND (esval2 <= es_integers);
  IF (esval1_is_numeric AND (esval2 = es_numbers)) OR
    (esval2_is_numeric AND (esval1 = es_numbers)) THEN
    RETURN (TRUE);
  END_IF;
  IF esval1_is_numeric XOR esval2_is_numeric THEN
    RETURN (FALSE);
  END_IF;
  IF ((esval1 = es_logicals) AND (esval2 = es_booleans)) OR
    ((esval1 = es_booleans) AND (esval2 = es_logicals)) THEN
    RETURN (TRUE);
  END_IF;
  -- All other cases are incompatible
  RETURN (FALSE);
END_FUNCTION;  -- compatible_es_values
FUNCTION compatible_intervals(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    amin, amax : REAL;
  END_LOCAL;
  IF min_exists(sp1) AND max_exists(sp2) THEN
    amin := real_min(sp1);  amax := real_max(sp2);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp1) AND max_included(sp2));
    END_IF;
  END_IF;
  IF min_exists(sp2) AND max_exists(sp1) THEN
    amin := real_min(sp2);  amax := real_max(sp1);
    IF amin > amax THEN  RETURN (FALSE);  END_IF;
    IF amin = amax THEN
      RETURN (min_included(sp2) AND max_included(sp1));
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- compatible_intervals
FUNCTION compatible_spaces(sp1, sp2 : maths_space) : BOOLEAN;
  LOCAL
    types1 : SET OF STRING := stripped_typeof (sp1);
    types2 : SET OF STRING := stripped_typeof (sp2);
    lgcl : LOGICAL := UNKNOWN;
    m, n : INTEGER;
    s1, s2 : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN types1 THEN
    REPEAT i := 1 TO SIZEOF (sp1\finite_space.members);
      lgcl := member_of(sp1\finite_space.members[i], sp2);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types2 THEN
    REPEAT i := 1 TO SIZEOF (sp2\finite_space.members);
      lgcl := member_of(sp2\finite_space.members[i], sp1);
      IF lgcl <> FALSE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (FALSE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF sp1\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id,
        sp2\elementary_space.space_id));
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types2) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types2) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types2) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types2) THEN
      RETURN (compatible_es_values(sp1\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (bool(sp1\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types2 THEN
    IF sp2\elementary_space.space_id = es_generics THEN
      RETURN (TRUE);
    END_IF;
    IF ('FINITE_INTEGER_INTERVAL' IN types1) OR
      ('INTEGER_INTERVAL_FROM_MIN' IN types1) OR
      ('INTEGER_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_integers));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types1) OR
      ('REAL_INTERVAL_FROM_MIN' IN types1) OR
      ('REAL_INTERVAL_TO_MAX' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_reals));
    END_IF;
    IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types1) OR
      ('POLAR_COMPLEX_NUMBER_REGION' IN types1) THEN
      RETURN (compatible_es_values(sp2\elementary_space.space_id, es_complex_numbers));
    END_IF;
    IF 'TUPLE_SPACE' IN types1 THEN
      RETURN (FALSE);
    END_IF;
    IF 'FUNCTION_SPACE' IN types1 THEN
      RETURN (bool(sp2\elementary_space.space_id = es_maths_functions));
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF subspace_of_es(sp1,es_integers) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_integers) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_integers) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_reals) THEN  -- Note that sp1 finite already handled.
    IF subspace_of_es(sp2,es_reals) THEN  -- Note that sp2 finite already handled.
      RETURN (compatible_intervals(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_reals) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp1,es_complex_numbers) THEN  -- Note sp1 finite already handled.
    IF subspace_of_es(sp2,es_complex_numbers) THEN  -- Note sp2 finite already handled.
      RETURN (compatible_complex_number_regions(sp1,sp2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(sp2,es_complex_numbers) THEN
    RETURN (FALSE);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN types1 THEN
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF sp1\uniform_product_space.exponent <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      RETURN (compatible_spaces(sp1\uniform_product_space.base,
        sp2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      n := SIZEOF (sp2\listed_product_space.factors);
      IF sp1\uniform_product_space.exponent <> n THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\uniform_product_space.base,
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := sp1\uniform_product_space.exponent;
      n := space_dimension(sp2\extended_tuple_space.base);
      IF m < n THEN
        RETURN (FALSE);
      END_IF;
      IF m = n THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, m - n))));
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types1 THEN
    n := SIZEOF (sp1\listed_product_space.factors);
    IF 'UNIFORM_PRODUCT_SPACE' IN types2 THEN
      IF n <> sp2\uniform_product_space.exponent THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp2\uniform_product_space.base,
          sp1\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN types2 THEN
      IF n <> SIZEOF (sp2\listed_product_space.factors) THEN
        RETURN (FALSE);
      END_IF;
      REPEAT i := 1 TO n;
        IF NOT compatible_spaces(sp1\listed_product_space.factors[i],
          sp2\listed_product_space.factors[i]) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (FALSE);
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1, sp2\extended_tuple_space.base));
      END_IF;
      RETURN (compatible_spaces(sp1, assoc_product_space(
        sp2\extended_tuple_space.base, make_uniform_product_space(
        sp2\extended_tuple_space.extender, n - m))));
    END_IF;
    IF (schema_prefix + 'FUNCTION_SPACE') IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF ('UNIFORM_PRODUCT_SPACE' IN types2) OR
      ('LISTED_PRODUCT_SPACE' IN types2) THEN
      RETURN (compatible_spaces(sp2, sp1));
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF NOT compatible_spaces(sp1\extended_tuple_space.extender,
        sp2\extended_tuple_space.extender) THEN
        RETURN (FALSE);
      END_IF;
      n := space_dimension(sp1\extended_tuple_space.base);
      m := space_dimension(sp2\extended_tuple_space.base);
      IF n < m THEN
        RETURN (compatible_spaces(assoc_product_space(sp1\extended_tuple_space.base,
          make_uniform_product_space(sp1\extended_tuple_space.extender, m - n)),
          sp2\extended_tuple_space.base));
      END_IF;
      IF n = m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          sp2\extended_tuple_space.base));
      END_IF;
      IF n > m THEN
        RETURN (compatible_spaces(sp1\extended_tuple_space.base,
          assoc_product_space(sp2\extended_tuple_space.base,
          make_uniform_product_space(sp2\extended_tuple_space.extender, n - m))));
      END_IF;
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      RETURN (FALSE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'FUNCTION_SPACE' IN types2 THEN
      s1 := sp1\function_space.domain_argument;
      s2 := sp2\function_space.domain_argument;
      CASE sp1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.domain_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      s1 := sp1\function_space.range_argument;
      s2 := sp2\function_space.range_argument;
      CASE sp1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s1, s2) AND subspace_of(s2, s1);
        sc_subspace : lgcl := subspace_of(s1, s2);
        sc_member : lgcl := member_of(s1, s2);
        END_CASE;
        END;
      sc_subspace :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := subspace_of(s2, s1);
        sc_subspace : lgcl := compatible_spaces(s1, s2);
        sc_member : lgcl := UNKNOWN;
        END_CASE;
        END;
      sc_member :BEGIN
        CASE sp2\function_space.range_constraint OF
        sc_equal : lgcl := member_of(s2, s1);
        sc_subspace : lgcl := UNKNOWN;
        sc_member : lgcl := compatible_spaces(s1, s2);
        END_CASE;
        END;
      END_CASE;
      IF lgcl = FALSE THEN
        RETURN (FALSE);
      END_IF;
      RETURN (TRUE);
    END_IF;
    -- Should be unreachable.
    RETURN (TRUE);
  END_IF;
  -- Should be unreachable.
  RETURN (TRUE);
END_FUNCTION;  -- compatible_spaces
FUNCTION composable_sequence(operands : LIST [2:?] OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (operands) - 1;
    IF NOT compatible_spaces (operands[i].range, operands[i+1].domain) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- composable_sequence
FUNCTION convert_to_literal(val : maths_atom) : generic_literal;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
  END_LOCAL;
  IF 'INTEGER' IN types THEN  RETURN (make_int_literal (val));      END_IF;
  IF 'REAL'    IN types THEN  RETURN (make_real_literal (val));     END_IF;
  IF 'BOOLEAN' IN types THEN  RETURN (make_boolean_literal (val));  END_IF;
  IF 'STRING'  IN types THEN  RETURN (make_string_literal (val));   END_IF;
  IF 'LOGICAL' IN types THEN  RETURN (make_logical_literal (val));  END_IF;
  IF 'BINARY'  IN types THEN  RETURN (make_binary_literal (val));   END_IF;
  IF (schema_prefix + 'MATHS_ENUM_ATOM') IN types THEN
    RETURN (make_maths_enum_literal (val));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_literal
FUNCTION convert_to_maths_function(func : maths_function_select) : maths_function;
  LOCAL
    efenum : elementary_function_enumerators;
    mthfun : maths_function;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_FUNCTION') IN TYPEOF (func) THEN
    mthfun := func;
  ELSE
    efenum := func;
    mthfun := make_elementary_function (efenum);
  END_IF;
  RETURN (mthfun);
END_FUNCTION;  -- convert_to_maths_function
FUNCTION convert_to_maths_value(val : GENERIC:G) : maths_value;
  LOCAL
    types : SET OF STRING := TYPEOF (val);
    ival  : maths_integer;
    rval  : maths_real;
    nval  : maths_number;
    tfval : maths_boolean;
    lval  : maths_logical;
    sval  : maths_string;
    bval  : maths_binary;
    tval  : maths_tuple := the_empty_maths_tuple;
    mval  : maths_value;
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VALUE') IN types THEN  RETURN (val);  END_IF;
  IF 'INTEGER' IN types THEN  ival := val;   RETURN (ival);   END_IF;
  IF 'REAL'    IN types THEN  rval := val;   RETURN (rval);   END_IF;
  IF 'NUMBER'  IN types THEN  nval := val;   RETURN (nval);   END_IF;
  IF 'BOOLEAN' IN types THEN  tfval := val;  RETURN (tfval);  END_IF;
  IF 'LOGICAL' IN types THEN  lval := val;   RETURN (lval);   END_IF;
  IF 'STRING'  IN types THEN  sval := val;   RETURN (sval);   END_IF;
  IF 'BINARY'  IN types THEN  bval := val;   RETURN (bval);   END_IF;
  IF 'LIST' IN types THEN
    REPEAT i := 1 TO SIZEOF (val);
      mval := convert_to_maths_value (val[i]);
      IF NOT EXISTS (mval) THEN  RETURN (?);  END_IF;
      INSERT (tval, mval, i-1);
    END_REPEAT;
    RETURN (tval);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- convert_to_maths_value
FUNCTION convert_to_operand(val : maths_value) : generic_expression;
  LOCAL
    types  : SET OF STRING := stripped_typeof (val);
  END_LOCAL;
  -- Use intermediate variables of appropriate declared types to help the compilers.
  IF 'GENERIC_EXPRESSION' IN types THEN  RETURN (val);  END_IF;
  IF 'MATHS_ATOM' IN types THEN  RETURN (convert_to_literal (val));  END_IF;
  IF 'ATOM_BASED_VALUE' IN types THEN  RETURN (make_atom_based_literal(val));  END_IF;
  IF 'MATHS_TUPLE' IN types THEN  RETURN (make_maths_tuple_literal(val));  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- convert_to_operand
FUNCTION convert_to_operands(values : AGGREGATE OF maths_value)
                            : LIST OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
    loc : INTEGER := 0;
  END_LOCAL;
  IF NOT EXISTS (values) THEN  RETURN (?);  END_IF;
  REPEAT i := LOINDEX (values) TO HIINDEX (values);
    INSERT (operands, convert_to_operand (values[i]), loc);
    loc := loc + 1;
  END_REPEAT;
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands
FUNCTION convert_to_operands_prcmfn(srcdom  : maths_space_or_function;
                                    prepfun : LIST OF maths_function;
                                    finfun  : maths_function_select)
                                   : LIST [2:?] OF generic_expression;
  LOCAL
    operands : LIST OF generic_expression := [];
  END_LOCAL;
  INSERT (operands, srcdom, 0);
  REPEAT i := 1 TO SIZEOF (prepfun);
    INSERT (operands, prepfun[i], i);
  END_REPEAT;
  INSERT (operands, convert_to_maths_function (finfun), SIZEOF (prepfun)+1);
  RETURN (operands);
END_FUNCTION;  -- convert_to_operands_prcmfn
FUNCTION definite_integral_check(domain   : tuple_space;
                                 vrblint  : input_selector;
                                 lowerinf : BOOLEAN;
                                 upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  k := vrblint;
  IF k > dim THEN  RETURN (FALSE);  END_IF;
  fspc := factor_space (domn, k);
  IF NOT ((schema_prefix + 'REAL_INTERVAL') IN TYPEOF (fspc)) THEN
    RETURN (FALSE);
  END_IF;
  IF lowerinf AND min_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  IF upperinf AND max_exists (fspc) THEN  RETURN (FALSE);  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_check
FUNCTION definite_integral_expr_check(operands : LIST [2:?] OF generic_expression;
                                      lowerinf : BOOLEAN;
                                      upperinf : BOOLEAN) : BOOLEAN;
  LOCAL
    nops : INTEGER := 2;
    vspc : maths_space;
    dim : nonnegative_integer;
    k : positive_integer;
    bspc : maths_space;
  END_LOCAL;
  IF NOT lowerinf THEN  nops := nops + 1;  END_IF;
  IF NOT upperinf THEN  nops := nops + 1;  END_IF;
  IF SIZEOF (operands) <> nops THEN  RETURN (FALSE);  END_IF;
  IF NOT ('GENERIC_VARIABLE' IN stripped_typeof(operands[2])) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT has_values_space (operands[2]) THEN  RETURN (FALSE);  END_IF;
  vspc := values_space_of (operands[2]);
  IF NOT ('REAL_INTERVAL' IN stripped_typeof(vspc)) THEN  RETURN (FALSE);  END_IF;
  IF lowerinf THEN
    IF min_exists (vspc) THEN  RETURN (FALSE);  END_IF;
    k := 3;
  ELSE
    IF NOT has_values_space (operands[3]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[3]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
    k := 4;
  END_IF;
  IF upperinf THEN
    IF max_exists (vspc) THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF NOT has_values_space (operands[k]) THEN  RETURN (FALSE);  END_IF;
    bspc := values_space_of (operands[k]);
    IF NOT compatible_spaces (bspc, vspc) THEN  RETURN (FALSE);  END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- definite_integral_expr_check
FUNCTION derive_definite_integral_domain(igrl : definite_integral_function)
                                        : tuple_space;

  -- Internal utility function:
  FUNCTION process_product_space(spc         : product_space;
                                 idx, prefix : INTEGER;
                                 vdomn       : maths_space) : product_space;
    LOCAL
      uspc : uniform_product_space;
      expnt : INTEGER;
      factors : LIST OF maths_space;
    END_LOCAL;
    IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN TYPEOF (spc) THEN
      uspc := spc;
      expnt := uspc.exponent + prefix;
      IF idx <= uspc.exponent THEN  expnt := expnt - 1;  END_IF;
      IF expnt = 0 THEN
        RETURN (make_listed_product_space([]));
      ELSE
        RETURN (make_uniform_product_space(uspc.base,expnt));
      END_IF;
    ELSE
      factors := spc\listed_product_space.factors;
      IF idx <= SIZEOF (factors) THEN  REMOVE (factors, idx);  END_IF;
      IF prefix > 0 THEN
        INSERT (factors, vdomn, 0);
        IF prefix > 1 THEN  INSERT (factors, vdomn, 0);  END_IF;
      END_IF;
      RETURN (make_listed_product_space(factors));
    END_IF;
  END_FUNCTION;  -- process_product_space

  -- Resume body of derive_definite_integral_domain function
  LOCAL
    idomn : tuple_space := igrl.integrand.domain;
    types : SET OF STRING := TYPEOF (idomn);
    idx : INTEGER := igrl.variable_of_integration;
    tupled : BOOLEAN := bool(((space_dimension(idomn) = 1) AND
                             ((schema_prefix + 'TUPLE_SPACE') IN types)));
    prefix : INTEGER := 0;
    espc : extended_tuple_space;
    vdomn : maths_space;
  END_LOCAL;
  IF tupled THEN
    idomn := factor1(idomn);
    types := TYPEOF (idomn);
  END_IF;
  IF igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;  END_IF;
  IF igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;  END_IF;
  vdomn := factor_space(idomn,idx);
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    espc := idomn;
    idomn := make_extended_tuple_space(process_product_space(espc.base,idx,
      prefix,vdomn),espc.extender);
  ELSE
    idomn := process_product_space(idomn,idx,prefix,vdomn);
  END_IF;
  IF tupled THEN  RETURN (one_tuples_of(idomn));
  ELSE            RETURN (idomn);                 END_IF;
END_FUNCTION;  -- derive_definite_integral_domain
FUNCTION derive_elementary_function_domain(ef_val : elementary_function_enumerators)
                                          : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_or : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_logicals));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (the_integer_tuples);
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_multiply_i : RETURN (the_integer_tuples);
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_eq_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ne_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_gt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_lt_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_ge_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_le_i : RETURN (make_uniform_product_space (the_integers, 2));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_listed_product_space ([the_logicals, the_integers,
    the_integers]));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (the_real_tuples);
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_multiply_r : RETURN (the_real_tuples);
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_exponentiate_r : RETURN (make_listed_product_space ([the_nonnegative_reals,
    the_reals]));
  ef_exponentiate_ri : RETURN (make_listed_product_space ([the_reals, the_integers]));
  ef_eq_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ne_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_gt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_lt_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_ge_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_le_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_abs_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_reals, 2));
  ef_cos_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_listed_product_space ([the_logicals, the_reals, the_reals]));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (the_complex_tuples);
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_multiply_c : RETURN (the_complex_tuples);
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_exponentiate_ci : RETURN (make_listed_product_space ([the_complex_numbers,
    the_integers]));
  ef_eq_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_ne_c : RETURN (make_uniform_product_space (the_complex_numbers, 2));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_listed_product_space ([the_logicals, the_complex_numbers,
    the_complex_numbers]));
  ef_subscript_s : RETURN (make_listed_product_space ([the_strings, the_integers]));
  ef_eq_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ne_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_gt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_lt_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_ge_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_le_s : RETURN (make_uniform_product_space (the_strings, 2));
  ef_subsequence_s : RETURN (make_listed_product_space ([the_strings, the_integers,
    the_integers]));
  ef_concat_s : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_strings));
  ef_size_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_format : RETURN (make_listed_product_space ([the_numbers, the_strings]));
  ef_value : RETURN (make_uniform_product_space (the_strings, 1));
  ef_like : RETURN (make_uniform_product_space (the_strings, 2));
  ef_if_s : RETURN (make_listed_product_space ([the_logicals, the_strings,
    the_strings]));
  ef_subscript_b : RETURN (make_listed_product_space ([the_binarys, the_integers]));
  ef_eq_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ne_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_gt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_lt_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_ge_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_le_b : RETURN (make_uniform_product_space (the_binarys, 2));
  ef_subsequence_b : RETURN (make_listed_product_space ([the_binarys, the_integers,
    the_integers]));
  ef_concat_b : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_binarys));
  ef_size_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_if_b : RETURN (make_listed_product_space ([the_logicals, the_binarys,
    the_binarys]));
  ef_subscript_t : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_eq_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_ne_t : RETURN (make_uniform_product_space (the_tuples, 2));
  ef_concat_t : RETURN (make_extended_tuple_space (the_zero_tuple_space, the_tuples));
  ef_size_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_entuple : RETURN (the_tuples);
  ef_detuple : RETURN (make_uniform_product_space (the_generics, 1));
  ef_insert : RETURN (make_listed_product_space ([the_tuples, the_generics,
    the_integers]));
  ef_remove : RETURN (make_listed_product_space ([the_tuples, the_integers]));
  ef_if_t : RETURN (make_listed_product_space ([the_logicals, the_tuples,
    the_tuples]));
  ef_sum_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_add_it : RETURN (make_extended_tuple_space (the_integer_tuples,
    the_integer_tuples));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_scalar_mult_it : RETURN (make_listed_product_space ([the_integers,
    the_integer_tuples]));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integer_tuples, 2));
  ef_sum_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_add_rt : RETURN (make_extended_tuple_space (the_real_tuples, the_real_tuples));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_scalar_mult_rt : RETURN (make_listed_product_space ([the_reals,
    the_real_tuples]));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_real_tuples, 2));
  ef_norm_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_add_ct : RETURN (make_extended_tuple_space (the_complex_tuples,
    the_complex_tuples));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_scalar_mult_ct : RETURN (make_listed_product_space ([the_complex_numbers,
    the_complex_tuples]));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_tuples, 2));
  ef_norm_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_if : RETURN (make_listed_product_space ([the_logicals, the_generics,
    the_generics]));
  ef_ensemble : RETURN (the_tuples);
  ef_member_of : RETURN (make_listed_product_space ([the_generics, the_maths_spaces]));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_domain
FUNCTION derive_elementary_function_range(ef_val : elementary_function_enumerators)
                                         : tuple_space;
  IF NOT EXISTS (ef_val) THEN  RETURN (?);  END_IF;
  CASE ef_val OF
  ef_and : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_or : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_not : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_xor : RETURN (make_uniform_product_space (the_logicals, 2));
  ef_negate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_subtract_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_multiply_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_divide_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_mod_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_exponentiate_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_eq_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_i : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_i : RETURN (make_uniform_product_space (the_integers, 1));
  ef_negate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_reciprocal_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_subtract_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_multiply_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_divide_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_mod_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_exponentiate_ri : RETURN (make_uniform_product_space (the_reals, 1));
  ef_eq_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_r : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_abs_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_acos_r : RETURN (make_uniform_product_space (the_zero_pi_interval, 1));
  ef_asin_r : RETURN (make_uniform_product_space (the_neghalfpi_halfpi_interval, 1));
  ef_atan2_r : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_exp_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_ln_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log2_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_log10_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sin_r : RETURN (make_uniform_product_space (the_neg1_one_interval, 1));
  ef_sqrt_r : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_tan_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_if_r : RETURN (make_uniform_product_space (the_reals, 1));
  ef_negate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_reciprocal_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subtract_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_multiply_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_divide_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exponentiate_ci : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_eq_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_c : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_conjugate_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_abs_c : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_arg_c : RETURN (make_uniform_product_space (the_negpi_pi_interval, 1));
  ef_cos_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_exp_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_ln_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sin_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_sqrt_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_tan_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_if_c : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_subscript_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_eq_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_s : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_concat_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_size_s : RETURN (make_uniform_product_space (the_integers, 1));
  ef_format : RETURN (make_uniform_product_space (the_strings, 1));
  ef_value : RETURN (make_uniform_product_space (the_reals, 1));
  ef_like : RETURN (make_uniform_product_space (the_booleans, 1));
  ef_if_s : RETURN (make_uniform_product_space (the_strings, 1));
  ef_subscript_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_eq_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_gt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_lt_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ge_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_le_b : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_subsequence_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_concat_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_size_b : RETURN (make_uniform_product_space (the_integers, 1));
  ef_if_b : RETURN (make_uniform_product_space (the_binarys, 1));
  ef_subscript_t : RETURN (make_uniform_product_space (the_generics, 1));
  ef_eq_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_ne_t : RETURN (make_uniform_product_space (the_logicals, 1));
  ef_concat_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_size_t : RETURN (make_uniform_product_space (the_integers, 1));
  ef_entuple : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_detuple : RETURN (the_tuples);
  ef_insert : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_remove : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_if_t : RETURN (make_uniform_product_space (the_tuples, 1));
  ef_sum_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_product_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_add_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_subtract_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_scalar_mult_it : RETURN (make_uniform_product_space (the_integer_tuples, 1));
  ef_dot_prod_it : RETURN (make_uniform_product_space (the_integers, 1));
  ef_sum_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_product_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_add_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_subtract_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_scalar_mult_rt : RETURN (make_uniform_product_space (the_real_tuples, 1));
  ef_dot_prod_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_norm_rt : RETURN (make_uniform_product_space (the_reals, 1));
  ef_sum_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_product_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_add_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_subtract_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_scalar_mult_ct : RETURN (make_uniform_product_space (the_complex_tuples, 1));
  ef_dot_prod_ct : RETURN (make_uniform_product_space (the_complex_numbers, 1));
  ef_norm_ct : RETURN (make_uniform_product_space (the_nonnegative_reals, 1));
  ef_if : RETURN (make_uniform_product_space (the_generics, 1));
  ef_ensemble : RETURN (make_uniform_product_space (the_maths_spaces, 1));
  ef_member_of : RETURN (make_uniform_product_space (the_logicals, 1));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- derive_elementary_function_range
FUNCTION derive_finite_function_domain(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                      : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][1];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 1);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_domain
FUNCTION derive_finite_function_range(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                                     : tuple_space;
  LOCAL
    result : SET OF maths_value := [];
  END_LOCAL;
-- An ambiguity in ISO 10303-11:1994 pages 99-101 leaves the result of the following
-- three lines ambiguous in those cases where an operand is simultaneously a member
-- of the base type and the aggregate type.
-- REPEAT i := 1 TO SIZEOF (pairs);
--   result := result + pairs[i][2];
-- END_REPEAT;
-- The next line unions an empty set and the desired list to get the desired set.
  result := result + list_selected_components (pairs, 2);
  RETURN (one_tuples_of (make_finite_space (result)));
END_FUNCTION;  -- derive_finite_function_range
FUNCTION derive_function_domain(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    shape : LIST OF positive_integer;
    sidxs  : LIST OF INTEGER := [0];
    itvl   : finite_integer_interval;
    factors : LIST OF finite_integer_interval := [];
    is_uniform : BOOLEAN := TRUE;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_domain (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_domain (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    IF func\repackaging_function.input_repack = ro_nochange THEN
      RETURN (func\repackaging_function.operand.domain);
    END_IF;
    IF func\repackaging_function.input_repack = ro_wrap_as_tuple THEN
      RETURN (factor1 (func\repackaging_function.operand.domain));
    END_IF;
    IF func\repackaging_function.input_repack = ro_unwrap_tuple THEN
      RETURN (one_tuples_of (func\repackaging_function.operand.domain));
    END_IF;
    -- Unreachable, as there is no other possible value for input_repack.
    RETURN (?);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    shape := shape_of_array(func\unary_generic_expression.operand);
    sidxs := func\reindexed_array_function.starting_indices;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[i], sidxs[i]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[1].domain);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    shape := func\explicit_table_function.shape;
    sidxs[1] := func\explicit_table_function.index_base;
    REPEAT i := 1 TO SIZEOF (shape);
      itvl := make_finite_integer_interval (sidxs[1], sidxs[1]+shape[i]-1);
      INSERT (factors, itvl, i-1);
      IF shape[i] <> shape[1] THEN  is_uniform := FALSE;  END_IF;
    END_REPEAT;
    IF is_uniform THEN
      RETURN (make_uniform_product_space (factors[1], SIZEOF (shape)));
    END_IF;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [func\general_linear_function.sum_index] - 1)));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_finite_real_interval
      (func\b_spline_basis.repeated_knots[func\b_spline_basis.order], closed,
      func\b_spline_basis.repeated_knots[func\b_spline_basis.num_basis+1], closed)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\b_spline_function.basis);
      tspace := assoc_product_space (tspace, func\b_spline_function.basis[i].domain);
    END_REPEAT;
    RETURN (one_tuples_of (tspace));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    RETURN (func\rationalize_function.fun.domain);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (func\partial_derivative_function.derivand.domain);
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (derive_definite_integral_domain(func));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (func\abstracted_expression_function.variables);
      tspace := assoc_product_space (tspace, one_tuples_of (values_space_of
        (func\abstracted_expression_function.variables[i])));
    END_REPEAT;
    RETURN (tspace);
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      domain_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_listed_product_space ([])));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
    RETURN (func\imported_curve_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
    RETURN (func\imported_surface_function.parametric_domain);
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
    RETURN (func\imported_volume_function.parametric_domain);
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_domain);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_domain
FUNCTION derive_function_range(func : maths_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(func);
    tspace : tuple_space := make_listed_product_space ([]);
    m, n : nonnegative_integer := 0;
    temp : INTEGER := 0;
  END_LOCAL;
  IF 'FINITE_FUNCTION' IN typenames THEN
    RETURN (derive_finite_function_range (func\finite_function.pairs));
  END_IF;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_finite_space ([func\constant_function.sole_output])));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    tspace := func.domain;
    IF (space_dimension(tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
      TYPEOF (tspace)) THEN
      tspace := factor1 (tspace);
    END_IF;
    RETURN (one_tuples_of (factor_space (tspace, func\selector_function.selector)));
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN typenames THEN
    RETURN (derive_elementary_function_range (func\elementary_function.func_id));
  END_IF;
  IF 'RESTRICTION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (func\restriction_function.operand));
  END_IF;
  IF 'REPACKAGING_FUNCTION' IN typenames THEN
    tspace := func\repackaging_function.operand.range;
    IF func\repackaging_function.output_repack = ro_wrap_as_tuple THEN
      tspace := one_tuples_of (tspace);
    END_IF;
    IF func\repackaging_function.output_repack = ro_unwrap_tuple THEN
      tspace := factor1 (tspace);
    END_IF;
    IF func\repackaging_function.selected_output > 0 THEN
      tspace := one_tuples_of (factor_space (tspace,
        func\repackaging_function.selected_output));
    END_IF;
    RETURN (tspace);
  END_IF;
  IF 'REINDEXED_ARRAY_FUNCTION' IN typenames THEN
    RETURN (func\unary_generic_expression.operand\maths_function.range);
  END_IF;
  IF 'SERIES_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\series_composed_function.operands[SIZEOF
      (func\series_composed_function.operands)].range);
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (func\parallel_composed_function.final_function.range);
  END_IF;
  IF 'EXPLICIT_TABLE_FUNCTION' IN typenames THEN
    IF 'LISTED_REAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF 'LISTED_INTEGER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_integers));
    END_IF;
    IF 'LISTED_LOGICAL_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_logicals));
    END_IF;
    IF 'LISTED_STRING_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_strings));
    END_IF;
    IF 'LISTED_COMPLEX_NUMBER_DATA' IN typenames THEN
      RETURN (one_tuples_of (the_complex_numbers));
    END_IF;
    IF 'LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\listed_data.value_range));
    END_IF;
    IF 'EXTERNALLY_LISTED_DATA' IN typenames THEN
      RETURN (one_tuples_of (func\externally_listed_data.value_range));
    END_IF;
    IF 'LINEARIZED_TABLE_FUNCTION' IN typenames THEN
      RETURN (func\linearized_table_function.source.range);
    END_IF;
    IF 'BASIC_SPARSE_MATRIX' IN typenames THEN
      RETURN (func\basic_sparse_matrix.val.range);
    END_IF;
    -- Unreachable, as no other subtypes of explicit_table_function are permissible
    -- without first modifying this function to account for them.
    RETURN (?);
  END_IF;
  IF 'HOMOGENEOUS_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\homogeneous_linear_function.mat.range),
      func\homogeneous_linear_function.mat\explicit_table_function.shape
      [3 - func\homogeneous_linear_function.sum_index])));
  END_IF;
  IF 'GENERAL_LINEAR_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space
      (factor1 (func\general_linear_function.mat.range),
      func\general_linear_function.mat\explicit_table_function.shape
      [3 - func\general_linear_function.sum_index])));
  END_IF;
  IF 'B_SPLINE_BASIS' IN typenames THEN
    RETURN (one_tuples_of (make_uniform_product_space (the_reals,
      func\b_spline_basis.num_basis)));
  END_IF;
  IF 'B_SPLINE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\b_spline_function.coef.domain);
    m := SIZEOF (func\b_spline_function.basis);
    n := space_dimension (tspace);
    IF m = n THEN
      RETURN (one_tuples_of (the_reals));
    END_IF;
    IF m = n - 1 THEN
      RETURN (one_tuples_of (make_uniform_product_space (the_reals,
        factor_space (tspace, n)\finite_integer_interval.size)));
    END_IF;
    tspace := extract_factors (tspace, m+1, n);
    RETURN (one_tuples_of (make_function_space (sc_equal, tspace, sc_subspace,
      number_superspace_of (func\b_spline_function.coef.range))));
  END_IF;
  IF 'RATIONALIZE_FUNCTION' IN typenames THEN
    tspace := factor1 (func\rationalize_function.fun.range);
    n := space_dimension (tspace);
    RETURN (one_tuples_of (make_uniform_product_space (number_superspace_of (
      factor1 (tspace)), n-1)));
  END_IF;
  IF 'PARTIAL_DERIVATIVE_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\partial_derivative_function.derivand.range));
  END_IF;
  IF 'DEFINITE_INTEGRAL_FUNCTION' IN typenames THEN
    RETURN (drop_numeric_constraints (
      func\definite_integral_function.integrand.range));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN typenames THEN
    RETURN (one_tuples_of(values_space_of(func\abstracted_expression_function.expr)));
  END_IF;
  IF 'EXPRESSION_DENOTED_FUNCTION' IN typenames THEN
    RETURN (values_space_of (func\expression_denoted_function.expr)\function_space.
      range_argument);
  END_IF;
  IF 'IMPORTED_POINT_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_point_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_CURVE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_curve_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_SURFACE_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_surface_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'IMPORTED_VOLUME_FUNCTION' IN typenames THEN
      temp := dimension_of (func\imported_volume_function.geometry);
    RETURN (one_tuples_of (make_uniform_product_space (the_reals, temp)));
  END_IF;
  IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN
    RETURN (func\application_defined_function.explicit_range);
  END_IF;
  -- Unreachable, as no other subtypes of maths_function are permissible without
  -- first modifying this function to account for them.
  RETURN (?);
END_FUNCTION;  -- derive_function_range
FUNCTION domain_from(ref : maths_space_or_function) : tuple_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(ref);
    func      : maths_function;
  END_LOCAL;
  IF NOT EXISTS (ref) THEN  RETURN (?);  END_IF;
  IF 'TUPLE_SPACE' IN typenames THEN  RETURN (ref);                  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN  RETURN (one_tuples_of (ref));  END_IF;
  func := ref;
  IF 'CONSTANT_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\constant_function.source_of_domain));
  END_IF;
  IF 'SELECTOR_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\selector_function.source_of_domain));
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN
    RETURN (domain_from (func\parallel_composed_function.source_of_domain));
  END_IF;
  RETURN (func.domain);
END_FUNCTION;  -- domain_from
FUNCTION dot_count(str : STRING) : INTEGER;
  LOCAL
    n : INTEGER := 0;
  END_LOCAL;
  REPEAT i := 1 TO LENGTH (str);
    IF str[i] = '.' THEN  n := n + 1;  END_IF;
  END_REPEAT;
  RETURN (n);
END_FUNCTION;  -- dot_count
FUNCTION dotted_identifiers_syntax(str : STRING) : BOOLEAN;
  LOCAL
    k : positive_integer;
    m : positive_integer;
  END_LOCAL;
  IF NOT EXISTS (str) THEN  RETURN (FALSE);  END_IF;
  k := parse_express_identifier (str, 1);
  IF k = 1 THEN  RETURN (FALSE);  END_IF;
  REPEAT WHILE k <= LENGTH (str);
    IF (str[k] <> '.') OR (k = LENGTH (str)) THEN  RETURN (FALSE);  END_IF;
    m := parse_express_identifier (str, k+1);
    IF m = k + 1 THEN  RETURN (FALSE);  END_IF;
    k := m;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- dotted_identifiers_syntax
FUNCTION drop_numeric_constraints(spc : maths_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(spc);
    tspc : listed_product_space;
    factors : LIST OF maths_space := [];
    xspc : extended_tuple_space;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN typenames THEN
    RETURN (make_uniform_product_space (drop_numeric_constraints (
      spc\uniform_product_space.base), spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN typenames THEN
    tspc := spc;
    REPEAT i := 1 TO SIZEOF (tspc.factors);
      INSERT (factors, drop_numeric_constraints (tspc.factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space (factors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN typenames THEN
    xspc := spc;
    RETURN (make_extended_tuple_space (drop_numeric_constraints (xspc.base),
      drop_numeric_constraints (xspc.extender)));
  END_IF;
  IF subspace_of_es (spc, es_numbers) THEN
    RETURN (number_superspace_of (spc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- drop_numeric_constraints
FUNCTION enclose_cregion_in_pregion(crgn   : cartesian_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Determine whether a real is strictly within a real interval
  FUNCTION strictly_in(z    : REAL;
                       zitv : real_interval) : LOGICAL;
    RETURN ((NOT min_exists(zitv) OR (z > real_min(zitv))) AND
      (NOT max_exists(zitv) OR (z < real_max(zitv))));
  END_FUNCTION;
  -- Include direction in minmax collection
  PROCEDURE angle_minmax(    ab, a            : REAL;
                             a_in             : BOOLEAN;
                         VAR amin, amax       : REAL;
                         VAR amin_in, amax_in : BOOLEAN);
    a := angle(a - ab);
    IF amin = a THEN  amin_in := amin_in OR a_in;  END_IF;
    IF amin > a THEN  amin := a;  amin_in := a_in;  END_IF;
    IF amax = a THEN  amax_in := amax_in OR a_in;  END_IF;
    IF amax < a THEN  amax := a;  amax_in := a_in;  END_IF;
  END_PROCEDURE;
  -- Include distance in max collection
  PROCEDURE range_max(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmax    : REAL;
                      VAR rmax_in : BOOLEAN);
    IF rmax = r THEN  rmax_in := rmax_in OR incl;   END_IF;
    IF rmax < r THEN  rmax := r;  rmax_in := incl;  END_IF;
  END_PROCEDURE;
  -- Include distance in min collection
  PROCEDURE range_min(    r       : REAL;
                          incl    : BOOLEAN;
                      VAR rmin    : REAL;
                      VAR rmin_in : BOOLEAN);
    IF rmin = r THEN  rmin_in := rmin_in OR incl;  END_IF;
    IF (rmin < 0.0) OR (rmin > r) THEN  rmin := r;  rmin_in := incl;  END_IF;
  END_PROCEDURE;
  LOCAL
    xitv, yitv : real_interval;
    is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN;
    xmin, xmax, ymin, ymax, xc, yc : REAL := 0.0;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    rmin, rmax : REAL := -1.0;
    amin : REAL := 4.0;
    amax : REAL := -4.0;
    rmax_exists, outside : BOOLEAN := TRUE;
    rmin_in, rmax_in, amin_in, amax_in : BOOLEAN := FALSE;
    ab, a, r : REAL := 0.0;
    incl : BOOLEAN;
    ritv : real_interval;
    aitv : finite_real_interval;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  -- Extract elementary input information
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  is_xmin := min_exists(xitv);
  is_xmax := max_exists(xitv);
  is_ymin := min_exists(yitv);
  is_ymax := max_exists(yitv);
  IF is_xmin THEN  xmin := real_min(xitv);  xmin_in := min_included(xitv);  END_IF;
  IF is_xmax THEN  xmax := real_max(xitv);  xmax_in := max_included(xitv);  END_IF;
  IF is_ymin THEN  ymin := real_min(yitv);  ymin_in := min_included(yitv);  END_IF;
  IF is_ymax THEN  ymax := real_max(yitv);  ymax_in := max_included(yitv);  END_IF;
  rmax_exists := is_xmin AND is_xmax AND is_ymin AND is_ymax;
  -- Identify base direction with respect to which all relevant directions lie
  -- within +/- 0.5*PI, or that the centre lies properly inside crgn.
  IF       is_xmin AND (xc <= xmin)  THEN  ab := 0.0;
  ELSE IF  is_ymin AND (yc <= ymin)  THEN  ab := 0.5*PI;
  ELSE IF  is_ymax AND (yc >= ymax)  THEN  ab := -0.5*PI;
  ELSE IF  is_xmax AND (xc >= xmax)  THEN  ab := PI;
  ELSE                                     outside := FALSE;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF NOT outside AND NOT rmax_exists THEN
    RETURN (?);  -- No enclosing polar region exists (requires whole plane)
  END_IF;
  -- Identify any closest point on a side but not a corner.
  IF       is_xmin AND (xc <= xmin) AND strictly_in(yc,yitv) THEN
    rmin := xmin - xc;  rmin_in := xmin_in;
  ELSE IF  is_ymin AND (yc <= ymin) AND strictly_in(xc,xitv) THEN
    rmin := ymin - yc;  rmin_in := ymin_in;
  ELSE IF  is_ymax AND (yc >= ymax) AND strictly_in(xc,xitv) THEN
    rmin := yc - ymax;  rmin_in := ymax_in;
  ELSE IF  is_xmax AND (xc >= xmax) AND strictly_in(yc,yitv) THEN
    rmin := xc - xmax;  rmin_in := xmax_in;
  END_IF;  END_IF;  END_IF;  END_IF;
  IF is_xmin THEN
    IF is_ymin THEN  -- Consider lower left corner
      r := SQRT((xmin-xc)**2 + (ymin-yc)**2);
      incl := xmin_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmin_in AND ymin_in;
          amin := angle(0.0-ab);      amin_in := ymin_in;
          amax := angle(0.5*PI-ab);   amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF xc <= xmin THEN  -- Consider points near (xmin, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymax AND (xc <= xmin) THEN  -- Consider points near (xmin, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmin) AND xmin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymin THEN
    IF is_xmax THEN  -- Consider lower right corner
      r := SQRT((xmax-xc)**2 + (ymin-yc)**2);
      incl := xmax_in AND ymin_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymin-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymin THEN  incl := ymin_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmax_in AND ymin_in;
          amin := angle(0.5*PI-ab);   amin_in := ymin_in;
          amax := angle(PI-ab);       amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF yc <= ymin THEN  -- Consider points near (+infinity, ymin)
      angle_minmax(ab,0.0,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmin AND (yc <= ymin) THEN  -- Consider points near (-infinity, ymin)
      angle_minmax(ab,PI,(yc=ymin) AND ymin_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_xmax THEN
    IF is_ymax THEN  -- Consider upper right corner
      r := SQRT((xmax-xc)**2 + (ymax-yc)**2);
      incl := xmax_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmax-xc) - ab);
          IF xc = xmax THEN  incl := xmax_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower left corner
          rmin := 0.0;                rmin_in := xmax_in AND ymax_in;
          amin := angle(-PI-ab);      amin_in := ymax_in;
          amax := angle(-0.5*PI-ab);  amax_in := xmax_in;
        END_IF;
      END_IF;
    ELSE IF xc >= xmax THEN  -- Consider points near (xmax, +infinity)
      angle_minmax(ab,0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_ymin AND (xc >= xmax) THEN  -- Consider points near (xmax, -infinity)
      angle_minmax(ab,-0.5*PI,(xc=xmax) AND xmax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF is_ymax THEN
    IF is_xmin THEN  -- Consider upper left corner
      r := SQRT((xmin-xc)**2 + (ymax-yc)**2);
      incl := xmin_in AND ymax_in;
      IF rmax_exists THEN  range_max(r,incl,rmax,rmax_in);  END_IF;
      IF outside THEN
        IF r > 0.0 THEN
          range_min(r,incl,rmin,rmin_in);
          a := angle(atan2(ymax-yc,xmin-xc) - ab);
          IF xc = xmin THEN  incl := xmin_in;  END_IF;
          IF yc = ymax THEN  incl := ymax_in;  END_IF;
          angle_minmax(ab,a,incl,amin,amax,amin_in,amax_in);
        ELSE  -- Centre at lower right corner
          rmin := 0.0;                rmin_in := xmin_in AND ymax_in;
          amin := angle(0.5*PI-ab);   amin_in := ymax_in;
          amax := angle(PI-ab);       amax_in := xmin_in;
        END_IF;
      END_IF;
    ELSE IF yc >= ymax THEN  -- Consider points near (-infinity, ymax)
      angle_minmax(ab,PI,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;  END_IF;
    IF NOT is_xmax AND (yc >= ymax) THEN  -- Consider points near (+infinity, ymax)
      angle_minmax(ab,0.0,(yc=ymax) AND ymax_in,amin,amax,amin_in,amax_in);
    END_IF;
  END_IF;
  IF outside THEN  -- Change direction origin from ab back to zero
    amin := angle(amin+ab);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax+ab);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  ELSE
    amin := -PI;  amin_in := FALSE;
    amax := PI;   amax_in := FALSE;
  END_IF;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  minclo := open;
  IF rmin_in THEN  minclo := closed;  END_IF;
  IF rmax_exists THEN
    maxclo := open;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_cregion_in_pregion
FUNCTION enclose_pregion_in_cregion(prgn : polar_complex_number_region)
                                   : cartesian_complex_number_region;
  PROCEDURE nearest_good_direction(acart    : REAL;
                                   aitv     : finite_real_interval;
                                   VAR a    : REAL;
                                   VAR a_in : BOOLEAN);
    a := acart;                    a_in := TRUE;
    IF      a < aitv.min THEN
      -- a+2.0*PI > aitv.min automatically!
      IF a+2.0*PI < aitv.max THEN                               RETURN;  END_IF;
      IF a+2.0*PI = aitv.max THEN  a_in := max_included(aitv);  RETURN;  END_IF;
    ELSE IF a = aitv.min THEN      a_in := min_included(aitv);  RETURN;
    ELSE IF a < aitv.max THEN                                   RETURN;
    ELSE IF a = aitv.max THEN      a_in := max_included(aitv);  RETURN;
    END_IF;  END_IF;  END_IF;  END_IF;
    IF COS(acart - aitv.max) >= COS(acart - aitv.min) THEN
      a := aitv.max;               a_in := max_included(aitv);
    ELSE
      a := aitv.min;               a_in := min_included(aitv);
    END_IF;
  END_PROCEDURE;
  LOCAL
    xc, yc, xmin, xmax, ymin, ymax : REAL := 0.0;
    ritv, xitv, yitv : real_interval;
    aitv : finite_real_interval;
    xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN;
    xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN := FALSE;
    a, r : REAL := 0.0;
    a_in : BOOLEAN := FALSE;
    min_clo, max_clo : open_closed := open;
  END_LOCAL;
  IF NOT EXISTS (prgn) THEN  RETURN (?);  END_IF;
  -- Extract elementary input data
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  ritv := prgn.distance_constraint;
  aitv := prgn.direction_constraint;
  -- Determine xmin data
  nearest_good_direction(PI,aitv,a,a_in);
  IF COS(a) >= 0.0 THEN
    xmin_exists := TRUE;
    xmin := xc + real_min(ritv)*COS(a);
    xmin_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmin_exists := TRUE;
      xmin := xc + real_max(ritv)*COS(a);
      xmin_in := a_in AND max_included(ritv);
    ELSE
      xmin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine xmax data
  nearest_good_direction(0.0,aitv,a,a_in);
  IF COS(a) <= 0.0 THEN
    xmax_exists := TRUE;
    xmax := xc + real_min(ritv)*COS(a);
    xmax_in := a_in AND (min_included(ritv) OR (COS(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      xmax_exists := TRUE;
      xmax := xc + real_max(ritv)*COS(a);
      xmax_in := a_in AND max_included(ritv);
    ELSE
      xmax_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymin data
  nearest_good_direction(-0.5*PI,aitv,a,a_in);
  IF SIN(a) >= 0.0 THEN
    ymin_exists := TRUE;
    ymin := yc + real_min(ritv)*SIN(a);
    ymin_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymin_exists := TRUE;
      ymin := yc + real_max(ritv)*SIN(a);
      ymin_in := a_in AND max_included(ritv);
    ELSE
      ymin_exists := FALSE;
    END_IF;
  END_IF;
  -- Determine ymax data
  nearest_good_direction(0.5*PI,aitv,a,a_in);
  IF SIN(a) <= 0.0 THEN
    ymax_exists := TRUE;
    ymax := yc + real_min(ritv)*SIN(a);
    ymax_in := a_in AND (min_included(ritv) OR (SIN(a) = 0.0));
  ELSE
    IF max_exists(ritv) THEN
      ymax_exists := TRUE;
      ymax := yc + real_max(ritv)*SIN(a);
      ymax_in := a_in AND max_included(ritv);
    ELSE
      ymax_exists := FALSE;
    END_IF;
  END_IF;
  -- Construct result
  IF NOT (xmin_exists OR xmax_exists OR ymin_exists OR ymax_exists) THEN
    RETURN (?);  -- No finite boundaries exist
  END_IF;
  -- Construct real_constraint
  IF xmin_exists THEN
    IF xmin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_finite_real_interval(xmin,min_clo,xmax,max_clo);
    ELSE
      xitv := make_real_interval_from_min(xmin,min_clo);
    END_IF;
  ELSE
    IF xmax_exists THEN
      IF xmax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      xitv := make_real_interval_to_max(xmax,max_clo);
    ELSE
      xitv := the_reals;
    END_IF;
  END_IF;
  -- Construct imag_constraint
  IF ymin_exists THEN
    IF ymin_in THEN  min_clo := closed;  ELSE  min_clo := open;  END_IF;
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_finite_real_interval(ymin,min_clo,ymax,max_clo);
    ELSE
      yitv := make_real_interval_from_min(ymin,min_clo);
    END_IF;
  ELSE
    IF ymax_exists THEN
      IF ymax_in THEN  max_clo := closed;  ELSE  max_clo := open;  END_IF;
      yitv := make_real_interval_to_max(ymax,max_clo);
    ELSE
      yitv := the_reals;
    END_IF;
  END_IF;
  -- Construct cartesian region
  RETURN (make_cartesian_complex_number_region(xitv,yitv));
END_FUNCTION;  -- enclose_pregion_in_cregion
FUNCTION enclose_pregion_in_pregion(prgn   : polar_complex_number_region;
                                    centre : complex_number_literal)
                                   : polar_complex_number_region;
  -- Find equivalent direction in range -PI < a <= PI.
  FUNCTION angle(a : REAL) : REAL;
    REPEAT WHILE a > PI;    a := a - 2.0*PI;  END_REPEAT;
    REPEAT WHILE a <= -PI;  a := a + 2.0*PI;  END_REPEAT;
    RETURN (a);
  END_FUNCTION;
  -- Find proper limits for direction interval
  PROCEDURE angle_range(VAR amin, amax : REAL);
    amin := angle(amin);
    IF amin = PI THEN  amin := -PI;  END_IF;
    amax := angle(amax);
    IF amax <= amin THEN  amax := amax + 2.0*PI;  END_IF;
  END_PROCEDURE;
  -- Determine whether a direction is strictly within a direction interval
  FUNCTION strictly_in(a    : REAL;
                       aitv : finite_real_interval) : LOGICAL;
    a := angle(a);
    RETURN ({aitv.min < a < aitv.max} OR {aitv.min < a+2.0*PI < aitv.max});
  END_FUNCTION;
  -- Find min and max and related inclusion booleans among four candidates,
  -- using a base direction chosen to ensure the algebraic comparisons are valid.
  PROCEDURE find_aminmax(    ab,a0,a1,a2,a3  : REAL;
                             in0,in1,in2,in3 : BOOLEAN;
                         VAR amin,amax       : REAL;
                         VAR amin_in,amax_in : BOOLEAN);
    LOCAL
      a : REAL;
    END_LOCAL;
    amin := angle(a0-ab);                  amin_in := in0;
    amax := amin;                          amax_in := in0;
    a := angle(a1-ab);
    IF a = amin THEN                       amin_in := amin_in OR in1;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in1;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in1;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in1;             END_IF;
    a := angle(a2-ab);
    IF a = amin THEN                       amin_in := amin_in OR in2;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in2;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in2;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in2;             END_IF;
    a := angle(a3-ab);
    IF a = amin THEN                       amin_in := amin_in OR in3;  END_IF;
    IF a < amin THEN  amin := a;           amin_in := in3;             END_IF;
    IF a = amax THEN                       amax_in := amax_in OR in3;  END_IF;
    IF a > amax THEN  amax := a;           amax_in := in3;             END_IF;
    amin := amin+ab;
    amax := amax+ab;
    angle_range(amin,amax);
  END_PROCEDURE;

  LOCAL
    ritp, ritv : real_interval;
    aitp, aitv : finite_real_interval;
    xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL := 0.0;
    rmax_in, rmin_in, amin_in, amax_in : BOOLEAN := FALSE;
    rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
    in0, in1, in2, in3, inn : BOOLEAN := FALSE;
    minclo, maxclo : open_closed := open;
  END_LOCAL;
  -- Extract elementary input information
  IF NOT EXISTS (prgn) OR NOT EXISTS (centre) THEN  RETURN (?);  END_IF;
  xp := prgn.centre.real_part;
  yp := prgn.centre.imag_part;
  ritp := prgn.distance_constraint;
  aitp := prgn.direction_constraint;
  xc := centre.real_part;
  yc := centre.imag_part;
  IF (xc = xp) AND (yc = yp) THEN  RETURN (prgn);  END_IF;
  rc := SQRT((xp-xc)**2 + (yp-yc)**2);
  acp := atan2(yp-yc,xp-xc);
  apc := atan2(yc-yp,xc-xp);
  rmnp := real_min(ritp);
  -- Analyse cases by existence of max distance and direction limits
  IF max_exists(ritp) THEN
    rmxp := real_max(ritp);
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- annulus or disk, with or without slot or puncture
      inn := NOT max_included(aitp);  -- slot exists;
      a := angle(aitp.min);  -- slot direction
      rmax := rc+rmxp;                    rmax_in := max_included(ritp);
      IF inn AND (acp = a) THEN  rmax_in := FALSE;  END_IF;
      IF rc > rmxp THEN
        a0 := ASIN(rmxp/rc);
        amin := angle(acp-a0);            amin_in := max_included(ritp);
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+a0);            amax_in := amin_in;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := rc-rmxp;                  rmin_in := amin_in;
        IF inn THEN
          -- slotted case
          IF apc = a THEN  rmin_in := FALSE;  END_IF;
          IF angle(amin+0.5*PI) = a THEN  amin_in := FALSE;  END_IF;
          IF angle(amax-0.5*PI) = a THEN  amax_in := FALSE;  END_IF;
        END_IF;
      ELSE IF rc = rmxp THEN
        amin := angle(acp-0.5*PI);        amin_in := FALSE;
        IF amin = PI THEN  amin := -PI;  END_IF;
        amax := angle(acp+0.5*PI);        amax_in := FALSE;
        IF amax < amin THEN  amax := amax + 2.0*PI;  END_IF;
        rmin := 0.0;                      rmin_in := max_included(ritp);
        IF inn AND (apc = a) THEN  rmin_in := FALSE;  END_IF;
      ELSE IF rc > rmnp THEN
        IF inn AND (apc = a) THEN  -- in the slot
          rmin := 0.0;                    rmin_in := FALSE;
          amin := aitp.min;               amin_in := FALSE;
          amax := aitp.max;               amax_in := FALSE;
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        END_IF;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF inn THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;  END_IF;  END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc
      x := xp + rmxp*cos(aitp.min) - xc;
      y := yp + rmxp*sin(aitp.min) - yc;
      r0 := SQRT(x**2 + y**2);
      in0 := max_included(ritp) AND min_included(aitp);
      IF r0 <> 0.0 THEN  a0 := atan2(y,x);  END_IF;
      x := xp + rmxp*cos(aitp.max) - xc;
      y := yp + rmxp*sin(aitp.max) - yc;
      r1 := SQRT(x**2 + y**2);
      in1 := max_included(ritp) AND max_included(aitp);
      IF r1 <> 0.0 THEN  a1 := atan2(y,x);  END_IF;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      IF r1 = 0.0 THEN  a1 := a2;  in1 := in2;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF r0 = 0.0 THEN  a0 := a3;  in0 := in3;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmax
      IF strictly_in(acp,aitp) THEN
        rmax := rc+rmxp;                  rmax_in := max_included(ritp);
      ELSE
        rmax := r0;                       rmax_in := in0;
        IF rmax = r1 THEN                 rmax_in := rmax_in OR in1;  END_IF;
        IF rmax < r1 THEN  rmax := r1;    rmax_in := in1;             END_IF;
        IF rmax = r2 THEN                 rmax_in := rmax_in OR in2;  END_IF;
        IF rmax < r2 THEN  rmax := r2;    rmax_in := in2;             END_IF;
        IF rmax = r3 THEN                 rmax_in := rmax_in OR in3;  END_IF;
        IF rmax < r3 THEN  rmax := r3;    rmax_in := in3;             END_IF;
      END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        IF rc >= rmxp THEN
          rmin := rc-rmxp;                rmin_in := max_included(ritp);
        ELSE IF rc <= rmnp THEN
          rmin := rmnp-rc;                rmin_in := min_included(ritp);
        ELSE
          rmin := 0.0;                    rmin_in := TRUE;
        END_IF;  END_IF;
      ELSE
        rmin := r0;                       rmin_in := in0;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- use nearest point on line segment
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF {rmnp < r < rmxp} THEN  -- try nearest point on line segment
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r1 = rmin THEN                 rmin_in := rmin_in OR in1;  END_IF;
        IF r1 < rmin THEN  rmin := r1;    rmin_in := in1;             END_IF;
        IF r2 = rmin THEN                 rmin_in := rmin_in OR in2;  END_IF;
        IF r2 < rmin THEN  rmin := r2;    rmin_in := in2;             END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax, initially with respect to base direction ab.
      IF rc >= rmxp THEN  -- outside outer circle
        ab := acp;
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
        a := ACOS(rmxp/rc);
        IF strictly_in(apc-a,aitp) THEN
          amin := ab-ASIN(rmxp/rc);       amin_in := max_included(ritp);
        END_IF;
        IF strictly_in(apc+a,aitp) THEN
          amax := ab+ASIN(rmxp/rc);       amax_in := max_included(ritp);
        END_IF;
        angle_range(amin,amax);
      ELSE IF rc > rmnp THEN
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;  END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    IF rmax_in THEN  maxclo := closed;  END_IF;
    ritv := make_finite_real_interval(rmin,minclo,rmax,maxclo);
  ELSE  -- Not max_exists(ritp)
    IF (rc > rmnp) AND strictly_in(apc,aitp) THEN
      RETURN (?);  -- No pregion exists.  (Would require whole plane.)
    END_IF;
    IF aitp.max - aitp.min = 2.0*PI THEN
      -- complement of disk, with or without slot
      a := angle(aitp.min);  -- slot direction
      IF rc > rmnp THEN  -- already excluded if not aligned with slot
        IF max_included(aitp) THEN
          RETURN (?);  -- No pregion exists.  (Would require whole plane.)
        END_IF;
        rmin := 0.0;                      rmin_in := FALSE;
        amin := aitp.min;                 amin_in := FALSE;
        amax := aitp.max;                 amax_in := FALSE;
      ELSE
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
        amin := -PI;                      amin_in := FALSE;
        amax := PI;                       amax_in := TRUE;
        IF NOT max_included(aitp) THEN  -- Special cases when aligned with slot
          IF apc = a THEN
                                          rmin_in := FALSE;
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          ELSE IF acp = a THEN
            amin := aitp.min;             amin_in := FALSE;
            amax := aitp.max;             amax_in := FALSE;
          END_IF;  END_IF;
        END_IF;
      END_IF;
    ELSE  -- direction range < 2*PI
      -- Compute data for corners with respect to xc,yc (two at infinity)
      a0 := angle(aitp.min);
      in0 := FALSE;
      a1 := angle(aitp.max);
      in1 := FALSE;
      x := xp + rmnp*cos(aitp.max) - xc;
      y := yp + rmnp*sin(aitp.max) - yc;
      r2 := SQRT(x**2 + y**2);
      in2 := min_included(ritp) AND max_included(aitp);
      IF r2 <> 0.0 THEN  a2 := atan2(y,x);  ELSE  a2 := a1;  in2 := in1;  END_IF;
      x := xp + rmnp*cos(aitp.min) - xc;
      y := yp + rmnp*sin(aitp.min) - yc;
      r3 := SQRT(x**2 + y**2);
      in3 := min_included(ritp) AND min_included(aitp);
      IF r3 <> 0.0 THEN  a3 := atan2(y,x);  ELSE  a3 := a0;  in3 := in0;  END_IF;
      IF rmnp = 0.0 THEN  in2 := min_included(ritp);  in3 := in2;  END_IF;
      IF (apc = angle(aitp.min)) OR (acp = angle(aitp.min)) THEN
        in0 := min_included(aitp);
        in3 := in0;
      ELSE IF (apc = angle(aitp.max)) OR (acp = angle(aitp.max)) THEN
        in1 := max_included(aitp);
        in2 := in1;
      END_IF;  END_IF;
      -- Find rmin
      IF strictly_in(apc,aitp) THEN
        rmin := rmnp-rc;                  rmin_in := min_included(ritp);
      ELSE
        rmin := r2;                       rmin_in := in2;
        a := apc-aitp.min;
        r := rc*COS(a);
        IF rmnp < r THEN  -- use nearest point on aitp.min ray
          rmin := rc*SIN(ABS(a));         rmin_in := min_included(aitp);
        END_IF;
        a := apc-aitp.max;
        r := rc*COS(a);
        IF rmnp < r THEN  -- try nearest point on aitp.max ray
          r := rc*SIN(ABS(a));            inn := max_included(aitp);
          IF r = rmin THEN                rmin_in := rmin_in OR inn;  END_IF;
          IF r < rmin THEN  rmin := r;    rmin_in := inn;             END_IF;
        END_IF;
        IF r3 = rmin THEN                 rmin_in := rmin_in OR in3;  END_IF;
        IF r3 < rmin THEN  rmin := r3;    rmin_in := in3;             END_IF;
      END_IF;
      -- Find amin and amax
      ab := angle(0.5*(aitp.min+aitp.max));  -- reference direction
      IF rc > rmnp THEN
        find_aminmax(ab,a0,a1,a2,a3,in0,in1,in2,in3,amin,amax,amin_in,amax_in);
      ELSE
        -- Using base direction midway in prgn, compute all directions using
        -- values which ensure a3 < a2 and a0 < a1 algebraically.
        a0 := angle(a0-ab);
        a1 := angle(a1-ab);
        a2 := angle(a2-ab);
        a3 := angle(a3-ab);
        IF a3 > a2 THEN  a2 := a2 + 2.0*PI;  END_IF;
        IF a0 > a1 THEN  a0 := a0 + 2.0*PI;  END_IF;
        IF a3 < a0 THEN  amin := a3;      amin_in := in3;
        ELSE             amin := a0;      amin_in := in0;  END_IF;
        IF a2 > a1 THEN  amax := a2;      amax_in := in2;
        ELSE             amax := a1;      amax_in := in1;  END_IF;
        IF (amax - amin > 2.0*PI) OR
          ((amax - amin = 2.0*PI) AND (amin_in OR amax_in)) THEN
          -- Cannot see out
          amin := -PI;                    amin_in := FALSE;
          amax := PI;                     amax_in := TRUE;
          IF (rmin = 0.0) AND rmin_in THEN
            RETURN (?);  -- No pregion exists.  (Would require whole plane.)
          END_IF;
        ELSE
          amin := amin + ab;
          amax := amax + ab;
          angle_range(amin,amax);
        END_IF;
      END_IF;
    END_IF;
    IF rmin_in THEN  minclo := closed;  END_IF;
    ritv := make_real_interval_from_min(rmin,minclo);
  END_IF;
  minclo := open;  maxclo := open;
  IF amin_in THEN  minclo := closed;  END_IF;
  IF amax_in THEN  maxclo := closed;  END_IF;
  aitv := make_finite_real_interval(amin,minclo,amax,maxclo);
  -- Construct polar region
  RETURN (make_polar_complex_number_region(centre,ritv,aitv));
END_FUNCTION;  -- enclose_pregion_in_pregion
FUNCTION equal_cregion_pregion(crgn : cartesian_complex_number_region;
                               prgn : polar_complex_number_region) : LOGICAL;
  LOCAL
    arng, amin, xc, yc : REAL;
    aitv, xitv, yitv : real_interval;
    c_in : BOOLEAN;
  END_LOCAL;
  IF NOT EXISTS (crgn) OR NOT EXISTS (prgn) THEN  RETURN (FALSE);  END_IF;
  IF max_exists(prgn.distance_constraint) THEN  RETURN (FALSE);  END_IF;
  IF real_min(prgn.distance_constraint) <> 0.0 THEN  RETURN (FALSE);  END_IF;
  c_in := min_included(prgn.distance_constraint);
  aitv := prgn.direction_constraint;
  amin := aitv.min;
  arng := aitv.max - amin;
  xc := prgn.centre.real_part;
  yc := prgn.centre.imag_part;
  xitv := crgn.real_constraint;
  yitv := crgn.imag_constraint;
  IF arng = 0.5*PI THEN
    IF amin = 0.0 THEN  -- quadrant to upper right
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND min_exists(yitv) AND (real_min(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- quadrant to upper left
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_max(xitv) = xc) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT min_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT min_included(yitv))));
    END_IF;
    IF amin = -PI THEN  -- quadrant to lower left
      RETURN (max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND max_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv) AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- quadrant to lower right
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND max_included(aitv)
              AND min_included(xitv) AND NOT max_included(yitv))
          OR (NOT c_in AND min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv) AND NOT max_included(yitv))));
    END_IF;
  END_IF;
  IF arng = PI THEN
    IF amin = 0.0 THEN  -- upper half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND min_exists(yitv) AND (real_min(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(yitv))));
    END_IF;
    IF amin = 0.5*PI THEN  -- left half space
      RETURN (max_exists(xitv) AND NOT max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(xitv))));
    END_IF;
    IF amin = -PI THEN  -- lower half space
      RETURN (NOT max_exists(xitv) AND max_exists(yitv) AND NOT min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_max(yitv) = yc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND max_included(yitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT max_included(yitv))));
    END_IF;
    IF amin = -0.5*PI THEN  -- right half space
      RETURN (NOT max_exists(xitv) AND NOT max_exists(yitv) AND min_exists(xitv)
        AND NOT min_exists(yitv) AND (real_min(xitv) = xc)
        AND ((c_in AND min_included(aitv) AND max_included(aitv)
              AND min_included(xitv))
          OR (NOT c_in AND NOT min_included(aitv) AND NOT max_included(aitv)
              AND NOT min_included(xitv))));
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_cregion_pregion
FUNCTION equal_maths_functions(fun1, fun2 : maths_function) : LOGICAL;
  LOCAL
    cum : LOGICAL;
  END_LOCAL;
  IF fun1 = fun2 THEN  RETURN (TRUE);   END_IF;
  cum := equal_maths_spaces(fun1.domain,fun2.domain);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  cum := cum AND equal_maths_spaces(fun1.range,fun2.range);
  IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
  -- A lot of further analysis is possible, but not required.
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_functions
FUNCTION equal_maths_spaces(spc1, spc2 : maths_space) : LOGICAL;
  LOCAL
    spc1types : SET OF STRING := stripped_typeof(spc1);
    spc2types : SET OF STRING := stripped_typeof(spc2);
    set1, set2 : SET OF maths_value;
    cum : LOGICAL := TRUE;
    base : maths_space;
    expnt : INTEGER;
    factors : LIST OF maths_space;
    factors2 : LIST OF maths_space;
    fs1, fs2 : function_space;
    cum2 : LOGICAL;
  END_LOCAL;
  IF spc1 = spc2 THEN  RETURN (TRUE);  END_IF;
  -- Consider cases where it is not yet certain that spc1 <> spc2.
  IF 'FINITE_SPACE' IN spc1types THEN
    set1 := spc1\finite_space.members;
    IF 'FINITE_SPACE' IN spc2types THEN
      -- Members may have different but equivalent representations and in
      -- different orders.  May also have disguised repeats in same set of members.
      set2 := spc2\finite_space.members;
      REPEAT i := 1 TO SIZEOF (set1);
        cum := cum AND member_of (set1[i], spc2);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      IF cum = TRUE THEN
        REPEAT i := 1 TO SIZEOF (set2);
          cum := cum AND member_of (set2[i], spc1);
          IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
        END_REPEAT;
      END_IF;
      RETURN (cum);
    END_IF;
    IF 'FINITE_INTEGER_INTERVAL' IN spc2types THEN
      set2 := [];
      REPEAT i := spc2\finite_integer_interval.min TO spc2\finite_integer_interval.max;
        set2 := set2 + [i];
      END_REPEAT;
      RETURN (equal_maths_spaces(spc1,make_finite_space(set2)));
    END_IF;
  END_IF;
  IF ('FINITE_INTEGER_INTERVAL' IN spc1types) AND ('FINITE_SPACE' IN spc2types) THEN
    set1 := [];
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      set1 := set1 + [i];
    END_REPEAT;
    RETURN (equal_maths_spaces(make_finite_space(set1),spc2));
  END_IF;
  IF ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('POLAR_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc1,spc2));
  END_IF;
  IF ('POLAR_COMPLEX_NUMBER_REGION' IN spc1types) AND
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN spc2types) THEN
    -- Quadrants and half spaces have two representations
    RETURN (equal_cregion_pregion(spc2,spc1));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN spc1types THEN
    base := spc1\uniform_product_space.base;
    expnt := spc1\uniform_product_space.exponent;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF expnt <> spc2\uniform_product_space.exponent THEN  RETURN (FALSE);  END_IF;
      RETURN (equal_maths_spaces(base,spc2\uniform_product_space.base));
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors := spc2\listed_product_space.factors;
      IF expnt <> SIZEOF (factors) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN spc1types THEN
    factors := spc1\listed_product_space.factors;
    IF 'UNIFORM_PRODUCT_SPACE' IN spc2types THEN
      IF spc2\uniform_product_space.exponent <> SIZEOF (factors) THEN
        RETURN (FALSE);
      END_IF;
      base := spc2\uniform_product_space.base;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(base,factors[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'LISTED_PRODUCT_SPACE' IN spc2types THEN
      factors2 := spc2\listed_product_space.factors;
      IF SIZEOF (factors) <> SIZEOF (factors2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (factors);
        cum := cum AND equal_maths_spaces(factors[i],factors2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
  END_IF;
  IF ('EXTENDED_TUPLE_SPACE' IN spc1types) AND
    ('EXTENDED_TUPLE_SPACE' IN spc2types) THEN
    RETURN (equal_maths_spaces(spc1\extended_tuple_space.extender,
      spc2\extended_tuple_space.extender) AND equal_maths_spaces(
      spc1\extended_tuple_space.base, spc2\extended_tuple_space.base));
  END_IF;
  IF ('FUNCTION_SPACE' IN spc1types) AND
    ('FUNCTION_SPACE' IN spc2types) THEN
    fs1 := spc1;
    fs2 := spc2;
    IF fs1.domain_constraint <> fs2.domain_constraint THEN
      IF (fs1.domain_constraint = sc_equal) OR (fs2.domain_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.domain_constraint <> sc_subspace) OR
        (fs2.domain_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.domain_constraint,fs1.domain_argument) <>
        any_space_satisfies(fs2.domain_constraint,fs2.domain_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.domain_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.domain_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := equal_maths_spaces(fs1.domain_argument,fs2.domain_argument);
    IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
    IF fs1.range_constraint <> fs2.range_constraint THEN
      IF (fs1.range_constraint = sc_equal) OR (fs2.range_constraint = sc_equal) THEN
        RETURN (FALSE);
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) THEN
        fs1 := spc2;
        fs2 := spc1;
      END_IF;
      IF (fs1.range_constraint <> sc_subspace) OR
        (fs2.range_constraint <> sc_member) THEN
        -- Safety check.  Should be unreachable.
        RETURN (UNKNOWN);
      END_IF;
      IF any_space_satisfies(fs1.range_constraint,fs1.range_argument) <>
        any_space_satisfies(fs2.range_constraint,fs2.range_argument) THEN
        RETURN (FALSE);
      END_IF;
      IF NOT ('FINITE_SPACE' IN stripped_typeof(fs2.range_argument)) THEN
        RETURN (FALSE);
      END_IF;
      IF SIZEOF (['FINITE_SPACE','FINITE_INTEGER_INTERVAL'] *
        stripped_typeof(fs1.range_argument)) = 0 THEN
        RETURN (FALSE);
      END_IF;
      -- Remaining cases too complex.
      RETURN (UNKNOWN);
    END_IF;
    cum := cum AND equal_maths_spaces(fs1.range_argument,fs2.range_argument);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- equal_maths_spaces
FUNCTION equal_maths_values(val1, val2 : maths_value) : LOGICAL;
  FUNCTION mem_of_vs(val1, val2 : maths_value) : LOGICAL;
    IF NOT has_values_space(val2) THEN RETURN (UNKNOWN);  END_IF;
    IF NOT member_of(val1,values_space_of(val2)) THEN  RETURN (FALSE);  END_IF;
    RETURN (UNKNOWN);
  END_FUNCTION;  -- mem_of_vs
  LOCAL
    types1, types2 : SET OF STRING;
    list1, list2 : LIST OF maths_value;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF NOT EXISTS (val1) OR NOT EXISTS (val2) THEN  RETURN (FALSE);  END_IF;
  IF val1 = val2 THEN  RETURN (TRUE);  END_IF;
  types1 := stripped_typeof (val1);
  types2 := stripped_typeof (val2);
  IF ('MATHS_ATOM' IN types1) OR ('COMPLEX_NUMBER_LITERAL' IN types1) THEN
    IF 'MATHS_ATOM'             IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'COMPLEX_NUMBER_LITERAL' IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'LIST'                   IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF ('MATHS_ATOM' IN types2) OR ('COMPLEX_NUMBER_LITERAL' IN types2) THEN
    RETURN (equal_maths_values(val2,val1));
  END_IF;
  IF 'LIST' IN types1 THEN
    IF 'LIST' IN types2 THEN
      list1 := val1;
      list2 := val2;
      IF SIZEOF (list1) <> SIZEOF (list2) THEN  RETURN (FALSE);  END_IF;
      REPEAT i := 1 TO SIZEOF (list1);
        cum := cum AND equal_maths_values (list1[i], list2[i]);
        IF cum = FALSE THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    IF 'MATHS_SPACE'            IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'LIST' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_SPACE' IN types1 THEN
    IF 'MATHS_SPACE' IN types2 THEN
      RETURN (equal_maths_spaces(val1,val2));
    END_IF;
    IF 'MATHS_FUNCTION'         IN types2 THEN  RETURN (FALSE);  END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_SPACE' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF 'MATHS_FUNCTION' IN types1 THEN
    IF 'MATHS_FUNCTION' IN types2 THEN
      RETURN (equal_maths_functions(val1,val2));
    END_IF;
    IF 'GENERIC_EXPRESSION' IN types2 THEN  RETURN (mem_of_vs(val1,val2)); END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'MATHS_FUNCTION' IN types2 THEN  RETURN (equal_maths_values(val2,val1));  END_IF;
  IF ('GENERIC_EXPRESSION' IN types1) AND ('GENERIC_EXPRESSION' IN types2) THEN
    IF NOT has_values_space(val1) OR NOT has_values_space(val2) THEN
      RETURN (UNKNOWN);
    END_IF;
    IF NOT compatible_spaces(values_space_of(val1),values_space_of(val2)) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (UNKNOWN);
END_FUNCTION;  -- equal_maths_values
FUNCTION es_subspace_of_es(es1, es2 : elementary_space_enumerators) : BOOLEAN;
  IF NOT EXISTS (es1) OR NOT EXISTS (es2) THEN  RETURN (FALSE);  END_IF;
  IF es1 = es2 THEN  RETURN (TRUE);  END_IF;
  IF es2 = es_generics THEN  RETURN (TRUE);  END_IF;
  IF (es1 = es_booleans) AND (es2 = es_logicals) THEN  RETURN (TRUE);  END_IF;
  IF (es2 = es_numbers) AND ((es1 = es_complex_numbers) OR (es1 = es_reals) OR
    (es1 = es_integers)) THEN  RETURN (TRUE);  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- es_subspace_of_es
FUNCTION expression_is_constant(expr : generic_expression) : BOOLEAN;
  RETURN (bool(SIZEOF (free_variables_of (expr)) = 0));
END_FUNCTION;  -- expression_is_constant
FUNCTION extract_factors(tspace : tuple_space;
                         m, n   : INTEGER) : tuple_space;
  LOCAL
    tsp : tuple_space := the_zero_tuple_space;
  END_LOCAL;
  REPEAT i := m TO n;
    tsp := assoc_product_space (tsp, factor_space (tspace, i));
  END_REPEAT;
  RETURN (tsp);
END_FUNCTION;  -- extract_factors
FUNCTION extremal_position_check(fun : linearized_table_function) : BOOLEAN;
  LOCAL
    source_domain : maths_space;
    source_interval : finite_integer_interval;
    index : INTEGER := 1;
    base : INTEGER;
    shape : LIST OF positive_integer;
    ndim : positive_integer;
    slo, shi : INTEGER;
    sublo : LIST OF INTEGER := [];
    subhi : LIST OF INTEGER := [];
  END_LOCAL;
  IF NOT EXISTS (fun) THEN  RETURN (FALSE);  END_IF;
  source_domain := factor1 (fun.source.domain);
  IF (schema_prefix + 'TUPLE_SPACE') IN TYPEOF (source_domain) THEN
    source_domain := factor1 (source_domain);
  END_IF;
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (source_domain)) THEN
    RETURN (FALSE);
  END_IF;
  source_interval := source_domain;
  base := fun\explicit_table_function.index_base;
  shape := fun\explicit_table_function.shape;
  IF (schema_prefix + 'STANDARD_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    REPEAT j := 1 TO SIZEOF (shape);
      index := index * shape[j];
    END_REPEAT;
    index := fun.first + index - 1;
    RETURN (bool({source_interval.min <= index <= source_interval.max}));
  END_IF;
  IF (schema_prefix + 'REGULAR_TABLE_FUNCTION') IN TYPEOF (fun) THEN
    ndim := SIZEOF (fun\explicit_table_function.shape);
    REPEAT j:= 1 TO ndim;
      slo := base;
      shi := base + shape[j] - 1;
      IF fun\regular_table_function.increments[j] >= 0 THEN
        INSERT (sublo, slo, j-1);
        INSERT (subhi, shi, j-1);
      ELSE
        INSERT (sublo, shi, j-1);
        INSERT (subhi, slo, j-1);
      END_IF;
    END_REPEAT;
    index := regular_indexing (sublo, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    index := regular_indexing (subhi, base, shape,
      fun\regular_table_function.increments, fun.first);
    IF NOT ({source_interval.min <= index <= source_interval.max}) THEN
      RETURN (FALSE);
    END_IF;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- extremal_position_check
FUNCTION factor1(tspace : tuple_space) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\uniform_product_space.base);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    RETURN (tspace\listed_product_space.factors[1]);
    -- This path could return the indeterminate value if the list is empty.
    -- This is the correct result for this case.
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    RETURN (factor1 (tspace\extended_tuple_space.base));
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor1
FUNCTION factor_space(tspace : tuple_space;
                      idx    : positive_integer) : maths_space;
  LOCAL
    typenames : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    IF idx <= tspace\uniform_product_space.exponent THEN
      RETURN (tspace\uniform_product_space.base);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    IF idx <= SIZEOF (tspace\listed_product_space.factors) THEN
      RETURN (tspace\listed_product_space.factors[idx]);
    END_IF;
    RETURN (?);
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN typenames THEN
    IF idx <= space_dimension (tspace\extended_tuple_space.base) THEN
      RETURN (factor_space (tspace\extended_tuple_space.base, idx));
    END_IF;
    RETURN (tspace\extended_tuple_space.extender);
  END_IF;
  -- Should not be reachable.
  RETURN (?);
END_FUNCTION;  -- factor_space
FUNCTION free_variables_of(expr : generic_expression) : SET OF generic_variable;
  LOCAL
    typenames : SET OF STRING := stripped_typeof(expr);
    result : SET OF generic_variable := [];
    exprs : LIST OF generic_expression := [];
  END_LOCAL;
  IF 'GENERIC_LITERAL' IN typenames THEN
    RETURN (result);
  END_IF;
  IF 'GENERIC_VARIABLE' IN typenames THEN
    result := result + expr;
    RETURN (result);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN typenames THEN
    exprs := QUERY (ge <* expr\multiple_arity_generic_expression.operands |
      NOT (ge IN expr\quantifier_expression.variables));
    REPEAT i := 1 TO SIZEOF (exprs);
      result := result + free_variables_of (exprs[i]);
    END_REPEAT;
    REPEAT i := 1 TO SIZEOF (expr\quantifier_expression.variables);
      result := result - expr\quantifier_expression.variables[i];
    END_REPEAT;
    RETURN (result);
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN typenames THEN
    RETURN (free_variables_of (expr\unary_generic_expression.operand));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN typenames THEN
    result := free_variables_of (expr\binary_generic_expression.operands[1]);
    RETURN (result + free_variables_of (expr\binary_generic_expression.operands[2]));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN
    REPEAT i := 1 TO SIZEOF (expr\multiple_arity_generic_expression.operands);
      result := result + free_variables_of (
        expr\multiple_arity_generic_expression.operands[i]);
    END_REPEAT;
    RETURN (result);
  END_IF;
  -- In this case the subtype shall not contain any variable (see IP1 in
  -- generic_expression).
  RETURN (result);
END_FUNCTION;  -- free_variables_of
FUNCTION function_applicability(func      : maths_function_select;
                                arguments : LIST [1:?] OF maths_value) : BOOLEAN;
  LOCAL
    domain : tuple_space := convert_to_maths_function(func).domain;
    domain_types : SET OF STRING := TYPEOF (domain);
    narg : positive_integer := SIZEOF (arguments);
    arg : generic_expression;
  END_LOCAL;
  IF (schema_prefix + 'PRODUCT_SPACE') IN domain_types THEN
    IF space_dimension (domain) <> narg THEN  RETURN (FALSE);  END_IF;
  ELSE
    IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN domain_types THEN
      IF space_dimension (domain) > narg THEN  RETURN (FALSE);  END_IF;
    ELSE
      RETURN (FALSE);  -- Should be unreachable
    END_IF;
  END_IF;
  REPEAT i := 1 TO narg;
    arg := convert_to_operand (arguments[i]);
    IF NOT has_values_space (arg) THEN  RETURN (FALSE);  END_IF;
    IF NOT compatible_spaces (factor_space (domain, i), values_space_of (arg)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_applicability
FUNCTION function_is_1d_array(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_array
FUNCTION function_is_1d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    itvl : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF (schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (temp) THEN
    IF space_dimension (temp) <> 1 THEN  RETURN (FALSE);  END_IF;
    temp := factor1 (temp);
  END_IF;
  IF (schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp) THEN
    itvl := temp;
    RETURN (bool((itvl.min = 0) OR (itvl.min = 1)));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- function_is_1d_table
FUNCTION function_is_2d_table(func : maths_function) : BOOLEAN;
  LOCAL
    temp : maths_space;
    pspace : product_space;
    itvl1, itvl2 : finite_integer_interval;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  IF space_dimension (func.domain) <> 1 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (func.domain);
  IF NOT ('PRODUCT_SPACE' IN stripped_typeof(temp)) THEN  RETURN (FALSE);  END_IF;
  pspace := temp;
  IF space_dimension (pspace) <> 2 THEN  RETURN (FALSE);  END_IF;
  temp := factor1 (pspace);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl1 := temp;
  temp := factor_space (pspace, 2);
  IF NOT ('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp)) THEN
    RETURN (FALSE);
  END_IF;
  itvl2 := temp;
  RETURN (bool((itvl1.min = itvl2.min) AND ((itvl1.min = 0) OR (itvl1.min = 1))));
END_FUNCTION;  -- function_is_2d_table
FUNCTION function_is_array(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_array
FUNCTION function_is_table(func : maths_function) : BOOLEAN;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    base : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (func) THEN  RETURN (FALSE);  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  IF NOT ((schema_prefix + 'PRODUCT_SPACE') IN TYPEOF (tspace)) THEN
    RETURN (FALSE);
  END_IF;
  temp := factor1 (tspace);
  IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
    RETURN (FALSE);
  END_IF;
  base := temp\finite_integer_interval.min;
  IF (base <> 0) AND (base <> 1) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT i := 2 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (FALSE);
    END_IF;
    IF temp\finite_integer_interval.min <> base THEN  RETURN (FALSE);  END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- function_is_table
FUNCTION has_values_space(expr : generic_expression) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := stripped_typeof (expr);
  END_LOCAL;
  IF 'EXPRESSION' IN typenames THEN
    RETURN (bool(('NUMERIC_EXPRESSION' IN typenames) OR
      ('STRING_EXPRESSION' IN typenames) OR
      ('BOOLEAN_EXPRESSION' IN typenames)));
  END_IF;
  IF 'MATHS_FUNCTION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'FUNCTION_APPLICATION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_SPACE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_VARIABLE' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEPENDENT_VARIABLE_DEFINITION' IN typenames THEN
    RETURN (has_values_space (expr\unary_generic_expression.operand));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'LOGICAL_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'BINARY_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'PARTIAL_DERIVATIVE_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- has_values_space
FUNCTION list_selected_components(aggr : AGGREGATE OF LIST OF maths_value;
                                  k    : positive_integer) : LIST OF maths_value;
  LOCAL
    result : LIST OF maths_value := [];
    j : INTEGER := 0;
  END_LOCAL;
  REPEAT i := LOINDEX (aggr) TO HIINDEX (aggr);
    IF k <= SIZEOF (aggr[i]) THEN
      INSERT (result, aggr[i][k], j);
      j := j + 1;
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- list_selected_components
FUNCTION make_abstracted_expression_function(
                                    operands : LIST [2:?] OF generic_expression)
                                   : abstracted_expression_function;
  RETURN (abstracted_expression_function()
    || maths_function()
      || generic_expression()
    || quantifier_expression (remove_first (operands))  -- derived
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_abstracted_expression_function
FUNCTION make_atom_based_literal(lit_value : atom_based_value) : atom_based_literal;
  RETURN (atom_based_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_atom_based_literal
FUNCTION make_b_spline_basis(degree         : nonnegative_integer;
                             repeated_knots : LIST [2:?] OF REAL) : b_spline_basis;
  RETURN (b_spline_basis (degree, repeated_knots)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_b_spline_basis
FUNCTION make_b_spline_function(coef  : maths_function;
                                bases : LIST [1:?] OF b_spline_basis)
                               : b_spline_function;
  RETURN (b_spline_function (bases)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (coef) );
END_FUNCTION;  -- make_b_spline_function
FUNCTION make_banded_matrix(index_base    : zero_or_one;
                            shape         : LIST [1:?] OF positive_integer;
                            source        : maths_function;
                            first         : INTEGER;
                            default_entry : maths_value;
                            below         : INTEGER;
                            above         : INTEGER;
                            order         : ordering_type) : banded_matrix;
  RETURN (banded_matrix (default_entry, below, above, order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (source) );
END_FUNCTION;  -- make_banded_matrix
FUNCTION make_basic_sparse_matrix(index_base    : zero_or_one;
                                  shape         : LIST [1:?] OF positive_integer;
                                  operands      : LIST [3:3] OF maths_function;
                                  default_entry : maths_value;
                                  order         : ordering_type)
                                 : basic_sparse_matrix;
  RETURN (basic_sparse_matrix (default_entry, order)
    || explicit_table_function (index_base, shape)
      || maths_function()
        || generic_expression()
    || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_basic_sparse_matrix
FUNCTION make_binary_literal(lit_value : BINARY) : binary_literal;
  RETURN (binary_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_binary_literal
FUNCTION make_boolean_literal(lit_value : BOOLEAN) : boolean_literal;
  RETURN (boolean_literal (lit_value)
    || simple_boolean_expression()
      || boolean_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_boolean_literal
FUNCTION make_cartesian_complex_number_region(real_constraint : real_interval;
                                              imag_constraint : real_interval)
                                             : cartesian_complex_number_region;
  RETURN (cartesian_complex_number_region (real_constraint, imag_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_cartesian_complex_number_region
FUNCTION make_complex_number_literal(rpart, ipart : REAL) : complex_number_literal;
  RETURN (complex_number_literal (rpart, ipart)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_complex_number_literal
FUNCTION make_constant_function(sole_value   : maths_value;
                                src_of_domn  : maths_space_or_function)
                               : constant_function;
  RETURN (constant_function (sole_value, src_of_domn)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_constant_function
FUNCTION make_cos_expression(operand : numeric_expression) : cos_expression;
  RETURN (cos_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_cos_expression
FUNCTION make_definite_integral_expression(
                                   operands     : LIST [2:4] OF generic_expression;
                                   loinf, upinf : BOOLEAN)
                                          : definite_integral_expression;
  RETURN (definite_integral_expression (loinf, upinf)
    || quantifier_expression ([operands[2]])
      || multiple_arity_generic_expression (operands)
        || generic_expression() );
END_FUNCTION;  -- make_definite_integral_expression
FUNCTION make_definite_integral_function(integrand    : maths_function;
                                         varintg      : input_selector;
                                         loinf, upinf : BOOLEAN)
                                        : definite_integral_function;
  RETURN (definite_integral_function (varintg, loinf, upinf)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (integrand) );
END_FUNCTION;  -- make_definite_integral_function
FUNCTION make_elementary_function(func_id : elementary_function_enumerators)
                                 : elementary_function;
  RETURN (elementary_function (func_id)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_function
FUNCTION make_elementary_space(space_id : elementary_space_enumerators)
                              : elementary_space;
  RETURN (elementary_space (space_id)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_elementary_space
FUNCTION make_environment(varbl : generic_variable;
                          sem   : variable_semantics) : environment;
  RETURN (environment (varbl, sem) );
END_FUNCTION;  -- make_environment
FUNCTION make_expression_denoted_function(expression : generic_expression)
                                         : expression_denoted_function;
  RETURN (expression_denoted_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (expression) );
END_FUNCTION;  -- make_expression_denoted_function
FUNCTION make_extended_tuple_space(base     : product_space;
                                   extender : maths_space) : extended_tuple_space;
  RETURN (extended_tuple_space (base, extender)
    || maths_space ()
      || generic_expression()
    || generic_literal ()
      || simple_generic_expression() );
END_FUNCTION;  -- make_extended_tuple_space
FUNCTION make_finite_function(pairs : SET [1:?] OF LIST [2:2] OF maths_value)
                             : finite_function;
  RETURN (finite_function (pairs)
    || maths_function()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_function
FUNCTION make_finite_integer_interval(min : INTEGER;
                                      max : INTEGER) : finite_integer_interval;
  RETURN (finite_integer_interval (min, max)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_integer_interval
FUNCTION make_finite_real_interval(min    : REAL;
                                   minclo : open_closed;
                                   max    : REAL;
                                   maxclo : open_closed) : finite_real_interval;
  RETURN (finite_real_interval (min, minclo, max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_real_interval
FUNCTION make_finite_space(members : SET OF maths_value) : finite_space;
  RETURN (finite_space (members)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_finite_space
FUNCTION make_function_application(afunction : maths_function_select;
                                   arguments : LIST [1:?] OF maths_value)
                                  : function_application;
  RETURN (function_application (afunction, arguments)
    || multiple_arity_generic_expression (convert_to_maths_function (afunction) +
      convert_to_operands (arguments))  -- derived
      || generic_expression() );
END_FUNCTION;  -- make_function_application
FUNCTION make_function_space(domain_constraint : space_constraint_type;
                             domain_argument   : maths_space;
                             range_constraint  : space_constraint_type;
                             range_argument    : maths_space) : function_space;
  RETURN (function_space (domain_constraint, domain_argument, range_constraint,
    range_argument)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_function_space
FUNCTION make_general_linear_function(mat       : maths_function;
                                      sum_index : one_or_two)
                                     : general_linear_function;
  RETURN (general_linear_function (sum_index)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (mat) );
END_FUNCTION;  -- make_general_linear_function
FUNCTION make_int_literal(lit_value : INTEGER) : int_literal;
  RETURN (int_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_int_literal
FUNCTION make_integer_interval_from_min(min : INTEGER)
  : integer_interval_from_min;
  RETURN (integer_interval_from_min (min)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_integer_interval_from_min
FUNCTION make_listed_complex_number_data(index_base : zero_or_one;
                                         values     : LIST [2:?] OF REAL)
                                        : listed_complex_number_data;
  RETURN (listed_complex_number_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)/2])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_complex_number_data
FUNCTION make_listed_data(index_base  : zero_or_one;
                          values      : LIST [2:?] OF maths_value;
                          value_range : maths_space) : listed_data;
  RETURN (listed_data (values, value_range)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_data
FUNCTION make_listed_integer_data(index_base : zero_or_one;
                                  values     : LIST [1:?] OF INTEGER)
                                 : listed_integer_data;
  RETURN (listed_integer_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_integer_data
FUNCTION make_listed_product_space(factors : LIST OF maths_space)
                                  : listed_product_space;
  RETURN (listed_product_space (factors)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_product_space
FUNCTION make_listed_real_data(index_base : zero_or_one;
                               values     : LIST [1:?] OF REAL)
                              : listed_real_data;
  RETURN (listed_real_data (values)
    || explicit_table_function (index_base, [SIZEOF (values)])  -- 2nd derived
      || maths_function()
        || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_listed_real_data
FUNCTION make_logical_literal(lit_value : LOGICAL) : logical_literal;
  RETURN (logical_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_logical_literal
FUNCTION make_maths_enum_literal(lit_value : maths_enum_atom) : maths_enum_literal;
  RETURN (maths_enum_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_enum_literal

FUNCTION make_maths_real_variable(values_space : maths_space;
                                  name         : label) : maths_real_variable;
    
   RETURN (expression() || numeric_expression() || simple_numeric_expression() 
   ||  maths_real_variable() 
    || maths_variable (values_space, name)
      || generic_variable()
        || simple_generic_expression()
          || generic_expression()
    || real_numeric_variable()
      || numeric_variable()
        || variable() );
  END_FUNCTION;

FUNCTION make_maths_tuple_literal(lit_value : LIST OF maths_value)
                                 : maths_tuple_literal;
  RETURN (maths_tuple_literal (lit_value)
    || generic_literal()
      || simple_generic_expression()
        || generic_expression() );
END_FUNCTION;  -- make_maths_tuple_literal
FUNCTION make_mult_expression(operands : LIST [2:?] OF generic_expression)
                             : mult_expression;
  RETURN (mult_expression()
    || multiple_arity_numeric_expression()
      || numeric_expression()
        || expression()
          || generic_expression()
      || multiple_arity_generic_expression (operands) );
END_FUNCTION;  -- make_mult_expression
FUNCTION make_parallel_composed_function(srcdom    : maths_space_or_function;
                                         prepfuncs : LIST [2:?] OF maths_function;
                                         finfunc   : maths_function_select)
                                        : parallel_composed_function;
  RETURN (parallel_composed_function (srcdom, prepfuncs, finfunc)
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (convert_to_operands_prcmfn (
      srcdom, prepfuncs, finfunc)) );  -- derived
END_FUNCTION;  -- make_parallel_composed_function
FUNCTION make_partial_derivative_expression(derivand : generic_expression;
                                            dvars    : LIST [1:?] OF maths_variable;
                                            extend   : extension_options)
                                           : partial_derivative_expression;
  RETURN (partial_derivative_expression (dvars, extend)
    || unary_generic_expression (derivand)
      || generic_expression() );
END_FUNCTION;  -- make_partial_derivative_expression
FUNCTION make_partial_derivative_function(derivand : maths_function;
                                          dvars    : LIST [1:?] OF input_selector;
                                          extend   : extension_options)
                                         : partial_derivative_function;
  RETURN (partial_derivative_function (dvars, extend)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (derivand) );
END_FUNCTION;  -- make_partial_derivative_function
FUNCTION make_polar_complex_number_region(centre         : complex_number_literal;
                                          dis_constraint : real_interval;
                                          dir_constraint : finite_real_interval)
                                         : polar_complex_number_region;
  RETURN (polar_complex_number_region (centre, dis_constraint, dir_constraint)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_polar_complex_number_region
FUNCTION make_rationalize_function(fun : maths_function) : rationalize_function;
  RETURN (rationalize_function()
    || maths_function()
      || generic_expression()
    || unary_generic_expression (fun) );
END_FUNCTION;  -- make_rationalize_function
FUNCTION make_real_interval_from_min(min    : REAL;
                                     minclo : open_closed) : real_interval_from_min;
  RETURN (real_interval_from_min (min, minclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_from_min
FUNCTION make_real_interval_to_max(max    : REAL;
                                   maxclo : open_closed) : real_interval_to_max;
  RETURN (real_interval_to_max (max, maxclo)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_real_interval_to_max
FUNCTION make_real_literal(lit_value : REAL) : real_literal;
  RETURN (real_literal ()
    || literal_number(lit_value)
      || simple_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || simple_generic_expression()
      || generic_literal() );
END_FUNCTION;  -- make_real_literal
FUNCTION make_regular_table_function(index_base : zero_or_one;
                                     shape      : LIST [1:?] OF positive_integer;
                                     operand    : maths_function;
                                     first      : INTEGER;
                                     increments : LIST [1:?] OF INTEGER)
                                    : regular_table_function;
  RETURN (regular_table_function (increments)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_regular_table_function
FUNCTION make_reindexed_array_function(func       : maths_function;
                                       start_idxs : LIST [1:?] OF INTEGER)
                                      : reindexed_array_function;
  RETURN (reindexed_array_function(start_idxs)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (func) );
END_FUNCTION;  -- make_reindexed_array_function
FUNCTION make_repackaging_function(operand         : maths_function;
                                   input_repack    : repackage_options;
                                   output_repack   : repackage_options;
                                   selected_output : nonnegative_integer)
                                  : repackaging_function;
  RETURN (repackaging_function (input_repack, output_repack, selected_output)
    || maths_function()
      || generic_expression()
    || unary_generic_expression (operand) );
END_FUNCTION;  -- make_repackaging_function
FUNCTION make_selector_function(selector    : input_selector;
                                src_of_domn : maths_space_or_function)
                               : selector_function;
  RETURN (selector_function (selector, src_of_domn)
    || maths_function()
       || generic_expression()
    || generic_literal()
       || simple_generic_expression() );
END_FUNCTION;  -- make_selector_function
FUNCTION make_series_composed_function(functions : LIST [2:?] OF maths_function)
                                      : series_composed_function;
  RETURN (series_composed_function()
    || maths_function()
      || generic_expression()
    || multiple_arity_generic_expression (functions) );
END_FUNCTION;  -- make_series_composed_function
FUNCTION make_sin_expression(operand : numeric_expression) : sin_expression;
  RETURN (sin_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_sin_expression
FUNCTION make_standard_table_function(index_base : zero_or_one;
                                      shape      : LIST [1:?] OF positive_integer;
                                      operand    : maths_function;
                                      first      : INTEGER;
                                      order      : ordering_type)
                                     : standard_table_function;
  RETURN (standard_table_function (order)
    || linearized_table_function (first)
      || explicit_table_function (index_base, shape)
        || maths_function()
          || generic_expression()
      || unary_generic_expression (operand) );
END_FUNCTION;  -- make_standard_table_function
FUNCTION make_strict_triangular_matrix(index_base    : zero_or_one;
                                       shape         : LIST [1:?] OF positive_integer;
                                       source        : maths_function;
                                       first         : INTEGER;
                                       default_entry : maths_value;
                                       lo_up         : lower_upper;
                                       order         : ordering_type;
                                       main_diagonal_value : maths_value)
                                      : strict_triangular_matrix;
  RETURN (strict_triangular_matrix (main_diagonal_value)
    || triangular_matrix (default_entry, lo_up, order)
      || linearized_table_function (first)
        || explicit_table_function (index_base, shape)
          || maths_function()
            || generic_expression()
        || unary_generic_expression (source) );
END_FUNCTION;  -- make_strict_triangular_matrix
FUNCTION make_string_literal(lit_value : STRING) : string_literal;
  RETURN (string_literal (lit_value)
    || simple_string_expression()
      || string_expression()
        || expression()
          || generic_expression()
      || simple_generic_expression()
    || generic_literal() );
END_FUNCTION;  -- make_string_literal
FUNCTION make_unary_minus_expression(operand : numeric_expression)
  : unary_minus_expression;
  RETURN (unary_minus_expression()
    || unary_numeric_call_expression()
      || unary_numeric_expression()
        || numeric_expression()
          || expression()
            || generic_expression()
        || unary_generic_expression (operand) );
END_FUNCTION;  -- make_unary_minus_expression
FUNCTION make_uniform_product_space(base     : maths_space;
                                    exponent : positive_integer)
                                   : uniform_product_space;
  RETURN (uniform_product_space (base, exponent)
    || maths_space()
      || generic_expression()
    || generic_literal()
      || simple_generic_expression() );
END_FUNCTION;  -- make_uniform_product_space
FUNCTION max_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types)));
END_FUNCTION;  -- max_exists
FUNCTION max_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.max_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (bool(spc\real_interval_to_max.max_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- max_included
FUNCTION member_of(val : GENERIC:G;
                   spc : maths_space) : LOGICAL;

  -- Trivial function introduced to avoid NIST Fedex compiler error
  FUNCTION fedex(val : AGGREGATE OF GENERIC:X;
                 i   : INTEGER) : GENERIC:X;
    RETURN (val[i]);
  END_FUNCTION;  -- fedex

  LOCAL
    v : maths_value := simplify_maths_value (convert_to_maths_value (val));
    vtypes : SET OF STRING := stripped_typeof (v);
    s : maths_space := simplify_maths_space (spc);
    stypes : SET OF STRING := stripped_typeof (s);
    tmp_int : INTEGER;
    tmp_real : REAL;
    tmp_cmplx : complex_number_literal;
    lgcl, cum : LOGICAL;
    vspc, sspc : maths_space;
    smem : SET OF maths_value;
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (s) THEN
    RETURN (FALSE);
  END_IF;
  IF NOT EXISTS (v) THEN
    RETURN (s = the_generics);
  END_IF;
  IF ('GENERIC_EXPRESSION' IN vtypes) AND
    NOT ('MATHS_SPACE' IN vtypes) AND
    NOT ('MATHS_FUNCTION' IN vtypes) AND
    NOT ('COMPLEX_NUMBER_LITERAL' IN vtypes) THEN
    IF has_values_space (v) THEN
      vspc := values_space_of (v);
      IF subspace_of (vspc, s) THEN
        RETURN (TRUE);
      END_IF;
      IF NOT compatible_spaces (vspc, s) THEN
        RETURN (FALSE);
      END_IF;
      RETURN (UNKNOWN);
    END_IF;
    RETURN (UNKNOWN);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN stypes THEN
    CASE s\elementary_space.space_id OF
    es_numbers :  RETURN (('NUMBER' IN vtypes) OR
                          ('COMPLEX_NUMBER_LITERAL' IN vtypes));
    es_complex_numbers :  RETURN ('COMPLEX_NUMBER_LITERAL' IN vtypes);
    es_reals :  RETURN (('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes));
    es_integers :  RETURN ('INTEGER' IN vtypes);
    es_logicals :  RETURN ('LOGICAL' IN vtypes);
    es_booleans :  RETURN ('BOOLEAN' IN vtypes);
    es_strings :  RETURN ('STRING' IN vtypes);
    es_binarys :  RETURN ('BINARY' IN vtypes);
    es_maths_spaces :  RETURN ('MATHS_SPACE' IN vtypes);
    es_maths_functions :  RETURN ('MATHS_FUNCTION' IN vtypes);
    es_generics :  RETURN (TRUE);
    END_CASE;
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN ({s\finite_integer_interval.min <= tmp_int <=
        s\finite_integer_interval.max});
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (s\integer_interval_from_min.min <= tmp_int);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN stypes THEN
    IF 'INTEGER' IN vtypes THEN
      tmp_int := v;
      RETURN (tmp_int <= s\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\finite_real_interval.min_closure = closed THEN
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min <= tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min <= tmp_real <
            s\finite_real_interval.max});
        END_IF;
      ELSE
        IF s\finite_real_interval.max_closure = closed THEN
          RETURN ({s\finite_real_interval.min < tmp_real <=
            s\finite_real_interval.max});
        ELSE
          RETURN ({s\finite_real_interval.min < tmp_real <
            s\finite_real_interval.max});
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_from_min.min_closure = closed THEN
        RETURN (s\real_interval_from_min.min <= tmp_real);
      ELSE
        RETURN (s\real_interval_from_min.min < tmp_real);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN stypes THEN
    IF ('REAL' IN vtypes) AND NOT ('INTEGER' IN vtypes) THEN
      tmp_real := v;
      IF s\real_interval_to_max.max_closure = closed THEN
        RETURN (tmp_real <= s\real_interval_to_max.max);
      ELSE
        RETURN (tmp_real < s\real_interval_to_max.max);
     END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      RETURN (member_of(v\complex_number_literal.real_part,
        s\cartesian_complex_number_region.real_constraint) AND
        member_of(v\complex_number_literal.imag_part,
        s\cartesian_complex_number_region.imag_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN stypes THEN
    IF 'COMPLEX_NUMBER_LITERAL' IN vtypes THEN
      tmp_cmplx := v;
      tmp_cmplx.real_part := tmp_cmplx.real_part -
        s\polar_complex_number_region.centre.real_part;
      tmp_cmplx.imag_part := tmp_cmplx.imag_part -
        s\polar_complex_number_region.centre.imag_part;
      tmp_real := SQRT (tmp_cmplx.real_part**2 + tmp_cmplx.imag_part**2);
      IF NOT member_of(tmp_real,
        s\polar_complex_number_region.distance_constraint) THEN
        RETURN (FALSE);
      END_IF;
      IF tmp_real = 0.0 THEN
        RETURN (TRUE);  -- The centre has no direction.
      END_IF;
      tmp_real := atan2(tmp_cmplx.imag_part,tmp_cmplx.real_part);
      RETURN (member_of(tmp_real,
        s\polar_complex_number_region.direction_constraint) OR
        member_of(tmp_real + 2.0*PI,
        s\polar_complex_number_region.direction_constraint));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN stypes THEN
    smem := s\finite_space.members;
    cum := FALSE;
    REPEAT i := 1 TO SIZEOF (smem);
      cum := cum OR equal_maths_values(v,smem[i]);
      IF cum = TRUE THEN
        RETURN (TRUE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      IF SIZEOF (v) = s\uniform_product_space.exponent THEN
        sspc := s\uniform_product_space.base;
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
--          cum := cum AND member_of (fedex (v, i), sspc);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      factors := s\listed_product_space.factors;
      IF SIZEOF (v) = SIZEOF (factors) THEN
        cum := TRUE;
        REPEAT i := 1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],factors[i]);
--          cum := cum AND member_of (fedex (v, i), factors[i]);
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    IF 'LIST' IN vtypes THEN
      sspc := s\extended_tuple_space.base;
      tmp_int := space_dimension(sspc);
      IF SIZEOF (v) >= tmp_int THEN
        cum := TRUE;
        REPEAT i := 1 TO tmp_int;
          cum := cum AND member_of(v[i],factor_space(sspc,i));
--          cum := cum AND member_of (fedex (v, i), factor_space (sspc, i));
            -- See note above for explanation of fedex()
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        sspc := s\extended_tuple_space.extender;
        REPEAT i := tmp_int+1 TO SIZEOF (v);
          cum := cum AND member_of(v[i],sspc);
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    IF 'MATHS_FUNCTION' IN vtypes THEN
      vspc := v\maths_function.domain;
      sspc := s\function_space.domain_argument;
      CASE s\function_space.domain_constraint OF
      sc_equal : cum := equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := subspace_of (vspc, sspc);
      sc_member : cum := member_of (vspc, sspc);
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      vspc := v\maths_function.range;
      sspc := s\function_space.range_argument;
      CASE s\function_space.range_constraint OF
      sc_equal : cum := cum AND equal_maths_spaces (vspc, sspc);
      sc_subspace : cum := cum AND subspace_of (vspc, sspc);
      sc_member : cum := cum AND member_of (vspc, sspc);
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- member_of
FUNCTION min_exists(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  RETURN (bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) OR
    ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) OR
    ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types)));
END_FUNCTION;  -- min_exists
FUNCTION min_included(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) OR
    ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (TRUE);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (bool(spc\finite_real_interval.min_closure = closed));
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (bool(spc\real_interval_from_min.min_closure = closed));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- min_included
FUNCTION no_cyclic_domain_reference(ref  : maths_space_or_function;
                                    used : SET OF maths_function) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (ref);
    func      : maths_function;
  END_LOCAL;
  IF (NOT EXISTS (ref)) OR (NOT EXISTS (used)) THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    RETURN (TRUE);
  END_IF;
  func := ref;
  IF func IN used THEN
    RETURN (FALSE);
  END_IF;
  IF (schema_prefix + 'CONSTANT_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\constant_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'SELECTOR_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (func\selector_function.source_of_domain,
      used + [func]));
  END_IF;
  IF (schema_prefix + 'PARALLEL_COMPOSED_FUNCTION') IN typenames THEN
    RETURN (no_cyclic_domain_reference (
      func\parallel_composed_function.source_of_domain, used + [func]));
  END_IF;
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_domain_reference
FUNCTION no_cyclic_space_reference(spc  : maths_space;
                                   refs : SET OF maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING;
    refs_plus : SET OF maths_space;
  END_LOCAL;
  IF (spc IN refs) THEN
    RETURN (FALSE);
  END_IF;
  types := TYPEOF (spc);
  refs_plus := refs + spc;
  IF (schema_prefix + 'FINITE_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (sp <* QUERY (mem <* spc\finite_space.members |
      (schema_prefix + 'MATHS_SPACE') IN TYPEOF (mem)) |
      NOT no_cyclic_space_reference (sp, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\uniform_product_space.base, refs_plus));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (bool(SIZEOF (QUERY (fac <* spc\listed_product_space.factors |
      NOT no_cyclic_space_reference (fac, refs_plus))) = 0));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    RETURN (no_cyclic_space_reference (spc\extended_tuple_space.base, refs_plus)
      AND no_cyclic_space_reference (spc\extended_tuple_space.extender, refs_plus));
  END_IF;
  -- spc contains no references to other spaces
  RETURN (TRUE);
END_FUNCTION;  -- no_cyclic_space_reference
FUNCTION nondecreasing(lr : LIST OF REAL) : BOOLEAN;
  IF NOT EXISTS (lr) THEN
    RETURN (FALSE);
  END_IF;
  REPEAT j := 2 TO SIZEOF (lr);
    IF lr[j] < lr[j-1] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
FUNCTION number_superspace_of(spc : maths_space) : elementary_space;
  IF subspace_of_es(spc,es_integers) THEN  RETURN (the_integers);  END_IF;
  IF subspace_of_es(spc,es_reals)    THEN  RETURN (the_reals);     END_IF;
  IF subspace_of_es(spc,es_complex_numbers) THEN  RETURN (the_complex_numbers); END_IF;
  IF subspace_of_es(spc,es_numbers)  THEN  RETURN (the_numbers);   END_IF;
  RETURN (?);
END_FUNCTION;  -- number_superspace_of
FUNCTION number_tuple_subspace_check(spc : maths_space) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
    factors : LIST OF maths_space;
    cum : LOGICAL := TRUE;
  END_LOCAL;
  IF 'UNIFORM_PRODUCT_SPACE' IN types THEN
    RETURN (subspace_of_es(spc\uniform_product_space.base,es_numbers));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN types THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      cum := cum AND subspace_of_es(factors[i],es_numbers);
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types THEN
    cum := subspace_of_es(spc\extended_tuple_space.extender,es_numbers);
    cum := cum AND number_tuple_subspace_check(spc\extended_tuple_space.base);
    RETURN (cum);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
FUNCTION one_tuples_of(spc : maths_space) : tuple_space;
  RETURN (make_uniform_product_space (spc, 1));
END_FUNCTION;  -- one_tuples_of
FUNCTION parallel_composed_function_composability_check(
                                      funcs  : LIST OF maths_function;
                                      final  : maths_function_select) : BOOLEAN;
  LOCAL
    tplsp : tuple_space := the_zero_tuple_space;
    finfun : maths_function := convert_to_maths_function (final);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (funcs);
    tplsp := assoc_product_space (tplsp, funcs[i].range);
  END_REPEAT;
  RETURN (compatible_spaces (tplsp, finfun.domain));
END_FUNCTION;  -- parallel_composed_function_composability_check
FUNCTION parallel_composed_function_domain_check(
                                comdom : tuple_space;
                                funcs  : LIST OF maths_function) : BOOLEAN;
  REPEAT i := 1 TO SIZEOF (funcs);
    IF NOT (compatible_spaces (comdom, funcs[i].domain)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- parallel_composed_function_domain_check
FUNCTION parse_express_identifier(s : STRING;
                                  i : positive_integer) : positive_integer;
  LOCAL
    k : positive_integer;
  END_LOCAL;
  k := i;
  IF i <= LENGTH (s) THEN
    IF (s[i] LIKE '@') THEN
      REPEAT UNTIL (k > LENGTH (s)) OR
        ((s[k] <> '_') AND NOT (s[k] LIKE '@') AND NOT (s[k] LIKE '#'));
        k := k + 1;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (k);
END_FUNCTION;  -- parse_express_identifier
FUNCTION partial_derivative_check(domain : tuple_space;
                                  d_vars : LIST [1:?] OF input_selector) : BOOLEAN;
  LOCAL
    domn : tuple_space := domain;
    fspc : maths_space;
    dim : INTEGER;
    k : INTEGER;
  END_LOCAL;
  IF (space_dimension (domain) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (domain))) THEN
    domn := factor1 (domain);
  END_IF;
  dim := space_dimension (domn);
  REPEAT i := 1 TO SIZEOF (d_vars);
    k := d_vars[i];
    IF k > dim THEN
       RETURN (FALSE);
    END_IF;
    fspc := factor_space (domn, k);
    IF (NOT subspace_of_es (fspc,es_reals)) AND
      (NOT subspace_of_es (fspc,es_complex_numbers)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;  -- partial_derivative_check
FUNCTION real_max(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.max);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\integer_interval_to_max.max);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.max);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_TO_MAX') IN types) THEN
    RETURN (spc\real_interval_to_max.max);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_max
FUNCTION real_min(spc : maths_space) : REAL;
  LOCAL
    types : SET OF STRING := TYPEOF (spc);
  END_LOCAL;
  IF ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN types) THEN
    RETURN (spc\finite_integer_interval.min);
  END_IF;
  IF ((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\integer_interval_from_min.min);
  END_IF;
  IF ((schema_prefix + 'FINITE_REAL_INTERVAL') IN types) THEN
    RETURN (spc\finite_real_interval.min);
  END_IF;
  IF ((schema_prefix + 'REAL_INTERVAL_FROM_MIN') IN types) THEN
    RETURN (spc\real_interval_from_min.min);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- real_min
FUNCTION regular_indexing(sub   : LIST OF INTEGER;
                          base  : zero_or_one;
                          shape : LIST [1:?] OF positive_integer;
                          inc   : LIST [1:?] OF INTEGER;
                          first : INTEGER) : INTEGER;
  LOCAL
    k : INTEGER;
    index : INTEGER;
  END_LOCAL;
  IF NOT EXISTS (sub) OR NOT EXISTS (base) OR NOT EXISTS (shape) OR
    NOT EXISTS (inc) OR NOT EXISTS (first) THEN
    RETURN (?);
  END_IF;
  IF (SIZEOF (sub) <> SIZEOF (inc)) OR (SIZEOF (sub) <> SIZEOF (shape)) THEN
    RETURN (?);
  END_IF;
  index := first;
  REPEAT j := 1 TO SIZEOF (sub);
    IF NOT EXISTS (sub[j]) OR NOT EXISTS (inc[j]) THEN
      RETURN (?);
    END_IF;
    k := sub[j] - base;
    IF NOT ({0 <= k < shape[j]}) THEN
      RETURN (?);
    END_IF;
    index := index + k*inc[j];
  END_REPEAT;
  RETURN (index);
END_FUNCTION;
FUNCTION remove_first(alist : LIST OF GENERIC:GEN) : LIST OF GENERIC:GEN;
  LOCAL
    blist : LIST OF GENERIC:GEN := alist;
  END_LOCAL;
  IF SIZEOF (blist) > 0 THEN
    REMOVE (blist, 1);
  END_IF;
  RETURN (blist);
END_FUNCTION;  -- remove_first
FUNCTION repackage(tspace : tuple_space;
                   repckg : repackage_options) : tuple_space;
  CASE repckg OF
  ro_nochange : RETURN (tspace);
  ro_wrap_as_tuple : RETURN (one_tuples_of (tspace));
  ro_unwrap_tuple : RETURN (factor1 (tspace));
  OTHERWISE : RETURN (?);
  END_CASE;
END_FUNCTION;  -- repackage
FUNCTION shape_of_array(func : maths_function) : LIST OF positive_integer;
  LOCAL
    tspace : tuple_space;
    temp : maths_space;
    result : LIST OF positive_integer := [];
  END_LOCAL;
  IF (schema_prefix + 'EXPLICIT_TABLE_FUNCTION') IN TYPEOF (func) THEN
    RETURN (func\explicit_table_function.shape);
  END_IF;
  tspace := func.domain;
  IF (space_dimension (tspace) = 1) AND ((schema_prefix + 'TUPLE_SPACE') IN
    TYPEOF (factor1 (tspace))) THEN
    tspace := factor1 (tspace);
  END_IF;
  REPEAT i := 1 TO space_dimension (tspace);
    temp := factor_space (tspace, i);
    IF NOT ((schema_prefix + 'FINITE_INTEGER_INTERVAL') IN TYPEOF (temp)) THEN
      RETURN (?);
    END_IF;
    INSERT (result, temp\finite_integer_interval.size, i-1);
  END_REPEAT;
  RETURN (result);
END_FUNCTION;  -- shape_of_array
FUNCTION simplify_function_application(expr : function_application) : maths_value;
  FUNCTION ctmv(x : GENERIC:G) : maths_value;
    RETURN (convert_to_maths_value(x));
  END_FUNCTION;  -- local abbreviation for convert_to_maths_value function
  PROCEDURE parts(       c : complex_number_literal;
                  VAR x, y : REAL);
    x := c.real_part;  y := c.imag_part;
  END_PROCEDURE;  -- parts
  FUNCTION makec(x, y : REAL) : complex_number_literal;
    RETURN (make_complex_number_literal(x,y));
  END_FUNCTION;  -- local abbreviation for make_complex_number_literal function
  FUNCTION good_t(v  : maths_value;
                  tn : STRING) : BOOLEAN;
    LOCAL
      tpl : LIST OF maths_value;
    END_LOCAL;
    IF 'LIST' IN TYPEOF (v) THEN
      tpl := v;
      REPEAT i := 1 TO SIZEOF (tpl);
        IF NOT (tn IN TYPEOF (tpl[i])) THEN  RETURN (FALSE);  END_IF;
      END_REPEAT;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_FUNCTION;  -- good_t
  CONSTANT
    cnlit : STRING := schema_prefix + 'COMPLEX_NUMBER_LITERAL';
  END_CONSTANT;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr.func);
    ef_val : elementary_function_enumerators;
    is_elementary : BOOLEAN := FALSE;
    v, v1, v2, v3 : maths_value;
    vlist : LIST OF maths_value := [];
    gexpr : generic_expression;
    pairs : SET [1:?] OF LIST [2:2] OF maths_value;
    boo : BOOLEAN;
    lgc, cum : LOGICAL;
    j, k, n : INTEGER;
    p, q, r, s, t, u : REAL;
    str, st2 : STRING;
    bin, bi2 : BINARY;
    tpl, tp2 : LIST OF maths_value;
    mem :SET OF maths_value := [];
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (expr.arguments);
    v := simplify_maths_value(expr.arguments[i]);
    INSERT (vlist, v, i-1);
  END_REPEAT;
  IF SIZEOF (vlist) >= 1 THEN  v1 := vlist[1];  END_IF;
  IF SIZEOF (vlist) >= 2 THEN  v2 := vlist[2];  END_IF;
  IF SIZEOF (vlist) >= 3 THEN  v3 := vlist[3];  END_IF;
  IF 'ELEMENTARY_FUNCTION_ENUMERATORS' IN types THEN
    ef_val := expr.func;
    is_elementary := TRUE;
  END_IF;
  IF 'ELEMENTARY_FUNCTION' IN types THEN
    ef_val := expr.func\elementary_function.func_id;
    is_elementary := TRUE;
  END_IF;
  IF is_elementary THEN
    CASE ef_val OF
    ef_and : BEGIN
      cum := TRUE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum AND lgc;
          IF lgc = FALSE THEN  RETURN (ctmv(FALSE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> TRUE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_or : BEGIN
      cum := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'LOGICAL' IN TYPEOF (vlist[i]) THEN
          lgc := vlist[i];  cum := cum OR lgc;
          IF lgc = TRUE THEN  RETURN (ctmv(TRUE));  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(cum));  END_IF;
      IF cum <> FALSE THEN  INSERT (vlist, ctmv(cum), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_not :
      IF 'LOGICAL' IN TYPEOF (v1) THEN  lgc := v1;  RETURN (ctmv(NOT lgc));  END_IF;
    ef_xor : BEGIN
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;
        IF 'LOGICAL' IN TYPEOF (v2) THEN  cum := v2;  RETURN (ctmv(lgc XOR cum));
        ELSE IF lgc = FALSE THEN  RETURN (ctmv(v2));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v2]));
        END_IF;  END_IF;  END_IF;
      ELSE IF 'LOGICAL' IN TYPEOF (v2) THEN
        lgc := v2;
        IF lgc = FALSE THEN  RETURN (ctmv(v1));
        ELSE IF lgc = UNKNOWN THEN  RETURN (ctmv(UNKNOWN));
        ELSE  RETURN (make_function_application(ef_not,[v1]));
        END_IF;  END_IF;
      END_IF;  END_IF;
      END;
    ef_negate_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(-j));  END_IF;
    ef_add_i : BEGIN
      j := 0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j + k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 0 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j - k));
      END_IF;
    ef_multiply_i : BEGIN
      j := 1;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          k := vlist[i];  j := j * k;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF j <> 1 THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j DIV k));
      END_IF;
    ef_mod_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j MOD k));
      END_IF;
    ef_exponentiate_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  n := 1;
        REPEAT i := 1 TO ABS(k);  n := n * j;  END_REPEAT;
        IF k < 0 THEN  n := 1 DIV n;  END_IF;
        RETURN (ctmv(n));
      END_IF;
    ef_eq_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j = k));
      END_IF;
    ef_ne_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <> k));
      END_IF;
    ef_gt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j > k));
      END_IF;
    ef_lt_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j < k));
      END_IF;
    ef_ge_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j >= k));
      END_IF;
    ef_le_i :
      IF ('INTEGER' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        j := v1;  k := v2;  RETURN (ctmv(j <= k));
      END_IF;
    ef_abs_i :
      IF 'INTEGER' IN TYPEOF (v1) THEN  j := v1;  RETURN (ctmv(ABS(j)));  END_IF;
    ef_max_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k > j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_i : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'INTEGER' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  k := vlist[i];  IF k < j THEN  j := k;  END_IF;
          ELSE  j := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(j));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(j), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    -- ef_if_i : combined with ef_if
    ef_negate_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(-r));  END_IF;
    ef_reciprocal_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(1.0/r));  END_IF;
    ef_add_r : BEGIN
      r := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 0.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r - s));
      END_IF;
    ef_multiply_r : BEGIN
      r := 1.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          s := vlist[i];  r := r * s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF r <> 1.0 THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r / s));
      END_IF;
    ef_mod_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  t := r/s;  j := t DIV 1;
        IF (t < 0.0) AND (j <> t) THEN  j := j - 1;  END_IF;
        RETURN (ctmv(r - j * s));
      END_IF;
    ef_exponentiate_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r ** s));
      END_IF;
    ef_exponentiate_ri :
      IF ('REAL' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        r := v1;  k := v2;  t := 1.0;
        REPEAT i := 1 TO ABS(k);  t := t * r;  END_REPEAT;
        IF k < 0 THEN  t := 1.0/t;  END_IF;
        RETURN (ctmv(t));
      END_IF;
    ef_eq_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r = s));
      END_IF;
    ef_ne_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <> s));
      END_IF;
    ef_gt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r > s));
      END_IF;
    ef_lt_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r < s));
      END_IF;
    ef_ge_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r >= s));
      END_IF;
    ef_le_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(r <= s));
      END_IF;
    ef_abs_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ABS(r)));  END_IF;
    ef_max_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s > r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_min_r : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'REAL' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  s := vlist[i];  IF s < r THEN  r := s;  END_IF;
          ELSE  r := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(r));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(r), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_acos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ACOS(r)));  END_IF;
    ef_asin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(ASIN(r)));  END_IF;
    ef_atan2_r :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (ctmv(atan2(r,s)));
      END_IF;
    ef_cos_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(COS(r)));  END_IF;
    ef_exp_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(EXP(r)));  END_IF;
    ef_ln_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG(r)));  END_IF;
    ef_log2_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG2(r)));  END_IF;
    ef_log10_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(LOG10(r)));  END_IF;
    ef_sin_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SIN(r)));  END_IF;
    ef_sqrt_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(SQRT(r)));  END_IF;
    ef_tan_r :
      IF 'REAL' IN TYPEOF (v1) THEN  r := v1;  RETURN (ctmv(TAN(r)));  END_IF;
    -- ef_if_r : combined with ef_if
    ef_form_c :
      IF ('REAL' IN TYPEOF (v1)) AND ('REAL' IN TYPEOF (v2)) THEN
        r := v1;  s := v2;  RETURN (makec(r,s));
      END_IF;
    ef_rpart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.real_part));
      END_IF;
    ef_ipart_c :
      IF cnlit IN TYPEOF (v1) THEN
        RETURN (ctmv(v1\complex_number_literal.imag_part));
      END_IF;
    ef_negate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(-p,-q));  END_IF;
    ef_reciprocal_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := p*p + q*q;  RETURN (makec(p/t,-q/t));
      END_IF;
    ef_add_c : BEGIN
      p := 0.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p + r;  q := q + s;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF p*p+q*q <> 0.0 THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (makec(p-r,q-s));
      END_IF;
    ef_multiply_c : BEGIN
      p := 1.0;  q := 0.0;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF cnlit IN TYPEOF (vlist[i]) THEN
          parts(vlist[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (makec(p,q));  END_IF;
      IF (p <> 1.0) OR (q <> 0.0) THEN  INSERT (vlist, makec(p,q), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_divide_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := r*r+s*s;
        RETURN (makec((p*r+q*s)/t,(q*r-p*s)/t));
      END_IF;
    ef_exponentiate_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  t := 0.5*LOG(p*p+q*q);  u := atan2(q,p);
        p := r*t-s*u;  q := r*u+s*t;  r := EXP(p);
        RETURN (makec(r*COS(q),r*SIN(q)));
      END_IF;
    ef_exponentiate_ci :
      IF (cnlit IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        parts(v1,p,q);  k := v2;  r := 1.0;  s := 0.0;
        REPEAT i := 1 TO ABS(k);  r := p*r-q*s;  s := p*s+q*r;  END_REPEAT;
        IF k < 0 THEN  t := r*r+s*s;  r := r/t;  s := -s/t;  END_IF;
        RETURN (makec(r,s));
      END_IF;
    ef_eq_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p = r) AND (q = s)));
      END_IF;
    ef_ne_c :
      IF (cnlit IN TYPEOF (v1)) AND (cnlit IN TYPEOF (v2)) THEN
        parts(v1,p,q);  parts(v2,r,s);  RETURN (ctmv((p <> r) OR (q <> s)));
      END_IF;
    ef_conjugate_c :
      IF cnlit IN TYPEOF (v1) THEN  parts(v1,p,q);  RETURN (makec(p,-q));  END_IF;
    ef_abs_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(SQRT(p*p+q*q)));
      END_IF;
    ef_arg_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (ctmv(atan2(q,p)));
      END_IF;
    ef_cos_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*COS(p),(t-u)*SIN(p)));
      END_IF;
    ef_exp_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(EXP(p)*COS(q),EXP(p)*SIN(q)));
      END_IF;
    ef_ln_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  RETURN (makec(0.5*LOG(p*p+q*q),atan2(q,p)));
      END_IF;
    ef_sin_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := 0.5*EXP(-q);  u := 0.5*EXP(q);
        RETURN (makec((t+u)*SIN(p),(u-t)*COS(p)));
      END_IF;
    ef_sqrt_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := SQRT(SQRT(p*p+q*q));  u := 0.5*atan2(q,p);
        RETURN (makec(t*COS(u),t*SIN(u)));
      END_IF;
    ef_tan_c :
      IF cnlit IN TYPEOF (v1) THEN
        parts(v1,p,q);  t := EXP(2.0*q) + EXP(-2.0*q) + 2.0*COS(2.0*p);
        RETURN (makec(2.0*SIN(2.0*p)/t,(EXP(-2.0*q)-EXP(2.0*q))/t));
      END_IF;
    -- ef_if_c : combined with ef_if
    ef_subscript_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        str := v1;  k := v2;  RETURN (ctmv(str[k]));
      END_IF;
    ef_eq_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str = st2));
      END_IF;
    ef_ne_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <> st2));
      END_IF;
    ef_gt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str > st2));
      END_IF;
    ef_lt_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str < st2));
      END_IF;
    ef_ge_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str >= st2));
      END_IF;
    ef_le_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        str := v1;  st2 := v2;  RETURN (ctmv(str <= st2));
      END_IF;
    ef_subsequence_s :
      IF ('STRING' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        str := v1;  j := v2;  k := v3;  RETURN (ctmv(str[j:k]));
      END_IF;
    ef_concat_s : BEGIN
      str := '';
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          st2 := vlist[i];  str := str + st2;
          REMOVE (vlist, i);
        ELSE IF str <> '' THEN
          INSERT (vlist, ctmv(str), i);
          str := '';
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(str));  END_IF;
      IF str <> '' THEN  INSERT (vlist, ctmv(str), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_s :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(LENGTH(str)));  END_IF;
    ef_format :
      IF ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(FORMAT(v1,v2)));
      END_IF;
    ef_value :
      IF 'STRING' IN TYPEOF (v1) THEN  str:=v1;  RETURN (ctmv(VALUE(str)));  END_IF;
    ef_like :
      IF ('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
        RETURN (ctmv(v1 LIKE v2));
      END_IF;
    -- ef_if_s : combined with ef_if
    ef_subscript_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        bin := v1;  k := v2;  RETURN (ctmv(bin[k]));
      END_IF;
    ef_eq_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin = bi2));
      END_IF;
    ef_ne_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <> bi2));
      END_IF;
    ef_gt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin > bi2));
      END_IF;
    ef_lt_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin < bi2));
      END_IF;
    ef_ge_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin >= bi2));
      END_IF;
    ef_le_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('BINARY' IN TYPEOF (v2)) THEN
        bin := v1;  bi2 := v2;  RETURN (ctmv(bin <= bi2));
      END_IF;
    ef_subsequence_b :
      IF ('BINARY' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) AND
        ('INTEGER' IN TYPEOF (v3)) THEN
        bin := v1;  j := v2;  k := v3;  RETURN (ctmv(bin[j:k]));
      END_IF;
    ef_concat_b : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'BINARY' IN TYPEOF (vlist[i]) THEN
          IF boo THEN  bi2 := vlist[i];  bin := bin + bi2;
          ELSE         bin := vlist[i];  boo := TRUE;  END_IF;
          REMOVE (vlist, i);
        ELSE IF boo THEN
          INSERT (vlist, ctmv(bin), i);
          boo := FALSE;
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(bin));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(bin), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_b :
      IF 'BINARY' IN TYPEOF (v1) THEN  bin:=v1;  RETURN (ctmv(BLENGTH(bin)));  END_IF;
    -- ef_if_b : combined with ef_if
    ef_subscript_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  RETURN (ctmv(tpl[k]));
      END_IF;
    ef_eq_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    ef_ne_t :
      IF ('LIST' IN TYPEOF (v1)) AND ('LIST' IN TYPEOF (v2)) THEN
        lgc := equal_maths_values(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(NOT lgc));  END_IF;
      END_IF;
    ef_concat_t : BEGIN
      tpl := [];
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF 'STRING' IN TYPEOF (vlist[i]) THEN
          tp2 := vlist[i];  tpl := tpl + tp2;
          REMOVE (vlist, i);
        ELSE IF SIZEOF (tpl) <> 0 THEN
          INSERT (vlist, ctmv(tpl), i);
          tpl := [];
        END_IF;  END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF SIZEOF (tpl) <> 0 THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_size_t :
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(SIZEOF(tpl)));  END_IF;
    ef_entuple :
      RETURN (ctmv(vlist));
    ef_detuple :  -- This can have multiple outputs, but the expression only
                  -- denotes the first.
      IF 'LIST' IN TYPEOF (v1) THEN  tpl:=v1;  RETURN (ctmv(tpl[1]));  END_IF;
    ef_insert :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v3)) THEN
        tpl := v1;  k := v3;  INSERT (tpl, v2, k);  RETURN (ctmv(tpl));
      END_IF;
    ef_remove :
      IF ('LIST' IN TYPEOF (v1)) AND ('INTEGER' IN TYPEOF (v2)) THEN
        tpl := v1;  k := v2;  REMOVE (tpl, k);  RETURN (ctmv(tpl));
      END_IF;
    -- ef_if_t : combined with ef_if
    ef_sum_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 0;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_product_it :
      IF good_t(v1,'INTEGER') THEN
        tpl := v1;  j := 1;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_add_it : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'INTEGER') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_it :
      IF ('INTEGER' IN TYPEOF (v1)) AND good_t(v2,'INTEGER') THEN
        j := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := j * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_it :
      IF good_t(v1,'INTEGER') AND good_t(v2,'INTEGER') THEN
        tpl := v1;  tp2 := v2;  j := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  j := j + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(j));
      END_IF;
    ef_sum_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_product_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 1.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_add_rt : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],'REAL') THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);  tpl[j] := tpl[j] + tp2[j];  END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := tpl[i] - tp2[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_rt :
      IF ('REAL' IN TYPEOF (v1)) AND good_t(v2,'REAL') THEN
        r := v1;  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);  tpl[i] := r * tpl[i];  END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_rt :
      IF good_t(v1,'REAL') AND good_t(v2,'REAL') THEN
        tpl := v1;  tp2 := v2;  r := 0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i] * tp2[i];  END_REPEAT;
        RETURN (ctmv(r));
      END_IF;
    ef_norm_rt :
      IF good_t(v1,'REAL') THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  r := r + tpl[i]*tpl[i];  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_sum_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 0.0;  q := 0.0;
        REPEAT i:=1 TO SIZEOF (tpl);  parts(tpl[i],r,s);  p:=p+r;  q:=q+s;  END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_product_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  p := 1.0;  q := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  p := p*r-q*s;  q := p*s+q*r;
        END_REPEAT;
        RETURN (makec(p,q));
      END_IF;
    ef_add_ct : BEGIN
      boo := FALSE;
      REPEAT i := SIZEOF (vlist) TO 1 BY -1;
        IF good_t(vlist[i],cnlit) THEN
          IF NOT boo THEN  tpl := vlist[i];  boo := TRUE;
          ELSE
            tp2 := vlist[i];
            IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
            REPEAT l := 1 TO SIZEOF (tpl);
              parts(tpl[j],p,q); parts(tp2[j],r,s);  tpl[j] := makec(p+r,q+s);
            END_REPEAT;
          END_IF;
          REMOVE (vlist, i);
        END_IF;
      END_REPEAT;
      IF SIZEOF (vlist) = 0 THEN  RETURN (ctmv(tpl));  END_IF;
      IF boo THEN  INSERT (vlist, ctmv(tpl), 0);  END_IF;
      IF SIZEOF (vlist) = 1 THEN  RETURN (vlist[1]);  END_IF;
      END;
    ef_subtract_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  tpl[i] := makec(p-r,q-s);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_scalar_mult_ct :
      IF (cnlit IN TYPEOF (v1)) AND good_t(v2,cnlit) THEN
        parts(v1,p,q);  tpl := v2;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],r,s);  tpl[i] := makec(p*r-q*s,p*s+q*r);
        END_REPEAT;
        RETURN (ctmv(tpl));
      END_IF;
    ef_dot_prod_ct :
      IF good_t(v1,cnlit) AND good_t(v2,cnlit) THEN
        tpl := v1;  tp2 := v2;  t := 0.0;  u := 0.0;
        IF SIZEOF (tpl) <> SIZEOF (tp2) THEN  RETURN (?);  END_IF;
        REPEAT i := 1 TO SIZEOF (tpl);
          parts(tpl[i],p,q);  parts(tp2[i],r,s);  t := t + p*r+q*s;  u := u + q*r-p*s;
        END_REPEAT;
        RETURN (makec(t,u));
      END_IF;
    ef_norm_ct :
      IF good_t(v1,cnlit) THEN
        tpl := v1;  r := 0.0;
        REPEAT i := 1 TO SIZEOF (tpl);  parts(tpl[i],p,q);  r:=r+p*p+q*q;  END_REPEAT;
        RETURN (ctmv(SQRT(r)));
      END_IF;
    ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t :
      IF 'LOGICAL' IN TYPEOF (v1) THEN
        lgc := v1;  IF lgc THEN  RETURN (v2);  ELSE  RETURN (v3);  END_IF;
      END_IF;
    ef_ensemble :   -- (mem + vlist) effectively converts list to set
      RETURN (make_finite_space(mem + vlist));
    ef_member_of :
      IF (schema_prefix + 'MATHS_SPACE') IN TYPEOF (v2) THEN
        lgc := member_of(v1,v2);
        IF lgc <> UNKNOWN THEN  RETURN (ctmv(lgc));  END_IF;
      END_IF;
    END_CASE;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  IF 'ABSTRACTED_EXPRESSION_FUNCTION' IN types THEN
    gexpr := substitute(expr.func\abstracted_expression_function.expr,
      expr.func\quantifier_expression.variables,vlist);
    RETURN (simplify_generic_expression(gexpr));
  END_IF;
  IF 'FINITE_FUNCTION' IN types THEN
    pairs := expr.func\finite_function.pairs;
    REPEAT i := 1 TO SIZEOF (pairs);
      IF equal_maths_values(vlist[1],pairs[i][1]) THEN
        RETURN (simplify_maths_value(pairs[i][2]));
      END_IF;
    END_REPEAT;
    RETURN (make_function_application(expr.func,vlist));
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- simplify_function_application
FUNCTION simplify_generic_expression(expr : generic_expression) : maths_value;
  FUNCTION restore_unary(expr : unary_generic_expression;
                         opnd : generic_expression) : generic_expression;
    expr.operand := opnd;
    RETURN (expr);
  END_FUNCTION;  -- restore_unary
  FUNCTION restore_binary(expr       : binary_generic_expression;
                          opd1, opd2 : generic_expression) : generic_expression;
    expr.operands[1] := opd1;
    expr.operands[2] := opd2;
    RETURN (expr);
  END_FUNCTION;  -- restore_binary
  FUNCTION restore_mulary(expr : multiple_arity_generic_expression;
                          ops  : LIST OF generic_expression) : generic_expression;
    expr.operands := ops;
    RETURN (expr);
  END_FUNCTION;  -- restore_mulary
  FUNCTION make_number_literal(nmb : NUMBER) : generic_literal;
    IF 'INTEGER' IN TYPEOF (nmb) THEN  RETURN (make_int_literal(nmb));  END_IF;
    RETURN (make_real_literal(nmb));
  END_FUNCTION;  -- make_number_literal;
  LOCAL
    types : SET OF STRING := stripped_typeof (expr);
    v1, v2 : maths_value;
    vlist : LIST OF maths_value := [];
    op1, op2 : generic_expression;
    oplist : LIST OF generic_expression := [];
    opnds : LIST [2:?] OF generic_expression;
    n, m : INTEGER;
    finfun : maths_function_select;
    boo : BOOLEAN;
    str : STRING;
    nmb : NUMBER;
  END_LOCAL;
  -- Unwrap the elementary kinds of literals
  IF 'INT_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\int_literal.the_value));
  END_IF;
  IF 'REAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_literal.the_value));
  END_IF;
  IF 'BOOLEAN_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\boolean_literal.the_value));
  END_IF;
  IF 'STRING_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\string_literal.the_value));
  END_IF;
  IF 'COMPLEX_NUMBER_LITERAL' IN types THEN
    RETURN (expr);  -- No simpler expression available
  END_IF;
  IF 'LOGICAL_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\logical_literal.lit_value));
  END_IF;
  IF 'BINARY_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\binary_literal.lit_value));
  END_IF;
  IF 'MATHS_ENUM_LITERAL' IN types THEN
    RETURN (expr\maths_enum_literal.lit_value);
  END_IF;
  IF 'REAL_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\real_tuple_literal.lit_value));
  END_IF;
  IF 'INTEGER_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\integer_tuple_literal.lit_value));
  END_IF;
  IF 'ATOM_BASED_LITERAL' IN types THEN
    RETURN (expr\atom_based_literal.lit_value);
  END_IF;
  IF 'MATHS_TUPLE_LITERAL' IN types THEN
    RETURN (convert_to_maths_value (expr\maths_tuple_literal.lit_value));
  END_IF;
  -- Simplify one special class of literals
  IF 'MATHS_SPACE' IN types THEN
    RETURN (simplify_maths_space(expr));
  END_IF;
  -- Simplify one special kind of expression
  IF 'FUNCTION_APPLICATION' IN types THEN
    RETURN (simplify_function_application(expr));
  END_IF;
  -- Separate and simplify the operands
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\unary_generic_expression.operand);
    op1 := convert_to_operand(v1);
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    v1 := simplify_generic_expression(expr\binary_generic_expression.operands[1]);
    op1 := convert_to_operand(v1);
    v2 := simplify_generic_expression(expr\binary_generic_expression.operands[2]);
    op2 := convert_to_operand(v2);
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      v1 := simplify_generic_expression(opnds[i]);
      INSERT (vlist, v1, i-1);
      INSERT (oplist, convert_to_operand(v1), i-1);
    END_REPEAT;
  END_IF;
  -- Simplify the one kind of maths_function which derives its operands.
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    v1 := vlist[1];
    n := SIZEOF (vlist);
    finfun := vlist[n];
    REMOVE (vlist, n);
    REMOVE (vlist, 1);
    RETURN (make_parallel_composed_function(v1,vlist,finfun));
  END_IF;
  -- Simplify individual kinds of expressions.  It is not necessary to cover all cases.
  IF ('ABS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ABS(v1)));
  END_IF;
  IF ('ACOS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ACOS(v1)));
  END_IF;
  IF 'AND_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF NOT boo THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('ASIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ASIN(v1)));
  END_IF;
  IF ('ATAN_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (ATAN(v1,v2)));
  END_IF;
  IF ('COMPARISON_EXPRESSION' IN types) AND (
    (('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2))) OR
    (('STRING' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2))) OR
    (('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2))) ) THEN
    IF      'COMPARISON_EQUAL'         IN types THEN  boo := bool(v1 = v2);
    ELSE IF 'COMPARISON_GREATER'       IN types THEN  boo := bool(v1 > v2);
    ELSE IF 'COMPARISON_GREATER_EQUAL' IN types THEN  boo := bool(v1 >= v2);
    ELSE IF 'COMPARISON_LESS'          IN types THEN  boo := bool(v1 < v2);
    ELSE IF 'COMPARISON_LESS_EQUAL'    IN types THEN  boo := bool(v1 <= v2);
    ELSE IF 'COMPARISON_NOT_EQUAL'     IN types THEN  boo := bool(v1 <> v2);
    ELSE IF 'LIKE_EXPRESSION'          IN types THEN  boo := bool(v1 LIKE v2);
    ELSE  RETURN (?);  -- Unreachable
    END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;  END_IF;
    RETURN (convert_to_maths_value (boo));
  END_IF;
  IF 'CONCAT_EXPRESSION' IN types THEN
    str := '';
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'STRING' IN TYPEOF (vlist[i]) THEN
        str := vlist[i] + str;
        REMOVE (oplist, i);
      ELSE IF LENGTH(str) > 0 THEN
        INSERT (oplist, make_string_literal(str), i);
        str := '';
      END_IF;  END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(str));  END_IF;
    IF LENGTH(str) > 0 THEN  INSERT (oplist, make_string_literal(str), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('COS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (COS(v1)));
  END_IF;
  IF ('DIV_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 DIV v2));
  END_IF;
  IF 'EQUALS_EXPRESSION' IN types THEN
    opnds := expr\binary_generic_expression.operands;
    RETURN (convert_to_maths_value (opnds[1] :=: opnds[2]));
  END_IF;
  IF ('EXP_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (EXP(v1)));
  END_IF;
  IF ('FORMAT_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('STRING' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (FORMAT(v1,v2)));
  END_IF;
  IF ('INDEX_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    str := v1;  n := v2;
    RETURN (convert_to_maths_value (str[n]));
  END_IF;
  IF ('INT_VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF 'INTERVAL_EXPRESSION' IN types THEN
    str := '';
    IF 'NUMBER'  IN TYPEOF (vlist[1]) THEN str := 'NUMBER';   END_IF;
    IF 'STRING'  IN TYPEOF (vlist[1]) THEN str := 'STRING';   END_IF;
    IF 'BOOLEAN' IN TYPEOF (vlist[1]) THEN str := 'BOOLEAN';  END_IF;
    IF (LENGTH (str) > 0) AND (str IN TYPEOF (vlist[2])) AND
      (str IN TYPEOF (vlist[3])) THEN
      RETURN (convert_to_maths_value ({vlist[1] <= vlist[2] <= vlist[3]}));
    END_IF;
  END_IF;
  IF ('LENGTH_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LENGTH(v1)));
  END_IF;
  IF ('LOG_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG(v1)));
  END_IF;
  IF ('LOG10_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG10(v1)));
  END_IF;
  IF ('LOG2_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (LOG2(v1)));
  END_IF;
  IF 'MAXIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb < vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF 'MINIMUM_EXPRESSION' IN types THEN
    boo := FALSE;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        IF boo THEN
          IF nmb > vlist[i] THEN  nmb := vlist[i];  END_IF;
        ELSE
          nmb := vlist[i];  boo := TRUE;
        END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF boo THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
  END_IF;
  IF ('MINUS_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 - v2));
  END_IF;
  IF ('MOD_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 MOD v2));
  END_IF;
  IF 'MULT_EXPRESSION' IN types THEN
    nmb := 1;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb * vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 1 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('NOT_EXPRESSION' IN types) AND ('BOOLEAN' IN TYPEOF (v1)) THEN
    boo := v1;
    RETURN (convert_to_maths_value (NOT(boo)));
  END_IF;
  IF ('ODD_EXPRESSION' IN types) AND ('INTEGER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (ODD(v1)));
  END_IF;
  IF 'OR_EXPRESSION' IN types THEN
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'BOOLEAN' IN TYPEOF (vlist[i]) THEN
        boo := vlist[i];
        IF boo THEN  RETURN (convert_to_maths_value(TRUE));  END_IF;
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(FALSE));  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF 'PLUS_EXPRESSION' IN types THEN
    nmb := 0;
    REPEAT i := SIZEOF (vlist) TO 1 BY -1;
      IF 'NUMBER' IN TYPEOF (vlist[i]) THEN
        nmb := nmb + vlist[i];
        REMOVE (oplist, i);
      END_IF;
    END_REPEAT;
    IF SIZEOF (oplist) = 0 THEN  RETURN (convert_to_maths_value(nmb));  END_IF;
    IF nmb <> 0 THEN  INSERT (oplist, make_number_literal(nmb), 0);  END_IF;
    IF SIZEOF (oplist) = 1 THEN  RETURN (oplist[1]);  END_IF;
  END_IF;
  IF ('POWER_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 ** v2));
  END_IF;
  IF ('SIN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SIN(v1)));
  END_IF;
  IF ('SLASH_EXPRESSION' IN types) AND
    ('NUMBER' IN TYPEOF (v1)) AND ('NUMBER' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 / v2));
  END_IF;
  IF ('SQUARE_ROOT_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (SQRT(v1)));
  END_IF;
  IF ('SUBSTRING_EXPRESSION' IN types) AND
    ('STRING' IN TYPEOF (vlist[1])) AND ('NUMBER' IN TYPEOF (vlist[2])) AND
    ('NUMBER' IN TYPEOF (vlist[3])) THEN
    str := vlist[1];  n := vlist[2];  m := vlist[3];
    RETURN (convert_to_maths_value (str[n:m]));
  END_IF;
  IF ('TAN_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (TAN(v1)));
  END_IF;
  IF ('UNARY_MINUS_EXPRESSION' IN types) AND ('NUMBER' IN TYPEOF (v1)) THEN
    nmb := v1;
    RETURN (convert_to_maths_value (-nmb));
  END_IF;
  IF ('VALUE_EXPRESSION' IN types) AND ('STRING' IN TYPEOF (v1)) THEN
    RETURN (convert_to_maths_value (VALUE(v1)));
  END_IF;
  IF ('XOR_EXPRESSION' IN types) AND
    ('BOOLEAN' IN TYPEOF (v1)) AND ('BOOLEAN' IN TYPEOF (v2)) THEN
    RETURN (convert_to_maths_value (v1 XOR v2));
  END_IF;
  -- No special simplification defined, return same with simplified operands.
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_unary(expr,op1));
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_binary(expr,op1,op2));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    RETURN (restore_mulary(expr,oplist));
  END_IF;
  -- Should be unreachable, but for safety, return unsimplified expression.
  RETURN (expr);
END_FUNCTION;  -- simplify_generic_expression
FUNCTION simplify_maths_space(spc : maths_space) : maths_space;
  LOCAL
    stypes : SET OF STRING := stripped_typeof (spc);
    sset : SET OF maths_value;
    zset : SET OF maths_value := [];
    zval : maths_value;
    zspc : maths_space;
    zallint : BOOLEAN := TRUE;
    zint, zmin, zmax : INTEGER;
    factors : LIST OF maths_space;
    zfactors : LIST OF maths_space := [];
    rspc : maths_space;
  END_LOCAL;
  IF 'FINITE_SPACE' IN stypes THEN
    sset := spc\finite_space.members;
    REPEAT i := 1 TO SIZEOF (sset);
      zval := simplify_maths_value(sset[i]);
      zset := zset + [zval];
      IF zallint AND ('INTEGER' IN TYPEOF (zval)) THEN
        zint := zval;
        IF i = 1 THEN
          zmin := zint;
          zmax := zint;
        ELSE
          IF zint < zmin THEN
            zmin := zint;
          END_IF;
          IF zint > zmax THEN
            zmax := zint;
          END_IF;
        END_IF;
      ELSE
        zallint := FALSE;
      END_IF;
    END_REPEAT;
    IF zallint AND (SIZEOF(zset) = zmax-zmin+1) THEN
      RETURN (make_finite_integer_interval(zmin,zmax));
    END_IF;
    RETURN (make_finite_space(zset));
  END_IF;
  IF 'UNIFORM_PRODUCT_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\uniform_product_space.base);
    RETURN (make_uniform_product_space(zspc,spc\uniform_product_space.exponent));
  END_IF;
  IF 'LISTED_PRODUCT_SPACE' IN stypes THEN
    factors := spc\listed_product_space.factors;
    REPEAT i := 1 TO SIZEOF (factors);
      INSERT (zfactors, simplify_maths_space(factors[i]), i-1);
    END_REPEAT;
    RETURN (make_listed_product_space(zfactors));
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\extended_tuple_space.base);
    rspc := simplify_maths_space(spc\extended_tuple_space.extender);
    RETURN (make_extended_tuple_space(zspc,rspc));
  END_IF;
  IF 'FUNCTION_SPACE' IN stypes THEN
    zspc := simplify_maths_space(spc\function_space.domain_argument);
    rspc := simplify_maths_space(spc\function_space.range_argument);
    RETURN (make_function_space(spc\function_space.domain_constraint,zspc,
      spc\function_space.range_constraint,rspc));
  END_IF;
  RETURN (spc);
END_FUNCTION;  -- simplify_maths_space
FUNCTION simplify_maths_value(val : maths_value) : maths_value;
  LOCAL
    vtypes : SET OF STRING := stripped_typeof(val);
    vlist : LIST OF maths_value;
    nlist : LIST OF maths_value := [];
  END_LOCAL;
  IF 'GENERIC_EXPRESSION' IN vtypes THEN
    RETURN (simplify_generic_expression(val));
  END_IF;
  IF 'LIST' IN vtypes THEN
    vlist := val;
    REPEAT i := 1 TO SIZEOF (vlist);
      INSERT (nlist, simplify_maths_value(vlist[i]), i-1);
    END_REPEAT;
    RETURN (convert_to_maths_value(nlist));
  END_IF;
  RETURN (val);
END_FUNCTION;  -- simplify_maths_value
FUNCTION singleton_member_of(spc : maths_space) : maths_value;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    IF SIZEOF (spc\finite_space.members) = 1 THEN
      RETURN (spc\finite_space.members[1]);
    END_IF;
    RETURN (?);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    IF spc\finite_integer_interval.size = 1 THEN
      RETURN (spc\finite_integer_interval.min);
    END_IF;
    RETURN (?);
  END_IF;
  RETURN (?);
END_FUNCTION;  -- singleton_member_of
FUNCTION space_dimension(tspace : tuple_space) : nonnegative_integer;
  LOCAL
    types : SET OF STRING := TYPEOF (tspace);
  END_LOCAL;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN types THEN
    RETURN (tspace\uniform_product_space.exponent);
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN types THEN
    RETURN (SIZEOF (tspace\listed_product_space.factors));
  END_IF;
  IF (schema_prefix + 'EXTENDED_TUPLE_SPACE') IN types THEN
    -- In the case of an extended_tuple_space, the minimum dimension is returned.
    RETURN (space_dimension (tspace\extended_tuple_space.base));
  END_IF;
  -- Should be unreachable
  RETURN (?);
END_FUNCTION;  -- space_dimension
FUNCTION space_is_continuum(space : maths_space) : BOOLEAN;
  LOCAL
    typenames : SET OF STRING := TYPEOF (space);
    factors : LIST OF maths_space;
  END_LOCAL;
  IF NOT EXISTS (space) THEN
    RETURN (FALSE);
  END_IF;
  IF subspace_of_es(space,es_reals) OR subspace_of_es(space,es_complex_numbers) THEN
    RETURN (TRUE);
  END_IF;
  IF (schema_prefix + 'UNIFORM_PRODUCT_SPACE') IN typenames THEN
    RETURN (space_is_continuum(space\uniform_product_space.base));
  END_IF;
  IF (schema_prefix + 'LISTED_PRODUCT_SPACE') IN typenames THEN
    factors := space\listed_product_space.factors;
    IF SIZEOF(factors) = 0 THEN
      RETURN (FALSE);
    END_IF;
    REPEAT i := 1 TO SIZEOF (factors);
      IF NOT space_is_continuum(factors[i]) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_continuum
FUNCTION space_is_singleton(spc : maths_space) : BOOLEAN;
  LOCAL
    types : SET OF STRING := stripped_typeof (spc);
  END_LOCAL;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (bool(SIZEOF (spc\finite_space.members) = 1));
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types THEN
    RETURN (bool(spc\finite_integer_interval.size = 1));
  END_IF;
  RETURN (FALSE);
END_FUNCTION;  -- space_is_singleton
FUNCTION stripped_typeof(arg : GENERIC:G) : SET OF STRING;
  LOCAL
    types : SET OF STRING := TYPEOF (arg);
    stypes : SET OF STRING := [];
    n : INTEGER := LENGTH (schema_prefix);
  END_LOCAL;
  REPEAT i := 1 TO SIZEOF (types);
    IF types[i][1:n] = schema_prefix THEN
       stypes := stypes + types[i][n+1:LENGTH(types[i])];
    ELSE
       stypes := stypes + types[i];
    END_IF;
  END_REPEAT;
  RETURN (stypes);
END_FUNCTION;  -- stripped_typeof
FUNCTION subspace_of(space1, space2 : maths_space) : LOGICAL;
  LOCAL
    spc1 : maths_space := simplify_maths_space(space1);
    spc2 : maths_space := simplify_maths_space(space2);
    types1 : SET OF STRING := stripped_typeof (spc1);
    types2 : SET OF STRING := stripped_typeof (spc2);
    lgcl, cum : LOGICAL;
    es_val : elementary_space_enumerators;
    bnd1, bnd2 : REAL;
    n : INTEGER;
    sp1, sp2 : maths_space;
    prgn1, prgn2 : polar_complex_number_region;
    aitv : finite_real_interval;
  END_LOCAL;
  IF NOT EXISTS (spc1) OR NOT EXISTS (spc2) THEN
    RETURN (FALSE);
  END_IF;
  IF spc2 = the_generics THEN
    RETURN (TRUE);
  END_IF;
  IF 'ELEMENTARY_SPACE' IN types1 THEN
    IF NOT ('ELEMENTARY_SPACE' IN types2) THEN
      RETURN (FALSE);
    END_IF;
    es_val := spc2\elementary_space.space_id;
    IF spc1\elementary_space.space_id = es_val THEN
      RETURN (TRUE);
    END_IF;
    -- Note that the cases (spc2=the_generics) and (spc1=spc2) have been handled.
    CASE spc1\elementary_space.space_id OF
    es_numbers :  RETURN (FALSE);
    es_complex_numbers :  RETURN (es_val = es_numbers);
    es_reals :  RETURN (es_val = es_numbers);
    es_integers :  RETURN (es_val = es_numbers);
    es_logicals :  RETURN (FALSE);
    es_booleans :  RETURN (es_val = es_logicals);
    es_strings :  RETURN (FALSE);
    es_binarys :  RETURN (FALSE);
    es_maths_spaces :  RETURN (FALSE);
    es_maths_functions :  RETURN (FALSE);
    es_generics :  RETURN (FALSE);
    END_CASE;
    -- Should be unreachable.
    RETURN (UNKNOWN);
  END_IF;
  IF 'FINITE_INTEGER_INTERVAL' IN types1 THEN
    cum := TRUE;
    REPEAT i := spc1\finite_integer_interval.min TO spc1\finite_integer_interval.max;
      cum := cum AND member_of (i, spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'INTEGER_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_FROM_MIN' IN types2 THEN
      RETURN (spc1\integer_interval_from_min.min>=spc2\integer_interval_from_min.min);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'INTEGER_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_integers));
    END_IF;
    IF 'INTEGER_INTERVAL_TO_MAX' IN types2 THEN
      RETURN (spc1\integer_interval_to_max.max <= spc2\integer_interval_to_max.max);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_REAL_INTERVAL' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF ('FINITE_REAL_INTERVAL' IN types2) OR
      ('REAL_INTERVAL_FROM_MIN' IN types2) OR
      ('REAL_INTERVAL_TO_MAX' IN types2) THEN
      IF min_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.min;
        bnd2 := real_min (spc2);
        IF (bnd1 < bnd2) OR ((bnd1 = bnd2) AND min_included (spc1) AND NOT
          min_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      IF max_exists (spc2) THEN
        bnd1 := spc1\finite_real_interval.max;
        bnd2 := real_max (spc2);
        IF (bnd1 > bnd2) OR ((bnd1 = bnd2) AND max_included (spc1) AND NOT
          max_included (spc2)) THEN
          RETURN (FALSE);
        END_IF;
      END_IF;
      RETURN (TRUE);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_FROM_MIN' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_FROM_MIN' IN types2 THEN
      bnd1 := spc1\real_interval_from_min.min;
      bnd2 := spc2\real_interval_from_min.min;
      RETURN ((bnd2 < bnd1) OR ((bnd2 = bnd1) AND (min_included (spc2) OR
        NOT min_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'REAL_INTERVAL_TO_MAX' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_reals));
    END_IF;
    IF 'REAL_INTERVAL_TO_MAX' IN types2 THEN
      bnd1 := spc1\real_interval_to_max.max;
      bnd2 := spc2\real_interval_to_max.max;
      RETURN ((bnd2 > bnd1) OR ((bnd2 = bnd1) AND (max_included (spc2) OR
        NOT max_included (spc1))));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(spc1\cartesian_complex_number_region.real_constraint,
        spc2\cartesian_complex_number_region.real_constraint) AND
        subspace_of(spc1\cartesian_complex_number_region.imag_constraint,
        spc2\cartesian_complex_number_region.imag_constraint));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_cregion_in_pregion(spc1,
        spc2\polar_complex_number_region.centre),spc2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'POLAR_COMPLEX_NUMBER_REGION' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      es_val := spc2\elementary_space.space_id;
      RETURN ((es_val = es_numbers) OR (es_val = es_complex_numbers));
    END_IF;
    IF 'CARTESIAN_COMPLEX_NUMBER_REGION' IN types2 THEN
      RETURN (subspace_of(enclose_pregion_in_cregion(spc1),spc2));
    END_IF;
    IF 'POLAR_COMPLEX_NUMBER_REGION' IN types2 THEN
      prgn1 := spc1;
      prgn2 := spc2;
      IF prgn1.centre = prgn2.centre THEN
        IF prgn2.direction_constraint.max > PI THEN
          aitv := make_finite_real_interval(-PI,open,prgn2.direction_constraint.max
            -2.0*PI,prgn2.direction_constraint.max_closure);
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND (subspace_of(prgn1.direction_constraint,prgn2.direction_constraint)
              OR subspace_of(prgn1.direction_constraint,aitv)));
        ELSE
          RETURN (subspace_of(prgn1.distance_constraint,prgn2.distance_constraint)
            AND subspace_of(prgn1.direction_constraint,prgn2.direction_constraint));
        END_IF;
      END_IF;
      RETURN (subspace_of(enclose_pregion_in_pregion(prgn1,prgn2.centre),prgn2));
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FINITE_SPACE' IN types1 THEN
    cum := TRUE;
    REPEAT i := 1 TO SIZEOF (spc1\finite_space.members);
      cum := cum AND member_of (spc1\finite_space.members[i], spc2);
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (cum);
  END_IF;
  IF 'PRODUCT_SPACE' IN types1 THEN
    IF 'PRODUCT_SPACE' IN types2 THEN
      IF space_dimension (spc1) = space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      IF space_dimension (spc1) >= space_dimension (spc2) THEN
        cum := TRUE;
        REPEAT i := 1 TO space_dimension (spc1);
          cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
          IF cum = FALSE THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
        RETURN (cum);
      END_IF;
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'EXTENDED_TUPLE_SPACE' IN types1 THEN
    IF 'EXTENDED_TUPLE_SPACE' IN types2 THEN
      n := space_dimension (spc1);
      IF n < space_dimension (spc2) THEN
        n := space_dimension (spc2);
      END_IF;
      cum := TRUE;
      REPEAT i := 1 TO n+1;
        cum := cum AND subspace_of (factor_space(spc1,i), factor_space(spc2,i));
        IF cum = FALSE THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  IF 'FUNCTION_SPACE' IN types1 THEN
    IF 'ELEMENTARY_SPACE' IN types2 THEN
      RETURN (spc2\elementary_space.space_id = es_maths_functions);
    END_IF;
    IF 'FUNCTION_SPACE' IN types2 THEN
      cum := TRUE;
      sp1 := spc1\function_space.domain_argument;
      sp2 := spc2\function_space.domain_argument;
      CASE spc1\function_space.domain_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND (subspace_of (sp1, sp2));
        END_CASE;
        END;
      END_CASE;
      IF cum = FALSE THEN
        RETURN (FALSE);
      END_IF;
      sp1 := spc1\function_space.range_argument;
      sp2 := spc2\function_space.range_argument;
      CASE spc1\function_space.range_constraint OF
      sc_equal : BEGIN
        CASE spc2\function_space.range_constraint OF
        sc_equal : cum := cum AND equal_maths_spaces (sp1, sp2);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : cum := cum AND member_of (sp1, sp2);
        END_CASE;
        END;
      sc_subspace : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : RETURN (FALSE);
        sc_subspace : cum := cum AND subspace_of (sp1, sp2);
        sc_member : BEGIN
          IF NOT member_of (sp1, sp2) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        END_CASE;
        END;
      sc_member : BEGIN
        CASE spc2\function_space.domain_constraint OF
        sc_equal : cum := cum AND space_is_singleton(sp1) AND
          equal_maths_spaces(singleton_member_of(sp1),sp2);
        sc_subspace : BEGIN
          IF NOT member_of (sp2, sp1) THEN
            RETURN (FALSE);
          END_IF;
          cum := UNKNOWN;
          END;
        sc_member : cum := cum AND subspace_of (sp1, sp2);
        END_CASE;
        END;
      END_CASE;
      RETURN (cum);
    END_IF;
    RETURN (FALSE);
  END_IF;
  -- Should be unreachable
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of
FUNCTION subspace_of_es(spc : maths_space;
                        es  : elementary_space_enumerators) : LOGICAL;
  LOCAL
    types : SET OF STRING := stripped_typeof(spc);
  END_LOCAL;
  IF NOT EXISTS (spc) OR NOT EXISTS (es) THEN  RETURN (FALSE);  END_IF;
  IF 'ELEMENTARY_SPACE' IN types THEN
    RETURN (es_subspace_of_es(spc\elementary_space.space_id,es));
  END_IF;
  IF 'FINITE_SPACE' IN types THEN
    RETURN (all_members_of_es(spc\finite_space.members,es));
  END_IF;
  CASE es OF
  es_numbers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) OR
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) OR
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_complex_numbers : RETURN (
    ('CARTESIAN_COMPLEX_NUMBER_REGION' IN types) OR
    ('POLAR_COMPLEX_NUMBER_REGION' IN types) );
  es_reals : RETURN (
    ('FINITE_REAL_INTERVAL' IN types) OR
    ('REAL_INTERVAL_FROM_MIN' IN types) OR
    ('REAL_INTERVAL_TO_MAX' IN types) );
  es_integers : RETURN (
    ('FINITE_INTEGER_INTERVAL' IN types) OR
    ('INTEGER_INTERVAL_FROM_MIN' IN types) OR
    ('INTEGER_INTERVAL_TO_MAX' IN types) );
  es_logicals : RETURN (FALSE);
  es_booleans : RETURN (FALSE);
  es_strings : RETURN (FALSE);
  es_binarys : RETURN (FALSE);
  es_maths_spaces : RETURN (FALSE);
  es_maths_functions : RETURN ('FUNCTION_SPACE' IN types);
  es_generics : RETURN (TRUE);
  END_CASE;
  RETURN (UNKNOWN);
END_FUNCTION;  -- subspace_of_es
FUNCTION substitute(expr : generic_expression;
                    vars : LIST [1:?] OF generic_variable;
                    vals : LIST [1:?] OF maths_value) : generic_expression;
  LOCAL
    types : SET OF STRING := stripped_typeof(expr);
    opnds : LIST OF generic_expression;
    op1, op2 : generic_expression;
    qvars : LIST OF generic_variable;
    srcdom : maths_space_or_function;
    prpfun : LIST [1:?] OF maths_function;
    finfun : maths_function_select;
  END_LOCAL;
  IF SIZEOF (vars) <> SIZEOF (vals) THEN  RETURN (?);  END_IF;
  IF 'GENERIC_LITERAL' IN types THEN  RETURN (expr);  END_IF;
  IF 'GENERIC_VARIABLE' IN types THEN
    REPEAT i := 1 TO SIZEOF (vars);
      IF expr :=: vars[i] THEN  RETURN (vals[i]);  END_IF;
    END_REPEAT;
    RETURN (expr);
  END_IF;
  IF 'QUANTIFIER_EXPRESSION' IN types THEN
    qvars := expr\quantifier_expression.variables;
    -- Variables subject to a quantifier do not participate in this kind of
    -- substitution process.
    REPEAT i := SIZEOF (vars) TO 1 BY -1;
      IF vars[i] IN qvars THEN
        REMOVE (vars, i);
        REMOVE (vals, i);
      END_IF;
    END_REPEAT;
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      IF NOT (opnds[i] IN qvars) THEN
        expr\multiple_arity_generic_expression.operands[i] :=
          substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of quantifier_expression
        -- which derive their operands from other attributes!
      END_IF;
    END_REPEAT;
    RETURN (expr);  -- operands modified!
  END_IF;
  IF 'UNARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\unary_generic_expression.operand;
    expr\unary_generic_expression.operand := substitute(op1, vars, vals);
    -- This technique will not work on subtypes of unary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'BINARY_GENERIC_EXPRESSION' IN types THEN
    op1 := expr\binary_generic_expression.operands[1];
    expr\binary_generic_expression.operands[1] := substitute(op1, vars, vals);
    op2 := expr\binary_generic_expression.operands[2];
    expr\binary_generic_expression.operands[2] := substitute(op2, vars, vals);
    -- This technique will not work on subtypes of binary_generic_expression
    -- which derive their operands from other attributes!
  END_IF;
  IF 'PARALLEL_COMPOSED_FUNCTION' IN types THEN
    -- Subtype of multiple_arity_generic_expression which derives its operands.
    srcdom := expr\parallel_composed_function.source_of_domain;
    prpfun := expr\parallel_composed_function.prep_functions;
    finfun := expr\parallel_composed_function.final_function;
    srcdom := substitute(srcdom,vars,vals);
    REPEAT i := 1 TO SIZEOF (prpfun);
      prpfun[i] := substitute(prpfun[i],vars,vals);
    END_REPEAT;
    IF 'MATHS_FUNCTION' IN stripped_typeof(finfun) THEN
      finfun := substitute(finfun,vars,vals);
    END_IF;
    RETURN (make_parallel_composed_function(srcdom,prpfun,finfun));
  END_IF;
  IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN
    opnds := expr\multiple_arity_generic_expression.operands;
    REPEAT i := 1 TO SIZEOF (opnds);
      expr\multiple_arity_generic_expression.operands[i] :=
        substitute(opnds[i],vars,vals);
        -- This technique will not work on subtypes of multiple_arity_generic_
        -- expression which derive their operands from other attributes!
    END_REPEAT;
  END_IF;
  RETURN (expr);
END_FUNCTION;  -- substitute
FUNCTION values_space_of(expr : generic_expression) : maths_space;
  LOCAL
    e_prefix : STRING := 'ISO13584_EXPRESSIONS_SCHEMA.';
    typenames : SET OF STRING := TYPEOF (expr);
  END_LOCAL;
  IF (schema_prefix + 'MATHS_VARIABLE') IN typenames THEN
    RETURN (expr\maths_variable.values_space);
  END_IF;
  IF (e_prefix + 'EXPRESSION') IN typenames THEN
    IF (e_prefix + 'NUMERIC_EXPRESSION') IN typenames THEN
      IF expr\numeric_expression.is_int THEN
        IF (e_prefix + 'INT_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\int_literal.the_value]));
        ELSE
          RETURN (the_integers);
        END_IF;
      ELSE
        IF (e_prefix + 'REAL_LITERAL') IN typenames THEN
          RETURN (make_finite_space ([expr\real_literal.the_value]));
        ELSE
          RETURN (the_reals);
        END_IF;
      END_IF;
    END_IF;
    IF (e_prefix + 'BOOLEAN_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'BOOLEAN_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\boolean_literal.the_value]));
      ELSE
        RETURN (the_booleans);
      END_IF;
    END_IF;
    IF (e_prefix + 'STRING_EXPRESSION') IN typenames THEN
      IF (e_prefix + 'STRING_LITERAL') IN typenames THEN
        RETURN (make_finite_space ([expr\string_literal.the_value]));
      ELSE
        RETURN (the_strings);
      END_IF;
    END_IF;
    RETURN (?);  -- unknown subtype of expression
  END_IF;
  IF (schema_prefix + 'MATHS_FUNCTION') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      RETURN (make_function_space (sc_equal, expr\maths_function.domain,
        sc_equal, expr\maths_function.range));
    END_IF;
  END_IF;
  IF (schema_prefix + 'FUNCTION_APPLICATION') IN typenames THEN
    RETURN (expr\function_application.func.range);
  END_IF;
  IF (schema_prefix + 'MATHS_SPACE') IN typenames THEN
    IF expression_is_constant (expr) THEN
      RETURN (make_finite_space ([expr]));
    ELSE
      -- This case cannot occur in this version of the schema.
      -- When it becomes possible, the subtypes should be analysed and
      -- more finely defined spaces returned.
      RETURN (make_elementary_space (es_maths_spaces));
    END_IF;
  END_IF;
  IF (schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION') IN typenames THEN
    RETURN (values_space_of (expr\unary_generic_expression.operand));
  END_IF;
  IF (schema_prefix + 'COMPLEX_NUMBER_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr]));
  END_IF;
  IF (schema_prefix + 'LOGICAL_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\logical_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'BINARY_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\binary_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_ENUM_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_enum_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'REAL_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\real_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'INTEGER_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\integer_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'ATOM_BASED_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\atom_based_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'MATHS_TUPLE_LITERAL') IN typenames THEN
    RETURN (make_finite_space ([expr\maths_tuple_literal.lit_value]));
  END_IF;
  IF (schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\partial_derivative_expression.derivand)));
  END_IF;
  IF (schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION') IN typenames THEN
    RETURN (drop_numeric_constraints (values_space_of (
      expr\definite_integral_expression.integrand)));
  END_IF;
  RETURN (?);  -- not recognized as a mathematical expression
END_FUNCTION;  -- values_space_of
END_SCHEMA;  -- mathematical_functions_schema
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA measure_schema;

REFERENCE FROM basic_attribute_schema   -- ISO 10303-41
  (get_name_value,
   name_attribute,
   name_attribute_select); 
REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation_context); 

REFERENCE FROM support_resource_schema;    -- ISO 10303-41

  TYPE s_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    derived_unit);
  END_TYPE;

  TYPE absorbed_dose_measure = REAL;
  END_TYPE;

TYPE acceleration_measure = REAL;
  END_TYPE;

  TYPE radioactivity_measure = REAL;
  END_TYPE;

TYPE amount_of_substance_measure = REAL;
  END_TYPE;

  TYPE area_measure = REAL;
  END_TYPE;

  TYPE celsius_temperature_measure = REAL;
  END_TYPE;

  TYPE context_dependent_measure = REAL;
  END_TYPE;

  TYPE count_measure = NUMBER;
  END_TYPE;

  TYPE descriptive_measure = STRING;
  END_TYPE;
  
  TYPE capacitance_measure = REAL;
  END_TYPE;
  
  TYPE dose_equivalent_measure = REAL;
  END_TYPE;

  TYPE electric_charge_measure = REAL;
  END_TYPE;
  
  TYPE electric_current_measure = REAL;
  END_TYPE;

  TYPE conductance_measure = REAL;
  END_TYPE;

  TYPE electric_potential_measure = REAL;
  END_TYPE;
  
  TYPE energy_measure = REAL;
  END_TYPE;  
  
  TYPE force_measure = REAL;
  END_TYPE;  
  
  TYPE frequency_measure = REAL;
  END_TYPE; 
  
  TYPE magnetic_flux_density_measure = REAL;
  END_TYPE;

  TYPE illuminance_measure = REAL;
  END_TYPE;  

  TYPE inductance_measure = REAL;
  END_TYPE;
  
  TYPE length_measure = REAL;
  END_TYPE;

  TYPE luminous_intensity_measure = REAL;
  END_TYPE;

  TYPE luminous_flux_measure = REAL;
  END_TYPE;

  TYPE mass_measure = REAL;
  END_TYPE;

  TYPE measure_value = SELECT 
    (absorbed_dose_measure,
     dose_equivalent_measure,
     radioactivity_measure,
     acceleration_measure,
     amount_of_substance_measure, 
     area_measure, 
     celsius_temperature_measure, 
     context_dependent_measure, 
     count_measure, 
     descriptive_measure, 
     capacitance_measure,
     electric_charge_measure,
     conductance_measure,
     electric_current_measure, 
     electric_potential_measure,
     energy_measure,
     magnetic_flux_density_measure,
     force_measure,
     frequency_measure,
     illuminance_measure,
     inductance_measure,
     length_measure, 
     luminous_flux_measure,
     luminous_intensity_measure, 
     magnetic_flux_measure,
     mass_measure, 
     numeric_measure, 
     non_negative_length_measure,
     parameter_value, 
     plane_angle_measure, 
     positive_length_measure, 
     positive_plane_angle_measure, 
     positive_ratio_measure, 
     power_measure,
     pressure_measure,
     ratio_measure, 
     resistance_measure,
     solid_angle_measure, 
     thermodynamic_temperature_measure, 
     time_measure, 
     velocity_measure,
     volume_measure);
  END_TYPE;

  TYPE magnetic_flux_measure = REAL;
  END_TYPE;

  TYPE non_negative_length_measure = length_measure;
   WHERE
    WR1: SELF >= 0.0;
  END_TYPE;

  TYPE numeric_measure = NUMBER;
  END_TYPE;

  TYPE parameter_value = REAL;
  END_TYPE;

  TYPE plane_angle_measure = REAL;
  END_TYPE;

  TYPE positive_length_measure = non_negative_length_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE positive_plane_angle_measure = plane_angle_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE positive_ratio_measure = ratio_measure;
    WHERE
      WR1: SELF > 0.0;
  END_TYPE;

  TYPE power_measure = REAL;
  END_TYPE;

  TYPE pressure_measure = REAL;
  END_TYPE;

  TYPE ratio_measure = REAL;
  END_TYPE;

  TYPE resistance_measure = REAL;
  END_TYPE;

  TYPE si_prefix = ENUMERATION OF (exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, nano, pico, femto, atto);
  END_TYPE;

  TYPE si_unit_name = ENUMERATION OF (metre, gram, second, ampere, kelvin, mole, candela, radian, steradian, hertz, newton, pascal, joule, watt, coulomb, volt, farad, ohm, siemens, weber, tesla, henry, degree_Celsius, lumen, lux, becquerel, gray, sievert);
  END_TYPE;

  TYPE solid_angle_measure = REAL;
  END_TYPE;

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE;

  TYPE time_measure = REAL;
  END_TYPE;

  TYPE unit = SELECT (derived_unit, named_unit);
  END_TYPE;

  TYPE velocity_measure = REAL;
  END_TYPE;
  
  TYPE volume_measure = REAL;
  END_TYPE;

ENTITY absorbed_dose_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.ABSORBED_DOSE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY absorbed_dose_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.gray);  
END_ENTITY;

  ENTITY si_absorbed_dose_unit
     SUBTYPE OF (absorbed_dose_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.gray;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY acceleration_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ACCELERATION_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
  
  ENTITY acceleration_unit
    SUBTYPE OF (derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

ENTITY radioactivity_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.RADIOACTIVITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY radioactivity_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.becquerel);  
END_ENTITY;

  ENTITY si_radioactivity_unit
     SUBTYPE OF (radioactivity_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.becquerel;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY amount_of_substance_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY area_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY area_unit
   SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
      dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  ENTITY celsius_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY context_dependent_unit
    SUBTYPE OF (named_unit);
    name : label;
  END_ENTITY;

  ENTITY conversion_based_unit
    SUBTYPE OF (named_unit);
     name : label;
     conversion_factor : measure_with_unit;
  WHERE
    WR1: SELF\named_unit.dimensions = derive_dimensional_exponents(conversion_factor\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY derived_unit
    SUPERTYPE OF (ONEOF(absorbed_dose_unit,
	acceleration_unit,
    radioactivity_unit,
	area_unit,
    capacitance_unit,
	dose_equivalent_unit,
    electric_charge_unit,
    conductance_unit,
    electric_potential_unit,
    energy_unit,
    magnetic_flux_density_unit,
    force_unit,
    frequency_unit,
    illuminance_unit,
    inductance_unit,
    magnetic_flux_unit,
    power_unit,
    pressure_unit,
    resistance_unit,
    velocity_unit,
    volume_unit));
    elements : SET [1:?] OF derived_unit_element;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: (SIZEOF(elements) > 1) OR ((SIZEOF(elements) = 1) AND (elements[1].exponent <> 1.0));
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY derived_unit_element;
    unit : named_unit;
    exponent : REAL;
  END_ENTITY;

  ENTITY dimensional_exponents;
    length_exponent : REAL;
    mass_exponent : REAL;
    time_exponent : REAL;
    electric_current_exponent : REAL;
    thermodynamic_temperature_exponent : REAL;
    amount_of_substance_exponent : REAL;
    luminous_intensity_exponent : REAL;
  END_ENTITY;

  ENTITY capacitance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.farad);  
  END_ENTITY;

  ENTITY capacitance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.CAPACITANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_capacitance_unit
     SUBTYPE OF (capacitance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.farad;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

ENTITY dose_equivalent_measure_with_unit
 SUBTYPE OF (measure_with_unit);
WHERE
    WR1: 'MEASURE_SCHEMA.DOSE_EQUIVALENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;

ENTITY dose_equivalent_unit
 SUBTYPE OF (derived_unit);
WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.sievert);  
END_ENTITY;

  ENTITY si_dose_equivalent_unit
     SUBTYPE OF (dose_equivalent_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.sievert;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY electric_charge_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.coulomb);  
  END_ENTITY;

  ENTITY electric_charge_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_CHARGE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_electric_charge_unit
     SUBTYPE OF (electric_charge_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.coulomb;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
  
  ENTITY electric_current_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY electric_current_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;
  
   ENTITY conductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.siemens);  
  END_ENTITY;

  ENTITY conductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.CONDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_conductance_unit
     SUBTYPE OF (conductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.siemens;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY electric_potential_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.volt);  
  END_ENTITY;

  ENTITY electric_potential_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_electric_potential_unit
     SUBTYPE OF (electric_potential_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.volt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY energy_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.joule);  
  END_ENTITY;

  ENTITY energy_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ENERGY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_energy_unit
     SUBTYPE OF (energy_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.joule;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY magnetic_flux_density_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.tesla);  
  END_ENTITY;

  ENTITY magnetic_flux_density_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_magnetic_flux_density_unit
     SUBTYPE OF (magnetic_flux_density_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.tesla;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY force_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.newton);  
  END_ENTITY;

  ENTITY force_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.FORCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_force_unit
     SUBTYPE OF (force_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.newton;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY frequency_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.hertz);  
  END_ENTITY;

  ENTITY frequency_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.FREQUENCY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_frequency_unit
     SUBTYPE OF (frequency_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.hertz;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY global_unit_assigned_context
    SUBTYPE OF (representation_context);
    units : SET [1:?] OF unit;
  END_ENTITY;

  ENTITY illuminance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lux);  
  END_ENTITY;

  ENTITY illuminance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.ILLUMINANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_illuminance_unit
     SUBTYPE OF (illuminance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.lux;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY inductance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.henry);  
  END_ENTITY;

  ENTITY inductance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.INDUCTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_inductance_unit
     SUBTYPE OF (inductance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.henry;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY length_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY length_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 1.0) AND 
    (SELF\named_unit.dimensions.mass_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.time_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND 
    (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY luminous_flux_unit
    SUBTYPE OF(named_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.lumen);  
  END_ENTITY;

  ENTITY luminous_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LUMINOUS_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY luminous_intensity_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY luminous_intensity_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
  END_ENTITY;

  ENTITY magnetic_flux_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.weber);  
  END_ENTITY;

  ENTITY magnetic_flux_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MAGNETIC_FLUX_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_magnetic_flux_unit
     SUBTYPE OF (magnetic_flux_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.weber;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY mass_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY mass_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF(length_measure_with_unit, 
    mass_measure_with_unit, 
	time_measure_with_unit, 
    electric_current_measure_with_unit, 
	thermodynamic_temperature_measure_with_unit, 
    celsius_temperature_measure_with_unit, 
	amount_of_substance_measure_with_unit, 
    luminous_intensity_measure_with_unit, 
	plane_angle_measure_with_unit, 
    solid_angle_measure_with_unit, 
	area_measure_with_unit, 
	volume_measure_with_unit, 
    ratio_measure_with_unit, 
    acceleration_measure_with_unit,
    capacitance_measure_with_unit,
    electric_charge_measure_with_unit,
    conductance_measure_with_unit,
    electric_potential_measure_with_unit,
    energy_measure_with_unit,
    magnetic_flux_density_measure_with_unit,
    force_measure_with_unit,
    frequency_measure_with_unit,
    illuminance_measure_with_unit,
    inductance_measure_with_unit,
    luminous_flux_measure_with_unit,
    magnetic_flux_measure_with_unit,
    power_measure_with_unit,
    pressure_measure_with_unit,
    resistance_measure_with_unit,
    velocity_measure_with_unit,
	absorbed_dose_measure_with_unit,
    radioactivity_measure_with_unit,
    dose_equivalent_measure_with_unit));
    value_component : measure_value;
    unit_component : unit;
  WHERE
    WR1: valid_units(SELF);
  END_ENTITY;

  ENTITY named_unit
    SUPERTYPE OF (ONEOF(si_unit, conversion_based_unit, context_dependent_unit) ANDOR 
    ONEOF(length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, 
    amount_of_substance_unit, luminous_flux_unit, luminous_intensity_unit, plane_angle_unit, 
    solid_angle_unit, ratio_unit));
    dimensions : dimensional_exponents;
  END_ENTITY;

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY plane_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY power_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.watt);  
  END_ENTITY;

  ENTITY power_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.POWER_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_power_unit
     SUBTYPE OF (power_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.watt;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;
 
  ENTITY pressure_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.pascal);  
  END_ENTITY;

  ENTITY pressure_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.PRESSURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_pressure_unit
     SUBTYPE OF (pressure_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.pascal;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  ENTITY ratio_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY ratio_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY resistance_unit
    SUBTYPE OF(derived_unit);
  WHERE
    WR1: derive_dimensional_exponents(SELF) = dimensions_for_si_unit (si_unit_name.ohm);  
  END_ENTITY;

  ENTITY resistance_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.RESISTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY si_resistance_unit
     SUBTYPE OF (resistance_unit,si_unit);
  WHERE
    WR1: SELF\si_unit.name = si_unit_name.ohm;
    WR2: NOT EXISTS(SELF\derived_unit.name);
  END_ENTITY;

  
  ENTITY si_unit
    SUBTYPE OF (named_unit);
    prefix : OPTIONAL si_prefix;
    name : si_unit_name;
  DERIVE
    SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
  WHERE
    WR1: NOT(('MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF(SELF)) AND
             (SIZEOF(USEDIN(SELF,'MEASURE_SCHEMA.DERIVED_UNIT_ELEMENT.UNIT')) > 0)) OR
            (prefix = si_prefix.kilo); 
  END_ENTITY;

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY solid_angle_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY time_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY time_unit
    SUBTYPE OF (named_unit);
  WHERE
    WR1: (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY velocity_measure_with_unit
   SUBTYPE OF (measure_with_unit);
  WHERE
   WR1: 'MEASURE_SCHEMA.VELOCITY_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;
  
  ENTITY velocity_unit
  SUBTYPE OF (derived_unit);
  WHERE
  WR1: derive_dimensional_exponents(SELF) = 
       dimensional_exponents ( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  ENTITY volume_measure_with_unit
    SUBTYPE OF (measure_with_unit);
  WHERE
    WR1: 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY volume_unit
    SUBTYPE OF (derived_unit);
   WHERE
     WR1: derive_dimensional_exponents(SELF) = 
          dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 );
  END_ENTITY;

  FUNCTION derive_dimensional_exponents (x : unit):dimensional_exponents;
    LOCAL
      result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    END_LOCAL;

    IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x\derived_unit.elements) TO HIINDEX(x\derived_unit.elements);
        result.length_exponent := result.length_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.time_exponent);
        result.electric_current_exponent := result.electric_current_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.amount_of_substance_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.luminous_intensity_exponent + 
        (x\derived_unit.elements[i]\derived_unit_element.exponent * 
         x\derived_unit.elements[i]\derived_unit_element.unit\named_unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x\named_unit.dimensions;
    END_IF;
    RETURN (result);
  END_FUNCTION;

  FUNCTION dimensions_for_si_unit (n : si_unit_name):dimensional_exponents;
    CASE n OF 
      metre:
        RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      gram:
        RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      second:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
      ampere:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
      kelvin:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      mole:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
      candela:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      radian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      steradian:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      hertz:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      newton:
        RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      pascal:
        RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      joule:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      watt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
      coulomb:
        RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
      volt:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
      farad:
        RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0));
      ohm:
        RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
      siemens:
        RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
      weber:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      tesla:
        RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      henry:
        RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
      degree_Celsius:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      lumen:
        RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      lux:
        RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      becquerel:
        RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      gray:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      sievert:
        RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      OTHERWISE:
        RETURN (?);
    END_CASE;
  END_FUNCTION;

  FUNCTION valid_units (m : measure_with_unit):BOOLEAN;
    IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
      dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ACCELERATION_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.CAPACITANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, -1.0, 4.0, 2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ELECTRIC_CHARGE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
        IF 'MEASURE_SCHEMA.CONDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( -2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;
        IF 'MEASURE_SCHEMA.ELECTRIC_POTENTIAL_MEASURE' IN TYPEOF(m.value_component) THEN
          IF derive_dimensional_exponents(m.unit_component) <> 
            dimensional_exponents( 2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0 ) THEN
            RETURN (FALSE);
          END_IF;
    END_IF;    
    IF 'MEASURE_SCHEMA.ENERGY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.FORCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.FREQUENCY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ILLUMINANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.INDUCTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.LUMINOUS_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
     IF 'MEASURE_SCHEMA.MAGNETIC_FLUX_DENSITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POWER_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.PRESSURE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( -1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RESISTANCE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.VELOCITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents( 1.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RADIOACTIVITY_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ABSORBED_DOSE_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.DOSE_EQUIVALENT_MEASURE' IN TYPEOF(m.value_component) THEN
      IF derive_dimensional_exponents(m.unit_component) <> 
        dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;
END_SCHEMA;
(*
ISO TC184/SC4/WG12 N4852 - ISO 10303-108 paramaterization_schema - EXPRESS
THIS IS DOCUMENT I CONTAINING REVISED EXPRESS FOR 'PARAMETERIZATION AND CONSTRAINTS FOR EXPLICIT GEOMETRIC  
PRODUCT MODELS' TO TAKE INTO ACCOUNT TC1 FOR THAT DOCUMENT -- 2008-03-17  
*)                                          


SCHEMA parameterization_schema;

REFERENCE FROM support_resource_schema             -- ISO 10303-41
  (identifier,
   label,
   text);

REFERENCE FROM representation_schema               -- ISO 10303-43
  (representation_item,
   using_representations);

REFERENCE FROM mathematical_functions_schema       -- ISO 10303-50
  (finite_space,
   maths_number,
   maths_value,
   maths_variable,
   member_of,
   positive_integer);

REFERENCE FROM variational_representation_schema   -- ISO 10303-108
  (variational_representation_item);

REFERENCE FROM ISO13584_generic_expressions_schema -- ISO 13584-20
  (environment,
   generic_variable,
   variable_semantics);

TYPE attribute_identifier = identifier;
WHERE
   WR1: validate_attribute_id(SELF);
END_TYPE;

ENTITY variational_parameter
  ABSTRACT SUPERTYPE OF (ONEOF (bound_variational_parameter, 
                                unbound_variational_parameter))
  SUBTYPE OF (variational_representation_item, maths_variable);
  parameter_description : OPTIONAL text; 
  parameter_current_value : maths_value;
WHERE
  WR1 : member_of(parameter_current_value, 
    SELF\maths_variable.values_space);
  WR2 : SELF\maths_variable.name = SELF\representation_item.name;
END_ENTITY; 

ENTITY bound_variational_parameter
  SUBTYPE OF (variational_parameter);
DERIVE
  SELF\variational_parameter.parameter_current_value : maths_value := ?;
WHERE
WR1 : 'PARAMETERIZATION_SCHEMA.BOUND_PARAMETER_ENVIRONMENT'
    IN TYPEOF(SELF\generic_variable.interpretation);
END_ENTITY; 

ENTITY unbound_variational_parameter
  SUBTYPE OF (variational_parameter);
WHERE
  WR1: 'PARAMETERIZATION_SCHEMA.UNBOUND_PARAMETER_ENVIRONMENT' 
    IN TYPEOF(SELF\generic_variable.interpretation);
END_ENTITY;

ENTITY bound_parameter_environment
  SUBTYPE OF (environment);  
WHERE
  WR1: ('PARAMETERIZATION_SCHEMA.BOUND_VARIATIONAL_PARAMETER' IN
    TYPEOF(SELF\environment.syntactic_representation)) AND
    ('PARAMETERIZATION_SCHEMA.INSTANCE_ATTRIBUTE_REFERENCE' IN
    TYPEOF(SELF\environment.semantics));
END_ENTITY; 

ENTITY unbound_parameter_environment
  SUBTYPE OF (environment);  
WHERE
  WR1: ('PARAMETERIZATION_SCHEMA.UNBOUND_VARIATIONAL_PARAMETER' IN
    TYPEOF(SELF\environment.syntactic_representation)) AND
    ('PARAMETERIZATION_SCHEMA.UNBOUND_VARIATIONAL_PARAMETER_SEMANTICS' IN
    TYPEOF(SELF\environment.semantics));
END_ENTITY; 

ENTITY instance_attribute_reference
  SUBTYPE OF (variable_semantics);  
  attribute_name  : attribute_identifier;
  owning_instance : representation_item;
END_ENTITY; 

ENTITY unbound_variational_parameter_semantics
  SUBTYPE OF (variable_semantics);
END_ENTITY;

ENTITY fixed_instance_attribute_set
  SUBTYPE OF (variational_representation_item);
  fixed_attributes : SET[1:?] OF instance_attribute_reference;
WHERE
  WR1: SIZEOF(QUERY(q <* using_representations(SELF) | 
    SIZEOF(QUERY(r <* q.items |
    'PARAMETERIZATION_SCHEMA.FIXED_INSTANCE_ATTRIBUTE_SET' 
    IN TYPEOF(r))) > 1)) = 0;
END_ENTITY;

ENTITY generated_finite_numeric_space
  SUBTYPE OF (finite_space);
  start_value      : maths_number;
  increment_value  : maths_number;
  increment_number : positive_integer;
DERIVE
  SELF\finite_space.members : SET [2:?] OF maths_number 
    := make_numeric_set(start_value, increment_value, increment_number); 
WHERE
  WR1: increment_value <> 0.0;
END_ENTITY;

FUNCTION make_numeric_set(start, delta : maths_number; 
                          incs         : positive_integer) 
                                       : SET [2:?] OF maths_number;

  LOCAL
    i : INTEGER;
    numeric_set : SET[2:?] OF maths_number := [start, (start + delta)];
  END_LOCAL;

  IF incs > 1 THEN REPEAT i := 2 TO incs;
                     numeric_set := numeric_set + (start + (i*delta));
                   END_REPEAT;
  END_IF;
  RETURN(numeric_set);
END_FUNCTION;

FUNCTION validate_attribute_id(attid : attribute_identifier) : BOOLEAN;

  CONSTANT
    letters      : SET[52:52] OF STRING := 
      ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',
       'q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F',
       'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
       'W','X','Y','Z'];
    numbers_etc  : SET[15:15] OF STRING := 
      ['0','1','2','3','4','5','6','7','8','9','_','[',']','.','\'];
    valid_chars  : SET[67:67] OF STRING := letters + numbers_etc;
  END_CONSTANT;

  LOCAL
    id_length : INTEGER := LENGTH(attid);
    id_valid  : BOOLEAN := TRUE;
    i         : INTEGER;
  END_LOCAL;

  -- check that indentifier starts with a letter

  IF NOT (attid[1] IN letters) THEN 
    id_valid := FALSE; 
  END_IF;
  
  -- check that no invalid characters occur subsequently

  REPEAT i := 2 TO id_length WHILE id_valid = TRUE;
    IF NOT (attid[i] IN valid_chars) THEN 
      id_valid := FALSE;
    END_IF;
  END_REPEAT;
  RETURN(id_valid);

END_FUNCTION;

END_SCHEMA; -- parameterization_schema 
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA person_organization_schema;

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_id_value, 
    get_name_value, 
    get_role, 
    id_attribute, 
    id_attribute_select,
    name_attribute, 
    name_attribute_select,
    object_role, 
    role_association);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  TYPE person_organization_select = SELECT (
    person, 
    organization, 
    person_and_organization);
  END_TYPE;

  TYPE pos_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    person_and_organization_role,
    person_and_organization,
    person_role,
    organization_role,
    organizational_project);
  END_TYPE;
  
  TYPE pos_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    address,
    organizational_project);
  END_TYPE;

  TYPE pos_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    address,
    person_and_organization);
  END_TYPE;

  ENTITY address;
    internal_location : OPTIONAL label;
    street_number : OPTIONAL label;
    street : OPTIONAL label;
    postal_box : OPTIONAL label;
    town : OPTIONAL label;
    region : OPTIONAL label;
    postal_code : OPTIONAL label;
    country : OPTIONAL label;
    facsimile_number : OPTIONAL label;
    telephone_number : OPTIONAL label;
    electronic_mail_address : OPTIONAL label;
    telex_number : OPTIONAL label;
  DERIVE
    name : label := get_name_value(SELF);
    url : identifier := get_id_value(SELF);
  WHERE
    WR1: EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
  END_ENTITY;

  ENTITY organization;
    id : OPTIONAL identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_relationship;
    name : label;
    description : OPTIONAL text;
    relating_organization : organization;
    related_organization : organization;
  END_ENTITY;

  ENTITY organization_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organization_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_organization_type : organization_type;
    related_organization_type : organization_type;
  END_ENTITY;

  ENTITY organizational_address
    SUBTYPE OF (address);
    organizations : SET [1:?] OF organization;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY organizational_project;
    name : label;
    description : OPTIONAL text;
    responsible_organizations : SET [1:?] OF organization;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organizational_project_relationship;
    name : label;
    description : OPTIONAL text;
    relating_organizational_project : organizational_project;
    related_organizational_project : organizational_project;
  END_ENTITY;

  ENTITY person;
    id : identifier;
    last_name : OPTIONAL label;
    first_name : OPTIONAL label;
    middle_names : OPTIONAL LIST [1:?] OF label;
    prefix_titles : OPTIONAL LIST [1:?] OF label;
    suffix_titles : OPTIONAL LIST [1:?] OF label;
  WHERE
    WR1: EXISTS(last_name) OR EXISTS(first_name);
  END_ENTITY;

  ENTITY person_and_organization;
    the_person : person;
    the_organization : organization;
  DERIVE
    name : label := get_name_value(SELF);
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_and_organization_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_role;
    name : label;
  DERIVE
    description : text := get_description_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_type_definition;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    formation : person_type_definition_formation;
  END_ENTITY;

  ENTITY person_type_definition_formation;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    of_person_type : person_type;
  END_ENTITY;

  ENTITY person_type_definition_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_person_type_definition : person_type_definition;
    related_person_type_definition : person_type_definition;
  END_ENTITY;

  ENTITY personal_address
    SUBTYPE OF (address);
    people : SET [1:?] OF person;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_position_in_organization : position_in_organization;
    related_position_in_organization : position_in_organization;
  END_ENTITY;

  ENTITY position_in_organization_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  FUNCTION acyclic_organization_relationship (relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_relationship;
    END_LOCAL;

    IF relation.relating_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_organization_type_relationship (relation : organization_type_relationship; relatives : SET OF organization_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organization_type_relationship;
    END_LOCAL;

    IF relation.relating_organization_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_organizational_project_relationship (relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF organizational_project_relationship;
    END_LOCAL;

    IF relation.relating_organizational_project IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_person_type_definition_relationship (relation : person_type_definition_relationship; relatives : SET OF person_type_definition; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF person_type_definition_relationship;
    END_LOCAL;

    IF relation.relating_person_type_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'PERSON_ORGANIZATION_SCHEMA.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_position_in_organization_relationship (relation : position_in_organization_relationship; relatives : SET OF position_in_organization; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF position_in_organization_relationship;
    END_LOCAL;

    IF relation.relating_position_in_organization IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N6141 - ISO/IS 10303-46 Visual presentation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N4830
*) 


SCHEMA presentation_appearance_schema;
 
REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     b_spline_curve, 
     cartesian_point,
     composite_curve,
     curve,
     geometric_representation_item,
     point,
     polyline, 
     vector);

REFERENCE FROM group_schema
  (group);

REFERENCE FROM measure_schema
    (descriptive_measure,
     length_measure,
     measure_with_unit,
     plane_angle_measure,
     positive_length_measure,
     ratio_measure,
     positive_ratio_measure);

REFERENCE FROM presentation_organization_schema
     (area_dependent_annotation_representation,
      presentation_area,
      presentation_layer_assignment,
      presentation_layer_usage,
      presentation_representation,
      presentation_set,
      presentation_view,
      product_data_representation_view,
      view_dependent_annotation_representation);

REFERENCE FROM presentation_definition_schema
    (annotation_curve_occurrence,
     annotation_fill_area,
     annotation_symbol_occurrence,
     annotation_text_with_delineation,
     symbol_representation_with_blanking_box);

REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol_outline,
     character_glyph_symbol_stroke,
     colour);

REFERENCE FROM representation_schema
    (founded_item,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     bag_to_set);
 

  TYPE approximation_method = ENUMERATION OF
    (chordal_deviation,
     chordal_length);
  END_TYPE;

  TYPE box_characteristic_select = SELECT
    (box_height,
     box_width,
     box_slant_angle,
     box_rotate_angle);
  END_TYPE;

  TYPE box_height = positive_ratio_measure;
  END_TYPE;

  TYPE box_rotate_angle = plane_angle_measure;
  END_TYPE;

  TYPE  box_slant_angle = plane_angle_measure;
  END_TYPE;

  TYPE box_width = positive_ratio_measure;
  END_TYPE;

  TYPE character_spacing_select = SELECT
    (length_measure,
     ratio_measure,
     measure_with_unit,
     descriptive_measure,
     pre_defined_character_spacing);
  END_TYPE;

  TYPE character_style_select = SELECT
    (character_glyph_style_stroke,
     character_glyph_style_outline,
     text_style_for_defined_font);
  END_TYPE;

  TYPE curve_font_or_scaled_curve_font_select = SELECT
    (curve_style_font_select,
     curve_style_font_and_scaling);
  END_TYPE;

  TYPE curve_or_annotation_curve_occurrence = SELECT
    (curve,
     annotation_curve_occurrence);
  END_TYPE;

  TYPE curve_or_render = SELECT
    (curve_style,
     curve_style_rendering);
  END_TYPE;

  TYPE curve_style_font_select = SELECT
    (curve_style_font,
     pre_defined_curve_font,
     externally_defined_curve_font);
  END_TYPE;

  TYPE curve_tolerance_deviation = positive_length_measure;
  END_TYPE;

  TYPE curve_tolerance_parameter = REAL;
  END_TYPE;

  TYPE direction_count_select = SELECT
    (u_direction_count,
     v_direction_count);
  END_TYPE;

  TYPE fill_style_select = SELECT
    (fill_area_style_colour,
     pre_defined_tile_style,
     externally_defined_tile_style,
     fill_area_style_tiles,
     pre_defined_hatch_style,
     externally_defined_hatch_style,
     fill_area_style_hatching);
  END_TYPE;

  TYPE fill_area_style_tile_shape_select = SELECT
    (fill_area_style_tile_curve_with_style,
     fill_area_style_tile_coloured_region,
     fill_area_style_tile_symbol_with_style,
     pre_defined_tile,
     externally_defined_tile);
  END_TYPE;

  TYPE hiding_or_blanking_select = SELECT
    (presentation_area,
     presentation_view,
     product_data_representation_view,
     annotation_fill_area,
     area_dependent_annotation_representation,
     view_dependent_annotation_representation,
     annotation_text_with_delineation,
     character_glyph_symbol_stroke,
     character_glyph_symbol_outline,
     symbol_representation_with_blanking_box);
  END_TYPE;

  TYPE invisibility_context = EXTENSIBLE GENERIC_ENTITY SELECT 
    (presentation_layer_usage,
     presentation_representation,
     presentation_set);
  END_TYPE;

  TYPE invisible_item = EXTENSIBLE GENERIC_ENTITY SELECT 
    (styled_item,
     presentation_layer_assignment,
     representation);
  END_TYPE;

  TYPE marker_select = SELECT
    (marker_type,
     pre_defined_marker);
  END_TYPE;

  TYPE marker_type = ENUMERATION OF
    (dot,
     x,
     plus,
     asterisk,
     ring,
     square,
     triangle);
  END_TYPE;

  TYPE null_style = ENUMERATION OF
    (null);
  END_TYPE;

  TYPE presentation_style_select = SELECT
    (pre_defined_presentation_style,
     point_style,
     curve_style,
     surface_style_usage,
     symbol_style,
     fill_area_style,
     text_style,
     approximation_tolerance,
     externally_defined_style,
     null_style);
  END_TYPE;

  TYPE product_or_presentation_space = ENUMERATION OF
    (product_shape_space,
     presentation_area_space);
  END_TYPE;

  TYPE rendering_properties_select = SELECT
    (surface_style_reflectance_ambient,
     surface_style_transparent);
  END_TYPE;

  TYPE shading_curve_method = ENUMERATION OF
    (constant_colour,
     linear_colour);
  END_TYPE;

  TYPE shading_surface_method = ENUMERATION OF
    (constant_shading,
     colour_shading,
     dot_shading,
     normal_shading);
  END_TYPE;

  TYPE size_select  = SELECT
    (positive_length_measure,
     measure_with_unit,
     descriptive_measure,
     pre_defined_size);
  END_TYPE;

  TYPE squared_or_rounded = ENUMERATION OF
    (squared,
     rounded);
  END_TYPE;

  TYPE style_context_select = SELECT
    (group,
     presentation_layer_assignment,
     presentation_set,
     representation,
     representation_item,
     representation_relationship);
  END_TYPE;

  TYPE surface_side = ENUMERATION OF
    (positive,
     negative,
     both);
  END_TYPE;

  TYPE surface_side_style_select = SELECT
    (surface_side_style,
     pre_defined_surface_side_style);
  END_TYPE;

  TYPE surface_style_element_select = SELECT
    (surface_style_fill_area,
     surface_style_boundary,
     surface_style_silhouette,
     surface_style_segmentation_curve,
     surface_style_control_grid,
     surface_style_parameter_line,
     surface_style_rendering);
  END_TYPE;

  TYPE surface_tolerance_deviation = positive_length_measure;
  END_TYPE;

  TYPE surface_tolerance_parameter = REAL;
  END_TYPE;

  TYPE symbol_style_select = SELECT
    (symbol_element_style,
     symbol_colour);
  END_TYPE;


  TYPE text_justification = label;
  END_TYPE;

  TYPE tolerance_deviation_select = SELECT
    (curve_tolerance_deviation,
     surface_tolerance_deviation);
  END_TYPE;

  TYPE tolerance_parameter_select = SELECT
    (curve_tolerance_parameter,
     surface_tolerance_parameter);
  END_TYPE;

  TYPE tolerance_select = SELECT
    (approximation_tolerance_deviation,
     approximation_tolerance_parameter);
  END_TYPE;

  TYPE u_direction_count = INTEGER;
    WHERE
      WR1: SELF > 1;
  END_TYPE;

  TYPE v_direction_count = INTEGER;
    WHERE
      WR1: SELF > 1;
  END_TYPE;

  ENTITY approximation_tolerance
    SUBTYPE OF (founded_item);
      tolerance : tolerance_select;
  END_ENTITY;

  ENTITY approximation_tolerance_deviation
    SUBTYPE OF (founded_item);
      tessellation_type : approximation_method;
      tolerances        : SET [1:2] OF tolerance_deviation_select;
      definition_space  : product_or_presentation_space;
    WHERE
      WR1: (HIINDEX(SELF.tolerances) = 1)
            XOR
        (TYPEOF(SELF.tolerances[1]) <> TYPEOF(SELF.tolerances[2]));
  END_ENTITY;

  ENTITY approximation_tolerance_parameter
    SUBTYPE OF (founded_item);
      tolerances : SET [1:2] OF tolerance_parameter_select;
    WHERE
      WR1: (HIINDEX (SELF.tolerances) = 1 )
             XOR
        (TYPEOF (SELF.tolerances[1]) <> TYPEOF (SELF.tolerances[2]));
  END_ENTITY;

  ENTITY character_glyph_style_outline
    SUBTYPE OF (founded_item);
      outline_style : curve_style;
  END_ENTITY;

  ENTITY character_glyph_style_outline_with_characteristics
    SUBTYPE OF (character_glyph_style_outline);
      characteristics : fill_area_style;
  END_ENTITY;

  ENTITY character_glyph_style_stroke
    SUBTYPE OF (founded_item);
      stroke_style : curve_style;
  END_ENTITY;

  ENTITY context_dependent_invisibility
    SUBTYPE OF (invisibility);
      presentation_context : invisibility_context;
  END_ENTITY;

  ENTITY context_dependent_over_riding_styled_item
    SUBTYPE OF(over_riding_styled_item);
      style_context : LIST[1:?] OF style_context_select;
    WHERE
      WR1: 
(SIZEOF(QUERY(sc <* SELF.style_context | 'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(sc)))= 1) OR
(SIZEOF(QUERY(sc <* SELF.style_context |
     ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(sc))
  OR ('REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP' IN TYPEOF(sc)) ))
  = SIZEOF(style_context));     
  END_ENTITY;

  ENTITY curve_style
    SUBTYPE OF (founded_item);
      name         : label;
      curve_font   : curve_font_or_scaled_curve_font_select;
      curve_width  : size_select;
      curve_colour : colour;
  END_ENTITY;

  ENTITY curve_style_curve_pattern
    SUBTYPE OF (geometric_representation_item);
      pattern        : annotation_curve_occurrence;
      pattern_length : positive_length_measure;
  END_ENTITY;

  ENTITY curve_style_curve_pattern_set
    SUBTYPE OF (curve_style_font, 
                geometric_representation_item);
      pattern_set : SET [1:?] OF curve_style_curve_pattern;
  END_ENTITY;

  ENTITY curve_style_font
    SUBTYPE OF (founded_item);
      name         : label;
      pattern_list : LIST [1:?] OF curve_style_font_pattern;
  END_ENTITY;

  ENTITY curve_style_font_and_scaling
    SUBTYPE OF (founded_item);
      name               : label;
      curve_font         : curve_style_font_select;
      curve_font_scaling : REAL;
  END_ENTITY;

  ENTITY curve_style_font_pattern
    SUBTYPE OF (founded_item);
      visible_segment_length   : positive_length_measure;
      invisible_segment_length : positive_length_measure;
  END_ENTITY;

  ENTITY curve_style_rendering;
    rendering_method     : shading_curve_method;
    rendering_properties : surface_rendering_properties;
  END_ENTITY;

  ENTITY curve_style_wide
    SUBTYPE OF (curve_style_font);
      interior_style : fill_area_style;
  END_ENTITY;

  ENTITY curve_style_with_ends_and_corners
    SUBTYPE OF (curve_style);
      curve_ends    : squared_or_rounded;
      curve_corners : squared_or_rounded;
  END_ENTITY;

  ENTITY curve_style_with_extension
    SUBTYPE OF (curve_style);
      curve_extensions   : length_measure;
  END_ENTITY;

  ENTITY draughting_pre_defined_curve_font
    SUBTYPE OF (pre_defined_curve_font);
    WHERE
      WR1: SELF.name IN
        ['continuous',
         'chain',
         'chain double dash',
         'dashed',
         'dotted'];
  END_ENTITY;

  ENTITY externally_defined_curve_font
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_hatch_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY externally_defined_style
    SUBTYPE OF (externally_defined_item, founded_item);
  END_ENTITY;

  ENTITY externally_defined_tile
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_tile_style
    SUBTYPE OF (externally_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY fill_area_style
    SUBTYPE OF (founded_item);
      name        : label;
      fill_styles : SET [1:?] OF fill_style_select;
    WHERE
      WR1: SIZEOF(QUERY(fill_style <* SELF.fill_styles |
         'PRESENTATION_APPEARANCE_SCHEMA.'+
         'FILL_AREA_STYLE_COLOUR' IN
         TYPEOF(fill_style)
         )) <= 1;
  END_ENTITY;

  ENTITY fill_area_style_colour;
    name        : label;
    fill_colour : colour;
  END_ENTITY;

  ENTITY fill_area_style_hatching
    SUBTYPE OF (geometric_representation_item);
      hatch_line_appearance         : curve_style;
      start_of_next_hatch_line      : one_direction_repeat_factor;
      point_of_reference_hatch_line : cartesian_point;
      pattern_start                 : cartesian_point;
      hatch_line_angle              : plane_angle_measure;
  END_ENTITY;

  ENTITY fill_area_style_tile_coloured_region
    SUBTYPE OF (geometric_representation_item);
      closed_curve  : curve_or_annotation_curve_occurrence;
      region_colour : colour;
    WHERE
      WR1: (NOT('GEOMETRY_SCHEMA.CURVE' IN TYPEOF (closed_curve))) OR 
        ('GEOMETRY_SCHEMA.CIRCLE' IN TYPEOF (closed_curve)) OR 
        ('GEOMETRY_SCHEMA.ELLIPSE' IN TYPEOF (closed_curve)) OR 
        ( ('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\b_spline_curve.closed_curve = TRUE) ) OR 
        ( ('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\composite_curve.closed_curve = TRUE) ) OR 
        ( ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF (closed_curve)) 
             AND (closed_curve\polyline.points[LOINDEX(closed_curve\polyline.points)] = 
                  closed_curve\polyline.points[HIINDEX(closed_curve\polyline.points)]) );
  END_ENTITY;

  ENTITY fill_area_style_tile_curve_with_style
    SUBTYPE OF (geometric_representation_item);
      styled_curve : annotation_curve_occurrence;
  END_ENTITY;

  ENTITY fill_area_style_tile_symbol_with_style
    SUBTYPE OF (geometric_representation_item);
      symbol : annotation_symbol_occurrence;
  END_ENTITY;

  ENTITY fill_area_style_tiles
    SUBTYPE OF (geometric_representation_item);
      tiling_pattern : two_direction_repeat_factor;
      tiles          : SET [1:?] OF fill_area_style_tile_shape_select;
      tiling_scale   : positive_ratio_measure;
  END_ENTITY;

  ENTITY invisibility;
    invisible_items : SET [1:?] OF invisible_item;
  END_ENTITY;

  ENTITY occlusion_precedence;
      higher_precedence : hiding_or_blanking_select;
      lower_precedence  : hiding_or_blanking_select;
      occlusion_context : representation;
    WHERE
      WR1: acyclic_occlusion_precedence (SELF, [SELF.lower_precedence]);
  END_ENTITY;

  ENTITY one_direction_repeat_factor
    SUBTYPE OF (geometric_representation_item);
      repeat_factor : vector;
  END_ENTITY;

  ENTITY over_riding_styled_item
    SUBTYPE OF (styled_item);
      over_ridden_style : styled_item;
  END_ENTITY;

  ENTITY point_style
    SUBTYPE OF (founded_item);
      name          : label;
      marker        : marker_select;
      marker_size   : size_select;
      marker_colour : colour;
  END_ENTITY;

  ENTITY pre_defined_character_spacing
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_curve_font
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_hatch_style
    SUBTYPE OF (pre_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY pre_defined_marker
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_presentation_style
    SUBTYPE OF (founded_item, pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_size
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_surface_side_style
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_tile
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_tile_style
    SUBTYPE OF (pre_defined_item, geometric_representation_item);
  END_ENTITY;

  ENTITY presentation_style_assignment
    SUBTYPE OF (founded_item);
      styles : SET [1:?] OF presentation_style_select;
    WHERE
      WR1: SIZEOF (QUERY (style1 <* SELF.styles |
           NOT (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           NOT ((TYPEOF (style1) <> TYPEOF (style2)) OR
             (SIZEOF (['PRESENTATION_APPEARANCE_SCHEMA.' + 
                       'SURFACE_STYLE_USAGE',
                       'PRESENTATION_APPEARANCE_SCHEMA.'+
                       'EXTERNALLY_DEFINED_STYLE'] *
                     TYPEOF (style1)) = 1)
           ))) = 0
         ))) = 0;
      WR2: SIZEOF (QUERY (style1 <* SELF.styles |
         'PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN
         TYPEOF(style1)
         )) <= 2;
      WR3: SIZEOF (QUERY (style1 <* SELF.styles |
         ('PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF (style1)) AND 
         (SIZEOF (QUERY (style2 <* (SELF.styles - style1) |
           ('PRESENTATION_APPEARANCE_SCHEMA.SURFACE_STYLE_USAGE' IN TYPEOF (style2)) AND 
           ((style1\surface_style_usage.side = both) OR 
           (style2\surface_style_usage.side = both) OR 
           (style1\surface_style_usage.side = style2\surface_style_usage.side)) )) > 0))) = 0;
  END_ENTITY;

  ENTITY presentation_style_by_context
    SUBTYPE OF (presentation_style_assignment);
      style_context : style_context_select;
  END_ENTITY;

  ENTITY symbol_colour;
    colour_of_symbol : colour;
  END_ENTITY;

  ENTITY symbol_element_style
    SUBTYPE OF (founded_item);
      style_of_symbol : presentation_style_assignment;
    WHERE
      WR1: SIZEOF (QUERY ( style <* SELF.style_of_symbol.styles |
           'PRESENTATION_APPEARANCE_SCHEMA.SYMBOL_STYLE' IN
           TYPEOF (style))) = 0;
      WR2: NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
                'PRESENTATION_STYLE_BY_CONTEXT' IN
              TYPEOF (SELF.style_of_symbol)
           );
  END_ENTITY;

  ENTITY symbol_style
    SUBTYPE OF (founded_item);
      name            : label; 
      style_of_symbol : symbol_style_select;
  END_ENTITY;

  ENTITY styled_item
    SUBTYPE OF (representation_item);
      styles :  SET [1:?] OF presentation_style_assignment;
      item   :  representation_item;
    WHERE
      WR1: (SIZEOF(SELF.styles) = 1)
               XOR
         (SIZEOF(QUERY(pres_style <* SELF.styles |
         NOT ('PRESENTATION_APPEARANCE_SCHEMA.' +
              'PRESENTATION_STYLE_BY_CONTEXT' IN
         TYPEOF(pres_style))
         )) = 0);
      WR2: NOT ('PRESENTATION_APPEARANCE_SCHEMA.STYLED_ITEM' IN TYPEOF(item));
      WR3: ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(item)) OR
           ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item));               
  END_ENTITY;

  ENTITY surface_rendering_properties;
    rendered_colour : colour;
  END_ENTITY;

  ENTITY surface_side_style
    SUBTYPE OF (founded_item);
      name   : label;
      styles : SET [1:7] OF surface_style_element_select;
    WHERE
      WR1: SIZEOF(QUERY( style1 <* SELF.styles |
           SIZEOF(QUERY( style2 <* SELF.styles - style1 |
           TYPEOF(style1) = TYPEOF(style2)
           )) > 0
           )) = 0;
  END_ENTITY;

  ENTITY surface_style_boundary
    SUBTYPE OF (founded_item);
      style_of_boundary : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_control_grid
    SUBTYPE OF (founded_item);
      style_of_control_grid : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_fill_area
    SUBTYPE OF (founded_item);
      fill_area : fill_area_style;
  END_ENTITY;

  ENTITY surface_style_parameter_line
    SUBTYPE OF (founded_item);
      style_of_parameter_lines : curve_or_render;
      direction_counts         : SET [1:2] OF direction_count_select;
    WHERE
      WR1: (HIINDEX(SELF.direction_counts) = 1)
                        XOR
         (TYPEOF(SELF.direction_counts[1]) <>
          TYPEOF(SELF.direction_counts[2]));
  END_ENTITY;

  ENTITY surface_style_reflectance_ambient;
    ambient_reflectance : REAL;
  END_ENTITY;

  ENTITY surface_style_reflectance_ambient_diffuse
    SUBTYPE OF (surface_style_reflectance_ambient);
      diffuse_reflectance : REAL;
  END_ENTITY;

  ENTITY surface_style_reflectance_ambient_diffuse_specular
    SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
      specular_reflectance : REAL;
      specular_exponent    : REAL;
      specular_colour      : colour;
  END_ENTITY;

  ENTITY surface_style_rendering;
    rendering_method : shading_surface_method;
    surface_colour   : colour;
  END_ENTITY;

  ENTITY surface_style_rendering_with_properties
    SUBTYPE OF (surface_style_rendering);
      properties : SET [1:2] OF rendering_properties_select;
    WHERE
      WR1: (HIINDEX(SELF.properties) = 1)
                   XOR
         (TYPEOF(SELF.properties[1]) <> TYPEOF(SELF.properties[2]));
  END_ENTITY;

  ENTITY surface_style_segmentation_curve
    SUBTYPE OF (founded_item);
      style_of_segmentation_curve : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_silhouette
    SUBTYPE OF (founded_item);
      style_of_silhouette : curve_or_render;
  END_ENTITY;

  ENTITY surface_style_transparent;
      transparency : REAL;
    WHERE
      WR1: {0.0 <= transparency <= 1.0};
  END_ENTITY;

  ENTITY surface_style_usage
    SUBTYPE OF (founded_item);
      side  : surface_side;
      style : surface_side_style_select;
  END_ENTITY;

  ENTITY text_style
    SUBTYPE OF (founded_item);
      name                 : label;
      character_appearance : character_style_select;
  END_ENTITY;

  ENTITY text_style_for_defined_font;
    text_colour : colour;
  END_ENTITY;

  ENTITY text_style_with_box_characteristics
    SUBTYPE OF (text_style);
      characteristics : SET [1:4] OF box_characteristic_select;
    WHERE
      WR1: SIZEOF( QUERY( c1 <* SELF.characteristics |
           SIZEOF( QUERY( c2 <* SELF.characteristics - c1 |
           TYPEOF (c1) = TYPEOF (c2)
           )) > 0
           )) = 0;
  END_ENTITY;

  ENTITY text_style_with_justification
    SUBTYPE OF (text_style);
      justification : text_justification;
  END_ENTITY;

  ENTITY text_style_with_mirror
    SUBTYPE OF (text_style);
      mirror_placement : axis2_placement;
  END_ENTITY;

  ENTITY text_style_with_spacing
    SUBTYPE OF (text_style);
      character_spacing : character_spacing_select;
  END_ENTITY;

  ENTITY two_direction_repeat_factor
    SUBTYPE OF (one_direction_repeat_factor);
      second_repeat_factor : vector;
  END_ENTITY;

  SUBTYPE_CONSTRAINT founded_item_subtypes FOR founded_item;
    ONEOF (approximation_tolerance,
      approximation_tolerance_deviation,
      approximation_tolerance_parameter,
      character_glyph_style_outline,
      character_glyph_style_stroke,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      curve_style_font_pattern,
      externally_defined_style,
      fill_area_style,
      point_style,
      pre_defined_presentation_style,
      presentation_style_assignment,
      surface_side_style,
      surface_style_boundary,
      surface_style_control_grid,
      surface_style_fill_area,
      surface_style_parameter_line,
      surface_style_segmentation_curve,
      surface_style_silhouette,
      surface_style_usage,
      symbol_element_style,
      symbol_style,
      text_style);
  END_SUBTYPE_CONSTRAINT;

  SUBTYPE_CONSTRAINT pas_geometric_representation_item_subtypes FOR geometric_representation_item;  
    (ONEOF ( 
     curve, 
     curve_style_curve_pattern, 
     curve_style_curve_pattern_set ,
     externally_defined_hatch_style,
     externally_defined_tile_style,  
     fill_area_style_hatching,
     fill_area_style_tile_coloured_region,
     fill_area_style_tile_curve_with_style, 
     fill_area_style_tile_symbol_with_style, 
     fill_area_style_tiles, 
     one_direction_repeat_factor,
     point, 
     pre_defined_hatch_style,  
     pre_defined_tile_style, 
     vector)); 
  END_SUBTYPE_CONSTRAINT; 

  FUNCTION acyclic_occlusion_precedence
       ( relation : occlusion_precedence;
     set_of_lower : SET OF hiding_or_blanking_select ) : BOOLEAN;
    LOCAL
      x : SET OF occlusion_precedence;
      local_set_of_lower : SET OF hiding_or_blanking_select;
    END_LOCAL;
    REPEAT i:=1 TO HIINDEX(set_of_lower);
      IF relation.higher_precedence :=: set_of_lower[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set (USEDIN ( relation.higher_precedence,
                   'PRESENTATION_APPEARANCE_SCHEMA.'+
           'OCCLUSION_PRECEDENCE.LOWER_PRECEDENCE'));
    local_set_of_lower := set_of_lower + relation.higher_precedence;
    IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
        IF NOT acyclic_occlusion_precedence(x[i] ,
                                     local_set_of_lower) THEN
            RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA; 
(*
ISO TC184/SC4/WG12 N6141 - ISO/IS 10303-46 Visual presentation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N4830
*)

SCHEMA presentation_definition_schema;
 
REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);
 
REFERENCE FROM geometric_model_schema (
	geometric_curve_set);  

REFERENCE FROM geometry_schema
    (axis2_placement,
     b_spline_curve,
     composite_curve,
     curve,
     geometric_representation_item,
     point,
     polyline 
     );
 
REFERENCE FROM measure_schema
    (positive_ratio_measure);
 
REFERENCE FROM presentation_appearance_schema
    (styled_item);

REFERENCE FROM presentation_organization_schema
    (annotation_representation_select);
 
REFERENCE FROM presentation_resource_schema
    (character_glyph_symbol,
     planar_box,
     planar_extent,
     font_select,
     text_font);
 
REFERENCE FROM representation_schema
    (item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation,
     using_representations);

REFERENCE FROM support_resource_schema
    (label,
     text,
     bag_to_set);
     
  TYPE annotation_symbol_occurrence_item = SELECT (
    annotation_symbol,
    defined_symbol); 
  END_TYPE;

  TYPE curve_or_curve_set = SELECT (
    curve,
    geometric_curve_set); 
  END_TYPE;

  TYPE defined_glyph_select = SELECT
    (pre_defined_character_glyph,
     externally_defined_character_glyph);
  END_TYPE;

  TYPE defined_symbol_select = SELECT
    (pre_defined_symbol,
     externally_defined_symbol);
  END_TYPE;

  TYPE text_alignment = label;
  END_TYPE;

  TYPE text_delineation = label;
  END_TYPE;

  TYPE text_or_character = SELECT
    (annotation_text,
     annotation_text_character,
     defined_character_glyph,
     composite_text,
     text_literal);
  END_TYPE;

  TYPE text_path = ENUMERATION OF
    (left,
     right,
     up,
     down);
  END_TYPE;

  TYPE annotation_table_occurrence_item = SELECT(
    annotation_table, 
    defined_table); 
  END_TYPE; 

  TYPE annotation_text_occurrence_item = SELECT(
    text_literal, 
    annotation_text, 
    annotation_text_character, 
    defined_character_glyph, 
    composite_text); 
  END_TYPE; 

  TYPE presentable_text = STRING;
    WHERE
      WR1: control_characters_free(SELF);
  END_TYPE;

  TYPE text_string_representation_item = SELECT(
    text_literal, 
    annotation_text, 
    annotation_text_character, 
    defined_character_glyph, 
    composite_text, 
    axis2_placement); 
  END_TYPE; 

  ENTITY annotation_curve_occurrence
    SUBTYPE OF (annotation_occurrence);
      SELF\styled_item.item : curve_or_curve_set;
  END_ENTITY;

  ENTITY annotation_fill_area
    SUBTYPE OF (geometric_representation_item);
      boundaries : SET [1:?] OF curve;
    WHERE
      WR1: (SELF\geometric_representation_item.dim = 3) OR (SIZEOF (QUERY (curve <* SELF.boundaries |
          NOT (
              ('GEOMETRY_SCHEMA.CIRCLE' IN TYPEOF (curve)) OR 
              ('GEOMETRY_SCHEMA.ELLIPSE' IN TYPEOF (curve)) OR 
              ( ('GEOMETRY_SCHEMA.B_SPLINE_CURVE' IN TYPEOF (curve)) 
                   AND (curve\b_spline_curve.closed_curve = TRUE) ) OR 
              ( ('GEOMETRY_SCHEMA.COMPOSITE_CURVE' IN TYPEOF (curve)) 
                   AND (curve\composite_curve.closed_curve = TRUE) ) OR 
              ( ('GEOMETRY_SCHEMA.POLYLINE' IN TYPEOF (curve)) 
                   AND (curve\polyline.points[LOINDEX(curve\polyline.points)] = 
                        curve\polyline.points[HIINDEX(curve\polyline.points)]) )
              ) )) = 0);
  END_ENTITY;

  ENTITY annotation_fill_area_occurrence
    SUBTYPE OF (annotation_occurrence);
      fill_style_target     : point;
      SELF\styled_item.item : annotation_fill_area;
  END_ENTITY;

  ENTITY annotation_occurrence
    SUPERTYPE OF (ONEOF(annotation_point_occurrence,
                        annotation_curve_occurrence,
                        annotation_fill_area_occurrence,
                        annotation_text_occurrence,
                        annotation_symbol_occurrence))
    SUBTYPE OF (styled_item);
    WHERE
      WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
             TYPEOF (SELF);
      WR2: SIZEOF (QUERY (reps <* using_representations(SELF) | 
        NOT('PRESENTATION_ORGANIZATION_SCHEMA.ANNOTATION_REPRESENTATION_SELECT' IN TYPEOF(reps)))) = 0;
  END_ENTITY;

  ENTITY annotation_occurrence_relationship;
    name                           : label;
    description                    : text;
    relating_annotation_occurrence : annotation_occurrence;
    related_annotation_occurrence  : annotation_occurrence;
  END_ENTITY;

  ENTITY annotation_point_occurrence
    SUBTYPE OF (annotation_occurrence);
    SELF\styled_item.item : point;
  END_ENTITY;

  ENTITY annotation_symbol
    SUBTYPE OF(mapped_item);
      SELF\mapped_item.mapping_source : symbol_representation_map;
      SELF\mapped_item.mapping_target : symbol_target;
    WHERE
      WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
          TYPEOF (SELF);
  END_ENTITY;

  ENTITY annotation_symbol_occurrence
    SUBTYPE OF (annotation_occurrence);
      SELF\styled_item.item : annotation_symbol_occurrence_item;
  END_ENTITY;

  ENTITY annotation_table
    SUBTYPE OF(annotation_symbol);
    WHERE
      WR1: 'PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
          TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
  END_ENTITY;

  ENTITY annotation_table_occurrence
    SUBTYPE OF (annotation_symbol_occurrence);
      SELF\styled_item.item : annotation_table_occurrence_item;
  END_ENTITY;

  ENTITY annotation_text
    SUBTYPE OF (mapped_item); 
      SELF\mapped_item.mapping_target : axis2_placement;
    WHERE
      WR1: 'PRESENTATION_DEFINITION_SCHEMA.TEXT_STRING_REPRESENTATION' IN
        TYPEOF( SELF\mapped_item.mapping_source.mapped_representation);
      WR2: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
        TYPEOF( SELF);
  END_ENTITY;

  ENTITY annotation_text_character
    SUBTYPE OF (mapped_item); 
      alignment                       : text_alignment;
      SELF\mapped_item.mapping_target : axis2_placement;
    WHERE
      WR1: 'PRESENTATION_RESOURCE_SCHEMA.CHARACTER_GLYPH_SYMBOL' IN
         TYPEOF (SELF\mapped_item.mapping_source.mapped_representation);
      WR2: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN
         TYPEOF (SELF);
  END_ENTITY;

  ENTITY annotation_text_occurrence
    SUBTYPE OF (annotation_occurrence);
      SELF\styled_item.item : annotation_text_occurrence_item;
  END_ENTITY;

  ENTITY annotation_text_with_associated_curves
    SUBTYPE OF (annotation_text);
      associated_curves : SET[1:?] of curve;
  END_ENTITY;

  ENTITY annotation_text_with_blanking_box
    SUBTYPE OF (annotation_text);
      blanking : planar_box;
  END_ENTITY;

  ENTITY annotation_text_with_delineation
    SUBTYPE OF (annotation_text);
      delineation : text_delineation;
  END_ENTITY;

  ENTITY annotation_text_with_extent
    SUBTYPE OF (annotation_text);
      extent : planar_extent;
  END_ENTITY;

  ENTITY composite_text
    SUBTYPE OF (geometric_representation_item);
      collected_text : SET[2:?] of text_or_character;
    WHERE
      WR1: acyclic_composite_text( SELF, SELF.collected_text);
  END_ENTITY;

  ENTITY composite_text_with_associated_curves
    SUBTYPE OF (composite_text);
      associated_curves : SET[1:?] of curve;
  END_ENTITY;

  ENTITY composite_text_with_blanking_box
    SUBTYPE OF (composite_text);
      blanking : planar_box;
  END_ENTITY;

  ENTITY composite_text_with_delineation
    SUBTYPE OF (composite_text);
      delineation : text_delineation;
  END_ENTITY;

  ENTITY composite_text_with_extent
    SUBTYPE OF (composite_text);
      extent : planar_extent;
  END_ENTITY;

  ENTITY defined_character_glyph
    SUBTYPE OF(geometric_representation_item);
      definition : defined_glyph_select;
      placement  : axis2_placement;
  END_ENTITY;

  ENTITY defined_symbol
    SUBTYPE OF(geometric_representation_item);
      definition : defined_symbol_select;
      target     : symbol_target;
  END_ENTITY;

  ENTITY defined_table
    SUBTYPE OF(defined_symbol);
  END_ENTITY;

  ENTITY externally_defined_character_glyph
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_symbol
    SUBTYPE OF (externally_defined_item);
  END_ENTITY;

  ENTITY pre_defined_character_glyph
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY pre_defined_symbol
    SUBTYPE OF (pre_defined_item);
  END_ENTITY;

  ENTITY symbol_representation
    SUBTYPE OF (representation);
  END_ENTITY;

  ENTITY symbol_representation_map
    SUBTYPE OF (representation_map);
      SELF\representation_map.mapped_representation : symbol_representation;
      SELF\representation_map.mapping_origin        : axis2_placement;
  WHERE
    WR1: SIZEOF(
           QUERY(mi <* SELF\representation_map.map_usage | NOT('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_SYMBOL' IN TYPEOF(mi)))
         ) = 0; 
  END_ENTITY;

  ENTITY symbol_representation_relationship
    SUBTYPE OF (representation_relationship_with_transformation);
      SELF\representation_relationship.rep_1 : symbol_representation;
      SELF\representation_relationship.rep_2 : symbol_representation;
    WHERE
      WR1: acyclic_symbol_representation_relationship (SELF,
                                                     [SELF\representation_relationship.
                                                           rep_2]);
  END_ENTITY;

  ENTITY symbol_representation_with_blanking_box
    SUBTYPE OF (symbol_representation);
      blanking : planar_box;
    WHERE
      WR1: item_in_context (SELF.blanking, SELF\representation.context_of_items);
  END_ENTITY;

  ENTITY symbol_target
    SUBTYPE OF (geometric_representation_item);
      placement         : axis2_placement;
      x_scale           : positive_ratio_measure;
      y_scale           : positive_ratio_measure;
  END_ENTITY;

  ENTITY table_representation
    SUBTYPE OF (symbol_representation);
    WHERE
      WR1: (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_1') | 
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr)) 
            )) = 0) AND 
            (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                      'REPRESENTATION_RELATIONSHIP.REP_2') | 
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr)) 
            )) = 0);
  END_ENTITY;

  ENTITY table_record_field_representation
    SUBTYPE OF (symbol_representation);
    WHERE
      WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                     'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
           (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                                   'REPRESENTATION_MAP.'+ 
                                                   'MAPPED_REPRESENTATION') | 
            SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                                 'MAPPED_ITEM.'+
                                                 'MAPPING_SOURCE') |   
            SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                          'PRESENTATION_DEFINITION_SCHEMA.'+
                                          'TABLE_RECORD_REPRESENTATION' IN 
                                          TYPEOF (rep))) > 0
            )) > 0))  
               > 0);
  END_ENTITY;

  ENTITY table_record_field_representation_with_clipping_box
    SUBTYPE OF (table_record_field_representation);
      clipping_box : planar_box;
    WHERE
      WR1: item_in_context (SELF.clipping_box, 
                            SELF\representation.context_of_items);
  END_ENTITY;

  ENTITY table_record_representation
    SUBTYPE OF (symbol_representation);
    WHERE
      WR1: (SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                'REPRESENTATION_RELATIONSHIP.REP_2')) > 0) 
                        OR 
           (SIZEOF(QUERY( map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                                   'REPRESENTATION_MAP.'+ 
                                                   'MAPPED_REPRESENTATION') | 
            SIZEOF(QUERY( mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.'+
                                                 'MAPPED_ITEM.'+
                                                 'MAPPING_SOURCE') |   
	        SIZEOF(QUERY( rep <* using_representations (mi) |                              
	                             'PRESENTATION_DEFINITION_SCHEMA.'+
	                              'TABLE_REPRESENTATION' IN 
	                              TYPEOF (rep))) > 0

            )) > 0))  
               > 0);
      WR2: (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_1') | 
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr)) 
            )) = 0) AND 
            (SIZEOF (QUERY (trr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                 'REPRESENTATION_RELATIONSHIP.REP_2') | 
            NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION_RELATIONSHIP' IN TYPEOF (trr)) 
            )) = 0);
  END_ENTITY;

  ENTITY table_representation_relationship
    SUBTYPE OF (symbol_representation_relationship);
    WHERE
      WR1: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
            TYPEOF (SELF\representation_relationship.rep_1))   
           OR
           ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_2));
      WR2: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_1))   
           OR
           ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_2));
      WR3: NOT ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_1)) 
           OR
           ('PRESENTATION_DEFINITION_SCHEMA.TABLE_RECORD_FIELD_REPRESENTATION' IN
           TYPEOF (SELF\representation_relationship.rep_2));
  END_ENTITY;

  ENTITY table_text_relationship
    SUBTYPE OF (annotation_occurrence_relationship);
      field : table_record_field_representation;
      SELF\annotation_occurrence_relationship.relating_annotation_occurrence : annotation_table_occurrence; 
      SELF\annotation_occurrence_relationship.related_annotation_occurrence : annotation_text_occurrence; 
    WHERE
      WR1: 'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TABLE'
         IN TYPEOF (SELF\annotation_occurrence_relationship.
                  relating_annotation_occurrence\styled_item.item);
      WR2: field_in_table (SELF.field,
                           SELF\annotation_occurrence_relationship.
                                relating_annotation_occurrence);
  END_ENTITY;

  ENTITY text_literal
    SUBTYPE OF (geometric_representation_item);
      literal   : presentable_text;
      placement : axis2_placement;
      alignment : text_alignment;
      path      : text_path;
      font      : font_select;
  END_ENTITY;

  ENTITY text_literal_with_associated_curves
    SUBTYPE OF (text_literal);
      associated_curves : SET[1:?] of curve;
  END_ENTITY;

  ENTITY text_literal_with_blanking_box
    SUBTYPE OF (text_literal);
      blanking : planar_box;
  END_ENTITY;

  ENTITY text_literal_with_delineation
    SUBTYPE OF (text_literal);
      delineation : text_delineation;
  END_ENTITY;

  ENTITY text_literal_with_extent
    SUBTYPE OF (text_literal);
      extent : planar_extent;
  END_ENTITY;

  ENTITY text_string_representation
    SUBTYPE OF (representation);
      SELF\representation.items : SET[1:?] OF text_string_representation_item; 
    WHERE
      WR1: SIZEOF (
         QUERY (item <* SELF\representation.items |
           NOT (SIZEOF (['PRESENTATION_DEFINITION_SCHEMA.TEXT_LITERAL',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                         'PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT_CHARACTER',
                         'PRESENTATION_DEFINITION_SCHEMA.DEFINED_CHARACTER_GLYPH',
                         'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                 TYPEOF (item)) = 0)
         )) >= 1;
     WR2: SIZEOF (
         QUERY (a2p <* 
           QUERY (item <* SELF\representation.items | 
             'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF (item)) |
           NOT ((SIZEOF (
             QUERY (at <* 
               QUERY (item <* SELF\representation.items | 
                  'PRESENTATION_DEFINITION_SCHEMA.' + 
                  'ANNOTATION_TEXT' IN TYPEOF (item)) | 
               (at\mapped_item.mapping_target :=: a2p))) >= 1) OR
           (SIZEOF (
             QUERY (atc <* 
               QUERY (item <* SELF\representation.items |
                 'PRESENTATION_DEFINITION_SCHEMA.' + 
                 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF (item)) | 
               (atc\mapped_item.mapping_target :=: a2p))) >= 1)
          ))) = 0;
  END_ENTITY;

  SUBTYPE_CONSTRAINT pds_geometric_representation_item_subtypes FOR geometric_representation_item;  
    (ONEOF ( 
      annotation_fill_area,
      composite_text,
      curve,
      defined_character_glyph,
      defined_symbol,
      point,
      symbol_target,
      text_literal)); 
  END_SUBTYPE_CONSTRAINT; 

  FUNCTION acyclic_composite_text(start_composite : composite_text;
                                child_text : SET [1:?] OF
                                text_or_character) : LOGICAL;
    LOCAL
      i : INTEGER;
      local_composite_text : SET [0:?] OF composite_text;
      local_annotation_text : SET [0:?] OF annotation_text;
      local_children : SET [0:?] OF text_or_character;
    END_LOCAL;

    local_composite_text := QUERY (child <* child_text |
                          ('PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'
                           IN TYPEOF (child)));

    IF (SIZEOF (local_composite_text) > 0) 
      THEN
        REPEAT i := 1 TO HIINDEX (local_composite_text);
          IF (start_composite :=: local_composite_text[i]) 
            THEN
              RETURN (FALSE);
          END_IF;
        END_REPEAT;
    END_IF;

    local_children := child_text;

    IF (SIZEOF (local_composite_text)) > 0 THEN
      REPEAT i := 1 TO HIINDEX (local_composite_text);
        local_children := local_children +
                          local_composite_text[i].collected_text;
      END_REPEAT;
    END_IF;

    local_annotation_text := QUERY (child <* child_text |
                            ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT'
                             IN TYPEOF (child)));

    IF (SIZEOF (local_annotation_text) > 0) THEN
      REPEAT i := 1 TO HIINDEX (local_annotation_text);
        local_children := local_children +
        QUERY (item <* local_annotation_text[i]\mapped_item.
                       mapping_source.mapped_representation.items |
          SIZEOF(['PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_TEXT',
                  'PRESENTATION_DEFINITION_SCHEMA.COMPOSITE_TEXT'] *
                  TYPEOF(item)) > 0);
      END_REPEAT;
    END_IF;

    IF (local_children :<>: child_text) THEN
      RETURN (acyclic_composite_text (start_composite, local_children));
    ELSE
      RETURN (TRUE);
    END_IF;

  END_FUNCTION;

  FUNCTION acyclic_symbol_representation_relationship
    (relation : symbol_representation_relationship;
     children : SET OF symbol_representation ) : BOOLEAN;
    LOCAL
      x : SET OF symbol_representation_relationship;
      local_children : SET OF symbol_representation;
    END_LOCAL;
 
    REPEAT i:=1 TO HIINDEX(children);
      IF relation\representation_relationship.rep_1 :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
 
    x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                  'REPRESENTATION_SCHEMA.'+
                  'REPRESENTATION_RELATIONSHIP.'+ 'REP_2'));
    local_children := children + relation\representation_relationship.rep_1;
 
    IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
        IF NOT acyclic_symbol_representation_relationship(x[i] , 
                                                  local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
 
    RETURN (TRUE);
 
  END_FUNCTION;

  FUNCTION control_characters_free 
    (s : STRING) : BOOLEAN;

    LOCAL
      ch : STRING;
    END_LOCAL;

    REPEAT i:=1 TO LENGTH(s);
      ch := s[i];
      IF (ch = '\x9') OR (ch = '\xA') OR (ch = '\xD') THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);

  END_FUNCTION;

  FUNCTION field_in_table (field : table_record_field_representation;
                           table : annotation_table_occurrence): BOOLEAN;
    LOCAL
      table_rep : table_representation;
      symbol_rep_rel_set : SET OF symbol_representation_relationship;
      mapped_item_set : SET OF mapped_item;
      table_record_rep_set : SET OF table_record_representation := [];
    END_LOCAL;
 
    table_rep := table\styled_item.item\mapped_item.mapping_source.
      mapped_representation;
    mapped_item_set := QUERY(item <* table_rep.items |
                         ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                          TYPEOF(item))
                                   AND
                         ('PRESENTATION_DEFINITION_SCHEMA.'+
                          'TABLE_RECORD_REPRESENTATION' IN
                           TYPEOF(item\mapped_item.mapping_source.
                                      mapped_representation ))
                       );
 
    REPEAT i := 1 TO HIINDEX(mapped_item_set);
      table_record_rep_set := table_record_rep_set +
             mapped_item_set[i].mapping_source.mapped_representation;
    END_REPEAT;
 
    symbol_rep_rel_set := bag_to_set (USEDIN(table_rep, 
                                 'REPRESENTATION_SCHEMA.'+
                                 'REPRESENTATION_RELATIONSHIP.REP_1'));
 
    REPEAT i := 1 TO HIINDEX(symbol_rep_rel_set);
       table_record_rep_set := table_record_rep_set +
                symbol_rep_rel_set[i]\representation_relationship.rep_2;
    END_REPEAT;
 
    IF SIZEOF(QUERY( table_record_rep <* table_record_rep_set |
                (SIZEOF(QUERY( rep_rel <* USEDIN(table_record_rep,
                              'REPRESENTATION_SCHEMA.'+
                              'REPRESENTATION_RELATIONSHIP.REP_1') |
                         ('PRESENTATION_DEFINITION_SCHEMA.' +
                         'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rep_rel)) AND  
                         (rep_rel.rep_2 :=: field)
                         )) > 0)
                         OR
                (SIZEOF(QUERY(item <* table_record_rep.items |
                          ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN
                           TYPEOF(item))
                                   AND
                          (field :=: item\mapped_item.mapping_source.
                                      mapped_representation )
                           )) > 0)
               )) = 0 THEN
      RETURN(FALSE);
    END_IF;
 
    RETURN(TRUE);
 
  END_FUNCTION;

END_SCHEMA; 
(*
ISO TC184/SC4/WG12 N6141 - ISO/IS 10303-46 Visual presentation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N4830
*) 


SCHEMA presentation_organization_schema;

REFERENCE FROM presentation_resource_schema
   (colour,
    planar_box,
    planar_extent,
    presentation_scaled_placement);

REFERENCE FROM presentation_definition_schema
    (annotation_occurrence,
     symbol_representation,
     symbol_representation_relationship);

REFERENCE FROM presentation_appearance_schema
    (styled_item);

REFERENCE FROM geometry_schema
    (axis2_placement,    
     axis2_placement_2d,
     axis2_placement_3d,
     cartesian_point,
     curve,
     direction,
     dot_product,
     geometric_representation_context,
     geometric_representation_item,
     placement,
     plane
     );
 
REFERENCE FROM representation_schema
    (founded_item,
     item_defined_transformation,
     item_in_context,
     mapped_item,
     representation,
     representation_item,
     representation_map,
     representation_relationship,
     representation_relationship_with_transformation,
     using_representations);
 
REFERENCE FROM measure_schema
   (length_measure,
    positive_ratio_measure,
    positive_plane_angle_measure);
 
REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text,
     bag_to_set);

  TYPE area_or_view = SELECT 
    (presentation_area,
     presentation_view);
  END_TYPE;

  TYPE camera_model_d3_multi_clipping_interection_select = SELECT ( 
    camera_model_d3_multi_clipping_union, 
    plane); 
  END_TYPE; 
 
  TYPE camera_model_d3_multi_clipping_union_select = SELECT ( 
    camera_model_d3_multi_clipping_intersection, 
    plane); 
  END_TYPE; 

  TYPE central_or_parallel = ENUMERATION OF 
    (central, 
     parallel);
  END_TYPE;

  TYPE layered_item = SELECT 
    (presentation_representation,
     representation_item);
  END_TYPE;

  SUBTYPE_CONSTRAINT pos_geometric_representation_item_subtypes FOR geometric_representation_item;  
      (ONEOF ( 
    camera_model, 
    camera_model_d3_multi_clipping_intersection,
    camera_model_d3_multi_clipping_union, 
    curve,
    direction,
    light_source)); 
  END_SUBTYPE_CONSTRAINT; 

  TYPE presentation_representation_select = SELECT 
    (presentation_representation,
     presentation_set);
  END_TYPE;

  TYPE presentation_size_assignment_select = SELECT 
    (presentation_view,
     presentation_area,
     area_in_set);
  END_TYPE;

  TYPE annotation_representation_select = EXTENSIBLE SELECT (
    area_dependent_annotation_representation, 
    presentation_area,
    presentation_view,
    symbol_representation,
    view_dependent_annotation_representation);
  END_TYPE;

  TYPE area_dependent_annotation_representation_item = SELECT (
    annotation_occurrence, 
    axis2_placement); 
  END_TYPE;

  TYPE product_data_representation_view_item = SELECT (
    camera_image, 
    axis2_placement); 
  END_TYPE; 

  TYPE view_dependent_annotation_representation_item = SELECT (
    annotation_occurrence, 
    axis2_placement); 
  END_TYPE;

  ENTITY area_dependent_annotation_representation
    SUBTYPE OF (presentation_representation);
      SELF\representation.items : SET[1:?] OF area_dependent_annotation_representation_item; 
    WHERE
      WR1: SIZEOF (QUERY (item <* SELF\representation.items | 
        ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
        TYPEOF (item))
        )) >= 1;
      WR2: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
                                  OR 
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                             'REPRESENTATION_MAP.'+ 
                                             'MAPPED_REPRESENTATION') | 
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |   
            SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                           'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                           'PRESENTATION_AREA' IN 
                                           TYPEOF (rep))) > 0
            )) > 0))  
            > 0);
      WR3: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
           NOT('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
           TYPEOF (prr\representation_relationship.rep_1)))) = 0)
                                  AND 
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                             'REPRESENTATION_MAP.'+ 
                                             'MAPPED_REPRESENTATION') | 
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |   
            SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                      NOT('PRESENTATION_ORGANIZATION_SCHEMA.'+
                                          'PRESENTATION_AREA' IN 
                                          TYPEOF (rep)))) > 0
            )) > 0))  
            = 0);
  END_ENTITY;

  ENTITY area_in_set;
    area   : presentation_area;
    in_set : presentation_set;
  END_ENTITY;

  ENTITY background_colour
    SUBTYPE OF (colour);
      presentation : area_or_view;
    UNIQUE
      UR1:  presentation;
  END_ENTITY;

  ENTITY camera_image
    SUPERTYPE OF(ONEOF(camera_image_2d_with_scale,
  	  camera_image_3d_with_scale))
    SUBTYPE OF (mapped_item); 
      SELF\mapped_item.mapping_source : camera_usage;
      SELF\mapped_item.mapping_target : planar_box;
    WHERE
      WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM'
        IN TYPEOF (SELF);
  END_ENTITY;

  ENTITY camera_image_2d_with_scale
    SUBTYPE OF (camera_image);
    DERIVE
      scale : positive_ratio_measure := (SELF\mapped_item.mapping_target\planar_extent.size_in_x)/
      (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d2.view_window\planar_extent.size_in_x);
    WHERE
      WR1: ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL_D2' IN TYPEOF(SELF\mapped_item.mapping_source.mapping_origin));
      WR2: aspect_ratio (SELF\mapped_item.mapping_target) = aspect_ratio (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d2.view_window);
      WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d2.view_window_clipping;
  END_ENTITY;
 
  ENTITY camera_image_3d_with_scale
    SUBTYPE OF (camera_image);
    DERIVE
      scale: positive_ratio_measure := ((SELF\mapped_item.mapping_target\
           planar_extent.size_in_x) / (SELF\mapped_item.mapping_source.
           mapping_origin\camera_model_d3.perspective_of_volume.view_window.
           size_in_x));
    WHERE
      WR1: ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_MODEL_D3'
         IN TYPEOF (SELF\mapped_item.mapping_source.mapping_origin));
      WR2: aspect_ratio(SELF\mapped_item.mapping_target) =
           aspect_ratio(SELF\mapped_item.mapping_source.mapping_origin\
           camera_model_d3.perspective_of_volume.view_window);
      WR3: SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.front_plane_clipping
           AND
           SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_volume_sides_clipping;
      WR4: (SELF\mapped_item.mapping_target\planar_extent.size_in_x > 0)
           AND
           (SELF\mapped_item.mapping_target\planar_extent.size_in_y > 0);
      WR5: (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_window.size_in_x > 0)
           AND
           (SELF\mapped_item.mapping_source.mapping_origin\camera_model_d3.
           perspective_of_volume.view_window.size_in_y > 0);
      WR6: ('GEOMETRY_SCHEMA.' +
            'AXIS2_PLACEMENT_2D' IN TYPEOF (SELF\mapped_item.
           mapping_target\planar_box.placement))
           AND NOT ('GEOMETRY_SCHEMA.' +
           'AXIS2_PLACEMENT_3D' IN TYPEOF (SELF\mapped_item.
           mapping_target\planar_box.placement));
  END_ENTITY;

  ENTITY camera_model
    ABSTRACT
    SUPERTYPE OF (ONEOF(camera_model_d2, camera_model_d3))
    SUBTYPE OF (geometric_representation_item);
    WHERE
      WR1: (SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                  'ITEM_DEFINED_TRANSFORMATION.' +
                                  'TRANSFORM_ITEM_1')) +
            SIZEOF (USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                  'REPRESENTATION_MAP.MAPPING_ORIGIN'))
            ) > 0;
      WR2: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                              'STYLED_ITEM.ITEM')) = 0;
  END_ENTITY;

  ENTITY camera_model_d2
    SUBTYPE OF (camera_model);
      view_window          : planar_box;
      view_window_clipping : BOOLEAN;
    WHERE
      WR1: SELF\geometric_representation_item.dim = 2;
  END_ENTITY;

  ENTITY camera_model_d2_shape_clipping
    SUBTYPE OF (camera_model_d2);
      shape_clipping : curve;
  END_ENTITY;

  ENTITY camera_model_d3
    SUBTYPE OF (camera_model);
      view_reference_system : axis2_placement_3d;
      perspective_of_volume : view_volume;
    WHERE
      WR1: SELF\geometric_representation_item.dim = 3;
  END_ENTITY;

  ENTITY camera_model_d3_multi_clipping 
    SUBTYPE OF (camera_model_d3); 
      shape_clipping : SET [1:?] OF camera_model_d3_multi_clipping_interection_select; 
  END_ENTITY; 
 
  ENTITY camera_model_d3_multi_clipping_union 
    SUBTYPE OF (geometric_representation_item); 
      shape_clipping : SET [2:?] OF camera_model_d3_multi_clipping_union_select; 
  END_ENTITY;   
 
  ENTITY camera_model_d3_multi_clipping_intersection 
    SUBTYPE OF (geometric_representation_item); 
      shape_clipping : SET [2:?] OF camera_model_d3_multi_clipping_interection_select; 
  END_ENTITY;

  ENTITY camera_model_d3_with_hlhsr
    SUBTYPE OF (camera_model_d3);
      hidden_line_surface_removal : BOOLEAN;
  END_ENTITY;

  ENTITY camera_model_with_light_sources
    SUBTYPE OF (camera_model_d3);
      sources : SET [1:?] OF light_source;
  END_ENTITY;

  ENTITY camera_usage
    SUBTYPE OF (representation_map);
      SELF\representation_map.mapping_origin : camera_model;
    WHERE
      WR1: NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
          IN TYPEOF(SELF\representation_map.mapped_representation));
  END_ENTITY;

  ENTITY graphical_transformation
    SUBTYPE OF (item_defined_transformation);
      SELF\item_defined_transformation.transform_item_1 : axis2_placement_2d;
      SELF\item_defined_transformation.transform_item_2 : presentation_scaled_placement;
  END_ENTITY;

  ENTITY light_source
    SUPERTYPE OF (ONEOF(light_source_ambient,
                        light_source_directional,
                        light_source_positional,
                        light_source_spot))
    SUBTYPE OF (geometric_representation_item);
      light_colour : colour;
    WHERE
      WR1: SIZEOF(USEDIN(SELF,'PRESENTATION_APPEARANCE_SCHEMA.'+
                              'STYLED_ITEM.ITEM')) = 0;
  END_ENTITY;

  ENTITY light_source_ambient
    SUBTYPE OF (light_source);
  END_ENTITY;

  ENTITY light_source_directional
    SUBTYPE OF (light_source);
      orientation : direction;
  END_ENTITY;

  ENTITY light_source_positional
    SUBTYPE OF (light_source);
      position             : cartesian_point;
      constant_attenuation : REAL;
      distance_attenuation : REAL;
  END_ENTITY;

  ENTITY light_source_spot
    SUBTYPE OF (light_source);
      position               : cartesian_point;
      orientation            : direction;
      concentration_exponent : REAL;
      constant_attenuation   : REAL;
      distance_attenuation   : REAL;
      spread_angle           : positive_plane_angle_measure;
  END_ENTITY;

  ENTITY presentation_area
    SUBTYPE OF (presentation_representation);
    WHERE
      WR1: ((SIZEOF (QUERY (ais <* USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                                 'AREA_IN_SET.AREA') | 
             SIZEOF (USEDIN (ais, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                  'PRESENTATION_SIZE.UNIT')) =1)) > 0) OR
            (SIZEOF (USEDIN (SELF, 'PRESENTATION_ORGANIZATION_SCHEMA.' +
                                   'PRESENTATION_SIZE.UNIT')) =1));
  END_ENTITY;

  ENTITY presentation_layer_assignment;
    name           : label;
    description    : text;
    assigned_items : SET [1:?] OF layered_item;
  END_ENTITY;

  ENTITY presentation_layer_usage;
      assignment   : presentation_layer_assignment;
      presentation : presentation_representation;
    UNIQUE
      UR1: assignment, presentation;
  END_ENTITY;

  ENTITY presentation_representation
    SUPERTYPE OF (ONEOF(area_dependent_annotation_representation,
      presentation_area,
      presentation_view,
      product_data_representation_view,
      view_dependent_annotation_representation))
    SUBTYPE OF (representation);
      SELF\representation.context_of_items : geometric_representation_context;
    WHERE
      WR1: SELF\representation.
           context_of_items\geometric_representation_context.
           coordinate_space_dimension = 2;
      WR2: ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN TYPEOF (SELF))
           OR
           (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
           OR 
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                             'REPRESENTATION_MAP.'+ 
                                             'MAPPED_REPRESENTATION') | 
           SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                          'MAPPED_ITEM.'+
                                          'MAPPING_SOURCE') |   
           SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                        'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                        'PRESENTATION_REPRESENTATION' IN 
                                        TYPEOF (rep))) > 0
           )) > 0))  
           > 0);
  END_ENTITY;

  ENTITY presentation_representation_relationship
    SUBTYPE OF (representation_relationship_with_transformation);
      SELF\representation_relationship.rep_1                                       : presentation_representation; 
      SELF\representation_relationship.rep_2                                       : presentation_representation; 
      SELF\representation_relationship_with_transformation.transformation_operator : graphical_transformation;
    WHERE
      WR1: acyclic_presentation_representation_relationship (SELF,
           [SELF\representation_relationship.rep_2]);
      WR2: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA' IN
           TYPEOF (SELF\representation_relationship.rep_1)) 
           AND
           NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'PRODUCT_DATA_REPRESENTATION_VIEW',
                         'PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'VIEW_DEPENDENT_ANNOTATION_REPRESENTATION'] *
           TYPEOF (SELF\representation_relationship.rep_2)) = 0));
      WR3: NOT (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW'
           IN TYPEOF (SELF\representation_relationship.rep_1))
           AND
           NOT (SIZEOF (['PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'PRESENTATION_AREA',
                         'PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'PRESENTATION_VIEW',
                         'PRESENTATION_ORGANIZATION_SCHEMA.' +
                         'AREA_DEPENDENT_ANNOTATION_REPRESENTATION'] *
                TYPEOF (SELF\representation_relationship.rep_2))=0));
      WR4: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF(SELF\representation_relationship.rep_2)))
              XOR
           ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_AREA'IN
           TYPEOF(SELF\representation_relationship.rep_1));
      WR5: (NOT ('PRESENTATION_ORGANIZATION_SCHEMA.' +
                 'PRODUCT_DATA_REPRESENTATION_VIEW' IN
           (TYPEOF(SELF\representation_relationship.rep_1) +
            TYPEOF(SELF\representation_relationship.rep_2))))
              XOR
           ('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
            TYPEOF(SELF\representation_relationship.rep_1))
              AND
           ('PRESENTATION_ORGANIZATION_SCHEMA.PRODUCT_DATA_REPRESENTATION_VIEW' IN
            TYPEOF(SELF\representation_relationship.rep_2));
  END_ENTITY;

  ENTITY presentation_set;
   INVERSE
     areas : SET [1:?] OF area_in_set FOR in_set;
  END_ENTITY;

  ENTITY presentation_size;
      unit : presentation_size_assignment_select;
      size : planar_box;
    UNIQUE
      UR1: unit;
    WHERE
      WR1: (('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_REPRESENTATION'
           IN TYPEOF (SELF.unit)) AND
           item_in_context (SELF.size, 
                            SELF.unit\representation.context_of_items)
           )
           OR
           (('PRESENTATION_ORGANIZATION_SCHEMA.AREA_IN_SET'
           IN TYPEOF (SELF.unit)) AND
           (SIZEOF (QUERY ( ais <* SELF.unit\area_in_set.in_set.areas |
                NOT item_in_context (SELF.size, ais.area\representation.
                                                context_of_items) )) = 0)); 
  END_ENTITY;

  ENTITY presentation_view
    SUBTYPE OF (presentation_representation);
  END_ENTITY;

  ENTITY presented_item
    ABSTRACT SUPERTYPE;
  END_ENTITY;

  ENTITY presented_item_representation;
    presentation : presentation_representation_select;
    item         : presented_item;
  END_ENTITY;

  ENTITY product_data_representation_view
    SUBTYPE OF (presentation_representation);
      SELF\representation.items : SET[1:?] OF product_data_representation_view_item;
    WHERE
      WR1: SIZEOF (QUERY (item <* SELF\representation.items | 
        ('PRESENTATION_ORGANIZATION_SCHEMA.CAMERA_IMAGE' IN
         TYPEOF (item))
        )) >= 1;
      WR2: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
                                  OR 
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                             'REPRESENTATION_MAP.'+ 
                                             'MAPPED_REPRESENTATION') | 
           SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                          'MAPPED_ITEM.'+
                                          'MAPPING_SOURCE') |   
           SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                       'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                       'PRESENTATION_VIEW' IN 
                                        TYPEOF (rep))) > 0
           )) > 0))  
               > 0);
      WR3: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
            NOT('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
            TYPEOF (prr\representation_relationship.rep_1)))) = 0)
                                  AND 
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                             'REPRESENTATION_MAP.'+ 
                                             'MAPPED_REPRESENTATION') | 
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |   
            SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                       NOT('PRESENTATION_ORGANIZATION_SCHEMA.'+
                                           'PRESENTATION_VIEW' IN 
                                       TYPEOF (rep)))) > 0
            )) > 0))  
            = 0);
  END_ENTITY;

  ENTITY representation_item_dependent_layer_assignment
    SUBTYPE OF (presentation_layer_assignment);
      item_context : representation_item;
  END_ENTITY;

  ENTITY view_dependent_annotation_representation
    SUBTYPE OF (presentation_representation);
      SELF\representation.items : SET [1:?] OF view_dependent_annotation_representation_item;
    WHERE
      WR1: SIZEOF (QUERY (item <* SELF\representation.items |
        ('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN
        TYPEOF (item))
        )) >= 1;
      WR2: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
           'PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF (prr\representation_relationship.rep_1))) > 0)
                                  OR 
          (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                            'REPRESENTATION_MAP.'+ 
                                            'MAPPED_REPRESENTATION') | 
           SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                          'MAPPED_ITEM.'+
                                          'MAPPING_SOURCE') |   
           SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                       'PRESENTATION_ORGANIZATION_SCHEMA.'+
                                       'PRESENTATION_VIEW' IN 
                                        TYPEOF (rep))) > 0
           )) > 0))  
           > 0);
      WR3: (SIZEOF (QUERY (prr <* USEDIN (SELF, 'REPRESENTATION_SCHEMA.' +
                                                'REPRESENTATION_RELATIONSHIP.REP_2') | 
           NOT('PRESENTATION_ORGANIZATION_SCHEMA.PRESENTATION_VIEW' IN
           TYPEOF (prr\representation_relationship.rep_1)))) = 0)
                                  AND 
           (SIZEOF(QUERY( rm <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.'+ 
                                             'REPRESENTATION_MAP.'+ 
                                             'MAPPED_REPRESENTATION') | 
            SIZEOF(QUERY( mi <* USEDIN(rm, 'REPRESENTATION_SCHEMA.'+
                                           'MAPPED_ITEM.'+
                                           'MAPPING_SOURCE') |   
            SIZEOF(QUERY( rep <* using_representations (mi) |                              
                                      NOT('PRESENTATION_ORGANIZATION_SCHEMA.'+
                                          'PRESENTATION_VIEW' IN 
                                      TYPEOF (rep)))) > 0
           )) > 0))  
           = 0);
  END_ENTITY;

  ENTITY view_volume
    SUBTYPE OF (founded_item);
      projection_type            : central_or_parallel;
      projection_point           : cartesian_point;
      view_plane_distance        : length_measure;
      front_plane_distance       : length_measure;
      front_plane_clipping       : BOOLEAN;
      back_plane_distance        : length_measure;
      back_plane_clipping        : BOOLEAN;
      view_volume_sides_clipping : BOOLEAN;
      view_window                : planar_box;
    INVERSE
      camera_usages : SET[1:?] OF camera_model_d3 FOR perspective_of_volume;
    WHERE
      WR1:('GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D' IN TYPEOF(SELF\view_volume.view_window.placement)) OR
  (dot_product ((representation_item(' ') || geometric_representation_item() || direction([0.0,0.0,1.0])),
    SELF.view_window\planar_box.placement\axis2_placement_3d.p[3] ) = 1.0);
    WR2: view_plane_distance = view_window.placement\placement.location.coordinates[3];
  END_ENTITY;

  RULE symbol_representation_rule
    FOR (presentation_representation_relationship);
    WHERE
      WR1: SIZEOF(QUERY(each_1 <* presentation_representation_relationship  |
                NOT ('PRESENTATION_DEFINITION_SCHEMA.'+
                'SYMBOL_REPRESENTATION_RELATIONSHIP' IN TYPEOF(each_1)) AND
          (SIZEOF(QUERY(each_2 <* [each_1\representation_relationship.rep_1,
                                   each_1\representation_relationship.rep_2] |
          'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN TYPEOF(each_2)
          )) > 0)
          )) = 0;
  END_RULE;

  FUNCTION acyclic_presentation_representation_relationship
    ( relation : presentation_representation_relationship;
      children : SET OF presentation_representation ) : BOOLEAN;

    LOCAL
      x : SET OF presentation_representation_relationship;
      local_children : SET OF presentation_representation;
    END_LOCAL;

    REPEAT i:=1 TO HIINDEX(children);
      IF relation\representation_relationship.rep_1 :=: children[i] THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;

    x := bag_to_set (USEDIN ( relation\representation_relationship.rep_1,
                  'REPRESENTATION_SCHEMA.'+
                  'REPRESENTATION_RELATIONSHIP.REP_2'));
    local_children := children + relation\representation_relationship.rep_1;

    IF SIZEOF (x) > 0 THEN
      REPEAT i:=1 TO HIINDEX (x);
        IF NOT acyclic_presentation_representation_relationship
          (x[i] , local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;

    RETURN (TRUE);

  END_FUNCTION;

  FUNCTION aspect_ratio (p : planar_box) : positive_ratio_measure;
    IF (p.size_in_x > 0.) AND (p.size_in_y > 0.) THEN
      RETURN (p.size_in_x / p.size_in_y);
    ELSE
      RETURN (?);
    END_IF;
  END_FUNCTION; 

END_SCHEMA; 
(*
ISO TC184/SC4/WG12 N6141 - ISO/IS 10303-46 Visual presentation - EXPRESS
Supersedes ISO TC184/SC4/WG12 N4830
*) 


SCHEMA presentation_resource_schema;

REFERENCE FROM external_reference_schema
    (externally_defined_item,
     pre_defined_item);

REFERENCE FROM geometry_schema
    (axis2_placement,
     curve,
     geometric_representation_item
     );

REFERENCE FROM measure_schema
    (length_measure,
     positive_length_measure,
     positive_ratio_measure,
     ratio_measure);

REFERENCE FROM presentation_definition_schema
    (annotation_fill_area,
     symbol_representation);

REFERENCE FROM representation_schema
    (item_in_context,
     representation);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);
 

TYPE font_select = SELECT
  (pre_defined_text_font,
   externally_defined_text_font,
   text_font);
END_TYPE;

TYPE staircase_or_linear = ENUMERATION OF 
  (staircase, 
   linear);
END_TYPE;


ENTITY character_glyph_font_usage;
  character : generic_character_glyph_symbol;
  font      : text_font;
END_ENTITY;

ENTITY character_glyph_symbol
  SUBTYPE OF (generic_character_glyph_symbol);
  character_box  : planar_extent;
  baseline_ratio : ratio_measure;
DERIVE
  box_height : length_measure := character_box.size_in_y;
WHERE
  WR1: {0.0 <= baseline_ratio <= 1.0};
  WR2: item_in_context(SELF.character_box, 
                       SELF\representation.context_of_items);
  WR3: 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE'
        IN TYPEOF (SELF.box_height);
END_ENTITY;

ENTITY character_glyph_symbol_outline
  SUBTYPE OF (character_glyph_symbol);
  outlines : SET [1:?] OF annotation_fill_area;
WHERE
  WR1: SELF.outlines <= SELF\representation.items;
END_ENTITY;

ENTITY character_glyph_symbol_stroke
  SUBTYPE OF (character_glyph_symbol);
  strokes : SET [1:?] OF curve;
WHERE
  WR1: SELF.strokes <= SELF\representation.items;
END_ENTITY;

ENTITY colour;
END_ENTITY;

ENTITY colour_associated
  SUBTYPE OF (colour);
  name : label;
  variable_to_be_shown : SET [1:?] OF REAL;
  mapping              : colour_association_table;
END_ENTITY;

ENTITY colour_association_table;
  discrete_states_with_colours : LIST [1:?] OF state_variable_with_colour;
  interpolation_type           : staircase_or_linear;
END_ENTITY;

ENTITY colour_rgb
  SUBTYPE OF (colour_specification);
  red   : REAL;
  green : REAL;
  blue  : REAL;
WHERE
  WR1: {0.0 <= red <= 1.0};
  WR2: {0.0 <= green <= 1.0};
  WR3: {0.0 <= blue <= 1.0};
END_ENTITY;

ENTITY colour_specification
  SUBTYPE OF (colour);
  name : label;
END_ENTITY;

ENTITY draughting_pre_defined_colour
  SUBTYPE OF (pre_defined_colour);
WHERE
  WR1: SELF.name IN
      ['red',
       'green',
       'blue',
       'yellow',
       'magenta',
       'cyan',
       'black',
       'white'];
END_ENTITY;

ENTITY draughting_pre_defined_text_font
   SUBTYPE of (pre_defined_text_font);
WHERE
   WR1: SELF.name[1:8] = 'ISO 3098';
END_ENTITY;

ENTITY externally_defined_text_font
  SUBTYPE OF (externally_defined_item);
END_ENTITY;

ENTITY generic_character_glyph_symbol
  ABSTRACT SUPERTYPE
  SUBTYPE OF (symbol_representation);
END_ENTITY; 

ENTITY planar_box
  SUBTYPE OF (planar_extent);
  placement:  axis2_placement;
END_ENTITY;

ENTITY planar_extent
  SUBTYPE OF (geometric_representation_item);
   size_in_x : length_measure;
   size_in_y : length_measure;
END_ENTITY;

ENTITY pre_defined_colour
  SUBTYPE OF (pre_defined_item, colour);
END_ENTITY;

ENTITY pre_defined_text_font
  SUBTYPE OF (pre_defined_item);
END_ENTITY;

ENTITY presentation_scaled_placement 
  SUBTYPE OF (geometric_representation_item);
  placement : axis2_placement;
  scaling   : positive_ratio_measure;
END_ENTITY;

ENTITY state_variable_with_colour;
  state_variable    : REAL;
  associated_colour : colour_specification;
END_ENTITY;

ENTITY text_font;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  glyphs : SET [1:?] OF character_glyph_font_usage FOR font;
END_ENTITY;

ENTITY text_font_family;
  id          : identifier;
  name        : label;
  description : text;
INVERSE
  fonts       : SET [1:?] OF text_font_in_family FOR family;
END_ENTITY;

ENTITY text_font_in_family;
  font   : text_font;
  family : text_font_family;
END_ENTITY;

SUBTYPE_CONSTRAINT prs_geometric_representation_item_subtypes FOR geometric_representation_item;  
    (ONEOF ( 
    curve,
	planar_extent,
	presentation_scaled_placement)); 
END_SUBTYPE_CONSTRAINT; 

END_SCHEMA; -- presentation_resource_schema
(* EXTRACTED FROM DOCUMENT ISO TC184/SC4/WG12 N2837 - EXPRESS CODE FOR THE
   IS VERSION OF ISO 10303-55: 'PROCEDURAL & HYBRID REPRESENTATION' *)

SCHEMA procedural_model_schema;

REFERENCE FROM support_resource_schema                  -- ISO 10303-41
  (text);

REFERENCE FROM representation_schema                    -- ISO 10303-43
  (item_in_context,
   representation,
   representation_item,
   representation_item_relationship,
   representation_relationship,
   using_representations);

REFERENCE FROM variational_representation_schema        -- ISO 10303-108
  (variational_representation);

ENTITY explicit_procedural_representation_relationship
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 : procedural_representation;
WHERE
  WR1 : (NOT ('PROCEDURAL_MODEL_SCHEMA.PROCEDURAL_REPRESENTATION' 
    IN TYPEOF(SELF\representation_relationship.rep_2))) AND 
    (NOT ('VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION'
    IN TYPEOF(SELF\representation_relationship.rep_2)));
  WR2 : SELF\representation_relationship.rep_1.context_of_items :=:
    SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY; 

ENTITY explicit_procedural_representation_item_relationship
  SUBTYPE OF (representation_item_relationship);
  SELF\representation_item_relationship.relating_representation_item :
    procedural_representation_sequence;
WHERE
  WR1 : NOT ('PROCEDURAL_MODEL_SCHEMA.PROCEDURAL_REPRESENTATION_SEQUENCE'
    IN TYPEOF(
      SELF\representation_item_relationship.related_representation_item));
  WR2 : SIZEOF(QUERY(q <* using_representations(
    SELF\representation_item_relationship.related_representation_item) |
    item_in_context(
      SELF\representation_item_relationship.relating_representation_item,
      q.context_of_items))) > 0;
END_ENTITY; 

ENTITY procedural_representation
  SUBTYPE OF (representation);
  SELF\representation.items : 
    SET[1:?] OF procedural_representation_sequence;
END_ENTITY; 

ENTITY procedural_representation_sequence
  SUBTYPE OF (representation_item);
  elements         : LIST[1:?] OF representation_item;
  suppressed_items : SET[0:?] OF representation_item;
  rationale        : text;
WHERE
  WR1: SIZEOF(QUERY(q <* suppressed_items | NOT (q IN elements))) = 0;
END_ENTITY;

ENTITY user_selected_elements
  SUBTYPE OF (representation_item);
  picked_items : SET[1:?] OF representation_item;
END_ENTITY; 

ENTITY indirectly_selected_elements
  SUBTYPE OF (user_selected_elements);
  indirectly_picked_items : SET[1:?] OF representation_item;
END_ENTITY; 

END_SCHEMA; -- procedural_model_schema

(* THIS IS EXTRACTED FROM DOCUMENT ISO TC184/SC4/WG12 N2837 - EXPRESS CODE FOR THE 
   IS VERSION OF ISO 10303-55: 'PROCEDURAL & HYBRID REPRESENTATION' *)

SCHEMA procedural_shape_model_schema;

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation);

REFERENCE FROM geometry_schema                          -- ISO 10303-42
  (geometric_representation_item);

REFERENCE FROM topology_schema                          -- ISO 10303-42
  (topological_representation_item);

REFERENCE FROM geometric_model_schema                   -- ISO 10303-42
  (edge_based_wireframe_model,
   face_based_surface_model,
   shell_based_surface_model,
   shell_based_wireframe_model,
   solid_model);

REFERENCE FROM representation_schema                    -- ISO 10303-43
  (representation,
   representation_item_relationship,
   representation_relationship);

REFERENCE FROM procedural_model_schema;                 -- ISO 10303-55 

TYPE shape_representation_item = SELECT
  (geometric_representation_item,
   topological_representation_item);
END_TYPE;

ENTITY explicit_procedural_shape_representation_relationship
  SUBTYPE OF (explicit_procedural_representation_relationship);
  SELF\representation_relationship.rep_1 : procedural_shape_representation; 
  SELF\representation_relationship.rep_2 : shape_representation;
END_ENTITY; 

ENTITY explicit_procedural_geometric_representation_item_relationship
  SUBTYPE OF (explicit_procedural_representation_item_relationship);
  SELF\representation_item_relationship.relating_representation_item :
    procedural_shape_representation_sequence;
  SELF\representation_item_relationship.related_representation_item :
    geometric_representation_item; 
WHERE
  WR1 : NOT (
    'PROCEDURAL_SHAPE_MODEL_SCHEMA.PROCEDURAL_SHAPE_REPRESENTATION_SEQUENCE'
    IN TYPEOF(
      SELF\representation_item_relationship.related_representation_item));
END_ENTITY; 

ENTITY procedural_shape_representation
  SUBTYPE OF (procedural_representation, shape_representation);
  SELF\representation.items : 
    SET[1:?] OF procedural_shape_representation_sequence;
END_ENTITY; 

ENTITY procedural_shape_representation_sequence
  SUBTYPE OF (geometric_representation_item, 
              procedural_representation_sequence);
  SELF\procedural_representation_sequence.elements : LIST [1:?] OF shape_representation_item;              
END_ENTITY; 

ENTITY procedural_solid_representation_sequence
  SUBTYPE OF (procedural_shape_representation_sequence);
WHERE
  WR1 : 'GEOMETRIC_MODEL_SCHEMA.SOLID_MODEL' IN TYPEOF(SELF);
END_ENTITY; 

ENTITY procedural_surface_representation_sequence
  SUBTYPE OF (procedural_shape_representation_sequence);
WHERE
  WR1 : ('GEOMETRIC_MODEL_SCHEMA.FACE_BASED_SURFACE_MODEL' IN TYPEOF(SELF))
    XOR
    ('GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(SELF));
END_ENTITY; 

ENTITY procedural_wireframe_representation_sequence
  SUBTYPE OF (procedural_shape_representation_sequence);
WHERE
WR1 : ('GEOMETRIC_MODEL_SCHEMA.EDGE_BASED_WIREFRAME_MODEL' IN TYPEOF(SELF))
    XOR
    ('GEOMETRIC_MODEL_SCHEMA.SHELL_BASED_WIREFRAME_MODEL' IN TYPEOF(SELF));
END_ENTITY; 

ENTITY user_selected_shape_elements
  SUBTYPE OF (user_selected_elements);
  SELF\user_selected_elements.picked_items : SET [1:?] OF shape_representation_item;
END_ENTITY; 

ENTITY indirectly_selected_shape_elements
  SUBTYPE OF (indirectly_selected_elements,
              user_selected_shape_elements);
  SELF\indirectly_selected_elements.indirectly_picked_items : SET [1:?] OF shape_representation_item;              
END_ENTITY; 

END_SCHEMA; -- procedural_shape_model_schema
(* Genenerated from: ../../irs/10303-049.exp *)

SCHEMA process_property_representation_schema;

REFERENCE FROM support_resource_schema
    (label, 
     text);

REFERENCE FROM representation_schema
    (representation);

REFERENCE FROM process_property_schema
    (action_property, 
     resource_property);

ENTITY action_property_representation;
  name           : label;
  description    : text;
  property       : action_property;
  representation : representation;
END_ENTITY;

ENTITY resource_property_representation;
  name           : label;
  description    : text;
  property       : resource_property;
  representation : representation;
END_ENTITY;

END_SCHEMA; -- process_property_representation_schema
(* Genenerated from: ../../irs/10303-049.exp *)

SCHEMA process_property_schema;

REFERENCE FROM action_schema
    (action, 
     action_method,
     action_method_relationship,
     action_relationship,
     action_resource,
     action_resource_relationship,
     acyclic_action_relationship);

REFERENCE FROM product_property_definition_schema
    (characterized_product_definition,
     property_definition, 
     shape_definition);

REFERENCE FROM support_resource_schema
    (identifier,
     label,
     text);

TYPE characterized_action_definition = SELECT
   (action,
   action_method,
   action_method_relationship,
   action_relationship);
END_TYPE;

TYPE characterized_resource_definition = SELECT
  (action_resource,
   action_resource_relationship,
   action_resource_requirement,
   action_resource_requirement_relationship);
END_TYPE;

TYPE property_or_shape_select = SELECT
     (property_definition,
      shape_definition);
END_TYPE;

ENTITY action_property;
  name        : label;
  description : text;
  definition  : characterized_action_definition;
END_ENTITY;

ENTITY product_definition_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE 
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;

ENTITY process_product_association;
  name            : label;
  description     : text;
  defined_product : characterized_product_definition;
  process         : product_definition_process;
END_ENTITY;

ENTITY property_process
  SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;

ENTITY process_property_association;
  name              : label;
  description       : text;
  process           : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;

ENTITY replacement_relationship
  SUBTYPE OF (action_relationship);
WHERE
  WR1: acyclic_action_relationship (SELF,
       [SELF\action_relationship.related_action],
       'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
END_ENTITY;

ENTITY resource_property;
  name        : label;
  description : text;
  resource    : characterized_resource_definition;
END_ENTITY;

ENTITY action_resource_requirement;
  name        : label;
  description : text;
  kind        : resource_requirement_type;
  operations  : SET [1:?] OF characterized_action_definition;
END_ENTITY;

ENTITY action_property_relationship;
  name                     : label;
  description              : text;
  relating_action_property : action_property;
  related_action_property  : action_property;
WHERE
  WR1: relating_action_property :<>: related_action_property;
END_ENTITY;

ENTITY requirement_for_action_resource
  SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;

ENTITY resource_property_relationship;
  name                       : label;
  description                : text;
  relating_resource_property : resource_property;
  related_resource_property  : resource_property;
WHERE
  WR1: relating_resource_property :<>: related_resource_property;
END_ENTITY;

ENTITY action_resource_requirement_relationship;
  name                                 : label;
  description                          : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement  : action_resource_requirement;
WHERE
  WR1: relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY;

ENTITY resource_requirement_type;
  name        : label;
  description : text;
END_ENTITY;

ENTITY resource_requirement_type_relationship;
  name                      : label;
  description               : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type  : resource_requirement_type;
WHERE
  WR1: relating_requirement_type :<>: related_requirement_type;
END_ENTITY;

END_SCHEMA; -- process_property_schema
(* Genenerated from: ../../irs/wg12n529.exp *)

SCHEMA product_concept_schema;

  REFERENCE FROM support_resource_schema
    (text, label, identifier);

  REFERENCE FROM application_context_schema
    (product_concept_context);

ENTITY concept_feature_operator;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY concept_feature_relationship;
  name                              : label;
  description                       : OPTIONAL text;
  relating_product_concept_feature  : product_concept_feature;
  related_product_concept_feature   : product_concept_feature;
END_ENTITY;

ENTITY concept_feature_relationship_with_condition
  SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;

ENTITY conditional_concept_feature
  SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;

ENTITY product_concept;
  id                  : identifier;
  name                : label;
  description         : OPTIONAL text;
  market_context      : product_concept_context;
UNIQUE
  UR1: id;
END_ENTITY;

ENTITY product_concept_feature;
  id          : identifier;
  name        : label;
  description : OPTIONAL text;
END_ENTITY;

ENTITY product_concept_feature_association;
  name        : label;
  description : OPTIONAL text;
  concept     : product_concept;
  feature     : product_concept_feature;
END_ENTITY;

ENTITY product_concept_relationship;
  name                     : label;
  description              : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept  : product_concept;
END_ENTITY;

END_SCHEMA; -- product_concept_schema
(*
 ISO TC184/SC4/WG12 N7298 - ISO 10303-59 Quality of product shape data
 Supersedes ISO TC184/SC4/WG12 N5088
*)

SCHEMA product_data_quality_criteria_schema;

  REFERENCE FROM product_data_quality_inspection_result_schema
    (data_quality_inspection_result_representation);

  REFERENCE FROM representation_schema
    (representation,
     representation_item,
     representation_item_relationship);

  REFERENCE FROM support_resource_schema (text, bag_to_set);

  TYPE detailed_report_type = ENUMERATION OF
    (measured_element,
     inferior_quality_element);
  END_TYPE;

  TYPE summary_report_type = ENUMERATION OF
    (unspecified,
     conclusion_only,
     number_of_quality_defects,
     number_of_inspections_and_conclusion,
     full_statistics);
  END_TYPE;

  TYPE preferred_ordering = ENUMERATION OF
    (extremity_order,
     detected_order);
  END_TYPE;

  ENTITY data_quality_criteria_representation
    SUBTYPE OF(representation);
    WHERE
      WR1 :  SIZEOF( QUERY( q <* SELF\representation.items|
                                'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.' +
                                'DATA_QUALITY_CRITERION' IN TYPEOF(q))) > 0;
  END_ENTITY;

  ENTITY data_quality_criterion
    SUBTYPE OF(representation_item);
    WHERE
      WR1 : SIZEOF(QUERY(q <*
              bag_to_set( USEDIN(SELF,
                'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS'))
              |'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
               'DATA_QUALITY_INSPECTION_RESULT_REPRESENTATION'
               IN TYPEOF(q)))=0;
  END_ENTITY;

  ENTITY data_quality_measurement_requirement
    SUBTYPE OF(representation_item);
    WHERE
      WR1 : SIZEOF(QUERY(q <*
              bag_to_set( USEDIN(SELF,
                'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS'))
              |'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
               'DATA_QUALITY_INSPECTION_RESULT_REPRESENTATION'
               IN TYPEOF(q)))=0;
  END_ENTITY;

  ENTITY data_quality_criterion_measurement_association
    SUBTYPE OF(representation_item_relationship);
      SELF\representation_item_relationship.relating_representation_item : data_quality_criterion;
      SELF\representation_item_relationship.related_representation_item  : data_quality_measurement_requirement;
  END_ENTITY;

  ENTITY data_quality_assessment_specification;
      description : text;
  END_ENTITY;

  ENTITY data_quality_criterion_assessment_association;
      criterion                : data_quality_criterion;
      assessment_specification : data_quality_assessment_specification;
  END_ENTITY;

  ENTITY data_quality_assessment_measurement_association;
      assessment_specification : data_quality_criterion_assessment_association;
      measurement_requirement  : data_quality_criterion_measurement_association;
    WHERE
      WR1 : SELF.measurement_requirement\representation_item_relationship.
            relating_representation_item :=:
            SELF.assessment_specification.criterion;
  END_ENTITY;

  ENTITY data_quality_report_request
    ABSTRACT SUPERTYPE OF (ONEOF(summary_report_request, detailed_report_request));
      description                 : text;
      criterion_of_report_request : data_quality_criterion;
  END_ENTITY;

  ENTITY summary_report_request
    SUBTYPE OF(data_quality_report_request);
      summary_report_request_type : summary_report_type;
  END_ENTITY;

  ENTITY detailed_report_request
    SUBTYPE OF(data_quality_report_request);
      detailed_report_request_type : detailed_report_type;
      report_sequence              : preferred_ordering;
  END_ENTITY;

  ENTITY detailed_report_request_with_number_of_data
    SUBTYPE OF(detailed_report_request);
      number_of_data : INTEGER;
    DERIVE
      SELF\detailed_report_request.detailed_report_request_type:detailed_report_type:= measured_element;
  END_ENTITY;



END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N7298 - ISO 10303-59 Quality of product shape data
 Supersedes ISO TC184/SC4/WG12 N5088
*)

SCHEMA product_data_quality_definition_schema;

  REFERENCE FROM product_data_quality_criteria_schema
    (data_quality_criteria_representation);

  REFERENCE FROM product_data_quality_inspection_result_schema
    (data_quality_inspection_result_representation);

  REFERENCE FROM product_definition_schema
    (product_definition);

  REFERENCE FROM support_resource_schema (text);

  TYPE used_quality_representation_select = SELECT
    (data_quality_criteria_representation,
     data_quality_inspection_result_representation);
  END_TYPE;

  ENTITY data_quality_definition;
      description : text;
  END_ENTITY;

  ENTITY data_quality_definition_representation_relationship;
      description         : text;
      definition          : data_quality_definition;
      used_representation : used_quality_representation_select;
  END_ENTITY;

  ENTITY product_data_and_data_quality_relationship;
      description  : text;
      product_data : product_definition;
      data_quality : data_quality_definition;
  END_ENTITY;

  ENTITY data_quality_definition_relationship;
      description                      : text;
      relating_data_quality_definition : data_quality_definition;
      related_data_quality_definition  : data_quality_definition;
  END_ENTITY;

  ENTITY software_for_data_quality_check;
      description      : text;
      software_name    : text;
      software_version : text;
      data_quality     : data_quality_definition_representation_relationship;
  END_ENTITY;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N7298 - ISO 10303-59 Quality of product shape data
 Supersedes ISO TC184/SC4/WG12 N5088
*)

SCHEMA product_data_quality_inspection_result_schema;

  REFERENCE FROM product_data_quality_criteria_schema;

  REFERENCE FROM product_data_quality_definition_schema
    (data_quality_definition_representation_relationship,
     product_data_and_data_quality_relationship);

  REFERENCE FROM product_definition_schema
    (product_definition);

  REFERENCE FROM representation_schema
    (representation,
     representation_item,
     representation_item_relationship);

  REFERENCE FROM support_resource_schema
    (bag_to_set);

  TYPE statistical_value_type = ENUMERATION OF
    (number_of_inspected_instances,
     number_of_quality_defects_detected);
  END_TYPE;

  TYPE inspected_element_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;
  
  ENTITY data_quality_inspection_result_representation
    SUBTYPE OF(representation);
      criteria_inspected : data_quality_criteria_representation;
    WHERE
      WR1 : SIZEOF( QUERY( q <* SELF\representation.items|
                                'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.' +
                                'DATA_QUALITY_INSPECTION_RESULT' IN TYPEOF(q))) > 0;
      WR2 : SIZEOF(inspected_product_definition(SELF)) > 0;
  END_ENTITY;

  ENTITY data_quality_inspection_result
    SUBTYPE OF(representation_item);
      criterion_inspected : data_quality_criterion;
    WHERE
      WR1 : SIZEOF(QUERY(q <* bag_to_set( USEDIN(SELF,
                            'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS'))
                          |'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
                           'DATA_QUALITY_CRITERIA_REPRESENTATION'
                           IN TYPEOF(q)))=0;
  END_ENTITY;

  ENTITY data_quality_inspection_result_with_judgement
    SUBTYPE OF(data_quality_inspection_result);
      judgement : BOOLEAN;
  END_ENTITY;

  ENTITY data_quality_inspection_report
    SUPERTYPE OF (ONEOF(data_quality_inspection_criterion_report, data_quality_inspection_instance_report))
    SUBTYPE OF(representation_item);
      inspection_result : data_quality_inspection_result;
    WHERE
      WR1 : SIZEOF(QUERY(q <* bag_to_set( USEDIN(SELF,
                            'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS'))
                          |'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
                           'DATA_QUALITY_CRITERIA_REPRESENTATION'
                           IN TYPEOF(q)))=0;
  END_ENTITY;

  ENTITY data_quality_inspection_criterion_report
    SUBTYPE OF(data_quality_inspection_report);
      statistical_values : SET [1:2] OF data_quality_inspection_criterion_report_item;
    WHERE
      WR1 : SIZEOF(QUERY(i1<*bag_to_set(USEDIN(
              SELF\data_quality_inspection_report.
              inspection_result.criterion_inspected,
              'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
              'DATA_QUALITY_REPORT_REQUEST.CRITERION_OF_REPORT_REQUEST'))|
              'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
              'SUMMARY_REPORT_REQUEST'
            IN TYPEOF(i1)))>0;
      WR2 : (SIZEOF(SELF.statistical_values) = 1 ) OR 
            (SELF.statistical_values[1].value_type <>
             SELF.statistical_values[2].value_type);
  END_ENTITY;

  ENTITY data_quality_inspection_criterion_report_item
    SUBTYPE OF(representation_item);
      statistical_value : INTEGER;
      value_type        : statistical_value_type;
    WHERE
      WR1 : SIZEOF(QUERY(q <* bag_to_set( USEDIN(SELF,
                            'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS'))
                          |'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
                           'DATA_QUALITY_CRITERIA_REPRESENTATION'
                           IN TYPEOF(q)))=0;
  END_ENTITY;

  ENTITY data_quality_inspection_instance_report
    SUBTYPE OF(data_quality_inspection_report);
      inspected_instances : LIST [1:?] OF data_quality_inspection_instance_report_item;
    WHERE
      WR1 : SIZEOF(QUERY(i1<*bag_to_set(USEDIN(
              SELF\data_quality_inspection_report.
              inspection_result.criterion_inspected,
              'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
              'DATA_QUALITY_REPORT_REQUEST.CRITERION_OF_REPORT_REQUEST'))|
              'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
              'DETAILED_REPORT_REQUEST'
            IN TYPEOF(i1)))>0;
  END_ENTITY;

  ENTITY data_quality_inspection_instance_report_item
    SUBTYPE OF(representation_item);
     inspected_elements : SET [1:?] OF inspected_element_select;
    WHERE
      WR1 : SIZEOF(QUERY(q <* bag_to_set( USEDIN(SELF,
                            'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS'))
                          |'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
                           'DATA_QUALITY_CRITERIA_REPRESENTATION'
                           IN TYPEOF(q)))=0;
  END_ENTITY;

  ENTITY data_quality_report_measurement_association
    SUBTYPE OF(representation_item_relationship);
      SELF\representation_item_relationship.relating_representation_item : data_quality_measurement_requirement;
      SELF\representation_item_relationship.related_representation_item  : data_quality_inspection_report;
  END_ENTITY;

  FUNCTION inspected_product_definition
    (dqir:data_quality_inspection_result_representation)
    :BAG OF product_definition;
    LOCAL
      dqdr :BAG OF data_quality_definition_representation_relationship:= [];
      pdqdr :BAG OF product_data_and_data_quality_relationship:= [];
      pd   :BAG OF product_definition:= [];
    END_LOCAL;
    dqdr := USEDIN(dqir,'PRODUCT_DATA_QUALITY_DEFINITION_SCHEMA.'
                       +'DATA_QUALITY_DEFINITION_REPRESENTATION_RELATIONSHIP.'
                       +'USED_REPRESENTATION');
    REPEAT i:= 1 TO SIZEOF(dqdr);
      pdqdr := USEDIN(dqdr[i].definition,
                      'PRODUCT_DATA_QUALITY_DEFINITION_SCHEMA.'
                     +'PRODUCT_DATA_AND_DATA_QUALITY_RELATIONSHIP.'
                     +'DATA_QUALITY');
      REPEAT j:= 1 TO SIZEOF(pdqdr);
        pd := pd + pdqdr[j].product_data; 
      END_REPEAT;
    END_REPEAT;
    RETURN(pd);
  END_FUNCTION;



END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA product_definition_schema;

  REFERENCE FROM application_context_schema (
    product_context, 
    product_definition_context);
  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    get_name_value, 
    id_attribute,
    id_attribute_select,
    name_attribute,
    name_attribute_select);
  REFERENCE FROM product_property_definition_schema (
    characterized_object);
  REFERENCE FROM document_schema (
    document);
  REFERENCE FROM effectivity_schema (
    effectivity);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  REFERENCE FROM external_reference_schema (
    external_source);
    
  TYPE product_definition_or_reference = SELECT (
    product_definition, 
    generic_product_definition_reference);
  END_TYPE;
    
  TYPE pds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    product_category);
  END_TYPE;
  TYPE pds_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    product_definition,
    product_definition_substitute);
  END_TYPE;
  
  TYPE source = ENUMERATION OF (made, bought, not_known);
  END_TYPE;

  ENTITY characterized_product
    SUBTYPE OF (characterized_object, product);
  END_ENTITY;

  ENTITY generic_product_definition_reference
    ABSTRACT SUPERTYPE OF ( ONEOF ( product_definition_reference, product_definition_reference_with_local_representation) );
    source : external_source;
  END_ENTITY;
 
  ENTITY product;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY;

  ENTITY product_category;
    name : label;
    description : OPTIONAL text;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_category_relationship;
    name : label;
    description : OPTIONAL text;
    category : product_category;
    sub_category : product_category;
  WHERE
    WR1: acyclic_product_category_relationship(SELF, [SELF.sub_category]);
  END_ENTITY;

  ENTITY product_definition;
    id : identifier;
    description : OPTIONAL text;
    formation : product_definition_formation;
    frame_of_reference : product_definition_context;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_context_association;
    definition : product_definition;
    frame_of_reference : product_definition_context;
    role : product_definition_context_role;
  END_ENTITY;

  ENTITY product_definition_context_role;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY product_definition_effectivity
    SUBTYPE OF (effectivity);
    usage : product_definition_relationship;
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
  END_ENTITY;

  ENTITY product_definition_formation;
    id : identifier;
    description : OPTIONAL text;
    of_product : product;
  UNIQUE
    UR1: id, of_product;
  END_ENTITY;

  ENTITY product_definition_formation_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product_definition_formation : product_definition_formation;
    related_product_definition_formation : product_definition_formation;
  END_ENTITY;

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF (product_definition_formation);
    make_or_buy : source;
  END_ENTITY;

  ENTITY product_definition_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product_definition : product_definition_or_reference;
    related_product_definition : product_definition_or_reference;
  END_ENTITY;

  ENTITY product_definition_reference
    SUBTYPE OF (generic_product_definition_reference);
    product_id : identifier;
    product_definition_formation_id : identifier;
    product_definition_id : identifier;
    id_owning_organization_name : OPTIONAL label;
  END_ENTITY;
 
  ENTITY product_definition_reference_with_local_representation
    SUBTYPE OF (generic_product_definition_reference, product_definition);
  END_ENTITY;
  
  ENTITY product_definition_substitute;
    description : OPTIONAL text;
    context_relationship : product_definition_relationship;
    substitute_definition : product_definition;
  DERIVE
    name : label := get_name_value(SELF);
  WHERE
    WR1: context_relationship.related_product_definition :<>: substitute_definition;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF (product_definition);
    documentation_ids : SET [1:?] OF document;
  END_ENTITY;

  ENTITY product_related_product_category
    SUBTYPE OF (product_category);
    products : SET [1:?] OF product;
  END_ENTITY;

  ENTITY product_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_product : product;
    related_product : product;
  END_ENTITY;

  FUNCTION acyclic_product_category_relationship (relation : product_category_relationship; children : SET OF product_category):BOOLEAN;
    LOCAL
      x : SET OF product_category_relationship;
      local_children : SET OF product_category;
    END_LOCAL;

    REPEAT i := 1 TO HIINDEX(children);
      IF relation.category :=: children[i] THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
    local_children := children + relation.category;
    IF SIZEOF(x) > 0 THEN
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_definition_formation_relationship (relation : product_definition_formation_relationship; relatives : SET [1:?] OF product_definition_formation; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_definition_formation_relationship;
    END_LOCAL;

    IF relation.relating_product_definition_formation IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_definition_relationship (relation : product_definition_relationship; relatives : SET [1:?] OF product_definition; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_definition_relationship;
    END_LOCAL;

    IF relation.relating_product_definition IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_product_relationship (relation : product_relationship; relatives : SET [1:?] OF product; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF product_relationship;
    END_LOCAL;

    IF relation.relating_product IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION categories_of_product
   (obj : product) : SET OF STRING; 
  LOCAL
    category_assignments: BAG OF product_category;
    categories: SET OF STRING:=[];
  END_LOCAL;
    category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
    REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
      categories := categories + category_assignments[i].name;
    END_REPEAT;
    RETURN(categories);
  END_FUNCTION; 

  FUNCTION get_product_definitions (c_def_instance : product):SET OF product_definition;
    LOCAL
      pd_set : SET OF product_definition_formation := [];
      pdr_set : SET OF product_definition := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA product_property_definition_schema;

  REFERENCE FROM process_property_schema (
    action_property, 
    resource_property);
  REFERENCE FROM product_definition_schema (
    product_definition, 
    product_definition_relationship);
  REFERENCE FROM product_structure_schema (
    assembly_component_usage,
    multi_level_reference_designator,
    next_assembly_usage_occurrence);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    identifier, 
    label, 
    text);
  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    id_attribute,
    id_attribute_select);
    
  TYPE characterized_definition = SELECT (
    characterized_object, 
    characterized_product_definition, 
    shape_definition);
  END_TYPE;

  TYPE ppds_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    property_definition,
    shape_aspect, 
    shape_aspect_relationship);
  END_TYPE;

  TYPE characterized_product_definition = SELECT (
    product_definition, 
    product_definition_relationship,
    multi_level_reference_designator);
  END_TYPE;

  TYPE derived_property_select = SELECT (property_definition, action_property, resource_property);
  END_TYPE;

  TYPE shape_definition = SELECT (product_definition_shape, shape_aspect, shape_aspect_relationship);
  END_TYPE;

  TYPE internal_or_reflected_shape_aspect = SELECT (
    shape_aspect,
    reflected_shape_aspect_id);
  END_TYPE;

  TYPE reflected_shape_aspect_id = identifier;
  END_TYPE;

  TYPE multi_or_next_assembly_usage_occurrence = SELECT (
    multi_level_reference_designator,
    next_assembly_usage_occurrence);
  END_TYPE;

  ENTITY characterized_object;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY characterized_object_relationship;
    name : label;
    description : OPTIONAL text;
    relating_object : characterized_object;
    related_object : characterized_object;
  END_ENTITY;

  ENTITY component_path_shape_aspect
    SUBTYPE OF (shape_aspect);
    location : multi_or_next_assembly_usage_occurrence;
    component_shape_aspect : internal_or_reflected_shape_aspect;
  UNIQUE
    UR1 : location, component_shape_aspect;
  WHERE
    WR1: SIZEOF(QUERY(cp <* location.location | NOT (
      EXISTS(cp\assembly_component_usage.reference_designator)))) = 0; 
  END_ENTITY;

  ENTITY general_property;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY general_property_association;
    name : label;
    description : OPTIONAL text;
    base_definition : general_property;
    derived_definition : derived_property_select;
  WHERE
    WR1: SIZEOF(USEDIN(derived_definition, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
    WR2: derived_definition.name = base_definition.name;
  END_ENTITY;

  ENTITY general_property_relationship;
    name : label;
    description : OPTIONAL text;
    relating_property : general_property;
    related_property : general_property;
  END_ENTITY;

  ENTITY product_definition_shape
    SUBTYPE OF (property_definition);
  UNIQUE
    UR1: SELF\property_definition.definition;
  WHERE
    WR1: SIZEOF(['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
  END_ENTITY;

  ENTITY property_definition;
    name : label;
    description : OPTIONAL text;
    definition : characterized_definition;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_aspect;
    name : label;
    description : OPTIONAL text;
    of_shape : product_definition_shape;
    product_definitional : LOGICAL;
  DERIVE
    id : identifier := get_id_value(SELF);
  UNIQUE
    UR1: id, of_shape;    
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_aspect_relationship;
    name : label;
    description : OPTIONAL text;
    relating_shape_aspect : shape_aspect;
    related_shape_aspect : shape_aspect;
  DERIVE
    id : identifier := get_id_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  FUNCTION acyclic_characterized_object_relationship (relation : characterized_object_relationship; relatives : SET [1:?] OF characterized_object; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF characterized_object_relationship;
    END_LOCAL;

    IF relation.relating_object IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_general_property_relationship (relation : general_property_relationship; relatives : SET [1:?] OF general_property; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF general_property_relationship;
    END_LOCAL;

    IF relation.relating_property IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_shape_aspect_relationship (relation : shape_aspect_relationship; relatives : SET [1:?] OF shape_aspect; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF shape_aspect_relationship;
    END_LOCAL;

    IF relation.relating_shape_aspect IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION get_shape_aspects (c_def_instance : characterized_definition):SET OF shape_aspect;
    LOCAL
      pd_set : SET OF product_definition_shape := [];
      pdr_set : SET OF shape_aspect := [];
    END_LOCAL;

    pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)

SCHEMA product_property_representation_schema;

  REFERENCE FROM basic_attribute_schema (
    description_attribute, 
    description_attribute_select,
    get_description_value, 
    get_name_value, 
    name_attribute,
    name_attribute_select);
  REFERENCE FROM material_property_definition_schema (
    property_definition_relationship);
  REFERENCE FROM product_definition_schema (
    product_definition, 
    product_definition_relationship);
  REFERENCE FROM product_property_definition_schema (
    characterized_object, 
    characterized_definition, 
    general_property, 
    product_definition_shape, 
    property_definition, 
    shape_aspect, 
    shape_aspect_relationship);
  REFERENCE FROM representation_schema (
    representation, 
    representation_item, 
    representation_relationship, 
    using_representations, 
    mapped_item, 
    representation_context, 
    representation_map,
    list_representation_item,
    set_representation_item);
  REFERENCE FROM support_resource_schema (
    bag_to_set, 
    label, 
    text);

  TYPE pprs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    context_dependent_shape_representation,
    property_definition_representation);
  END_TYPE;
  
  TYPE pprs_name_attribute_select = SELECT BASED_ON name_attribute_select WITH (
    context_dependent_shape_representation,
    property_definition_representation);
  END_TYPE;

  TYPE chained_representation_link = SELECT (mapped_item, representation_context, representation_relationship);
  END_TYPE;

  TYPE represented_definition = SELECT (
    general_property, 
    property_definition, 
    property_definition_relationship, 
    shape_aspect, 
    shape_aspect_relationship);
  END_TYPE;

  TYPE item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT (
    represented_definition);
  END_TYPE;
  
  TYPE item_identified_representation_usage_select = SELECT (
    representation_item,
    list_representation_item,
    set_representation_item);
  END_TYPE;  

  ENTITY chain_based_item_identified_representation_usage
    SUBTYPE OF (item_identified_representation_usage);
    nodes : LIST [2:?] OF UNIQUE representation;
    undirected_link : LIST [1:?] OF chained_representation_link;
  DERIVE
    root : representation := nodes[1];
    SELF\item_identified_representation_usage.used_representation RENAMED leaf : representation := nodes[HIINDEX(nodes)];
    directed_link : LIST [1:?] OF representation_relationship := get_directed_link(nodes, undirected_link);
  WHERE
    WR1 : EXISTS(directed_link);
  END_ENTITY;
 
  ENTITY characterized_chain_based_item_within_representation 
    SUBTYPE OF (characterized_item_within_representation);
    nodes : LIST[2:?] OF UNIQUE representation;
    undirected_link : LIST[1:?] OF chained_representation_link;
  DERIVE
    root : representation := nodes[1];
    SELF\characterized_item_within_representation.rep RENAMED leaf : representation := nodes[HIINDEX(nodes)];
    directed_link : LIST[1:?] OF representation_relationship := get_directed_link(nodes, undirected_link);
  WHERE
    WR1 : EXISTS(directed_link);
  END_ENTITY;
 
  ENTITY characterized_item_within_representation
    SUBTYPE OF (characterized_object);
    item : representation_item;
    rep : representation;
  UNIQUE
    WR1: item, rep;
  WHERE
    WR2: rep IN using_representations(item);
  END_ENTITY;

  ENTITY context_dependent_shape_representation;
    representation_relation : shape_representation_relationship;
    represented_product_relation : product_definition_shape;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition);
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR3: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY item_identified_representation_usage;
    name : label;
    description : OPTIONAL text;
    definition : item_identified_representation_usage_definition;
    used_representation : representation;
    identified_item : item_identified_representation_usage_select;
  WHERE
    WR1: SELF.used_representation IN using_representations(SELF.identified_item);
  END_ENTITY;

  ENTITY property_definition_representation;
    definition : represented_definition;
    used_representation : representation;
  DERIVE
    description : text := get_description_value(SELF);
    name : label := get_name_value(SELF);
  WHERE
    WR1: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
    WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_definition_representation
    SUBTYPE OF (property_definition_representation);
    SELF\property_definition_representation.definition : property_definition;
    SELF\property_definition_representation.used_representation : shape_representation;
  WHERE
    WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(definition)) OR
         ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(definition\property_definition.definition));   
  END_ENTITY;

  ENTITY shape_representation
    SUBTYPE OF (representation);
  END_ENTITY;

  ENTITY shape_representation_relationship
    SUBTYPE OF (representation_relationship);
  WHERE
    WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
  END_ENTITY;

  FUNCTION get_directed_link ( nodes : LIST OF representation;
                            undirected_link  : LIST OF chained_representation_link) : LIST OF representation_relationship;
  LOCAL
   directed_link : LIST OF representation_relationship := [];
  END_LOCAL;

  IF (SIZEOF(nodes) <> SIZEOF(undirected_link) + 1) OR
     (value_unique(nodes) = FALSE)
  THEN
   RETURN(?);
  END_IF;
  
  REPEAT i := 1 to SIZEOF(undirected_link);
   CASE TRUE OF
    ('REPRESENTATION_SCHEMA.REPRESENTATION_CONTEXT' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i]\representation.context_of_items   :=: undirected_link[i]) AND 
         (nodes[i+1]\representation.context_of_items :=: undirected_link[i])) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF (((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_1) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_2)) OR
         ((nodes[i]   :=: undirected_link[i]\representation_relationship.rep_2) AND
          (nodes[i+1] :=: undirected_link[i]\representation_relationship.rep_1))) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    ('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(undirected_link[i])) :
    BEGIN
     IF ((nodes[i] IN using_representations(undirected_link[i])) AND 
         (nodes[i+1] :=: undirected_link[i]\mapped_item.mapping_source\representation_map.mapped_representation)) THEN
       INSERT(directed_link, representation_relationship('','',nodes[i+1],nodes[i]), (i - 1));
     ELSE
       RETURN(?); 
     END_IF;
    END;

    OTHERWISE : RETURN(?);
   END_CASE;
  END_REPEAT;
  
  IF (value_unique(directed_link) = FALSE)
  THEN
   RETURN(?);
  END_IF;
  
  RETURN(directed_link);
  END_FUNCTION;

  FUNCTION relatives_of_product_definitions (definition_set : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
    FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
      LOCAL
        local_def : SET OF product_definition := [];
        local_pdr : SET OF product_definition_relationship := [];
        local_total : SET OF product_definition := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(definition_set);
        local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_pdr);
        local_def := local_def + local_pdr[i].related_product_definition;
      END_REPEAT;
      IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
        RETURN (local_def);
      ELSE
        local_total := total_definitions + local_def;
        RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
  END_FUNCTION;

  FUNCTION relatives_of_shape_representations (shape_representation_set : SET OF shape_representation):SET OF shape_representation;
    FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
      LOCAL
        local_shape_rep : SET OF shape_representation := [];
        local_srr : SET OF shape_representation_relationship := [];
        local_total : SET OF shape_representation := [];
      END_LOCAL;

      REPEAT i := 1 TO HIINDEX(shape_representation_set);
        local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
      END_REPEAT;
      REPEAT i := 1 TO HIINDEX(local_srr);
        IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
          local_shape_rep := local_shape_rep + local_srr[i].rep_2;
        END_IF;
      END_REPEAT;
      IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
        RETURN (shape_representation_set);
      ELSE
        local_total := total_reps + local_shape_rep;
        RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
      END_IF;
    END_FUNCTION;

    RETURN (local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));
  END_FUNCTION;

  FUNCTION get_property_definition_representations (c_def_instance : characterized_definition):SET OF property_definition_representation;
    LOCAL
      pd_set : SET OF property_definition := [];
      pdr_set : SET OF property_definition_representation := [];
    END_LOCAL;

    pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
    IF (SIZEOF(pd_set) < 1) THEN
      RETURN (pdr_set);
    END_IF;
    REPEAT i := 1 TO HIINDEX(pd_set);
      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
    END_REPEAT;
    RETURN (pdr_set);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 Nnnnn - ISO/IS 10303-44 Product structure configuration - EXPRESS
*)

SCHEMA product_structure_schema;

  REFERENCE FROM product_definition_schema
    (product,
     product_definition,
     product_definition_relationship,
     acyclic_product_definition_relationship);

  REFERENCE FROM measure_schema
     (measure_with_unit);

  REFERENCE FROM support_resource_schema
     (identifier, label, text);

ENTITY alternate_product_relationship;
  name        : label;
  definition  : OPTIONAL text;
  alternate   : product;
  base        : product;
  basis       : text;
UNIQUE
  UR1: alternate, base;
WHERE
  WR1: alternate :<>: base;
END_ENTITY;

ENTITY assembly_component_usage
  SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence,
                       specified_higher_usage_occurrence,
                       promissory_usage_occurrence))
  SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;

ENTITY assembly_component_usage_substitute;
  name              : label;
  definition        : OPTIONAL text;
  base              : assembly_component_usage;
  substitute        : assembly_component_usage;
UNIQUE
  UR1: base,substitute;
WHERE
  WR1: base.relating_product_definition :=:
       substitute.relating_product_definition;
  WR2: base :<>: substitute;
END_ENTITY;

ENTITY assembly_component_usage_substitute_with_ranking
  SUBTYPE OF (assembly_component_usage_substitute);
  ranking           : INTEGER;
  ranking_rationale : text;
END_ENTITY;

ENTITY make_from_usage_option
  SUBTYPE OF (product_definition_usage);
  ranking           : INTEGER;
  ranking_rationale : text;
  quantity          : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  WR1: SIZEOF (QUERY (example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition)) =SIZEOF(members);
END_ENTITY;

ENTITY multi_level_reference_designator;
  name : OPTIONAL label;
  description : OPTIONAL text; 
  location : LIST[1:?] OF UNIQUE next_assembly_usage_occurrence;
DERIVE
  root_node : product_definition := location[1].relating_product_definition;
UNIQUE
  UR1 : location;
END_ENTITY;

ENTITY next_assembly_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
UNIQUE
  UR1 : SELF\assembly_component_usage.reference_designator, SELF\product_definition_relationship.relating_product_definition;  
END_ENTITY;

ENTITY product_definition_occurrence_relationship;
  name             : label;
  description      : OPTIONAL text;
  occurrence       : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  WR1: occurrence_usage.relating_product_definition :<>: 
       occurrence;
  WR2: occurrence_usage.related_product_definition :<>: 
       occurrence;
  WR3: occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY;

ENTITY product_definition_usage
  SUPERTYPE OF (ONEOF (make_from_usage_option,
                       assembly_component_usage))
  SUBTYPE OF (product_definition_relationship);
UNIQUE
  UR1: SELF\product_definition_relationship.id,
       SELF\product_definition_relationship.relating_product_definition,
       SELF\product_definition_relationship.related_product_definition;
WHERE
  WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
END_ENTITY;

ENTITY promissory_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
END_ENTITY;

ENTITY quantified_assembly_component_usage
  SUBTYPE OF (assembly_component_usage);
  quantity   : measure_with_unit;
WHERE
  WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
       OR (quantity.value_component > 0);
END_ENTITY;

ENTITY specified_higher_usage_occurrence
  SUBTYPE OF (assembly_component_usage);
  upper_usage   : assembly_component_usage;
  next_usage    : next_assembly_usage_occurrence;
UNIQUE
  UR1: upper_usage, next_usage;
WHERE
  WR1: SELF :<>: upper_usage;
  WR2: SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
  WR3: SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
  WR4: (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition) OR
       (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION') |
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition)) = 1);
  WR5: SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage)) = 1;
END_ENTITY;

END_SCHEMA; -- product_structure
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)


SCHEMA qualifications_schema;
  REFERENCE FROM support_resource_schema (identifier, label, text, bag_to_set);
  ENTITY qualification;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_qualification : qualification;
    related_qualification : qualification;
  END_ENTITY;

  ENTITY qualification_type;
    id : identifier;
    name : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_type_relationship;
    id : identifier;
    name : label;
    description : OPTIONAL text;
    relating_qualification_type : qualification_type;
    related_qualification_type : qualification_type;
  END_ENTITY;

  FUNCTION acyclic_qualification_relationship (relation : qualification_relationship; relatives : SET OF qualification; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_relationship;
    END_LOCAL;

    IF relation.relating_qualification IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

  FUNCTION acyclic_qualification_type_relationship (relation : qualification_type_relationship; relatives : SET OF qualification_type; specific_relation : STRING):BOOLEAN;
    LOCAL
      x : SET OF qualification_type_relationship;
    END_LOCAL;

    IF relation.relating_qualification_type IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N5100 - ISO/IS 10303-45 Material properties - EXPRESS
*)


SCHEMA qualified_measure_schema;

REFERENCE FROM mathematical_functions_schema
     (maths_value);

REFERENCE FROM measure_schema
     (measure_with_unit,
unit);

REFERENCE FROM representation_schema
     (representation_item);

REFERENCE FROM support_resource_schema
     (label,
      text,
      bag_to_set);

TYPE value_qualifier = SELECT
  (precision_qualifier,
   type_qualifier,
   uncertainty_qualifier);
END_TYPE;

ENTITY descriptive_representation_item
  SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;

ENTITY expanded_uncertainty
  SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;

ENTITY maths_value_qualification;
  name 			: label;
  description 		: text;
  qualified_maths_value : maths_value_with_unit;
  qualifiers 		: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM'
           IN TYPEOF(SELF\maths_value_qualification.qualified_maths_value));
END_ENTITY;

ENTITY maths_value_representation_item
  SUBTYPE OF (representation_item, maths_value_with_unit);
END_ENTITY;

ENTITY maths_value_with_unit;
  value_component 	: maths_value;
  unit_component 		: unit;
END_ENTITY;

ENTITY measure_qualification;
  name 			: label;
  description 		: text;
  qualified_measure 	: measure_with_unit;
  qualifiers 		: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
  WR2: NOT ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM'
           IN TYPEOF(SELF\measure_qualification.qualified_measure));
END_ENTITY;

ENTITY measure_representation_item
  SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;

ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;

ENTITY qualified_representation_item
  SUBTYPE OF (representation_item);
  qualifiers 	: SET [1:?] OF value_qualifier;
WHERE
  WR1: SIZEOF(QUERY(temp <* qualifiers |
             'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
             IN TYPEOF(temp))) < 2;
END_ENTITY;

ENTITY qualitative_uncertainty
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;

ENTITY standard_uncertainty
  SUPERTYPE OF (expanded_uncertainty)
  SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;

ENTITY type_qualifier;
  name : label;
END_ENTITY;

ENTITY uncertainty_qualifier
 SUPERTYPE OF (ONEOF (standard_uncertainty,
                     qualitative_uncertainty));
  measure_name : label;
  description  : text;
END_ENTITY;

END_SCHEMA;  -- qualified_measure_schema

(*
ISO TC184/SC4/WG12 N6135 - ISO/IS 10303-43 Representation structures - EXPRESS
*) 

SCHEMA representation_schema;

REFERENCE FROM basic_attribute_schema
  (description_attribute,
   description_attribute_select,
   get_description_value,
   get_id_value,
   id_attribute,
   id_attribute_select);

REFERENCE FROM measure_schema
  (measure_value,
   measure_with_unit);

REFERENCE FROM support_resource_schema
  (bag_to_set,
   identifier,
   label,
   text);
   
  TYPE rs_description_attribute_select = SELECT BASED_ON description_attribute_select WITH (
    representation);
  END_TYPE;
  TYPE rs_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    representation);
  END_TYPE;

  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE;

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE;

  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE;

  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE;

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE;

  ENTITY binary_representation_item 
    SUBTYPE OF (representation_item); 
      binary_value : BINARY; 
  END_ENTITY; 

  ENTITY bytes_representation_item 
    SUBTYPE OF (binary_representation_item); 
    DERIVE 
      no_of_bytes : INTEGER := BLENGTH(SELF\binary_representation_item.binary_value) DIV 8; 
    WHERE 
      WR1: BLENGTH(SELF\binary_representation_item.binary_value) MOD 8 = 0; 
  END_ENTITY; 

  ENTITY compound_representation_item
    SUBTYPE OF (representation_item);
      item_element : compound_item_definition;
  END_ENTITY;

  ENTITY definitional_representation
    SUBTYPE OF (representation);
    WHERE
      WR1: 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN
          TYPEOF (SELF\representation.context_of_items );
  END_ENTITY;

  ENTITY definitional_representation_relationship
    SUBTYPE OF (representation_relationship);
     WHERE
       WR1: acyclic_representation_relationship(SELF,
         [SELF\representation_relationship.rep_2],
         'REPRESENTATION_SCHEMA.'+'REPRESENTATION');
  END_ENTITY;  

  ENTITY definitional_representation_relationship_with_same_context
    SUBTYPE OF (definitional_representation_relationship);
     WHERE
       WR1: SELF\representation_relationship.rep_1.context_of_items :=: 
            SELF\representation_relationship.rep_2.context_of_items;
  END_ENTITY;  

  ENTITY founded_item;
    DERIVE
      users : SET[0:?] OF founded_item_select := using_items(SELF,[]);
    WHERE
      WR1: SIZEOF(users) > 0;
      WR2: NOT(SELF IN users);  
  END_ENTITY;

  ENTITY functionally_defined_transformation;
    name        : label;
    description : OPTIONAL text;
  END_ENTITY;

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF (representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY item_defined_transformation;
    name             : label;
    description      : OPTIONAL text;
    transform_item_1 : representation_item;
    transform_item_2 : representation_item;
  END_ENTITY;

  ENTITY mapped_item
    SUBTYPE OF (representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      WR1: acyclic_mapped_representation(SELF);
  END_ENTITY;

  ENTITY parametric_representation_context
    SUBTYPE OF (representation_context);
  END_ENTITY;

  ENTITY representation;
      name             : label;
      items            : SET[1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id               : identifier := get_id_value (SELF);
      description      : text := get_description_value (SELF);
    WHERE
      WR1: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                                 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
         <= 1;
      WR2: SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                                 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
         <= 1;
  END_ENTITY;

  ENTITY representation_context;
      context_identifier : identifier;
      context_type       : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
  END_ENTITY;

  ENTITY representation_item
    SUPERTYPE OF(ONEOF(binary_representation_item,
      compound_representation_item, 
      mapped_item, 
      value_representation_item));
      name : label;
    WHERE
      WR1: SIZEOF(using_representations(SELF)) > 0;
  END_ENTITY;

  ENTITY representation_item_relationship;
    name : label;
    description : OPTIONAL text;
    relating_representation_item : representation_item;
    related_representation_item : representation_item;
  END_ENTITY;

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage : SET[1:?] OF mapped_item FOR mapping_source;
    WHERE
      WR1: item_in_context(SELF.mapping_origin,
        SELF.mapped_representation.context_of_items);
  END_ENTITY;

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY;

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF (representation_relationship);
      transformation_operator : transformation;
    WHERE
      WR1: SELF\representation_relationship.rep_1.context_of_items
           :<>: SELF\representation_relationship.rep_2.context_of_items;
  END_ENTITY;

  ENTITY uncertainty_assigned_representation
    SUBTYPE OF (representation);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF (measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      WR1: valid_measure_value (SELF\measure_with_unit.value_component);
  END_ENTITY;

  ENTITY value_representation_item
    SUBTYPE OF (representation_item);
      value_component : measure_value;
    WHERE
      WR1: SIZEOF (QUERY (rep <* using_representations (SELF) |
        NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
        IN TYPEOF (rep.context_of_items)
        ))) = 0;
  END_ENTITY;

  FUNCTION acyclic_mapped_representation
    (mi : mapped_item) : BOOLEAN;
    LOCAL
      rms : SET OF representation_map;
      mis : SET OF mapped_item;
      rs1, rs2 : SET OF representation;
    END_LOCAL;
 
    rs1 := using_representations(mi);
    rs2 := [];
    -- loop as long as there are elements in rs1
    REPEAT WHILE SIZEOF(rs1) > 0; 
      REPEAT i := 1 TO HIINDEX(rs1);
        -- Determine the set of representation_map that reference the parent_set
        rms := bag_to_set(USEDIN(rs1[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_MAP.MAPPED_REPRESENTATION'));
        IF SIZEOF(rms) > 0 THEN
          REPEAT j := 1 TO HIINDEX(rms);
            mis := bag_to_set(USEDIN(rms[i], 'REPRESENTATION_SCHEMA.MAPPED_ITEM.MAPPING_SOURCE'));
            IF SIZEOF(mis) > 0 THEN
              REPEAT j := 1 TO HIINDEX(mis);
                -- check mis members for instance equal with mi. If so then there is a cycle
                IF mis[i] :=: mi THEN
                  RETURN (FALSE);
                END_IF;
                rs2 := rs2 + using_representations(mis[i]);
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
      rs1 := rs2;
      rs2 := [];
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION;  
  
  FUNCTION acyclic_representation_relationship
    (relation : representation_relationship; relatives : SET[1:?] OF representation; specific_relation : STRING) : BOOLEAN; 
    LOCAL
      x : SET OF representation_relationship;
    END_LOCAL;

    IF relation.rep_1 IN relatives THEN
      RETURN (FALSE);
    END_IF;
    x := QUERY(r <* bag_to_set(USEDIN(relation.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2')) | specific_relation IN TYPEOF(r));
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  END_FUNCTION; 

  FUNCTION item_in_context
    (item  : representation_item;
     cntxt : representation_context) : BOOLEAN;
    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) > 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z <* USEDIN (item , '') |
             'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) > 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);
  END_FUNCTION;

  FUNCTION using_items (item : founded_item_select;
                        checked_items: SET OF founded_item_select)
                      : SET OF founded_item_select;
    LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
      ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) > 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);
  END_FUNCTION;

  FUNCTION using_representations (item : founded_item_select)
    : SET OF representation;
    LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag := USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) > 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);
  END_FUNCTION;

  FUNCTION valid_measure_value
    (m : measure_value) : BOOLEAN;
    IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m > 0.0);
    ELSE
     IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m > 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;
  END_FUNCTION;

END_SCHEMA;
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)



SCHEMA security_classification_schema;
  REFERENCE FROM support_resource_schema (label, text);
  ENTITY security_classification;
    name : label;
    purpose : text;
    security_level : security_classification_level;
  END_ENTITY;

  ENTITY security_classification_level;
    name : label;
  END_ENTITY;

END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7297 - ISO/DIS 10303-47 Shape variation tolerances - EXPRESS
*) 


SCHEMA shape_aspect_definition_schema;

REFERENCE FROM measure_schema   -- ISO 10303-41
  (length_measure_with_unit,
   measure_with_unit); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (bag_to_set,
   label,
   identifier); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation,
   using_representations); 

REFERENCE FROM geometry_schema   -- ISO 10303-42
  (axis2_placement,
   cartesian_point,
   direction,
   geometric_representation_context,
   line,
   placement,
   plane); 

REFERENCE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item,
   measure_representation_item); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (characterized_object,
   shape_aspect,
   shape_aspect_relationship); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (shape_representation); 

REFERENCE FROM shape_dimension_schema   -- ISO 10303-47
  (dimensional_location,
   dimensional_size); 


TYPE common_datum_list = LIST[2:?] OF datum_reference_element;
WHERE
  WR1: SIZEOF( QUERY(dre <* SELF | dre\shape_aspect.of_shape <> SELF[1]\shape_aspect.of_shape)) = 0;
END_TYPE; 

TYPE datum_or_common_datum = SELECT
   (common_datum_list, 
    datum);
END_TYPE; 

TYPE datum_reference_modifier = EXTENSIBLE SELECT
   (datum_reference_modifier_with_value, 
    simple_datum_reference_modifier);
END_TYPE; 

TYPE datum_reference_modifier_type = EXTENSIBLE ENUMERATION OF 
   (circular_or_cylindrical,
    spherical,
    distance,
    projected);
END_TYPE; 

TYPE limit_condition = ENUMERATION OF 
   (maximum_material_condition,
    least_material_condition,
    regardless_of_feature_size);
END_TYPE; 

TYPE shape_representation_with_parameters_items = EXTENSIBLE GENERIC_ENTITY SELECT
   (descriptive_representation_item, 
    direction, 
    measure_representation_item, 
    placement);
END_TYPE; 

TYPE simple_datum_reference_modifier = EXTENSIBLE ENUMERATION OF 
   (free_state,
    basic,
    translation,
    least_material_requirement,
    maximum_material_requirement,
    point,
    line,
    plane,
    orientation,
    any_cross_section,
    any_longitudinal_section,
    contacting_feature,
    distance_variable,
    degree_of_freedom_constraint_x,
    degree_of_freedom_constraint_y,
    degree_of_freedom_constraint_z,
    degree_of_freedom_constraint_u,
    degree_of_freedom_constraint_v,
    degree_of_freedom_constraint_w,
    minor_diameter,
    major_diameter,
    pitch_diameter);
END_TYPE; 

ENTITY all_around_shape_aspect
  SUBTYPE OF (continuous_shape_aspect);
END_ENTITY;

ENTITY apex
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;

ENTITY between_shape_aspect
  SUBTYPE OF (continuous_shape_aspect);
END_ENTITY;

ENTITY centre_of_symmetry
  SUBTYPE OF (derived_shape_aspect);
END_ENTITY;

ENTITY common_datum
  SUBTYPE OF (composite_shape_aspect, datum);
WHERE
  WR1: SIZEOF (SELF\composite_shape_aspect.component_relationships) = 2;
  WR2: SIZEOF (QUERY ( sar <* SELF\composite_shape_aspect.component_relationships| NOT (('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF (sar.related_shape_aspect)) AND NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMMON_DATUM' IN TYPEOF (sar.related_shape_aspect))) )) = 0;
END_ENTITY;

ENTITY composite_group_shape_aspect
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

ENTITY composite_shape_aspect
  SUPERTYPE OF (ONEOF (continuous_shape_aspect,
                       common_datum,
                       composite_group_shape_aspect))
  SUBTYPE OF (shape_aspect);
INVERSE
  component_relationships : SET[2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
END_ENTITY;

ENTITY contacting_feature
  SUBTYPE OF (shape_aspect);
WHERE
  WR1: SELF\shape_aspect.product_definitional = FALSE;
END_ENTITY;

ENTITY continuous_shape_aspect
  SUPERTYPE OF ( ONEOF (between_shape_aspect, all_around_shape_aspect) )
  SUBTYPE OF (composite_shape_aspect);
END_ENTITY;

ENTITY datum
  SUBTYPE OF (shape_aspect);
  identification : identifier;
INVERSE
  established_by_relationships : SET[1:?] OF shape_aspect_relationship FOR related_shape_aspect;
UNIQUE
  UR1: identification,SELF\shape_aspect.of_shape;
WHERE
  WR1: ('SHAPE_ASPECT_DEFINITION_SCHEMA.COMMON_DATUM' IN TYPEOF(SELF)) 
   XOR ((SIZEOF(QUERY(x <* SELF\datum.established_by_relationships |
          SIZEOF(['SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE',
             'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_TARGET'] * 
           TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)) = 1)) >= 1));
  WR2: SIZEOF(QUERY(x <* SELF\datum.established_by_relationships | 
          ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE' IN TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)))) <= 1; 
  WR3: SELF\shape_aspect.product_definitional = FALSE;
  WR4: SELF\shape_aspect.name = '';
END_ENTITY;

ENTITY datum_feature
  SUPERTYPE OF (ONEOF (dimensional_location_with_datum_feature, dimensional_size_with_datum_feature))
  SUBTYPE OF (shape_aspect);
INVERSE
  feature_basis_relationship : SET[1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF(QUERY(sar <* SELF\datum_feature.feature_basis_relationship | ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF (sar\shape_aspect_relationship.related_shape_aspect)))) = 1;
  WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY datum_reference;
  precedence : INTEGER;
  referenced_datum : datum;
WHERE
  WR1: precedence > 0;
END_ENTITY;

ENTITY datum_reference_compartment
  SUBTYPE OF (general_datum_reference);
INVERSE
  owner : datum_system FOR constituents;
END_ENTITY;

ENTITY datum_reference_element
  SUBTYPE OF (general_datum_reference);
DERIVE
  owner : general_datum_reference := sts_get_general_datum_reference(SELF);
WHERE
  WR1: SELF <> owner;
  WR2: EXISTS(owner);
  WR3: SELF\shape_aspect.of_shape = owner\shape_aspect.of_shape;
END_ENTITY;

ENTITY datum_reference_modifier_with_value;
  modifier_type : datum_reference_modifier_type;
  modifier_value : length_measure_with_unit;
WHERE
  WR1: (modifier_value\measure_with_unit.value_component > 0.0);
END_ENTITY;

ENTITY datum_system
  SUBTYPE OF (shape_aspect);
  constituents : LIST[1:3] OF UNIQUE datum_reference_compartment;
UNIQUE
  UR1: SELF\shape_aspect.of_shape,SELF\shape_aspect.name;
WHERE
  WR1: SELF\shape_aspect.product_definitional = FALSE;
END_ENTITY;

ENTITY datum_target
  SUBTYPE OF (shape_aspect);
  target_id : identifier;
INVERSE
  target_basis_relationship : SET[1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
  WR1: SIZEOF(QUERY(sar <* SELF\datum_target.target_basis_relationship | ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF (sar\shape_aspect_relationship.related_shape_aspect)))) = 1;
  WR2: SELF\shape_aspect.product_definitional = TRUE;
END_ENTITY;

ENTITY derived_shape_aspect
  SUPERTYPE OF (ONEOF (apex,
                       centre_of_symmetry,
                       geometric_alignment,
                       geometric_contact,
                       geometric_intersection,
                       parallel_offset,
                       perpendicular_to,
                       extension,
                       tangent))
  SUBTYPE OF (shape_aspect);
INVERSE
  deriving_relationships : SET[1:?] OF shape_aspect_deriving_relationship FOR relating_shape_aspect;
END_ENTITY;

ENTITY dimensional_location_with_datum_feature
  SUBTYPE OF (datum_feature, dimensional_location);
END_ENTITY;

ENTITY dimensional_size_with_datum_feature
  SUBTYPE OF (datum_feature, dimensional_size);
END_ENTITY;

ENTITY extension
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY feature_definition
  SUBTYPE OF (characterized_object);
END_ENTITY;

ENTITY general_datum_reference
  ABSTRACT SUPERTYPE OF (ONEOF (datum_reference_compartment,
                                datum_reference_element))
  SUBTYPE OF (shape_aspect);
  base : datum_or_common_datum;
  modifiers : OPTIONAL SET[1:?] OF datum_reference_modifier;
WHERE
  WR1: SELF\shape_aspect.name = '';
  WR2: NOT EXISTS(SELF\shape_aspect.description);
  WR3: NOT EXISTS(SELF\shape_aspect.id);
  WR4: SELF\shape_aspect.product_definitional = FALSE;
  WR5: NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF(base)) OR (SELF\shape_aspect.of_shape = base\shape_aspect.of_shape);
  WR6: NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.COMMON_DATUM_LIST' IN TYPEOF(base)) OR (SELF\shape_aspect.of_shape = base[1]\shape_aspect.of_shape);
END_ENTITY;

ENTITY geometric_alignment
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY geometric_contact
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 2;
END_ENTITY;

ENTITY geometric_intersection
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
END_ENTITY;

ENTITY instanced_feature
  SUBTYPE OF (feature_definition, shape_aspect);
WHERE
  WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF (SELF.of_shape.definition);
  WR2: SELF.product_definitional;
END_ENTITY;

ENTITY parallel_offset
  SUBTYPE OF (derived_shape_aspect);
  offset : measure_with_unit;
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY perpendicular_to
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

ENTITY referenced_modified_datum
  SUBTYPE OF (datum_reference);
  modifier : limit_condition;
END_ENTITY;

ENTITY shape_aspect_deriving_relationship
  SUBTYPE OF (shape_aspect_relationship);
  SELF\shape_aspect_relationship.relating_shape_aspect : derived_shape_aspect;
END_ENTITY;

ENTITY shape_representation_with_parameters
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET[1:?] OF shape_representation_with_parameters_items;
END_ENTITY;

ENTITY symmetric_shape_aspect
  SUBTYPE OF (shape_aspect);
INVERSE
  basis_relationships : SET[1:?] OF shape_aspect_deriving_relationship FOR related_shape_aspect;
END_ENTITY;

ENTITY tangent
  SUBTYPE OF (derived_shape_aspect);
WHERE
  WR1: SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
END_ENTITY;

SUBTYPE_CONSTRAINT sads_shape_aspect_subtypes FOR shape_aspect;
  ONEOF (contacting_feature,
         datum,
         datum_feature,
         datum_target,
         datum_system,
         general_datum_reference);
END_SUBTYPE_CONSTRAINT;

RULE unique_datum_system FOR 
(datum_system);

LOCAL
  pass : BOOLEAN := TRUE;
END_LOCAL; 
REPEAT i := 1 TO SIZEOF(datum_system);
 REPEAT j := 1 TO SIZEOF(datum_system);
  IF (i <> j) THEN
   IF datum_system[i]\datum_system.constituents = 
      datum_system[j]\datum_system.constituents  THEN
    pass := FALSE;
   END_IF;
  END_IF;
 END_REPEAT;
END_REPEAT;WHERE
  WR1: pass;
END_RULE; 

FUNCTION sts_get_general_datum_reference
 (input : datum_reference_element) : general_datum_reference; 
LOCAL
      general_datum_reference_bag : BAG OF general_datum_reference :=
(USEDIN(input, 
      'SHAPE_ASPECT_DEFINITION_SCHEMA.' + 'GENERAL_DATUM_REFERENCE.' + 'BASE'));
    END_LOCAL;

    IF SIZEOF(general_datum_reference_bag) = 1 THEN
      RETURN (general_datum_reference_bag[1]);
    ELSE
      RETURN (?);
    END_IF;END_FUNCTION; 

END_SCHEMA;  -- shape_aspect_definition_schema
(*
 ISO TC184/SC4/WG12 N7298 - ISO 10303-59 Quality of product shape data
 Supersedes ISO TC184/SC4/WG12 N5088
*)

SCHEMA shape_data_quality_criteria_schema;

  REFERENCE FROM GEOMETRIC_MODEL_SCHEMA;

  REFERENCE FROM GEOMETRY_SCHEMA;

  REFERENCE FROM MEASURE_SCHEMA;

  REFERENCE FROM PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA;

  REFERENCE FROM PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA
    (data_quality_inspection_result_representation,
     data_quality_report_measurement_association,
     data_quality_inspection_report);

  REFERENCE FROM QUALIFIED_MEASURE_SCHEMA
    (qualified_representation_item,
     value_qualifier,
     type_qualifier,
     measure_representation_item);

  REFERENCE FROM REPRESENTATION_SCHEMA
    (compound_representation_item,
     representation,
     value_representation_item,
     set_representation_item);

  REFERENCE FROM SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA;

  REFERENCE FROM SUPPORT_RESOURCE_SCHEMA
    (text,
     bag_to_set);

  REFERENCE FROM TOPOLOGY_SCHEMA;

  TYPE shape_data_quality_assessment_specification_select = SELECT
    (shape_data_quality_assessment_by_logical_test,
     shape_data_quality_assessment_by_numerical_test);
  END_TYPE; 

  TYPE shape_data_quality_value_limit_type_select = SELECT
    (shape_data_quality_value_range,
     shape_data_quality_value_limit);
  END_TYPE;

  ENTITY shape_data_quality_criteria_representation
    SUBTYPE OF(data_quality_criteria_representation);
    WHERE
      WR1 : SIZEOF( QUERY( q <* SELF\representation.items|
                               'SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
                               'SHAPE_DATA_QUALITY_CRITERION' IN TYPEOF(q))) > 0;
  END_ENTITY;

  ENTITY shape_data_quality_criterion
    SUPERTYPE OF (ONEOF(erroneous_data, inapt_data))
    SUBTYPE OF(data_quality_criterion, data_quality_measurement_requirement);
      assessment_specification : shape_data_quality_assessment_specification_select;
    WHERE
      WR1 : SIZEOF(USEDIN(SELF,
            'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
            'DATA_QUALITY_CRITERION_ASSESSMENT_ASSOCIATION.'+
            'CRITERION'
            )) = 0;
      WR2 : SIZEOF(QUERY(i1<*bag_to_set(
              USEDIN(SELF,
                    'REPRESENTATION_SCHEMA.'+
                    'REPRESENTATION_ITEM_RELATIONSHIP.'+
                    'RELATED_REPRESENTATION_ITEM'))|
             'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
             'DATA_QUALITY_CRITERION_MEASUREMENT_ASSOCIATION'
              IN TYPEOF(i1))) = 0;
      WR3 : SIZEOF(QUERY(i1<*bag_to_set(
              USEDIN(SELF,
                    'REPRESENTATION_SCHEMA.'+
                    'REPRESENTATION_ITEM_RELATIONSHIP.'+
                    'RELATING_REPRESENTATION_ITEM'))|
             'PRODUCT_DATA_QUALITY_CRITERIA_SCHEMA.'+
             'DATA_QUALITY_CRITERION_MEASUREMENT_ASSOCIATION'
              IN TYPEOF(i1))) = 0;
  END_ENTITY;

  ENTITY shape_data_quality_assessment_by_numerical_test
    SUBTYPE OF(data_quality_assessment_specification);
      threshold : shape_data_quality_value_limit_type_select;
  END_ENTITY;

  ENTITY shape_data_quality_value_range
    SUBTYPE OF(compound_representation_item);
    WHERE
      WR1 : ('REPRESENTATION_SCHEMA.SET_REPRESENTATION_ITEM'
               IN TYPEOF (SELF\compound_representation_item.item_element)) AND
            ((SIZEOF(SELF\compound_representation_item.item_element) = 2) AND 
            ((SIZEOF(QUERY (i1 <* SELF\compound_representation_item.item_element | 
              ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)))) = 2)
             OR (SIZEOF(QUERY (i2 <* SELF\compound_representation_item.item_element | 
              ('REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF(i2)))) = 2))) ;
      WR2 : (SIZEOF(QUERY (i <* SELF\compound_representation_item.item_element
             | (i.name = 'upper limit'))) = 1)
            AND (SIZEOF(QUERY (i <* SELF\compound_representation_item.item_element
             | (i.name = 'lower limit'))) = 1);
      WR3 : (SIZEOF(QUERY(i1 <* SELF\compound_representation_item.item_element |
            ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
            (SIZEOF (QUERY (i2 <* SELF\compound_representation_item.item_element |
            ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
            (i1 :<>: i2) AND 
            (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
            OR
            (SIZEOF(QUERY(i1 <* SELF\compound_representation_item.item_element |
            ('REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
            (SIZEOF (QUERY (i2 <* SELF\compound_representation_item.item_element |
            ('REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
            (i1 :<>: i2) AND 
            (TYPEOF(i1\value_representation_item.value_component) =
             TYPEOF(i2\value_representation_item.value_component)))
            ) = 1))) = 2);
  END_ENTITY;

  ENTITY shape_data_quality_value_limit
    ABSTRACT SUPERTYPE OF (ONEOF(shape_data_quality_upper_value_limit, shape_data_quality_lower_value_limit))
    SUBTYPE OF(measure_representation_item, qualified_representation_item);
  END_ENTITY;

  ENTITY shape_data_quality_upper_value_limit
    SUBTYPE OF(shape_data_quality_value_limit);
    WHERE
      WR1 : SELF\qualified_representation_item.qualifiers[1].name = 'maximum';
  END_ENTITY;

  ENTITY shape_data_quality_lower_value_limit
    SUBTYPE OF(shape_data_quality_value_limit);
    WHERE
      WR1 : SELF\qualified_representation_item.qualifiers[1].name = 'minimum';
  END_ENTITY;
  
  ENTITY shape_summary_request_with_representative_value
    SUBTYPE OF(summary_report_request);
  END_ENTITY;

  ENTITY shape_data_quality_assessment_by_logical_test
    SUBTYPE OF(data_quality_assessment_specification);
  END_ENTITY;

  ENTITY erroneous_data
    ABSTRACT SUPERTYPE OF (ONEOF(erroneous_topology, erroneous_geometry, erroneous_topology_and_geometry_relationship, erroneous_manifold_solid_brep))
    SUBTYPE OF(shape_data_quality_criterion);
  END_ENTITY;

  ENTITY erroneous_topology
    ABSTRACT SUPERTYPE OF (ONEOF(open_edge_loop, open_closed_shell, inconsistent_adjacent_face_normals, disconnected_face_set))
    SUBTYPE OF(erroneous_data);
  END_ENTITY;

  ENTITY open_edge_loop
    SUBTYPE OF(erroneous_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_LOOP']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.ORIENTED_EDGE']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY open_closed_shell
    SUBTYPE OF(erroneous_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CLOSED_SHELL']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY inconsistent_adjacent_face_normals
    SUBTYPE OF(erroneous_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'CLOSED_OR_OPEN_SHELL_SELECT']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY disconnected_face_set
    SUBTYPE OF(erroneous_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY erroneous_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(inconsistent_curve_transition_code, erroneous_b_spline_curve_definition, inconsistent_surface_transition_code, erroneous_b_spline_surface_definition))
    SUBTYPE OF(erroneous_data);
  END_ENTITY;

  ENTITY inconsistent_curve_transition_code
    SUBTYPE OF(erroneous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      angle_tolerance                                            : plane_angle_measure;
      curvature_ratio_tolerance                                  : ratio_measure;
      distance_tolerance                                         : length_measure;
      flat_curvature_radius_tolerance                            : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.COMPOSITE_CURVE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'COMPOSITE_CURVE_TRANSITION_LOCATOR']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY erroneous_b_spline_curve_definition
    SUBTYPE OF(erroneous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY inconsistent_surface_transition_code
    SUBTYPE OF(erroneous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      angle_tolerance                                            : plane_angle_measure;
      curvature_ratio_tolerance                                  : ratio_measure;
      distance_tolerance                                         : length_measure;
      flat_curvature_radius_tolerance                            : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.RECTANGULAR_COMPOSITE_SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'RECTANGULAR_COMPOSITE_SURFACE_TRANSITION_LOCATOR']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY erroneous_b_spline_surface_definition
    SUBTYPE OF(erroneous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY erroneous_topology_and_geometry_relationship
    ABSTRACT SUPERTYPE OF (ONEOF(inconsistent_edge_and_curve_directions, inconsistent_face_and_surface_normals, inconsistent_face_and_closed_shell_normals, intersecting_loops_in_face, wrongly_placed_loop))
    SUBTYPE OF(erroneous_data);
  END_ENTITY;

  ENTITY inconsistent_edge_and_curve_directions
    SUBTYPE OF(erroneous_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      distance_tolerance : length_measure; -- ISO 10303-59 error!
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE') 
            ;
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE'])
            ;
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY inconsistent_face_and_surface_normals
    SUBTYPE OF(erroneous_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY inconsistent_face_and_closed_shell_normals
    SUBTYPE OF(erroneous_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY intersecting_loops_in_face
    SUBTYPE OF(erroneous_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE',
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY wrongly_placed_loop
    SUBTYPE OF(erroneous_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_BOUND']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY erroneous_manifold_solid_brep
    ABSTRACT SUPERTYPE OF (ONEOF(wrongly_oriented_void, wrongly_placed_void, intersecting_shells_in_solid, solid_with_wrong_number_of_voids))
    SUBTYPE OF(erroneous_data);
  END_ENTITY;

  ENTITY wrongly_oriented_void
    SUBTYPE OF(erroneous_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE') ;
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY wrongly_placed_void
    SUBTYPE OF(erroneous_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE') ;
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY intersecting_shells_in_solid
    SUBTYPE OF(erroneous_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE') ;
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY solid_with_wrong_number_of_voids
    SUBTYPE OF(erroneous_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE') ;
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.BREP_WITH_VOIDS']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY inapt_data
    ABSTRACT SUPERTYPE OF (ONEOF(inapt_topology, inapt_geometry, inapt_topology_and_geometry_relationship, inapt_manifold_solid_brep))
    SUBTYPE OF(shape_data_quality_criterion);
  END_ENTITY;

  ENTITY inapt_topology
    ABSTRACT SUPERTYPE OF (ONEOF(free_edge, non_manifold_at_edge, non_manifold_at_vertex, over_used_vertex))
    SUBTYPE OF(inapt_data);
  END_ENTITY;

  ENTITY free_edge
    SUBTYPE OF(inapt_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            []);
      WR5 : SIZEOF(QUERY(sdqr <* bag_to_set(USEDIN(SELF,
             'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'DATA_QUALITY_INSPECTION_RESULT.'+
             'CRITERION_INSPECTED'))|
             ('SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
              'SHAPE_DATA_QUALITY_INSPECTION_RESULT'
              IN TYPEOF(sdqr)) AND
              (SIZEOF(QUERY(sdqiir <* bag_to_set(USEDIN(sdqr,
                 'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                 'DATA_QUALITY_INSPECTION_REPORT.'+
                 'INSPECTION_RESULT'))|
                 ('SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                  'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT'
                   IN TYPEOF(sdqiir)) AND
                 (SIZEOF(QUERY(sdqiri <* sdqiir.inspected_instances|
                          ('TOPOLOGY_SCHEMA.CLOSED_SHELL'
                   IN TYPEOF(sdqiri.inspected_elements[1])))) = 0)
               )) = 0)
            )) = 0;
 END_ENTITY;

  ENTITY non_manifold_at_edge
    SUBTYPE OF(inapt_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY non_manifold_at_vertex
    SUBTYPE OF(inapt_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.VERTEX_POINT']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY over_used_vertex
    SUBTYPE OF(inapt_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.VERTEX_POINT']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY inapt_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(nearly_degenerate_geometry, discontinuous_geometry, self_intersecting_geometry, geometry_with_local_near_degeneracy, overlapping_geometry, multiply_defined_geometry, geometry_with_local_irregularity, overcomplex_geometry))
    SUBTYPE OF(inapt_data);
  END_ENTITY;

  ENTITY nearly_degenerate_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(small_area_surface, short_length_curve, entirely_narrow_surface))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY small_area_surface
    SUBTYPE OF(nearly_degenerate_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.AREA_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.AREA_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.AREA_MEASURE']);
  END_ENTITY;

  ENTITY short_length_curve
    SUBTYPE OF(nearly_degenerate_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY entirely_narrow_surface
    SUBTYPE OF(nearly_degenerate_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      width_tolerance                                            : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.BOUNDED_SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY discontinuous_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(g1_discontinuous_curve, g2_discontinuous_curve, g1_discontinuous_surface, g2_discontinuous_surface))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY g1_discontinuous_curve
    SUBTYPE OF(discontinuous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_CURVE_KNOT_LOCATOR']);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY g2_discontinuous_curve
    SUBTYPE OF(discontinuous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      assessment_specification_2                                 : shape_data_quality_assessment_by_numerical_test;
      flat_curvature_radius_tolerance                            : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.RATIO_MEASURE'
            IN value_limit_type(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold)) ;
      WR3 : validate_measured_data_type(SELF,
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'PLANE_ANGLE_AND_RATIO_PAIR');
      WR4 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE']);
      WR5 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_CURVE_KNOT_LOCATOR']);
      WR6 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY g1_discontinuous_surface
    SUBTYPE OF(discontinuous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold)) ;
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_KNOT_LOCATOR']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.PLANE_ANGLE_MEASURE']);
  END_ENTITY;

  ENTITY g2_discontinuous_surface
    SUBTYPE OF(discontinuous_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      assessment_specification_2                                 : shape_data_quality_assessment_by_numerical_test;
      flat_curvature_radius_tolerance                            : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.RATIO_MEASURE'
            IN value_limit_type(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold));
      WR3 : validate_measured_data_type(SELF,
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'PLANE_ANGLE_AND_RATIO_PAIR');
      WR4 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR5 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_KNOT_LOCATOR']);
      WR6 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.RATIO_MEASURE'])
            ;
  END_ENTITY;

  ENTITY self_intersecting_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(self_intersecting_curve, self_intersecting_surface))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY self_intersecting_curve
    SUBTYPE OF(self_intersecting_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      arc_length_separation_factor                               : REAL;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.CURVE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.POINT_ON_CURVE','GEOMETRY_SCHEMA.POINT_ON_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY self_intersecting_surface
    SUBTYPE OF(self_intersecting_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      geodesic_separation_factor                                 : REAL;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.POINT_ON_SURFACE',
             'GEOMETRY_SCHEMA.POINT_ON_SURFACE']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY geometry_with_local_near_degeneracy
    ABSTRACT SUPERTYPE OF (ONEOF(curve_with_small_curvature_radius, short_length_curve_segment, surface_with_small_curvature_radius, small_area_surface_patch, narrow_surface_patch, indistinct_surface_knots, indistinct_curve_knots, nearly_degenerate_surface_boundary, nearly_degenerate_surface_patch))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY curve_with_small_curvature_radius
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.POINT_ON_CURVE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY short_length_curve_segment
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_CURVE_SEGMENT']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY surface_with_small_curvature_radius
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.POINT_ON_SURFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY small_area_surface_patch
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.AREA_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.AREA_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_PATCH']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.AREA_MEASURE']);
  END_ENTITY;

  ENTITY narrow_surface_patch
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      width_tolerance                                            : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_PATCH']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY indistinct_surface_knots
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PARAMETER_VALUE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PARAMETER_VALUE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_KNOT_LOCATOR']);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY indistinct_curve_knots
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PARAMETER_VALUE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PARAMETER_VALUE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_CURVE_KNOT_LOCATOR']);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY nearly_degenerate_surface_boundary
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_VALUE_RANGE'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_OR_RECTANGULAR_COMPOSITE_SURFACE_SELECT']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'BOUNDARY_CURVE_OF_B_SPLINE_OR_RECTANGULAR_COMPOSITE_SURFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY nearly_degenerate_surface_patch
    SUBTYPE OF(geometry_with_local_near_degeneracy);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_VALUE_RANGE'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_PATCH']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY overlapping_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(partly_overlapping_curves, partly_overlapping_surfaces))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY partly_overlapping_curves
    SUBTYPE OF(overlapping_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.CURVE','GEOMETRY_SCHEMA.CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.TRIMMED_CURVE','GEOMETRY_SCHEMA.TRIMMED_CURVE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY partly_overlapping_surfaces
    SUBTYPE OF(overlapping_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.AREA_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.AREA_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE','GEOMETRY_SCHEMA.SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE',
             'GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.AREA_MEASURE']);
  END_ENTITY;

  ENTITY multiply_defined_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(multiply_defined_curves, multiply_defined_surfaces, multiply_defined_cartesian_points, multiply_defined_directions, multiply_defined_placements))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY multiply_defined_curves
    SUBTYPE OF(multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.CURVE','GEOMETRY_SCHEMA.CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY multiply_defined_surfaces
    SUBTYPE OF(multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold)) AND
            ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE','GEOMETRY_SCHEMA.SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY multiply_defined_cartesian_points
    SUBTYPE OF(multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.CARTESIAN_POINT','GEOMETRY_SCHEMA.CARTESIAN_POINT']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY multiply_defined_directions
    SUBTYPE OF(multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.DIRECTION','GEOMETRY_SCHEMA.DIRECTION']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY multiply_defined_placements
    SUBTYPE OF(multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      assessment_specification_2                                 : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold));
      WR3 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
            'PLANE_ANGLE_AND_LENGTH_PAIR');
      WR4 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.PLACEMENT','GEOMETRY_SCHEMA.PLACEMENT']);
      WR5 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR6 : validate_accuracy_types(SELF,
            []);
      WR7 : SIZEOF(QUERY(sdqr <* bag_to_set(USEDIN(SELF,
             'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'DATA_QUALITY_INSPECTION_RESULT.'+
             'CRITERION_INSPECTED'))|
             ('SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
              'SHAPE_DATA_QUALITY_INSPECTION_RESULT'
              IN TYPEOF(sdqr)) AND
              (SIZEOF(QUERY(sdqiir <* bag_to_set(USEDIN(sdqr,
                 'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                 'DATA_QUALITY_INSPECTION_REPORT.'+
                 'INSPECTION_RESULT'))|
                 ('SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                  'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT'
                   IN TYPEOF(sdqiir)) AND
                 (SIZEOF(QUERY(sdqiri <* sdqiir.inspected_instances|
                          (TYPEOF(sdqiri.inspected_elements[1])
                           <>TYPEOF(sdqiri.inspected_elements[2])))) = 0)
               )) = 0)
            )) = 0;
  END_ENTITY;

  ENTITY geometry_with_local_irregularity
    ABSTRACT SUPERTYPE OF (ONEOF(extreme_patch_width_variation, zero_surface_normal, abrupt_change_of_surface_normal))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY extreme_patch_width_variation
    SUBTYPE OF(geometry_with_local_irregularity);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.RATIO_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.RATIO_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_KNOT_LOCATOR']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY zero_surface_normal
    SUBTYPE OF(geometry_with_local_irregularity);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.POINT_ON_SURFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.PLANE_ANGLE_MEASURE']);
  END_ENTITY;

  ENTITY abrupt_change_of_surface_normal
    SUBTYPE OF(geometry_with_local_irregularity);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      small_vector_tolerance                                     : length_measure;
      test_point_distance_tolerance                              : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.POINT_ON_SURFACE',
             'GEOMETRY_SCHEMA.POINT_ON_SURFACE']);
      WR4 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY overcomplex_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(excessively_high_degree_curve, excessively_high_degree_surface, surface_with_excessive_patches_in_one_direction, curve_with_excessive_segments, high_degree_linear_curve, high_degree_planar_surface, high_degree_conic, high_degree_axi_symmetric_surface))
    SUBTYPE OF(inapt_geometry);
  END_ENTITY;

  ENTITY excessively_high_degree_curve
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY excessively_high_degree_surface
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY surface_with_excessive_patches_in_one_direction
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_OR_RECTANGULAR_COMPOSITE_SURFACE_SELECT']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY curve_with_excessive_segments
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_OR_COMPOSITE_CURVE_SELECT']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY high_degree_linear_curve
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      approximation_tolerance                                    : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY high_degree_planar_surface
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      approximation_tolerance                                    : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY high_degree_conic
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      approximation_tolerance                                    : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY high_degree_axi_symmetric_surface
    SUBTYPE OF(overcomplex_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      approximation_tolerance                                    : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRY_SCHEMA.B_SPLINE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY inapt_topology_and_geometry_relationship
    ABSTRACT SUPERTYPE OF (ONEOF(topology_related_to_nearly_degenerate_geometry, geometric_gap_in_topology, non_smooth_geometry_transition_across_edge, topology_related_to_self_intersecting_geometry, steep_geometry_transition_across_edge, topology_related_to_overlapping_geometry, topology_related_to_multiply_defined_geometry, overcomplex_topology_and_geometry_relationship))
    SUBTYPE OF(inapt_data);
  END_ENTITY;

  ENTITY topology_related_to_nearly_degenerate_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(short_length_edge, small_area_face, entirely_narrow_face))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY short_length_edge
    SUBTYPE OF(topology_related_to_nearly_degenerate_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
             AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY small_area_face
    SUBTYPE OF(topology_related_to_nearly_degenerate_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.AREA_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.AREA_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.AREA_MEASURE']);
  END_ENTITY;

  ENTITY entirely_narrow_face
    SUBTYPE OF(topology_related_to_nearly_degenerate_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      width_tolerance                                            : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY geometric_gap_in_topology
    ABSTRACT SUPERTYPE OF (ONEOF(gap_between_adjacent_edges_in_loop, gap_between_vertex_and_base_surface, gap_between_vertex_and_edge, gap_between_edge_and_base_surface, gap_between_pcurves_related_to_an_edge, gap_between_faces_related_to_an_edge))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY gap_between_adjacent_edges_in_loop
    SUBTYPE OF(geometric_gap_in_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_LOOP']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.ORIENTED_EDGE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY gap_between_vertex_and_base_surface
    SUBTYPE OF(geometric_gap_in_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.VERTEX_POINT',
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_FACE_SURFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY gap_between_vertex_and_edge
    SUBTYPE OF(geometric_gap_in_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.VERTEX_POINT',
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY gap_between_edge_and_base_surface
    SUBTYPE OF(geometric_gap_in_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE',
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_FACE_SURFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY gap_between_pcurves_related_to_an_edge
    SUBTYPE OF(geometric_gap_in_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['GEOMETRY_SCHEMA.POINT_ON_SURFACE',
             'GEOMETRY_SCHEMA.POINT_ON_SURFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY gap_between_faces_related_to_an_edge
    SUBTYPE OF(geometric_gap_in_topology);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY non_smooth_geometry_transition_across_edge
    ABSTRACT SUPERTYPE OF (ONEOF(g1_discontinuity_between_adjacent_faces, g2_discontinuity_between_adjacent_faces))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY g1_discontinuity_between_adjacent_faces
    SUBTYPE OF(non_smooth_geometry_transition_across_edge);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.PLANE_ANGLE_MEASURE']);
  END_ENTITY;

  ENTITY g2_discontinuity_between_adjacent_faces
    SUBTYPE OF(non_smooth_geometry_transition_across_edge);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      assessment_specification_2                                 : shape_data_quality_assessment_by_numerical_test;
      flat_curvature_radius_tolerance                            : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.RATIO_MEASURE'
            IN value_limit_type(assessment_specification_2\shape_data_quality_assessment_by_numerical_test.threshold));
      WR3 : validate_measured_data_type(SELF,
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'PLANE_ANGLE_AND_RATIO_PAIR');
      WR4 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR5 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE']);
      WR6 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.RATIO_MEASURE']);
  END_ENTITY;

  ENTITY topology_related_to_self_intersecting_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(self_intersecting_loop, self_intersecting_shell, intersecting_connected_face_sets))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY self_intersecting_loop
    SUBTYPE OF(topology_related_to_self_intersecting_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      arc_length_distance_factor                                 : REAL;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_LOOP']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE',
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY self_intersecting_shell
    SUBTYPE OF(topology_related_to_self_intersecting_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      geodesic_separation_factor                                 : REAL;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_FACE_SURFACE',
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_FACE_SURFACE']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY intersecting_connected_face_sets
    SUBTYPE OF(topology_related_to_self_intersecting_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET',
             'TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_FACE_SURFACE',
             'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_FACE_SURFACE']);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY steep_geometry_transition_across_edge
    ABSTRACT SUPERTYPE OF (ONEOF(steep_angle_between_adjacent_edges, steep_angle_between_adjacent_faces))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY steep_angle_between_adjacent_edges
    SUBTYPE OF(steep_geometry_transition_across_edge);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_LOOP']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.ORIENTED_EDGE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.PLANE_ANGLE_MEASURE']);
  END_ENTITY;

  ENTITY steep_angle_between_adjacent_faces
    SUBTYPE OF(steep_geometry_transition_across_edge);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.CONNECTED_FACE_SET']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'POINT_ON_EDGE_CURVE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.PLANE_ANGLE_MEASURE']);
  END_ENTITY;

  ENTITY topology_related_to_overlapping_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(partly_overlapping_faces, partly_overlapping_edges))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY partly_overlapping_faces
    SUBTYPE OF(topology_related_to_overlapping_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.AREA_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.AREA_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE',
             'TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.SUBFACE','TOPOLOGY_SCHEMA.SUBFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.AREA_MEASURE']);
  END_ENTITY;

  ENTITY partly_overlapping_edges
    SUBTYPE OF(topology_related_to_overlapping_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE',
             'TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.SUBEDGE','TOPOLOGY_SCHEMA.SUBEDGE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY topology_related_to_multiply_defined_geometry
    ABSTRACT SUPERTYPE OF (ONEOF(multiply_defined_faces, multiply_defined_vertices, multiply_defined_edges))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY multiply_defined_faces
    SUBTYPE OF(topology_related_to_multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE',
             'TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY multiply_defined_vertices
    SUBTYPE OF(topology_related_to_multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold)) AND
            ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.VERTEX_POINT',
             'TOPOLOGY_SCHEMA.VERTEX_POINT']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY multiply_defined_edges
    SUBTYPE OF(topology_related_to_multiply_defined_geometry);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE',
             'TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY overcomplex_topology_and_geometry_relationship
    ABSTRACT SUPERTYPE OF (ONEOF(unused_patches, edge_with_excessive_segments, face_surface_with_excessive_patches_in_one_direction))
    SUBTYPE OF(inapt_topology_and_geometry_relationship);
  END_ENTITY;

  ENTITY unused_patches
    SUBTYPE OF(overcomplex_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
             AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
             'B_SPLINE_SURFACE_STRIP']);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY edge_with_excessive_segments
    SUBTYPE OF(overcomplex_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.EDGE_CURVE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY face_surface_with_excessive_patches_in_one_direction
    SUBTYPE OF(overcomplex_topology_and_geometry_relationship);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['TOPOLOGY_SCHEMA.FACE_SURFACE']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY inapt_manifold_solid_brep
    ABSTRACT SUPERTYPE OF (ONEOF(partly_overlapping_solids, small_volume_solid, multiply_defined_solids, entirely_narrow_solid, solid_with_excessive_number_of_voids))
    SUBTYPE OF(inapt_data);
  END_ENTITY;

  ENTITY partly_overlapping_solids
    SUBTYPE OF(inapt_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
      interference_tolerance                                     : length_measure;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
             AND ('MEASURE_SCHEMA.AREA_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.AREA_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP',
             'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            ['TOPOLOGY_SCHEMA.SUBFACE','TOPOLOGY_SCHEMA.SUBFACE']);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.AREA_MEASURE']);
  END_ENTITY;

  ENTITY small_volume_solid
    SUBTYPE OF(inapt_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.VOLUME_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.VOLUME_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.VOLUME_MEASURE']);
  END_ENTITY;

  ENTITY multiply_defined_solids
    SUBTYPE OF(inapt_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_UPPER_VALUE_LIMIT'
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.LENGTH_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.LENGTH_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP',
             'GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY entirely_narrow_solid
    SUBTYPE OF(inapt_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_logical_test;
      width_tolerance                                            : length_measure;
    WHERE
      WR1 : validate_measured_data_type(SELF,
            'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.BOOLEAN_VALUE');
      WR2 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP']);
      WR3 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR4 : validate_accuracy_types(SELF,
            ['MEASURE_SCHEMA.LENGTH_MEASURE']);
  END_ENTITY;

  ENTITY solid_with_excessive_number_of_voids
    SUBTYPE OF(inapt_manifold_solid_brep);
      SELF\shape_data_quality_criterion.assessment_specification : shape_data_quality_assessment_by_numerical_test;
    WHERE
      WR1 : ('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.' +
            'SHAPE_DATA_QUALITY_LOWER_VALUE_LIMIT' 
            IN TYPEOF(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold))
            AND ('MEASURE_SCHEMA.COUNT_MEASURE'
            IN value_limit_type(SELF\shape_data_quality_criterion.assessment_specification\shape_data_quality_assessment_by_numerical_test.threshold));
      WR2 : validate_measured_data_type(SELF,
            'MEASURE_SCHEMA.COUNT_MEASURE');
      WR3 : validate_inspected_elements_type(SELF,
            ['GEOMETRIC_MODEL_SCHEMA.MANIFOLD_SOLID_BREP']);
      WR4 : validate_locations_of_extreme_value_type(SELF,
            []);
      WR5 : validate_accuracy_types(SELF,
            []);
  END_ENTITY;

  ENTITY shape_criteria_representation_with_accuracy
    SUBTYPE OF(shape_data_quality_criteria_representation);
      required_general_accuracy : SET [1:?] OF shape_measurement_accuracy;
  END_ENTITY;

  ENTITY shape_measurement_accuracy;
      description : text;
      range       : shape_data_quality_value_limit_type_select;
  END_ENTITY;

  ENTITY shape_data_quality_criterion_and_accuracy_association;
      required_specific_accuracy   : shape_measurement_accuracy;
      shape_data_quality_criterion : shape_data_quality_criterion;
  END_ENTITY;



  FUNCTION validate_inspected_elements_type
    (ei:shape_data_quality_criterion;
     type_list:BAG OF STRING):LOGICAL;
     LOCAL
       sdqir: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_RESULT:=[];
       sdir: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT:=[];
       sdiri: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT_ITEM:=[];
       t_type_list:BAG OF STRING:=[];
     END_LOCAL;
  
     -- STEP-1
     -- collect all shape_data_quality_inspection_instance_report_item
     -- instances associated with the given shape_data_quality_criterion
     -- via shape_data_quality_inspection_result and
     -- shape_data_quality_inspection_instance_report

     sdqir := QUERY(q <* bag_to_set(USEDIN(ei,
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_RESULT.'+
                   'CRITERION_INSPECTED'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT'
            IN TYPEOF(q));
     IF(SIZEOF(sdqir) = 0) THEN
       RETURN(TRUE);
     END_IF;
     REPEAT i:= 1 TO SIZEOF(sdqir);
       sdir := sdir + QUERY(q <* bag_to_set(USEDIN(sdqir[i],
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_REPORT.'+
                   'INSPECTION_RESULT'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT'
            IN TYPEOF(q));
     END_REPEAT;
     IF(SIZEOF(sdir) = 0) THEN
       RETURN(TRUE);
     END_IF;

     REPEAT i:= 1 TO SIZEOF(sdir);
       sdiri := sdiri + QUERY(q <* sdir[i].inspected_instances|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT_ITEM'
            IN TYPEOF(q));
     END_REPEAT;

     -- STEP-2
     -- check if the types of inspected_elements of the collected
     -- instances are exactly coincident with the type names in the 
     -- type list given as an input argument of this function.

     -- If there is no instance_report_item, then return true.
     IF(SIZEOF(sdiri) = 0) THEN
       RETURN(TRUE);
     END_IF;
  
     -- When reports exist, then perform the following checking process.
     REPEAT i:= 1 TO SIZEOF(sdiri);
       -- If the size of inspected_elements is not equal to the size of
       -- type_list, then return false.
       IF(SIZEOF(sdiri[i].inspected_elements) <> 
          SIZEOF(type_list)) THEN
         RETURN(FALSE);
       END_IF;
       -- check all elements in the type_list 
       -- for each element of inspected_elements.
       t_type_list := type_list;
       REPEAT j:= 1 TO SIZEOF(sdiri[i].inspected_elements);
         REPEAT k:= 1 TO SIZEOF(t_type_list);
           IF(t_type_list[k] IN
              TYPEOF(sdiri[i].inspected_elements[j])) THEN
            t_type_list := t_type_list - t_type_list[k];
            ESCAPE;
           END_IF;
         END_REPEAT;
       END_REPEAT;
       IF(SIZEOF(t_type_list) > 0) THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
  
    RETURN(TRUE);
  END_FUNCTION;

  FUNCTION validate_locations_of_extreme_value_type
    (ei:shape_data_quality_criterion;
     type_list:BAG OF STRING):LOGICAL;
     LOCAL
       sdqir: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_RESULT:=[];
       sdir: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT:=[];
       sdei: SET OF
        INSTANCE_REPORT_ITEM_WITH_EXTREME_INSTANCES:=[];
       t_type_list:BAG OF STRING:=[];
     END_LOCAL;
  
     -- STEP-1
     -- collect all instance_report_item_with_extreme_instances instances
     -- associated with the given shape_data_quality_criterion
     -- via shape_data_quality_inspection_result and
     -- shape_data_quality_inspection_instance_report.

     sdqir := QUERY(q <* bag_to_set(USEDIN(ei,
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_RESULT.'+
                   'CRITERION_INSPECTED'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT'
            IN TYPEOF(q));
     IF(SIZEOF(sdqir) = 0) THEN
       RETURN(TRUE);
     END_IF;
     REPEAT i:= 1 TO SIZEOF(sdqir);
       sdir := sdir + QUERY(q <* bag_to_set(USEDIN(sdqir[i],
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_REPORT.'+
                   'INSPECTION_RESULT'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT'
            IN TYPEOF(q));
     END_REPEAT;
     REPEAT i:= 1 TO SIZEOF(sdir);
       sdei := sdei + QUERY(q <* sdir[i].inspected_instances|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'INSTANCE_REPORT_ITEM_WITH_EXTREME_INSTANCES'
            IN TYPEOF(q));
     END_REPEAT;
  
     -- STEP-2
     -- check if the types of locations_of_extreme_value attributes
     -- of all extreme_instances attributes of the collected instances are 
     -- exactly coincident with the type names in the type list given as an 
     -- input argument of this function. 

     -- If there is no instance report, then return true.
     IF(SIZEOF(sdei) = 0) THEN
       RETURN(TRUE);
     END_IF;
  
     -- If the type_list is empty and 
     -- instance_report_item_with_extreme_instances exists, then return false.
     IF((SIZEOF(type_list) = 0) AND (SIZEOF(sdei) <> 0)) THEN
       RETURN(FALSE);
     END_IF;
  
     -- When report_items exist, then perform the following checking process.
     REPEAT i:= 1 TO SIZEOF(sdei);
       REPEAT j:= 1 TO SIZEOF(sdei[i].extreme_instances);
         -- If the size of locations_of_extreme_value is not equal to
         -- the size of type_list, then return false.
         IF(SIZEOF(sdei[i].extreme_instances[j].
                           locations_of_extreme_value) <>
            SIZEOF(type_list)) THEN
            RETURN(FALSE);
         END_IF;
         t_type_list := type_list;
         -- check all elements of the type_list 
         --  for each element of locations_of_extreme_value.
         REPEAT k:= 1 TO SIZEOF(sdei[i].extreme_instances[j]
                                  .locations_of_extreme_value);
           REPEAT l:= 1 TO SIZEOF(t_type_list);
             IF(t_type_list[l] IN
               TYPEOF(sdei[i].extreme_instances[j].
                       locations_of_extreme_value[k])) THEN
               t_type_list := t_type_list - t_type_list[l];
               ESCAPE;
             END_IF;
           END_REPEAT;
         END_REPEAT;
         IF(SIZEOF(t_type_list) > 0) THEN
           RETURN(FALSE);
         END_IF;
       END_REPEAT;
     END_REPEAT;
  
     RETURN(TRUE);
  END_FUNCTION;

  FUNCTION validate_measured_data_type
    (ei:shape_data_quality_criterion;
     type_string: STRING):LOGICAL;
     LOCAL
       sdqir: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_RESULT:=[];
       sdcr: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_CRITERION_REPORT:=[];
       sdir: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT:=[];
       sdii: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT_ITEM:=[];
       sdei: BAG OF
        INSTANCE_REPORT_ITEM_WITH_EXTREME_INSTANCES:=[];
     END_LOCAL;
  
     -- STEP-1
     -- collect all shape_data_quality_inspection_criterion_report instances,
     -- all shape_data_quality_inspection_instance_report_item instances, and
     -- instance_report_item_with_extreme_instances instances
     -- associated with the given shape_data_quality_criterion
     -- via shape_data_quality_inspection_result.
  
     sdqir := QUERY(q <* bag_to_set(USEDIN(ei,
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_RESULT.'+
                   'CRITERION_INSPECTED'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT'
            IN TYPEOF(q));
     IF(SIZEOF(sdqir) = 0) THEN
       RETURN(TRUE);
     END_IF;
     REPEAT i:= 1 TO SIZEOF(sdqir);
       sdcr := sdcr + QUERY(q <* bag_to_set(USEDIN(sdqir[i],
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_REPORT.'+
                   'INSPECTION_RESULT'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_CRITERION_REPORT'
            IN TYPEOF(q));
     END_REPEAT;
     REPEAT i:= 1 TO SIZEOF(sdqir);
       sdir := sdir + QUERY(q <* bag_to_set(USEDIN(sdqir[i],
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_REPORT.'+
                   'INSPECTION_RESULT'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT'
            IN TYPEOF(q));
     END_REPEAT;
  
     -- If there is no report, then return true.
     IF((SIZEOF(sdcr) = 0) AND (SIZEOF(sdir) = 0)) THEN
       RETURN(TRUE);
     END_IF;
  
     REPEAT i:= 1 TO SIZEOF(sdir);
       sdii := sdii + QUERY(q <* sdir[i].inspected_instances|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT_ITEM'
            IN TYPEOF(q));
     END_REPEAT;
     REPEAT i:= 1 TO SIZEOF(sdir);
       sdei := sdei + QUERY(q <* sdir[i].inspected_instances|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'INSTANCE_REPORT_ITEM_WITH_EXTREME_INSTANCES'
            IN TYPEOF(q));
     END_REPEAT;
  
     -- When reports exist, then perform the following checking process.  
     -- Check representative_measured_value of 
     -- shape_data_quality_inspection_criterion_report
     REPEAT i:= 1 TO SIZEOF(sdcr);
      IF(NOT(type_string IN
         TYPEOF(sdcr[i].representative_measured_value))) THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
  
     -- Check measured_value of shape_data_quality_inspection_
     -- instance_report_item
     REPEAT i:= 1 TO SIZEOF(sdii);
       IF(NOT(type_string IN
         TYPEOF(sdii[i].measured_value))) THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
  
     -- Check measured_value of extreme_instances of
     -- instance_report_item_with_extreme_instance
     REPEAT i:= 1 TO SIZEOF(sdei);
       REPEAT j:= 1 TO SIZEOF(sdei[i].extreme_instances);
         IF(NOT(type_string IN
           TYPEOF(sdei[i].extreme_instances[j].measured_value)))
         THEN
           RETURN(FALSE);
         END_IF;
       END_REPEAT;
     END_REPEAT;
  
     RETURN(TRUE);
  
  END_FUNCTION;

  FUNCTION validate_accuracy_types
    (ei:shape_data_quality_criterion;
     type_list:BAG OF STRING):LOGICAL;
     LOCAL
       sdqca: BAG OF
        SHAPE_DATA_QUALITY_CRITERION_AND_ACCURACY_ASSOCIATION:=[];
       sma: BAG OF SHAPE_MEASUREMENT_ACCURACY:=[];
       sdqir: SET OF
        SHAPE_DATA_QUALITY_INSPECTION_RESULT:=[];
       scraa: BAG OF
        SHAPE_INSPECTION_RESULT_ACCURACY_ASSOCIATION:=[];
       t_logic:BOOLEAN;
     END_LOCAL;
     -- STEP-1
     -- collect types of range attribute of shape_measurement_accuracy
     -- referred from shape_data_quality_criterion_and_accuracy_association 
     -- that refers to given shape_data_quality_criterion.
     sdqca := USEDIN(ei,
               'SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.'+
               'SHAPE_DATA_QUALITY_CRITERION_AND_ACCURACY_ASSOCIATION.'+
               'SHAPE_DATA_QUALITY_CRITERION');
     IF(SIZEOF(sdqca) <> 0) THEN
       REPEAT i:= 1 TO SIZEOF(sdqca);
         sma := sma + sdqca[i].required_specific_accuracy;
       END_REPEAT;
  
       -- STEP-2
       -- check whether the collected types include all the type names
       -- in the type list given as an input argument of this function
       -- and they do not include any other type names. 
       IF(SIZEOF(type_list) < SIZEOF(sma)) THEN
         RETURN(FALSE);
       END_IF;
  
       REPEAT i:= 1 TO SIZEOF(sma);
         t_logic := FALSE;
         REPEAT j:= 1 TO SIZEOF(type_list);
           IF(type_list[j] IN value_limit_type(sma[i].range)) THEN
             t_logic := TRUE;
             ESCAPE;
           END_IF;
         END_REPEAT;
         IF(NOT(t_logic)) THEN
           RETURN(FALSE);
         END_IF;
       END_REPEAT;
    END_IF;
  
     -- STEP-3
     -- collect types of range attribute of shape_measurement_accuracy
     -- referred from shape_inspection_result_accuracy_association
     -- that refers to shape_data_quality_inspection_result
     -- for the given shape_data_quality_criterion.
     sdqir := QUERY(q <* bag_to_set(USEDIN(ei,
                   'PRODUCT_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                   'DATA_QUALITY_INSPECTION_RESULT.'+
                   'CRITERION_INSPECTED'))|
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
           'SHAPE_DATA_QUALITY_INSPECTION_RESULT'
            IN TYPEOF(q));
     IF(SIZEOF(sdqir) = 0) THEN
       RETURN(TRUE);
     END_IF;
  
     REPEAT i:= 1 TO SIZEOF(sdqir);
       scraa := USEDIN(sdqir[i],
               'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
               'SHAPE_INSPECTION_RESULT_ACCURACY_ASSOCIATION.'+
               'SHAPE_DATA_QUALITY_RESULT');
       IF(SIZEOF(scraa) <> 0) THEN
         sma := [];
         REPEAT j:= 1 TO SIZEOF(scraa);
           sma := sma + scraa[j].applied_specific_accuracy;
         END_REPEAT;
  
         -- STEP-4
         -- check whether the collected types include all the type
         -- names in the type list given as an input argument of
         -- this function and they do not include any other type names.
         IF(SIZEOF(type_list) < SIZEOF(sma)) THEN
           RETURN(FALSE);
         END_IF;
  
         REPEAT j:= 1 TO SIZEOF(sma);
           t_logic := FALSE;
           REPEAT k:= 1 TO SIZEOF(type_list);
             IF(type_list[k] IN value_limit_type(sma[j].range)) THEN
               t_logic := TRUE;
               ESCAPE;
             END_IF;
           END_REPEAT;
           IF(NOT(t_logic)) THEN
             RETURN(FALSE);
           END_IF;
         END_REPEAT;
       END_IF;
     END_REPEAT;
  
     RETURN(TRUE);
  END_FUNCTION;

  FUNCTION value_limit_type
    (iv:shape_data_quality_value_limit_type_select):SET OF STRING;
    LOCAL
      retval  : SET OF STRING := [];
    END_LOCAL;
    IF(('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.'
       +'SHAPE_DATA_QUALITY_VALUE_RANGE') IN TYPEOF(iv)) THEN
      retval := TYPEOF(iv\compound_representation_item.item_element[1].value_component);
    END_IF;
    IF(('SHAPE_DATA_QUALITY_CRITERIA_SCHEMA.'
       +'SHAPE_DATA_QUALITY_VALUE_LIMIT') IN TYPEOF(iv)) THEN
          IF(('MEASURE_SCHEMA.' + 'MEASURE_WITH_UNIT') IN TYPEOF(iv)) THEN
             retval := TYPEOF(iv\measure_with_unit.value_component);
         END_IF;
    END_IF;
    RETURN(retval);
  END_FUNCTION;

END_SCHEMA;
(*
 ISO TC184/SC4/WG12 N7298 - ISO 10303-59 Quality of product shape data
 Supersedes ISO TC184/SC4/WG12 N5088
*)

SCHEMA shape_data_quality_inspection_result_schema;

 REFERENCE FROM geometric_model_schema;

 REFERENCE FROM geometry_schema;

 REFERENCE FROM measure_schema;

 REFERENCE FROM product_data_quality_criteria_schema;

 REFERENCE FROM product_data_quality_inspection_result_schema;

 REFERENCE FROM product_definition_schema
   (product_definition);

 REFERENCE FROM product_property_definition_schema
   (property_definition,
    product_definition_shape,
    characterized_product_definition);

 REFERENCE FROM product_property_representation_schema
   (property_definition_representation,
    shape_representation,
    shape_representation_relationship,
    shape_definition_representation);

 REFERENCE FROM qualified_measure_schema
   (qualified_representation_item,
    value_qualifier,
    type_qualifier,
    measure_representation_item);

 REFERENCE FROM representation_schema
   (founded_item_select,
    founded_item,
    representation,
    representation_item,
    using_representations,
    representation_relationship,
    compound_representation_item,
    value_representation_item,
    set_representation_item);

 REFERENCE FROM SHAPE_DATA_QUALITY_CRITERIA_SCHEMA;

 REFERENCE FROM SUPPORT_RESOURCE_SCHEMA
   (bag_to_set);

 REFERENCE FROM TOPOLOGY_SCHEMA;

 TYPE measured_value_select = SELECT
   (boolean_value,
    measure_value,
    plane_angle_and_ratio_pair,
    plane_angle_and_length_pair);
 END_TYPE;

 TYPE boolean_value = BOOLEAN;
 END_TYPE;

 TYPE location_of_extreme_value_select = SELECT
   (inspected_shape_element_select,
    b_spline_surface_knot_locator,
    b_spline_curve_knot_locator,
    b_spline_curve_segment,
    b_spline_surface_strip,
    b_spline_surface_patch,
    composite_curve_transition_locator,
    rectangular_composite_surface_transition_locator,
    boundary_curve_of_b_spline_or_rectangular_composite_surface,
    oriented_edge,
    face_bound,
    point_on_edge_curve,
    point_on_face_surface,
    subedge,
    subface);
 END_TYPE;

 TYPE inspected_shape_element_select = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON inspected_element_select WITH
   (edge_loop,
    edge_curve,
    face_surface,
    curve,
    surface,
    vertex_point,
    closed_or_open_shell_select,
    b_spline_or_composite_curve_select,
    b_spline_or_rectangular_composite_surface_select,
    point,
    connected_face_set,
    manifold_solid_brep,
    direction,
    placement);
 END_TYPE;

 TYPE closed_or_open_shell_select = SELECT
   (closed_shell,
    open_shell);
 END_TYPE;

 TYPE b_spline_or_composite_curve_select = SELECT
   (b_spline_curve,
    composite_curve);
 END_TYPE;

 TYPE b_spline_or_rectangular_composite_surface_select = SELECT
   (b_spline_surface,
    rectangular_composite_surface);
 END_TYPE;

  TYPE u_or_v_parameter = ENUMERATION OF
   (u_parameter,
    v_parameter);
 END_TYPE;

TYPE surface_boundary_type = ENUMERATION OF
   (u_parameter_min,
    v_parameter_min,
    u_parameter_max,
    v_parameter_max);
 END_TYPE;

 ENTITY shape_data_quality_inspection_result_representation
   SUBTYPE OF(data_quality_inspection_result_representation);
   WHERE
     WR1 : SIZEOF( QUERY( q <* SELF\representation.items|
                              'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.' +
                              'SHAPE_DATA_QUALITY_INSPECTION_RESULT' IN TYPEOF(q))) > 0;
     WR2 : 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
           TYPEOF(SELF\representation.context_of_items);
     WR3 : SIZEOF(USEDIN(SELF,
                  'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.'+
                  'SHAPE_DATA_QUALITY_INSPECTED_SHAPE_AND_RESULT_RELATIONSHIP.'+
                  'REP_2'))>0;
 END_ENTITY;

 ENTITY shape_inspection_result_representation_with_accuracy
   SUBTYPE OF(shape_data_quality_inspection_result_representation);
     applied_general_accuracy : SET [1:?] OF shape_measurement_accuracy;
 END_ENTITY;

 ENTITY shape_data_quality_inspected_shape_and_result_relationship
   SUBTYPE OF(shape_representation_relationship);
     SELF\representation_relationship.rep_1 : shape_representation;
     SELF\representation_relationship.rep_2 : shape_data_quality_inspection_result_representation;
   WHERE
     WR1 : SIZEOF(
           using_product_definition_of_shape_representation(SELF.rep_1)
           *
           bag_to_set(inspected_product_definition(SELF.rep_2))
           ) > 0;
     WR2 : SELF.rep_1\representation.context_of_items :=: 
           SELF.rep_2\representation.context_of_items;
 END_ENTITY;

 ENTITY shape_data_quality_inspection_result
   SUBTYPE OF(data_quality_inspection_result);
    SELF\data_quality_inspection_result.criterion_inspected:shape_data_quality_criterion;
 END_ENTITY;

 ENTITY shape_data_quality_inspection_criterion_report
   SUBTYPE OF(data_quality_inspection_criterion_report);
     representative_measured_value : measured_value_select;
 END_ENTITY;

 ENTITY shape_inspection_result_accuracy_association;
     applied_specific_accuracy : shape_measurement_accuracy;
     shape_data_quality_result : shape_data_quality_inspection_result;
 END_ENTITY;

 ENTITY shape_data_quality_inspection_instance_report
   SUBTYPE OF(data_quality_inspection_instance_report);
     SELF\data_quality_inspection_instance_report.inspected_instances : LIST [1:?] OF shape_data_quality_inspection_instance_report_item;
 END_ENTITY;

 ENTITY shape_data_quality_inspection_instance_report_item
   SUBTYPE OF(data_quality_inspection_instance_report_item);
     SELF\data_quality_inspection_instance_report_item.inspected_elements : SET [1:?] OF inspected_shape_element_select;
     measured_value     : measured_value_select;
 END_ENTITY;

 ENTITY instance_report_item_with_extreme_instances
   SUBTYPE OF(shape_data_quality_inspection_instance_report_item);
     extreme_instances : LIST [1:?] OF extreme_instance;
 END_ENTITY;

 ENTITY extreme_instance;
     locations_of_extreme_value : SET [1:?] OF location_of_extreme_value_select;
     measured_value             : measured_value_select;
 END_ENTITY;

 ENTITY point_on_edge_curve
   SUBTYPE OF(point_on_curve);
     basis_edge_curve                : edge_curve;
   DERIVE
     SELF\point_on_curve.basis_curve : curve := SELF.basis_edge_curve.edge_geometry;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_edge_curve) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY point_on_face_surface
   SUBTYPE OF(point_on_surface);
     basis_face_surface                  : face_surface;
   DERIVE
     SELF\point_on_surface.basis_surface : surface := SELF.basis_face_surface.face_geometry;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_face_surface) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY plane_angle_and_ratio_pair
   SUBTYPE OF(founded_item);
     plane_angle_value : plane_angle_measure;
     ratio_value       : ratio_measure;
 END_ENTITY;

 ENTITY plane_angle_and_length_pair
   SUBTYPE OF(founded_item);
     plane_angle_value : plane_angle_measure;
     length_value      : length_measure;
 END_ENTITY;

 ENTITY b_spline_surface_knot_locator
   SUBTYPE OF(founded_item);
     basis_surface     : b_spline_surface;
     knot_index        : INTEGER;
     surface_parameter : u_or_v_parameter;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_surface) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY b_spline_surface_patch
   SUBTYPE OF(founded_item);
     basis_surface      : b_spline_surface;
     u_start_knot_index : INTEGER;
     v_start_knot_index : INTEGER;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_surface) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY b_spline_curve_knot_locator
   SUBTYPE OF(founded_item);
     basis_curve : b_spline_curve;
     knot_index  : INTEGER;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_curve) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY b_spline_curve_segment
   SUBTYPE OF(founded_item);
     basis_curve      : b_spline_curve;
     start_knot_index : INTEGER;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_curve) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY b_spline_surface_strip
   SUBTYPE OF(founded_item);
     basis_surface     : b_spline_surface;
     start_knot_index  : INTEGER;
     surface_parameter : u_or_v_parameter;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_surface) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY composite_curve_transition_locator
   SUBTYPE OF(founded_item);
     basis_curve      : composite_curve;
     transition_index : INTEGER;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_curve) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY rectangular_composite_surface_transition_locator
   SUBTYPE OF(founded_item);
     basis_surface      : rectangular_composite_surface;
     surface_parameter  : u_or_v_parameter;
     u_transition_index : INTEGER;
     v_transition_index : INTEGER;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_surface) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;

 ENTITY boundary_curve_of_b_spline_or_rectangular_composite_surface
   SUBTYPE OF(founded_item);
     basis_surface : b_spline_or_rectangular_composite_surface_select;
     boundary_type : surface_boundary_type;
   WHERE
     WR1 : SIZEOF(
           using_representations(SELF.basis_surface) *
           relating_shape_representations_of_extreme_values(SELF))>0;
 END_ENTITY;




 FUNCTION using_product_definition_of_shape_representation
 (item: shape_representation) : SET OF product_definition;
 LOCAL
   local_s_d_r: SET OF shape_definition_representation := [];
   local_p_d: SET OF product_definition := [];
   i : INTEGER;
 END_LOCAL;

 -- find shape_definition_representations 
   local_s_d_r  := QUERY(i1<* bag_to_set (USEDIN (item, 
  'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))|
  'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.'+
  'SHAPE_DEFINITION_REPRESENTATION'
  IN TYPEOF(i1)); 

 -- find product_definition_shape & product_definitions
 REPEAT i := 1 TO HIINDEX (local_s_d_r);
    IF ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION' IN 
      TYPEOF (local_s_d_r[i]\property_definition_representation.definition))
    THEN
      IF('PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION' IN TYPEOF
        (local_s_d_r[i]\property_definition_representation.definition\property_definition.definition))
      THEN
       local_p_d := local_p_d + local_s_d_r[i]\property_definition_representation.definition\property_definition.definition;
      END_IF;
    END_IF;
 END_REPEAT;
 RETURN (local_p_d);
 END_FUNCTION;

 FUNCTION relating_shape_representations_of_extreme_values
 (item:location_of_extreme_value_select)
  : SET OF shape_representation;

 LOCAL
   results   : SET OF shape_representation:=[];
   exti      : SET OF extreme_instance:=[];
   ii_ei     : SET OF 
        instance_report_item_with_extreme_instances:=[];
   sdiir        : SET OF 
        shape_data_quality_inspection_instance_report:=[];
   sdqr      : SET OF 
        shape_data_quality_inspection_result_representation:=[];
   sdisr     : SET OF 
        shape_data_quality_inspected_shape_and_result_relationship:=[];
 END_LOCAL;
 -- find extreme_instances 
 exti := exti + 
    bag_to_set( USEDIN(item,
      'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.' +
      'EXTREME_INSTANCE.'+
      'LOCATIONS_OF_EXTREME_VALUE')); 

 -- find instance_report_item_with_extreme_instances 
 REPEAT i := 1 TO HIINDEX (exti);
   ii_ei := ii_ei + 
     bag_to_set( USEDIN(exti[i],
       'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.' +
       'INSTANCE_REPORT_ITEM_WITH_EXTREME_INSTANCES.'+
       'EXTREME_INSTANCES')); 
 END_REPEAT;

 -- find shape_data_quality_inspection_instance_report
 REPEAT i := 1 TO HIINDEX (ii_ei);
   sdiir := sdiir + 
     bag_to_set( USEDIN(ii_ei[i],
       'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.' +
       'SHAPE_DATA_QUALITY_INSPECTION_INSTANCE_REPORT.'+
       'INSPECTED_INSTANCES')); 
 END_REPEAT;

 -- find shape_data_quality_inspection_result_representation
 REPEAT i := 1 TO HIINDEX (sdiir);
  sdqr := sdqr + 
    QUERY(i1<* bag_to_set( USEDIN(sdiir[i].inspection_result,
      'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS'))|
    'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.' +
    'SHAPE_DATA_QUALITY_INSPECTION_RESULT_REPRESENTATION' 
     IN TYPEOF(i1)); 
 END_REPEAT;

 -- find shape_data_quality_inspected_shape_and_result_relationship
 REPEAT i := 1 TO HIINDEX (sdqr);
   sdisr := sdisr +  bag_to_set(USEDIN(sdqr[i],
      'SHAPE_DATA_QUALITY_INSPECTION_RESULT_SCHEMA.' +
      'SHAPE_DATA_QUALITY_INSPECTED_SHAPE_AND_RESULT_RELATIONSHIP.'+
      'REP_2')); 
 END_REPEAT;

 -- find shape_representation
 REPEAT i := 1 TO HIINDEX (sdisr);
   results := results + sdisr[i].rep_1;
 END_REPEAT;

 RETURN (results);
 END_FUNCTION;



END_SCHEMA;
(*
ISO TC184/SC4/WG12 N7297 - ISO/DIS 10303-47 Shape variation tolerances - EXPRESS
*) 


SCHEMA shape_dimension_schema;

REFERENCE FROM basic_attribute_schema (
  get_id_value, 
  id_attribute,
  id_attribute_select);

REFERENCE FROM measure_schema   -- ISO 10303-41
  (measure_with_unit); 

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation,
   compound_representation_item); 

REFERENCE FROM qualified_measure_schema   -- ISO 10303-45
  (descriptive_representation_item,
   measure_representation_item,
   qualified_representation_item); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (item_identified_representation_usage_definition,
   shape_representation); 

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (shape_aspect,
   shape_aspect_relationship); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text); 

  TYPE sd_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    dimensional_size);
  END_TYPE;


TYPE angle_relator = ENUMERATION OF 
   (equal,
    large,
    small);
END_TYPE; 

TYPE dimensional_characteristic = SELECT
   (dimensional_location, 
    dimensional_size);
END_TYPE; 

TYPE sds_item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON item_identified_representation_usage_definition WITH 
   (dimensional_size);
END_TYPE; 

TYPE shape_dimension_representation_item = SELECT
   (compound_representation_item, 
    descriptive_representation_item, 
    measure_representation_item);
END_TYPE; 

ENTITY angular_location
  SUBTYPE OF (dimensional_location);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY angular_size
  SUBTYPE OF (dimensional_size);
  angle_selection : angle_relator;
END_ENTITY;

ENTITY dimensional_characteristic_representation;
  dimension : dimensional_characteristic;
  representation : shape_dimension_representation;
END_ENTITY;

ENTITY dimensional_location
  SUPERTYPE OF (ONEOF (angular_location,
                       dimensional_location_with_path))
  SUBTYPE OF (shape_aspect_relationship);
WHERE
  WR1: SELF\shape_aspect_relationship.relating_shape_aspect :<>: SELF\shape_aspect_relationship.related_shape_aspect;
  WR2: SELF\shape_aspect_relationship.relating_shape_aspect.of_shape :=: SELF\shape_aspect_relationship.related_shape_aspect.of_shape;
END_ENTITY;

ENTITY dimensional_location_with_path
  SUBTYPE OF (dimensional_location);
  path : shape_aspect;
END_ENTITY;

ENTITY dimensional_size
  SUPERTYPE OF (ONEOF (angular_size,
                       dimensional_size_with_path));
  applies_to : shape_aspect;
  name : label;
DERIVE
  id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, applies_to;    
WHERE
  WR1: applies_to.product_definitional = TRUE;
  WR2: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY dimensional_size_with_path
  SUBTYPE OF (dimensional_size);
  path : shape_aspect;
END_ENTITY;

ENTITY directed_dimensional_location
  SUBTYPE OF (dimensional_location);
END_ENTITY;

ENTITY shape_dimension_representation
  SUBTYPE OF (shape_representation);
  SELF\representation.items : SET[1:?] OF shape_dimension_representation_item;
WHERE
  WR1: SIZEOF (QUERY (temp <* items | NOT ( NOT('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (temp)) OR (('MEASURE_SCHEMA.LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (temp)) OR ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE_WITH_UNIT' IN TYPEOF (temp))) ) )) = 0;
END_ENTITY;

END_SCHEMA;  -- shape_dimension_schema
(*
ISO TC184/SC4/WG12 N7297 - ISO/DIS 10303-47 Shape variation tolerances - EXPRESS
*) 

SCHEMA shape_tolerance_schema;

  REFERENCE FROM basic_attribute_schema (
    get_id_value, 
    id_attribute,
    id_attribute_select);

REFERENCE FROM product_property_definition_schema   -- ISO 10303-41
  (product_definition_shape,
   shape_aspect,
   shape_aspect_relationship); 

REFERENCE FROM product_property_representation_schema   -- ISO 10303-41
  (item_identified_representation_usage_definition); 

REFERENCE FROM measure_schema   -- ISO 10303-41
  (derive_dimensional_exponents,
   dimensional_exponents,
   length_measure_with_unit,
   measure_with_unit,
   measure_value,
   plane_angle_measure_with_unit); 

REFERENCE FROM qualified_measure_schema   -- ISO 10303-45
  (measure_representation_item);

REFERENCE FROM representation_schema   -- ISO 10303-43
  (representation); 

REFERENCE FROM support_resource_schema   -- ISO 10303-41
  (identifier,
   label,
   text,
   type_check_function); 

REFERENCE FROM shape_aspect_definition_schema   -- ISO 10303-47
  (datum_reference,
   datum_system,
   limit_condition,
   general_datum_reference); 

REFERENCE FROM shape_dimension_schema   -- ISO 10303-47
  (dimensional_characteristic,
   dimensional_location,
   dimensional_size); 

TYPE st_id_attribute_select = SELECT BASED_ON id_attribute_select WITH (
    geometric_tolerance);
END_TYPE;

TYPE area_unit_type = EXTENSIBLE ENUMERATION OF 
   (circular,
    square,
    rectangular);
END_TYPE; 

TYPE datum_system_or_reference = SELECT
   (datum_reference, 
    datum_system);
END_TYPE; 

TYPE directed_tolerance_zone_type = ENUMERATION OF
  (perpendicular, parallel, including);
END_TYPE;

TYPE geometric_tolerance_modifier = EXTENSIBLE ENUMERATION OF 
   (maximum_material_requirement,
    least_material_requirement,
    reciprocity_requirement,
    any_cross_section,
    free_state,
    common_zone,
    minor_diameter,
    major_diameter,
    pitch_diameter,
    line_element,
    not_convex,
    statistical_tolerance,
    tangent_plane,
    each_radial_element,
    separate_requirement);
END_TYPE; 

TYPE geometric_tolerance_target = SELECT
   (dimensional_location, 
    dimensional_size, 
    product_definition_shape, 
    shape_aspect);
END_TYPE; 

TYPE oriented_tolerance_zone_type = ENUMERATION OF
  (perpendicular, parallel, angular);
END_TYPE;

TYPE shape_tolerance_select = SELECT
   (geometric_tolerance, 
    plus_minus_tolerance);
END_TYPE; 

TYPE sts_item_identified_representation_usage_definition = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON item_identified_representation_usage_definition WITH 
   (geometric_tolerance);
END_TYPE; 

TYPE tolerance_method_definition = SELECT
   (limits_and_fits, 
    tolerance_value);
END_TYPE; 

TYPE tolerance_zone_target = SELECT (
  dimensional_location,
  dimensional_size,
  geometric_tolerance,
  general_datum_reference);
END_TYPE;

ENTITY angularity_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY circular_runout_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY coaxiality_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY concentricity_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY cylindricity_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY dimension_related_tolerance_zone_element;
  related_dimension : dimensional_location;
  related_element : tolerance_zone_definition;
END_ENTITY;

ENTITY directed_tolerance_zone
  SUBTYPE OF (tolerance_zone_with_datum);
  direction : directed_tolerance_zone_type;
END_ENTITY;

ENTITY flatness_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY geometric_tolerance
  ABSTRACT SUPERTYPE OF (geometric_tolerance_with_datum_reference
                         ANDOR geometric_tolerance_with_defined_unit
                        ANDOR ONEOF (geometric_tolerance_with_modifiers,
                             modified_geometric_tolerance)
                      ANDOR unequally_disposed_geometric_tolerance
                     ANDOR ONEOF (cylindricity_tolerance,
                          flatness_tolerance,
                          line_profile_tolerance,
                          position_tolerance,
                          roundness_tolerance,
                          straightness_tolerance,
                          surface_profile_tolerance));
  name : label;
  description : OPTIONAL text;
  magnitude : OPTIONAL length_measure_with_unit;
  toleranced_shape_aspect : geometric_tolerance_target;
DERIVE
  controlling_shape : product_definition_shape := sts_get_product_definition_shape(toleranced_shape_aspect);
    id : identifier := get_id_value(SELF);
UNIQUE
  UR1: id, controlling_shape;
WHERE
  WR1: magnitude\measure_with_unit.value_component >= 0.0;
  WR2: EXISTS(controlling_shape);
  WR3: NOT ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(toleranced_shape_aspect))
       OR (toleranced_shape_aspect\shape_aspect_relationship.relating_shape_aspect.of_shape :=:
            toleranced_shape_aspect\shape_aspect_relationship.related_shape_aspect.of_shape);
  WR4: SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
END_ENTITY;

ENTITY geometric_tolerance_relationship;
  name : label;
  description : text;
  relating_geometric_tolerance : geometric_tolerance;
  related_geometric_tolerance : geometric_tolerance;
END_ENTITY;

ENTITY geometric_tolerance_with_datum_reference
  SUPERTYPE OF (ONEOF (angularity_tolerance,
                       circular_runout_tolerance,
                       coaxiality_tolerance,
                       concentricity_tolerance,
                       parallelism_tolerance,
                       perpendicularity_tolerance,
                       symmetry_tolerance,
                       total_runout_tolerance))
  SUBTYPE OF (geometric_tolerance);
  datum_system : SET[1:?] OF datum_system_or_reference;
WHERE
  WR1: (SIZEOF(QUERY(ds <* datum_system | 'SHAPE_TOLERANCE_SCHEMA.' + 'DATUM_SYSTEM' in TYPEOF(ds)))=0) OR (SIZEOF(datum_system)=1);
END_ENTITY;

ENTITY geometric_tolerance_with_defined_area_unit
  SUBTYPE OF (geometric_tolerance_with_defined_unit);
  area_type : area_unit_type;
  second_unit_size : OPTIONAL length_measure_with_unit;
WHERE
  WR1: NOT (EXISTS(second_unit_size) XOR (area_type = rectangular));
END_ENTITY;

ENTITY geometric_tolerance_with_defined_unit
  SUBTYPE OF (geometric_tolerance);
  unit_size : length_measure_with_unit;
WHERE
  WR1: ('NUMBER' IN TYPEOF (unit_size\measure_with_unit.value_component)) AND (unit_size\measure_with_unit.value_component > 0.0);
END_ENTITY;

ENTITY geometric_tolerance_with_maximum_tolerance
  SUBTYPE OF (geometric_tolerance_with_modifiers);
  maximum_upper_tolerance : length_measure_with_unit;
WHERE
  WR1: (geometric_tolerance_modifier.maximum_material_requirement IN SELF\geometric_tolerance_with_modifiers.modifiers) OR (geometric_tolerance_modifier.least_material_requirement IN SELF\geometric_tolerance_with_modifiers.modifiers);
  WR2: (maximum_upper_tolerance\measure_with_unit.unit_component = SELF\geometric_tolerance.magnitude\measure_with_unit.unit_component) AND (maximum_upper_tolerance\measure_with_unit.value_component > SELF\geometric_tolerance.magnitude\measure_with_unit.value_component);
END_ENTITY;

ENTITY geometric_tolerance_with_modifiers
  SUBTYPE OF (geometric_tolerance);
  modifiers : SET[1:?] OF geometric_tolerance_modifier;
END_ENTITY;

ENTITY limits_and_fits;
  form_variance : label;
  zone_variance : label;
  grade : label;
  source : text;
END_ENTITY;

ENTITY line_profile_tolerance
  SUBTYPE OF (geometric_tolerance);
END_ENTITY;

ENTITY modified_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  modifier : limit_condition;
END_ENTITY;

ENTITY non_uniform_zone_definition
  SUBTYPE OF (tolerance_zone_definition);
END_ENTITY;

ENTITY oriented_tolerance_zone
  SUBTYPE OF (tolerance_zone_with_datum);
  orientation : oriented_tolerance_zone_type;
  angle : OPTIONAL plane_angle_measure_with_unit;
WHERE
  WR1 : (orientation <> oriented_tolerance_zone_type.angular) XOR EXISTS(angle);
END_ENTITY;

ENTITY parallelism_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY perpendicularity_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY plus_minus_tolerance;
  range : tolerance_method_definition;
  toleranced_dimension : dimensional_characteristic;
UNIQUE
  UR1: toleranced_dimension;
END_ENTITY;

ENTITY position_tolerance
  SUBTYPE OF (geometric_tolerance);
END_ENTITY;

ENTITY projected_zone_definition
  SUBTYPE OF (tolerance_zone_definition);
  projection_end : shape_aspect;
  projected_length : length_measure_with_unit;
WHERE
  WR1: ('NUMBER' IN TYPEOF (projected_length\measure_with_unit.value_component)) AND (projected_length\measure_with_unit.value_component > 0.0);
  WR2: (derive_dimensional_exponents (projected_length\measure_with_unit.unit_component)= dimensional_exponents(1,0,0,0,0,0,0));
END_ENTITY;

ENTITY projected_zone_definition_with_offset
  SUBTYPE OF (projected_zone_definition);
  offset : length_measure_with_unit;
END_ENTITY;

ENTITY roundness_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY runout_zone_definition
  SUBTYPE OF (tolerance_zone_definition);
  orientation : runout_zone_orientation;
END_ENTITY;

ENTITY runout_zone_orientation;
  angle : plane_angle_measure_with_unit;
END_ENTITY;

ENTITY runout_zone_orientation_reference_direction
  SUBTYPE OF (runout_zone_orientation);
  orientation_defining_relationship : shape_aspect_relationship;
END_ENTITY;

ENTITY statistical_distribution_for_tolerance
  SUBTYPE OF (representation);
WHERE
  WR1: SIZEOF (QUERY (item <* SELF\representation.items | NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (item)))) = 0;
END_ENTITY;

ENTITY straightness_tolerance
  SUBTYPE OF (geometric_tolerance);
WHERE
  WR1: NOT ('SHAPE_TOLERANCE_SCHEMA.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF (SELF));
END_ENTITY;

ENTITY surface_profile_tolerance
  SUBTYPE OF (geometric_tolerance);
END_ENTITY;

ENTITY symmetry_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY tolerance_value;
  lower_bound : measure_with_unit;
  upper_bound : measure_with_unit;
DERIVE
  ubvc : REAL := upper_bound\measure_with_unit.value_component;
  lbvc : REAL := lower_bound\measure_with_unit.value_component;
WHERE
  WR1: ubvc > lbvc;
  WR2: upper_bound\measure_with_unit.unit_component = lower_bound\measure_with_unit.unit_component;
END_ENTITY;

ENTITY tolerance_with_statistical_distribution;
  associated_tolerance : shape_tolerance_select;
  tolerance_allocation : statistical_distribution_for_tolerance;
END_ENTITY;

ENTITY tolerance_zone
  SUBTYPE OF (shape_aspect);
  defining_tolerance : SET[1:?] OF tolerance_zone_target;
  form : tolerance_zone_form;
END_ENTITY;

ENTITY tolerance_zone_definition
  SUPERTYPE OF (ONEOF (projected_zone_definition,
                       non_uniform_zone_definition,
                       runout_zone_definition));
  zone : tolerance_zone;
  boundaries : SET[0:?] OF shape_aspect;
END_ENTITY;

ENTITY tolerance_zone_form;
  name : label;
END_ENTITY;

ENTITY tolerance_zone_with_datum
  SUPERTYPE OF (ONEOF (directed_tolerance_zone, oriented_tolerance_zone))
  SUBTYPE OF (tolerance_zone);
  datum_reference : datum_system;
END_ENTITY;

ENTITY total_runout_tolerance
  SUBTYPE OF (geometric_tolerance_with_datum_reference);
END_ENTITY;

ENTITY unequally_disposed_geometric_tolerance
  SUBTYPE OF (geometric_tolerance);
  displacement : length_measure_with_unit;
WHERE
  WR1: ('NUMBER' IN TYPEOF (SELF\geometric_tolerance_with_defined_unit.unit_size\measure_with_unit.value_component)) AND (SELF\geometric_tolerance_with_defined_unit.unit_size\measure_with_unit.value_component > 0.0);
END_ENTITY;

RULE subtype_exclusiveness_geometric_tolerance FOR 
(geometric_tolerance);
WHERE
  WR1: SIZEOF(QUERY (gt <* geometric_tolerance | NOT (type_check_function(gt, ['SHAPE_TOLERANCE_SCHEMA.ANGULARITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.CIRCULAR_RUNOUT_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.COAXIALITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.CONCENTRICITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.CYLINDRICITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.FLATNESS_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.LINE_PROFILE_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.PARALLELISM_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.PERPENDICULARITY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.POSITION_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.ROUNDNESS_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.STRAIGHTNESS_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.SURFACE_PROFILE_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.SYMMETRY_TOLERANCE', 'SHAPE_TOLERANCE_SCHEMA.TOTAL_RUNOUT_TOLERANCE'] , 2 ) ))) = 0;
END_RULE; 

FUNCTION sts_get_product_definition_shape
 (input : geometric_tolerance_target) : product_definition_shape; 
CASE TRUE OF ('SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_LOCATION' IN TYPEOF(input)) : 
                 RETURN(input\shape_aspect_relationship.relating_shape_aspect\shape_aspect.of_shape);
               ('SHAPE_DIMENSION_SCHEMA.DIMENSIONAL_SIZE' IN TYPEOF(input)) : 
                 RETURN(input\dimensional_size.applies_to\shape_aspect.of_shape);
               ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(input)) : 
                 RETURN(input);
               ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT' IN TYPEOF(input)) : 
                 RETURN(input\shape_aspect.of_shape);
  OTHERWISE : RETURN(?);
  END_CASE;END_FUNCTION; 

END_SCHEMA;  -- shape_tolerance_schema

(* THIS IS DOCUMENT ISO TC184/SC4/WG12 N4852, CONTAINING REVISED EXPRESS FOR *)
(* ISO 10303-108, 'PARAMETERIZATION AND CONSTRAINTS FOR EXPLICIT GEOMETRIC   *)
(* PRODUCT MODELS' TO TAKE INTO ACCOUNT TC1 FOR THAT DOCUMENT -- 2007-04-20  *)                                          
(* file modifed in accordance with proposed solution in SEDS # 1290          *)
(* 2011-10-06 corrected syntax error in neutral_sketch_representation.wr1 TT *)



SCHEMA sketch_schema;

REFERENCE FROM product_property_representation_schema -- ISO 10303-41
  (shape_representation);

REFERENCE FROM geometry_schema;                       -- ISO 10303-42

REFERENCE FROM topology_schema                        -- ISO 10303-42
  (face_surface);

REFERENCE FROM geometric_model_schema                 -- ISO 10303-42
  (solid_model,
   surface_model);

REFERENCE FROM representation_schema                  -- ISO 10303-43
  (item_in_context,
   mapped_item,
   representation,
   representation_item_relationship,
   representation_map,
   using_items,
   using_representations);

REFERENCE FROM variational_representation_schema      -- ISO 10303-108
  (auxiliary_geometric_representation_item,
   variational_representation,
   variational_representation_item);

TYPE surface_or_solid_model = SELECT
  (surface_model,
   solid_model);
END_TYPE;

TYPE planar_curve_select = SELECT
  (line,
   conic,
   trimmed_curve,
   pcurve,
   surface_curve);
WHERE
  WR1: SELF\geometric_representation_item.dim = 3;
  WR2: check_curve_planarity(SELF);
END_TYPE;

TYPE sketch_element_select = EXTENSIBLE SELECT
  (point,
   curve);
WHERE
  WR1: 'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
END_TYPE;

TYPE sketch_basis_select = SELECT
  (planar_curve_select,
   curve_bounded_surface,
   face_surface);
END_TYPE;

TYPE sketch_type_select = SELECT
  (neutral_sketch_representation,
   positioned_sketch,
   subsketch);
END_TYPE;

TYPE curves_or_area = ENUMERATION OF
  (curves, area);
END_TYPE;

ENTITY implicit_point_on_plane
  ABSTRACT SUPERTYPE OF (ONEOF
    (implicit_planar_intersection_point,
     implicit_planar_projection_point))
  SUBTYPE OF (point, auxiliary_geometric_representation_item);
  using_sketch   : positioned_sketch;
  computed_representation 
                 : cartesian_point;
DERIVE
  plane_of_point : 
    plane := get_plane_of_implicit_geometry(using_sketch);
WHERE
  WR1: (plane_of_point\elementary_surface.position.location = 
    computed_representation) XOR
    (dot_product(plane_of_point\elementary_surface.position.p[3],
    get_relative_direction_2points
    (plane_of_point\elementary_surface.position.location, 
    computed_representation)) = 0);
  WR2: SIZEOF(TYPEOF(computed_representation) * 
    ['SKETCH_SCHEMA.IMPLICIT_POINT_ON_PLANE',
     'GEOMETRY_SCHEMA.POINT_REPLICA']) = 0;
END_ENTITY;

ENTITY implicit_planar_intersection_point
  SUBTYPE OF (implicit_point_on_plane);
  external_curve : curve;
END_ENTITY;

ENTITY implicit_planar_projection_point
  SUBTYPE OF (implicit_point_on_plane);
  external_point       : point;
  projection_direction : direction;
END_ENTITY;

ENTITY implicit_planar_curve
  ABSTRACT SUPERTYPE OF (ONEOF
    (implicit_intersection_curve,
     implicit_projected_curve,
     implicit_model_intersection_curve,
     implicit_silhouette_curve))
  SUBTYPE OF (curve, auxiliary_geometric_representation_item);
  using_sketch                  : positioned_sketch;
  computed_representation       : curve;
DERIVE
  curve_plane : plane 
    := get_plane_of_implicit_geometry(using_sketch);
WHERE
  WR1: SIZEOF(TYPEOF(computed_representation) * 
    ['SKETCH_SCHEMA.IMPLICIT_PLANAR_CURVE',
     'GEOMETRY_SCHEMA.CURVE_REPLICA']) = 0;
END_ENTITY;

ENTITY implicit_intersection_curve
  SUBTYPE of (implicit_planar_curve);
  external_surface : surface;
END_ENTITY;

ENTITY implicit_projected_curve
  SUBTYPE of (implicit_planar_curve);
  external_curve       : curve;
  projection_direction : direction;
END_ENTITY;

ENTITY implicit_model_intersection_curve
  SUBTYPE of (implicit_planar_curve);
  intersected_model : surface_or_solid_model;
END_ENTITY;

ENTITY implicit_silhouette_curve
  SUBTYPE of (implicit_planar_curve);
  silhouetted_model : surface_or_solid_model;
  view_direction    : direction;
END_ENTITY;

ENTITY neutral_sketch_representation
  SUBTYPE OF (shape_representation);
  neutral_sketch_semantics  : curves_or_area; 
  SELF\representation.items : SET[1:?] OF sketch_element_select;
WHERE
  WR1: SIZEOF(QUERY(q <* items | NOT(
         ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(q)) AND
         (q\geometric_representation_item.dim = 3)))) = 0;
END_ENTITY;

ENTITY positioned_sketch
  SUBTYPE OF (geometric_representation_item);
  sketch_basis       : sketch_basis_select;
  auxiliary_elements : 
    SET[0:?] OF auxiliary_geometric_representation_item;
WHERE
  WR1: NOT (('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN 
    TYPEOF(sketch_basis)) AND NOT ('GEOMETRY_SCHEMA.PLANE' IN
    TYPEOF(sketch_basis\curve_bounded_surface.basis_surface)));
  WR2: NOT (('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF(sketch_basis)) AND
    NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(sketch_basis\face_surface.face_geometry)));
  WR3: SIZEOF(QUERY(q <* auxiliary_elements | (SIZEOF(TYPEOF(q) * 
    ['GEOMETRY_SCHEMA.POINT','GEOMETRY_SCHEMA.CURVE']) = 0))) = 0;
  WR4: SIZEOF(QUERY(q <* auxiliary_elements | 
    q\geometric_representation_item.dim <> 3)) = 0;
END_ENTITY;

ENTITY repositioned_neutral_sketch
  SUBTYPE OF (mapped_item, geometric_representation_item);
DERIVE
  map : representation_map := SELF\mapped_item.mapping_source;
WHERE
  WR1 : 'SKETCH_SCHEMA.NEUTRAL_SKETCH_REPRESENTATION'
    IN TYPEOF(map.mapped_representation);
  WR2 : 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D' IN 
    TYPEOF(map.mapping_origin);
  WR3 : 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_3D' IN 
    TYPEOF(SELF\mapped_item.mapping_target);
END_ENTITY;

ENTITY implicit_explicit_positioned_sketch_relationship
  SUBTYPE OF (representation_item_relationship);
  SELF\representation_item_relationship.relating_representation_item 
    : repositioned_neutral_sketch; 
  SELF\representation_item_relationship.related_representation_item  
    : positioned_sketch;
WHERE
  WR1: SIZEOF(QUERY(q <* using_representations(
    SELF\representation_item_relationship.related_representation_item) |
    item_in_context(
    SELF\representation_item_relationship.relating_representation_item,
    q.context_of_items))) > 0; 
END_ENTITY;

ENTITY subsketch
  SUBTYPE OF (geometric_representation_item);
  subsketch_elements : SET[1:?] OF sketch_element_select; 
  owning_sketch      : sketch_type_select;
WHERE
  WR1: (('SKETCH_SCHEMA.NEUTRAL_SKETCH_REPRESENTATION' 
    IN TYPEOF(owning_sketch)) AND (SIZEOF(QUERY(q <* 
    subsketch_elements | NOT (owning_sketch IN 
    using_representations(q)))) = 0))
    XOR
    ((SIZEOF(TYPEOF(owning_sketch) *
     ['SKETCH_SCHEMA.POSITIONED_SKETCH','SKETCH_SCHEMA.SUBSKETCH']) = 1)
    AND 
    (SIZEOF(QUERY(q <* subsketch_elements |
     NOT (owning_sketch IN using_items(q,[])))) = 0));
END_ENTITY;

ENTITY rigid_subsketch
  SUBTYPE OF (subsketch); 
END_ENTITY;

FUNCTION get_relative_direction_2points 
           (cp1, cp2 : cartesian_point) : direction;

  LOCAL
    d1, d2, d3, magnitude : REAL;
    result                : direction := ?;  
  END_LOCAL;

  -- check that input points are three-dimensional

  IF ((cp1.dim <> 3) OR (cp2.dim <> 3)) THEN 
    RETURN(result);
  ELSE

    -- construct components of vector and compute its magnitude

    BEGIN
      d1 := cp2.coordinates[1] - cp1.coordinates[1];
      d2 := cp2.coordinates[2] - cp1.coordinates[2];
      d3 := cp2.coordinates[3] - cp1.coordinates[3];
      magnitude := sqrt(d1*d1 + d2*d2 + d3*d3);
      IF (magnitude = 0) THEN 
        return(result); -- direction is indeterminate in this case
      END_IF;
      result := dummy_gri || direction([d1, d2, d3]);
    END;
  END_IF;
  RETURN(result);

END_FUNCTION;

FUNCTION check_curve_planarity (checked_curve: curve) : BOOLEAN;

  LOCAL
    crv    : curve   := checked_curve;
    i,j    : INTEGER;
    result : BOOLEAN := FALSE;
  END_LOCAL;

  -- Determine whether the curve lies on a plane, according to its type

  IF (SIZEOF(['GEOMETRY_SCHEMA.CONIC','GEOMETRY_SCHEMA.LINE'] *
    TYPEOF(crv)) > 0) 
  THEN result := TRUE;
  ELSE
    IF (('GEOMETRY_SCHEMA.TRIMMED_CURVE' IN TYPEOF(crv)) 
      AND check_curve_planarity(crv\trimmed_curve.basis_curve))
    THEN result := TRUE;
    ELSE
      IF (('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(crv)) 
        AND ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(crv\pcurve.basis_surface)))
      THEN result := TRUE;
      ELSE
        IF ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(crv)) 
        THEN
        BEGIN
          REPEAT j := 1 TO HIINDEX(crv\surface_curve.basis_surface);
            IF ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(crv\surface_curve.basis_surface[j])) 
            THEN result := TRUE;
            END_IF;
          END_REPEAT;
        END;
        END_IF;
      END_IF;
    END_IF;
  END_IF;

  RETURN(result);

END_FUNCTION;

FUNCTION get_plane_of_implicit_geometry
         (ps : positioned_sketch) : plane;

  LOCAL
    sb     : sketch_basis_select := ps.sketch_basis;
    result : plane := ?;
  END_LOCAL;

  -- determine plane of implicit geometry from the underlying entity data
  -- type of its owning instance of positioned_sketch_representation.  If
  -- the sketch basis is of type planar_curve_select then the planarity 
  -- of the curve is guaranteed by a WHERE rule on the SELECT type of that 
  -- name.

  IF ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF(sb)) THEN 
    result := sb\face_surface.face_geometry;
  ELSE
    IF ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' IN TYPEOF(sb)) THEN
      result := sb\curve_bounded_surface.basis_surface;
    ELSE 
      IF ('SKETCH_SCHEMA.PLANAR_CURVE_SELECT' IN TYPEOF(sb)) THEN
      BEGIN
 
        IF ('GEOMETRY_SCHEMA.CONIC' IN TYPEOF(sb)) 
          THEN result := dummy_gri || surface() || 
            elementary_surface(sb\conic.position) || plane();
        END_IF;

        IF ('GEOMETRY_SCHEMA.TRIMMED_CURVE' IN TYPEOF(sb)) 
          THEN 
          BEGIN
            result := get_plane_of_implicit_geometry(
            dummy_gri || positioned_sketch(sb\trimmed_curve.basis_curve,[]));
          END;
        END_IF;

        IF ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(sb))
          THEN result := sb\pcurve.basis_surface;
        END_IF;

        IF ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(sb)) THEN
        BEGIN
          IF ((SIZEOF(sb\surface_curve.basis_surface) = 1) -- case of one basis surface 
            AND ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(sb\surface_curve.basis_surface[1])))
          THEN result := sb\surface_curve.basis_surface[1];
          ELSE -- case of two basis surfaces
            IF (('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(sb\surface_curve.basis_surface[1]))
              AND ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(sb\surface_curve.basis_surface[2])))
            THEN result := ?;
              -- both basis surfaces are planes, their intersection curve 
              -- is a line, and no unique plane is defined
            ELSE -- only one of the two basis surfaces is a plane
              IF ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(sb\surface_curve.basis_surface[1]))
              THEN result := sb\surface_curve.basis_surface[1];
              ELSE result := sb\surface_curve.basis_surface[2];
              END_IF;
            END_IF;
          END_IF;
        END;
        END_IF;
      END;
      END_IF;
    END_IF;
  END_IF;

  RETURN(result);

END_FUNCTION;

END_SCHEMA; -- sketch_schema

(*
ISO TC184/SC4/WG12 N5267 - ISO/IS 10303-111 solid_shape_element_schema - EXPRESS
ISO 10303-111, 'ELEMENTS FOR THE PROCEDURAL MODELLING OF SOLID SHAPES'
UPDATED ACCORDING TO TC1  -- 2008-07-31 -- *)                          

SCHEMA solid_shape_element_schema;

REFERENCE FROM support_resource_schema                 -- ISO 10303-41
  (text);

REFERENCE FROM measure_schema                          -- ISO 10303-41
  (length_measure,
   non_negative_length_measure,
   plane_angle_measure, 
   positive_length_measure,
   positive_plane_angle_measure);

REFERENCE FROM geometry_schema                         -- ISO 10303-42
  (axis2_placement_3d,
   bounded_curve,   
   bounded_surface,
   curve_bounded_surface,
   geometric_representation_item,
   point,
   point_on_curve,
   surface);

REFERENCE FROM topology_schema                          --ISO 10303-42
  (connected_face_set,
   edge_curve,
   face_surface,
   open_shell,
   topological_representation_item,
   vertex); 

REFERENCE FROM geometric_model_schema                   --ISO 10303-42
  (boolean_result,
   csg_primitive,
   extruded_face_solid,
   primitive_2d,
   revolved_face_solid,
   solid_model,
   swept_face_solid);

REFERENCE FROM representation_schema                    --ISO 10303-43
  (representation_item,
   using_items);

REFERENCE FROM mathematical_functions_schema            --ISO 10303-50
  (positive_integer);
 
REFERENCE FROM sketch_schema                            --ISO 10303-108
  (positioned_sketch); 
 
TYPE base_solid_select = SELECT
  (solid_model,
   csg_primitive,
   boolean_result);
WHERE
   WR1: NOT('GEOMETRIC_MODEL_SCHEMA.PRIMITIVE_2D' IN TYPEOF(SELF));
END_TYPE;

TYPE blend_end_condition_select = SELECT 
  (point_on_curve,  
   edge_curve, 
   vertex);
END_TYPE;

TYPE generalized_surface_select = SELECT 
  (surface, 
   face_surface, 
   surfaced_open_shell);
END_TYPE;

TYPE trim_condition_select = SELECT 
  (length_measure,
   plane_angle_measure,   
   generalized_surface_select,
   solid_model);
END_TYPE;

TYPE blend_radius_variation_type = ENUMERATION OF 
  (linear_blend,  
   cubic_blend, 
   unspecified_blend);
END_TYPE;
 
TYPE trim_intent = ENUMERATION OF
  (blind,
   offset,
   through_all,
   unspecified,
   up_to_next);
END_TYPE;

ENTITY modified_solid
  ABSTRACT SUPERTYPE OF (ONEOF
                        (edge_blended_solid,
                         sculptured_solid,
                         shelled_solid,
                         offset_face_solid,
                         modified_solid_with_placed_configuration))
  SUBTYPE OF (solid_model);
  rationale  : text;
  base_solid : base_solid_select;
END_ENTITY;

ENTITY edge_blended_solid
  ABSTRACT SUPERTYPE OF (track_blended_solid ANDOR (ONEOF
                         (solid_with_constant_radius_edge_blend,
                          solid_with_chamfered_edges)))
  SUBTYPE OF (modified_solid);
  blended_edges : LIST [1:?] OF UNIQUE edge_curve;
END_ENTITY; 

ENTITY track_blended_solid
  ABSTRACT SUPERTYPE OF (track_blended_solid_with_end_conditions)
  SUBTYPE OF (edge_blended_solid);
WHERE
  WR1: check_continuous_edges(SELF\edge_blended_solid.blended_edges);
END_ENTITY; 

ENTITY track_blended_solid_with_end_conditions
  SUBTYPE OF (track_blended_solid);
  end_conditions : LIST [2:2] OF blend_end_condition_select;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) *
    ['SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_CONSTANT_RADIUS_EDGE_BLEND',
     'SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_VARIABLE_RADIUS_EDGE_BLEND',
     'SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_CHAMFERED_EDGES']) = 1;
  WR2: NOT (('GEOMETRY_SCHEMA.VERTEX' IN TYPEOF(end_conditions[1]))
       AND ('GEOMETRY_SCHEMA.VERTEX' IN TYPEOF(end_conditions[2])));
  WR3: NOT (('GEOMETRY_SCHEMA.VERTEX' IN TYPEOF(end_conditions[1]))
       AND (NOT ((end_conditions[1] 
            :=: SELF\edge_blended_solid.blended_edges[1].edge_start)
            XOR (end_conditions[1] 
            :=: SELF\edge_blended_solid.blended_edges[1].edge_end))));
  WR4: NOT (('GEOMETRY_SCHEMA.VERTEX' IN TYPEOF(end_conditions[2]))
       AND (NOT ((end_conditions[2] 
            :=: SELF\edge_blended_solid.blended_edges[HIINDEX(
                SELF\edge_blended_solid.blended_edges)].edge_start)
            XOR (end_conditions[2] 
            :=: SELF\edge_blended_solid.blended_edges[HIINDEX(
                SELF\edge_blended_solid.blended_edges)].edge_end))));
END_ENTITY; 

ENTITY solid_with_constant_radius_edge_blend
  SUBTYPE OF (edge_blended_solid);
  radius : positive_length_measure;
END_ENTITY;

ENTITY solid_with_variable_radius_edge_blend
  SUBTYPE OF (track_blended_solid);
  point_list         : LIST[2:?] OF point;
  radius_list        : LIST[2:?] OF positive_length_measure;
  edge_function_list : LIST[1:?] OF blend_radius_variation_type;
WHERE
  WR1: SIZEOF(point_list) = SIZEOF(radius_list); 
  WR2: SIZEOF(edge_function_list) = SIZEOF(radius_list) - 1;
  WR3: NOT((point_list[1] = point_list[HIINDEX(point_list)]) AND NOT 
         (radius_list[1] = radius_list[HIINDEX(radius_list)]));
END_ENTITY;

ENTITY solid_with_chamfered_edges
  ABSTRACT SUPERTYPE OF (ONEOF
                        (solid_with_single_offset_chamfer,
                         solid_with_double_offset_chamfer,
                         solid_with_angle_based_chamfer))
  SUBTYPE OF (edge_blended_solid);
END_ENTITY;

ENTITY solid_with_single_offset_chamfer
  SUBTYPE OF (solid_with_chamfered_edges);
  offset_distance : positive_length_measure;
END_ENTITY;

ENTITY solid_with_double_offset_chamfer
  SUBTYPE OF (solid_with_chamfered_edges);
  left_offset_distance  : positive_length_measure;  
  right_offset_distance : positive_length_measure;
END_ENTITY;

ENTITY solid_with_angle_based_chamfer
  SUBTYPE OF (solid_with_chamfered_edges);
  offset_distance             : positive_length_measure;
  left_offset                 : BOOLEAN;
  offset_angle                : positive_plane_angle_measure;
END_ENTITY;

ENTITY surfaced_open_shell
  SUBTYPE OF (open_shell);
WHERE 
  WR1: SIZEOF(QUERY(q <* SELF\connected_face_set.cfs_faces |
         NOT ('TOPOLOGY_SCHEMA.FACE_SURFACE' IN TYPEOF(q)))) = 0;
END_ENTITY;

ENTITY sculptured_solid
  SUBTYPE OF (modified_solid);
  sculpturing_element : generalized_surface_select;
  positive_side       : BOOLEAN;
END_ENTITY;

ENTITY sculptured_solid_with_selection
  SUBTYPE OF (sculptured_solid);
  retained_solid : topological_representation_item;
END_ENTITY;

ENTITY offset_face_solid
  SUBTYPE OF (modified_solid);
  offset_faces     : LIST [1:?] OF SET[1:?] OF face_surface;
  offset_distances : LIST [1:?] OF length_measure;
WHERE
  WR1: SIZEOF(offset_faces) = SIZEOF(offset_distances); 
END_ENTITY;

ENTITY shelled_solid
  SUPERTYPE OF (ONEOF
               (double_offset_shelled_solid, 
                complex_shelled_solid))
  SUBTYPE OF (modified_solid);
  deleted_face_set : SET [1:?] OF face_surface;
  thickness        : length_measure;
WHERE
  WR1: thickness <> 0;
END_ENTITY; 

ENTITY double_offset_shelled_solid
  SUBTYPE OF (shelled_solid);
  thickness2 : length_measure;
WHERE
  WR1: thickness2 <> 0;
  WR2: SELF\shelled_solid.thickness <> thickness2;
END_ENTITY; 

ENTITY complex_shelled_solid
  SUBTYPE OF (shelled_solid);
  thickened_face_list :  LIST [1:?] OF SET[1:?] OF face_surface;
  thickness_list      :  LIST [1:?] OF length_measure;
WHERE
  WR1: SIZEOF(thickened_face_list) = SIZEOF(thickness_list);
  WR2: SIZEOF(QUERY(q <* thickness_list | (q = 0))) = 0;
END_ENTITY; 

ENTITY modified_solid_with_placed_configuration
  ABSTRACT SUPERTYPE OF (ONEOF
                        (solid_with_depression, 
                         solid_with_protrusion,
                         solid_with_shape_element_pattern))
  SUBTYPE OF (modified_solid);
  placing : axis2_placement_3d;
END_ENTITY; 

ENTITY solid_with_depression
  ABSTRACT SUPERTYPE OF (solid_with_through_depression
    ANDOR ONEOF (solid_with_hole,
                 solid_with_pocket,
                 solid_with_slot,
                 solid_with_groove))
  SUBTYPE OF (modified_solid_with_placed_configuration);
  depth : positive_length_measure;
END_ENTITY;

ENTITY solid_with_through_depression
  SUBTYPE OF (solid_with_depression);
  exit_faces : SET[1:?] OF face_surface;
WHERE
  WR1: SIZEOF(TYPEOF(SELF) *
         ['SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_HOLE',
          'SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_POCKET',
          'SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_SLOT']) = 1;
END_ENTITY;

ENTITY solid_with_hole
  ABSTRACT SUPERTYPE OF (solid_with_stepped_round_hole)
  SUBTYPE OF (solid_with_depression);
END_ENTITY;

ENTITY solid_with_stepped_round_hole
SUPERTYPE OF (solid_with_stepped_round_hole_and_conical_transitions
  ANDOR ONEOF (solid_with_flat_bottom_round_hole,
               solid_with_conical_bottom_round_hole,
               solid_with_spherical_bottom_round_hole))
SUBTYPE OF (solid_with_hole);
  segments           : positive_integer;
  segment_radii      : LIST[1:segments] OF positive_length_measure;
  segment_depths     : LIST[1:segments] OF positive_length_measure;
DERIVE
  SELF\solid_with_depression.depth
                     : positive_length_measure := compute_total_depth(SELF);
WHERE
  WR1: NOT (('SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_THROUGH_DEPRESSION'
       IN TYPEOF(SELF)) AND (SIZEOF(TYPEOF(SELF) *
       ['SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE',
       'SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_SPHERICAL_BOTTOM_ROUND_HOLE',
       'SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_FLAT_BOTTOM_ROUND_HOLE']) 
       <> 0)); 
END_ENTITY;

ENTITY conical_stepped_hole_transition
  SUBTYPE OF (geometric_representation_item);
  transition_number  : positive_integer;
  cone_apex_angle    : plane_angle_measure;
  cone_base_radius   : positive_length_measure;
END_ENTITY;

ENTITY solid_with_stepped_round_hole_and_conical_transitions
  SUBTYPE OF (solid_with_stepped_round_hole);
  conical_transitions : SET[1:?] OF conical_stepped_hole_transition; 
WHERE
  WR1: SIZEOF (conical_transitions) <= 
         (SELF\solid_with_stepped_round_hole.segments + 1);
  WR2: ('SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_THROUGH_DEPRESSION'
         IN TYPEOF(SELF)) XOR (SIZEOF(conical_transitions) <= 
         SELF\solid_with_stepped_round_hole.segments);
  WR3: validate_countersink_radii(SELF);
END_ENTITY;

ENTITY solid_with_flat_bottom_round_hole
  SUBTYPE OF (solid_with_stepped_round_hole);
  fillet_radius : non_negative_length_measure;
WHERE
  WR1 : fillet_radius < 
          SELF\solid_with_stepped_round_hole.segment_radii[segments];
END_ENTITY;

ENTITY solid_with_spherical_bottom_round_hole
  SUBTYPE OF (solid_with_stepped_round_hole);
  sphere_radius : positive_length_measure;
WHERE
  WR1 : sphere_radius >= 
          SELF\solid_with_stepped_round_hole.segment_radii[segments];
END_ENTITY;

ENTITY solid_with_conical_bottom_round_hole
  SUBTYPE OF (solid_with_stepped_round_hole);
  semi_apex_angle : positive_plane_angle_measure;
  tip_radius      : non_negative_length_measure;
WHERE
  WR1 : tip_radius < 
          SELF\solid_with_stepped_round_hole.segment_radii[segments];
END_ENTITY;

ENTITY solid_with_pocket
ABSTRACT SUPERTYPE OF (ONEOF 
                      (solid_with_rectangular_pocket,
                       solid_with_circular_pocket,
                       solid_with_general_pocket))
SUBTYPE OF (solid_with_depression);
  floor_blend_radius : non_negative_length_measure;
  draft_angle        : plane_angle_measure;
END_ENTITY;

ENTITY solid_with_rectangular_pocket
  SUBTYPE OF (solid_with_pocket);
  pocket_length : positive_length_measure;
  pocket_width  : positive_length_measure;
  corner_radius : non_negative_length_measure;
WHERE
  WR1: (corner_radius < pocket_width/2) 
         AND (corner_radius < pocket_length/2);
END_ENTITY;

ENTITY solid_with_circular_pocket
  SUBTYPE OF (solid_with_pocket);
  pocket_radius: positive_length_measure; 
WHERE 
  WR1: SELF\solid_with_pocket.floor_blend_radius <= pocket_radius;
END_ENTITY;

ENTITY solid_with_general_pocket  
  SUBTYPE OF (solid_with_pocket);
  profile         : positioned_sketch;
  reference_point : point;
WHERE
  WR1: SIZEOF(['GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE',
    'TOPOLOGY_SCHEMA.FACE_SURFACE'] * TYPEOF(profile.sketch_basis)) = 1;
  WR2: profile IN using_items(reference_point,[]); 
END_ENTITY;

ENTITY solid_with_slot
  ABSTRACT SUPERTYPE OF ((ONEOF (solid_with_straight_slot,
                                 solid_with_curved_slot))
                     AND (ONEOF (solid_with_trapezoidal_section_slot,
                                 solid_with_tee_section_slot)))
  SUBTYPE OF (solid_with_depression);
  slot_width     : positive_length_measure;
  closed_ends    : LIST[2:2] OF LOGICAL;
  end_exit_faces : LIST[2:2] OF SET[0:?] OF face_surface;
WHERE
  WR1: NOT(('SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_THROUGH_DEPRESSION' IN
         TYPEOF(SELF)) AND (closed_ends = [FALSE,FALSE]));
  WR2: NOT(((closed_ends[1] = TRUE) AND (SIZEOF(end_exit_faces[1]) <> 0))
         OR ((closed_ends[2] = TRUE) AND (SIZEOF(end_exit_faces[2]) <> 0)));
END_ENTITY;

ENTITY solid_with_straight_slot
  SUBTYPE OF (solid_with_slot);
  slot_length : positive_length_measure;
END_ENTITY;

ENTITY solid_with_curved_slot
  SUBTYPE OF (solid_with_slot);
  slot_centreline : bounded_curve;
END_ENTITY;

ENTITY solid_with_trapezoidal_section_slot
SUBTYPE OF (solid_with_slot);
  draft_angle         : plane_angle_measure;
  floor_fillet_radius : non_negative_length_measure;
END_ENTITY;

ENTITY solid_with_tee_section_slot
  SUBTYPE OF (solid_with_slot);
  tee_section_width  : positive_length_measure;
  collar_depth       : positive_length_measure;
WHERE
  WR1: collar_depth < SELF\solid_with_depression.depth;
  WR2: tee_section_width > SELF\solid_with_slot.slot_width; 
END_ENTITY;

ENTITY solid_with_groove
  SUBTYPE OF (solid_with_depression);
  groove_radius       : positive_length_measure;
  groove_width        : positive_length_measure;
  draft_angle         : plane_angle_measure;
  floor_fillet_radius : non_negative_length_measure;
  external_groove     : BOOLEAN;
WHERE
  WR1: NOT ('SOLID_SHAPE_ELEMENT_SCHEMA.SOLID_WITH_THROUGH_DEPRESSION'
         IN TYPEOF(SELF));
END_ENTITY; 

ENTITY solid_with_protrusion
  ABSTRACT SUPERTYPE OF (ONEOF 
                        (solid_with_circular_protrusion,
                         solid_with_rectangular_protrusion,
                         solid_with_general_protrusion))
  SUBTYPE OF (modified_solid_with_placed_configuration);
  protrusion_height      : positive_length_measure;
  protrusion_draft_angle : plane_angle_measure;
END_ENTITY;

ENTITY solid_with_circular_protrusion
  SUBTYPE OF (solid_with_protrusion);
  protrusion_radius : positive_length_measure;
END_ENTITY;

ENTITY solid_with_rectangular_protrusion
  SUBTYPE OF (solid_with_protrusion);
  protrusion_length        : positive_length_measure;
  protrusion_width         : positive_length_measure;
  protrusion_corner_radius : non_negative_length_measure;
WHERE
  WR1: (protrusion_corner_radius <= protrusion_width/2) 
         AND (protrusion_corner_radius <= protrusion_length/2);
END_ENTITY;

ENTITY solid_with_general_protrusion
  SUBTYPE OF (solid_with_protrusion);
  profile         : positioned_sketch;
  reference_point : point;
WHERE
  WR1: SIZEOF(['GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE',
    'TOPOLOGY_SCHEMA.FACE_SURFACE'] * TYPEOF(profile.sketch_basis)) = 1;
  WR2: profile IN using_items(reference_point,[]);
END_ENTITY;

ENTITY solid_with_shape_element_pattern
  ABSTRACT SUPERTYPE OF (ONEOF
                        (solid_with_circular_pattern,
                         solid_with_rectangular_pattern))
  SUBTYPE OF (modified_solid_with_placed_configuration);
  replicated_element : modified_solid_with_placed_configuration;
END_ENTITY;

ENTITY solid_with_circular_pattern
  SUPERTYPE OF (solid_with_incomplete_circular_pattern)
  SUBTYPE OF (solid_with_shape_element_pattern);
  replicate_count  : positive_integer;
  angular_spacing  : plane_angle_measure;
  radial_alignment : BOOLEAN;
  reference_point  : point;
END_ENTITY;

ENTITY solid_with_rectangular_pattern
  SUPERTYPE OF (solid_with_incomplete_rectangular_pattern)
  SUBTYPE OF (solid_with_shape_element_pattern);
  row_count      : positive_integer;
  column_count   : positive_integer;
  row_spacing    : length_measure;
  column_spacing : length_measure; 
WHERE
   WR1: (row_count * column_count) > 1;
END_ENTITY;

ENTITY solid_with_incomplete_circular_pattern
  SUBTYPE OF (solid_with_circular_pattern);
  omitted_instances : SET[1:?] OF positive_integer;
WHERE
  WR1: SIZEOF(omitted_instances) <
         SELF\solid_with_circular_pattern.replicate_count;
  WR2: SIZEOF(QUERY(q <* omitted_instances | q > 
         SELF\solid_with_circular_pattern.replicate_count)) = 0;
END_ENTITY;

ENTITY solid_with_incomplete_rectangular_pattern
  SUBTYPE OF (solid_with_rectangular_pattern);
  omitted_instances : SET[1:?] OF LIST [2:2] OF positive_integer;
WHERE
  WR1: NOT([1,1] IN omitted_instances);
  WR2: SIZEOF(omitted_instances) <
         ((SELF\solid_with_rectangular_pattern.row_count *
           SELF\solid_with_rectangular_pattern.column_count) - 1);
  WR3: SIZEOF(QUERY(q <* omitted_instances |
         ((q[1] > SELF\solid_with_rectangular_pattern.row_count) OR
          (q[2] > SELF\solid_with_rectangular_pattern.column_count)))) = 0;
END_ENTITY;

ENTITY thickened_face_solid
  SUBTYPE OF (solid_model);
  base_element : generalized_surface_select;
  offset1      : length_measure;
  offset2      : length_measure;
WHERE
  WR1: NOT (('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(base_element)) AND
    (NOT ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(base_element))));
  WR2: offset1 <> offset2;
END_ENTITY;

ENTITY extruded_face_solid_with_trim_conditions
  SUPERTYPE OF (ONEOF
                 (extruded_face_solid_with_draft_angle, 
                  extruded_face_solid_with_multiple_draft_angles))
  SUBTYPE OF (extruded_face_solid);
  first_trim_condition  : trim_condition_select;
  second_trim_condition : trim_condition_select;
  first_trim_intent     : trim_intent;
  second_trim_intent    : trim_intent;
  first_offset          : non_negative_length_measure;
  second_offset         : non_negative_length_measure;
WHERE
  WR1: NOT(('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(first_trim_condition)) OR
         ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(second_trim_condition)));
  WR2: NOT ((('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition)) AND 
         ((first_trim_intent = trim_intent.offset) 
         OR (first_trim_intent = trim_intent.up_to_next))) OR  
         (('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition)) AND 
         ((second_trim_intent = trim_intent.offset) 
         OR (second_trim_intent = trim_intent.up_to_next))));
  WR3: NOT (((NOT ('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition))) AND 
         ((first_trim_intent = trim_intent.blind) 
         OR (first_trim_intent = trim_intent.through_all))) OR  
         ((NOT('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition))) AND 
         ((second_trim_intent = trim_intent.blind) 
         OR (second_trim_intent = trim_intent.through_all))));
  WR4: (((first_trim_intent = trim_intent.offset) 
           AND (first_offset > 0)) XOR
         ((first_trim_intent <> trim_intent.offset) 
           AND (first_offset = 0))) AND 
         (((second_trim_intent = trim_intent.offset) 
           AND (second_offset > 0)) XOR
         ((second_trim_intent <> trim_intent.offset) 
            AND (second_offset = 0)));
  WR5: NOT((('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition)) AND
            ('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition))) AND
         (first_trim_condition = second_trim_condition));
END_ENTITY;

ENTITY extruded_face_solid_with_draft_angle
  SUBTYPE OF (extruded_face_solid_with_trim_conditions);
  draft_angle : plane_angle_measure;
WHERE
  WR1: draft_angle <> 0;
END_ENTITY;

ENTITY extruded_face_solid_with_multiple_draft_angles
  SUBTYPE OF (extruded_face_solid_with_trim_conditions);
  drafted_edges : LIST[2:?] OF SET[1:?] OF edge_curve;
  draft_angles  : LIST[2:?] OF plane_angle_measure;
WHERE
  WR1: SIZEOF(drafted_edges) = SIZEOF(draft_angles);
  WR2: SIZEOF(QUERY(q <* draft_angles | q = 0)) = 0;
  WR3: SIZEOF(QUERY(q <* drafted_edges | (SIZEOF(QUERY(r <* q | NOT 
         (SELF\swept_face_solid.swept_face IN 
          using_items(r,[])))) > 0))) = 0;
END_ENTITY;

ENTITY revolved_face_solid_with_trim_conditions
  SUBTYPE OF(revolved_face_solid);
  first_trim_condition  : trim_condition_select;
  second_trim_condition : trim_condition_select;
WHERE
  WR1: NOT (('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(first_trim_condition)) 
         OR ('MEASURE_SCHEMA.LENGTH_MEASURE' 
         IN TYPEOF(second_trim_condition)));
  WR2: NOT((('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(first_trim_condition)) AND
            ('MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' 
         IN TYPEOF(second_trim_condition))) AND
         (first_trim_condition = second_trim_condition));
END_ENTITY;

ENTITY auxiliary_geometric_instance_aggregator
  SUBTYPE OF (geometric_representation_item);
  shape_element   : geometric_representation_item;
  auxiliary_items : SET[1:?] OF geometric_representation_item;
WHERE
  WR1: SIZEOF(QUERY(q <* auxiliary_items | 
                shape_element IN using_items(q,[]))) = 0;
END_ENTITY;

FUNCTION check_continuous_edges (edges : LIST OF UNIQUE edge_curve)
                                       : BOOLEAN;

  LOCAL
    i           : INTEGER;
    next_vertex : vertex;
  END_LOCAL;

  -- first check whether there is only one edge in the list: in this
  -- case there is no connectivity to be checked.

  IF (SIZEOF(edges) = 1)
  THEN RETURN(TRUE);
  END_IF;

  -- otherwise, establish the matching vertices of edges 1 and 2 in 
  -- the list, and determine the vertex of edge 2 to which edge 3, 
  -- must be connected, if there are more than two edges in the list.

  IF ((edges[2].edge_start :=: edges[1].edge_end)
    XOR (edges[2].edge_start :=: edges[1].edge_start))
  THEN next_vertex := edges[2].edge_end;
  ELSE 
    IF ((edges[2].edge_end :=: edges[1].edge_end)
      XOR (edges[2].edge_end :=: edges[1].edge_start))
    THEN next_vertex := edges[2].edge_start;
    ELSE RETURN(FALSE); -- no match between any vertices of edges 1 and 2 
    END_IF;
  END_IF;

  -- exit if there are only two edges and they are connected

  IF (SIZEOF(edges) = 2)
  THEN RETURN(TRUE);
  END_IF;

  -- otherwise, check that any remaining edges are connected in list order.

  REPEAT i := 3 TO HIINDEX(edges);
    IF (edges[i].edge_start :=: next_vertex)
    THEN next_vertex := edges[i].edge_end;
    ELSE
      IF (edges[i].edge_end :=: next_vertex)
      THEN next_vertex := edges[i].edge_start;
      ELSE RETURN(FALSE); -- no match is found.
      END_IF;
    END_IF; 
  END_REPEAT;
  RETURN(TRUE); -- all edges have now been successfully checked.

END_FUNCTION;

FUNCTION compute_total_depth (swsrh : solid_with_stepped_round_hole)
                                    : positive_length_measure;

LOCAL
i  : positive_integer;
n  : positive_integer := swsrh.segments;
td : positive_length_measure := swsrh.segment_depths[1];
END_LOCAL;

IF n = 1 
THEN RETURN(td);
ELSE
  REPEAT i := 2 TO n;
    td := td + swsrh.segment_depths[i];
  END_REPEAT;
END_IF;
RETURN(td);

END_FUNCTION;

FUNCTION validate_countersink_radii 
  (cskhole : solid_with_stepped_round_hole_and_conical_transitions) 
           : BOOLEAN;

  LOCAL
    i,j             : INTEGER;
    n               : INTEGER := 1 +
                        cskhole\solid_with_stepped_round_hole.segments;
    smaller, larger : positive_length_measure;
  END_LOCAL;

  REPEAT i := 1 TO SIZEOF(cskhole.conical_transitions);

  -- First check whether transition i applies to the entry of the hole or 
  -- the exit of a through hole - those cases only need to be checked for 
  -- the sign of the cone apex angle.

  IF (((cskhole.conical_transitions[i].transition_number = 1)
       AND (cskhole.conical_transitions[i].cone_apex_angle < 0))
    XOR ((cskhole.conical_transitions[i].transition_number = n)
         AND (cskhole.conical_transitions[i].cone_apex_angle > 0))) 
  THEN RETURN(FALSE); 
  ELSE
    IF ((cskhole.conical_transitions[i].transition_number <> 1)
      AND (cskhole.conical_transitions[i].transition_number <> n))
    THEN

  -- For all remaining transitions, check that the cone base radius 
  -- lies in the range of validity.


      BEGIN
        j := cskhole.conical_transitions[i].transition_number;
        IF cskhole\solid_with_stepped_round_hole.segment_radii[j] 
          > cskhole\solid_with_stepped_round_hole.segment_radii[j-1]
        THEN 
          BEGIN
            IF (cskhole.conical_transitions[i].cone_apex_angle > 0)
            THEN RETURN(FALSE);
            END_IF;
            larger 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j];
            smaller 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j-1];
          END;
        ELSE
          BEGIN
            IF (cskhole.conical_transitions[i].cone_apex_angle < 0)
            THEN RETURN(FALSE);
            END_IF;
            larger  
              := cskhole\solid_with_stepped_round_hole.segment_radii[j-1];
            smaller 
              := cskhole\solid_with_stepped_round_hole.segment_radii[j];
          END;
        END_IF; 
        IF ((cskhole.conical_transitions[i].cone_base_radius > larger)
          OR (cskhole.conical_transitions[i].cone_base_radius < smaller))
        THEN RETURN(FALSE);
        END_IF;
      END;
    END_IF;
  END_IF;
  END_REPEAT;
  RETURN(TRUE);

END_FUNCTION;

END_SCHEMA; -- solid_shape_element_schema
(*
2009-11-14
ISO TC184/SC4/WG12 N7295 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
*)
(*
Supersedes ISO TC184/SC4/WG12 N6753 - ISO/IS 10303-41 Fundamentals of product description and support - EXPRESS
changes to product_property_representation_schema and to measure_schema as per TC2 - WG12 N6752.
*)


SCHEMA support_resource_schema;
  TYPE identifier = STRING;
  END_TYPE;

  TYPE label = STRING;
  END_TYPE;

  TYPE text = STRING;
  END_TYPE;

  FUNCTION bag_to_set (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
    LOCAL
      the_set : SET OF GENERIC:intype := [];
    END_LOCAL;

    IF SIZEOF(the_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);
        the_set := the_set + the_bag[i];
      END_REPEAT;
    END_IF;
    RETURN (the_set);
  END_FUNCTION;

  FUNCTION type_check_function (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER):LOGICAL;
    IF ((NOT EXISTS(the_type)) OR (SIZEOF(sub_names) = 0)) THEN
      RETURN (UNKNOWN);
    ELSE
      CASE criterion OF 
        0: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) > 0);
        1: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 0);
        2: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 1);
        3: RETURN (SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
        OTHERWISE : RETURN (UNKNOWN);
      END_CASE;
    END_IF;
  END_FUNCTION;

END_SCHEMA;
(*
   ISO TC184/SC4/WG12 N7169 - ISO/CD-TS 10303-42 ed 4
*)

SCHEMA topology_schema;
   REFERENCE FROM geometry_schema;
   REFERENCE FROM representation_schema(representation_item);

 CONSTANT
    dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();        
 END_CONSTANT;

 TYPE list_of_reversible_topology_item =
                               LIST [0:?] of reversible_topology_item;
 END_TYPE;

 TYPE reversible_topology = SELECT
           (reversible_topology_item,
            list_of_reversible_topology_item,
            set_of_reversible_topology_item);
 END_TYPE;

 TYPE reversible_topology_item = SELECT
   (edge, 
    path, 
    face, 
    face_bound,
    closed_shell, 
    open_shell);
 END_TYPE;

  TYPE set_of_reversible_topology_item =
                       SET [0:?] of reversible_topology_item;
  END_TYPE;

 TYPE shell = SELECT
   (vertex_shell,
    wire_shell,
    open_shell,
    closed_shell);
 END_TYPE;

 ENTITY closed_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY connected_edge_set
   SUBTYPE OF (topological_representation_item);
   ces_edges : SET [1:?] OF edge;
 END_ENTITY;

 ENTITY connected_face_set
   SUPERTYPE OF (ONEOF (closed_shell, open_shell))
   SUBTYPE OF (topological_representation_item);
   cfs_faces : SET [1:?] OF face;
 END_ENTITY;

 ENTITY connected_face_sub_set
   SUBTYPE OF (connected_face_set);
   parent_face_set   :  connected_face_set;
 END_ENTITY;

 ENTITY edge
   SUPERTYPE OF(ONEOF(edge_curve, oriented_edge, subedge))
   SUBTYPE OF (topological_representation_item);
   edge_start : vertex;
   edge_end   : vertex;
 END_ENTITY;

 ENTITY edge_curve
   SUBTYPE OF(edge,geometric_representation_item);
   edge_geometry : curve;
   same_sense    : BOOLEAN;
 END_ENTITY;

 ENTITY edge_loop
   SUBTYPE OF (loop,path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_start) :=:
        (SELF\path.edge_list[ne].edge_end);
 END_ENTITY;

 ENTITY face
   SUPERTYPE OF(ONEOF(face_surface, subface, oriented_face))
   SUBTYPE OF (topological_representation_item);
   bounds : SET[1:?] OF face_bound;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
   WR2: SIZEOF(QUERY(temp <* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp))) <= 1;
 END_ENTITY;

 ENTITY face_bound
   SUBTYPE OF(topological_representation_item);
   bound       :  loop;
   orientation :  BOOLEAN;
 END_ENTITY;

    ENTITY face_outer_bound
    SUBTYPE OF (face_bound);
    END_ENTITY;

 ENTITY face_surface
   SUBTYPE OF(face,geometric_representation_item);
   face_geometry :  surface;
   same_sense    :  BOOLEAN;
 WHERE
   WR1: NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
 END_ENTITY;

 ENTITY loop
   SUPERTYPE OF (ONEOF(vertex_loop, edge_loop, poly_loop))
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY open_path
   SUBTYPE OF (path);
 DERIVE
   ne : INTEGER := SIZEOF(SELF\path.edge_list);
 WHERE
   WR1: (SELF\path.edge_list[1].edge_element.edge_start) :<>:
                       (SELF\path.edge_list[ne].edge_element.edge_end);
 END_ENTITY;

 ENTITY open_shell
   SUBTYPE OF (connected_face_set);
 END_ENTITY;

 ENTITY oriented_closed_shell
   SUBTYPE OF (closed_shell);
   closed_shell_element : closed_shell;
   orientation          : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF (SELF.closed_shell_element));
 END_ENTITY;

 ENTITY oriented_edge
   SUBTYPE OF (edge);
   edge_element : edge;
   orientation  : BOOLEAN;
 DERIVE
   SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
   SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
 END_ENTITY;

 ENTITY oriented_face
   SUBTYPE OF (face);
   face_element : face;
   orientation  : BOOLEAN;
 DERIVE
   SELF\face.bounds : SET[1:?] OF face_bound
          := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
 END_ENTITY;

 ENTITY oriented_open_shell
   SUBTYPE OF (open_shell);
   open_shell_element : open_shell;
   orientation        : BOOLEAN;
 DERIVE
   SELF\connected_face_set.cfs_faces : SET [1:?] OF face
                                := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' 
                IN TYPEOF (SELF.open_shell_element));
 END_ENTITY;

 ENTITY oriented_path
   SUBTYPE OF (path);
   path_element : path;
   orientation  : BOOLEAN;
 DERIVE
   SELF\path.edge_list : LIST [1:?] OF UNIQUE oriented_edge
                           := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
 WHERE
   WR1: NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
 END_ENTITY;

 ENTITY path
   SUPERTYPE OF (ONEOF(open_path, edge_loop, oriented_path))
   SUBTYPE OF (topological_representation_item);
   edge_list  : LIST [1:?] OF UNIQUE oriented_edge;
 WHERE
   WR1: path_head_to_tail(SELF);
 END_ENTITY;

 ENTITY poly_loop
   SUBTYPE OF (loop,geometric_representation_item);
   polygon : LIST [3:?] OF UNIQUE cartesian_point;
 END_ENTITY;

 ENTITY seam_edge
   SUBTYPE OF (oriented_edge);
     pcurve_reference : pcurve ; 
 WHERE
    WR1 : ( 'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element) )  AND
                ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF
                       (edge_element\edge_curve.edge_geometry)) ;
   WR2 :  pcurve_reference IN edge_element\edge_curve.edge_geometry\
                                 surface_curve.associated_geometry ;
 END_ENTITY;

 ENTITY subedge
   SUBTYPE OF (edge);
   parent_edge   :  edge;
 END_ENTITY;

 ENTITY subface
   SUBTYPE OF (face);
   parent_face   :  face;
 WHERE
   WR1: NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
              list_to_set(list_face_loops(parent_face))));
 END_ENTITY;

 ENTITY topological_representation_item
   SUPERTYPE OF (ONEOF(vertex, edge, face_bound, face, vertex_shell,
                   wire_shell, connected_edge_set, connected_face_set,
                    (loop ANDOR path)))
   SUBTYPE OF (representation_item);
 END_ENTITY;

 ENTITY vertex
   SUBTYPE OF (topological_representation_item);
 END_ENTITY;

 ENTITY vertex_point
 SUBTYPE OF(vertex,geometric_representation_item);
   vertex_geometry : point;
 END_ENTITY;

 ENTITY vertex_loop
   SUBTYPE OF (loop);
   loop_vertex : vertex;
 END_ENTITY;

 ENTITY vertex_shell
   SUBTYPE OF (topological_representation_item);
   vertex_shell_extent : vertex_loop;
 END_ENTITY;

 ENTITY wire_shell
   SUBTYPE OF (topological_representation_item);
   wire_shell_extent : SET [1:?] OF loop;
 WHERE
   WR1: NOT mixed_loop_type_set(wire_shell_extent);
 END_ENTITY;

   FUNCTION boolean_choose (b : boolean;
            choice1, choice2 : generic : item)  : generic : item;
 
     IF b THEN
       RETURN (choice1);
     ELSE
       RETURN (choice2);
     END_IF;
   END_FUNCTION;

 FUNCTION closed_shell_reversed (a_shell : closed_shell) :
                                       oriented_closed_shell;
  LOCAL
    the_reverse : oriented_closed_shell;
  END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
      the_reverse := dummy_tri ||
                    connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                    closed_shell () || oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));
   ELSE
      the_reverse := dummy_tri ||
               connected_face_set (
                 a_shell\connected_face_set.cfs_faces) ||
               closed_shell () || oriented_closed_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION conditional_reverse (p       : BOOLEAN;
                               an_item : reversible_topology)
                                       : reversible_topology;
   IF p THEN
     RETURN (an_item);
   ELSE
     RETURN (topology_reversed (an_item));
   END_IF;
 END_FUNCTION;

FUNCTION edge_curve_pcurves (an_edge  : edge_curve;
                       the_surface_curves : SET OF surface_curve)
      : SET OF pcurve;
LOCAL
  a_curve      : curve;
  result       : SET OF pcurve;
  the_geometry : LIST[1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
         IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];
         END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
            THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;

  RETURN (result);
END_FUNCTION;

 FUNCTION edge_reversed (an_edge : edge) : oriented_edge;
   LOCAL
     the_reverse : oriented_edge;
   END_LOCAL;

   IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT (an_edge\oriented_edge.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start) ||
             oriented_edge(an_edge, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_bound_reversed (a_face_bound : face_bound) : face_bound;
   LOCAL
     the_reverse : face_bound ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT (a_face_bound\face_bound.orientation))
                            || face_outer_bound() ;
   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
   END_IF;
  RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION face_reversed (a_face : face) : oriented_face;
   LOCAL
     the_reverse : oriented_face ;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
          oriented_face(a_face\oriented_face.face_element,
                           NOT (a_face\oriented_face.orientation)) ;
   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds)) ||
                               oriented_face(a_face, FALSE) ;
   END_IF;
      RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_face_loops(f: face) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
   
   REPEAT i := 1 TO SIZEOF(f.bounds);
     loops := loops +(f.bounds[i].bound);
   END_REPEAT;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_loop_edges(l: loop): LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);
       edges := edges + (l\path.edge_list[i].edge_element);
     END_REPEAT;
   END_IF;

   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_of_topology_reversed (a_list
                                  : list_of_reversible_topology_item)
                                  : list_of_reversible_topology_item;
   LOCAL
     the_reverse : list_of_reversible_topology_item;
   END_LOCAL;
    
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_list);
     the_reverse := topology_reversed (a_list [i]) + the_reverse;
   END_REPEAT;
  
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION list_shell_edges(s : shell) : LIST[0:?] OF edge;
   LOCAL
     edges : LIST[0:?] OF edge := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
     edges := edges + list_loop_edges(list_shell_loops(s)[i]);
   END_REPEAT;
   
   RETURN(edges);
 END_FUNCTION;

 FUNCTION list_shell_faces(s : shell) : LIST[0:?] OF face;
   LOCAL
     faces : LIST[0:?] OF face := [];
   END_LOCAL;
   
   IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
       faces := faces + s\connected_face_set.cfs_faces[i];
     END_REPEAT;
   END_IF;
      
   RETURN(faces);
 END_FUNCTION;

 FUNCTION list_shell_loops(s : shell) : LIST[0:?] OF loop;
   LOCAL
     loops : LIST[0:?] OF loop := [];
   END_LOCAL;
      
   IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
     loops := loops + s.vertex_shell_extent;
   END_IF;
      
   IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
     REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
       loops := loops + s.wire_shell_extent[i];
     END_REPEAT;
   END_IF;
      
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR 
      ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);
       loops := loops + list_face_loops(s.cfs_faces[i]);
     END_REPEAT;
   END_IF;
      
   RETURN(loops);
 END_FUNCTION;

 FUNCTION list_to_set(l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
   LOCAL
     s : SET OF GENERIC:T := [];
   END_LOCAL;
      
   REPEAT i := 1 TO SIZEOF(l);
     s := s + l[i];
   END_REPEAT;
   
   RETURN(s);
 END_FUNCTION;

 FUNCTION mixed_loop_type_set(l: SET[0:?] OF loop): LOGICAL;
    LOCAL
      poly_loop_type: LOGICAL;
    END_LOCAL;
    IF(SIZEOF(l) <= 1) THEN
      RETURN(FALSE);
    END_IF;
    poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
    REPEAT i := 2 TO SIZEOF(l);
      IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
          THEN
          RETURN(TRUE);
       END_IF;
    END_REPEAT;
    RETURN(FALSE);
  END_FUNCTION;

 FUNCTION open_shell_reversed ( a_shell : open_shell) :
                                         oriented_open_shell;
   LOCAL
     the_reverse : oriented_open_shell;
   END_LOCAL;
   IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     the_reverse := dummy_tri ||
                  connected_face_set (
                      a_shell\connected_face_set.cfs_faces) ||
                  open_shell () || oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                      (NOT (a_shell\oriented_open_shell.orientation)));
   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set (
                     a_shell\connected_face_set.cfs_faces) ||
                 open_shell () ||  oriented_open_shell (a_shell, FALSE);
   END_IF;
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
   LOCAL
     n : INTEGER;
     p : LOGICAL := TRUE;
   END_LOCAL;
     
     n := SIZEOF (a_path.edge_list);
     REPEAT i := 2 TO n;
       p := p AND (a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);
     END_REPEAT;
     
     RETURN (p);
 END_FUNCTION;

FUNCTION path_reversed (a_path : path) : oriented_path;
  LOCAL
    the_reverse : oriented_path ;
  END_LOCAL;
  IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed (a_path.edge_list)) ||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation)) ;
  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed (a_path.edge_list)) ||
                       oriented_path(a_path, FALSE);
  END_IF;

  RETURN (the_reverse);
END_FUNCTION;

 FUNCTION set_of_topology_reversed (a_set : set_of_reversible_topology_item)
                                          : set_of_reversible_topology_item;
   LOCAL
     the_reverse : set_of_reversible_topology_item;
   END_LOCAL;
   
   the_reverse := [];
   REPEAT i := 1 TO SIZEOF (a_set);
     the_reverse := the_reverse + topology_reversed (a_set [i]);
   END_REPEAT;
   
   RETURN (the_reverse);
 END_FUNCTION;

 FUNCTION shell_reversed (a_shell : shell) : shell;
   IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
     RETURN (open_shell_reversed (a_shell));
   ELSE
     IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (closed_shell_reversed (a_shell));
     ELSE
       RETURN (?);
     END_IF;
   END_IF;
 END_FUNCTION;

 FUNCTION topology_reversed (an_item : reversible_topology)
                                     : reversible_topology;

   IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
     RETURN (edge_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
     RETURN (path_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
     RETURN (face_bound_reversed (an_item));
   END_IF;
  
   IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
     RETURN (face_reversed (an_item));
   END_IF;

   IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
     RETURN (shell_reversed (an_item));
   END_IF;

   IF ('SET' IN TYPEOF (an_item)) THEN
     RETURN (set_of_topology_reversed (an_item));
   END_IF;

   IF ('LIST' IN TYPEOF (an_item)) THEN
     RETURN (list_of_topology_reversed (an_item));
   END_IF;

   RETURN (?);
 END_FUNCTION;


FUNCTION vertex_point_pcurves (a_vertex  : vertex_point; 
      the_degenerates : SET OF evaluated_degenerate_pcurve)
      : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result  : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
    result := result + a_point;
  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);
         IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
            result := result + the_degenerates[j];
         END_IF;
      END_REPEAT;
  END_IF;

  RETURN (result);
END_FUNCTION;

 END_SCHEMA; -- end TOPOLOGY schema
(*
ISO TC184/SC4/WG12 N4852 - ISO 10303-108 paramaterization_schema - EXPRESS
THIS IS DOCUMENT I CONTAINING REVISED EXPRESS FOR 'PARAMETERIZATION AND CONSTRAINTS FOR EXPLICIT GEOMETRIC  
PRODUCT MODELS' TO TAKE INTO ACCOUNT TC1 FOR THAT DOCUMENT -- 2008-03-17  *) 
                                         


SCHEMA variational_representation_schema;

REFERENCE FROM geometry_schema                        -- ISO 10303-42
  (geometric_representation_item);

REFERENCE FROM representation_schema                  -- ISO 10303-43
  (representation,
   representation_item,
   representation_relationship,
   using_representations);

REFERENCE FROM parameterization_schema                -- ISO 10303-108
  (bound_variational_parameter,
   fixed_instance_attribute_set,
   instance_attribute_reference,
   unbound_variational_parameter);

REFERENCE FROM explicit_constraint_schema             -- ISO 10303-108
  (explicit_constraint,
   free_form_constraint);

REFERENCE FROM explicit_geometric_constraint_schema   -- ISO 10303-108
  (explicit_geometric_constraint);

REFERENCE FROM iso13584_generic_expressions_schema    -- ISO 13584-20
  (environment,
   generic_variable);

ENTITY variational_representation_item
  ABSTRACT SUPERTYPE OF (auxiliary_geometric_representation_item)
  SUBTYPE OF (representation_item);
WHERE
  WR1: SIZEOF(QUERY(q <* using_representations(SELF) |
    NOT ('VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION'  
    IN TYPEOF(q)))) = 0;
  WR2: SIZEOF(QUERY(q <* using_representations(SELF) |
    NOT (SELF IN q.items))) = 0; 
END_ENTITY;

ENTITY auxiliary_geometric_representation_item
  SUBTYPE OF (geometric_representation_item, 
              variational_representation_item);
END_ENTITY;

ENTITY variational_representation 
  SUBTYPE OF (representation);
INVERSE
  cm_link : variational_current_representation_relationship FOR rep_1;
WHERE
  WR1: SIZEOF(QUERY(q <* SELF\representation.items | 
    'VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION_ITEM' 
    IN TYPEOF(q))) > 0;
  WR2: SIZEOF(QUERY(q <* (SELF\representation.items - 
    cm_link.rep_2.items) | invalidate_vrep_item(q))) = 0;
END_ENTITY;

ENTITY variational_current_representation_relationship
  SUBTYPE OF (representation_relationship);
  SELF\representation_relationship.rep_1 
                 : variational_representation;
  current_result : representation;
UNIQUE
  UR1: current_result;
WHERE
  WR1: QUERY(q <* SELF\representation_relationship.rep_1.items | NOT
    ('VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION_ITEM'
    IN TYPEOF(q))) = SELF\representation_relationship.rep_2.items;
  WR2: SELF\representation_relationship.rep_1.context_of_items :=:
    SELF\representation_relationship.rep_2.context_of_items;
  WR3: SIZEOF(QUERY(q <* SELF\representation_relationship.rep_2.items |
    'VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION_ITEM' 
    IN TYPEOF(q))) = 0;
  WR4: TYPEOF(SELF\representation_relationship.rep_1) -
       TYPEOF(SELF\representation_relationship.rep_2) =
       ['VARIATIONAL_REPRESENTATION_SCHEMA.VARIATIONAL_REPRESENTATION'];
  WR5: current_result :=: SELF\representation_relationship.rep_2;
END_ENTITY;

FUNCTION invalidate_vrep_item(item : representation_item) 
                                   : BOOLEAN;

  LOCAL
    reps    : SET[1:?] OF representation := using_representations(item);
    ri    : SET[1:?] OF variational_representation_item;
    iar     : instance_attribute_reference;
    i       : INTEGER;
    n       : INTEGER := HIINDEX(reps);
  END_LOCAL;

  IF ('PARAMETERIZATION_SCHEMA.BOUND_VARIATIONAL_PARAMETER' IN TYPEOF(item))
  THEN
    IF 'PARAMETERIZATION_SCHEMA.INSTANCE_ATTRIBUTE_REFERENCE' 
      IN TYPEOF(item\generic_variable.interpretation\environment.semantics)
    THEN
      BEGIN
        iar := item\generic_variable.interpretation\environment.semantics;
        IF (reps <> using_representations(iar\instance_attribute_reference.owning_instance))
        THEN
          RETURN(TRUE);
        END_IF;
      END;
    ELSE RETURN(TRUE); -- parameter not attached to an instance attribute
    END_IF;
  END_IF;

  IF ('PARAMETERIZATION_SCHEMA.UNBOUND_VARIATIONAL_PARAMETER' IN TYPEOF(item))
  THEN
    BEGIN 
      REPEAT i := 1 TO n;
        ri := QUERY(q <* reps[i]\representation.items | 
          'EXPLICIT_CONSTRAINT_SCHEMA.FREE_FORM_CONSTRAINT' IN TYPEOF(q));
        IF SIZEOF(QUERY(r <* ri | 
          item IN (r\free_form_constraint.reference_elements + r\free_form_constraint.constrained_elements))) = 0
        THEN 
          RETURN(TRUE);
        END_IF;
      END_REPEAT;
    END;
  END_IF;

  IF ('PARAMETERIZATION_SCHEMA.FIXED_INSTANCE_ATTRIBUTE_SET' 
    IN TYPEOF(item))
  THEN
    REPEAT i := 1 TO SIZEOF(item\fixed_instance_attribute_set.fixed_attributes);
--next line is previous
--      IF (reps <> using_representations(item\fixed_instance_attribute_set.fixed_attributes[i]))
--is this intent?
      IF (reps <> using_representations(item\fixed_instance_attribute_set.fixed_attributes[i]\instance_attribute_reference.owning_instance))
      THEN
        RETURN(TRUE);
      END_IF;
    END_REPEAT;
  END_IF;

  IF ('EXPLICIT_CONSTRAINT_SCHEMA.EXPLICIT_CONSTRAINT' IN TYPEOF(item))
  THEN
    IF SIZEOF(QUERY(q <* 
      (item\explicit_constraint.reference_elements + item\explicit_constraint.constrained_elements) |
      reps <> using_representations(q))) > 0
    THEN
      RETURN(TRUE);
    END_IF;
  END_IF;

  IF ('VARIATIONAL_REPRESENTATION_SCHEMA.AUXILIARY_GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(item))
  THEN
    BEGIN 
      REPEAT i := 1 TO n;
        ri := QUERY(q <* reps[i]\representation.items | 
          'EXPLICIT_GEOMETRIC_CONSTRAINT_SCHEMA.EXPLICIT_GEOMETRIC_CONSTRAINT' IN TYPEOF(q));
        IF SIZEOF(QUERY(r <* ri | 
          item IN r\explicit_geometric_constraint.reference_elements)) = 0
        THEN
          RETURN(TRUE);
        END_IF;
      END_REPEAT;
    END;
  END_IF;

  RETURN(FALSE); -- no invalid cases have been found

END_FUNCTION;

END_SCHEMA; -- variational_representation_schema
