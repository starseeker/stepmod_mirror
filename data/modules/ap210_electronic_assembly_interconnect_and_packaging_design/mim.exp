(*
   $Id: mim.exp,v 1.7 2004/12/14 16:13:11 liutkus Exp $
   ISO TC184/SC4/WG12 N - ISO/CD-TS 10303-xxxx Ap210 electronic assembly interconnect and packaging design - EXPRESS MIM
*)


SCHEMA Ap210_electronic_assembly_interconnect_and_packaging_design_mim;
	USE FROM Advanced_boundary_representation_mim;
	USE FROM Altered_package_mim;
	USE FROM Altered_part_mim;
	USE FROM Analytical_model_mim;
	USE FROM Ap210_assembly_functional_interface_requirements_mim;
	USE FROM Ap210_assembly_functional_requirements_mim;
	USE FROM Ap210_assembly_physical_design_mim;
	USE FROM Ap210_assembly_physical_interface_requirements_mim;
	USE FROM Ap210_assembly_physical_requirements_mim;
	USE FROM Ap210_assembly_requirement_allocation_mim;
	USE FROM Ap210_assembly_technology_constraints_mim;
	USE FROM Ap210_connection_zone_based_model_extraction_mim;
	USE FROM Ap210_device_functional_and_physical_characterization_mim;
	USE FROM Ap210_functional_decomposition_mim;
	USE FROM Ap210_functional_requirement_allocation_mim;
	USE FROM Ap210_functional_specification_mim;
	USE FROM Ap210_geometric_dimensioning_and_tolerancing_mim;
	USE FROM Ap210_interconnect_design_mim;
	USE FROM Ap210_interconnect_design_for_microwave_mim;
	USE FROM Ap210_interconnect_functional_requirements_mim;
	USE FROM Ap210_interconnect_physical_requirements_mim;
	USE FROM Ap210_interconnect_requirement_allocation_mim;
	USE FROM Ap210_interconnect_technology_constraints_mim;
	USE FROM Ap210_laminate_assembly_design_mim;
	USE FROM Ap210_package_functional_and_physical_characterization_mim;
	USE FROM Ap210_packaged_part_white_box_model_mim;
	USE FROM Ap210_physical_unit_physical_characterization_mim;
	USE FROM Ap210_printed_part_functional_and_physical_characterization_mim;
	USE FROM Ap210_product_rule_mim;
	USE FROM Area_2d_mim;
	USE FROM Assembly_2d_shape_mim;
	USE FROM Assembly_3d_shape_mim;
	USE FROM Assembly_component_placement_requirements_mim;
	USE FROM Assembly_functional_interface_requirement_mim;
	USE FROM Assembly_module_design_mim;
	USE FROM Assembly_module_macro_definition_mim;
	USE FROM Assembly_module_usage_view_mim;
	USE FROM Assembly_module_with_cable_component_mim;
	USE FROM Assembly_module_with_interconnect_component_mim;
	USE FROM Assembly_module_with_macro_component_mim;
	USE FROM Assembly_module_with_packaged_connector_component_mim;
	USE FROM Assembly_module_with_subassembly_mim;
	USE FROM Assembly_physical_interface_requirement_mim;
	USE FROM Assembly_physical_requirement_allocation_mim;
	USE FROM Assembly_shape_mim;
	USE FROM Assembly_technology_mim;
	USE FROM Bare_die_mim;
	USE FROM Construction_geometry_mim;
	USE FROM Basic_geometry_mim;
	USE FROM Cable_mim;
	USE FROM Characteristic_mim;
	USE FROM Chemical_substance_mim;
	USE FROM Component_feature_mim;
	USE FROM Component_grouping_mim;
	USE FROM Connectivity_allocation_to_physical_network_mim;
	USE FROM Curve_swept_solid_mim;
	USE FROM Datum_difference_based_model_mim;
	USE FROM Design_management_mim;
	USE FROM Design_specific_assignment_to_assembly_usage_view_mim;
	USE FROM Design_specific_assignment_to_interconnect_usage_view_mim;
	USE FROM Device_marking_mim;
	USE FROM Dimension_tolerance_mim;
	USE FROM Electrical_network_definition_mim;
	USE FROM Extended_geometric_tolerance_mim;
	USE FROM Fabrication_joint_mim;
	USE FROM Fabrication_requirement_mim;
	USE FROM Feature_and_connection_zone_mim;
	USE FROM Fill_area_mim;
	USE FROM Form_features_mim;
	USE FROM Functional_decomposition_to_assembly_design_mim;
	USE FROM Functional_decomposition_to_design_mim;
	USE FROM Functional_decomposition_to_interconnect_design_mim;
	USE FROM Functional_decomposition_with_nodal_representation_to_packaged_mapping_mim;
	USE FROM Functional_design_elaboration_mim;
	USE FROM Functional_specification_mim;
	USE FROM Functional_unit_requirement_allocation_mim;
	USE FROM Geometric_tolerance_mim;
	USE FROM Geometrically_bounded_surface_mim;
	USE FROM Interconnect_2d_shape_mim;
	USE FROM Interconnect_3d_shape_mim;
	USE FROM Interconnect_module_connection_routing_mim;
	USE FROM Interconnect_module_to_assembly_module_relationship_mim;
	USE FROM Interconnect_module_usage_view_mim;
	USE FROM Interconnect_module_with_macros_mim;
	USE FROM Interconnect_non_planar_shape_mim;
	USE FROM Interconnect_physical_requirement_allocation_mim;
	USE FROM Interconnect_placement_requirements_mim;
	USE FROM Interface_component_mim;
	USE FROM Land_mim;
	USE FROM Layered_3d_shape_mim;
	USE FROM Layered_interconnect_module_3d_shape_mim;
	USE FROM Layered_interconnect_module_design_mim;
	USE FROM Layered_interconnect_module_with_printed_component_design_mim;
	USE FROM Layered_shape_mim;
	USE FROM Layout_macro_definition_mim;
	USE FROM Manifold_subsurface_mim;
	USE FROM Manufacturing_technology_mim;
	USE FROM Model_parameter_mim;
	USE FROM Network_functional_design_view_mim;
	USE FROM Network_functional_usage_view_mim;
	USE FROM Non_feature_shape_element_mim;
	USE FROM Package_mim;
	USE FROM Packaged_connector_model_mim;
	USE FROM Packaged_part_black_box_model_mim;
	USE FROM Packaged_part_white_box_model_mim;
	USE FROM Part_external_reference_mim;
	USE FROM Part_feature_function_mim;
	USE FROM Part_feature_grouping_mim;
	USE FROM Part_feature_location_mim;
	USE FROM Part_template_extension_mim;
	USE FROM Part_terminal_mim;
	USE FROM Physical_component_feature_mim;
	USE FROM Physical_layout_template_mim;
	USE FROM Physical_node_requirement_to_implementing_component_allocation_mim;
	USE FROM Physical_unit_design_view_mim;
	USE FROM Physical_unit_interconnect_definition_mim;
	USE FROM Physical_unit_usage_view_mim;
	USE FROM Planned_characteristic_mim;
	USE FROM Pre_defined_datum_2d_symbol_mim;
	USE FROM Pre_defined_datum_3d_symbol_mim;
	USE FROM Pre_defined_datum_symbol_mim;
	USE FROM Printed_physical_layout_template_mim;
	USE FROM Product_identification_extension_mim;
	USE FROM Product_rule_mim;
	USE FROM Requirement_decomposition_mim;
	USE FROM Sequential_laminate_assembly_design_mim;
	USE FROM Shape_composition_mim;
	USE FROM Shape_parameters_mim;
	USE FROM Shield_mim;
	USE FROM Signal_mim;
	USE FROM Software_mim;
	USE FROM Specification_document_mim;
	USE FROM Stratum_non_planar_shape_mim;
	USE FROM Styled_curve_mim;
	USE FROM Styled_text_mim;
	USE FROM Technology_mim;
	USE FROM Test_requirement_allocation_mim;
	USE FROM Thermal_network_definition_mim;
	USE FROM Via_component_mim;
	USE FROM Wireframe_2d_mim;

	USE FROM Contract_schema;
	USE FROM Presentation_definition_schema;	
	USE FROM Presentation_resource_schema;

SUBTYPE_CONSTRAINT component_definition_subtypes FOR component_definition;         
  (ONEOF (printed_component, packaged_component, routed_physical_component)
                ANDOR (thermal_component) ANDOR (cable_component));
END_SUBTYPE_CONSTRAINT;        

SUBTYPE_CONSTRAINT component_terminal_subtypes FOR component_terminal;         
  (ONEOF(assembly_module_macro_component_join_terminal,
        interconnect_module_macro_component_join_terminal));
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT model_parameter_subtypes FOR model_parameter;         
	(ONEOF(analytical_model_parameter,
               category_model_parameter,
               rule_function_domain_parameter,
               rule_function_range_parameter));
END_SUBTYPE_CONSTRAINT;               

SUBTYPE_CONSTRAINT physical_unit_subtypes FOR physical_unit;         
 (ONEOF (bare_die, 
          package, 
          packaged_part, 
          assembly_definition, 
          interconnect_definition,
          reference_packaged_part_assembly_implementation,
          reference_packaged_part_interconnect_implementation));
END_SUBTYPE_CONSTRAINT;

SUBTYPE_CONSTRAINT shape_definition_3d_intersection_subtypes FOR shape_definition_3d_intersection;         
  (ONEOF (edge_segment_cross_section,
              pre_defined_parallel_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship,
              pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship));
END_SUBTYPE_CONSTRAINT;        

TYPE ap210_frozen_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON frozen_assigned_item WITH 
     (alternate_product_relationship,
      applied_date_and_time_assignment,
      applied_document_reference,
      applied_group_assignment,
      characterized_object,
      component_definition,
      component_shape_aspect,
      composite_curve_segment,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style,
      fill_area_style_colour,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      inter_stratum_feature,
      material_designation,
      measure_with_unit,
      plus_minus_tolerance,
      pre_defined_item,
      product_concept,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
      runout_zone_orientation,
      shape_aspect,
      shape_aspect_relationship,
      stratum_feature,
      tolerance_value,
      tolerance_zone_form);
END_TYPE;

TYPE group_assigned_item = SELECT
     (assembly_bond_definition,
      design_object,
      component_definition,
      component_feature,
      component_interface_terminal,
      component_shape_aspect,
      component_terminal,
      compound_representation_item,
      configuration_item,
      inter_stratum_feature,
      laminate_component_interface_terminal,
      printed_part_template_terminal,
      product,
      product_definition_formation,
      property_definition_representation,
      representation,
      representation_item,
      requirements_property,
      rule_definition,
      shape_aspect,
      shape_aspect_relationship,
      stratum,
      stratum_feature,
      stratum_surface);
END_TYPE;

TYPE ap210_managed_design_object = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON managed_design_object WITH 
     (action,
      alternate_product_relationship,
      applied_approval_assignment,
      applied_date_and_time_assignment,
      applied_document_reference,
      applied_group_assignment,
      approval,
      approval_status,
      certification,
      characterized_object,
      composite_curve_segment,
      configuration_effectivity,
      configuration_item,
      contract,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      date,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style,
      fill_area_style_colour,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      layer_connection_point,
      material_designation,
      measure_with_unit,
      organization,
      person,
      person_and_organization,
      plus_minus_tolerance,
      pre_defined_item,
      product,
      product_concept,
      product_definition,
      product_definition_formation,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
      runout_zone_orientation,
      security_classification,
      shape_aspect,
      shape_aspect_relationship,
      tolerance_value,
      tolerance_zone_form,
      versioned_action_request);
END_TYPE; -- managed_design_object

TYPE ap210_owner_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON owner_assigned_item WITH 
     (alternate_product_relationship,
      characterized_object,
      component_definition,
      component_shape_aspect,
      composite_curve_segment,
      curve_style,
      curve_style_font,
      curve_style_font_and_scaling,
      dimension_related_tolerance_zone_element,
      dimensional_characteristic_representation,
      dimensional_size,
      document_usage_constraint,
      externally_defined_item,
      fill_area_style,
      fill_area_style_colour,
      geometric_tolerance,
      geometric_tolerance_relationship,
      group,
      inter_stratum_feature,
      material_designation,
      measure_with_unit,
      plus_minus_tolerance,
      pre_defined_item,
      product_concept,
      product_definition_formation_relationship,
      product_definition_relationship,
      property_definition,
      property_definition_relationship,
      property_definition_representation,
      representation,
      representation_context,
      representation_item,
      representation_relationship,
      runout_zone_orientation,
      shape_aspect,
      shape_aspect_relationship,
      stratum_feature,
      tolerance_value,
      tolerance_zone_form);
END_TYPE; -- owner_assigned_item

TYPE ap210_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH 
     (product_definition_formation_with_specified_source,
      requirement_allocation_group);
END_TYPE; --ap210_approval_item

TYPE ap210_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH 
     (product_definition_formation_with_specified_source);
END_TYPE; --ap210_certification_item

TYPE ap210_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH 
     (requirements_property,
      signal,
      stratum);
END_TYPE; --ap210_classification_item

TYPE ap210_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH 
     (rule_action);
END_TYPE; --ap210_date_and_time_item

TYPE ap210_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH 
     (component_definition,
      component_feature,
      component_interface_terminal,
      component_shape_aspect,
      component_terminal,
      functional_unit_terminal_definition,
      inter_stratum_feature,
      interconnect_module_component_surface_feature,
      layer,
      laminate_component_interface_terminal,
      package_terminal,
      part_template_definition,
      physical_connectivity_definition,
      physical_connectivity_element,
      requirements_property,
      rule_definition,
      signal,
      stratum,
      stratum_feature);
END_TYPE; --ap210_document_reference_item

TYPE ap210_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH 
     (product_definition_formation_with_specified_source,
      rule_definition);
END_TYPE; --ap210_organization_item

TYPE ap210_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH 
     (rule_action);
END_TYPE; --ap210_person_and_organization_item

TYPE ap210_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH 
    (physical_connectivity_element, 
     requirements_property); 
END_TYPE; 


ENTITY material_functional_category
  SUBTYPE OF (group);
WHERE
  WR1: SELF\group.name IN 
     ['bonding agent', 'potting compound', 'marking material'];
END_ENTITY; -- material_functional_category

(** It is not used by any ARM concept and by any mapping *)
ENTITY named_unit_variable
  SUBTYPE OF (named_unit, variable_semantics); 
INVERSE
  associated_variable_environment: environment FOR semantics; 
END_ENTITY; -- named_unit_variable

RULE add_design_object_management_relationship_unique_constraint FOR
 ( add_design_object_assignment, add_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  adoa_bag : BAG OF add_design_object_assignment;
  adora_bag : BAG OF add_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(add_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(add_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
   'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(add_design_object_assignment[i].items[j]))
    AND (add_design_object_assignment[i].items[j].name = 
            'design object addition') ) THEN
      IF EXISTS( add_design_object_assignment[i].items[j].
                          related_product_definition ) 
                                                               THEN
        IF( NOT( add_design_object_assignment[i].items[j].
                           related_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                    add_design_object_assignment[i].items[j].
                             related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(add_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
        SIZEOF(add_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
           TYPEOF(add_design_object_request_assignment[i].items[j]))
AND (add_design_object_request_assignment[i].items[j].name = 
                             'design object addition') ) THEN
      IF EXISTS( 
           add_design_object_request_assignment[i].items[j].
                             related_product_definition ) 
                                                          THEN
        IF( NOT( 
           add_design_object_request_assignment[i].items[j].
                               related_product_definition 
                                           IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
             add_design_object_request_assignment[i].items[j].
                                    related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
            'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
                         (pdr\product_definition_relationship.name = 'design object addition') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adoa_bag := QUERY( adoa <* add_design_object_assignment | 
                                 (pdr_bag[j] IN adoa.items) );
    REPEAT k := 1 to SIZEOF(adoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adoa_bag[k].items) by 1;
        IF EXISTS( adoa_bag[k].items[l] ) THEN
          IF ( adoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + adoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adora_bag := QUERY( adora <* add_design_object_request_assignment | 
                                          (pdr_bag[j] IN adora.items) );
    REPEAT k := 1 to SIZEOF(adora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(adora_bag[k].items) by 1;
        IF ( adora_bag[k].items[l] IN mdo_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          mdo_bag := mdo_bag + adora_bag[k].items[l];
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- add_design_object_management_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of add_design_object_assignment and add_design_object_request_assignment
that has a common product_definition that is the related_product_definition of a
product_definition_relationship that has a name of 'design object addition' where the
product_definition_relationship is a member of the items attribute of the
add_design_object_assignment and add_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="adjacent_stratum_surface_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The adjacent_stratum_surface_definition_constraint rule 
constrains the related and relating shape_aspect of a shape_aspect_relationship
when it is used as a adjacent stratum surface definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE adjacent_stratum_surface_definition_constraint FOR 
( shape_aspect_relationship );
WHERE
   WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
           'STRATUM_SURFACE' IN TYPEOF (sar.related_shape_aspect)) AND
   (sar.related_shape_aspect\shape_aspect.description IN ['secondary surface']))))) = 0;
   WR2: SIZEOF (QUERY (sar <* shape_aspect_relationship |
               (sar\shape_aspect_relationship.name = 'adjacent stratum surface definition') AND
     (NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'STRATUM_SURFACE' IN TYPEOF (sar.relating_shape_aspect)) AND
    (sar.relating_shape_aspect\shape_aspect.description IN ['primary surface']))))) = 0;
END_RULE; -- adjacent_stratum_surface_definition_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
If shape_aspect_relationship.name = 'adjacent stratum surface definition' the 
shape_aspect_relationship.related_shape_aspect shall be a stratum_surface 
with a description of 'secondary surface'.
</formal.propositions.rul>
<formal.propositions.rul>
If shape_aspect_relationship.name = 'adjacent stratum surface definition' the 
shape_aspect_relationship.relating_shape_aspect shall be a stratum_surface 
with a description of 'primary surface'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="adjacent_stratum_surface_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The adjacent_stratum_surface_definition_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
adjacent_stratum_surface_definition, so that the ARM name shall be unique
and that the combination of ARM precedent_surface and ARM subsequent_surface
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE adjacent_stratum_surface_definition_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  assd : BAG OF shape_aspect_relationship := 
      QUERY( sar <* shape_aspect_relationship
| (sar\shape_aspect_relationship.description = 'adjacent stratum surface definition') );
  pass1 : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
  pss_bag : BAG OF stratum_surface := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass2 : BOOLEAN := TRUE;
  sss_bag : BAG OF stratum_surface;
END_LOCAL;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i]\shape_aspect_relationship.name ) THEN
    IF ( assd[i]\shape_aspect_relationship.name IN name_bag ) THEN
      pass1 := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + assd[i]\shape_aspect_relationship.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(assd) by 1;
  IF EXISTS( assd[i].relating_shape_aspect ) THEN
    IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_SURFACE' IN TYPEOF(assd[i].relating_shape_aspect) ) THEN
      IF( NOT( assd[i].relating_shape_aspect IN pss_bag ) ) THEN
        pss_bag := pss_bag + assd[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pss_bag) by 1;
  IF ( NOT pass2 ) THEN ESCAPE;
  END_IF;
  sss_bag := [];
  sar_bag := QUERY( sar <* assd | (sar.relating_shape_aspect :=: 
              pss_bag[i]) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_SURFACE' IN TYPEOF(assd[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sss_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          sss_bag := sss_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- adjacent_stratum_surface_definition_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of
'adjacent stratum surface definition' must have a unique name attribute.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of
'adjacent stratum surface definition' must have a unique combination of
relating_shape_aspect and related_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="aggregate_connectivity_requirement_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The aggregate_connectivity_requirement_unique_constraint rule constrains
product_definition_relationship population members, that fill the role
of ARM aggregate_connectivity_requirement, so that the ARM
design_definition_path attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE aggregate_connectivity_requirement_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  acr : BAG OF product_definition_relationship := 
                     QUERY( pdr <* product_definition_relationship |
                     (pdr\product_definition_relationship.name = 'aggregate connectivity requirement') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].related_product_definition ) THEN
    IF ( acr[i].id = 'design composition path' ) THEN
      IF ( acr[i].related_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + acr[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- aggregate_connectivity_requirement_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'aggregate connectivity requirement' must have a unique
related_product_definition attribute that points to a
product_definition with an id of 'design composition path'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="analytical_model_port_unique_constraint">
<RULE.DESCRIPTION>
The analytical_model_port_unique_constraint rule constrains the analytical_model_port
population members, that fill the role of ARM analytical_model_port, so that the
combination of ARM port_name and ARM accessed_analytical_model attributes shall be
unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of analytical_model_port must have a unique combination of name
attribute and analytical_model entity assigned to the analytical_model_port by a
representation_relationship with a name of 'access mechanism'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="analytical_model_vector_port_assignment_constraint">
<RULE.DESCRIPTION>
The analytical_model_vector_port_assignment_constraint rule constrains the
definition of the property_definition_representation to ensure that
there will be an ordered list of assigned_functional_unit_terminals.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of angular_dimension_with_orientation must have a
unique property_definition entity with a name of 'datum based vector orientation'
that is related to the angular_dimension_with_orientation by a
property_definition_relationship with a name of 'measurement orientation'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="angular_size_dimension_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The angular_size_dimension_constraint rule constrains the use of an angular_size when it is used as an angular size dimension.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each angular_size shall be represented by exactly zero shape_dimension_representation that contain at least one representation_item that has a name that is neither 'full angle' nor 'half angle'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each angular_size shall be represented by exactly zero shape_dimension_representation that contains a representation_item with the name of 'full angle' and a representation_item with a name of 'half angle'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each angular_size shall have a name of 'angular'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="application_context_requires_ap_definition">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The application_context_requires_ap_definition rule assures that each
instance of application_context has an application_protocol_definition with
name equal to 'electronic_assembly_interconnect_and_packaging_design'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE application_context_requires_ap_definition FOR
  (application_context, application_protocol_definition);
WHERE
  WR1: SIZEOF (QUERY (ac <* application_context |
       NOT (SIZEOF (QUERY (apd <* application_protocol_definition |
       (ac :=: apd\application_protocol_definition.application)
       AND
       (apd\application_protocol_definition.application_interpreted_model_schema_name =
         'electronic_assembly_interconnect_and_packaging_design'
       ))) = 1 ))) = 0;
END_RULE; --application_context_requires_ap_definition
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of application_context, there shall be exactly one
instance of application_protocol_definition that references the instance of
application_context as its application with a value of
'electronic_assembly_interconnect_and_packaging_design' as its application_interpreted_model_schema_name.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="approval_requires_approval_date_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approval_requires_approval_date_time rule assures that each instance of approval
has an associated date or time. 
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approval_requires_approval_date_time FOR (approval,
         approval_date_time);
WHERE
  WR1: SIZEOF(QUERY ( app <* approval |
       NOT (SIZEOF (QUERY (adt <* approval_date_time |
       app :=: adt.dated_approval)) = 1))) = 0;
END_RULE; -- approval_requires_approval_date_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, there shall be exactly one instance of
approval_date_time.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="approval_requires_approval_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approval_requires_approval_person_organization rule assures that for each
instance of approval there is an organization or person that is 
responsible for that approval.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approval_requires_approval_person_organization FOR (approval,
         approval_person_organization);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (apo <* approval_person_organization |
       app :=: apo.authorized_approval)) >= 1))) = 0;
END_RULE; -- approval_requires_approval_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, there shall be one or more instances of
approval_person_organization.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="approval_role_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approval_role_constraint rule assures that each
approval_role has a role that is 'authorizer'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approval_role_constraint FOR
  (approval_role);
WHERE
  WR1: SIZEOF (QUERY (apr <* approval_role |
       NOT (apr\approval_role.role = 'authorizer')
       )) = 0;
END_RULE; -- approval_role_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval_role, the role shall be 'authorizer'. 
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="approvals_are_assigned">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The approvals_are_assigned rule assures that each
approval is referenced by at least one approval_assignment as
assigned_approval.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE approvals_are_assigned FOR
  (approval, approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (app <* approval |
       NOT (SIZEOF (QUERY (aa <* approval_assignment |
       app :=: aa.assigned_approval )) >= 1 ))) = 0;
END_RULE; -- approvals_are_assigned
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, there shall be one or more instances of
approval_assignment.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_alternate_product_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_alternate_product_constraint rule constrains the base of
alternate_product_relationship when it is used as an assembly alternate
product.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
IF alternate_product_relationship.basis = 
'assembly alternate product' THEN alternate_product_relationship.base 
shall be a product which is the related_product_definition of an 
assembly_component_usage whose relating_product_definition {is a 
physical_unit} {has a frame_of_reference of an 
application_context_element where application_context_element.name = 
'physical design'}.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_composition_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_composition_relationship_unique_constraint rule constrains
assembly_component_usage population members, that fill the role of ARM
assembly_composition_relationship, so that the combination of ARM assembly
and ARM component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE assembly_composition_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  acr : BAG OF assembly_component_usage := 
 QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'assembly composition') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  cd_bag : BAG OF component_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(acr) by 1;
  IF EXISTS( acr[i].relating_product_definition ) THEN
    IF( (acr[i].relating_product_definition.frame_of_reference.name = 
         'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(acr[i].relating_product_definition)) ) THEN
      IF ( NOT ( acr[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + acr[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cd_bag := [];
  acu_bag := QUERY( acu <* acr | (acu.relating_product_definition :=: 
                               pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].related_product_definition ) THEN
      IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN 
             TYPEOF(acu_bag[j].related_product_definition) ) THEN
        IF ( acu_bag[j].related_product_definition IN cd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          cd_bag := cd_bag + acu_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- assembly_composition_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of assembly_component_usage with a name of
'assembly composition' must have a unique combination of
related_product_definition and relating_product_definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_requirement_allocation_constraint rule constrains the related and 
relating shape_aspect or product_definition when the shape_aspect_relationship 
or the product_definition_relationship is being used as an assembly requirement.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'assembly requirement allocation'
the related_shape_aspect must be a
(component_terminal)
(component_interface_terminal)
(component_shape_aspect whose description is ('component feature')
   ('component termination passage interface terminal')
   ('land interface terminal')
   ('non functional land interface terminal')
   ('printed connector component interface terminal'))
or it shall be an assembly_joint.
</Informal.propositions.rul>

<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'assembly requirement allocation'
the relating_shape_aspect shall have a {of_shape with a property_definition
with a definition that is a product_definition with a frame_of_reference
that is a application_context_element with a name of 'assembly requirement'}
and a definition for a property_definition that is a requirements_property.
</Informal.propositions.rul> 

<Informal.propositions.rul>
IF product_definition_relationship.name = 'assembly requirement allocation'
the related_product_definition shall be a component_definition.
</Informal.propositions.rul>  

<Informal.propositions.rul>
IF product_definition_relationship.name = 'assembly requirement allocation' 
the relating_product_definition shall have a {frame_of_reference with a 
that is a application_context_element with a name of 'assembly requirement'}
and a definition for a property_definition that is a requirements_property.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="assembly_separation_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The assembly_separation_requirement_allocation_constraint rule constrains the
related_shape_aspect of a shape_aspect_relationship when it is being used as
an assembly separation requirement.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'assembly separation requirement'
the related_shape_aspect shall be a
(component_terminal) 
(component_interface_terminal) 
(component_shape_aspect whose description is 
   ('component feature') 
   ('component termination passage interface terminal') 
   ('land interface terminal') 
   ('non functional land interface terminal') 
   ('printed connector component interface terminal')) or the related_shape_aspect
shall be an assembly_joint.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="bare_die_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The bare_die_unique_constraint rule constrains the bare_die,
externally_defined_bare_die and library_defined_bare_die population members, that
fill the role of ARM bare_die, so the combination of ARM implemented_function and
ARM used_package shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE bare_die_unique_constraint FOR
 ( bare_die); --, externally_defined_bare_die, library_defined_bare_die );
LOCAL
  bd : BAG OF physical_unit := QUERY( r <* bare_die |
(r.frame_of_reference.name = 'physical design usage') );
(**  edbd : BAG OF physical_unit := QUERY( r <* externally_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') );
  ldbd : BAG OF physical_unit := QUERY( r <* library_defined_bare_die |
(r.frame_of_reference.name = 'physical design usage') ); *)
  pu : BAG OF physical_unit;
  pdr_bag : BAG OF product_definition_relationship;
  fu_bag : BAG OF functional_unit := [];
  pu_bag : BAG OF physical_unit;
  ut_bag : BAG OF property_definition;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition;
END_LOCAL;

pu := bd + edbd + ldbd;
REPEAT i := 1 to SIZEOF(pu) by 1;
  pdr_bag := QUERY( pdr <* USEDIN( pu[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) |
( (pdr\product_definition_relationship.name = 'implemented function') AND
(pdr.relating_product_definition.frame_of_reference.name = 
         'functional design usage')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) ) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].relating_product_definition ) THEN
      IF( NOT( pdr_bag[j].relating_product_definition IN fu_bag ) ) THEN
        fu_bag := fu_bag + pdr_bag[j].relating_product_definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pu_bag := QUERY( r <* pu | (SIZEOF(QUERY(pdr <* USEDIN( fu_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION' ) |
((pdr\product_definition_relationship.name = 'implemented function')AND
        (pdr.related_product_definition :=: r)) ))>0) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(pu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ut_bag := QUERY( pd <* USEDIN( pu_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION' ) | (pd\property_definition.name = 'unit technology') );
    REPEAT k := 1 to SIZEOF(ut_bag) by 1;
      IF EXISTS( ut_bag[k] ) THEN
        IF ( ut_bag[k] IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + ut_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- bare_die_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of bare_die, externally_defined_bare_die and library_defined_bare_die
must have a unique combination of functional_unit entity related by an
'implemented function' product_definition_relationship and a property_definition entity
with a name of 'unit technology' whose definition attribute points to the bare_die,
externally_defined_bare_die and library_defined_bare_die.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="bevel_edge_feature_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The bevel_edge_feature_shape_constraint rule requires maximum
and minimum bevel width and bevel angles to be assigned to a 
shape_representation when it is being used as a bevel edge feature shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
For each shape_representation\ representation.name = 
'bevel edge feature shape' there shall be exactly one representation_item 
that is a length_measure_with_unit where representation_item.name = 
'maximum bevel width' assigned to representation.items.
</Informal.propositions.rul>
<Informal.propositions.rul>
For each shape_representation\ representation.name = 'bevel edge feature shape'
there shall be exactly one representation_item which is a 
length_measure_with_unit where representation_item.name = 'minimum bevel width'
assigned to representation.items.
</Informal.propositions.rul> 
<Informal.propositions.rul>
For each shape_representation\ representation.name = 'bevel edge feature shape'
there shall be exactly one representation_item which is a 
plane_angle_measure_with_unit where representation_item.name = 
'maximum bevel angle' assigned to representation.items.
</Informal.propositions.rul>  
<Informal.propositions.rul>
For each shape_representation\ representation.name = 'bevel edge feature shape'
there shall be exactly one representation_item which is a 
plane_angle_measure_with_unit where representation_item.name = 
'minimum bevel angle' assigned to representation.items.
</Informal.propositions.rul>
<Informal.propositions.rul>
This representation shall only be a representation of the shape of
an edge segment of the interconnect product.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="boundary_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The boundary_size_characteristic_constraint rule constrains the use of a representation when it is used as a boundary size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE boundary_size_characteristic_constraint FOR
  (representation);
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'diametrical boundary size')
        OR (rep\representation.name = 'opposing boundary set size'))
       AND (NOT(SIZEOF(QUERY(lmwu <* rep.items |
       (lmwu\representation_item.name = 'tolerance value'))) = 1)))) = 0;
END_RULE; -- boundary_size_characteristic_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each representation with a name of either 'diametrical boundary size' or 'opposing boundary set size' shall contain exactly one length_measure_with_unit that has a name of 'tolerance value'.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name of either 'diametrical boundary size' or 'opposing boundary set size' shall contain exactly one length_measure_with_unit that has a name of 'tolerance value', and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the physical_unit_geometric_tolerance that is specified as the defining_tolerance by the tolerance_zone that is specified as the zone by the tolerance_zone_definition that specifies the tolerance_zone_boundary as its boundaries and the property_definition of which has a description of 'boundary zone definition with specified size' and is represented by the instance of representation with a name of either 'diametrical boundary size' or 'opposing boundary set size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="boundary_zone_definition_with_specified_size_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The boundary_zone_definition_with_specified_size_constraint rule constrains the use of a property_definition when it is used as a boundary zone definition with specified size.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' shall be a property_definition of a tolerance_zone_boundary.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' shall have exactly one representation with a name of either 'diametrical boundary size' or 'opposing boundary set size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="bus_structural_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The bus_strucutral_definition_unique_constraint rule constrains the product.name population members to satisfy the uniqueness requirement of the ARM application object Bus_structural_definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)

RULE bus_structural_definition_unique_constraint FOR 
(bus_structural_definition, product_definition_formation, product);

LOCAL
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(bus_structural_definition) by 1;
  IF EXISTS( bus_structural_definition[i].formation.of_product.name ) THEN
    IF (bus_structural_definition[i].formation.of_product.name IN 
                                                       name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + 
bus_structural_definition[i]\product_definition.formation.of_product.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1: pass;

END_RULE; -- bus_structural_definition_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The product.name shall be unique within a population of bus_structural_definition.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="cartesian_coordinate_system_constraint">
<RULE.DESCRIPTION>
The cartesian_coordinate_system_constraint rule requires the units of
a global_unit_assigned_context to at least include a length_unit and a
plane_angle_unit when the global_unit_assigned_context is also a geometric_representation_context
and is a global_uncertainty_assigned_context.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE cartesian_coordinate_system_constraint FOR 
    (global_unit_assigned_context,
     geometric_representation_context,
     global_uncertainty_assigned_context);
LOCAL
  guac_inst : SET OF global_unit_assigned_context := 
              QUERY ( guac <* global_unit_assigned_context |
            ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF (guac)) AND
            ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'GLOBAL_UNCERTAINTY_ASSIGNED_CONTEXT' IN TYPEOF (guac)));
END_LOCAL;
WHERE
  WR1: SIZEOF (QUERY (guac <* guac_inst |
       NOT (SIZEOF (guac.units) <= 3))) = 0;
  WR2: SIZEOF (QUERY (guac <* guac_inst | (NOT (
       (SIZEOF (QUERY (u <* guac.units |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.LENGTH_UNIT'
       IN TYPEOF (u)))) = 1) 
       AND 
       (SIZEOF (QUERY (u <* guac.units |
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PLANE_ANGLE_UNIT'
       IN TYPEOF (u)))) = 1) 
       AND
       (SIZEOF (QUERY (u <* guac.units |
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SOLID_ANGLE_UNIT'
       IN TYPEOF (u)) )) <= 1)
       )))) = 0;
  WR3: SIZEOF( QUERY( grc <* guac_inst |
       NOT( (grc.coordinate_space_dimension = 2) OR
       (grc.coordinate_space_dimension = 3)))) = 0;
  WR4: SIZEOF (QUERY (guac <* guac_inst |
       NOT ((SIZEOF (QUERY (u <* guac.uncertainty |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (u))) = 1)))) = 0;
  WR5: SIZEOF (QUERY (guac <* guac_inst | 
       NOT (SIZEOF (QUERY (u <* guac.units |NOT(
   NOT((
    'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'PLANE_ANGLE_UNIT' IN TYPEOF(u)) AND
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'CONVERSION_BASED_UNIT' IN TYPEOF(u)) AND
    (u\conversion_based_unit.name = 'degree'))
  OR
      ((abs(u\conversion_based_unit.
          conversion_factor\measure_with_unit.value_component - 
              0.0174532925) <= 0.001) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'PLANE_ANGLE_MEASURE_WITH_UNIT' 
       IN TYPEOF(u\conversion_based_unit.conversion_factor)))
  ))) = 0)
  )) = 0;
END_RULE; -- cartesian_coordinate_system_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of global_unit_assigned_context implementing the arm Cartesian_coordinate_system, the set of units 
shall contain a maximum of 3 elements.
</formal.propositions.rul>
<formal.propositions.rul>
For each instance of global_unit_assigned_context implementing the arm Cartesian_coordinate_system, exactly one element of
the set of units shall be a length_unit, exactly one element of the set of
units shall be a plane_angle_unit where the unit is either radian or degree, 
and no more than one element of the set of units shall be a solid_angle_unit.
</formal.propositions.rul>
<formal.propositions.rul>
Each geometric_representation_context implementing the arm Cartesian_coordinate_system, the coordinate_space_dimension shall
have a value of 2 or 3.
</formal.propositions.rul>
<formal.propositions.rul>
For each global_uncertainty_assigned_context implementing the arm Cartesian_coordinate_system, exactly one element 
of the set of uncertainty shall be a length_measure_with_unit.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="cartesian_transformation_operator_2d_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The cartesian_transformation_operator_2d_constraint rule requires the units of
a global_unit_assigned_context to at least include a length_unit and a
plane_angle_unit and a scale greater than zero.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE cartesian_transformation_operator_2d_constraint FOR 
                  (cartesian_transformation_operator_2d);
WHERE
  WR1: SIZEOF(QUERY ( cto2 <* cartesian_transformation_operator_2d |  NOT(
       EXISTS(cto2.axis1) AND EXISTS(cto2.axis2)
       AND (cto2.scale > 0.0 )))) = 0;
END_RULE; -- cartesian_transformation_operator_2d_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Axis1 and axis2 shall exist and the scale value shall be greater than 0.0.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="centre_of_symmetry_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The centre_of_symmetry_constraint rule constrains the use of a centre_of_symmetry when it is used as a centre of symmetry.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each centre_of_symmetry shall have description of either 'axis', 'plane', or 'point'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="certification_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The certification_requires_date_or_date_and_time rule assures that
each certification has an associated applied_date_assignment or
an applied_date_and_time_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE certification_requires_date_or_date_and_time FOR
  (certification, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (cert <* certification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       cert IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       cert IN ada.items )) = 1 )))) = 0;
END_RULE; -- certification_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of certification, exactly one instance of
applied_date_and_time_assignment or exactly one instance of
applied_date_assignment shall contain the instance of certification in its
set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="certification_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The certification_unique_constraint rule constrains the certification.name population members to satisfy the uniqueness requirement of the ARM application object Certification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)

RULE certification_unique_constraint FOR (certification);

LOCAL
  r :  BAG OF certification := QUERY (r <* certification | TRUE);
  pass :  BOOLEAN := TRUE;
  name_bag :  BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\certification.name ) THEN
    IF (r[i]\certification.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\certification.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1:  pass;

END_RULE; -- certification_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of certification.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="change_design_object_management_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The change_design_object_management_relationship_unique_constraint rule constrains
the change_from_design_object_assignment, change_from_design_object_request_assignment,
change_to_design_object_assignment and change_to_design_object_request_assignment population
members, that fill the role of ARM change_design_object_management_relationship, so
that the combination of ARM current_design and ARM current_design_object attributes
shall be unique within the population and that the combination of ARM previous_design
and ARM previous_design_object attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE change_design_object_management_relationship_unique_constraint FOR
 (  change_from_design_object_assignment, 
 change_from_design_object_request_assignment,
change_to_design_object_assignment, 
change_to_design_object_request_assignment );
LOCAL
  pd_bag : BAG OF product_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  ctdoa_bag : BAG OF change_to_design_object_assignment;
  ctdora_bag : BAG OF change_to_design_object_request_assignment;
  cfdoa_bag : BAG OF change_from_design_object_assignment;
  cfdora_bag : BAG OF change_from_design_object_request_assignment;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(change_from_design_object_assignment) by 1;
  REPEAT j := 1 TO 
          SIZEOF(change_from_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
     TYPEOF(change_from_design_object_assignment[i].items[j]))
AND (change_from_design_object_assignment[i].items[j].name = 
                                   'design object change') ) THEN
      IF EXISTS
( change_from_design_object_assignment[i].items[j].
 relating_product_definition ) 
                                                             THEN
        IF( NOT
          ( change_from_design_object_assignment[i].items[j].
                               relating_product_definition 
                                               IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
            change_from_design_object_assignment[i].items[j].
                               relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to 
         SIZEOF(change_from_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
       SIZEOF(change_from_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
      TYPEOF(change_from_design_object_request_assignment[i].items[j]))
AND (change_from_design_object_request_assignment[i].items[j].name = 
                      'design object change') ) THEN
      IF EXISTS
  ( change_from_design_object_request_assignment[i].items[j].
                                    relating_product_definition )
                                                THEN
        IF( NOT
  ( change_from_design_object_request_assignment[i].items[j].
                                       relating_product_definition 
                                          IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
    change_from_design_object_request_assignment[i].items[j].
                                      relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT (pass1 AND pass2) ) THEN ESCAPE;
  END_IF;
  IF ( pass1 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
        (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdoa_bag := QUERY( ctdoa <* change_to_design_object_assignment | 
                (pdr_bag[j] IN ctdoa.items) );
      REPEAT k := 1 to SIZEOF(ctdoa_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdoa_bag[k].items) by 1;
          IF EXISTS( ctdoa_bag[k].items[l] ) THEN
            IF ( ctdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass1 ) THEN ESCAPE;
      END_IF;
      ctdora_bag := 
         QUERY( ctdora <* change_to_design_object_request_assignment | 
                    (pdr_bag[j] IN ctdora.items) );
      REPEAT k := 1 to SIZEOF(ctdora_bag) by 1;
        IF ( NOT pass1 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(ctdora_bag[k].items) by 1;
          IF EXISTS( ctdora_bag[k].items[l] ) THEN
            IF ( ctdora_bag[k].items[l] IN mdo_bag ) THEN
              pass1 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + ctdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
  IF ( pass2 ) THEN
    mdo_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
   (pdr\product_definition_relationship.name = 'design object change') );
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdoa_bag := QUERY( cfdoa <* change_from_design_object_assignment | 
                                           (pdr_bag[j] IN cfdoa.items) );
      REPEAT k := 1 to SIZEOF(cfdoa_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdoa_bag[k].items) by 1;
          IF EXISTS( cfdoa_bag[k].items[l] ) THEN
            IF ( cfdoa_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdoa_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
    REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass2 ) THEN ESCAPE;
      END_IF;
      cfdora_bag := 
        QUERY( cfdora <* change_from_design_object_request_assignment | 
                                        (pdr_bag[j] IN cfdora.items) );
      REPEAT k := 1 to SIZEOF(cfdora_bag) by 1;
        IF ( NOT pass2 ) THEN ESCAPE;
        END_IF;
        REPEAT l := 1 to SIZEOF(cfdora_bag[k].items) by 1;
          IF EXISTS( cfdora_bag[k].items[l] ) THEN
            IF ( cfdora_bag[k].items[l] IN mdo_bag ) THEN
              pass2 := FALSE;
              ESCAPE;
            ELSE
              mdo_bag := mdo_bag + cfdora_bag[k].items[l];
            END_IF;
          END_IF;
        END_REPEAT;
      END_REPEAT;
    END_REPEAT;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- change_design_object_management_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of change_to_design_object_assignment and change_to_design_object_request_assignment
that has a common product_definition that is the related_product_definition of a
product_definition_relationship that has a name of 'design object change' where the
product_definition_relationship is a member of the items attribute of the
change_to_design_object_assignment and change_to_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of change_from_design_object_assignment and change_from_design_object_request_assignment
that has a common product_definition that is the relating_product_definition of a
product_definition_relationship that has a name of 'design object change' where the
product_definition_relationship is a member of the items attribute of the
change_from_design_object_assignment and change_from_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="change_request_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The change_request_unique_constraint rule constrains the versioned_action_request
population members, that fill the role of ARM change_request, so that the
combination of ARM version and ARM work_request_id attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE change_request_unique_constraint FOR
 ( versioned_action_request );
LOCAL
  cr : BAG OF versioned_action_request := 
          QUERY( v <* versioned_action_request
               | (SIZEOF(QUERY(ara <* 
USEDIN(v,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')|(
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CHANGE_REQUEST' IN TYPEOF(ara)) ))>0) );
  version_bag : BAG OF STRING := [];
  var_bag : BAG OF versioned_action_request;
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(versioned_action_request) by 1;
  IF EXISTS( versioned_action_request[i].version ) THEN
    IF( NOT( versioned_action_request[i].version IN version_bag ) ) THEN
      version_bag := version_bag + versioned_action_request[i].version;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(version_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  var_bag := QUERY( v <* versioned_action_request | 
                       (v\versioned_action_request.version = version_bag[i]) );
  id_bag := [];
  REPEAT j := 1 to SIZEOF(var_bag) by 1;
    IF EXISTS( var_bag[j].id ) THEN
      IF ( var_bag[j].id IN id_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        id_bag := id_bag + var_bag[j].id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- change_request_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of versioned_action_request that is the assigned_action_request
of a change_request entity must have a unique combination of version and id
attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The characteristic_constraint rule constrains the use of a
representation_item or a measure_representation_item when it is used as a characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
No more than one instance of characterized_product_category shall relate a specific product_category.name to a specific document through applied_document_reference.
<note>
The same label may be used for different characterized_product_category when different documents are referenced.  This is the mechanism that permits category names to be isolated in the different contexts established by different dictionaries.
</note>
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_external_reference_constraint rule constrains the use of a representation when it is used as a component external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'design owner'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'part number'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'revision code'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'product definition id'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'component external reference'
shall contain a descriptive_representation_item with a name of 'reference designation'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_external_reference_constraint rule constrains the use of a
descriptive_representation_item when it is used as a component feature external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<INFORMAL.PROPOSITIONS.RUL>
Each descriptive_representation_item with a name of 'component feature external reference'
shall be a member of items for a representation with a name of `component external reference'.
</INFORMAL.PROPOSITIONS.RUL>
<INFORMAL.PROPOSITIONS.RUL>
For each descriptive_representation_item with a name of 'component feature external reference'
the combination of the its description and the representation with a name of 
`component external reference' of which it is a member of items shall be unique.
</INFORMAL.PROPOSITIONS.RUL>
</INFORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_external_reference_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_external_reference_unique_constraint rule constrains the
property_definition_representation population members, that fill the role of ARM
component_feature_external_reference, so that the combination of ARM name
and ARM associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of descriptive_representation_item with a name of
'component feature external reference' must have a unique combination of
description attributes and representation entities where the representations
have the descriptive_representation_items in their items attribute and the
representations have a name of 'component external reference'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_to_layout_feature_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_to_layout_feature_relationship_constraint rule 
constrains the related and relating shape_aspect of a 
shape_aspect_relationship that is used as a component feature to layout feature.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_feature_to_layout_feature_relationship_constraint FOR 
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_TERMINAL']
       * TYPEOF(sar.relating_shape_aspect)) > 0)
       )) = 0;
  WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'component feature to layout feature')
       AND NOT(SIZEOF(
       ['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM_FEATURE']
       * TYPEOF(sar.related_shape_aspect)) > 0)
       )) = 0;
END_RULE; -- component_feature_to_layout_feature_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'component feature to layout feature'
the shape_aspect_relationship.relating_shape_aspect is a
(component_shape_aspect) 
(component_interface_terminal) 
(component_terminal).
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'component feature to layout feature'
the shape_aspect_relationship.related_shape_aspect is a 
(component_shape_aspect) 
(stratum_feature).
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="component_feature_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_feature_unique_constraint rule constrains the component_terminal
and component_interface_terminal population members, that fill the role of
ARM component_feature, so that the combination of ARM definition and ARM
associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_feature_unique_constraint FOR
 ( component_terminal, component_interface_terminal );
LOCAL
  ct : BAG OF shape_aspect := 
     QUERY( ct <* component_terminal | (ct\shape_aspect.description IN 
['assembly module component terminal',
'bare die component terminal',
'interconnect component join terminal',
'interconnect module component terminal',
'interconnect module component stratum based terminal',
'minimally defined component terminal',
'packaged component join terminal']) );
  cit : BAG OF shape_aspect := 
         QUERY( cit <* component_interface_terminal | (
cit\shape_aspect.description IN ['interconnect component interface terminal',
'packaged connector component interface terminal']) );
  cf : BAG OF shape_aspect;
  cd_bag : BAG OF component_definition := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  def_bag : BAG OF shape_aspect;
END_LOCAL;

cf := ct + cit;
REPEAT i := 1 to SIZEOF(cf) by 1;
  IF EXISTS( cf[i].of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN TYPEOF(cf[i].of_shape.definition) ) THEN
      IF ( NOT ( cf[i].of_shape.definition IN cd_bag )) THEN
        cd_bag := cd_bag + cf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  def_bag := [];
  sa_bag := QUERY( sa <* cf | (sa.of_shape.definition :=: cd_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT' ) | 
             (sar\shape_aspect_relationship.name = 'instantiated feature') );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN def_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          def_bag := def_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_feature_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of 'assembly module component terminal',
'bare die component terminal', 'interconnect component join terminal',
'interconnect module component terminal', 'interconnect module component stratum based terminal',
'minimally defined component terminal' or 'packaged component join terminal' and
component_interface_terminal with a name of either 'interconnect component interface terminal'
or 'packaged connector component interface terminal' must have a unique combination of
of_shape.definition attributes and shape_aspect entities where the shape_aspects
are related to the component_terminals and component_interface_terminals by a
shape_aspect_relationship with a name of 'instantiated feature'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_mounting_clearance_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_mounting_clearance_relationship_constraint rule
constrain the items of a representation and constrain the usage of that 
representation when it is used as a component mounting clearance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF the representation name = 'mounting clearance' it shall contain one item that 
is a length_measure_with_unit that has a name = 'minimum height'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF the representation name = 'mounting clearance' there shall be one 
property_definition_representation for which the representation is the 
used_representation and the definition for the 
property_definition_representation is a property_definition with a name 
equal to 'component mounting property', and the shape_aspect for the property_definition
is a component_feature_relationship.
</Informal.propositions.rul> 
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_overlap_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_overlap_relationship_constraint rule
constrain the items of a representation and constrain the usage of that 
representation when it is used as a component overlap clearance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF the representation name = 'overlap clearance' it shall contain one item that 
is a length_measure_with_unit that has a name = 'minimum clearance'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF the representation name = 'overlap clearance' there shall be two 
property_definition_representations for which the representation is the 
used_representation and the definition for the 
property_definition_representations is a property_definition with a name 
equal to 'component mounting property' and one of the property_definitions 
has a description = 'current component' and the second property_definition
has a description = 'previously placed component'.
</Informal.propositions.rul> 
<Informal.propositions.rul> 
IF the representation name = 'overlap clearance' the two 
property_definition_representations for which the representation is the 
used_representation must have two 
product_definition_relationships which point to 
one product_definition.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_part_2d_geometric_representation_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_part_2d_geometric_representation_relationship_constraint rule 
constrains the rep_1 and rep_2 attributes of a shape_representation_relationship when it is used to relate a component planar shape and the defining part planar shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part planar shape' the representation_relationship.rep_1 shall
have the same dimensionality as representation_relationship.rep_2.
</Formal.propositions.rul>
</Formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part planar shape' the representation_relationship.rep_1 shall be 
a shape_representation with name = 'planar projected shape' that is the 
used_representation of a property_definition_representation where 
property_definition_representation references an instance through the definition attribute that
(is a physical_unit) 
(is a part_template_definition whose shape is defined by a 
characterized_object).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part planar shape' the representation_relationship.rep_2 shall be 
a shape_representation with name = 'planar projected shape' that is the 
used_representation of a property_definition_representation where 
({property_definition_representation definition is a product_definition_shape} 
{property_definition_representation references a product_definition that is a 
component_definition}) 
(property_definition_representation references a shape_aspect that is a 
component_shape_aspect).
</Informal.propositions.rul>
<Informal.propositions.rul>
The combination of representation_relationship.rep_1, 
representation_relationship.rep_2 shall be unique within a population
of representation_relationship with a representation_relationship 
name = 'component part planar shape'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="component_part_3d_geometric_representation_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_part_3d_geometric_representation_relationship_constraint rule 
constrains the rep_1 and rep_2 attributes of a 
shape_representation_relationship when it is used to relate a component 3d shape and the defining part 3d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_part_3d_geometric_representation_relationship_constraint FOR
( shape_representation_relationship );
LOCAL
 rr: SET OF representation_relationship :=
      QUERY ( srr <* shape_representation_relationship |
       srr\representation_relationship.name = 'component part 3d shape');
 pass: BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(rr) by 1;
IF ((rr[i].rep_1.context_of_items.coordinate_space_dimension) <> 
          (rr[i].rep_2.context_of_items.coordinate_space_dimension))
THEN
  pass := FALSE;
END_IF;
END_REPEAT;
WHERE
 WR1: pass;
END_RULE; -- component_part_3d_geometric_representation_-
          -- relationship_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part 3d shape' the representation_relationship.rep_1 shall
have the same context dimensionality as representation_relationship.rep_2.
</Formal.propositions.rul>
</Formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part 3d shape' the representation_relationship.rep_1 shall be 
a shape_representation with name = '3d bound volume shape' or 
'part template non planar 2d shape' that is the 
used_representation of a property_definition_representation where 
property_definition_representation.definition.definition 
(is a physical_unit) 
(is a part_template_definition whose shape is defined by a 
characterized_object).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_representation_relationship\representation_relationship.name = 
'component part 3d shape' the representation_relationship.rep_2 shall be 
a shape_representation with name = '3d bound volume shape' that is the 
used_representation of a property_definition_representation where 
({property_definition_representation definition is a product_definition_shape} 
{property_definition_representation definition references a 
component_definition}) 
(property_definition_representation definition references a 
component_shape_aspect).
</Informal.propositions.rul>
<Informal.propositions.rul>
The combination of representation_relationship.rep1 and
representation_relationship.rep2 shall be unique.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="component_placement_restriction_assignment_constraint">
<RULE.DESCRIPTION>
The component_placement_restriction_assignment_constraint rule constrains
a representation that is used as a component placement restriction assignment.
This rule implements WR1 of the Application object.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF representation_relationship.name = 'component placement restriction assignment area' the 
shape_aspect at the end of the path starting with rep_2 through used_representation of a property_definition_representation and ending with property_definition_representation.definition.definition shall be a mounting_restriction_area.

IF representation_relationship.name = 'component placement restriction assignment volume' the 
shape_aspect at the end of the path starting with rep_2 through used_representation of a property_definition_representation and ending with property_definition_representation.definition.definition shall be a mounting_restriction_volume.

At least one of area or volume shall exist.
</formal.propositions.rul>
<formal.propositions.rul> 
IF representation.name = 
'component placement restriction assignment' the representation shall be referenced as a used_representation by a
property_definition_representation that shall have a definition that shall be a 
grouped_requirements_property which has a name = 
'item restricted requirements property'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_interface_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_assembly_module_interface_terminal_assignment_constraint rule
constrains the related_shape_aspect of a shape_aspect_relationship when it is
used as a component terminal to assembly module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_interface_terminal where the product_definition referenced through the path 
assembly_module_interface_terminal to it's supertype
shape_aspect.of_shape.definition.name = 'assembly module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_terminal where component_terminal\shape_aspect.description = 
   ('assembly module component terminal') 
   ('interconnect module component terminal')) 
(component_interface_terminal) 
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_assembly_module_interface_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE 
component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
              'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_MODULE_INTERFACE_TERMINAL' IN TYPEOF(cttamta[i].relating_shape_aspect) ) 
    THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_assembly_module_interface_terminal_assignment_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique assembly_module_interface_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_join_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_assembly_module_join_terminal_assignment_constraint rule
constrains the related_shape_aspect of a shape_aspect_relationship when it is
used as a component terminal to assembly module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_join_terminal where the product referenced through the path 
assembly_module_join_terminal to it's supertyp
shape_aspect.of_shape.definition is a product_definition has a name = 'assembly module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_terminal where component_terminal\shape_aspect.description = 
   ('assembly module component terminal') 
   ('interconnect module component terminal')) 
(component_interface_terminal) 
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_assembly_module_join_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique assembly_module_join_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_interface_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_interconnect_module_interface_terminal_assignment_constraint
rule constrains the related_shape_aspect of a shape_aspect_relationship when
it is used as a component terminal to interconnect module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_interface_terminal where the product referenced through the path 
assembly_module_interface_terminal to it's supertype
shape_aspect.of_shape.definition is a 
product_definition that has a name = 'interconnect module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_shape_aspect where component_shape_aspect description =
   ('component termination passage interface terminal') 
   ('land interface terminal') 
   ('non functional land interface terminal') 
   ('printed connector component interface terminal)).
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_interconnect_module_interface_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_interface_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERCONNECT_MODULE_INTERFACE_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique interconnect_module_interface_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_join_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The component_terminal_to_interconnect_module_join_terminal_assignment_constraint
rule constrains the related_shape_aspect of a shape_aspect_relationship when
it is used as a component terminal to interconnect module terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_join_terminal where the product referenced through the path 
assembly_module_join_terminal to it's supertype
shape_aspect.of_shape.definition is a 
product_definition that has a name = 'interconnect module'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_shape_aspect where component_shape_aspect description =
   ('component termination passage interface terminal') 
   ('land interface terminal') 
   ('non functional land interface terminal') 
   ('printed connector component interface terminal)).
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_interconnect_module_join_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
FOR
 ( shape_aspect_relationship );
LOCAL
  cttimta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
          'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  imt_bag : BAG OF interconnect_module_join_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttimta) by 1;
  IF EXISTS( cttimta[i].relating_shape_aspect ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'INTERCONNECT_MODULE_JOIN_TERMINAL' IN 
                    TYPEOF(cttimta[i].relating_shape_aspect) ) THEN
      IF ( cttimta[i].relating_shape_aspect IN imt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        imt_bag := imt_bag + cttimta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'component feature to physical usage view assignment' must have a unique interconnect_module_join_terminal entity
as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_pca_terminal_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_pca_terminal_assignment_constraint rule constrains
the related_shape_aspect of a shape_aspect_relationship when it is used as a
component terminal to pca terminal assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {shape_aspect_relationship.name = 'component feature to physical usage view assignment'} 
{shape_aspect_relationship.relating_shape_aspect is an 
assembly_module_terminal\shape_aspect.description = 'pca terminal'} 
the shape_aspect_relationship.related_shape_aspect shall be a 
(component_terminal where component_terminal\shape_aspect.description = 
   ('assembly module component terminal') 
   ('interconnect module component terminal')) 
(component_interface_terminal) 
(assembly_module_terminal where 
assembly_module_terminal\shape_aspect.description = 'pca terminal').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_terminal_to_pca_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_terminal_to_pca_terminal_assignment_unique_constraint
rule constrains the shape_aspect_relationship population members, that fill the
role of ARM component_terminal_to_pca_terminal_assignment, so that
the ARM usage_view_terminal attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  cttamta : BAG OF shape_aspect_relationship := QUERY( sar <*
shape_aspect_relationship | (sar\shape_aspect_relationship.name = 
             'component feature to physical usage view assignment') );
  pass : BOOLEAN := TRUE;
  amt_bag : BAG OF assembly_module_terminal := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(cttamta) by 1;
  IF EXISTS( cttamta[i].relating_shape_aspect ) THEN
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT' IN TYPEOF(cttamta[i].relating_shape_aspect)) AND
(cttamta[i].relating_shape_aspect\shape_aspect.description = 'pca terminal') ) THEN
      IF ( cttamta[i].relating_shape_aspect IN amt_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        amt_bag := amt_bag + cttamta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_terminal_to_pca_terminal_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'component feature to physical usage view assignment'
must have a unique assembly_module_terminal entity with a description of
'pca terminal' as the shape_aspect_relationship's relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="component_termination_passage_template_terminal_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_termination_passage_template_terminal_constraint rule constrains
the use of a shape_aspect when it is used as a component termination passage
template terminal.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF a shape_aspect 
{has a description = ('component termination passage interface terminal') 
('component termination passage join terminal')} 
{is the related_shape_aspect of a shape_aspect_relationship which 
   {has a name = 'access mechanism'} 
   {has a relating_shape_aspect which is a part_template_definition with 
      {a description = 'component termination passage template'} 
      {a of_shape.definition which is a characterized_object}}} 
the shape_aspect must be the relating_shape_aspect of at least one 
shape_aspect_relationship where 
{shape_aspect_relationship.name = 'terminal connection zone'} 
{shape_aspect_relationship.related_shape_aspect is a 
shape_aspect.description = 'connection zone'}.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="component_termination_passage_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The component_termination_passage_template_terminal_unique_constraint rule constrains
the shape_aspect population members, that fill the role of ARM
component_termination_passage_template_terminal, so the combination of ARM
associated_definition and ARM name shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE component_termination_passage_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  ctptt : BAG OF shape_aspect := QUERY( sa <* shape_aspect |
((sa\shape_aspect.description = 
'component termination passage template interface terminal') OR
(sa\shape_aspect.description = 
'component termination passage template join terminal')) );
  name_bag : BAG OF STRING := [];
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ctptt) by 1;
  IF EXISTS( ctptt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ctptt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ctptt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ptd_bag := [];
  sa_bag := QUERY( sa <* ctptt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(sa_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'access mechanism') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect)) AND
(sar.relating_shape_aspect\shape_aspect.name = 
       'component termination passage template')) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN ptd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          ptd_bag := ptd_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- component_termination_passage_template_terminal_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of either
'component termination passage template interface terminal' or
'component termination passage template join terminal' must have a unique
combination of name attribute and part_template_definition entity with a name
of 'component termination passage template' where the part_template_definition
is related to the shape_aspect by a shape_aspect_relationship with a name of
'access mechanism'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="composite_shape_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The composite_shape_element_constraint rule constrains the use of a composite_shape_aspect when it is used as a composite shape element or as an implementation of the ARM object Part_group_feature or as an implementation of the ARM object Composite_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each composite_shape_aspect shall be specified as the relating_shape_aspect by at least two shape_aspect_relationship that have a name of 'composing'.
</formal.propositions.rul>
<formal.propositions.rul>
Each composite_shape_aspect shall be at least one other type of shape_aspect.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each composite_shape_aspect that has a description of 'part group feature' shall only be related to
other part features by the 'composing' shape_aspect_relationship.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="composite_signal_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The composite_signal_property_constraint rule constrains the use
of a property_definition when it is used as a composite signal property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A property_definition with a name = 'composite signal property' shall be 
the relating_property_definition of at least one 
property_definition_relationship with a name = 
'composite signal property relationship'.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="conductive_interconnect_element_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conductive_interconnect_element_terminal_unique_constraint rule constrains
component_terminal population members, that fill the role of ARM
conductive_interconnect_element_terminal, so that the combination of ARM
name and ARM associated_component shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE conductive_interconnect_element_terminal_unique_constraint FOR
 ( component_terminal );
LOCAL
  ciet : BAG OF component_terminal := QUERY( ct <* component_terminal |
(ct\shape_aspect.description = 'conductive interconnect element terminal') );
  name_bag : BAG OF STRING := [];
  ct_bag : BAG OF component_terminal;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  csa_bag : BAG OF component_shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ciet) by 1;
  IF EXISTS( ciet[i]\shape_aspect.name ) THEN
    IF( NOT( ciet[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ciet[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ct_bag := QUERY( ct <* ciet | (ct\shape_aspect.name = name_bag[i]) );
  csa_bag := [];
  REPEAT j := 1 to SIZEOF(ct_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN( ct_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'associated component') AND (sar.relating_shape_aspect\shape_aspect.description IN
['conductive interconnect element with pre defined transitions',
'conductive interconnect element with user defined single transition'])
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF( sar_bag[k].relating_shape_aspect IN csa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          csa_bag := csa_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- conductive_interconnect_element_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of
'conductive interconnect element terminal' must have a
unique combination of name attributes and component_shape_aspect
entities that are related via a shape_aspect_relationship with a
name of 'associated component'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conductive_interconnect_element_with_pre_defined_transitions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conductive_interconnect_element_with_pre_defined_transitions_constraint rule
constrains the use of a shape_aspect when it is used as a conductive
interconnect element with pre defined transitions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with pre defined transitions'} 
{of_shape.definition is a component_definition} shall be the definition of 
exactly one property_definition_representation that has a used_representation
(that is a shape_representation.name = 'bound face' and one item is a 
face_surface) 
(that is a representation.name = 'styled curve' and one item is 
an annotation_curve_occurrence).
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with pre defined transitions'} 
{of_shape.definition is a component_definition} shall be the 
related_shape_aspect of exactly one shape_aspect_relationship with a 
name = 'instantiated feature' that has a relating_shape_aspect that is a 
part_template_definition with a description = 'trace template'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="conductive_interconnect_element_with_user_defined_single_transition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The
conductive_interconnect_element_with_user_defined_single_transition_constraint
rule constrains the use of a shape_aspect when it is used as a conductive
interconnect element with user defined single transition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the relating_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'end terminus'} 
{shape_aspect_relationship.related_shape_aspect is a layer_connection_point}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the relating_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'start terminus'} 
{shape_aspect_relationship.related_shape_aspect is a layer_connection_point}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall participate as a definition of exactly two 
property_definition_representations whose used_representation is a 
shape_representation and one shape_representation.items is a curve.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the related_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'instantiated feature'} 
{shape_aspect_relationship.description = 'end feature'} 
{shape_aspect_relationship.relating_shape_aspect is a 
part_template_definition whose description = 'trace template'}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect with 
{name = 'conductive interconnect element with user defined single transition'} 
{of_shape.definition is a component_definition} 
shall be the related_shape_aspect of one shape_aspect_relationship where 
{shape_aspect_relationship.name = 'instantiated feature'} 
{shape_aspect_relationship.description = 'start feature'} 
{shape_aspect_relationship.relating_shape_aspect is a 
part_template_definition whose description = 'trace template'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="configuration_controlled_message_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The configuration_controlled_message_constraint rule constrains the value
of the description of a descriptive_representation_item when it is used as
an approval date, manufacturers code, part number, or revision identifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF descriptive_representation_item\representation_item.name = 
'approval date' the descriptive_representation_item shall be an item in a 
representation that is referenced in an approval_assignment and the value 
of SELF.description shall be the concatenation of the value of 
date.year_component + ',' + the value of calendar_date.month_component + 
',' + the value of  calendar_date.day_component + ',' + 
the value of local_time.hour_component + ',' +  the value of 
local_time.minute_component + ',' + the value of local_time.second_component +
',' + the value of  coordinated_universal_time_offset.hour_offset + ',' + 
the value of  coordinated_universal_time_offset.minute_offset + ',' + 
the value of coordinated_universal_time_offset.sense.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF descriptive_representative_item\representative_item.name = 
'manufacturers code' the descriptive_representation_item shall be an item in a
representation that is referenced in an organization_assignment and the
value of SELF.description shall be identical to that of organization.id.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF descriptive_representative_item\representative_item.name = 'part number' 
the descriptive_representation_item shall be an item in a representation that 
is referenced in a property_definition_representation which has a 
definition.definition.formation that is a product_definition_formation and 
the value of SELF.description shall be identical to that of 
product_definition_formation.of_product.id.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF descriptive_representative_item\representative_item.name = 
'revision identifier' the descriptive_representation_item shall be an item 
in a representation which is referenced in a 
property_definition_representation that has a definition.definition.formation 
that is a product_definition_formation and the value of SELF.description 
shall be identical to that of product_definition_formation.id.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="configuration_item_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The configuration_item_requires_person_organization rule assures
that each configuration_item has an
applied_person_and_organization_assignment or an
applied_organization_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE configuration_item_requires_person_organization FOR
  (configuration_item,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (ci <* configuration_item |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       ci IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       ci IN aoa.items )) = 1 )))) = 0;
END_RULE; -- configuration_item_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of configuration_item, there shall be exactly one instance of
applied_person_and_organization_assignment that contains the instance of
configuration_item in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_boundary_and_surface_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_boundary_and_surface_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a conical tolerance zone boundary and surface relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'conical tolerance zone boundary and surface' shall have a related_shape_aspect that is either a part_template_definition or is on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'conical tolerance zone boundary and surface' shall have a relating_shape_aspect that is a tolerance_zone_boundary with a description of 'conical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'conical tolerance zone boundary and surface' shall have exactly one property_definition with a description of 'conical tolerance zone boundary size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a conical tolerance zone boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall be a property_definition of a tolerance_zone_boundary that has a description of 'conical'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size' and each of the property_definition that have a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance shall have the same name.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size' and each of the property_definition that have a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance shall relate to the same property_definition with a description of either 'datum system property with material conditions' or 'datum system property without material conditions' to specify their 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall relate to exactly two property_definition that have a description of 'conical tolerance zone boundary size' to specify its 'boundary size' and each of the property_definition that have a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance either shall not be modified_geometric_tolerance or shall have the same modifier.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone 
boundary' shall relate to exactly two property_definition that have a description of 
'conical tolerance zone boundary size' to specify its 'boundary size' and each of the 
property_definition that have a description of 'conical tolerance zone boundary size' 
shall be related as a 'defined boundary' to exactly one 
physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance 
shall specify the same instance of shape_aspect as their toleranced_shape_aspect, and 
that shape_aspect shall either be a centre_of_symmetry with a description of 'axis', 
or a composite_shape_aspect in which all the 'composing' shape_aspects are of type 
centre_of_symmetry and have a description of 'axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary' shall be a property_definition of a tolerance_zone_boundary that has a description of 'conical' and that tolerance_zone_boundary shall be specified as the first of the boundaries of a tolerance_zone_definition that specifies as its zone a tolerance_zone that has a description of 'conical'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_boundary_diametrical_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_boundary_diametrical_size_characteristic_constraint rule constrains the use of a property_definition when it is used as a conical tolerance zone boundary diametrical size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be a property_definition of a shape_aspect_relationship that has a name of 'conical tolerance zone boundary and surface'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be related as a 'boundary size' to exactly one property_definition that has a description of 'conical tolerance zone boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'conical tolerance zone boundary value', and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the physical_unit_geometric_tolerance that relates to the instance of property_definition that has a description of 'conical tolerance zone boundary size' to specify its 'defined boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and that physical_unit_geometric_tolerance shall be either a position_tolerance, a parallelism_tolerance, a perpendicularity_tolerance, or an angularity_tolerance.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'conical tolerance zone boundary size' shall be related as a 'boundary size' to exactly one property_definition that has a description of 'conical tolerance zone boundary' and that property_definition shall be applied to the same instance of tolerance_zone_boundary as specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'conical tolerance zone boundary and surface' and to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="conical_tolerance_zone_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The conical_tolerance_zone_definition_constraint rule constrains the use of a tolerance_zone_definition when it is used as a conical tolerance zone definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_definition that specifies a tolerance_zone with a description of 'conical' shall have exactly one boundary that is a tolerance_zone_boundary with a description of 'conical' and that tolerance_zone_boundary shall have exactly one property_definition that has a description of 'conical tolerance zone boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each tolerance_zone_definition that specifies a tolerance_zone with a description of 'conical' as it zone, shall have that tolerance_zone specify exactly two physical_unit_geometric_tolerance, as its defining_tolerance, and these physical_unit_geometric_tolerance shall be the same physical_unit_geometric_tolerance that relate to the property_definitions with a description of 'conical tolerance zone boundary size' that are applied to shape_aspect_relationships with names of 'conical tolerance zone boundary and surface' that specify the tolerance_zone_boundary, as the relating_shape_aspect, that is specified as the boundaries of the tolerance_zone_definition.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="connection_zone_constraint">
<RULE.DESCRIPTION>
The connection_zone_constraint rule constrains the use of
shape_aspect and shape_representation when implementing the ARM concepts
of Connection_zone and the associated colour.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE connection_zone_constraint FOR ( shape_aspect, representation );
WHERE
   WR1: SIZEOF( QUERY( sa <* shape_aspect | 
        (sa\shape_aspect.description = 'connection zone') AND NOT 
        (SIZEOF (USEDIN (sa, '')) >= 1))) = 0;
   WR2: SIZEOF( QUERY( sa <* shape_aspect | 
              (sa\shape_aspect.description = 'connection zone') AND 
        NOT(SIZEOF( QUERY( sar <* USEDIN(sa,
        'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
        (sar\shape_aspect_relationship.name IN [
        'connection',
        'minimum attachment region size',
        'maximum attachment region size',
        'external connection area', 
        'external connection zone',
        'internal connection zone',
        'mounting area', 
        'terminal connection zone'
         ]))) >= 1))) = 0;
END_RULE; -- connection_zone_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
Each instance of shape_aspect with a description of 'connection zone'
shall be referenced at least once.
</formal.propositions.rul> 
<formal.propositions.rul> 
Each instance of shape_aspect with a description of 'connection zone'
shall be referenced by at least one shape_aspect_relationship with a 
name of 
'connection',
'minimum attachment region size',
'maximum attachment region size',
'external connection area',
'external connection zone',
'internal connection zone',
'mounting area', or
'terminal connection zone'.
</formal.propositions.rul> 
</formal.propositions> 
<informal.propositions rule.types="IP">  
<informal.propositions.rul> 
Each instance of shape_aspect with a description of 'connection zone'
that is represented by a shape_representation that is capable of
representing topological information shall be represented by a
shape_representation that describes the connection zone
as being a set of connected points.
<example>
If a manifold_surface_shape_representation were to represent a connection zone,
there would only be one shell in the representation.
</example>
</informal.propositions.rul> 
</informal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="contract_unique_constraint">
<RULE.DESCRIPTION>
The contract_unique_constraint rule constrains the contract.name population members to satisfy the uniqueness requirement of the ARM application object Contract.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)

RULE contract_unique_constraint FOR (contract);

LOCAL
  r : BAG OF contract := QUERY (r <* contract | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\contract.name ) THEN
    IF (r[i]\contract.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\contract.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;

END_RULE; -- contract_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of contract.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="curve_extension_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_extension_constraint rule limits the values that the
extension for curve_style_with_extension shall be.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
 The allowed values for extension are: 
    + 0.5*width +/- delta,
    0 +/- delta,
    - 0.5*width +/- delta.
where delta is uncertainty_measure_with_unit, assigned by user.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="curve_style_font_and_scaling_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_style_font_and_scaling_unique_constraint rule constrains the curve_style_font_and_scaling name attribute in a population to satisfy the uniqueness requirement of the ARM application object Curve_style_font_and_scaling.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of curve_style_font_and_scaling.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="curve_style_requires_length_measure_with_unit">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_style_requires_length_measure_with_unit rule constrains the
entity pointed to by the curve_width attribute of a curve_style.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A curve_style.curve_width shall be a length_measure_with_unit.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="curve_style_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The curve_style_unique_constraint rule constrains the representation
population members, that fill the role of ARM curve_style, so that the
ARM name shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of representation with a name of 'curve style parameters' must
have a unique descriptive_representation_item.description attribute where the
descriptive_representation_item has a name of 'curve style name' and is a member
of the representation's set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="date_and_time_require_minute_and_second">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The date_and_time_require_minute_and_second rule constrains date_and_time
to include a minute and second component.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE date_and_time_require_minute_and_second FOR ( date_and_time );
WHERE
  WR1: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.minute_component)))) = 0;
  WR2: SIZEOF(QUERY(dat <* date_and_time |
              NOT(Exists(dat.time_component.second_component)))) = 0;
END_RULE; -- date_and_time_require_minute_and_second
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A date_and_time shall have a time_component.minute_component.
</formal.propositions.rul>
<formal.propositions.rul>
A date_and_time shall have a time_component.second_component.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="date_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The date_constraint rule specifies that all instances of
date shall have a year_number that has 4 digits.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE date_constraint FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       d.year_component < 1856)) = 0;
END_RULE; -- date_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date, the year_component shall be greater than or equal to 1856.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="datum_axis_and_tolerance_zone_orienting_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_axis_and_tolerance_zone_orienting_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum axis and tolerance zone orienting relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum axis and tolerance zone' shall have a related_shape_aspect that is a physical_unit_datum with a description of 'axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum axis and tolerance zone' shall have a relating_shape_aspect that is a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum axis and tolerance zone' shall have exactly one property_definition with a description of 'datum axis related orientation'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_axis_related_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_axis_related_orientation_constraint rule constrains the use of a property_definition when it is used as a datum axis related orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum axis related orientation' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum axis and tolerance zone'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum axis related orientation' shall have a name of either 'centred on arc' or 'centred on radial'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum axis related orientation' shall be related as a 'zone orientation' to exactly one property_definition that has a description of 'tolerance zone orientation'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_based_direction_vector_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_based_direction_vector_constraint rule constrains the use of a property_definition when it is used as a datum based direction vector.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall be a property_definition of a physical_unit_datum that has a description of 'plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall have a representation that contains exactly one axis1_placement that has a name of 'orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall have a name of either 'positive direction vector' or 'negative direction vector'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum direction property' shall be related as a 'element direction vector' to at least one property_definition that has a description of 'direction element'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_based_length_measure_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_based_length_measure_constraint rule constrain the usage of a
representation and the items of a representation when it is used as
maximum component height or clearance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name = 
('maximum positive component height') 
('maximum negative component height')
(`maximum mounting clearance')
(`minimum mounting clearance') shall have one items that is a 
length_measure_with_unit.name = 'measure'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation with a name = 
('maximum positive component height') 
('maximum negative component height') 
(`maximum mounting clearance')
(`minimum mounting clearance') shall have one items that is a 
direction.name = 'measure orientation' or that is a descriptive_representation_item.name = 'measure orientation'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation with a name = 
('maximum positive component height') 
('maximum negative component height') 
(`maximum mounting clearance')
(`minimum mounting clearance') shall be the used_representation of
one property_definition_representation that has a definition.definition that
is a datum.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="datum_based_vector_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_based_vector_orientation_constraint rule constrains the use of a property_definition when it is used as a datum based vector orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall be a property_definition of a shape_aspect that has a description of 'vector'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall relate to exactly two property_definition that have a description of 'direction element' to specify its 'direction component'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' either shall be related as a 'zone orientation' to at least one property_definition that has a description of 'tolerance zone orientation', shall be related as a 'measurement orientation' to at least one property_definition that has a description of 'dimensional location property' and that is a property_definition of a dimensional_location_with_direction, or shall be related as a 'measurement orientation' to at least one property_definition that has a description of 'dimensional location property' and that is a property_definition of an angular_dimension_with_orientation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall relate to exactly two property_definition that have a description of 'direction element' to specify its 'direction component' and each of these shall be a property_definition of instances of shape_aspect_relationship that have a name of 'datum plane and half plane relationship' and each of these shape_aspect_relationship shall specify a different physical_unit_datum that has a description of 'plane' as their related_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum based vector orientation' shall relate to exactly two property_definition that have a description of 'direction element' to specify its 'direction component' and each of these shall be a property_definition of instances of shape_aspect_relationship that have a name of 'datum plane and half plane relationship' and each of these shape_aspect_relationship shall specify a different physical_unit_datum that has a description of 'plane' as their related_shape_aspect and these physical_unit_datum shall be related to the same datum_reference_frame as 'reference plane'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector', and this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'. 

Additionally, each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector', and this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'.

Finally, each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship' and that shape_aspect_relationship shall have a related_shape_aspect that is of type physical_unit_datum and has a description of 'plane'. 

None of these physical_unit_datum shall be the same.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector', this property_definition shall be a property_definition of a physical_unit_datum that has a description of 'plane'. 

Additionally, each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector', this property_definition shall be a property_definition of a physical_unit_datum that has a description of 'plane'.

Finally, each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship' and that shape_aspect_relationship shall have a related_shape_aspect of type physical_unit_datum that has a description of 'plane'. 

These physical_unit_datum shall be related to the same datum_reference_frame as 'reference plane'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_material_condition_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_material_condition_property_constraint rule constrains the use of a property_definition when it is used as a datum feature material condition property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum feature usage in datum system'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall be related as a 'applied material condition property' to exactly one property_definition that has a description of 'datum system property with material conditions'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall have a name of either 'least material requirement' or 'maximum material principle'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum feature material condition property' shall be related as an 'applied material condition property' to exactly one property_definition that has a description of 'datum system property with material conditions' and that property_definition shall be applied to the same instance of datum_system as specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'datum feature usage in datum system' and to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_common_datum_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_common_datum_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in common datum relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in common datum' shall have a relating_shape_aspect that is a physical_unit_datum that has a name of 'common datum'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_datum_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_datum_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in datum relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'datum feature usage in common datum' or 'datum feature usage in single datum' shall have a related_shape_aspect that is a physical_unit_datum_feature.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'datum feature usage in common datum' or 'datum feature usage in single datum' shall have a relating_shape_aspect that is a physical_unit_datum.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'datum feature usage in common datum' or 'datum feature usage in single datum' shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_datum_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_datum_relationship_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
datum_feature_usage_in_datum_relationship, so that the combination of ARM
relating_shape_element and ARM related_shape_element attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE datum_feature_usage_in_datum_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  dfuidr : BAG OF shape_aspect_relationship := 
           QUERY( sar <* shape_aspect_relationship |
((sar\shape_aspect_relationship.name = 'datum feature usage in common datum') OR
(sar\shape_aspect_relationship.name = 'datum feature usage in single datum')) );
  pudf_bag : BAG OF physical_unit_datum_feature := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pud_bag : BAG OF physical_unit_datum;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuidr) by 1;
  IF EXISTS( dfuidr[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM' IN TYPEOF(dfuidr[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dfuidr[i].relating_shape_aspect IN pud_bag ) ) THEN
        pud_bag := pud_bag + dfuidr[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pud_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pudf_bag := [];
  sar_bag := 
  QUERY( sar <* dfuidr | ((sar.relating_shape_aspect :=: pud_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT_DATUM_FEATURE' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pudf_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pudf_bag := pudf_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- datum_feature_usage_in_datum_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of either
'datum feature usage in common datum' or 'datum feature usage in single datum'
must have a unique combination of relating_shape_aspect and related_shape_aspect
attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_datum_system_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_datum_system_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in datum system relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have a related_shape_aspect that is a physical_unit_datum_feature.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have a relating_shape_aspect that is a datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have exactly one property_definition with a description of 'datum feature material condition property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in datum system' shall have a related_shape_aspect that is a physical_unit_datum_feature that is in the set of physical_unit_datum_feature that are related as either 'datum feature usage in common datum' or 'datum feature usage in single datum' to the physical_unit_datum that are related as the 'datum usage in datum system' to the datum_system that is the relating_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_feature_usage_in_single_datum_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_feature_usage_in_single_datum_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum feature usage in single datum relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'datum feature usage in single datum' shall have a relating_shape_aspect that is a physical_unit_datum that has a name of 'single datum'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_precedence_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_precedence_assignment_constraint rule constrains the use of a property_definition when it is used as a datum precedence assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum usage in datum system'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall be related as a 'assigned datum precedence' to exactly one property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall have a name of either 'primary', 'secondary', or 'tertiary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum precedence assignment' shall be related as an 'assigned datum precedence' to exactly one property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' and that property_definition shall be applied to the same instance of datum_system as specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'datum usage in datum system' and to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_precedence_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_precedence_assignment_unique_constraint rule constrains
property_definition population members, that fill the role
of ARM datum_precedence_assignment, so that the combination of ARM
name and ARM datum_system_conditions_definition shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE datum_precedence_assignment_unique_constraint FOR
 ( property_definition );
LOCAL
  dpa : BAG OF property_definition := QUERY( pd <* property_definition |
(pd\property_definition.description = 'datum precedence assignment') );
  name_bag : BAG OF STRING := [];
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  pds : BAG OF property_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dpa) by 1;
  IF EXISTS( dpa[i]\property_definition.name ) THEN
    IF( NOT( dpa[i]\property_definition.name IN name_bag ) ) THEN
      name_bag := name_bag + dpa[i]\property_definition.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pds := [];
  pd_bag := QUERY( pd <* dpa | (pd\property_definition.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN(pd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION' ) |
((pdr\property_definition_relationship.name = 'assigned datum precedence') AND
(pdr.relating_property_definition\property_definition.description IN [
'datum system property with material conditions',
'datum system property without material conditions'])) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_property_definition ) THEN
        IF ( pdr_bag[k].relating_property_definition IN pds ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pds := pds + pdr_bag[k].relating_property_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- datum_precedence_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of property_definition with a description of
'datum precedence assignment' must have a unique combination of
name attribute and property_definition entity with a description of
either 'datum system property with material conditions' or
'datum system property without material conditions' where the
property_definitions are related by a property_definition_relationship
with a name of 'assigned datum precedence'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_system_defining_conditions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_system_defining_conditions_constraint rule constrains the use of a property_definition when it is used as a datum system defining conditions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' shall be a property_definition of a datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' shall relate to exactly one, two, or three property_definition that have a description of 'datum precedence assignment' to specify its 'assigned datum precedence'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' that relates, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'tertiary' shall also relate, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'secondary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' that relates, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'secondary' shall also relate, as 'assigned datum precedence', to a property_definition that has a description of 'datum precedence assignment' and has a name of 'primary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property with material conditions' shall be related as a 'referenced datum system definition' to at least one geometric_tolerance_with_specified_datum_system.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property without material conditions' either shall be related as a 'referenced datum system definition' to at least one geometric_tolerance_with_specified_datum_system or shall be related as a 'referenced datum system property' to at least one property_definition that has a description of 'dimensional location property' and that is a property_definition for a datum_system_based_dimensional_location.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'datum system property with material conditions' or 'datum system property without material conditions' shall relate to exactly one, two, or three property_definition that have a description of 'datum precedence assignment' to specify its 'assigned datum precedence' and those property_definition shall have unique names.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_system_defining_conditions_with_material_conditions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_system_defining_conditions_with_material_conditions_constraint rule constrains the use of a property_definition when it is used as a datum system defining conditions with material conditions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property with material conditions' shall relate to at least one property_definition that has a description of 'datum feature material condition property' to specify its 'applied material condition property'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_system_defining_conditions_without_material_conditions_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_system_defining_conditions_without_material_conditions_constraint rule constrains the use of a property_definition when it is used as a datum system defining conditions without material conditions.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'datum system property without material conditions' shall relate to exactly zero property_definition that have a description of 'datum feature material condition property' to specify its 'applied material condition property'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_target_usage_in_datum_target_set_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_target_usage_in_datum_target_set_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum target usage in datum target set relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'datum target usage'
must have a unique combination of related_shape_aspect and relating_shape_aspect attributes.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'datum target usage'
must have a unique combination of description and relating_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="datum_usage_in_datum_system_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The datum_usage_in_datum_system_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a datum usage in datum system relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'datum usage in datum system'
must have a unique combination of related_shape_aspect and relating_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="default_assembly_bond_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The default_assembly_bond_shape_constraint rule constrains the usage of
a shape_representation when it is used as a default assembly bond shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_representation\representation.name = 'default assembly bond shape' 
shall be related to exactly one assembly_bond_definition.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="default_passage_based_land_physical_template_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The default_passage_based_land_physical_template_unique_constraint rule constrains
land_physical_template population members, that fill the role of ARM
default_passage_based_land_physical_template, so that the combination of ARM
of_passage_technology and ARM of_stratum_technology attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE default_passage_based_land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  dpblpt : BAG OF land_physical_template := 
QUERY( lpt <* land_physical_template |
(lpt\shape_aspect.description IN ['default via based',
'default attachment size and via based',
'default unsupported passage based',
'default component termination passage based',
'default attachment size and component termination passage based']) );
  sar_bag : BAG OF shape_aspect_relationship;
  pt_bag : BAG OF passage_technology := [];
  pdr_bag : BAG OF property_definition_relationship;
  pass : BOOLEAN := TRUE;
  st_bag : BAG OF stratum_technology;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dpblpt) by 1;
  sar_bag := QUERY( sar <* USEDIN(dpblpt[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PASSAGE_TECHNOLOGY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( NOT ( sar_bag[j].related_shape_aspect IN pt_bag ) ) THEN
        pt_bag := pt_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pt_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  st_bag := [];
  sar_bag := QUERY( sar <* USEDIN(pt_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | ((sar\shape_aspect_relationship.name =
'technology usage') AND (sar.relating_shape_aspect IN dpblpt)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := 
    QUERY( pdr <* USEDIN(sar_bag[j].relating_shape_aspect\shape_aspect.of_shape,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'technology usage') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM_TECHNOLOGY' IN 
      TYPEOF(pdr.relating_property_definition.definition))) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_property_definition.definition ) THEN
        IF 
          ( pdr_bag[k].relating_property_definition.definition IN st_bag ) 
                                                                      THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          st_bag := st_bag + 
                       pdr_bag[k].relating_property_definition.definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- default_passage_based_land_physical_template_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of land_physical_template with a description of either
'default via based', 'default attachment size and via based',
'default unsupported passage based', 'default component termination passage based'
 or 'default attachment size and component termination passage based' must
have a unique combination of passage_technology and stratum_technology entities
where the passage_technology is related to the land_physical_template by a
shape_aspect_relationship with a name of 'technology usage' and where the
stratum_technology is related to the land_physical_template by a
property_definition_relationship with a name of 'technology usage'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="delete_design_object_management_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The delete_design_object_management_relationship_unique_constraint rule constrains
the delete_design_object_assignment and delete_design_object_request_assignment population
members, that fill the role of ARM delete_design_object_management_relationship, so
that the combination of ARM previous_design and ARM previous_design_object attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE delete_design_object_management_relationship_unique_constraint FOR
 ( delete_design_object_assignment, 
   delete_design_object_request_assignment );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  pd_bag : BAG OF product_definition := [];
  ddoa_bag : BAG OF delete_design_object_assignment;
  ddora_bag : BAG OF delete_design_object_request_assignment;
  pass : BOOLEAN := TRUE;
  mdo_bag : BAG OF managed_design_object;
END_LOCAL;

REPEAT i := 1 to SIZEOF(delete_design_object_assignment) by 1;
  REPEAT j := 1 TO SIZEOF(delete_design_object_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
        IN TYPEOF(delete_design_object_assignment[i].items[j]))
AND (delete_design_object_assignment[i].items[j].name = 
                          'design object deletion') ) THEN
      IF EXISTS( delete_design_object_assignment[i].items[j].
                                      relating_product_definition )
                                                               THEN
        IF( NOT( delete_design_object_assignment[i].items[j].
                                          relating_product_definition 
                                                 IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
                 delete_design_object_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(delete_design_object_request_assignment) by 1;
  REPEAT j := 1 TO 
         SIZEOF(delete_design_object_request_assignment[i].items) by 1;
    IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' 
         IN TYPEOF(delete_design_object_request_assignment[i].items[j]))
AND (delete_design_object_request_assignment[i].items[j].name = 
                                     'design object deletion') ) THEN
      IF EXISTS
       ( delete_design_object_request_assignment[i].items[j].
                                        relating_product_definition )
                                                            THEN
        IF( NOT
( delete_design_object_request_assignment[i].items[j].
                                         relating_product_definition 
                                              IN pd_bag ) ) THEN
          pd_bag := pd_bag + 
          delete_design_object_request_assignment[i].items[j].
                                           relating_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mdo_bag := [];
  pdr_bag := QUERY( pdr <* USEDIN(pd_bag[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION') | 
                        (pdr\product_definition_relationship.name = 'design object deletion') );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddoa_bag := QUERY( ddoa <* delete_design_object_assignment | 
                                   (pdr_bag[j] IN ddoa.items) );
    REPEAT k := 1 to SIZEOF(ddoa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddoa_bag[k].items) by 1;
        IF EXISTS( ddoa_bag[k].items[l] ) THEN
          IF ( ddoa_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddoa_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    ddora_bag := 
        QUERY( ddora <* delete_design_object_request_assignment | 
                                    (pdr_bag[j] IN ddora.items) );
    REPEAT k := 1 to SIZEOF(ddora_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(ddora_bag[k].items) by 1;
        IF EXISTS( ddora_bag[k].items[l] ) THEN
          IF ( ddora_bag[k].items[l] IN mdo_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            mdo_bag := mdo_bag + ddora_bag[k].items[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- delete_design_object_management_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of delete_design_object_assignment and delete_design_object_request_assignment
that has a common product_definition that is the relating_product_definition of a
product_definition_relationship that has a name of 'design object deletion' where the
product_definition_relationship is a member of the items attribute of the
delete_design_object_assignment and delete_design_object_request_assignment must have unique
managed_design object entities in their items attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_action_directive">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_action_directive rule specifies that all
instances of action_directive are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_action_directive FOR (action_directive);
WHERE
  WR1: SIZEOF (QUERY (ad <* action_directive |
       NOT (SIZEOF (USEDIN (ad, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_action_directive
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of action_directive, there shall be a reference to the
action_directive instance from an attribute of another entity.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_approval_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_approval_status rule specifies that all
instances of approval_status are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_approval_status FOR (approval_status);
WHERE
WR1: SIZEOF (QUERY (ast <* approval_status |
     NOT (SIZEOF (USEDIN (ast, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_approval_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of approval_status, there shall be a reference to the 
approval_status instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>


<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_certification_type">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_certification_type rule specifies that all
instances of certification_type are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_certification_type FOR (certification_type);
WHERE
  WR1: SIZEOF (QUERY (ct <* certification_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_certification_type
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of certification_type, there shall be a reference to the 
certification_type instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_contract_type">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_contract_type rule specifies that all
instances of contract_type are dependent on the usage to define another
entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_contract_type FOR (contract_type);
WHERE
  WR1: SIZEOF(QUERY ( ct <* contract_type |
       NOT (SIZEOF (USEDIN (ct, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_contract_type
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of contract_type, there shall be a reference to the 
contract_type instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_date">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_date rule specifies that all instances of
date are dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (dt <* date |
       NOT (SIZEOF(USEDIN (dt, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date, there shall be a reference to the 
date instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_date_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_date_role rule specifies that all instances
of date_role are dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (SIZEOF (USEDIN (dr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date_role, there shall be a reference to the 
date_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_date_time_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_date_time_role rule specifies that all
instances of date_time_role are dependent on the usage to define another
entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_date_time_role FOR (date_time_role);
WHERE
  WR1: SIZEOF (QUERY (dtr <* date_time_role |
       NOT (SIZEOF (USEDIN (dtr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_date_time_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of date_time_role, there shall be a reference to the 
date_time_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_document_type">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_document_type rule specifies that all
instances of document_type are dependent on the usage to define another
entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_document_type FOR (document_type);
WHERE
  WR1: SIZEOF (QUERY (dt <* document_type |
       NOT (SIZEOF (USEDIN (dt, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_document_type
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of document_type, there shall be a reference to the 
document_type instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_named_unit">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_named_unit rule specifies that all instances
of named_unit are dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_named_unit FOR (named_unit);
WHERE
  WR1: SIZEOF (QUERY (nu <* named_unit |
       NOT (SIZEOF (USEDIN (nu, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_named_unit
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of named_unit, there shall be a reference to the 
named_unit instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_organization_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_organization_role rule specifies that all
instances of organization_role are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_organization_role FOR (
         organization_role);
WHERE
  WR1: SIZEOF (QUERY (org <* organization_role |
       NOT (SIZEOF (USEDIN (org, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_organization_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of organization_role, there shall be a reference to the 
organization_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_parametric_representation_context">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_parametric_representation_context rule
specifies that all instances of parametric_representation_context are
dependent on the usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_parametric_representation_context FOR
  (parametric_representation_context);
WHERE
  WR1: SIZEOF (QUERY (prc <* parametric_representation_context |
       NOT (SIZEOF (USEDIN (prc, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_parametric_representation_context
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of parametric_representation_context, there shall be a
reference to the parametric_representation_context instance from an
attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_person_and_organization_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_person_and_organization_role rule specifies
that all instances of person_and_organization_role are dependent on the
usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_person_and_organization_role FOR (
         person_and_organization_role);
WHERE
  WR1: SIZEOF (QUERY (poar <* person_and_organization_role |
       NOT (SIZEOF (USEDIN (poar, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_person_and_organization_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of person_and_organization_role, there shall be a reference to
the person_and_organization_role instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_representation_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_representation_item rule specifies that all
instances of representation_item are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_representation_item FOR (representation_item);
WHERE
  WR1: SIZEOF (QUERY (ri <* representation_item |
       NOT (SIZEOF (USEDIN (ri, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_representation_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of representation_item, there shall be a reference to the 
representation_item instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_security_classification_level">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_security_classification_level rule specifies
that all instances of security_classification_level are dependent on the
usage to define another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_security_classification_level FOR (
         security_classification_level);
WHERE
  WR1: SIZEOF (QUERY (scl <* security_classification_level |
       NOT (SIZEOF (USEDIN (scl, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_security_classification_level
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of security_classification_level, there shall be a reference
to the security_classification_level instance from an attribute of another
entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_shape_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_shape_representation rule specifies that all
instances of shape_representation are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_shape_representation FOR (
         shape_representation);
WHERE
  WR1: SIZEOF (QUERY (sr <* shape_representation |
       NOT (SIZEOF(USEDIN(sr, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_shape_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of shape_representation, there shall be a reference to the 
shape_representation instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="dependent_instantiable_tolerance_value">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dependent_instantiable_tolerance_value rule specifies that all
instances of tolerance_value are dependent on the usage to define
another entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dependent_instantiable_tolerance_value FOR (
         tolerance_value);
WHERE
  WR1: SIZEOF (QUERY (tv <* tolerance_value |
       NOT (SIZEOF(USEDIN(tv, '')) >= 1))) = 0;
END_RULE; -- dependent_instantiable_tolerance_value
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
For each instance of tolerance_value, there shall be a reference to the 
tolerance_value instance from an attribute of another entity.
</formal.propositions.rul> 
</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="derived_shape_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The derived_shape_element_constraint rule constrains the use of a derived_shape_aspect when it is used as a derived shape element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each derived_shape_aspect shall not be derived from itself either directly or through intermediate derived_shape_aspects.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_composition_path_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_composition_path_constraint rule constrains relating and related
product_definition of a product_definition_relationship when it is used as
a design composition path.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 'design composition path' the 
relating_product_definition shall be a component_functional_unit with a 
frame_of_reference that is an application_context_element.name = 
'functional occurrence' and product_definition.description = 
'design definition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 'design composition path' the 
related_product_definition shall be a component_functional_unit with a 
frame_of_reference that is an application_context_element.name = 
'functional occurrence'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_component_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_component_constraint rule
constrains the relating and related product_definition for a
product_definition_relationship when it is used as a design functional unit
allocation to assembly_component.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_functional_unit_allocation_to_assembly_component_constraint FOR
( product_definition_relationship );
WHERE
   WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
     (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
                 (NOT(
    (pdr.relating_product_definition\product_definition.description = 'design definition path')
                    AND
            (pdr.relating_product_definition.id = 'design composition path')
                 ))
               )) = 0;

   WR2: SIZEOF (QUERY (pdr <* product_definition_relationship |
   (pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component')
               AND
     (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'COMPONENT_DEFINITION' IN TYPEOF (pdr.related_product_definition))) 
               )) = 0;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_relationship.name =
'design functional unit allocation to assembly component' the
SELF.relating_product_definition shall have a description = 'design definition path'
and an id = 'design composition path'.
</formal.propositions.rul>
<formal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly component' the 
SELF.related_product_definition shall be a component_definition.
</formal.propositions.rul>
</formal.propositions>

<informal.propositions rule.types="IP">
<informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly component' 
it shall be the definition of a property_definition which
is the definintion of a property_definition_representation which
has an item that is a descriptive_representation_item with a name
of 'local swappable' and a description of 'false' or 'true'.
</informal.propositions.rul>
<informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly component' 
it shall be the definition of a property_definition which
is the definintion of a property_definition_representation which
has an item that is a descriptive_representation_item with a name
of 'global swappable' and a description of 'false' or 'true'.
</informal.propositions.rul>
</informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_component_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_component_unique_constraint rule
constrains product_definition_relationship population members, that fill the role
of ARM design_functional_unit_allocation_to_assembly_component, so that the
combination of ARM implementation and ARM path_alias shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE
design_functional_unit_allocation_to_assembly_component_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatac : BAG OF product_definition_relationship := 
QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly component') );
  cd_bag : BAG OF component_definition := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatac) by 1;
  IF EXISTS( dfuatac[i].related_product_definition ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'COMPONENT_DEFINITION' IN 
TYPEOF(dfuatac[i].related_product_definition) ) THEN
      IF( NOT( dfuatac[i].related_product_definition IN cd_bag ) ) THEN
        cd_bag := cd_bag + dfuatac[i].related_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cd_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdr_bag := QUERY( pdr <* dfuatac | 
                 (pdr.related_product_definition :=: cd_bag[i]) );
  id_bag := [];
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].id ) THEN
      IF ( pdr_bag[j].id IN id_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        id_bag := id_bag + pdr_bag[j].id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'design functional unit allocation to assembly component' must have a
unique combination related_product_definition and id attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_joint_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_joint_constraint rule
constrains the relating and related product_definitions of a 
product_definition_relationship when it is a design functional unit
allocation to assembly joint.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly joint' THEN 
SELF.relating_product_definition shall be a 
component_functional_unit.description = 'design definition path' that is the 
relating_product_definition of a product_definition_relationship.name = 
'design composition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to assembly joint' THEN 
SELF.related_product_definition shall be a product_definition that is 
the of_shape.definition of an assembly_joint.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_assembly_joint_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_assembly_joint_unique_constraint rule
constrains product_definition_relationship population members, that fill the role
of ARM design_functional_unit_allocation_to_assembly_joint, so that the ARM
functional_design_definition_path shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE
design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  dfuataj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to assembly joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuataj) by 1;
  IF EXISTS( dfuataj[i].relating_product_definition ) THEN
    IF ( dfuataj[i].relating_product_definition.id = 
                         'design composition path' ) THEN
      IF ( dfuataj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuataj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_functional_unit_allocation_to_assembly_joint_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'design functional unit allocation to assembly joint' must have a
unique relating_product_definition attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_fabrication_joint_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_fabrication_joint_constraint rule
constrains the relating and related product_definition for a
product_definition_relationship when it is a design functional unit
allocation to fabrication joint.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to fabrication joint' THEN 
SELF.relating_product_definition shall be a 
component_functional_unit.description = 'design definition path' that is the 
relating_product_definition of a product_definition_relationship.name = 
'design composition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to fabrication joint' THEN 
SELF.related_product_definition shall be a product_definition that is the 
of_shape.definition of an fabrication_joint.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_fabrication_joint_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_fabrication_joint_unique_constraint rule
constrains product_definition_relationship population members, that fill the role
of ARM design_functional_unit_allocation_to_fabrication_joint, so that the ARM
functional_design_definition_path shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE
design_functional_unit_allocation_to_fabrication_joint_unique_constraint
FOR ( product_definition_relationship );
LOCAL
  dfuatfj : BAG OF product_definition_relationship := 
      QUERY( pdr <* product_definition_relationship |
(pdr\product_definition_relationship.name = 'design functional unit allocation to fabrication joint') );
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dfuatfj) by 1;
  IF EXISTS( dfuatfj[i].relating_product_definition ) THEN
    IF ( dfuatfj[i].relating_product_definition.id = 
                    'design composition path' ) THEN
      IF ( dfuatfj[i].relating_product_definition IN pd_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + dfuatfj[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_functional_unit_allocation_to_fabrication_joint_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a name of
'design functional unit allocation to fabrication joint' must have a
unique relating_product_definition attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_functional_unit_allocation_to_reference_functional_unit_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_functional_unit_allocation_to_reference_functional_unit_constraint
rule constrains the related and relating product_definition for a
product_definition_relationship when it is a design functional unit
allocation to reference function unit.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to reference functional unit' THEN 
SELF.relating_product_definition shall be a 
component_functional_unit.description = 'design definition path' that is the 
relating_product_definition of a product_definition_relationship.name = 
'design composition path'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'design functional unit allocation to reference functional unit' THEN 
SELF.related_product_definition shall be a 
component_functional_unit.description = 'reference definition path' that 
shall be the relating_product_definition of a 
product_definition_relationship.name = 'reference composition path'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_3d_position_constraint
rule constrains mapped_item when it is used as a
design intent modification in stratum planar position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_intent_modification_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'positioned design intent modification 3d shape')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target)))) = 0;
END_RULE; -- design_intent_modification_3d_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item with a name of
'positioned design intent modification 3d shape' shall
have a mapping_target that is a axis2_placement_3d.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item with a name of
'positioned design intent modification 3d shape' shall
be an item for a shape_representation with a name of
'3d bound volume shape' that is the used_representation
of a property_definiton_representation with a definition
that is a product_definition_shape with a definition
that is a physical_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each mapped_item with a name of
'positioned design intent modification 3d shape' shall
have a mapping_source that has a mapped_representation
that has a name of '3d bound volume shape' or is a
manifold_surface_shape_representation and that mapped_representation
is the used_representation for a property_definition_representation.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_non_planar_2d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_non_planar_2d_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a design intent modification non planar 2d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'design intent modification non planar 2d shape' shall be
the used_representation for exactly one property_definition
that shall have a definition that is a shape_modification.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_planar_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_planar_position_constraint
rule constrains mapped_item when it is used as a
design intent modification planar position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_intent_modification_planar_position_constraint FOR
( mapped_item );
WHERE
 WR1: SIZEOF(QUERY(mi <* mapped_item |
     (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target)))) = 0;
 WR2: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
       AND (SIZEOF(QUERY(rep <* USEDIN(mi,       
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REPRESENTATION.ITEMS') |
       SIZEOF(USEDIN(rep,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
     + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')) = 0
       )) = 0))) = 0;
 WR3: SIZEOF(QUERY(mi <* mapped_item |
    (mi\representation_item.name = 'design intent modification planar position')
     AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN
      TYPEOF(mi.mapping_source.mapped_representation)))) = 0;
END_RULE; -- design_intent_modification_planar_position_-
     -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
have a mapping_target that is a axis2_placement_2d.
</formal.propositions.rul>

<formal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
be an item for a representation that is a 
used_representation of a property_definition_representation.
</formal.propositions.rul>

<formal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
have a mapping_source that has a mapped_representation
that is a property_definition_representation.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item with a name of
'design intent modification planar position' shall
be an item for a shape_representation with a name of
'planar projected shape' that is the used_representation
of a property_definiton_representation with a definition
that is a product_definition_shape with a definition
that is a physical_unit.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_sequence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_sequence_constraint rule constrains the
related and relating shape_aspect of a shape_aspect_relationship when it
is a shape modification sequence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'shape modification sequence' 
THEN SELF.relating_shape_aspect shall be a shape_modification.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'shape modification sequence' 
THEN SELF.related_shape_aspect shall be a shape_modification.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="design_intent_modification_sequence_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_intent_modification_sequence_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
design_intent_modification_sequence, so that the combination of ARM
precedent_modification and ARM subsequent_modification attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE design_intent_modification_sequence_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  dims : BAG OF shape_aspect_relationship := 
         QUERY( sar <* shape_aspect_relationship |
(sar\shape_aspect_relationship.name = 'shape modification sequence'));
  pm_bag : BAG OF shape_modification := [];
  sar_bag : BAG OF shape_aspect_relationship;
  sm_bag : BAG OF shape_modification;
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dims) by 1;
  IF EXISTS( dims[i].relating_shape_aspect ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_MODIFICATION' IN TYPEOF(dims[i].relating_shape_aspect) ) THEN
      IF ( NOT ( dims[i].relating_shape_aspect IN pm_bag ) ) THEN
        pm_bag := pm_bag + dims[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pm_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* dims | 
         (sar.relating_shape_aspect :=: pm_bag[i]) );
  sm_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_MODIFICATION' IN 
                     TYPEOF(sar_bag[j].related_shape_aspect) ) THEN
        IF ( sar_bag[j].related_shape_aspect IN sm_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sm_bag := sm_bag + sar_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- design_intent_modification_sequence_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'shape modification sequence'
that references a common shape_modification through its relating_shape_aspect attribute must
have a unique reference to a shape_modification through its related_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="design_object_management_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The design_object_management_relationship_constraint rule constrains the
related and relating product_definition of a product_definition_relationship
when it is a design object management relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
('design object addition') 
('design object change') 
('design object deletion') 
THEN SELF.related_product_definition shall be a 
(product_definition_with_associated_documents) 
(physical_unit) 
(functional_unit).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 
('design object addition') 
('design object change') 
('design object deletion') 
THEN SELF.relating_product_definition shall be a 
(product_definition_with_associated_documents) 
(physical_unit) 
(functional_unit).
</Informal.propositions.rul>
<Informal.propositions.rul>
FOR each product_definition_relationship.name = 
('design object addition') 
('design object change') 
('design object deletion') 
there must be exactly one 
(add_design_object_assignment) 
(delete_design_object_assignment) 
({change_to_design_object_assignment} 
 {change_from_design_object_assignment}) populated.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="device_2d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The device_2d_position_constraint rule constrains the mapping_target of a
mapped_item when it is used as a device_2d_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = 'planar projected shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be a representation_item that is an 
items of a shape_representation where 
{shape_representation.name = 'planar projected shape'} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
packaged_part} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
physical_unit}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = 'planar projected shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item shall be an items of a shape_representation that is the 
used_representation of a property_definition_representation that has a 
definition.definition of a product_definition_relationship.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = 'planar projected shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be an axis2_placement_2d.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="device_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The device_3d_position_constraint rule constrains the mapping_target and the
usage of a mapped_item when it is used as a device_3d_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = '3d bound volume shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be a representation_item that is an 
items of a shape_representation where 
{shape_representation.name = '3d bound volume shape'} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
packaged_part} 
{shape_representation is the used_representation of a 
property_definition_representation whose definition.definition is a 
physical_unit}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = '3d bound volume shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item shall be an items of a shape_representation that is the 
used_representation of a property_definition_representation that has a 
definition.definition that is a product_definition_relationship.
</Informal.propositions.rul> 
<Informal.propositions.rul> 
IF mapped_item.mapping_source.mapped_representative is a shape_representation 
{with a name = '3d bound volume shape'} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a bare_die} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition of a physical_unit} 
THEN mapped_item.mapping_target shall be an axis2_placement_3d.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="device_terminal_map_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The device_terminal_map_relationship_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is used
as a device terminal map relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'device terminal map relationship' 
THEN shape_aspect_relationship.relating_shape_aspect shall be a 
device_terminal_map.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'device terminal map relationship' 
THEN shape_aspect_relationship.related_shape_aspect shall be a 
device_terminal_map.
</formal.propositions.rul>
</formal.Propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="diametrical_boundary_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The diametrical_boundary_size_characteristic_constraint rule constrains the use of a representation when it is used as a diametrical boundary size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name of 'diametrical boundary size' shall represent at least one property_definition that has a description of 'boundary zone definition with specified size' and that property_definition shall be applied to a tolerance_zone_boundary that has a description of 'circular or cylindrical or spherical'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_along_curve_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_along_curve_constraint rule constrains the use of a dimensional_location_with_path when it is used as a dimension along curve.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location_with_path shall have a description that is either 'arc length' or 'linear'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_along_curve_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_along_curve_unique_constraint rule constrains the
dimensional_location_with_path population members, that fill the
role of ARM dimension_along_curve, so that the ARM path
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dimension_along_curve_unique_constraint FOR
 ( dimensional_location_with_path );
LOCAL
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location_with_path) by 1;
  IF EXISTS( dimensional_location_with_path[i].path ) THEN
    IF ( dimensional_location_with_path[i].path IN sa_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      sa_bag := sa_bag + dimensional_location_with_path[i].path;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- dimension_along_curve_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of dimensional_location_with_path must have a
unique path attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_location_with_direction_vector_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_location_with_direction_vector_unique_constraint rule constrains the
dimensional_location_with_direction population members, that fill the role of ARM
dimension_location_with_direction_vector, so that the ARM measurement_direction
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE dimension_location_with_direction_vector_unique_constraint FOR
 ( dimensional_location );
LOCAL
  p_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_relationship;
  pdrep_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF property_definition := [];
  place_bag : BAG OF placement := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  p_bag := QUERY( pd <* USEDIN(dimensional_location[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | 
(pd\property_definition.description = 'dimensional location property') );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN(p_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
((pdr\property_definition_relationship.name = 'measurement orientation') AND
(pdr.related_property_definition\property_definition.description = 
         'datum based vector orientation')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].related_property_definition ) THEN
        IF ( pdr_bag[k].related_property_definition IN pd_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pd_bag := pd_bag + pdr_bag[k].related_property_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdrep_bag := USEDIN(p_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdrep_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(pdrep_bag[k].used_representation.items) by 1;
        IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PLACEMENT' IN TYPEOF(pdrep_bag[k].used_representation.items[l])) AND
(pdrep_bag[k].used_representation.items[l]\representation_item.name = 'orientation') ) THEN
          IF EXISTS( pdrep_bag[k].used_representation.items[l] ) THEN
           IF ( pdrep_bag[k].used_representation.items[l] IN 
                                                 place_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              place_bag := place_bag + 
                           pdrep_bag[k].used_representation.items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- dimension_location_with_direction_vector_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of dimensional_location_with_direction must either have a
unique property_definition entity with a name of 'datum based vector orientation'
that is related to the dimensional_location_with_direction by a
property_definition_relationship with a name of 'measurement orientation' or
have a unique placement entity with a name of 'orientation' that is related
to the dimensional_location_with_direction by a property_definition_representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a dimension qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has a name of either 'predefined dimension qualifier' or 'user defined dimension qualifier' shall have a qualified_measure that is a measure_with_unit that is contained in the shape_dimension_representation that is a representation of at least one dimensional_location or dimensional_size.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_related_positional_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_related_positional_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a dimension related positional boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall be a property_definition of a positional_boundary that has a description of 'dimension related positional boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall relate to at least one property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary member property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall relate to at least one property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary member property' and each of the property_definition that have a description of 'positional boundary member property' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance shall relate to the same property_definition with a description of either 'datum system property with material conditions' or 'datum system property without material conditions' to specify their 'referenced datum system definition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension related positional boundary property' shall relate to at least one property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary member property' and each of the property_definition that have a description of 'positional boundary member property' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance, and each of these physical_unit_geometric_tolerance either shall not be modified_geometric_tolerance or shall have the same modifier.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimension_set_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimension_set_constraint rule constrains the use of a property_definition when it is used as a dimension set.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension set' shall relate, to specify its 'set associated dimension', to at least one property_definition that is either a dimensional_size_property, or is a property_definition of a dimensional_location, that has a description of 'dimensional location property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'dimension set' shall be related as a 'true profile specification' to at least one property_definition that has a description of 'true profile'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimensional_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimensional_characteristic_constraint rule constrains the use of a dimensional_location and a dimensional_size when they are used as a dimensional characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location description shall be among 'angular', 'arc length', 'controlled radius', 'diameter', 'linear', or 'radius'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size name shall be among 'angular', 'arc length', 'controlled radius', 'diameter', 'linear', or 'radius'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location shall be represented by exactly one shape_dimension_representation that contains a descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location shall be represented by exactly zero shape_dimension_representation that contains more than one descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size shall be represented by exactly one shape_dimension_representation that contains a descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size shall be represented by exactly zero shape_dimension_representation that contains more than one descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location shall be specified as the dimension by at most one dimensional_characteristic_representation that is not an auxiliary_characteristic_dimension_representation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size shall be specified as the dimension by at most one dimensional_characteristic_representation that is not an auxiliary_characteristic_dimension_representation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location that has a description of 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not plane_angle_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size that has a name of 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not plane_angle_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_location that has a description that is not 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not length_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each dimensional_size that has a name that is not 'angular' shall be represented by exactly zero shape_dimension_representation that contain one or more measure_with_unit that are not length_measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
If there is at least one dimensional_location, there shall exist exactly one requirements_property that has a representation that contains a descriptive_representation_item that has the name of 'requirements description' and a description of 'geometric dimensioning and tolerancing reference', and that requirements_property shall be an item of one or more document_reference the assigned_document of which are ee_specification.
</Informal.propositions.rul>

<Informal.propositions.rul>
If there is at least one dimensional_size, there shall exist exactly one requirements_property that has a representation that contains a descriptive_representation_item that has the name of 'requirements description' and a description of 'geometric dimensioning and tolerancing reference', and that requirements_property shall be an item of one or more document_reference the assigned_document of which are ee_specification.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimensional_location_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimensional_location_constraint rule constrains the use of a dimensional_location when it is used as a dimensional location.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location shall have a description that is not 'diameter'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="dimensional_size_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The dimensional_size_constraint rule constrains the use of a dimensional_size when it is used as a dimensional size.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_size shall be represented by exactly zero shape_dimension_representation that name if it exists is not 'envelope tolerance'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="directed_action_requires_approval">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_action_requires_approval rule assure that each
instance of directed_action has an associated 
applied_approval_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_action_requires_approval FOR
  (directed_action, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       da IN aaa.items )) = 1 ))) = 0;
END_RULE; -- directed_action_requires_approval
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of directed_action, there shall be exactly one instance
of applied_approval_assignment that contains the instance of directed_action
in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="directed_action_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_action_requires_date_or_date_and_time rule
assures that each instance of directed_action has an
associated applied_date_assignment or an
applied_date_and_time_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_action_requires_date_or_date_and_time FOR
  (directed_action, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (da <* directed_action |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (da IN adata.items)
       AND (adata.role\date_time_role.name = 'start date'))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (da IN ada.items)
       AND (ada.role\date_role.name = 'start date'))) = 1 )))) = 0;
END_RULE; -- directed_action_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of directed_action, there shall be exactly one
instance of applied_date_and_time_assignment whose role.name is 'start date'
or exactly one instance of applied_date_assignment whose role.name is
'start date' that contains the instance of directed_action in
its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="directed_axis_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_axis_constraint rule constrains the use of a derived_shape_aspect when it is used as a directed axis.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_axis_constraint FOR
  (derived_shape_aspect);
WHERE
  WR1: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'derived axis')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       AND (sar\shape_aspect_relationship.related_shape_aspect\shape_aspect.description = 'axis')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'end shape aspect')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(dsa <* derived_shape_aspect |
       (dsa\shape_aspect.description = 'directed axis')
       AND NOT(SIZEOF(QUERY(sar <* USEDIN(dsa,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
       (sar\shape_aspect_relationship.name = 'start shape aspect')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT' IN TYPEOF(sar\shape_aspect_relationship.related_shape_aspect))
       )) = 1))) = 0;
END_RULE; -- directed_axis_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall relate to exactly one centre_of_symmetry that has a description of 'axis' to specify its 'derived axis'.
</formal.propositions.rul>

<formal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall relate to exactly one shape_aspect to specify its 'end shape aspect'.
</formal.propositions.rul>

<formal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall relate to exactly one shape_aspect to specify its 'start shape aspect'.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall specify a unique combination of shape_aspect that relate to the derived_shape_aspect to specify its 'start shape aspect' and its 'derived axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each derived_shape_aspect that has a description of 'directed axis' shall not relate to the same shape_aspect to specify its 'start shape aspect' and its 'end shape aspect'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="directed_axis_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The directed_axis_unique_constraint rule constrains the derived_shape_aspect
population members, that fill the role of ARM directed_axis, so that the
combination of ARM axis_to_be_oriented and ARM start_shape_element attributes
shall be unique within the population
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE directed_axis_unique_constraint FOR
 ( derived_shape_aspect );
LOCAL
  da : BAG OF derived_shape_aspect := QUERY( r <* derived_shape_aspect |
(r\shape_aspect.description = 'directed axis') );
  sar_bag : BAG OF shape_aspect_relationship;
  cos_bag : BAG OF centre_of_symmetry := [];
  sar2_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(da) by 1;
  sar_bag := QUERY( sar <* USEDIN(da[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.related_shape_aspect\shape_aspect.description = 'axis') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CENTRE_OF_SYMMETRY' IN TYPEOF(sar.related_shape_aspect))) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF( NOT( sar_bag[j].related_shape_aspect IN cos_bag ) ) THEN
        cos_bag := cos_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(cos_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  sar_bag := QUERY( sar <* USEDIN(cos_bag[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'derived axis') AND
(sar.relating_shape_aspect IN da)) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar2_bag := QUERY( sar <* USEDIN(sar_bag[j].relating_shape_aspect,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
(sar\shape_aspect_relationship.name = 'start shape aspect') );
    REPEAT k := 1 to SIZEOF(sar2_bag) by 1;
      IF EXISTS( sar2_bag[k].related_shape_aspect ) THEN
        IF ( sar2_bag[k].related_shape_aspect IN sa_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          sa_bag := sa_bag + sar2_bag[k].related_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- directed_axis_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of derived_shape_aspect with a description of 'derived axis'
must have a unique combination of centre_of_symmetry and shape_aspect
entities where the centre_of_symmetry is related to the derived_shape_aspect
by a shape_aspect_relationship with a name of 'derived axis' and the
shape_aspect is related to the derived_shape_aspect by a
shape_aspect_relationship with a name of 'start shape aspect'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="direction_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The direction_element_constraint rule constrains the use of a property_definition when it is used as a direction element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE direction_element_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'element direction vector')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'half datum plane direction vector')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description = 
          'datum direction_property')
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'direction element')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'direction component')
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))
       AND (pdr.related_property_definition\property_definition.description =
       'datum based vector orientation'))) = 1))) = 0;
END_RULE; -- direction_element_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall be related as a 'direction component' to at least one property_definition that has a description of 'datum based vector orientation'.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship'. The shape_aspect_relationship shall have a related_shape_aspect of type physical_unit_datum that has a description of 'plane' and a relating_shape_aspect of type shape_aspect that has a description of 'half plane' and that is not on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall have a representation that contains exactly one plane_angle_measure_with_unit that has a name of 'angle value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'half datum plane direction vector', this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'. 

Additionally, each instance of property_definition that has a description of 'direction element' shall relate to exactly one property_definition that has a description of 'datum direction property' to specify its 'element direction vector', this property_definition shall be applied to a physical_unit_datum that has a description of 'plane'.

Finally, each instance of property_definition that has a description of 'direction element' shall be a property_definition of a shape_aspect_relationship that has a name of 'datum plane and half plane relationship' and that shape_aspect_relationship shall have a related_shape_aspect of type physical_unit_datum that has a description of 'plane'. 

Each of these three physical_unit_datum shall not be the same.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="edge_segment_vertex_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The edge_segment_vertex_constraint rule constrains the shape_aspect and shape_aspect_relationship population members to satisfy the requirements of the ARM object Edge_segment_vertex.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE edge_segment_vertex_constraint 
FOR (shape_aspect_relationship, edge_segment_vertex);
LOCAL
sar : BAG OF shape_aspect_relationship := [];
esv : BAG OF edge_segment_vertex := edge_segment_vertex;
pass : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 1 to SIZEOF (esv) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
      sar := QUERY (sar <* shape_aspect_relationship |
       esv[i] = sar\shape_aspect_relationship.related_shape_aspect);
       pass := (SIZEOF(sar) = 2);
      REPEAT j := 2 to SIZEOF (sar) by 1;
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( (sar[j]) :<>: (sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := ( TYPEOF(sar[j]) = TYPEOF(sar[j-1]));
       IF (NOT pass) THEN ESCAPE; END_IF;
       pass := (sar[j].relating_shape_aspect :=:
               sar[j-1].relating_shape_aspect);
      END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;  -- edge_segment_vertex_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each edge_segment_vertex shall be referenced by two different segments for the same edge,
where the types of the two segments shall be the same.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="edge_segment_vertex_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The edge_segment_vertex_unique_constraint rule constrains the
edge_segment_vertex population members, that fill the role of ARM
edge_segment_vertex, to have unique ARM name attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE edge_segment_vertex_unique_constraint FOR
 ( edge_segment_vertex );
LOCAL
  esv : BAG OF edge_segment_vertex := QUERY( r <* edge_segment_vertex
| (r\shape_aspect.name = 'single datum') );
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(esv) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := QUERY( pd <* USEDIN( esv[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | 
(pd\property_definition.description = 'shape element characterization') );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := USEDIN( pd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      IF ( (pdr_bag[k].used_representation\representation.name = 
           'shape element characterization') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pdr_bag[k].used_representation.items[1])) ) THEN
        IF EXISTS
            ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description ) THEN
          IF ( pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description IN 
                   desc_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            desc_bag := desc_bag + 
                      pdr_bag[k].used_representation.items[1]\descriptive_representation_item.description;
          END_IF;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- edge_segment_vertex_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The colour_specification.name shall be unique within a population of colour_rgb.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_document_constraint">
<RULE.DESCRIPTION>
The ee_document_constraint rule constrains the usage of a document.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_document_constraint FOR ( document );
WHERE
  WR1: SIZEOF(QUERY(doc <* document |
       (SIZEOF(QUERY(adata <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(doc <* document |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'publisher')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'publisher')
       )) = 1)))) = 0;
  WR3: SIZEOF(QUERY(doc <* document |
       NOT (SIZEOF(USEDIN(doc,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS')) = 1)
       )) = 0;
END_RULE; -- ee_document_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A document shall be an items of an applied_date_and_time_assignment where the date and time is in the role of 'creation date'.
</formal.propositions.rul>
<formal.propositions.rul>
A document shall be an items of 
(an applied_organization_assignment.role.name = 'publisher') 
(a applied_person_and_organization_assignment.role.name = 'publisher').
</formal.propositions.rul>
<formal.propositions.rul>
A document shall be an items of exactly one document_identifier_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_document_unique_constraint">
<RULE.DESCRIPTION>
The ee_document_unique_constraint rule constrains document population members, that fill the role of ARM ee_document, so that ARM identification attributes shall be unique within the population.
The combination of base_identifier and revision shall be unique.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_document_unique_constraint FOR
 ( document, document_identifier_assignment );
LOCAL
  pass : BOOLEAN := TRUE;
  rev_exists_bag : BAG OF document := [];
  dia_bag : BAG OF document_identifier_assignment := [];
  desc_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(document) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  IF NOT(EXISTS( document[i].description )) THEN
   pass := FALSE;
  END_IF;
END_REPEAT;


REPEAT i := 1 to SIZEOF(document_identifier_assignment) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(document_identifier_assignment[i].items) by 1;
     desc_bag := desc_bag + document_identifier_assignment[i].items[j]\document.description;
  END_REPEAT;
  IF NOT(value_unique(desc_bag)) THEN
    pass := FALSE;
  END_IF;
END_REPEAT;

WHERE
  WR1: pass;
END_RULE; -- ee_document_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of document must have a unique combination of document_identifier and document.description.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_material_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_material_constraint rule constrains the use of a material_designation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<INFORMAL.PROPOSITIONS RULE.TYPES="IP">
<Informal.propositions.rul>
The material_designation shall be the designation for at most one material_electrical_conductivity_category.
</Informal.propositions.rul>

<Informal.propositions.rul>
The material_designation shall be the designation for at most one material_optical_conductivity_category.
</Informal.propositions.rul>

<Informal.propositions.rul>
The material_designation shall be the designation for at most one material_thermal_conductivity_category.
</Informal.propositions.rul>

<Informal.propositions.rul>
The material_designation shall be an items for exactly one applied_document_reference.
</Informal.propositions.rul>

</INFORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_material_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_material_unique_constraint rule constrains the material_designation
population members, that fill the role of ARM ee_material, so that the
combination of ARM material_name and ARM registration_document attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_material_unique_constraint FOR
 ( material_designation );
LOCAL
  name_bag : BAG OF STRING := [];
  md_bag : BAG OF material_designation;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(material_designation) by 1;
  IF EXISTS( material_designation[i].name ) THEN
    IF( NOT( material_designation[i].name IN name_bag ) ) THEN
      name_bag := name_bag + material_designation[i].name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  md_bag := QUERY( md <* material_designation | (md\material_designation.name = name_bag[i]) );
  doc_bag := [];
  REPEAT j := 1 to SIZEOF(md_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( md_bag[j], 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DOCUMENT') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- ee_material_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of material_designation must have a unique combination of name
attribute and document entity assigned to the material_designation by an
applied_document_reference's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_configuration_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_configuration_constraint rule constrains the usage of an
ee_product_configuration.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A configuration_item shall be the item of one 
(organization_assignment.role.name = 'configuration manager') 
(person_and_organization_assignment.role.name = 'configuration manager').
</Informal.propositions.rul>
<Informal.propositions.rul>
A configuration_item shall be an items of an approval_assignment.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_configuration_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_configuration_unique_constraint rule constrains the configuration_item
population members, that fill the role of ARM ee_product_configuration, so that the
combination of ARM item_id and ARM satisfying_product attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_configuration_unique_constraint FOR
 ( configuration_item );
LOCAL
  id_bag : BAG OF STRING := [];
  ci_bag : BAG OF configuration_item;
  cd_bag : BAG OF configuration_design;
  pass : BOOLEAN := TRUE;
  pdf_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_item) by 1;
  IF EXISTS( configuration_item[i].id ) THEN
    IF( NOT( configuration_item[i].id IN id_bag ) ) THEN
      id_bag := id_bag + configuration_item[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdf_bag := [];
  ci_bag := QUERY( ci <* configuration_item | (ci.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(ci_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    cd_bag := USEDIN( ci_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'CONFIGURATION_DESIGN.CONFIGURATION');
    REPEAT k := 1 to SIZEOF(cd_bag) by 1;
      IF EXISTS( cd_bag[k].design ) THEN
        IF ( cd_bag[k].design IN pdf_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pdf_bag := pdf_bag + cd_bag[k].design;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- ee_product_configuration_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of configuration_item must have a unique combination of id
attribute and product_definition_formation entity related to the configuration_item
by a configuration_design entity.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_constraint">
<RULE.DESCRIPTION>
The ee_product_constraint rule constrains the usage of a product.
<note>
Since there is no standard interpretation of category for Ee_product, there is no population constraint on product_category in this rule.
</note>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_constraint FOR ( product );
WHERE
  WR1: SIZEOF(QUERY(prod <* product |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(prod,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'design owner')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(prod,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'design owner')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(p <* product |
              SIZEOF(USEDIN(p,
              'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT')) = 0)) = 0;
END_RULE; -- ee_product_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A product shall be an items in 
(an organization_assignment.role.name = 'design owner') 
(a person_and_organization_assignment.role.name = 'design owner').
</formal.propositions.rul>
<formal.propositions.rul>
A product shall be the of_product of at least one 
product_definition_formation.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_definition_constraint rule constrains the use of a
product_definition_with_associated_documents.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_definition_constraint FOR 
( product_definition_with_associated_documents );
WHERE
  WR1: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(QUERY(adata <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')
       | (adata.role\date_time_role.name = 'creation date')
       )) = 1)))) = 0;
  WR2: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT ((SIZEOF(QUERY(aoa <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (aoa.role\organization_role.name = 'creator')
       )) = 1) OR 
       (SIZEOF(QUERY(apaoa <* USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')
       | (apaoa.role\person_and_organization_role.name = 'creator')
       )) = 1))
       )) = 0;
  WR3: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
  WR4: SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents |
       NOT(
       (SIZEOF(USEDIN(pdwad,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 1)
       )
       )) = 0;
END_RULE; -- ee_product_definition_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of one 
applied_date_and_time_assignment with a date and time role name = 'creation date'.
</formal.propositions.rul>
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of at least one 
(applied_organization_assignment with an organization role name = 'creator') 
(applied_person_and_organization_assignment with a person and organization role name = 'creator').
</formal.propositions.rul>
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of one 
applied_approval_assignment.
</formal.propositions.rul>
<formal.propositions.rul>
A product_definition_with_associated_documents shall be the item of one 
applied_security_classification_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_definition_unique_constraint rule constrains the
product_definition_with_associated_documents, physical_unit and functional_unit
population members, that fill the role of ARM ee_product_definition, so that the
the combination of ARM product_definition_id and ARM version attributes shall be unique
within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_definition_unique_constraint FOR
 ( product_definition_with_associated_documents, 
   physical_unit, functional_unit );
LOCAL
  pdwad : BAG OF product_definition := 
QUERY( r <* product_definition_with_associated_documents | (TRUE) );
  pu : BAG OF product_definition := QUERY( r <* physical_unit | (TRUE) );
  fu : BAG OF product_definition := QUERY( r <* functional_unit | (TRUE) );
  epd : BAG OF product_definition;
  pdf_bag : BAG OF product_definition_formation;
  pd_bag : BAG OF product_definition;
  pass1 : BOOLEAN := TRUE;
  lcs_bag : BAG OF STRING;
  pass2 : BOOLEAN := TRUE;
  id_bag : BAG OF STRING;
END_LOCAL;

epd := pdwad + pu + fu;
REPEAT i := 1 to SIZEOF(epd) by 1;
  IF EXISTS( epd[i].formation ) THEN
    IF( NOT( epd[i].formation IN pdf_bag ) ) THEN
      pdf_bag := pdf_bag + epd[i].formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  lcs_bag := [];
  id_bag := [];
  pd_bag := QUERY( pd <* epd | (pd.formation :=: pdf_bag[i]) );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass2 ) THEN
      IF EXISTS( pd_bag[j].id ) THEN
        IF ( pd_bag[j].id IN id_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          id_bag := id_bag + pd_bag[j].id;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass2;
END_RULE; -- ee_product_definition_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_with_associated_documents, physical_unit and
functional_unit must have a unique combination of formation and id attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_model_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_model_unique_constraint rule constrains the product_concept.id population members to satisfy the uniqueness requirement of the ARM application object Ee_product_model.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE ee_product_model_unique_constraint FOR (product_concept);

LOCAL
  r : BAG OF product_concept := QUERY (r <* product_concept | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\product_concept.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
  WR1 : pass;
END_RULE; -- ee_product_model_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The id shall be unique within a population of product_concept.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_unique_constraint">
<RULE.DESCRIPTION>
The ee_product_unique_constraint rule constrains the product
population members, that fill the role of ARM ee_product, so that the
combination of ARM part_number and ARM design_owner attributes shall
be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_unique_constraint FOR
 ( product );
LOCAL
  id_bag : BAG OF STRING := [];
  p_bag : BAG OF product;
  aoa_bag : BAG OF applied_organization_assignment;
  apaoa_bag : BAG OF applied_person_and_organization_assignment;
  pass : BOOLEAN := TRUE;
  o_bag : BAG OF organization;
  pao_bag : BAG OF person_and_organization;
END_LOCAL;

REPEAT i := 1 to SIZEOF(product) by 1;
  IF EXISTS( product[i].id ) THEN
    IF( NOT( product[i].id IN id_bag ) ) THEN
      id_bag := id_bag + product[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  o_bag := [];
  pao_bag := [];
  p_bag := QUERY( p <* product | (p.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(p_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aoa_bag := QUERY( aoa <* USEDIN( p_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ORGANIZATION' IN TYPEOF(aoa.assigned_organization)) AND 
(aoa.role\organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(aoa_bag) by 1;
      IF EXISTS( aoa_bag[k].assigned_organization ) THEN
        IF ( aoa_bag[k].assigned_organization IN o_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          o_bag := o_bag + aoa_bag[k].assigned_organization;
        END_IF;
      END_IF;
    END_REPEAT;
    apaoa_bag := QUERY( apaoa <* USEDIN( p_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PERSON_AND_ORGANIZATION' IN 
TYPEOF(apaoa.assigned_person_and_organization)) 
AND (apaoa.role\person_and_organization_role.name = 'design owner')) );
    REPEAT k := 1 to SIZEOF(apaoa_bag) by 1;
      IF EXISTS( apaoa_bag[k].assigned_person_and_organization ) THEN
        IF ( apaoa_bag[k].assigned_person_and_organization IN pao_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          pao_bag := pao_bag + 
                     apaoa_bag[k].assigned_person_and_organization;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- ee_product_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product must have a unique combination of id
attribute and either organization or person_and_organization entity
assigned to the product by either an applied_organization_assignment's
or an applied_person_andorganization_assignment's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="ee_product_version_supersedence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The ee_product_version_supersedence_constraint rule constrains the usage of a
product_definition_formation_relationship when it is a product version supersedence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE ee_product_version_supersedence_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       ((pdfr\product_definition_formation_relationship.name = 'product version supersedence')
       AND (NOT(pdfr.relating_product_definition_formation.of_product :=:
           pdfr.related_product_definition_formation.of_product)))
       )) = 0;
END_RULE; -- ee_product_version_supersedence_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_formation_relationship.name = 'product version supersedence' 
THEN the relating version and the related version shall be for the same product. 
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="equivalent_functional_terminals_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The equivalent_functional_terminals_assignment_constraint rule constrains
the related and relating shape_aspect of a shape_aspect_relationship when it
is used as an equivalent functional terminals assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'equivalent functional terminals 
assignment' THEN {related_shape_aspect} {relating_shape_aspect} shall be 
functional_unit_terminal_definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="equivalent_functional_unit_definition_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The equivalent_functional_unit_definition_assignment_constraint rule constrains
the use of the related and relating product_definition of a
product_definition_relationship when it is used as an equivalent functional
unit definition assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 
'equivalent functional unit definition assignment' THEN 
{related_product_definition} 
{relating_product_definition} shall be a functional_unit with a 
frame_of_reference that is an application_context_element.name = 
('functional network design') ('functional design usage').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="evaluated_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The evaluated_characteristic_constraint rule constrains the rep_1, rep_2, and
description of a representation_relationship when it is used as an
evaluated characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of representation_relationship whose name = 
'evaluated characteristic' shall have one rep_2 which is a 
coordinated_representation_item.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each instance of representation_relationship whose name = 
'evaluated characteristic' shall have a description = ('valid') ('invalid') 
('not evaluatable') ('to be evaluated').
</Informal.propositions.rul>
<Informal.propositions.rul>
Each instance of representation_relationship whose name = 
'evaluated characteristic' shall have one rep_1 that is a representation that 
is the used_representation of a property_definition_representation that has a 
name = 'planned characteristic'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="explicitly_located_layer_connection_point_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The explicitly_located_layer_connection_point_unique_constraint rule constrains the
layer_connection_point population members, that fill the role of ARM
explicitly_located_layer_connection_point, so that the combination of ARM location
and ARM resident_design_layer_stratum attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE explicitly_located_layer_connection_point_unique_constraint FOR
 ( layer_connection_point );
LOCAL
  ellcp : BAG OF layer_connection_point := 
   QUERY( lcp <* layer_connection_point
| (lcp\shape_aspect.description = 'explicitly located') );
  s_bag : BAG OF stratum := [];
  lcp_bag : BAG OF layer_connection_point;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  cp_bag : BAG OF cartesian_point;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ellcp) by 1;
  IF EXISTS( ellcp[i].of_shape.definition ) THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'STRATUM' IN TYPEOF(ellcp[i].of_shape.definition) ) THEN
      IF( NOT( ellcp[i].of_shape.definition IN s_bag ) ) THEN
        s_bag := s_bag + ellcp[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  cp_bag := [];
  lcp_bag := 
    QUERY( lcp <* ellcp | (lcp.of_shape.definition :=: s_bag[i]) );
  REPEAT j := 1 to SIZEOF(lcp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := USEDIN( lcp_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PROPERTY_DEFINITION.DEFINITION');
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := QUERY( pdr <* USEDIN( pd_bag[k],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
((pdr.used_representation\representation.name =
'connection point location') AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'CARTESIAN_POINT' IN TYPEOF(pdr.used_representation.items[1]))) );
      REPEAT l := 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].used_representation.items[1] ) THEN
          IF ( pdr_bag[l].used_representation.items[1] IN cp_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            cp_bag := cp_bag + pdr_bag[l].used_representation.items[1];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- explicitly_located_layer_connection_point_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of layer_connection_point with a description of 'explicitly located'
must have a unique combination of of_shape.definition attribute and
cartesian_point entity related to the layer_connection_point by a
property_definition_representation entity that has the layer_connection_point
as its definition.definition attribute and has the cartesian_point in the items
attribute of shape_representation that the property_definition_representation
has as its used_representation attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="feature_group_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The feature_group_relationship_constraint rule constrains
the relating_shape_aspect of a shape_aspect_relationship when it is used
as a feature group relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE feature_group_relationship_constraint FOR
( shape_aspect_relationship );
WHERE
  WR1: SIZEOF(QUERY(sar <* shape_aspect_relationship |
       (sar\shape_aspect_relationship.name = 'feature group relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))
       )) = 0;
END_RULE; -- feature_group_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'feature group relationship' THEN 
SELF.relating_shape_aspect shall be a composite_shape_aspect.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="feature_shape_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The feature_shape_definition_constraint rule constrains the use of a 
shape_representation when it is used as a feature_shape_definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">  
<formal.propositions.rul> 
Each instance of shape_representation with a name of 'zone shape' and a dimensionality of 3
shall be a manifold_subsurface_shape_representation.
</formal.propositions.rul> 

</formal.propositions> 
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="fill_area_occurrence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The fill_area_occurrence_constraint rule constrains the values of styled_item,
fill_style_target, and styles of an annotation_fill_area_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE fill_area_occurrence_constraint FOR 
( annotation_fill_area_occurrence );
WHERE
  WR1: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'ANNOTATION_FILL_AREA' IN TYPEOF(afao.item))
       )) = 0;
  WR2: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CARTESIAN_POINT' IN TYPEOF(afao.fill_style_target))
       )) = 0;
  WR3: SIZEOF(QUERY(afao <* annotation_fill_area_occurrence |
       SIZEOF(QUERY(psa <* afao.styles |
       SIZEOF(QUERY(cs <* psa.styles |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'CURVE_STYLE' IN TYPEOF(cs))
       )) = 0
       )) = 0
       )) = 0;
END_RULE; -- fill_area_occurrence_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
An annotation_fill_area_occurrence shall have a SELF\styled_item.item that is an 
annotation_fill_area.
</formal.propositions.rul>
<formal.propositions.rul>
An annotation_fill_area_occurrence shall have a fill_style_target that is a 
cartesian_point.
</formal.propositions.rul>
<formal.propositions.rul>
An annotation_fill_area_occurrence shall have at least one styles.styles 
that is a curve_style.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
An annotation_fill_area_occurrence shall have a styled_item.item.boundaries 
that is a representation_item that is an item of a styled_item that has 
one styles.styles that is a curve_style.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="fill_area_style_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

fill_area_style_constraint
The fill_area_style_constraint rule constrains the size of fill_styles of a fill_area_style.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE fill_area_style_constraint FOR ( fill_area_style );
WHERE
  WR1: SIZEOF(QUERY(fas <* fill_area_style |
       NOT (SIZEOF(fas.fill_styles) = 1 )
       )) = 0;
END_RULE; -- fill_area_style_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
The size of fill_styles shall be exactly 1.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="fill_area_style_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The fill_area_style_unique_constraint rule constrains the fill_area_style.name population members to satisfy the uniqueness requirement of the ARM application object Fill_area_style.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE fill_area_style_unique_constraint FOR (fill_area_style);

LOCAL
  r :  BAG OF fill_area_style := QUERY (r <* fill_area_style | TRUE);
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i]\fill_area_style.name ) THEN
    IF (r[i]\fill_area_style.name IN name_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i]\fill_area_style.name;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;

END_RULE; -- fill_area_style_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The name shall be unique within a population of fill_area_style.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_specification_to_requirement_occurrence_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_specification_to_requirement_occurrence_assignment_constraint
rule constrains a representation_relationship when it
is used as a functional_specification_to_requirement_occurrence_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF {representation_relationship.name = 'functional specification to requirement occurrence assignment'}
THEN rep_1 shall reference a representation that is a used_representation for a property_definition_representation
that has a definition that is a requirements_property.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF {representation_relationship.name = 'functional specification to requirement occurrence assignment'}
THEN rep_2 shall be a functional_specification.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_network_node_definition_unique_constraint">
<RULE.DESCRIPTION>
The functional_unit_network_node_definition_unique_constraint rule constrains
the network_node_definition population members, that fill the role of ARM
functional_unit_network_node_definition, so that the combination of ARM
functional_unit_network_node_name and ARM associated_functional_unit_definition
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_network_node_definition_unique_constraint FOR
 ( network_node_definition );
LOCAL
  funnd : BAG OF network_node_definition := 
 QUERY( nnd <* network_node_definition
| (nnd.frame_of_reference.name = 'functional network design') );
  name_bag : BAG OF STRING := [];
  nnd_bag : BAG OF network_node_definition;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(funnd) by 1;
  IF EXISTS( funnd[i]\product_definition.name ) THEN
    IF( NOT( funnd[i]\product_definition.name IN name_bag ) ) THEN
      name_bag := name_bag + funnd[i]\product_definition.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  nnd_bag := QUERY( nnd <* funnd | (nnd\product_definition.name = 
          name_bag[i]) );
  REPEAT j := 1 to SIZEOF(nnd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( nnd_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition)) AND 
                  (pdr\product_definition_relationship.name = 'functional unit network node')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_unit_network_node_definition_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of network_node_definition with a frame_of_reference.name
of 'functional network design' must have a unique combination of
formation.of_product.name attribute and functional_unit entity
related to the network_node_definition by a product_definition_relationship
with a name of 'functional unit network node'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_network_terminal_definition_bus_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_network_terminal_definition_bus_assignment_constraint rule
constrains the related and relating property_definition for a
property_definition_relationship when it is used as a functional unit network
terminal definition bus assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition bus assignment' THEN SELF.relating_property_definition.definition 
shall be a bus_structural_definition.
</formal.propositions.rul>
<formal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition bus assignment' THEN SELF.related_property_definition shall be a 
product_definition_shape that is the of_shape of a 
functional_unit_terminal_definition.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_network_terminal_definition_node_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_network_terminal_definition_node_assignment_constraint rule
constrains the value of the related and relating property_definition of a 
property_definition_relationship when it is a functional unit network
terminal definition node assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition node assignment' THEN SELF.relating_property_definition.definition 
shall be a network_node_definition that has a frame_of_reference that is 
an application_context_element.name = 'functional network design'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF property_definition_relationship.name = 'functional unit network terminal 
definition node assignment' THEN SELF.related_property_definition shall be a 
product_definition_shape that is the of_shape of a 
functional_unit_terminal_definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_requirement_allocation_constraint rule constrains the
related and relating product_definition of a product_definition_relationship
when it is a functional unit requirement allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship name = 'functional unit requirement 
allocation' THEN the relating_product_definition {shall be a 
product_definition with a frame_of_reference that is an 
application_context_element with name = 'design requirement'} 
{shall be the definition of a property_definition that is the
related_property_definition for a property_definition_relationship 
{with a name of 'functional requirement'} and a relating_property_relationship 
that is a requirements_property}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF product_definition_relationship.name = 'functional unit requirement 
allocation' THEN the related_product_definition shall be a 
component_functional_unit whose frame_of_reference is an 
application_context_element name = 'functional occurrence'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_terminal_bus_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_terminal_bus_assignment_constraint rule constrains the
related and relating property_definition of a property_definition_relationship
when it is a functional unit terminal bus assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal 
bus assignment' THEN the relating_property_definition definition shall be
a bus_structural_definition.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal 
bus assignment' THEN the related_property_definition shall be a 
product_definition_shape that is the of_shape of a 
component_functional_terminal whose description = 'unit terminal'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_terminal_node_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_terminal_node_assignment_constraint rule constrains the
related and relating property_definition of a property_definition_relationship
when it is a functional unit terminal node assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal node 
assignment' THEN the relating_property_definition definition shall be a 
network_node_definition that has a frame_of_reference that is an 
application_context_element with a name = 'functional network design'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF property_definition_relationship name = 'functional unit terminal node 
assignment' THEN the relating_property_definition shall be a
product_definition_shape that is the of_shape of a 
component_functional_terminal whose description = 'unit terminal'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_unique_constraint rule constrains the component_functional_unit
population members, that fill the role of ARM component_functional, so that the
combination of ARM reference_designation and ARM composed_network attributes shall
be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_unique_constraint FOR
 ( component_functional_unit );
LOCAL
  fu : BAG OF component_functional_unit := 
QUERY( cfu <* component_functional_unit
| (cfu.frame_of_reference.name = 'functional occurrence') );
  id_bag : BAG OF STRING := [];
  cfu_bag : BAG OF component_functional_unit;
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(fu) by 1;
  IF EXISTS( fu[i].id ) THEN
    IF( NOT( fu[i].id IN id_bag ) ) THEN
      id_bag := id_bag + fu[i].id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(id_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  cfu_bag := QUERY( cfu <* fu | (cfu.id = id_bag[i]) );
  REPEAT j := 1 to SIZEOF(cfu_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( cfu_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') | 
((pdr\product_definition_relationship.name = 'network composition')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'FUNCTIONAL_UNIT'
IN TYPEOF(pdr.relating_product_definition)) AND 
      (pdr.relating_product_definition.frame_of_reference.name =
       'functional network design')) );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].relating_product_definition ) THEN
        IF ( pdr_bag[k].relating_product_definition IN fu_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          fu_bag := fu_bag + pdr_bag[k].relating_product_definition;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_unit_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_functional_unit with a frame_of_reference.name of
'functional occurrence' must have a unique combination of id attribute and
functional_unit entity related to the component_functional_unit
by a product_definition_relationship entity with a name of 'network composition'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_unit_usage_view_terminal_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_unit_usage_view_terminal_definition_unique_constraint rule
constrains the functional_unit_terminal_definition population members, that
fill the role of ARM functional_unit_usage_view_terminal_definition, so that
the combination of ARM signal_name and ARM associated_functional_unit_definition
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR
 ( functional_unit_terminal_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  futd_bag : BAG OF functional_unit_terminal_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  fu_bag : BAG OF functional_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(functional_unit_terminal_definition) by 1;
  IF EXISTS( functional_unit_terminal_definition[i]\shape_aspect.name ) THEN
    IF( NOT( functional_unit_terminal_definition[i]\shape_aspect.name IN 
                                              name_bag ) ) THEN
      name_bag := name_bag + 
                    functional_unit_terminal_definition[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  fu_bag := [];
  futd_bag := QUERY( futd <* functional_unit_terminal_definition |
((futd\shape_aspect.name = name_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'FUNCTIONAL_UNIT' IN TYPEOF(futd.of_shape.definition)) AND
(futd.of_shape.definition.frame_of_reference.name = 
                                    'functional design usage')) );
  REPEAT j := 1 to SIZEOF(futd_bag) by 1;
    IF EXISTS( futd_bag[j].of_shape.definition ) THEN
      IF ( futd_bag[j].of_shape.definition IN fu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        fu_bag := fu_bag + futd_bag[j].of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- functional_unit_usage_view_terminal_definition_unique_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of functional_unit_terminal_definition must have a unique
combination of name and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_part_terminal_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_usage_view_to_part_terminal_assignment_constraint rule 
constrains the related and relating shape_aspect of a shape_aspect_relationship
when it is used as a functional terminal allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.relating_shape_aspect shall be a functional_unit_terminal_definition 
with a description = 'scalar terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.related_shape_aspect shall be an (assembly_module_terminal) 
(bare_die_terminal) (interconnect_module_terminal) 
(packaged_part_terminal).
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_part_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_usage_view_to_part_terminal_assignment_unique_constraint rule constrains 
shape_aspect_relationship population members, that fill the role of ARM
functional_usage_view_to_part_terminal_assignment, so that the combination of ARM
functional_usage_view_terminal and ARM physical_usage_view_terminal attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'functional terminal allocation'
that references a common functional_unit_terminal_definition with a name of 'scalar terminal'
through its relating_shape_aspect attribute must have a unique reference to either an
assembly_module_terminal, bare_die_terminal, interconnect_module_terminal 
or packaged_part_terminal through its related_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_printed_part_template_terminal_assignment_constraint">
<RULE.DESCRIPTION>
The functional_usage_view_to_printed_part_template_terminal_assignment_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is used as
a functional terminal allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.relating_shape_aspect shall be a functional_unit_terminal_definition 
with a description = 'scalar terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'functional terminal allocation' THEN 
SELF.related_shape_aspect shall be an 
(printed_part_template_terminal whose description = 
   ('interface terminal') ('join terminal')).
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
functional_usage_view_to_part_terminal_assignment, so that the combination of ARM
functional_usage_view_terminal and ARM physical_usage_view_terminal attributes
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of
'functional terminal allocation' must have a unique combination of
related_shape_aspect and relating_shape_aspect attributes where the
related_shape_aspect points to a printed_part_template_terminal
entity.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="geometric_tolerance_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The geometric_tolerance_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a geometric tolerance qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE geometric_tolerance_qualifier_constraint FOR
  (measure_qualification);
WHERE
  WR1: SIZEOF(QUERY(mq <* measure_qualification |
       ((mq\measure_qualification.name = 'predefined geometric tolerance qualifier')
       OR (mq\measure_qualification.name = 'user defined geometric tolerance qualifier'))
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MEASURE_WITH_UNIT' IN TYPEOF(mq.qualified_measure))
       AND(SIZEOF(QUERY(pugt <* USEDIN(mq.qualified_measure,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'GEOMETRIC_TOLERANCE.MAGNITUDE') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt)))) = 0)
       ))) = 0;
END_RULE; -- geometric_tolerance_qualifier_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each measure_qualification that has a name of either 'predefined geometric tolerance qualifier' or 'user defined geometric tolerance qualifier' shall have a qualified_measure that is a measure_with_unit that is the magnitude of a least one physical_unit_geometric_tolerance.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="geometric_tolerance_with_applied_material_condition_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The geometric_tolerance_with_applied_material_condition_property_constraint rule constrains the use of a modified_geometric_tolerance when it is used as a geometric tolerance with applied material condition property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each modified_geometric_tolerance shall specify as its toleranced_shape_aspect a 
shape_aspect that either lies on the boundary of the shape of the product; is a 
centre_of_symmetry with a description of either 'axis', 'plane', or 'point'; is a 
part_template_definition; or is a composite_shape_aspect the 'composing' shape_aspects 
of which either are all of type part_template_definition, or are all of type 
centre_of_symmetry and have the same description -- either 'axis', 'plane', or 
'point'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each modified_geometric_tolerance that specifies as its toleranced_shape_aspect a 
shape_aspect that is either on the boundary of the shape of the product, is a 
part_template_definition, or is a composite_shape_aspect the 'composing' shape_aspects 
of which are all of type part_template_definition; shall also be a position_tolerance 
with a name of 'boundary based position'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="inter_stratum_extent_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The inter_stratum_extent_constraint rule constrains the related and
relating product_definition of a product_definition_relationship when it is
an inter stratum extent.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE inter_stratum_extent_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'inter stratum extent') AND
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.related_product_definition)) AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.relating_product_definition)) 
       ))) = 0;
END_RULE; -- inter_stratum_extent_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_relationship.name = 'inter stratum extent' THEN 
{SELF.related_product_definition shall be a stratum} 
{SELF.relating_product_definition shall be a stratum}.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_component_interface_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_component_interface_terminal_unique_constraint rule constrains
the component_terminal population members, that fill the role of ARM
interconnect_component_interface_terminal, so that the combination of ARM name
and ARM associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of 'interconnect component interface terminal'
must have a unique combination of name and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_component_join_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_component_join_terminal_unique_constraint rule constrains
the component_terminal population members, that fill the role of ARM
interconnect_component_join_terminal, so that the combination of ARM name
and ARM associated_component attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of component_terminal with a name of 'interconnect component join terminal'
must have a unique combination of name and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_constraint_region_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_module_constraint_region_terminal_constraint rule constrains
the use of a group_shape_aspect when it is used to implement the ARM
concept of interconnect_module_constraint_region.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A group_shape_aspect with a description of 
"interconnect module constraint region" shall
have exactly one shape_representation
that shall be a csg_2d_shape_representation or that shall be a 3 dimensional representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_stratum_assembly_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_module_stratum_assembly_relationship_constraint rule
constrains the related and relating product_definition and the use of an
assembly_component_usage when it is an interconnect module stratum
assembly relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_module_stratum_assembly_relationship_constraint FOR
( assembly_component_usage );
WHERE
  WR1: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT' IN TYPEOF(acu.relating_product_definition))
       )) = 0;
  WR2: SIZEOF(QUERY(acu <* assembly_component_usage |
       (acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(acu.related_product_definition))
       )) = 0;
END_RULE; -- interconnect_module_stratum_assembly_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN 
SELF.relating_product_definition shall be a physical_unit.
</formal.propositions.rul>

<formal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN 
SELF.related_product_definition shall be a stratum.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN 
SELF.relating_product_definition shall be a physical_unit {whose 
frame_of_reference shall be an application_context_element.name = 
'physical design'} {whose formation.of_product shall be a product that is 
used in a product_categorization.name = 'interconnect module'}.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF assembly_component_usage\product_definition_relationship.name = 
'interconnect module stratum assembly relationship' THEN SELF shall be the 
definition of not more than one product_definition_shape that is the definition
of a property_definition_representation whose used_representation.items[i] 
is a mapped_item\representation_item.name = '3d positioned stratum shape in 
interconnect module' or 'planar positioned stratum shape in
interconnect module'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_stratum_assembly_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interconnect_module_stratum_assembly_relationship_unique_constraint rule constrains
assembly_component_usage population members, that fill the role of ARM
interconnect_module_stratum_assembly_relationship, so that the combination of ARM assembly
and ARM reference_designation attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR
 ( assembly_component_usage );
LOCAL
  imsar : BAG OF assembly_component_usage := 
QUERY( acu <* assembly_component_usage |
(acu\product_definition_relationship.name = 'interconnect module stratum assembly relationship') );
  pu_bag : BAG OF physical_unit := [];
  acu_bag : BAG OF assembly_component_usage;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(imsar) by 1;
  IF EXISTS( imsar[i].relating_product_definition ) THEN
    IF( (imsar[i].relating_product_definition.frame_of_reference.name = 
        'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(imsar[i].relating_product_definition)) ) THEN
      IF ( NOT ( imsar[i].relating_product_definition IN pu_bag )) THEN
        pu_bag := pu_bag + imsar[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  acu_bag := 
   QUERY( acu <* imsar | (acu.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(acu_bag) by 1;
    IF EXISTS( acu_bag[j].reference_designator ) THEN
      IF ( acu_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + acu_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- interconnect_module_stratum_assembly_relationship_-
          -- unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of assembly_component_usage with a name of
'interconnect module stratum assembly relationship' that has a common
relating_prooduct_definition must have a unique reference_designator.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="interconnect_module_surface_feature_constraint">
<RULE.DESCRIPTION>
The interconnect_module_surface_feature_constraint rule constrains the use of a shape_aspect when it is used to implement the ARM concept of Interconnect_module_surface_feature.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">

<formal.propositions.rul>
Each shape_aspect with a description of
'interconnect module surface feature' shall have an of_shape that
is a product_definition_shape with a definition that is a physical_unit
, externally_defined_physical_unit or a library_defined_physical_unit
that has a name of 'interconnect module', and a frame_of_reference which
is an application_context_element with a name of 'physical design usage'. 
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="interface_component_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The interface_component_allocation_constraint rule constrains the related
and relating product_definition of a product_definition_relationship when it
is an interface component allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A product_definition_relationship with a name of 'interface component allocation' 
shall have a relating_product_definition that is a component_definition whose 
description is 'mating connector'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF product_definition_relationship.name = 'interface component allocation' 
THEN SELF.related_product_definition is a interface_component_definition 
{whose frame_of_reference is an application_context_element.name = 
'physical occurrence'} {is the related_product_definition of a 
product_definition_relationship 
   {whose name = 'instantiated part'} 
   {whose relating_product_definition is a physical_unit with a 
frame_of_reference which is an application_context_element.name = 
'physical design usage'}}.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="internal_stratum_access_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The internal_stratum_access_constraint rule constrains the related and
relating shape_aspect of a shape_aspect_relationship when it is an internal
stratum access.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'internal stratum access' THEN 
SELF.relating_shape_aspect shall be a 
probe_access_area\shape_aspect.description = 'internal probe access area' 
whose of_shape.definition is a component_definition whose formation.of_product 
is a product which is related to a product_category.name = 
'interconnect module'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'internal stratum access' THEN 
SELF.related_shape_aspect shall be a plated_passage\shape_aspect.description = 
('bonded conductive base blind via') ('buried via') 
('interfacial connection') ('non conductive base blind via') 
('plated conductive base blind via').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="internal_stratum_access_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The internal_stratum_access_unique_constraint rule constrains the
shape_aspect_relationship population members, that fill the role of ARM
internal_stratum_access, so that the combination of ARM connected_probe
and ARM inter_stratum_feature attributes shall be unique within the
population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE internal_stratum_access_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  isa : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'internal stratum access'));
  paa_bag : BAG OF probe_access_area := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pp_bag : BAG OF plated_passage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(isa) by 1;
  IF EXISTS( isa[i].relating_shape_aspect ) THEN
    IF ( (isa[i].relating_shape_aspect\shape_aspect.description = 
'internal probe access area') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROBE_ACCESS_AREA' IN TYPEOF(isa[i].relating_shape_aspect)) ) THEN
      IF ( NOT ( isa[i].relating_shape_aspect IN paa_bag ) ) THEN
        paa_bag := paa_bag + isa[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(paa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pp_bag := [];
  sar_bag := QUERY( sar <* isa | ((sar.relating_shape_aspect :=: 
paa_bag[i]) AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PLATED_PASSAGE' IN TYPEOF(sar.related_shape_aspect)) AND
(sar.related_shape_aspect\shape_aspect.description IN 
['bonded conductive base blind via',
'buried via','interfacial connection','non conductive base blind via',
'plated conductive base blind via'])) );
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN pp_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pp_bag := pp_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- internal_stratum_access_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'internal stratum access'
must have a unique combination of relating_shape_aspect and related_shape_aspect attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="junction_vertex_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The junction_vertex_allocation_constraint rule constrains the related and
relating shape_aspect of a shape_aspect_relationship when it is a junction
vertex allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'junction vertex allocation' THEN 
SELF.related_shape_aspect shall be 
(a layer_connection_point\shape_aspect.description = 'explicitly located') 
(a join_shape_aspect\shape_aspect.name = 'inter stratum join').
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'junction vertex allocation' THEN 
SELF.relating_shape_aspect shall have a description = 'topological junction'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect_relationship.name = 'junction vertex allocation' THEN 
SELF.related_shape_aspect AND SELF.relating_shape_aspect shall be 
within the same product definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="junction_vertex_allocation_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The junction_vertex_allocation_unique_constraint rule constrains the
shape_aspect_relationship population members, that fill the role of
ARM junction_vertex_allocation, so that the ARM required_vertex
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'junction vertex allocation' must have a unique shape_aspect entity
with a name of 'topological junction' as the shape_aspect_relationship's
relating_shape_aspect attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="land_physical_template_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The land_physical_template_unique_constraint rule constrains the
land_physical_template population members, that fill the role of
ARM land_physical_template, so that the ARM pre_defined_classification_code
attribute shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE land_physical_template_unique_constraint FOR
 ( land_physical_template );
LOCAL
  adr_bag : BAG OF applied_document_reference;
  duc : BAG OF document_usage_constraint;
  pass : BOOLEAN := TRUE;
  duc_bag : BAG OF document_usage_constraint := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(land_physical_template) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  adr_bag := USEDIN(land_physical_template[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
  REPEAT j := 1 to SIZEOF(adr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    duc := QUERY( r <* USEDIN(adr_bag[j].assigned_document,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DOCUMENT_USAGE_CONSTRAINT.SOURCE') | (r\document_usage_constraint.subject_element =
'predefined classification code') );
    REPEAT k := 1 to SIZEOF(duc) by 1;
      IF EXISTS( duc[k] ) THEN
        IF ( duc[k] IN duc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          duc_bag := duc_bag + duc[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- land_physical_template_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of land_physical_template must have a unique
document_usage_constraint entity with a subject_element of
'predefined classification code' where the document_usage_constraint's
source attribute references the same entity as an applied_document_reference's
assigned_document attribute and the land_physical_template is a member
of the applied_document_reference's items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="land_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The land_template_terminal_unique_constraint rule constrains the
land_template_terminal population members, that fill the role of ARM
land_template_terminal, so the combination of ARM associated_definition
and ARM name shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE land_template_terminal_unique_constraint FOR
 ( land_template_terminal );
LOCAL
  ltt : BAG OF land_template_terminal := 
QUERY( sa <* land_template_terminal |
(sa\shape_aspect.description IN ['interface terminal','join terminal']) );
  name_bag : BAG OF STRING := [];
  ltt_bag : BAG OF land_template_terminal;
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  lpt_bag : BAG OF land_physical_template;
END_LOCAL;

REPEAT i := 1 to SIZEOF(ltt) by 1;
  IF EXISTS( ltt[i]\shape_aspect.name ) THEN
    IF ( NOT ( ltt[i]\shape_aspect.name IN name_bag ) ) THEN
      name_bag := name_bag + ltt[i]\shape_aspect.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  lpt_bag := [];
  ltt_bag := QUERY( sa <* ltt | (sa\shape_aspect.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(ltt_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    sar_bag := QUERY( sar <* USEDIN(ltt_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') | 
((sar\shape_aspect_relationship.name = 'associated definition') AND
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(sar.relating_shape_aspect))) );
    REPEAT k := 1 to SIZEOF(sar_bag) by 1;
      IF EXISTS( sar_bag[k].relating_shape_aspect ) THEN
        IF ( sar_bag[k].relating_shape_aspect IN lpt_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          lpt_bag := lpt_bag + sar_bag[k].relating_shape_aspect;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- land_template_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of land_template_terminal with a description of either
'interface terminal' or 'join terminal' must have a unique
combination of name attribute and land_physical_template entity where
the land_physical_template is related to the land_template_terminal by
a shape_aspect_relationship with a name of 'associated definition'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="layout_spacing_requirement_non_conforming_design_object_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The layout_spacing_requirement_non_conforming_design_object_constraint rule
constrains the related and relating shape_aspect and the use of a
shape_aspect_relationship when it is a layout spacing requirement violation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>

<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'layout spacing requirement violation' THEN
SELF.related_shape_aspect shall be a
(component_shape_aspect)
(component_terminal)
(component_interface_terminal)
(stratum_feature).
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'layout spacing requirement violation' THEN
SELF.relating_shape_aspect shall be a
(component_shape_aspect)
(component_terminal)
(component_interface_terminal)
(stratum_feature).
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'layout spacing requirement violation' THEN
SELF shall be the definition of exactly one group.name = 
'layout spacing requirements property'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="layout_spacing_requirement_occurrence_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The layout_spacing_requirement_occurrence_unique_constraint rule constrains
grouped_requirements_property population members, that fill the role of ARM
layout_spacing_requirement_occurrence, so that the combination of ARM
dependent_design_object_category and ARM reference_design_object_category
attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of grouped_requirements_property must have
a unique combination of characterized_object name attribute where the characterized_object
has a description of 'dependent design object category' and characterized_object name
attribute where the characterized_object has a description of 'reference design object category'
and the characterized_objects are members of an applied_group_assignment's items.definition
and the applied_group_assignment's assigned_group is the grouped_requirements_property.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="limit_dimension_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The limit_dimension_representation_constraint rule constrains the use of a shape_dimension_representation when it is used as a limit dimension representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'upper value' shall contain exactly two measure_with_unit in which the second measure_with_unit is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'lower value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'lower value' shall contain exactly two measure_with_unit in which the second measure_with_unit is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'upper value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_dimension_representation that contains two measure_with_unit that are the qualified_measure of two measure_qualification that have the name of 'dimension value qualifier' and in which the qualifiers are type_qualifier with the name of 'lower value' and 'upper value' shall have the measure_with_unit that is qualified as the 'upper value' to be greater than the measure_with_unit qualified as the 'lower value'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="located_interconnect_module_thickness_requirement_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The located_interconnect_module_thickness_requirement_unique_constraint rule constrains the
property_definition_representation population members, that fill the role of ARM
located_interconnect_module_thickness_requirement, so that the combination of ARM design
and ARM reference_location attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of property_definition_representation with a definition.name
of `located interconnect module thickness' must have a unique combination of
definition.definition.of_shape.definition attributes and axis_placement_2d,
axis_placement_3d entities where the axis_placements are in the items of
a representation that is related to the property_definition_representation's
used_representation attribute through a representation_relationship with a
name of 'reference location'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="marking_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The marking_constraint rule constrains the usage of a representation when it
is a marking.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE marking_constraint FOR ( representation );
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       ((rep\representation.name = 'marking')
       AND (SIZEOF(QUERY(pdr <* USEDIN(rep,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition)))) > 0))
       AND NOT (SIZEOF(QUERY(place <* rep.items |
       (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PLACEMENT' IN TYPEOF (place))
       AND (place\representation_item.name = 'marking location'))
       )) = 1)
       )) = 0;
END_RULE; -- marking_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall have exactly one items that is a 
placement\representation_item.name = 'marking location'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall be the used_representation on one property_definition_representation
whose definition
({is a pca_definition} 
 {has a formation.of_product that is a product of a product_categorization.name
  = 'assembly module'} 
 {has a frame_of_reference that is an application_context_element.name = 
  'physical design'})
({is a pcb_definition} 
 {has a formation.of_product that is a product of a product_categorization.name
  = 'interconnect module'} 
 {has a frame_of_reference that is an application_context_element.name = 
  'physical design'})
({is a (packaged_part) (externally_defined_packaged_part) 
  (library_defined_packaged_part)} 
 {has a frame_of_reference that is an application_context_element.name = 
  'physical design usage'}).
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall have exactly one items that is a 
descriptive_representation_item.name = ('approval date') ('manufacturers code')
('part number') ('revision identifier') ('marked message').
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} 
{is the used_representation of a property_definition_representation.definition 
that is a shape_aspect} 
{SELF.items[i] is a descriptive_representation_item.name = 'marked message'} 
THEN the value of descriptive_representation_item.description shall be 
identical to document_usage_constraint.subject_element_value.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} 
{is the used_representation of a property_definition_representation.definition 
that is a shape_aspect} THEN the shape_aspect shall be the 
designation.definitions[i] of a material_designation_relationship.description =
'marking material'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall be an items in a document_reference whose assigned_document 
{is a ee_specification} 
{whose source is a document_usage_constraint.subject_element = 
'marking specification'}
</Informal.propositions.rul>
<Informal.propositions.rul>
IF representation {SELF.name = 'marking'} {is the used_representation of a 
property_definition_representation.definition that is a shape_aspect} THEN 
SELF shall have exactly one items that is a 
(text_literal\representation_item.name = 'marking text') 
(annotation_text_occurrence\representation_item.name = 'marking text').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="material_composition_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The material_composition_relationship_constraint rule constrains the related
and relating product_definition of a product_material_composition_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A product_material_composition_relationship shall have a 
related_product_definition that is the of_definition of a material_designation.
</Informal.propositions.rul>
<Informal.propositions.rul>
A product_material_composition_relationship shall have a 
relating_product_definition that is the of_definition of a material_designation.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="mating_connector_placement_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The mating_connector_placement_relationship_constraint rule constrains the use
of a shape_representation when it is a mating connector placement.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE mating_connector_placement_relationship_constraint FOR
( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'mating connector placement')
       AND (SIZEOF(QUERY(p <* sr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PLACEMENT' IN TYPEOF(p))
       AND (p\representation_item.name = 'connector placement'))) = 0))) = 0;
END_RULE; -- mating_connector_placement_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_representation\representation.name = 'mating connector placement' 
THEN items[i] shall be a placement.name = 'connector placement'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_representation\representation.name = 'mating connector placement' 
THEN SELF shall be one items.mapping_source.mapped_representation of a 
shape_representation.name = 'volume shape' that is the used_representation 
of a property_definition_representation that has a definition.definition
that is a specified_higher_usage_occurrence that has a 
relating_product_definition that is a component_definition.description = 
'mating connector'.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF shape_representation\representation.name = 'mating connector placement' 
THEN SELF shall be the used_representation of a 
property_definition_representation that has a definition.definition that 
is a component_definition.description = 'mating connector'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="mating_connector_termination_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The mating_connector_termination_constraint rule constrains the of_shape
and use of a shape_aspect when it is a mating connector termination.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect.description = 'mating connector termination' THEN 
SELF.of_shape shall be a property_definition whose definition is a 
component_definition with a description = 'mating connector'.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF shape_aspect.description = 'mating connector termination' THEN SELF 
shall be the related_shape_aspect of a shape_aspect_relationship 
{whose name = 'instantiated terminal'} 
{whose relating_shape_aspect is (a packaged_part_terminal) 
(a printed_part_template_terminal whose description = 
 ('interface terminal') 
 ('join terminal'))}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="mating_connector_termination_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The mating_connector_termination_unique_constraint rule constrains the
shape_aspect population members, that fill the role of ARM
mating_connector_termination, so that the combination of ARM definition
and ARM accessed_connector attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of 'mating connector termination'
must have a unique combination of of_shape.definition attribute and
packaged_part_terminal entity related to the shape_aspect by a
shape_aspect_relationship with a name of 'instantiated terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="model_parameter_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The model_parameter_unique_constraint rule constrains the model_parameter
population members, that fill the role of ARM model_parameter, so that the
combination of ARM type_name and ARM reference_document attributes shall
be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE model_parameter_unique_constraint FOR
 ( model_parameter );
LOCAL
  name_bag : BAG OF STRING := [];
  mp_bag : BAG OF model_parameter;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  d_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(model_parameter) by 1;
  IF EXISTS( model_parameter[i]\representation_item.name ) THEN
    IF( NOT( model_parameter[i]\representation_item.name IN name_bag ) ) THEN
      name_bag := name_bag + model_parameter[i]\representation_item.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  mp_bag := QUERY( mp <* model_parameter | (mp\representation_item.name = name_bag[i]) );
  d_bag := [];
  REPEAT j := 1 to SIZEOF(mp_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := USEDIN( mp_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN d_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          d_bag := d_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- model_parameter_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of model_parameter must have a unique combination of name
attribute and document entity assigned to the model_parameter by an
applied_document_reference's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="next_higher_assembly_interface_requirement_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The next_higher_assembly_interface_requirement_constraint rule constrains the
use of a specified_higher_usage_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE next_higher_assembly_interface_requirement_constraint FOR 
( specified_higher_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(shuo <* specified_higher_usage_occurrence |
       NOT(SIZEOF(QUERY(pd <* USEDIN(shuo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))
       AND (pdr.used_representation\representation.name = '3d bound volume shape'))) = 0)
       )) = 0)
       )) = 0;
END_RULE; -- next_higher_assembly_interface_requirement_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each specified_higher_usage_occurrence shall be the definition.definition of a 
property_definition_representation that has a used_representation that
is a shape_representation.name = '3d bound volume shape'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="next_higher_assembly_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The next_higher_assembly_relationship_constraint rule constrains the use of
a next_assembly_usage_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
RULE next_higher_assembly_relationship_constraint FOR
( next_assembly_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(nauo <* next_assembly_usage_occurrence|
       NOT(SIZEOF(QUERY(pd <* USEDIN(nauo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION.DEFINITION') |
       ((SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))
       AND 
       (pdr.used_representation.context_of_items\geometric_representation_context.
       coordinate_space_dimension = 3)
       )) <= 1)
       AND
       (SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') |
        ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))
       AND 
       (pdr.used_representation.context_of_items\geometric_representation_context.
       coordinate_space_dimension = 2)
       )) <= 1))
       )) <= 1)
       )) = 0;
END_RULE; -- next_higher_assembly_relationship_constraint
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each next_assembly_usage_occurrence shall be the definition of not more than one property_definition which is the definition of not more than two property_definition_representation each of whose used_representation is a component_location which shall have either a 2 or 3d context, but there shall be no more than one of each context.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each next_assembly_usage_occurrence shall not be in a complex instance with both a quantity and a reference designation.
Each next_assembly_usage_occurrence shall have either a quantity or a reference designation,
which may require population of a complex instance of the supertype tree of next_assembly_usage_occurrence. 
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="next_higher_assembly_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The next_higher_assembly_relationship_unique_constraint rule constrains the
next_assembly_usage_occurrence population members, that fill the role of ARM
next_higher_assembly_relationship, so that the combination of ARM reference_designation
and the ARM assembly attribute inherited from the supertype
Assembly_composition_relationship shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE next_higher_assembly_relationship_unique_constraint FOR
 ( next_assembly_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  nauo_bag : BAG OF next_assembly_usage_occurrence;
  pass : BOOLEAN := TRUE;
  refdes_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(next_assembly_usage_occurrence) by 1;
  IF EXISTS( next_assembly_usage_occurrence[i].relating_product_definition )
                                                               THEN
    IF( 
(next_assembly_usage_occurrence[i].
                relating_product_definition.frame_of_reference.name 
                                                  = 'physical design')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' 
     IN TYPEOF(next_assembly_usage_occurrence[i].
                                relating_product_definition)) ) THEN
      IF ( NOT ( next_assembly_usage_occurrence[i].
                                  relating_product_definition 
                                              IN pu_bag )) THEN
        pu_bag := pu_bag + 
             next_assembly_usage_occurrence[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  refdes_bag := [];
  nauo_bag := QUERY( nauo <* next_assembly_usage_occurrence | 
                  (nauo.relating_product_definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(nauo_bag) by 1;
    IF EXISTS( nauo_bag[j].reference_designator ) THEN
      IF ( nauo_bag[j].reference_designator IN refdes_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        refdes_bag := refdes_bag + nauo_bag[j].reference_designator;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- next_higher_assembly_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of next_assembly_usage_occurrence that has a common
relating_prooduct_definition must have a unique reference_designator.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="no_shape_for_make_from">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The no_shape_for_make_from rule assures that for each instance
of make_from_usage_option, that a member of product_definition_shape
shall not be a part of it's property_definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE no_shape_for_make_from FOR
  (make_from_usage_option);
WHERE
  WR1: SIZEOF (QUERY (mfuo <* make_from_usage_option |
       NOT (SIZEOF (QUERY (pd <* USEDIN (mfuo, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PROPERTY_DEFINITION.DEFINITION') |
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE' IN 
       TYPEOF (pd))) = 0))) = 0;
END_RULE; -- no_shape_for_make_from
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
No design_make_from_relationship entities shall be referenced by the
definition attribute of a property_definition that is a
product_definition_shape.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="non_feature_shape_element_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The non_feature_shape_element_constraint rule constrains
the use of a shape_aspect when it is used to implement the ARM 
concept of Non_feature_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<informal.propositions rule.types="IP"> 
<informal.propositions.rul>
Each shape_aspect that does not define a product shall be
a characterized_definition that is the definition of
a property_definition that is the definition of a 
property_definition_representation that has
a used_representation that is a shape_representation
with a name of 'element shape'.
</informal.propositions.rul>
</informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="operational_requirement_occurrence_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The operational_requirement_occurrence_relationship_constraint rule constrains
the related and relating property_definition of a 
property_definition_relationship when it is an
operational_requirement_occurrence_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each property_definition_relationship whose name = ('and operation') 
('or operation') shall have a related_property_definition that is a 
requirements_property.
</formal.propositions.rul>
<formal.propositions.rul>
Each property_definition_relationship whose name = ('and operation') 
('or operation') shall have a relating_property_definition that is a 
requirements_property.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each property_definition_relationship whose name = ('and operation') 
('or operation') shall relate two property_definition each of which
shall have one property_definition_relationship whose 
name is 'requirements property composition' and the two 
property_definition_relationship shall relate to the
same property_definition that is a requirements_property as the composition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="opposing_boundary_set_size_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The opposing_boundary_set_size_characteristic_constraint rule constrains the use of a representation when it is used as an opposing boundary set size characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation with a name of 'opposing boundary set size' shall represent at least one property_definition that has a description of 'boundary zone definition with specified size' and that property_definition shall be applied to either a tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="organization_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The organization_unique_constraint rule constrains the organization.id population members to satisfy the uniqueness requirement of the ARM application object Organization.
</RULE.DESCRIPTION>

<EXPRESS.CODE>
*)

RULE organization_unique_constraint FOR (organization);

LOCAL
  r : BAG OF organization := QUERY (r <* organization | TRUE);
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF string := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF (r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF (r[i]\organization.id IN id_bag) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;

WHERE
WR1 : pass;
END_RULE; -- organization_unique_constraint

(*
</EXPRESS.CODE>

<Formal.propositions rule.types="WR">
<Formal.propositions.rul>

The id shall be unique within a population of organization.

</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="origin_constraint">
<RULE.DESCRIPTION>
The origin_constraint rule assures that each instance of representation_item that has a name of 'origin' has the properties required of an axis_placement at an origin including location and orientation.
The uncertainty in the equality expressions used in this rule shall be determined by the uncertainty length dimensions of the axes in the cartesian_coordinate_system in which the origin is founded.
An application that evaluates a data set according to this rule shall consider the data set in compliance with the rule if the values are within one value of uncertainty to the values specified in this rule.  The requirement to not populate the ref_direction and axis are designed to reduce error propagation.  
<example>
An equality constraint of 0.0 is equivalent to specifying 0.0 +/- epsilon where epsilon is the value of uncertainty.
</example>

</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE origin_constraint FOR (placement);
LOCAL
 origin_2d : SET OF axis2_placement_2d := QUERY(pl <* placement | ((pl\representation_item.name = 'origin') AND 
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_2D' IN TYPEOF(pl))));
 origin_3d : SET OF axis2_placement_3d := QUERY(pl <* placement | ((pl\representation_item.name = 'origin') AND 
    ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.AXIS2_PLACEMENT_3D' IN TYPEOF(pl))));
pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(origin_2d) by 1;
  IF (NOT pass) THEN ESCAPE; END_IF;
  IF (NOT((origin_2d[i].location.coordinates[1] = 0.0) AND
   (origin_2d[i].location.coordinates[2] = 0.0) AND
   NOT EXISTS(origin_2d[i].ref_direction)))
  THEN
   pass := FALSE;
  END_IF;
END_REPEAT;
REPEAT i := 1 to SIZEOF(origin_3d) by 1;
  IF (NOT pass) THEN ESCAPE; END_IF;
  IF NOT(
   (origin_3d[i].location.coordinates[1] = 0.0) AND
   (origin_3d[i].location.coordinates[2] = 0.0) AND
   (origin_3d[i].location.coordinates[3] = 0.0) AND
   (NOT(EXISTS(origin_3d[i].ref_direction))) AND 
   (NOT(EXISTS(origin_3d[i].axis)))
   )
  THEN
   pass := FALSE;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass; 
END_RULE; -- origin_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each placement that contains the attribute value 'origin' the placement shall be either an axis2_placement_2d or an axis2_placement_3d, and the properties shall be such that the placement is congruent with the origin of the coordinate system and axes congruent with the corresponding coordinate system axes.
<note>
coordinate system origin is implicit.  Including an origin provides an explicit reference.
</note>
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="package_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_external_reference_constraint rule constrains the use of a representation when it is used as a package external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_external_reference_constraint FOR
  (representation);
WHERE
   WR1: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'design owner')))) = 1)))=0;
   WR2: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'part number')))) = 1)))=0;
   WR3: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'revision code')))) = 1)))=0;
   WR4: SIZEOF (QUERY (rep <* representation |
        (rep\representation.name = 'package external reference') AND 
        (SIZEOF (QUERY (dri <* rep.items |
        NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
        (dri\representation_item.name = 'product definition id')))) = 1)))=0;
END_RULE; -- package_external_reference_constraint
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'design owner'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'part number'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'revision code'.
</FORMAL.PROPOSITIONS.RUL>
<FORMAL.PROPOSITIONS.RUL>
Each representation with a name of 'package external reference'
shall contain a descriptive_representation_item with a name of 'product definition id'.
</FORMAL.PROPOSITIONS.RUL>
</FORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="package_terminal_external_reference_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_terminal_external_reference_constraint rule constrains the use of a
descriptive_representation_item when it is used as a package terminal external reference.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_terminal_external_reference_constraint FOR
  (descriptive_representation_item);
WHERE
  WR1: SIZEOF(QUERY(dri <* descriptive_representation_item |
       (dri\representation_item.name = 'package terminal external reference')
       AND (SIZEOF(QUERY(rep <* USEDIN(dri,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'REPRESENTATION.ITEMS') |
       (rep\representation.name = 'package external reference'))) = 0)
       )) = 0;
END_RULE; -- package_terminal_external_reference_constraint
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each descriptive_representation_item with a name of 'package terminal external reference'
shall be a member of items for a representation with a name of 'package external reference'.
</FORMAL.PROPOSITIONS.RUL>

</FORMAL.PROPOSITIONS>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="package_terminal_external_reference_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_terminal_external_reference_unique_constraint rule constrains the
descriptive_representation_item population members, that fill the role of ARM
package_terminal_external_reference, so that the combination of ARM name
and ARM associated_definition attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_terminal_external_reference_unique_constraint FOR
 ( descriptive_representation_item );
LOCAL
  pter : BAG OF descriptive_representation_item := 
                QUERY( dri <* descriptive_representation_item
| (dri\representation_item.name = 'package terminal external reference') );
  desc_bag : BAG OF STRING := [];
  dri_bag : BAG OF descriptive_representation_item;
  rep_bag : BAG OF representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  IF EXISTS( pter[i]\descriptive_representation_item.description ) THEN
    IF ( NOT ( pter[i]\descriptive_representation_item.description IN desc_bag )) THEN
      desc_bag := desc_bag + pter[i]\descriptive_representation_item.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(desc_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  r_bag := [];
  dri_bag := QUERY( dri <* pter | (dri\descriptive_representation_item.description = desc_bag[i]) );
  REPEAT j := 1 to SIZEOF(dri_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    rep_bag := QUERY( r <* USEDIN( dri_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'REPRESENTATION.ITEMS' ) | (r\representation.name = 'package external reference') );
    REPEAT k := 1 to SIZEOF(rep_bag) by 1;
      IF EXISTS( rep_bag[k] ) THEN
        IF ( rep_bag[k] IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + rep_bag[k];
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- package_terminal_external_reference_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of descriptive_representation_item with a name of
'package terminal external reference' must have a unique combination of
description attributes and representation entities where the representations
have the descriptive_representation_items in their items attribute and the
representations have a name of 'package external reference'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="package_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The package_unique_constraint rule constrains the package population members, that
fill the role of ARM package, to have unique members in their ARM case_style attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE package_unique_constraint FOR
 ( package); --, externally_defined_package, library_defined_package );
LOCAL
  p : BAG OF physical_unit := QUERY( r <* package |
(r.frame_of_reference.name = 'physical design usage') );
(**  edp : BAG OF physical_unit := QUERY( r <* externally_defined_package |
(r.frame_of_reference.name = 'physical design usage') );
  ldp : BAG OF physical_unit := QUERY( r <* library_defined_package |
(r.frame_of_reference.name = 'physical design usage') ); *)
  pu : BAG OF physical_unit;
  pd_bag : BAG OF property_definition;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  r_bag : BAG OF representation := [];
END_LOCAL;

pu := p + edp + ldp;

REPEAT i := 1 to SIZEOF(pu) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pd_bag := USEDIN( pu[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION' );
  REPEAT j := 1 to SIZEOF(pd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pdr_bag := QUERY( pdr <* USEDIN( pd_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | 
(pdr.used_representation\representation.name =
'registered case style') );
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
      IF EXISTS( pdr_bag[k].used_representation ) THEN
        IF ( pdr_bag[k].used_representation IN r_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          r_bag := r_bag + pdr_bag[k].used_representation;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- package_unique_constraint 
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of package must have unique representation entities related
to the package where the representation has a name of 'registered case style'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="packaged_connector_terminal_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The packaged_connector_terminal_relationship_unique_constraint rule constrains the
packaged_connector_terminal_relationship population members, that fill the role of
ARM packaged_connector_terminal_relationship, to have unique combinations of ARM
connector and ARM join_terminal attributes and to have unique combinations of ARM
connector and ARM interface_terminal attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE packaged_connector_terminal_relationship_unique_constraint FOR
 ( packaged_connector_terminal_relationship );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  pctr_bag : BAG OF packaged_connector_terminal_relationship;
  it_bag : BAG OF packaged_part_terminal;
  jt_bag : BAG OF packaged_part_terminal;
  pass1 : BOOLEAN := TRUE;
  pass2 : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(packaged_connector_terminal_relationship) by 1;
  IF EXISTS( packaged_connector_terminal_relationship[i].
                               of_shape.definition ) THEN
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' 
   IN TYPEOF(packaged_connector_terminal_relationship[i].
                               of_shape.definition) ) THEN
      IF ( NOT ( packaged_connector_terminal_relationship[i].
                               of_shape.definition 
                                           IN pu_bag )) THEN
        pu_bag := pu_bag + 
    packaged_connector_terminal_relationship[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
  END_IF;
  it_bag := [];
  jt_bag := [];
  pctr_bag := QUERY( r <* packaged_connector_terminal_relationship | 
                            (r.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pctr_bag) by 1;
    IF ( NOT (pass1 OR pass2) ) THEN ESCAPE;
    END_IF;
    IF ( pass1 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].relating_shape_aspect))
AND (pctr_bag[j].relating_shape_aspect\shape_aspect.description = 'join terminal') ) THEN
      IF EXISTS( pctr_bag[j].relating_shape_aspect ) THEN
        IF ( pctr_bag[j].relating_shape_aspect IN jt_bag ) THEN
          pass1 := FALSE;
          ESCAPE;
        ELSE
          jt_bag := jt_bag + pctr_bag[j].relating_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
    IF ( pass2 AND (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART_TERMINAL' IN TYPEOF(pctr_bag[j].related_shape_aspect))
AND (pctr_bag[j].related_shape_aspect\shape_aspect.description = 
'interface terminal') ) THEN
      IF EXISTS( pctr_bag[j].related_shape_aspect ) THEN
        IF ( pctr_bag[j].related_shape_aspect IN it_bag ) THEN
          pass2 := FALSE;
          ESCAPE;
        ELSE
          it_bag := it_bag + pctr_bag[j].related_shape_aspect;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass1;
  WR2: pass2;
END_RULE; -- packaged_connector_terminal_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of packaged_connector_terminal_relationship that references a common
physical_unit through an of_shape.definition attribute must have unique related_shape_aspect
attributes that point to packaged_part_terminal entities with a description of 'join terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of packaged_connector_terminal_relationship that references a common
physical_unit through an of_shape.definition attribute must have unique relating_shape_aspect
attributes that point to packaged_part_terminal entities with a description of 'interface terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="packaged_part_unique_constraint">
<RULE.DESCRIPTION>
The packaged_part_unique_constraint rule constrains the packaged_part,
externally_defined_packaged_part and library_defined_packaged_part population members, that
fill the role of ARM packaged_part, so the ARM used_package.version shall be unique within a population of ARM Packaged_part.  This constraint enforces a single used_package.version for any given Packaged_part even though there are multiple packages.
<note>
The uniqueness constraint is divided between this construct and the the constraint on implemented function cardinality implemented in the packaged_part entity.
</note>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE packaged_part_unique_constraint FOR
 ( packaged_part); --, externally_defined_packaged_part, library_defined_packaged_part);
LOCAL
  pp : SET OF physical_unit := packaged_part; -- + externally_defined_packaged_part + library_defined_packaged_part;
  pdr_bag : BAG OF product_definition_relationship;
  pdf_bag : BAG OF product_definition_formation := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pp) by 1;
  IF ( NOT pass ) THEN ESCAPE; END_IF;
    pdf_bag := [];
    pdr_bag := QUERY( pdr <* USEDIN( pp[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | 
((pdr\product_definition_relationship.name = 'used package')
AND (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGE' IN TYPEOF(pdr.relating_product_definition)) (** OR
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EXTERNALLY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition)) OR
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'LIBRARY_DEFINED_PACKAGE' IN TYPEOF(pdr.relating_product_definition))  *)
) ) );
    pdf_bag := pdf_bag + pdr_bag[1].relating_product_definition.formation;
    REPEAT k := 1 to SIZEOF(pdr_bag) by 1;
     IF ( NOT pass ) THEN ESCAPE; END_IF;
      IF EXISTS( pdr_bag[k].relating_product_definition.formation ) THEN
        IF NOT( pdr_bag[k].relating_product_definition.formation IN pdf_bag ) THEN
          pass := FALSE;
        END_IF;
      END_IF;
    END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- packaged_part_unique_constraint 
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of packaged_part, externally_defined_packaged_part and library_defined_packaged_part
must have a single product_definition_formation of package related by a 'used package' relationship.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="parallel_shape_element_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The parallel_shape_element_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a parallel shape element relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'parallel' shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are parallel to themselves either directly or through intermediate shape_aspect_relationship with a name of 'parallel'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_constraint rule constrains the use of a 
product_definition_relationship when it is used as a part_device.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship which has a related_product_definition 
{which is a (bare_die) (externally_defined_bare_die) (library_defined_bare_die)}
{which has a frame_of_reference which is an application_context_element.name = 
 'physical design usage'} shall have 
{a SELF.description = 'part device'} 
{a relating_product_definition 
 {which is a (packaged_part) (externally_defined_packaged_part) 
  (library_defined_packaged_part)} 
 {which has a frame_of_reference which is an application_context_element.name = 
  'physical design usage'}}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship which has a related_product_definition 
{which is a (bare_die) (externally_defined_bare_die) (library_defined_bare_die)}
{which has a frame_of_reference which is an application_context_element.name = 
 'physical design usage'} shall 
{have a SELF.description = 'part device'} 
{be the definition of at most one property_definition_representation whose 
 used_representation 
 {has an items which is a mapped_item} 
 {has a name = 'planar projected shape'}}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship which has a related_product_definition 
{which is a (bare_die) (externally_defined_bare_die) (library_defined_bare_die)}
{which has a frame_of_reference which is an application_context_element.name = 
 'physical design usage'} shall 
{have a SELF.description = 'part device'} 
{be the definition of at most one property_definition_representation whose 
 used_representation 
 {has an items which is a mapped_item} 
 {has a name = '3d bound volume shape'}}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_terminal_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_terminal_constraint rule constrains the 
related_product_definition of a product_definition_relationship when it is a
part_device_terminal.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF a shape_aspect is the of_shape of a property_definition whose definition 
is a product_definition_relationship.description = 'part device' 
THEN the product_definition_relationship.related_product_definition shall 
be the of_shape.definition of a minimally_defined_bare_die_terminal.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_terminal_model_port_assignment_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_terminal_model_port_assignment_unique_constraint rule
constrains property_definition_representation population members, that
fill the role of ARM part_device_terminal_model_port_assignment, so
that the combination of ARM internal_connection and ARM internal_port
shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_device_terminal_model_port_assignment_unique_constraint FOR
 ( property_definition_representation );
LOCAL
  amp_bag : BAG OF analytical_model_port := [];
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  sa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(property_definition_representation) by 1;
  IF EXISTS( property_definition_representation[i].used_representation )
                                                            THEN
    IF( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ANALYTICAL_MODEL_PORT' IN TYPEOF(
property_definition_representation[i].used_representation) ) THEN
      IF( NOT( property_definition_representation[i].used_representation IN 
                                              amp_bag ) )
                                                               THEN
        amp_bag := amp_bag + 
              property_definition_representation[i].used_representation;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(amp_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sa_bag := [];
  pdr_bag := QUERY( pdr <* property_definition_representation | 
                            (pdr.used_representation :=: amp_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j].definition.definition ) THEN
      IF ( pdr_bag[j].definition.definition IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + pdr_bag[j].definition.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_device_terminal_model_port_assignment_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of property_definition_representation with a used_representation
attribute that references an analytical_model_port entity must have a unique
combination of used_representation and definition.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_terminal_unique_constraint rule constrains shape_aspect
population members, that fill the role of ARM part_device_terminal, so
that the combination of ARM terminated_device and ARM
used_bare_die_terminal shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_device_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  pdr_bag : BAG OF product_definition_relationship := [];
  sa_bag : BAG OF shape_aspect;
  pd_bag : BAG OF property_definition;
  sa : BAG OF bare_die_terminal;
  pass : BOOLEAN := TRUE;
  bdt_bag : BAG OF bare_die_terminal;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect) by 1;
  IF EXISTS( shape_aspect[i].of_shape.definition ) THEN
    IF( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP' IN 
TYPEOF(shape_aspect[i].of_shape.definition)) AND
(shape_aspect[i].of_shape.definition.description = 'part device') ) THEN
      IF( NOT( shape_aspect[i].of_shape.definition IN pdr_bag ) ) THEN
        pdr_bag := pdr_bag + shape_aspect[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  bdt_bag := [];
  sa_bag := QUERY( sa <* shape_aspect | (sa.of_shape.definition :=: 
                   pdr_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    pd_bag := QUERY( pd <* USEDIN(
sa_bag[j].of_shape.definition.related_product_definition,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION.DEFINITION') | (SIZEOF([
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'BARE_DIE'
-- ,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_BARE_DIE',
-- 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_BARE_DIE'
] * TYPEOF(pd.definition))>0) );
    REPEAT k := 1 to SIZEOF(pd_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      sa := QUERY( bdt <* USEDIN(pd_bag[k],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'SHAPE_ASPECT.OF_SHAPE') |
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'BARE_DIE_TERMINAL' IN TYPEOF(bdt)) );
      REPEAT l := 1 to SIZEOF(sa) by 1;
        IF EXISTS( sa[l] ) THEN
          IF ( sa[l] IN bdt_bag ) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            bdt_bag := bdt_bag + sa[l];
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_device_terminal_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect that has an
of_shape.definition.description of 'part device' shall have
a unique combination of of_shape.definition attribute and
bare_die_terminal entity where the bare_die_terminal's
of_shape.definition attribute references the same instance as
that referenced by the path through of_shape, definition, related_product_definition starting
at the shape_aspect instance.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_device_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_device_unique_constraint rule constrains product_definition_relationship
population members, that fill the role of ARM part_device, so that the
combination of ARM defined_packaged_part and ARM item_identification shall be
unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_device_unique_constraint FOR
 ( product_definition_relationship );
LOCAL
  pd : BAG OF product_definition_relationship := QUERY( pdr <*
product_definition_relationship | (pdr\product_definition_relationship.description = 'part device') );
  pu_bag : BAG OF physical_unit := [];
  pdr_bag : BAG OF product_definition_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pd) by 1;
  IF EXISTS( pd[i].relating_product_definition ) THEN
    IF( (pd[i].relating_product_definition.frame_of_reference.name =
'physical design usage') AND (SIZEOF(
['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PACKAGED_PART'
-- ,'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EXTERNALLY_DEFINED_PACKAGED_PART',
-- 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'LIBRARY_DEFINED_PACKAGED_PART'
] * 
TYPEOF(pd[i].relating_product_definition))>0) ) THEN
      IF( NOT( pd[i].relating_product_definition IN pu_bag ) ) THEN
        pu_bag := pu_bag + pd[i].relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  pdr_bag := QUERY( pdr <* pd | (pdr.relating_product_definition :=: 
                                                       pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(pdr_bag) by 1;
    IF EXISTS( pdr_bag[j]\product_definition_relationship.name ) THEN
      IF ( pdr_bag[j]\product_definition_relationship.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + pdr_bag[j]\product_definition_relationship.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_device_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_relationship with a description of
'part device' must have a unique combination of name and
relating_product_definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_feature_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_feature_constraint rule constrains the identification of a shape_aspect when it is used as an implementation of the ARM object Part_feature.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_feature_constraint FOR
  (shape_aspect, product_definition, shape_aspect_relationship);
LOCAL
pass : BOOLEAN := TRUE;
name_bag : BAG OF STRING := [];
sa : BAG OF shape_aspect := [];
pd : BAG OF product_definition := QUERY ( pd <* product_definition |
       pd.frame_of_reference\application_context_element.name
       = 'physical design usage');
END_LOCAL;
 REPEAT i := 1 to SIZEOF (pd) by 1;
name_bag := [];
sa := QUERY ( sa <* shape_aspect | (
(sa.of_shape\property_definition.definition = pd[i]) AND
(sa.product_definitional) AND
(NOT (sa\shape_aspect.description = 'connection zone'))
));
  REPEAT j := 1 to SIZEOF (sa) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
 IF sa[j]\shape_aspect.name in name_bag THEN pass := FALSE;
 ELSE
  name_bag := name_bag + sa[j]\shape_aspect.name;
 END_IF;
  END_REPEAT;
 END_REPEAT;
WHERE
 WR1: pass;
 WR2: SIZEOF(QUERY(sar <* shape_aspect_relationship |
      (sar\shape_aspect_relationship.name = 'precedent feature') AND
      (sar.related_shape_aspect = sar.relating_shape_aspect))) = 0;
 WR3: SIZEOF(QUERY(sa <* shape_aspect | 
      ((sa\shape_aspect.description = 'part group feature') OR
      (sa\shape_aspect.description = 'part generic feature') OR
      (sa\shape_aspect.description = 'polarity indication feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 1))) = 0;
 WR4: SIZEOF(QUERY(sa <* shape_aspect |
      ((sa\shape_aspect.description = 'interconnect module edge segment surface') OR
      (sa\shape_aspect.description = 'interconnect module cavity surface') OR
      (sa\shape_aspect.description = 'interconnect module cutout surface') OR
      (sa\shape_aspect.description = 'interconnect module edge surface') OR
      (sa\shape_aspect.description = 'interconnect module primary surface') OR
      (sa\shape_aspect.description = 'interconnect module secondary surface') OR
      (sa\shape_aspect.description = 'interconnect module surface feature'))
      AND (SIZEOF(QUERY(sar <* USEDIN(sa,
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
     'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT') |
      sar\shape_aspect_relationship.name = 'precedent feature')
      ) > 0))) = 0;
END_RULE; -- part_feature_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">

<formal.propositions.rul>
Each shape_aspect that is product_definitional and that is not a connection zone and that is for a product_definition with a frame_of_reference that is an application_context_element
with a name of 'physical design usage' shall be uniquely identifiable using shape_aspect name attribute within the context of that product_definition. 
<note>
This implies that the shape_aspect.name is not necessarily unique within the entire product model or exchange file.
Reference shape_element_constraint, connection_zone_constraint, and physical_unit for related constraints.
</note>
</formal.propositions.rul>

<formal.propositions.rul>
Each shape_aspect_relationship with a name of 'precedent feature'
shall not have a related_shape_aspect that is the same
has its relating_shape_aspect.
</formal.propositions.rul>

<formal.propositions.rul>
Each shape_aspect with a description of
'part group feature' or
'part generic feature' or
'polarity indication feature' or
shall the related_shape_aspect for at most 
one shape_aspect_relationship with a name of 'precedent feature'.
</formal.propositions.rul>

<formal.propositions.rul>
Each shape_aspect with a description of
'interconnect module cavity surface' or
'interconnect module cutout surface' or
'interconnect module edge segment surface' or
'interconnect module edge surface' or
'interconnect module primary surface' or
'interconnect module secondary surface' or
'interconnect module surface feature'
shall not be the related_shape_aspect for a shape_aspect_relationship with a name of 'precedent feature'.
</formal.propositions.rul>

</formal.propositions>

<informal.propositions rule.types="IP">
<informal.propositions.rul>
Each shape_aspect with a description of 'part generic feature' shall
implement the Part_feature ARM concept and none of the subtypes
or any other ARM concept that maps to shape_aspect.
</informal.propositions.rul>

<informal.propositions.rul>
Each shape_aspect with a description of
'part group feature' or
'part generic feature' or
'polarity indication feature' or
'interconnect module cavity surface' or
'interconnect module cutout surface' or
'interconnect module edge segment surface' or
'interconnect module edge surface' or
'interconnect module primary surface' or
'interconnect module secondary surface' or
'interconnect module surface feature'
shall implement the corresponding subtypes of the Part_feature ARM concept and no other subtypes
or any other ARM concept that maps to shape_aspect.
</informal.propositions.rul>

</informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_feature_unique_constraint">
<RULE.DESCRIPTION>
The part_feature_unique_constraint rule constrains the composite_shape_aspect,
shape_aspect, primary_orientation_feature, secondary_orientation_feature,
tertiary_orientation_feature,
package_body, part_tooling_feature, thermal_feature, part_mounting_feature,
package_terminal, assembly_module_terminal, bare_die_terminal,
interconnect_module_terminal, minimally_defined_bare_die_terminal,
packaged_part_terminal and package_body_surface population members, that fill
the role of ARM part_feature, so that the combination of ARM name and ARM
associated_definition attributes shall be unique within the population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_feature_unique_constraint FOR
 ( composite_shape_aspect, shape_aspect, primary_orientation_feature,
tertiary_orientation_feature,
secondary_orientation_feature, package_body, part_tooling_feature,
thermal_feature, part_mounting_feature, package_terminal,
assembly_module_terminal, bare_die_terminal, interconnect_module_terminal,
minimally_defined_bare_die_terminal, packaged_part_terminal, 
package_body_surface );
LOCAL
  csa : BAG OF shape_aspect := QUERY( r <* composite_shape_aspect |
(r\shape_aspect.description = 'part group feature') );
  sa : BAG OF shape_aspect := QUERY( r <* shape_aspect |
(r\shape_aspect.description IN ['part generic feature','polarity indication feature',
'interconnect module edge segment surface',
'interconnect module cavity surface',
'interconnect module cutout surface',
'interconnect module edge surface',
'interconnect module primary surface',
'interconnect module secondary surface',
'interconnect module surface feature']) );
  pof : BAG OF shape_aspect := QUERY( r <* 
                  primary_orientation_feature | (TRUE) );
  sof : BAG OF shape_aspect := QUERY( r <* 
                 secondary_orientation_feature | (TRUE) );
  tof : BAG OF shape_aspect := QUERY( r <* 
                 tertiary_orientation_feature | (TRUE) );
  pb : BAG OF shape_aspect := QUERY( r <* 
                                package_body | (TRUE) );
  ptf : BAG OF shape_aspect := QUERY( r <* part_tooling_feature | (TRUE) );
  tf : BAG OF shape_aspect := QUERY( r <* thermal_feature | (TRUE) );
  pmf : BAG OF shape_aspect := QUERY( r <* part_mounting_feature | (TRUE) );
  pt : BAG OF shape_aspect := QUERY( r <* package_terminal | (TRUE) );
  amt : BAG OF shape_aspect := QUERY( r <* 
                            assembly_module_terminal | (TRUE) );
  bdt : BAG OF shape_aspect := QUERY( r <* bare_die_terminal | (TRUE) );
  imt : BAG OF shape_aspect := QUERY( r <* 
                          interconnect_module_terminal | (TRUE) );
  mdbdt : BAG OF shape_aspect := QUERY( r <* 
                    minimally_defined_bare_die_terminal | (TRUE) );
  ppt : BAG OF shape_aspect := QUERY( r <* 
                                  packaged_part_terminal | (TRUE) );
  pbs : BAG OF shape_aspect := QUERY( r <* 
                                       package_body_surface | (TRUE) );
  pf : BAG OF shape_aspect := [];
  pu_bag : BAG OF physical_unit := [];
  sa_bag : BAG OF shape_aspect;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

sa := csa + sa + pof + sof +tof + pb + ptf + tf + pmf + 
          pt + amt + bdt + imt + mdbdt + ppt + pbs;
REPEAT i := 1 to SIZEOF(sa) by 1;
  IF EXISTS( sa[i] ) THEN
    IF ( NOT ( sa[i] IN pf )) THEN
      pf := pf + sa[i];
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pf) by 1;
  IF EXISTS( pf[i].of_shape.definition ) THEN
    IF ( (
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF(pf[i].of_shape.definition)) AND
(pf[i].of_shape.definition.frame_of_reference.name = 
'physical design usage') ) THEN
      IF ( NOT ( pf[i].of_shape.definition IN pu_bag )) THEN
        pu_bag := pu_bag + pf[i].of_shape.definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  name_bag := [];
  sa_bag := QUERY( sa <* pf | (sa.of_shape.definition :=: pu_bag[i]) );
  REPEAT j := 1 to SIZEOF(sa_bag) by 1;
    IF EXISTS( sa_bag[j]\shape_aspect.name ) THEN
      IF ( sa_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sa_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_feature_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of primary_orientation_feature, secondary_orientation_feature,
package_body, part_tooling_feature, thermal_feature, part_mounting_feature,
package_terminal, assembly_module_terminal, bare_die_terminal,
interconnect_module_terminal, minimally_defined_bare_die_terminal,
packaged_part_terminal, package_body_surface, composite_shape_aspect with a
description of 'part group feature', and shape_aspect with a description of
'part generic feature', 'polarity indication feature',
'interconnect module edge segment surface', 'interconnect module edge surface',
'interconnect module cavity surface', 'interconnect module cutout surface',
'interconnect module primary surface', 'interconnect module secondary surface',
'interconnect module surface feature' shall have a unique combination of name
and of_shape.definition attributes.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_template_non_planar_2d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_template_non_planar_2d_shape_constraint rule 
constrains manifold_surface_shape_representation
when it is used as a part template non planar 2d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_template_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'part template non planar 2d shape')
       AND NOT(SIZEOF(QUERY(a2p3d <* mssr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(a2p3d))
       )) = 1)
       )) = 0;
END_RULE; -- part_template_non_planar_2d_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall have exactly
one item that is a axis2_placement_3d.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall be the rep_1 for 
at most one representation_relationship with a rep_2 that is a
representation with a name of 'shape environment' with a 
item that is a descriptive_representation_item with a name 
of 'manufacturing' or 'end user application'.
</Informal.propositions.rul>

<Informal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall be the rep_1 for 
exactly one representation_relationship with a rep_2 that is a
representation with a name of 'shape material condition' with a 
item that is a descriptive_representation_item with a name 
of 'maximum material condition', 'minimum material condition',
or 'nominal material condition'.
</Informal.propositions.rul>

<Informal.propositions.rul>
A manifold_surface_shape_representation with a name of 
'part template non planar 2d shape' shall be the used_representation
for exactly one property_definition that shall also have a definition
that is a part_template_definition.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="part_template_planar_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_template_planar_shape_constraint rule constrains the items and the use
of a shape_representation when it is a part_template_planar_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation 
that is the used_representation of a property_definition_representation that 
has a definition.definition that is a part_template_definition 
shall have one items that 
{is a descriptive_representation_item} {has a name = 'shape material condition'}
{has a description = ('maximum material condition') 
('minimum material condition') ('nominal material condition')}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="part_terminal_external_reference_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The part_terminal_external_reference_unique_constraint rule constrains the
representation population members, that fill the role of ARM part_terminal_external_reference,
to have unique ARM associated_definition attributes with each ARM feature_name
attribute and ARM feature_type attribute combination.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE part_terminal_external_reference_unique_constraint FOR
 ( representation );
LOCAL
  pter : BAG OF representation := QUERY( r <* representation |
(r\representation.name = 'part terminal external reference'));
  fn_bag : BAG OF STRING := [];
  ft_bag : BAG OF STRING := [];
  r_bag : BAG OF representation;
  pdr_bag : BAG OF property_definition_representation;
  pass : BOOLEAN := TRUE;
  ptd_bag : BAG OF part_template_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pter) by 1;
  REPEAT j := 1 to SIZEOF(pter[i].items) by 1;
    IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'DESCRIPTIVE_REPRESENTATION_ITEM' IN 
TYPEOF(pter[i].items[j]) ) THEN
      IF ( (pter[i].items[j]\representation_item.name = 'feature name') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                                                  IN fn_bag )) ) THEN
        fn_bag := fn_bag + pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
      IF ( (pter[i].items[j]\representation_item.name = 'feature type') AND 
      (NOT ( pter[i].items[j]\descriptive_representation_item.description 
                 IN ft_bag )) ) THEN
        ft_bag := ft_bag + 
        pter[i].items[j]\descriptive_representation_item.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(fn_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  REPEAT j := 1 to SIZEOF(ft_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    r_bag := QUERY( r <* pter | ((SIZEOF(
QUERY(ri <* r.items | ((ri\descriptive_representation_item.description =
ft_bag[j]) AND (ri\representation_item.name = 'feature type')) ) )>0) AND 
(SIZEOF(QUERY(ri <* r.items |
((ri\descriptive_representation_item.description = fn_bag[i]) AND 
         (ri\representation_item.name = 'feature name')) ) )>0)) );
    ptd_bag := [];
    REPEAT k := 1 to SIZEOF(r_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      pdr_bag := USEDIN( r_bag[k], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION' );
      REPEAT l:= 1 to SIZEOF(pdr_bag) by 1;
        IF EXISTS( pdr_bag[l].definition.definition ) THEN
          IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PHYSICAL_UNIT' IN TYPEOF( pdr_bag[l].definition.definition ) ) THEN
            IF ( pdr_bag[l].definition.definition IN ptd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              ptd_bag := ptd_bag + pdr_bag[l].definition.definition;
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- part_terminal_external_reference_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of representation with a description of 'part terminal external reference'
that has a common pair of description attributes on descriptive_representation_items in
its set of items with name attributes of 'feature type' and 'feature name' must have 
unique physical_unit entities that are referenced by a property_definition_representation
definition.definition attribute and has one of said representations as the
property_definition_representation's used_representation attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="perpendicular_shape_element_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The perpendicular_shape_element_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a perpendicular shape element relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'perpendicular' shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are perpendicular to themselves either directly or through intermediate shape_aspect_relationship with a name of 'perpendicular'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="physical_connectivity_abstraction_map_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_connectivity_abstraction_map_unique_constraint rule constrains the
shape_aspect_relationship population members, that fill the role of ARM
physical_connectivity_abstraction_map, to have unique ARM geometric_context_based_definition
attributes with each ARM name_space_context_based_definition attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of
'physical to topological abstraction map' that references a common
physical_connectivity_element must reference a unique component_shape_aspect
with a description of either 'conductive interconnect element with pre defined transitions'
or 'conductive interconnect element with user defined single transition'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="physical_connectivity_definition_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_connectivity_definition_relationship_constraint rule constrains
the value of related and relating shape_aspect and the use of a
shape_aspect_relationship when it is a 
physical_connectivity_definition_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'physical connectivity definition change' 
THEN the related_shape_aspect shall be a physical_connectivity_definition.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'physical connectivity definition change' 
THEN the relating_shape_aspect shall be a physical_connectivity_definition.
</formal.propositions.rul>
<formal.propositions.rul>
Each shape_aspect_relationship which has a name = 'physical connectivity 
definition change' shall be the definition of one requirements_property.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="physical_connectivity_element_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_connectivity_element_unique_constraint rule constrains the
physical_connectivity_element population members, that fill the role of
ARM physical_connectivity_element, to be have unique ARM
connectivity_context attributes with each ARM name attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For every instance of physical_connectivity_element that has a common name
attribute that is referenced by a shape_aspect_relationship with a name
of 'structure element', the shape_aspect_relationships must have unique
relating_shape_aspect attribute values.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="physical_unit_3d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_unit_3d_shape_constraint rule constrains the items and the usage
of a shape_representation when it is a physical_unit_3d_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall be the 
used_representation of another property_definition_representation whose 
definition.definition is a physical_unit that has a frame_of_reference that 
is an application_context_element that has a name = ('physical design') 
('physical design usage').
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape environment' and that has a representation_item
with a name of 'manufacturing' or 'end user application'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape material condition' and that has a representation_item
with a name of 'maximum material condition' or
'minimum material condition' or 'nominal material condition'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
shall be related to one 
representation that has a name = 'externally defined shape purpose' 
or that has a name = 'predefined shape purpose'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
that is related to one 
representation that has a name = 'externally defined shape purpose' 
that shall have a representation_item that is an external_definition,
and that representation_item.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
that is related to one 
representation that has a name = 'predefined shape purpose' 
 shall have a representation_item
with a name of 'analysis' 
or 'shock analysis' 
or 'design'
or 'vibrational analysis'
or 'electromagnetic compatibility analysis'
or 'thermal analysis'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'} 
{with a coordinate_space_dimension = 3} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall have exactly 
one items that is a cartesian_point.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a physical_unit} shall be 
related through a 
property_definition_relationship {with a name = 'application technology constraint'}
to no more than one requirements_property, where the requirements_property is the relating_property_definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall
also be related to a package.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = '3d bound volume shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall
also be related to a package, where that package is referenced by the package_part as the 'used package'.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="physical_unit_planar_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_unit_planar_shape_constraint rule constrains the items and the usage
of a shape_representation when it is a physical_unit_planar_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall be the 
used_representation of another property_definition_representation whose 
definition.definition is a physical_unit that has a frame_of_reference that 
is an application_context_element that has a name = ('physical design') 
('physical design usage').
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape environment' and that has a representation_item
with a name of 'manufacturing' or 'end user application'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} 
shall be related to one 
representation that has a name = 'shape material condition' and that has a representation_item
with a name of 'maximum material condition' or
'minimum material condition' or 'nominal material condition'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
shall be related to one 
representation that has a name = 'predefined shape purpose' or that has a name
= 'externally defined purpose'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
and that is related to a
representation that has a name = 'predefined shape purpose' shall be related to a
representation that has a name = 'predefined shape purpose' where that
representation has a representation_item
with a name of 'design' or 'assembly symbol' or 'design profile'
or 'electromagnetic compatibility analysis'
or 'shock analysis'
or 'physical extent'
or 'thermal analysis'
or 'vibrational analysis'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit}
and that is related to a
representation that has a name = 'externally defined purpose' shall be related to a
representation that has a name = 'externally defined purpose' where that
representation has a representation_item
that is an external_definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall have exactly 
one items that is a cartesian_point.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'} 
{with a coordinate_space_dimension = 2} 
{that is the used_representation of a property_definition_representation that 
has a definition.definition that is a physical_unit} shall be the
used_representation of another property_definition_representation whose
definition is a requirements_property.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a physical_unit} shall be 
related through a 
property_definition_relationship {with a name = 'application technology constraint'}
to no more than one requirements_property, where the requirements_property is the relating_property_definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall 
also be related to a package.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_representation {with a name = 'planar projected shape'}
{that is the used_representation of a property_definition_representation that
has a definition.definition that is a packaged_part} shall
also be related to a package, where that package is referenced by the package_part as the 'used package'.
</Informal.propositions.rul>
</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="physical_unit_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The physical_unit_relationship_constraint rule constrains the 
related_product_definition of a product_definition_relationship when it is a
physical_unit_relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship that has a related_product_definition that
is a physical_unit with a frame_of_reference that is a 
product_definition_context.name = ('physical design') ('physical design usage')
shall have a related_product_definition that is a physical_unit with a 
frame_of_reference that is a product_definition_context.name = 
('physical design') ('physical design usage').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="placement_group_area_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The placement_group_area_assignment_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is a
placement_group_area_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'area impacted group' THEN related_shape_aspect 
shall be a mounting_restriction_area.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'area impacted group' THEN relating_shape_aspect
shall be (a group_shape_aspect) (a shape_aspect whose of_shape.definition 
is a group_product_definition whose frame_of_reference is a 
product_definition_context.name = 'design requirement').
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="placement_group_volume_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The placement_group_volume_assignment_constraint rule constrains the related
and relating shape_aspect of a shape_aspect_relationship when it is a
placement_group_volume_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'volume impacted group' THEN related_shape_aspect 
shall be a mounting_restriction_volume.
</formal.propositions.rul>
<formal.propositions.rul>
IF shape_aspect_relationship.name = 'volume impacted group' THEN relating_shape_aspect
shall be (a group_shape_aspect) (a shape_aspect whose of_shape.definition 
is a group_product_definition whose frame_of_reference is a 
product_definition_context.name = 'design requirement').
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="planar_curve_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The planar_curve_constraint rule constrains the dimensionality of a
shape_representation when it is only allowed to include planar curves.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE planar_curve_constraint FOR ( shape_representation );
WHERE
WR1: SIZEOF (QUERY (sr <* shape_representation | 
(
NOT(NOT ( sr\representation.name IN ['planar projected shape',
       'bevel edge feature shape',
       'step edge feature shape',
       'radius edge feature shape']) OR
(sr\representation.
context_of_items\geometric_representation_context.
coordinate_space_dimension = 2)
))
)) = 0;
END_RULE; -- planar_curve_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
If the name of a shape_representation is 'planar projected shape',
'bevel edge feature shape','step edge feature shape' or 
'radius edge feature shape' then dimensionality of the geometric
context shall be exactly 2.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="planned_effectivity_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The planned_effectivity_constraint rule constrains the usage of a
configuration_effectivity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE planned_effectivity_constraint FOR ( configuration_effectivity );
WHERE
  WR1: SIZEOF(QUERY(ce <* configuration_effectivity |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage))
       AND (ce.usage\product_definition_relationship.name = 'assembly composition'))
       )) = 0;
  WR2: SIZEOF(QUERY(ce <* configuration_effectivity |
       SIZEOF(USEDIN(ce,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS')) = 0 
       )) = 0;

END_RULE; -- planned_effectivity_constrain
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each configuration_effectivity shall have a usage that
is an assembly_component_usage with a name = 'assembly composition'.
</formal.propositions.rul>
<formal.propositions.rul>
Each configuration_effectivity shall be an items in an 
applied_approval_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="planned_effectivity_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The planned_effectivity_unique_constraint rule constrains the configuration_effectivity population
members, that fill the role of ARM planned_effectivity, to be have unique ARM effective_assembly
entities on each ARM configuration entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE planned_effectivity_unique_constraint FOR
 ( configuration_effectivity );
LOCAL
  ce_bag : BAG OF configuration_effectivity;
  ci_bag : BAG OF configuration_item := [];
  pass : BOOLEAN := TRUE;
  acu_bag : BAG OF assembly_component_usage;
END_LOCAL;

REPEAT i := 1 to SIZEOF(configuration_effectivity) by 1;
  IF EXISTS( configuration_effectivity[i].configuration.configuration ) THEN
    IF( NOT( configuration_effectivity[i].configuration.configuration IN 
                                                            ci_bag ) ) THEN
      ci_bag := ci_bag + 
               configuration_effectivity[i].configuration.configuration;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ci_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ce_bag := QUERY( r <* configuration_effectivity |
((r.configuration.configuration :=: ci_bag[i]) AND 
                              (r.usage\product_definition_relationship.name = 'assembly composition')
AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(r.usage)) ) );
  acu_bag := [];
  REPEAT j := 1 to SIZEOF(ce_bag) by 1;
    IF EXISTS( ce_bag[j].usage ) THEN
      IF ( ce_bag[j].usage IN acu_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        acu_bag := acu_bag + ce_bag[j].usage;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- planned_effectivity_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of configuration_effectivity that has a common configuration.configuration
attribute must have a unique usage attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="plus_minus_tolerance_range_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The plus_minus_tolerance_range_representation_constraint rule constrains the use of a shape_dimension_representation and a plus_minus_tolerance when they are used as a plus minus tolerance range representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE plus_minus_tolerance_range_representation_constraint FOR
  (shape_dimension_representation, plus_minus_tolerance);
WHERE
  WR1: SIZEOF(QUERY(pmt <* plus_minus_tolerance |
       NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'TOLERANCE_VALUE' IN TYPEOF (pmt.range))
       )) = 0;
END_RULE; -- plus_minus_tolerance_range_representation_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each plus_minus_tolerance shall have a range that is a tolerance_value.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value' shall contain exactly one measure_with_unit.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value' shall be the representation of either a dimensional_size or dimensional_location that is also the toleranced_dimension of exactly one plus_minus_tolerance the range of which is a tolerance_value.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each plus_minus_tolerance shall have a toleranced_dimension that is either a dimensional_size or dimensional_location that is represented by exactly one shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each plus_minus_tolerance shall have a range that is a tolerance_value the upper_bound and lower_bound of which are measure_with_unit, the units of which shall be the same units as that of the measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'basic value' and that is contained in the shape_dimension_representation that is a representation of the dimensional_size or dimensional_location that is the toleranced_dimension of the plus_minus_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="polarity_indication_feature_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The polarity_indication_feature_constraint rule constrains the body surfaces that may relate to it when the description is 'polarity indication feature'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
If the shape_aspect description is 'polarity indication feature', there shall be no more than one body_bottom_surface associated with it.
</formal.propositions.rul>
<formal.propositions.rul>
If the shape_aspect description is 'polarity indication feature', there shall be no more than one body_top_surface associated with it.
</formal.propositions.rul>
<formal.propositions.rul>
If the shape_aspect description is 'polarity indication feature', there shall be exactly one package_terminal associated with it.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="positional_boundary_and_profile_boundary_member_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The positional_boundary_and_profile_boundary_member_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a positional boundary and profile boundary member relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'positional boundary and profile boundary member' shall have a related_shape_aspect that has a description of 'tolerance zone boundary member' and is not on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'positional boundary and profile boundary member' shall have a relating_shape_aspect that is a positional_boundary with a description of 'profile related positional boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'positional boundary and profile boundary member' shall have exactly one property_definition with a description of 'positional boundary offset'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="positional_boundary_member_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The positional_boundary_member_definition_constraint rule constrains the use of a property_definition when it is used as a positional boundary member definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE positional_boundary_member_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition))))) = 0; 
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary member property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'DIMENSIONAL_SIZE_PROPERTY' IN 
       TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'boundary member associated dimension')
       )) = 1))) = 0; 
END_RULE; -- positional_boundary_member_definition_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be a property_definition of a positional_boundary_member.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall relate to exactly one dimensional_size_property to specify its 'boundary member associated dimension'.
</formal.propositions.rul>

</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be related as a 'defined boundary member property' to exactly one property_definition that has a description of 'dimension related positional boundary property'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'positional boundary member value' and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the position_tolerance that has a name of 'boundary based position' and that relates to the instance of property_definition that has a description of 'positional boundary member property' to specify its 'defined boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be related as a 'defined boundary member property' to exactly one property_definition that has a description of 'dimension related positional boundary property' and that is applied to a positional_boundary that has a description of 'dimension related positional boundary'. That positional_boundary shall be the same instance of positional_boundary to which the positional_boundary_member is related as a 'boundary member' and to which the instance of property_definition that has a description of 'positional boundary member property' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary member property' shall be related as a 'defined boundary' to exactly one position_tolerance that has a name of 'boundary based position'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="positional_boundary_offset_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The positional_boundary_offset_constraint rule constrains the use of a property_definition when it is used as a positional boundary offset.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE positional_boundary_offset_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF (pd.definition)) AND
 (pd.definition\shape_aspect_relationship.name = 'positional boundary and profile boundary member'))
       )) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'positional boundary offset')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION') |
       (pdr\property_definition_relationship.name = 'boundary offset') AND
       (pdr.relating_property_definition\property_definition.name =
       'profile related positional boundary property'))) = 1)
       )) = 0;
END_RULE; -- positional_boundary_offset_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary offset' shall be a property_definition of a shape_aspect_relationship that has a name of 'positional boundary and profile boundary member'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary offset' shall be related as a 'boundary offset' to exactly one property_definition that has a description of 'profile related positional boundary property'.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'positional boundary offset' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'positional boundary offset value', and that instance of length_measure_with_unit shall be the same instance of length_measure_with_unit as specified as the magnitude by the position_tolerance that has a name of 'boundary based position' and that relates to the instance of property_definition that has a description of 'profile related positional boundary property' to specify its 'defined boundary', that in turn relates to the instance of property_definition that has a description of 'positional boundary offset' to specify its 'boundary offset'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="pre_defined_dimension_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The pre_defined_dimension_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a pre defined dimension qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'predefined dimension qualifier' shall have exactly zero qualifiers for the measure_qualification that are type_qualifier the name of which is not either 'average', or 'free state'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="pre_defined_geometric_tolerance_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The pre_defined_geometric_tolerance_qualifier_constraint rule constrains the use of a measure_qualification when it is used as a pre-defined geometric tolerance qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'predefined geometric
tolerance qualifier' shall have exactly zero qualifiers for the
measure_qualification that are type_qualifier the name of which is not among
'each element', 'each radial element', 'free state', 'major diameter',
'minor diameter', 'not concave', 'not convex', or 'pitch diameter'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="printed_connector_template_terminal_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The printed_connector_template_terminal_relationship_unique_constraint rule constrains the
printed_connector_template_terminal_relationship population members, that fill the role of
ARM printed_connector_template_terminal_relationship, to have unique combinations of ARM
connector and ARM join_terminal attributes and to have unique combinations of ARM connector
and ARM interface_terminal attributes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of printed_connector_template_terminal_relationship that references a
common part_template_definition through a shape_aspect_relationship with a name of
'connector' must have a unique relating_shape_aspect attribute that points to a
printed_part_template_terminal with a description of 'join terminal'.
</formal.propositions.rul>
<formal.propositions.rul>
Every instance of printed_connector_template_terminal_relationship that references a
common part_template_definition through a shape_aspect_relationship with a name of
'connector' must have a unique related_shape_aspect attribute that points to a
printed_part_template_terminal with a description of 'interface terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="printed_part_template_terminal_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The printed_part_template_terminal_relationship_constraint rule constrains
the related and relating shape_aspect of a shape_aspect_relationship when it
is used as a printed part template terminal relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_aspect_relationship that has a name = 
'printed part template terminal relationship' shall have a 
related_shape_aspect that is a printed_part_template_terminal.
</formal.propositions.rul>
<formal.propositions.rul>
Each shape_aspect_relationship that has a name = 
'printed part template terminal relationship' shall have a 
relating_shape_aspect that is a printed_part_template_terminal.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="printed_part_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The printed_part_template_terminal_unique_constraint rule constrains the
printed_part_template_terminal population members, that fill the role of
ARM printed_part_template_terminal, to have unique names on each printed_part_template.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of 'printed part template terminal'
that is referenced by a shape_aspect_relationship with a name of 'associated definition'
that references a common shape_aspect with a description of 'printed part template' must
have a unique name attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="product_association_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_association_constraint rule constrains the usage of a
product_definition_formation_relationship when it is a product association.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_association_constraint FOR 
( product_definition_formation_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |
       (pdfr\product_definition_formation_relationship.name = 'product association')
       AND (SIZEOF(QUERY(adr <* USEDIN(pdfr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document))
       )) = 0))) = 0;
END_RULE; -- product_association_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_formation_relationship.name = 'product association' 
THEN SELF shall be an items of an applied_document_reference whose 
assigned_document is an ee_specification.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_association_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_association_unique_constraint rule constrains product_definition_formation_relationship
population members, that fill the role of ARM product_association, to have unique
ARM constraint_source attributes for each ARM relating_product attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_association_unique_constraint FOR
 ( product_definition_formation_relationship );
LOCAL
  pdfr : BAG OF product_definition_formation_relationship := QUERY( r <*
product_definition_formation_relationship | 
  (r\product_definition_formation_relationship.name = 'product association' ) );
  pdf_bag : BAG OF product_definition_formation := [];
  pdfr_bag : BAG OF product_definition_formation_relationship;
  pass : BOOLEAN := TRUE;
  adr_bag : BAG OF applied_document_reference;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(pdfr) by 1;
  IF EXISTS( pdfr[i].relating_product_definition_formation ) THEN
    IF( NOT( pdfr[i].relating_product_definition_formation IN pdf_bag ) )
                                                              THEN
      pdf_bag := pdf_bag + pdfr[i].
                 relating_product_definition_formation;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdf_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdfr_bag := QUERY( r <* pdfr | 
             (r.relating_product_definition_formation :=: pdf_bag[i]) );
  es_bag := [];
  REPEAT j := 1 to SIZEOF(pdfr_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( pdfr_bag[j], 
('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS')) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'EE_SPECIFICATION') IN TYPEOF(adr.assigned_document)) );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- product_association_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_formation_relationship with a name of 'product
association' that has a common relating_product_definition_formation must have
unique ee_specification entities assigned to the product_definition_formation_relationship
by an applied_document_reference's items attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="product_concept_requires_configuration_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_concept_requires_configuration_item assures that
each instance of product_concept shall have a 
configuration_item which is a item_concept. 
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_concept_requires_configuration_item FOR
  (product_concept, configuration_item);
WHERE
  WR1: SIZEOF (QUERY (pc <* product_concept |
       NOT (SIZEOF (QUERY (ci <* configuration_item |
       pc :=: ci.item_concept)) >=1 ))) = 0;
END_RULE; -- product_concept_requires_configuration_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_concept, there shall be at least one 
instance of configuration_item that contains the instance of product_concept
as the value of its item_concept attribute.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_formation_requires_approval">
<RULE.DESCRIPTION>
The product_definition_formation_requires_approval rule
assures that each instance of product_definition_formation that is an implementation of the Application Object Ee_product_version shall have an associated applied_approval_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_formation_requires_approval FOR
(product_definition,
  applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       pd.formation IN aaa.items )) = 1 )))) = 0;
END_RULE; -- product_definition_formation_requires_approval
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_definition_formation except for the instance referenced by an assembly_group_component_definition, there shall be exactly one instance of applied_approval_assignment that contains the instance of
product_definition_formation in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_formation_requires_person_organization">
<RULE.DESCRIPTION>
The product_definition_formation_requires_person_organization rule
assures that each instance of product_definition_formation that implements the Application Objec Ee_product_version shall
have either an applied_person_and_organization or an
applied_organization_assignment in the role of 'creator'.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_formation_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition|
       (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pd))) AND
       (NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       (pd.formation IN apaoa.items) AND (apaoa.role\person_and_organization_role.name = 'creator'))) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       (pd.formation IN aoa.items) AND (aoa.role\organization_role.name = 'creator'))) = 1 ))))) = 0;
END_RULE; -- product_definition_formation_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each product_definition that is not an implementation of Ee_product_version referenced by an implementation of Assembly_group_component_definition, exactly one instance of
applied_person_and_organization_assignment whose role.name is 'creator' or
exactly one instance of applied_organization_assignment whose role.name is
'creator' shall contain the instance of product_definition_formation in its
set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_definition_requires_date_or_date_and_time rule requires all
product_definition entities that implement the ARM concept of Ee_product_definition to be the items of exactly one
applied_date_and_time_assignment or applied_date_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_requires_date_or_date_and_time FOR
  (product_definition, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT 
       (NOT(is_ee_product_definition(pd)) OR 
       ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       pd IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       pd IN ada.items )) = 1 )))
       )) = 0;
END_RULE; -- product_definition_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_definition that implements the ARM concept of Ee_product_definition, exactly one instance of applied_date_and_time_assignment or exactly one instance of applied_date_assignment shall contain the instance of product_definition in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_definition_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_definition_requires_person_organization rule requires all
product_definition entities to be an items of exactly one
applied_person_and_organization_assignment or applied_organization_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_definition_requires_person_organization FOR
  (product_definition,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition | NOT
       (NOT(is_ee_product_definition(pd)) OR
       ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       pd IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       pd IN aoa.items )) = 1 )))
       )) = 0;
END_RULE; -- product_definition_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product_definition, exactly one instance of
applied_person_and_organization_assignment or exactly one instance of
applied_organization_assignment shall contain the instance of
product_definition in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_requires_person_organization rule requires all product entities to be
the items of exactly one applied_person_and_organization_assignment or
applied_organization_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_requires_person_organization FOR
  (product, applied_person_and_organization_assignment,
   applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       prod IN apaoa.items )) = 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       prod IN aoa.items )) = 1 )))) = 0;
END_RULE; -- product_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of product, there shall be exactly one instance of
applied_person_and_organization_assignment or exactly one instance of
applied_organization_assignment that contains the instance of product
in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="product_requires_product_definition_formation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The product_requires_product_definition_formation rule requires all
product entities to be the of_product of at least one
product_definition_formation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE product_requires_product_definition_formation FOR
  (product, product_definition_formation);
WHERE
  WR1: SIZEOF (QUERY (prod <* product |
       NOT (SIZEOF (QUERY (pdf <* product_definition_formation |
       prod :=: pdf.of_product )) >= 1 ))) = 0;
END_RULE; -- product_requires_product_definition_formation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each product there shall be at least one instance of
product_definition_formation that contains the instance of product in its
set of of_product.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="profile_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The profile_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a profile boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets' shall be a property_definition of either a tolerance_zone_explicit_opposing_boundary_set or a tolerance_zone_implicit_opposing_boundary_set.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets' shall relate to exactly one property_definition that has a description of 'true profile' to specify its 'basic profile'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets' shall be a property_definition of a tolerance_zone_boundary and that tolerance_zone_boundary shall be specified as exactly one of the boundaries of a tolerance_zone_definition that specifies as its zone a tolerance_zone that has exactly one defining_tolerance that is either a linear_profile_tolerance or a surface_profile_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="profile_boundary_definition_with_offsets_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The profile_boundary_definition_with_offsets_constraint rule constrains the use of a property_definition when it is used as a profile boundary definition with offsets.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE profile_boundary_definition_with_offsets_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       ((pd\property_definition.description = 'boundary zone definition with specified size')
       AND (pd\property_definition.name = 'profile boundary with offsets'))
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN
       TYPEOF(pd.definition))
       )) = 0;
END_RULE; -- profile_boundary_definition_with_offsets_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall be a property_definition of a tolerance_zone_explicit_opposing_boundary_set.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset', and each of these shall have a representation that contains exactly one length_measure_with_unit that has a name of 'tolerance zone boundary member offset value' and the sum of these length_measure_with_unit shall equal the length_measure_with_unit that has a name of 'tolerance value' that is contained within the representation of the instance of property_definition that has a description of 'boundary zone definition with specified size' that has a name of 'opposing boundary set size'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset', and the name of one of those property_definition shall be 'away from material'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'boundary zone definition with specified size' and a name of 'profile boundary with offsets' shall relate to exactly two property_definition that have a description of 'tolerance zone boundary member offset' to specify its 'profile tolerance zone boundary member offset', and the name of one of those property_definition shall be 'towards material'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="profile_related_positional_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The profile_related_positional_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a profile related positional boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE profile_related_positional_boundary_definition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition)) AND
       (pd.definition\shape_aspect.description = 'profile related positional boundary')
       ))) = 0;
  WR2: SIZEOF(QUERY(pd <* property_definition |
       (pd\property_definition.description = 'profile related positional boundary property')
       AND NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
(pdr.related_property_definition\property_definition.description = 'positional boundary offset')
       AND (pdr\property_definition_relationship.name = 'boundary offset'))) = 1))) = 0;
END_RULE; -- profile_related_positional_boundary_definition_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall be a property_definition of a positional_boundary that has a description of 'profile related positional boundary'.
</formal.propositions.rul>

<formal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall relate to exactly one property_definition that has a description of 'positional boundary offset' to specify its 'boundary offset'.
</formal.propositions.rul>
</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall relate to exactly one property_definition that has a description of 'positional boundary offset' to specify its 'boundary offset' and that property_definition shall be applied to a shape_aspect_relationship that has a name of 'positional boundary and profile boundary member'. The relating_shape_aspect of that shape_aspect_relationship shall be the same instance of positional_boundary to which the instance of property_definition that has a description of 'profile related positional boundary property' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'profile related positional boundary property' shall be related as a 'defined boundary' to exactly one physical_unit_geometric_tolerance and that physical_unit_geometric_tolerance shall be a position_tolerance that has a name of 'boundary based position'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="projected_tolerance_zone_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The projected_tolerance_zone_definition_constraint rule constrains the use of a projected_zone_definition when it is used as a projected tolerance zone definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each projected_zone_definition shall specify a tolerance_zone, as its zone, that specifies exactly one physical_unit_geometric_tolerance as its defining_tolerance, and that physical_unit_geometric_tolerance shall not be either a circular_runout_tolerance, a total_runout_tolerance, a linear_profile_tolerance, a surface_profile_tolerance; and shall not have a name of either 'boundary based position', 'circularity', 'cylindricity', 'flatness', or 'straightness'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each projected_zone_definition shall specify a tolerance_zone, as its zone, that 
specifies exactly one physical_unit_geometric_tolerance as its defining_tolerance, and 
that physical_unit_geometric_tolerance shall specify as its toleranced_shape_aspect a 
shape_aspect that is either a centre_of_symmetry that has a description of either 
'axis' or 'plane', or a composite_shape_aspect the 'composing' shape_aspects of which 
are all of type centre_of_symmetry and have the same description -- either 'axis' or 
'plane'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="projected_zone_and_base_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The projected_zone_and_base_relationship_constraint rule constrains the use of a projected_zone_definition when it is used as a projected zone and base relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE projected_zone_and_base_relationship_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end))
       OR (pzd.projection_end.product_definitional = TRUE)))) = 0;
END_RULE; -- projected_zone_and_base_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each projected_zone_definition shall have a projection_end that either is a part_template_definition or is on the boundary of the surface of the product.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="projected_zone_height_characteristic_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The projected_zone_height_characteristic_constraint rule constrains the use of a projected_zone_definition when it is used as a projected zone height characteristic.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE projected_zone_height_characteristic_constraint FOR
  (projected_zone_definition);
WHERE
  WR1: SIZEOF(QUERY(pzd <* projected_zone_definition |
       NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length))
       )) = 0;
END_RULE; -- projected_zone_height_characteristic_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each projected_zone_definition shall have a projected_length that is a length_measure_with_unit.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="promissory_usage_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The promissory_usage_relationship_constraint rule constrains the related and
relating product_definition and the use of a promissory_usage_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE promissory_usage_relationship_constraint FOR 
( promissory_usage_occurrence );
WHERE
  WR1: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PHYSICAL_UNIT' IN TYPEOF (puo.relating_product_definition))
       AND (puo.relating_product_definition.frame_of_reference.name
       = 'physical design'))) = 0;
  WR2: SIZEOF(QUERY(puo <* promissory_usage_occurrence |
       SIZEOF(USEDIN(puo,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS')
       ) = 0)) = 0;
END_RULE; -- promissory_usage_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each promissory_usage_occurrence shall have a relating_product_definition 
that is a physical_unit that has a frame_of_reference name = 'physical design'.
</formal.propositions.rul>
<formal.propositions.rul>
Each promissory_usage_occurrence shall be an items in an 
applied_security_classification_assignment.
</formal.propositions.rul>
</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each promissory_usage_occurrence shall have a related_product_definition 
that is a (physical_unit) (externally_defined_physical_unit) 
(library_defined_physical_unit) that has a frame_of_reference name = 
('physical design') ('physical design usage').
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="promissory_usage_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The promissory_usage_relationship_unique_constraint rule constrains promissory_usage_occurrence
population members, that fill the role of ARM promissory_usage_relationship, to have
unique ARM component attributes on each ARM assembly attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE promissory_usage_relationship_unique_constraint FOR
 ( promissory_usage_occurrence );
LOCAL
  pu_bag : BAG OF physical_unit := [];
  puo_bag : BAG OF promissory_usage_occurrence;
  pass : BOOLEAN := TRUE;
  comp_bag : BAG OF physical_unit;
END_LOCAL;

REPEAT i := 1 to SIZEOF(promissory_usage_occurrence) by 1;
  IF EXISTS( promissory_usage_occurrence[i].relating_product_definition ) 
                                                      THEN
    IF( (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_UNIT') IN
TYPEOF(promissory_usage_occurrence[i].relating_product_definition)) AND (
promissory_usage_occurrence[i].relating_product_definition.
frame_of_reference.name =
'physical design') ) THEN
      IF( NOT( promissory_usage_occurrence[i].
                                relating_product_definition IN pu_bag ) ) 
                                                                THEN
        pu_bag := pu_bag + promissory_usage_occurrence[i].
                                             relating_product_definition;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(pu_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  puo_bag := QUERY( puo <* promissory_usage_occurrence | 
      (puo.relating_product_definition :=: pu_bag[i]) );
  comp_bag := [];
  REPEAT j := 1 to SIZEOF(puo_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    IF ( ((
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PHYSICAL_UNIT') IN
TYPEOF(puo_bag[j].related_product_definition)) AND (
puo_bag[j].related_product_definition.frame_of_reference.name IN [
'physical design',
'physical design usage']) ) THEN
      IF EXISTS( puo_bag[j].related_product_definition ) THEN
        IF ( puo_bag[j].related_product_definition IN comp_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          comp_bag := comp_bag + puo_bag[j].related_product_definition;
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- promissory_usage_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of promissory_usage_occurrence that has a common relating_product_definition
must have a unique related_product_definition attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="radius_edge_feature_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The radius_edge_feature_shape_constraint rule constrains the items of a
shape_representation when it is a radius edge feature shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE radius_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum radius length')
       )) = 0))) = 0;
  WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'radius edge feature shape')
       AND (SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum radius length')
       )) = 0))) = 0;
END_RULE; -- radius_edge_feature_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_representation whose name = 'radius edge feature shape' shall have 
one items that is a length_measure_with_unit.name = 'maximum radius length'.
</formal.propositions.rul>
<formal.propositions.rul>
Each shape_representation whose name = 'radius edge feature shape' shall have 
one items that is a length_measure_with_unit.name = 'minimum radius length'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="reference_composition_path_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The reference_composition_path_constraint rule constrains the related and
relating product_definition of a product_definition_relationship when it is
a reference composition path.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE reference_composition_path_constraint FOR 
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
           TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'reference definition path')
       AND (pdr.relating_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
  WR2: SIZEOF(QUERY(pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference composition path')
       AND NOT(
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'COMPONENT_FUNCTIONAL_UNIT' IN 
         TYPEOF(pdr.related_product_definition))
       AND (pdr.related_product_definition.frame_of_reference.name =
      'functional occurrence')
       ))) = 0;
END_RULE; -- reference_composition_path_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
IF product_definition_relationship.name = 'reference composition path' 
THEN SELF.relating_product_definition shall be a component_functional_unit 
whose {description = 'reference definition path'} 
{frame_of_reference.name = 'functional occurrence'}.
</formal.propositions.rul>
<formal.propositions.rul>
IF product_definition_relationship.name = 'reference composition path' 
THEN SELF.related_product_definition shall be a component_functional_unit 
whose frame_of_reference.name = 'functional occurrence'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="reference_functional_unit_assignment_to_part_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The reference_functional_unit_assignment_to_part_constraint rule constrains
the use of product_to_part_relationship when it is used as a reference 
functional unit assignment to part.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE reference_functional_unit_assignment_to_part_constraint FOR
( product_definition_relationship );
WHERE
  WR1: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.related_product_definition))
       AND ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLICATION_CONTEXT_ELEMENT' IN
       TYPEOF(pdr.related_product_definition.frame_of_reference))
       AND ((pdr.relating_product_definition.frame_of_reference.name
              = 'physical design')
       OR (pdr.relating_product_definition.frame_of_reference.name
              = 'physical design usage'))))) = 0; 
  WR2: SIZEOF(QUERY( pdr <* product_definition_relationship |
       (pdr\product_definition_relationship.name = 'reference functional unit assignment to part')
       AND NOT (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))
       AND (pdr.relating_product_definition\product_definition.description = 
          'design definition path')
       AND (pdr.relating_product_definition.id = 
         'reference composition path')
       ))) = 0; 
END_RULE; -- reference_functional_unit_assignment_to_part_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
If a product_to_part_relationship has a name of 
'reference functional unit assignment to part' then the 
related_product_definition shall be a product_definition with a 
frame_of_reference that is an application_context_element with a name 
of 'physical design', or 'physical design usage'.
</formal.propositions.rul>
<formal.propositions.rul>
If a product_to_part_relationship has a name of 
'reference functional unit assignment to part' then the 
relating_product_definition shall be a product_definition with a 
description of 'design definition path' and an id of 
'reference composition path'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="reference_functional_unit_assignment_to_part_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The reference_functional_unit_assignment_to_part_unique_constraint rule constrains shape_aspect_relationship
population members, that fill the role of ARM reference_functional_unit_assignment_to_part, to have
unique implementations on each path_alias.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE reference_functional_unit_assignment_to_part_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name =
'reference functional unit assignment to part' ) );
  d_bag : BAG OF STRING := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  pd_bag : BAG OF product_definition;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i]\shape_aspect_relationship.description ) THEN
    IF( NOT( sar[i]\shape_aspect_relationship.description IN d_bag ) ) THEN
      d_bag := d_bag + sar[i]\shape_aspect_relationship.description;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(d_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.description = d_bag[i]) );
  pd_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect.of_shape.definition ) THEN
      IF ( sar_bag[j].related_shape_aspect.of_shape.definition IN pd_bag )
                                                                    THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        pd_bag := pd_bag + 
                    sar_bag[j].related_shape_aspect.of_shape.definition;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- reference_functional_unit_assignment_to_part_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of 'reference
functional unit assignment to part' that has a common description must have
unique related_shape_aspect.of_shape.definition attribute values.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="registered_font_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The registered_font_constraint rule constrains the usage of an
externally_defined_text_font.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE registered_font_constraint FOR ( externally_defined_text_font );
WHERE
  WR1: SIZEOF(QUERY(edtf <* externally_defined_text_font |
       (SIZEOF(QUERY(adr <* USEDIN(edtf,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'APPLIED_DOCUMENT_REFERENCE.ITEMS') |
       (adr.assigned_document.kind\document_type.product_data_type = 
                     'font registration document')
       )) = 0))) = 0;
END_RULE; -- registered_font_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each externally_defined_text_font shall be an items of an 
applied_document_reference whose assigned_document.kind.product_data_type = 
'font registration document'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="registered_font_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The registered_font_unique_constraint rule constrains the externally_defined_text_font
population members, that fill the role of ARM registered_font, to have unique
registration_documents on each font_code.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE registered_font_unique_constraint FOR
 ( externally_defined_text_font );
LOCAL
  ii_bag : BAG OF STRING := [];
  edtf_bag : BAG OF externally_defined_text_font;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  es_bag : BAG OF ee_specification;
END_LOCAL;

REPEAT i := 1 to SIZEOF(externally_defined_text_font) by 1;
  IF EXISTS( externally_defined_text_font[i].item_id ) THEN
    IF ( NOT ( externally_defined_text_font[i].item_id IN ii_bag ) ) THEN
      ii_bag := ii_bag + externally_defined_text_font[i].item_id;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ii_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  edtf_bag := QUERY( edtf <* externally_defined_text_font | 
            (edtf.item_id = ii_bag[i]) );
  REPEAT j := 1 to SIZEOF(edtf_bag) by 1;
    adr_bag := QUERY( adr <* USEDIN( edtf_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) | 
         (adr.assigned_document.kind\document_type.product_data_type =
'font registration document') );
    es_bag := [];
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN es_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          es_bag := es_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- registered_font_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of externally_defined_text_font that has a common item_id must
have unique ee_specifications that are referenced by an applied_document_reference
that has said externally_defined_text_fonts in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="requirements_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The requirements_property_constraint rule constrains the requirements_property population members to satisfy the requirements of the ARM object Ee_requirement_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE requirements_property_constraint FOR 
           (product_definition,
            descriptive_representation_item,
            requirements_property);
LOCAL
ri : BAG OF descriptive_representation_item := 
         QUERY (dri <* descriptive_representation_item 
                              | dri\representation_item.name = 
                                          'requirements name');
pd : BAG OF product_definition:=
         QUERY(tpd <* product_definition
               | ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                  'APPLICATION_CONTEXT_ELEMENT' IN
                  TYPEOF(tpd.frame_of_reference)) AND
                  (tpd.frame_of_reference.name IN ['requirement',
                                                   'design requirement',
                                                   'assembly requirement'])
                  AND
                  (tpd.name = 'requirements model'));

r : BAG OF representation := [];
pdr : BAG OF property_definition_representation := [];
pass1 : BOOLEAN := TRUE;

rp : BAG OF property_definition := [];
pass2 : BOOLEAN := TRUE;

END_LOCAL;
  (* WR1 Test *)
  REPEAT i := 1 to SIZEOF (ri) by 1;
     r := [];
     pdr := [];
     r := (USEDIN(ri[i],
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REPRESENTATION.ITEMS'));
     pass1 := (SIZEOF(r) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pdr := (USEDIN(r[1],
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
     pass1 := (SIZEOF(pdr) = 1);
     IF (NOT pass1) THEN ESCAPE; END_IF;

     pass1 := ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr[1].definition));
     IF (NOT pass1) THEN ESCAPE; END_IF;
  END_REPEAT;
  (* WR2 Test *)
  REPEAT i := 1 to SIZEOF (pd) by 1;
     rp := [];
     IF (NOT pass2) THEN ESCAPE; END_IF;
     rp := QUERY(rp <* USEDIN(pd[i],
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION.DEFINITION') |
             'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
     pass2 := (SIZEOF(rp) = 1);
  END_REPEAT;
WHERE
 WR1: pass1;
 WR2: pass2;
END_RULE; -- requirements_property_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">

<Formal.propositions.rul>
Each descriptive_representation_item with a name of 'requirements name' shall be referenced exactly once by a property_definition_representation that shall reference a property_definition that is a requirements_property.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each product_definition with a name of 'requirements model' and a frame_of_reference which is an application_constraint_element with a name of 'requirement' or 'design requirement' or 'assembly requirement' shall be the definition of exactly one requirements_property.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="requirements_property_unique_constraint">
<RULE.DESCRIPTION>
The requirements_property_unique_constraint rule constrains the requirements_property population members to satisfy the uniqueness requirements of the ARM object Ee_requirement_occurrence.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE requirements_property_unique_constraint FOR 
           (descriptive_representation_item,
            requirements_property);
LOCAL
desc_bag : BAG OF STRING := [];
pass1 : BOOLEAN := TRUE;
pdr : BAG OF property_definition_representation := [];
rep : BAG OF representation := [];
pd : BAG OF product_definition := [];

END_LOCAL;
  REPEAT i := 1 to SIZEOF (requirements_property) by 1;
     IF (NOT pass1) THEN ESCAPE; END_IF;
     IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'PRODUCT_DEFINITION' IN TYPEOF(requirements_property[i].definition))
      THEN pd := pd + requirements_property[i].definition;
     END_IF;
  END_REPEAT;
  IF (instance_unique(pd) = FALSE ) THEN pass1 := FALSE; END_IF;
WHERE
 WR1: pass1;
END_RULE; -- requirements_property_unique_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each descriptive_representation_item with a name of 'requirements name' shall have a unique associated definition.
</Formal.propositions.rul>
</Formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="restraint_condition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restraint_condition_constraint rule constrains the use of a property_definition when it is used as a restraint condition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restraint_condition_constraint FOR
  (property_definition);
WHERE
  WR1: SIZEOF(QUERY(pd <* property_definition |
       ((pd\property_definition.description = 'restraint') 
       OR (pd\property_definition.description = 'tolerance specific restraint'))
       AND (SIZEOF(QUERY(pdr <* USEDIN(pd, 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
    + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
    + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))
       AND (pdr\property_definition_relationship.name = 'restraint description'))) = 0))) = 0;
END_RULE; -- restraint_condition_constraint
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each instance of property_definition that has a description of either 'restraint' or 'tolerance specific restraint' shall relate to exactly one requirements_property to specify its 'restraint description'.
</formal.propositions.rul>

</formal.propositions>

<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'restraint' or 'tolerance specific restraint' shall be a property_definition of either a shape_aspect_relationship with a name of 'datum feature usage in common datum' or 'datum feature usage in single datum', or a shape_aspect that is either on the boundary of the shape of the product or is a part_template_definition.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_action_request_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_action_request_status rule restricts the status value of all
action_request_status entities to be either:
<list>
<list.item>'proposed'</list.item>
<list.item>'in_work'</list.item>
<list.item>'issued'</list.item>
<list.item>'hold'</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_action_request_status FOR (action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ars <* action_request_status |
       NOT (ars\action_request_status.status IN
       ['proposed', 'in work', 'issued', 'hold']))) = 0;
END_RULE; -- restrict_action_request_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of the action_request_status entity, the status
attribute shall have a value of "proposed", "in work", "issued", or "hold".
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_approval_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_approval_status rule restricts the name value of all
approval_status entities to be either:
<list>
<list.item>'approved'</list.item>
<list.item>'not yet approved'</list.item>
<list.item>'disapproved'</list.item>
<list.item>'withdrawn'</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_approval_status FOR (approval_status);
WHERE
  WR1: SIZEOF (QUERY (ast <* approval_status |
       NOT (ast\approval_status.name IN
       ['approved', 'not yet approved', 'disapproved', 'withdrawn']))) = 0;
END_RULE; -- restrict_approval_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of approval, the value of the name attribute shall 
be either "approved", "not yet approved", "disapproved" or "withdrawn".
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_date_role">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_date_role rule restricts the name value of all date_role entities
to be either:
<list>
<list.item>'creation date'</list.item>
<list.item>'request date'</list.item>
<list.item>'release date'</list.item>
<list.item>'start date'</list.item>
<list.item>'contract date'</list.item>
<list.item>'certification date'</list.item>
<list.item>'sign off date'</list.item>
<list.item>'classification date'</list.item>
<list.item>'declassification date'</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_date_role FOR (date_role);
WHERE
  WR1: SIZEOF (QUERY (dr <* date_role |
       NOT (dr\date_role.name IN ['creation date', 'request date', 'release date',
       'start date', 'contract date', 'certification date', 'sign off date',
       'classification date', 'declassification date']))) = 0;
END_RULE; -- restrict_date_role
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of date_role, the name attribute shall have the value of
"creation date", "request date", "release date", "start date", "contract date",
"certification date", "sign off date", "classification date", or
"declassification date".
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="restrict_manifold_surface_shape_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The restrict_manifold_surface_shape_representation rule 
requires each manifold_surface_shape_representation
to contain exactly one shell_based_surface_model that 
has exactly one shell that is an open_shell when the 
manifold_surface_shape_representation is implementing 
the arm concepts of 
<internal.ref linkend="Stratum_feature_non_planar_2d_shape">,
Design_intent_modification_non_planar_2d_shape,
and
<internal.ref linkend="Part_template_non_planar_2d_shape">,
and a non planar shape representation of the arm concept of
<internal.ref linkend="Stratum_feature_template_component">.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE restrict_manifold_surface_shape_representation FOR
  (manifold_surface_shape_representation);
  WHERE
    WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
         (mssr\representation.name IN ['stratum feature non planar 2d shape',
         'open shell based surface',
         'design intent modification non planar 2d shape', 
         'part template non planar 2d shape']) AND
         (NOT(SIZEOF(QUERY(sbsm <* mssr.items | 
         ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'SHELL_BASED_SURFACE_MODEL' IN TYPEOF(sbsm)) AND
         (SIZEOF(QUERY(os <* sbsm\shell_based_surface_model.sbsm_boundary |
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
         'OPEN_SHELL' IN TYPEOF(os))) = 1)
         )) = 1)))) = 0;
END_RULE; -- restrict_manifold_surface_shape_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each manifold_surface_shape_representation that has a name of
'stratum feature non planar 2d shape'
'open shell based surface',
'design intent modification non planar 2d shape', or
'part template non planar 2d shape'
shall have exactly one shell that is an open_shell that is in the role of sbsm_boundary for the
shell_based_surface_model that is in the items for the manifold_surface_shape_representation.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="rule_action_unique_constraint">
<RULE.DESCRIPTION>
The rule_action_unique_constraint rule constrains the rule_action population members, that
fill the role of ARM rule_action, to have unique product_definition_formation with a description of 'rule version' on each applied_date_and_time_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE rule_action_unique_constraint FOR
 ( rule_action );
LOCAL
  adta : BAG OF applied_date_and_time_assignment;
  adta_bag : BAG OF applied_date_and_time_assignment := [];
  ra_bag : BAG OF rule_action;
  aaa_bag : BAG OF applied_action_assignment;
  pass : BOOLEAN := TRUE;
  rd_bag : BAG OF product_definition_formation;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_action) by 1;
  adta := USEDIN( rule_action[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' );
  REPEAT j := 1 to SIZEOF(adta) by 1;
    IF EXISTS( adta[j] ) THEN
      IF( NOT( adta[j] IN adta_bag ) ) THEN
        adta_bag := adta_bag + adta[j];
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(adta_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ra_bag := QUERY( r <* rule_action | (r IN adta_bag[i].items) );
  rd_bag := [];
  REPEAT j := 1 to SIZEOF(ra_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    aaa_bag := QUERY( aa <* USEDIN( ra_bag[j], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ACTION_ASSIGNMENT.ASSIGNED_ACTION' ) | 
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_ACTION_ASSIGNMENT') IN TYPEOF(aa) ) );
    REPEAT k := 1 to SIZEOF(aaa_bag) by 1;
      IF ( NOT pass ) THEN ESCAPE;
      END_IF;
      REPEAT l := 1 to SIZEOF(aaa_bag[k].items) by 1;
        IF EXISTS( aaa_bag[k].items[l] ) THEN
          IF ( ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_FORMATION'  IN TYPEOF(aaa_bag[k].items[l])) AND
(aaa_bag[k].items[l]\product_definition_formation.description = 'rule version') ) THEN
            IF ( aaa_bag[k].items[l] IN rd_bag ) THEN
              pass := FALSE;
              ESCAPE;
            ELSE
              rd_bag := rd_bag + aaa_bag[k].items[l];
            END_IF;
          END_IF;
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- rule_action_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of rule_action that is referenced in the set of items of a common
applied_date_and_time_assignment must not be referenced by more than one
applied_action_assignment that references the same product_definition_formation with a description of 
'rule version' in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="rule_conclusion_definition_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The rule_conclusion_definition_unique_constraint rule constrains the rule_conclusion_definition population members to be uniquely identifiable within the scope of a rule definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE rule_conclusion_definition_unique_constraint FOR 
(rule_conclusion_definition,
representation,representation_relationship);
LOCAL
r : BAG of representation := 
           QUERY (r <* representation | r\representation.name = 
                                             'rule definition');
rr : BAG OF representation_relationship := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
name_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   count := 0;
   name_bag := [];
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr := USEDIN(r[i],
 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'REPRESENTATION_RELATIONSHIP.REP_1');
   REPEAT j := 1 to SIZEOF (rr) by 1;
    IF 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_CONCLUSION_DEFINITION' IN
       TYPEOF (rr[j].rep_2)
    THEN
      IF EXISTS( rr[j].rep_2\representation.name ) THEN
        IF rr[j].rep_2\representation.name IN name_bag
        THEN
         pass := FALSE;
        ELSE
         name_bag := name_bag + rr[j].rep_2\representation.name;
        END_IF;
      END_IF;
    END_IF;
   END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;  --  rule_conclusion_definition_unique_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
No more than one rule_conclusion_definition shall have the same name within the scope of a rule definition.
</Formal.propositions.rul>

</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="rule_function_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The rule_function_unique_constraint rule constrains the
rule_function_definition population members, that fill the role of
ARM Rule_function, so that the combination of ARM identifier
and ARM reference_document attributes shall be unique within the
population.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE rule_function_unique_constraint FOR
 ( rule_function_definition );
LOCAL
  name_bag : BAG OF STRING := [];
  rfd_bag : BAG OF rule_function_definition;
  adr_bag : BAG OF applied_document_reference;
  pass : BOOLEAN := TRUE;
  doc_bag : BAG OF document;
END_LOCAL;

REPEAT i := 1 to SIZEOF(rule_function_definition) by 1;
  IF EXISTS( rule_function_definition[i]\representation.name ) THEN
    IF( NOT( rule_function_definition[i]\representation.name IN name_bag ) ) THEN
      name_bag := name_bag + rule_function_definition[i]\representation.name;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(name_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  doc_bag := [];
  rfd_bag := QUERY( am <* rule_function_definition | 
               (am\representation.name = name_bag[i]) );
  REPEAT j := 1 to SIZEOF(rfd_bag) by 1;
    IF ( NOT pass ) THEN ESCAPE;
    END_IF;
    adr_bag := QUERY( adr <* USEDIN( rfd_bag[j],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
+ 'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) |
(adr.assigned_document.kind\document_type.product_data_type = 'reference document') );
    REPEAT k := 1 to SIZEOF(adr_bag) by 1;
      IF EXISTS( adr_bag[k].assigned_document ) THEN
        IF ( adr_bag[k].assigned_document IN doc_bag ) THEN
          pass := FALSE;
          ESCAPE;
        ELSE
          doc_bag := doc_bag + adr_bag[k].assigned_document;
        END_IF;
      END_IF;
    END_REPEAT;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- rule_function_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of rule_function_definition must have a unique combination of name
attribute and document entity assigned to the rule_function_definition by an
applied_document_reference's items attribute where the document has a
kind.product_data_type of 'reference document'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="rule_premise_definition_unique_constraint">
<RULE.DESCRIPTION>
The rule_premise_definition_unique_constraint rule constrains the rule_premise_definition population members to be uniquely identifiable within the scope of a rule definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE rule_premise_definition_unique_constraint FOR (rule_premise_definition,
representation,representation_relationship);
local
rr : BAG OF representation_relationship := [];
rpd : BAG OF rule_premise_definition := [];
pass : BOOLEAN := TRUE;
count : INTEGER := 0;
END_LOCAL;
  REPEAT i := 1 to SIZEOF (rule_premise_definition) by 1;
   count := 0;
   IF NOT pass THEN ESCAPE;
   END_IF;
   rr :=
USEDIN(rule_premise_definition[i],'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_2');
    REPEAT j := 1 to SIZEOF (rr) by 1;
     IF NOT pass THEN ESCAPE;
     END_IF;
     IF (rr[j]\representation_relationship.rep_1\representation.description IN
              ['rule definition']) THEN
     count := count + 1;
     END_IF;
     IF count = 2 THEN pass := FALSE;
     END_IF;
    END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE;
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each rule_premise_definition requires exactly one member of representation that has a description of
'rule definition',
</Formal.propositions.rul>

</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="rule_supersedence_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The rule_supersedence_constraint rule requires that an action_relationship
relate the from and to rule replacements.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each action that has a name = 'rule replacement from' shall be the
related_action of an action_relationship that [has a relating_action
with the name of 'rule replacement to'] [has a name of 'rule supersedence'].
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="runout_tolerance_zone_definition_with_specified_angle_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The runout_tolerance_zone_definition_with_specified_angle_constraint rule constrains the use of a runout_zone_definition when it is used as a runout tolerance zone definition with specified angle.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each runout_zone_definition shall specify the same instance of tolerance_zone as its zone that is specified as the relating_shape_aspect by the shape_aspect_relationship that is the orientation_defining_relationship of the runout_zone_orientation_reference_direction that is specified as the orientation.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_definition shall specify a tolerance_zone, as its zone, that specifies either exactly one circular_runout_tolerance or exactly one total_runout_tolerance as its defining_tolerance.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_definition shall specify a runout_zone_orientation_reference_direction, as its orientation, that specifies a shape_aspect_relationship, as its orientation_defining_relationship, that specifies a derived_shape_aspect with a description of 'directed axis', as its related_shape_aspect, and that derived_shape_aspect shall relate to a centre_of_symmetry with a description of 'axis' to specify its 'derived axis' and that centre_of_symmetry shall be a physical_unit_datum that is related, as the 'datum usage in datum system', to the datum_system that has a property_definition with a description of 'datum system property without material conditions' that is related, as the 'referenced datum system definition', to the physical_unit_geometric_tolerance that is specified as the defining_tolerance by the tolerance_zone that is specified as the zone.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="runout_tolerance_zone_orienting_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The runout_tolerance_zone_orienting_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a runout tolerance zone orienting relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'runout tolerance zone orienting' shall have a related_shape_aspect that is a derived_shape_aspect with a description of 'directed axis'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'runout tolerance zone orienting' shall have a relating_shape_aspect that is a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'runout tolerance zone orienting' shall be the  orientation_defining_relationship of exactly one runout_zone_orientation_reference_direction.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="runout_zone_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The runout_zone_orientation_constraint rule constrains the use of a runout_zone_orientation_reference_direction when it is used as a runout zone orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each runout_zone_orientation_reference_direction shall have an orientation_defining_relationship that is a shape_aspect_relationship with a name of 'runout tolerance zone orienting'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_orientation_reference_direction shall specify a plane_angle_measure_with_unit as its angle.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each runout_zone_orientation_reference_direction shall be specified as the orientation of exactly one runout_zone_definition.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="security_classification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The security_classification_constraint rule constrains the usage of a
security_classification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE security_classification_constraint FOR (security_classification,
     applied_date_and_time_assignment, applied_date_assignment,
     applied_person_and_organization_assignment, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (sc <* security_classification |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       (sc IN adata.items) AND
       ('classification date' = adata.role\date_time_role.name))) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       (sc IN ada.items) AND
       ('classification date' = ada.role\date_role.name))) = 1 )))) = 0;
  WR2: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (apa <* applied_person_and_organization_assignment |
       (sc IN apa.items) AND
       (apa.role\person_and_organization_role.name = 'classification officer')
       )) = 0)) = 0;
  WR3: SIZEOF (QUERY (sc <* security_classification |
       SIZEOF (QUERY (aaa <* applied_approval_assignment |
       (sc IN aaa.items))) = 0)) = 0;
END_RULE; -- security_classification_constraint
(*
</EXPRESS.CODE>
<FORMAL.PROPOSITIONS RULE.TYPES="WR">
<FORMAL.PROPOSITIONS.RUL>
Each security_classification shall be an items of 
either an applied_date_assignment whose role name = 'classification date' or 
an applied_date_and_time_assignment whose role name = 'classification date'.
</FORMAL.PROPOSITIONS.RUL>

<formal.propositions.rul>
Each security_classification shall be an items of an applied_person_and_organization_assignment 
whose role name = 'classification officer'.
</formal.propositions.rul>
<formal.propositions.rul>
Each security_classification shall be an items of an 
applied_approval_assignment.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="shape_dimension_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_dimension_representation_constraint rule constrains the use of a shape_dimension_representation when it is used as a shape dimension representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_dimension_representation_constraint FOR
  (shape_dimension_representation);
WHERE
    wr1: SIZEOF (QUERY (sdr <* shape_dimension_representation | 
          NOT (SIZEOF (QUERY (i <* sdr.items |
            (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
            + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
             (SIZEOF (QUERY (mq <* USEDIN (i,
               'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE') |
              mq\measure_qualification.name = 'dimension value qualifier')) <= 1))
            )) >= 1
         ))) = 0;
    wr2: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | (mq\measure_qualification.name = 'dimension value qualifier')
            AND             
              (SIZEOF (QUERY (q <* mq.qualifiers |
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                 + 'TYPE_QUALIFIER' IN TYPEOF (q))
               ) <> 1)
             )) > 0)
           )) > 0
         )) = 0;
    wr3: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | (mq\measure_qualification.name = 'dimension value qualifier')
            AND             
              (SIZEOF (QUERY (q <* mq.qualifiers |
                ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                 + 'TYPE_QUALIFIER' IN TYPEOF (q))
            AND
              (NOT (q\type_qualifier.name IN ['theoretically exact',
                               'maximum dimension',
                               'minumum dimersion',
                               'lower value',
                               'upper value',
                               'basic value']))
               )) > 0)
             )) > 0)
           )) > 0
         )) = 0;
    wr4: SIZEOF (QUERY (sdr <* shape_dimension_representation |
           SIZEOF (QUERY (i <* sdr.items |
             ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
              + 'MEASURE_WITH_UNIT' IN TYPEOF (i))
            AND
              (SIZEOF (QUERY (mq <* USEDIN (i,
                'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                + 'MEASURE_QUALIFICATION.QUALIFIED_MEASURE')
                | NOT (mq\measure_qualification.name IN ['dimension value qualifier',
                                   'predefined dimension qualifier',
                                   'user defined dimension qualifier'])
                )) > 0)
              )) > 0
            )) = 0;
     wr5: SIZEOF (QUERY (sdr <* shape_dimension_representation | NOT (
            SIZEOF (USEDIN (sdr, 
                   'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
                             + 'DIMENSIONAL_CHARACTERISTIC_REPRESENTATION.'
                                 + 'REPRESENTATION')) >= 1
           ))) = 0;
         

END_RULE; -- shape_dimension_representation_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each shape_dimension_representation shall contain measure_with_unit that shall be a qualified_measure of at most one measure_qualification that has the name of 'dimension value qualifier'.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation that contain measure_with_unit that are the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' shall have exactly one qualifier for the measure_qualification that is a type_qualifier.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation that contain measure_with_unit that are the qualified_measure of a measure_qualification that have the name of 'dimension value qualifier' shall have exactly zero qualifiers for the measure_qualification that are type_qualifier the name of which is not among 'theoretically exact', 'maximum dimension', 'minimum dimension', 'lower value', 'upper value', or 'basic value'.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation that contain measure_with_unit shall be the qualified_measure of exactly zero measure_qualification that have a name that is not among 'dimension value qualifier', 'predefined dimension qualifier', or 'user defined dimension qualifier'.
</Formal.propositions.rul>

<Formal.propositions.rul>
Each shape_dimension_representation shall be the representation of at least one dimensional_size or dimensional_location.
</Formal.propositions.rul>

</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_boundary_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_boundary_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element boundary relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'boundary' shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are on the boundary of themselves either directly or through intermediate shape_aspect_relationship with a name of 'boundary'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_composing_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_composing_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element composing relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.Propositions rule.types="WR">
<formal.propositions.rul>
Each shape_aspect_relationship with a name of 'composing' shall have a relating_shape_aspect that is a composite_shape_aspect.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_constituent_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_constituent_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element constituent relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of either 'constituent' or 'composing' or 
'interconnect module terminal surface constituent relationship' or
'bare die terminal surface constituent relationship' or
'package terminal surface constituent relationship'
shall not result in the assertion that the relating_shape_aspect and related_shape_aspect are constituents of themselves either directly or through intermediate shape_aspect_relationship with a name of either 'constituent' or 'composing'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'interconnect module terminal surface constituent relationship' shall specify a shape_aspect with a description of 
`interconnect module cavity surface' or
`interconnect module cutout surface' or
`interconnect module edge surface' or
`interconnect module edge segment surface' or
`interconnect module primary surface' or
`interconnect module secondary surface' or
`interconnect module surface feature' as the relating_shape_aspect and an interconnect_module_terminal as the related_shape_aspect.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'bare die terminal surface constituent relationship' shall specify a bare_die_surface or bare_die_edge_segment_surface as the relating_shape_aspect and a bare_die_terminal as the related_shape_aspect.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'package terminal surface constituent relationship' shall specify a package_body_surface or package_body_edge_segment_surface as the relating_shape_aspect and a package_terminal as the related_shape_aspect.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_constituent_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_constituent_relationship_unique_constraint rule constrains shape_aspect_relationship 
population members, that fill the role of ARM shape_element_constituent_relationship, to have
unique related_shape_elements on each relating_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_constituent_relationship_unique_constraint FOR
 ( shape_aspect_relationship );
LOCAL
  sar : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship | (r\shape_aspect_relationship.name IN [
'constituent', 'composing', 
'bare die terminal surface constituent relationship',
'interconnect module terminal surface constituent relationship',
'package terminal surface constituent relationship'] ) );
  sa_bag : BAG OF shape_aspect := [];
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(sar) by 1;
  IF EXISTS( sar[i].relating_shape_aspect ) THEN
    IF( NOT( sar[i].relating_shape_aspect IN sa_bag ) ) THEN
      sa_bag := sa_bag + sar[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( r <* sar | (r\shape_aspect_relationship.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- shape_element_constituent_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a name of either 'constituent'
or 'composing' or 'interconnect module terminal surface constituent relationship'
or 'bare die terminal surface constituent relationship'
or 'package terminal surface constituent relationship'
that has a common relating_shape_aspect shall have a unique
related_shape_aspect attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_deriving_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_deriving_relationship_constraint rule constrains the use of a shape_aspect_deriving_relationship when it is used as a shape element deriving relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_deriving_relationship shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_deriving_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_deriving_relationship_unique_constraint rule constrains shape_aspect_deriving_relationship
population members, that fill the role of ARM shape_element_deriving_relationship, to have
unique related_shape_elements on each relating_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_deriving_relationship_unique_constraint FOR
 ( shape_aspect_deriving_relationship );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  sadr_bag : BAG OF shape_aspect_deriving_relationship;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(shape_aspect_deriving_relationship) by 1;
  IF EXISTS( shape_aspect_deriving_relationship[i].relating_shape_aspect )
                                                    THEN
    IF( NOT( shape_aspect_deriving_relationship[i].
                           relating_shape_aspect IN sa_bag ) ) 
                                                  THEN
      sa_bag := sa_bag + 
            shape_aspect_deriving_relationship[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sadr_bag := QUERY( r <* shape_aspect_deriving_relationship | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(sadr_bag) by 1;
    IF EXISTS( sadr_bag[j].related_shape_aspect ) THEN
      IF ( sadr_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + sadr_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- shape_element_deriving_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_deriving_relationship that has a common relating_shape_aspect
must have a unique related_shape_aspect attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_locating_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_locating_relationship_constraint rule constrains the use of a dimensional_location when it is used as a shape element locating relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each dimensional_location shall not specify the same shape_aspect as both the related_shape_aspect and the relating_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_locating_relationship_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_locating_relationship_unique_constraint rule constrains dimensional_location
population members, that fill the role of ARM shape_element_locating_relationship, to have
unique located_shape_elements on each locating_shape_element.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_locating_relationship_unique_constraint FOR
 ( dimensional_location );
LOCAL
  sa_bag : BAG OF shape_aspect := [];
  dl_bag : BAG OF dimensional_location;
  pass : BOOLEAN := TRUE;
  rsa_bag : BAG OF shape_aspect;
END_LOCAL;

REPEAT i := 1 to SIZEOF(dimensional_location) by 1;
  IF EXISTS( dimensional_location[i].relating_shape_aspect ) THEN
    IF( NOT( dimensional_location[i].relating_shape_aspect IN sa_bag ) )
                                                              THEN
      sa_bag := sa_bag + dimensional_location[i].relating_shape_aspect;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(sa_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  dl_bag := QUERY( r <* dimensional_location | 
                    (r.relating_shape_aspect :=: sa_bag[i]) );
  rsa_bag := [];
  REPEAT j := 1 to SIZEOF(dl_bag) by 1;
    IF EXISTS( dl_bag[j].related_shape_aspect ) THEN
      IF ( dl_bag[j].related_shape_aspect IN rsa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        rsa_bag := rsa_bag + dl_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- shape_element_locating_relationship_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of dimensional_location that has a common relating_shape_aspect
must have a unique related_shape_aspect attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a shape element relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship shall have at most one property_definition that has a description of 'shape element relationship characterization' and that property_definition shall have at most one representation with a name of 'shape element relationship description' and that representation shall contain exactly one descriptive_representation_item.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship shall have at most one property_definition that has a description of 'shape element relationship characterization' and that property_definition shall have at most one representation with a name of 'shape element relationship name' and that representation shall contain exactly one descriptive_representation_item.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_element_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_element_unique_constraint rule constrains the representation population members to satisfy the uniqueness requirements of the ARM object Shape_element when the representation is used to identify the Shape_element.
<note>
This constraint only applies when shape_aspect is used as an implementation of the ARM concept of Datum and its subtypes or when the shape_aspect is used as an implementation of the ARM concept of Join_relationship or its subtypes.  All other shape_aspect implementations of ARM concepts are population constrained using the name attribute of shape_aspect as a control.  The population constraints may be applied using other RULES in this part of ISO 10303 or may be applied in entity subtypes in this part of ISO 10303.
</note>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_element_unique_constraint FOR 
           (representation,representation_item,
              property_definition_representation);
LOCAL
r : BAG OF representation := 
         QUERY (r <* representation | r\representation.name = 
                                          'shape element name');
ri : BAG OF representation_item := [];
pass : BOOLEAN := TRUE;
description_bag : BAG OF string := [];
END_LOCAL;
  REPEAT i := 1 to SIZEOF (r) by 1;
   IF (NOT pass) THEN ESCAPE; END_IF;
      pass := SIZEOF(QUERY(pdr <* 
  	     (USEDIN(r[i],
         'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
             'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))| 
   (pdr.definition\property_definition.description = 'shape element characterization'))) = 1;
      IF (NOT pass) THEN ESCAPE; END_IF;
      ri := QUERY ( ri <* representation_item | ri IN r[i].items);
      pass := (SIZEOF(ri) = 1);
      IF (NOT pass) THEN ESCAPE; END_IF;
      IF (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
                     'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF (ri)))
        THEN
         pass := FALSE;
         ESCAPE;
      END_IF;
      REPEAT j := 1 to SIZEOF (ri) by 1;
        IF EXISTS( ri[j]\descriptive_representation_item.description ) THEN
          IF (ri[j]\descriptive_representation_item.description IN 
                                               description_bag) THEN
            pass := FALSE;
            ESCAPE;
          ELSE
            description_bag := description_bag + 
                 ri[j]\descriptive_representation_item.description;
          END_IF;
        END_IF;
      END_REPEAT;
  END_REPEAT;
WHERE
 WR1: pass;
END_RULE; -- shape_element_unique_constraint
(*
</EXPRESS.CODE>
<Formal.propositions rule.types="WR">
<Formal.propositions.rul>
Each representation with a name of 'shape element name' shall be referenced no more than 
once by a property_definition_representation that shall reference a property_definition
with a name of 'shape element characterization' and each descriptive_representation_item 
description shall be used as a name by no more than one representation with a name of 
'shape element name', and each representation with a name of 'shape element name' shall 
have only one representation_item which shall be a descriptive_representation_item.
</Formal.propositions.rul>
</Formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="shape_representation_requires_origin">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shape_representation_requires_origin rule assures that each instance of shape_representation has exactly one associated axis2_placement_2d or axis2_placement_3d with a name of 'origin' or 'orientation' or assures that the representation contains at least one styled_item or assures that the representation that has a name of 'zone shape' does not include an origin or orientation. 
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE shape_representation_requires_origin FOR (shape_representation);
WHERE
  WR1: 
(* 
pseudocode
co:FOREACH (sr <* shape_representation |c1);
c1:EXACTLYONE(it <* sr\representation.items |c2) 
   or ATLEASTONE(it <* sr\representation.items |c3)
   or EXACTLYNONE(it <* sr\representation.items |c4);
c2:((it.name = 'origin') or (it.name = 'orientation')) and 
   (AXIS2_PLACEMENT_2D in TYPEOF(it)  OR
    AXIS2_PLACEMENT_3D in TYPEOF(it));
c3:STYLED_ITEM in TYPEOF(it);
c4:((it.name = 'origin') or (it.name = 'orientation')) and
   ((sr.name = 'zone shape') or 
   (sr.context_of_items.context_type = 'connection zone colour'));
*)
SIZEOF(QUERY ( sr <* shape_representation |  NOT(
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and 
   (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it))  OR
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'AXIS2_PLACEMENT_2D' in TYPEOF(it)))
))) = 1
) 
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
   ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
    'STYLED_ITEM' in TYPEOF(it))
))) >= 1
)
OR
(SIZEOF(QUERY ( it <* sr\representation.items | (
((it\representation_item.name = 'origin') or (it\representation_item.name = 'orientation')) and
   ((sr\representation.name = 'zone shape') or 
   (sr.context_of_items\representation_context.context_type = 'connection zone colour'))
))) = 0
)
))) = 0;
END_RULE; -- shape_representation_requires_origin
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
For each instance of shape_representation, there shall be exactly one instance of placement in the role of items that contains the attribute value 'origin' for the name of that axis_placement or there shall be at least one instance of placement in the role of items that contains the attribute value 'orientation' for the name of that axis_placement or ther shall be at least one instance of styled_item in the role of items.  The instance of placement shall be either an axis2_placement_2d or an axis2_placement_3d.  There shall be no instance of placement with name of origin or orientation in a shape_representation with a name of 'zone shape' or with a context type of 'connection zone colour'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="shield_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The shield_allocation_constraint rule constrains the related and relating
product_definition of a product_definition_relationship when it is a
shield allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship whose 
{name = 'assembly requirements allocation'} 
{description = 'shield allocation'} shall have a related_product_definition that
{is a shield} {is the related_product_definition of a 
product_definition_relationship whose name = 'shield group member'} 
{has a frame_of_reference that is a product_definition_context whose name = 
'physical occurrence'}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship whose 
{name = 'assembly requirements allocation'} 
{description = 'shield allocation'} shall have a relating_product_definition that
{is the relating_product_definition of a product_definition_relationship whose 
 name = 'shield group member'} 
{is the definition of a requirement_property whose name = 
 'electromagnetic requirement'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="signal_property_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The signal_property_constraint rule constrains the definition and usage of
a property_definition when it is a signal property.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
IF a property_definition.name = 'signal property' THEN SELF.definition shall 
be a signal.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF a property_definition.name = 'signal property' THEN (SELF.definition shall 
be a signal which is an items of an applied_classification_assignment whose 
assigned_group is a signal_category.description = 'signal property category') 
(SELF shall be an items of an applied_document_reference whose 
assigned_document is the source of a document_usage_constraint whose 
subject_element = 'signal property category').
</Informal.propositions.rul>
<Informal.propositions.rul>
IF a property_definition.name = 'signal property' THEN SELF shall be the 
definition of exactly one property_definition_representation.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="signal_specification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The signal_specification_constraint rule constrains the items and usage of a
representation when it is a signal specification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall be the used_representation of a 
property_definition_representation whose definition.definition is a functional_unit.frame_of_reference.name = 
'functional network design'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification'
shall be the used_representation of a 
property_definition_representation whose whose definition.definition is a 
component_functional_unit.frame_of_reference.name = 'functional occurrence'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall have exactly one items.name = 'maximum characteristic'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall have exactly one items.name = 
'measurement access mechanism'
and whose definition.definition is a 
component_functional_terminal.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall have exactly one items.name = 
'reference access mechanism'
and whose definition.definition is a 
component_functional_terminal.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification' 
shall be an items of an 
applied_document_reference whose assigned_document is an ee_specification 
whose kind.product_data_type = 'test specification'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation that has a name = 'signal specification'
shall have exactly one items.name equal to  
'minimum characteristic' and shall be the used_representation of a 
property_definition_representation whose definition.name = 'signal property'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="singular_dimension_representation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The singular_dimension_representation_constraint rule constrains the use of a shape_dimension_representation when it is used as a singular dimension representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_dimension_representation that contains a measure_with_unit that is the qualified_measure of a measure_qualification that has the name of 'dimension value qualifier' and in which the qualifier is a type_qualifier with a name of 'theoretically exact', 'maximum dimension', or 'minimum dimension' shall contain exactly one measure_with_unit.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="step_edge_feature_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The step_edge_feature_shape_constraint rule constrains the items of a
shape_representation when it is a step edge feature shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE step_edge_feature_shape_constraint FOR ( shape_representation );
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step depth')
       )) = 1))) = 0; 
 WR2: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum step width')
       )) = 1))) = 0; 
 WR3: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step depth')
       )) = 1))) = 0; 
 WR4: SIZEOF(QUERY(sr <* shape_representation |
       (sr\representation.name = 'step edge feature shape')
       AND NOT(SIZEOF(QUERY(lmwu <* sr.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'minimum step width')
       )) = 1))) = 0; 
END_RULE; -- step_edge_feature_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'maximum step depth'.
</formal.propositions.rul>
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'maximum step width'.
</formal.propositions.rul>
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'minimum step depth'.
</formal.propositions.rul>
<formal.propositions.rul>
A shape_representation whose name = 'step edge feature shape' shall have 
exactly one items which is a length_measure_with_unit whose name = 
'minimum step width'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_3d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_3d_shape_constraint rule constrains the usage of a
shape_representation when it is a stratum_3d_shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_representation {whose name = '3d bound volume shape'} 
{whose context_of_items is a 
geometric_representation_context.coordinate_space_dimension = 3} 
{is the used_representation of a property_definition_representation whose 
definition.definition is a stratum} shall be the used_representation of
exactly one property_definition_shape whose definition is a stratum.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_average_surface_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_average_surface_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a stratum average surface shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_average_surface_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum average surface shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'STRATUM_SURFACE' IN TYPEOF(pdr.definition.definition))
       AND (pdr.definition.definition\shape_aspect.description = 
                                            'average surface'))) = 1
       ))) = 0;

END_RULE; -- stratum_average_surface_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'stratum average surface shape' shall be
the used_representation for exactly one property_definition_representation
that shall also have a definition that is a property_definition that shall also have a definition that is a stratum_surface with a 
description of 'average surface'.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_concept_to_physical_usage_view_assignment_constraint">
<RULE.DESCRIPTION>
The stratum_concept_to_physical_usage_view_assignment_constraint rule
constrains the related_shape_aspect of a shape_aspect_relationship of a
shape_aspect_relationship when it is a 
stratum_concept_to_physical_usage_view_assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship whose name = 'stratum concept to physical usage view assignment' shall have a 
related_shape_aspect (which is a stratum_feature) (which is an 
inter_stratum_feature) (which is a component_shape_aspect whose description = 
'laminate component') (whose of_shape.definition {is a component_definition} 
{has a frame_of_reference.name = 'physical occurrence'} 
{has a name = 'laminate component'}).
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_in_stratum_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_in_stratum_3d_position_constraint rule constrains the
mapping_source, mapping_target, and usage of a mapped_item when it is a
stratum_feature_in_stratum_3d_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and
has a mapping_target that is a axis2_placement_3d shall 
have a mapping_source.mapped_representation that is the used_representation 
of a property_definition_representation.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and 
has a mapping_target that is a axis2_placement_3d shall 
be an items of a shape_representation {whose name = '3d bound volume shape'} 
{is the used_representation of a 
property_definition_representation whose {definition is a 
product_definition_shape} 
{definition.definition is a stratum} }.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_in_stratum_planar_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_in_stratum_planar_position_constraint rule constrains the
mapping_source, mapping_target, and usage of a mapped_item when it is a
stratum_feature_in_stratum_planar_position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and 
has a mapping_target that is an axis2_placement_2d shall
have a mapping_source.mapped_representation that is the used_representation 
of a property_definition_representation.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item whose name = 'positioned stratum feature in stratum' and 
has a mapping_target that is an axis2_placement_2d shall
be an items of a shape_representation {whose name = 'planar projected shape'} 
{is the used_representation of a property_definition_representation whose 
{definition is a product_definition_shape} 
{definition.definition is a stratum} }.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_non_planar_2d_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_non_planar_2d_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a stratum feature non planar 2d shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_feature_non_planar_2d_shape_constraint FOR 
( manifold_surface_shape_representation );
WHERE
  WR1: SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |
       (mssr\representation.name = 'stratum feature non planar 2d shape')
       AND NOT (
       SIZEOF(QUERY(pdr <* USEDIN(mssr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
        + 'STRATUM_FEATURE' IN TYPEOF(pdr.definition.definition))
       )) = 1
       ))) = 0;
END_RULE; -- stratum_feature_non_planar_2d_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'stratum feature non planar 2d shape' shall be
the used_representation for exactly one property_definition_representation
that shall also have a definition that is a property_definition that shall
also have a definition that is a stratum_feature.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_shape_stratum_average_surface_shape_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_shape_stratum_average_surface_shape_relationship_constraint rule 
constrains representation_relationship when it is used as a stratum
feature shape stratum average surface shape relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE 
stratum_feature_shape_stratum_average_surface_shape_relationship_constraint
 FOR 
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
'stratum feature shape stratum average surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum average surface shape')
       ))) = 0;
END_RULE; -- stratum_feature_shape_stratum_average_surface_-
          -- shape_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum average surface shape relationship' shall have
a rep_2 that is a manifold_surface_shape_representation with a name of 
'stratum feature non planar 2d shape'.
</formal.propositions.rul>

<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum average surface shape relationship' shall have
a rep_1 that is a manifold_surface_shape_representation with a name of 
'stratum average surface shape'.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_shape_stratum_surface_shape_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_shape_stratum_surface_shape_relationship_constraint rule 
constrains representation_relationship when it is used as a stratum
feature shape stratum surface shape relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR
( representation_relationship );
WHERE
  WR1: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
        'stratum feature shape stratum surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))
       AND (rr.rep_2\representation.name = 'stratum feature non planar 2d shape')
       ))) = 0;
  WR2: SIZEOF(QUERY(rr <* representation_relationship |
       (rr\representation_relationship.name = 
            'stratum feature shape stratum surface shape relationship')
       AND NOT(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))
       AND (rr.rep_1\representation.name = 'stratum surface shape')
       ))) = 0;
END_RULE; -- stratum_feature_shape_stratum_surface_shape_relationship_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum surface shape relationship' shall have
a rep_2 that is a manifold_surface_shape_representation with a name of 
'stratum feature non planar 2d shape'.
</formal.propositions.rul>

<formal.propositions.rul>
A representation_relationship with a name of 
'stratum feature shape stratum surface shape relationship' shall have
a rep_1 that is a manifold_surface_shape_representation with a name of 
'stratum surface shape'.
</formal.propositions.rul>

</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_feature_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_feature_unique_constraint rule constrains the stratum_feature population members,
that fill the role of ARM stratum_feature, to be have unique names on each stratum.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_feature_unique_constraint FOR
 ( stratum_feature );
LOCAL
  sf_bag : BAG OF stratum_feature;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_feature) by 1;
  IF EXISTS( stratum_feature[i].of_shape.definition ) THEN
    IF( NOT( stratum_feature[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_feature[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sf_bag := QUERY( r <* stratum_feature | 
             (r.of_shape.definition :=: s_bag[i]) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sf_bag) by 1;
    IF EXISTS( sf_bag[j]\shape_aspect.name ) THEN
      IF ( sf_bag[j]\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sf_bag[j]\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- stratum_feature_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of stratum_feature that has a common stratum
must have a unique name attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_interconnect_module_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_interconnect_module_3d_position_constraint rule constrains the
mapping_target, mapping_source and use of a mapped_item when it is a
3d positioned stratum shape in interconnect module.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = '3d positioned stratum shape in interconnect module')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE; -- stratum_interconnect_module_3d_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect
module' shall have a mapping_target that is an axis2_placement_3d.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect
module' shall be an items in exactly one representation that is related to an
assembly_component_usage that has a name = 'interconnect module stratum
assembly relationship'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect
module' shall have a mapping_target that is an items of exactly one
representation [that has a name = '3d bound volume shape'] [that is a
shape_representation] [is related to a product that is an interconnect
module].
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = '3d positioned stratum shape in interconnect module' shall have a mapping_source.mapped_representation that [is a
shape_representation] [has a name = '3d bound volume shape'] [is related to
a stratum].
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_interconnect_module_planar_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_interconnect_module_planar_position_constraint rule constrains the
mapping_target, mapping_source and use of a mapped_item when it is a
planar positioned stratum shape in interconnect module.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_interconnect_module_planar_position_constraint FOR 
          (mapped_item);
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 
          'planar positioned stratum shape in interconnect module')
    AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE; -- stratum_interconnect_module_planar_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall have a mapping_target that is an axis2_placement_2d.
</formal.propositions.rul>
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall be an items in exactly one representation that is 
related to an assembly_component_usage that has a name = 'interconnect module 
stratum assembly relationship'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall have a mapping_target that is an items of exactly one
representation [that has a name = 'planar projected shape'] [that is a
shape_representation] [is related to a product that is an interconnect
module].
</Informal.propositions.rul>
<Informal.propositions.rul>
Each mapped_item that has a name = 'planar positioned stratum shape in 
interconnect module' shall have a mapping_source.mapped_representation that 
[is a shape_representation] [has a name = 'planar projected shape'] 
[is related to a stratum].
</Informal.propositions.rul>
<Informal.propositions.rul>
The interconnect referenced by the assembly shape shall be the same interconnect that is referenced by the interconnect to stratum assembly relationship.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_make_from_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_make_from_relationship_constraint rule constrains the related
and relating product_definition for a make_from_usage_option when it is a
stratum make from relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_make_from_relationship_constraint FOR
(make_from_usage_option);
WHERE
  WR1: SIZEOF(QUERY(mfuo <* make_from_usage_option |
       (mfuo\product_definition_relationship.name = 'stratum make from')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(mfuo.related_product_definition)
       ))) = 0;
  WR2: SIZEOF(QUERY(mfuo <* make_from_usage_option |
       (mfuo\product_definition_relationship.name = 'stratum make from')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(mfuo.relating_product_definition)
       ))) = 0;
END_RULE; -- stratum_make_from_relationship_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each make_from_usage_option that has a name = 'stratum make from' shall
have its related_product_definition satisfied by a stratum.
</formal.propositions.rul>
<formal.propositions.rul>
Each make_from_usage_option that has a name = 'stratum make from' shall 
have its relating_product_definition satisfied by a stratum.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_planar_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_planar_shape_constraint rule requires each shape_representation
to be related to an axis2_placement_2d and a product_definition_shape
when it is implementing the arm concept
of <internal.ref linkend="Stratum_planar_shape">.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_planar_shape_constraint FOR (shape_representation);
WHERE
  WR1: SIZEOF(QUERY(sr <* shape_representation |
       NOT( NOT ((sr\representation.name = 'planar projected shape') AND 
       (SIZEOF(QUERY(pdr <* USEDIN(sr,
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION') |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STRATUM' IN TYPEOF(pdr.definition.definition))
       )) = 1))
       OR (SIZEOF(QUERY(a2p2d <* sr.items |
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_2D' IN TYPEOF(a2p2d))
       )) >= 0)))) = 0;
END_RULE; -- stratum_planar_shape_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each shape_representation that [has a name = 'planar projected shape']
[is related to a stratum through a property_definition_representation] shall
have at least one items satisfied by an axis2_placement_2d.
</formal.propositions.rul>
</formal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_surface_in_stratum_3d_position_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_surface_in_stratum_3d_position_constraint
rule constrains mapped_item when it is used as a
stratum surface in stratum 3d position.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_surface_in_stratum_3d_position_constraint FOR 
( mapped_item );
WHERE
  WR1: SIZEOF(QUERY(mi <* mapped_item |
       (mi\representation_item.name = 'stratum surface in stratum 3d position')
       AND NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))
       )) = 0;
END_RULE; -- stratum_surface_in_stratum_3d_position_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each mapped_item with a name of
'stratum surface in stratum 3d position' shall
have a mapping_target that is a axis2_placement_3d.
</formal.propositions.rul>

</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each mapped_item with a name of
'stratum surface in stratum 3d position' shall
be an item for a shape_representation with a name of
'3d bound volume shape' that is the used_representation
of a property_definiton_representation with a definition
that is a product_definition_shape with a definition
that is a stratum.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each mapped_item with a name of
'stratum surface in stratum 3d position' shall
have a mapping_source that has a mapped_representation
that is a manifold_surface_shape_representation with
a name of 'stratum surface shape' or 'stratum average surface shape'.
</Informal.propositions.rul>

</Informal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_surface_shape_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_surface_shape_constraint rule constrains
manifold_surface_shape_representation
when it is used as a stratum surface shape.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each manifold_surface_shape_representation with a name of
'stratum surface shape' shall be
the used_representation for exactly one property_definition
that shall have a definition that is a stratum_surface with a 
description of 'primary surface' or 'secondary surface'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_surface_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_surface_unique_constraint rule constrains the stratum_surface population members,
that fill the role of ARM stratum_surface, to be have unique descriptions on each stratum.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_surface_unique_constraint FOR
 ( stratum_surface );
LOCAL
  ss_bag : BAG OF stratum_surface;
  s_bag : BAG OF stratum := [];
  pass : BOOLEAN := TRUE;
  desc_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(stratum_surface) by 1;
  IF EXISTS( stratum_surface[i].of_shape.definition ) THEN
    IF( NOT( stratum_surface[i].of_shape.definition IN s_bag ) ) THEN
      s_bag := s_bag + stratum_surface[i].of_shape.definition;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(s_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  ss_bag := QUERY( r <* stratum_surface | 
               (r.of_shape.definition :=: s_bag[i]) );
  desc_bag := [];
  REPEAT j := 1 to SIZEOF(ss_bag) by 1;
    IF EXISTS( ss_bag[j]\shape_aspect.description ) THEN
      IF ( ss_bag[j]\shape_aspect.description IN desc_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        desc_bag := desc_bag + ss_bag[j]\shape_aspect.description;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- stratum_surface_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of stratum_surface that has a common stratum
must have a unique description attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="stratum_technology_line_width_tolerance_assignment_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The stratum_technology_line_width_tolerance_assignment_constraint rule
constrains the items and use of a representation when it is a
stratum technology line width tolerance assignment.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE stratum_technology_line_width_tolerance_assignment_constraint FOR
(representation);
WHERE
  WR1: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(lmwu <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum positive deviation')
       )) = 1))) = 0;
  WR2: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(si <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'STYLED_ITEM' IN TYPEOF (si))
       )) = 1))) = 0;
  WR3: SIZEOF(QUERY(rep <* representation |
       (rep\representation.name = 'stratum technology line width tolerance assignment')
       AND NOT(SIZEOF(QUERY(lmwu <* rep.items | 
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
       + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF (lmwu))
       AND (lmwu\representation_item.name = 'maximum negative deviation')
       )) = 1))) = 0;
END_RULE; -- stratum_technology_line_width_tolerance_assignment_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Each representation that has a name = 'stratum technology line width
tolerance assignment' shall have exactly one items {that is a
length_measure_with_unit} {has a name = 'maximum positive deviation'}.
</formal.propositions.rul> 
<formal.propositions.rul> 
Each representation that has a name = 'stratum technology line width 
tolerance assignment' shall have exactly one items that is a styled_item.
</formal.propositions.rul>  
<formal.propositions.rul>  
Each representation that has a name = 'stratum technology line width  
tolerance assignment' shall have exactly one items {that is a
length_measure_with_unit} {has a name = 'maximum negative deviation'}.
</formal.propositions.rul>   
</formal.propositions>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation that has a name = 'stratum technology line width
tolerance assignment' shall be related to exactly one stratum_technology.
</Informal.propositions.rul>
<Informal.propositions.rul>   
Each representation that has a name = 'stratum technology line width   
tolerance assignment' shall be related to a physical_unit that {has
a frame_of_reference.name = 'physical design'} {has a
formation.of_product that is a product that is part of a product_category
with a name = 'interconnect module'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="substitute_product_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The substitute_product_constraint rule requires all product entities that
are base products to be related to a substitute product and that all
assembly_component_usage entities in the role of a substitute in
an assembly_component_usage_substitute have no reference_designator 
attribute.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE substitute_product_constraint FOR (product,
assembly_component_usage_substitute);
WHERE
  WR1: SIZEOF(QUERY(acus <* assembly_component_usage_substitute |
       EXISTS(acus.substitute.reference_designator))) = 0;
END_RULE; -- substitute_product_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">

<formal.propositions.rul>
Each assembly_component_usage_substitute shall have a substitute that
does not have a reference_designator.
</formal.propositions.rul>

</formal.propositions>

<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product that is the formation.of_product of a product_definition that
is related to an assembly_component_usage as a base shall be related to
another product that is the formation.of_product of a product_definition
that is related to an assembly_component_usage as a substitute.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_combination_action_assignment">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_combination_action_assignment rule requires that only the
following combinations of action_assignment entities are allowed:
<list>
<list.item>applied_action_assignment by itself</list.item>
<list.item>applied_action_assignment in conjunction with change</list.item>
<list.item>applied_action_assignment in conjunction with start_work</list.item>
<list.item>change by itself</list.item>
<list.item>start_work by itself</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>

<Informal.Propositions rule.types = "IP">
<Informal.Propositions.rul>
An action_assignment must be an applied_action_assignment, change, start_work,
applied_action_assignment in conjunction with change, or
applied_action_assignment in conjunction with start_work.
</Informal.Propositions.rul>
</Informal.Propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<!--
*)
(*

WR1: An instance of action_assignment shall be at most one of type change,
start_work.  This allows for an applied_action_assignment to be a change
or a start_work.

*)
(*
-->

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_combination_shape_aspect">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_combination_shape_aspect rule requires all shape_aspect entities to 
be at most one of the following:
<list>
<list.item>assembly_bond_definition</list.item>
<list.item>assembly_joint</list.item>
<list.item>assembly_module_terminal</list.item>
<list.item>minimally_defined_bare_die_terminal</list.item>
<list.item>component_functional_terminal</list.item>
<list.item>component_interface_terminal</list.item>
<list.item>component_shape_aspect</list.item>
<list.item>component_terminal</list.item>
<list.item>datum_reference_frame</list.item>
<list.item>datum_system</list.item>
<list.item>derived_shape_aspect</list.item>
<list.item>device_terminal_map</list.item>
<list.item>fabrication_joint</list.item>
<list.item>functional_unit_terminal_definition</list.item>
<list.item>group_shape_aspect</list.item>
<list.item>interconnect_module_terminal</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>join_shape_aspect</list.item>
<list.item>land_template_terminal</list.item>
<list.item>layer</list.item>
<list.item>layer_connection_point</list.item>
<list.item>mounting_restriction_area</list.item>
<list.item>package_body</list.item>
<list.item>package_terminal</list.item>
<list.item>packaged_connector_terminal_relationship</list.item>
<list.item>packaged_part_terminal</list.item>
<list.item>part_connected_terminals_definition</list.item>
<list.item>part_template_definition</list.item>
<list.item>passage_technology</list.item>
<list.item>physical_connectivity_definition</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>physical_network</list.item>
<list.item>positional_boundary</list.item>
<list.item>positional_boundary_member</list.item>
<list.item>printed_part_cross_section_template_terminal</list.item>
<list.item>printed_part_template_connected_terminals_definition</list.item>
<list.item>printed_part_template_terminal</list.item>
<list.item>sequential_laminate_passage_based_fabrication_joint</list.item>
<list.item>shape_modification</list.item>
<list.item>stratum_concept_relationship</list.item>
<list.item>stratum_feature</list.item>
<list.item>stratum_surface</list.item>
<list.item>tolerance_zone</list.item>
<list.item>tolerance_zone_boundary</list.item>
<list.item>viewing_plane</list.item>
</list>

The subtype_combination_shape_aspect rule also requires all shape_aspect entities to be at most one of the following:
<list>
<list.item>assembly_bond_definition</list.item>
<list.item>assembly_joint</list.item>
<list.item>assembly_module_terminal</list.item>
<list.item>minimally_defined_bare_die_terminal</list.item>
<list.item>component_functional_terminal</list.item>
<list.item>component_interface_terminal</list.item>
<list.item>component_shape_aspect</list.item>
<list.item>component_terminal</list.item>
<list.item>datum_reference_frame</list.item>
<list.item>datum_system</list.item>
<list.item>device_terminal_map</list.item>
<list.item>fabrication_joint</list.item>
<list.item>functional_unit_terminal_definition</list.item>
<list.item>group_shape_aspect</list.item>
<list.item>interconnect_module_terminal</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>join_shape_aspect</list.item>
<list.item>land_template_terminal</list.item>
<list.item>layer</list.item>
<list.item>layer_connection_point</list.item>
<list.item>mounting_restriction_area</list.item>
<list.item>package_body</list.item>
<list.item>package_terminal</list.item>
<list.item>packaged_connector_terminal_relationship</list.item>
<list.item>packaged_part_terminal</list.item>
<list.item>part_connected_terminals_definition</list.item>
<list.item>part_template_definition</list.item>
<list.item>passage_technology</list.item>
<list.item>physical_connectivity_definition</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>physical_network</list.item>
<list.item>physical_unit_datum</list.item>
<list.item>positional_boundary</list.item>
<list.item>positional_boundary_member</list.item>
<list.item>printed_part_cross_section_template_terminal</list.item>
<list.item>printed_part_template_connected_terminals_definition</list.item>
<list.item>printed_part_template_terminal</list.item>
<list.item>sequential_laminate_passage_based_fabrication_joint</list.item>
<list.item>shape_modification</list.item>
<list.item>stratum_concept_relationship</list.item>
<list.item>stratum_feature</list.item>
<list.item>stratum_surface</list.item>
<list.item>tolerance_zone</list.item>
<list.item>tolerance_zone_boundary</list.item>
<list.item>viewing_plane</list.item>
</list>

Additionally, the subtype_combination_shape_aspect rule requires all 
shape_aspect entities to be at most one of the following:
<list>
<list.item>assembly_bond_definition</list.item>
<list.item>assembly_joint</list.item>
<list.item>component_functional_terminal</list.item>
<list.item>component_interface_terminal</list.item>
<list.item>component_shape_aspect</list.item>
<list.item>component_terminal</list.item>
<list.item>datum_reference_frame</list.item>
<list.item>datum_system</list.item>
<list.item>derived_shape_aspect</list.item>
<list.item>device_terminal_map</list.item>
<list.item>fabrication_joint</list.item>
<list.item>functional_unit_terminal_definition</list.item>
<list.item>group_shape_aspect</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>join_shape_aspect</list.item>
<list.item>land_template_terminal</list.item>
<list.item>layer</list.item>
<list.item>layer_connection_point</list.item>
<list.item>mounting_restriction_area</list.item>
<list.item>package_body</list.item>
<list.item>part_connected_terminals_definition</list.item>
<list.item>part_template_definition</list.item>
<list.item>passage_technology</list.item>
<list.item>physical_connectivity_definition</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>physical_network</list.item>
<list.item>physical_unit_datum_feature</list.item>
<list.item>physical_unit_datum_target</list.item>
<list.item>positional_boundary</list.item>
<list.item>positional_boundary_member</list.item>
<list.item>printed_part_cross_section_template_terminal</list.item>
<list.item>printed_part_template_connected_terminals_definition</list.item>
<list.item>printed_part_template_terminal</list.item>
<list.item>sequential_laminate_passage_based_fabrication_joint</list.item>
<list.item>shape_modification</list.item>
<list.item>stratum_concept_relationship</list.item>
<list.item>stratum_feature</list.item>
<list.item>stratum_surface</list.item>
<list.item>tolerance_zone</list.item>
<list.item>tolerance_zone_boundary</list.item>
<list.item>viewing_plane</list.item>
</list>

Finally, the subtype_combination_shape_aspect rule requires each 
shape_aspect entity to be at most one of the following:
<list>
<list.item>physical_unit_datum_feature</list.item>
<list.item>physical_unit_datum_target</list.item>
<list.item>physical_unit_datum</list.item>
</list>
<note>
The inclusion of a subtype of shape_aspect in three conjuctive subclauses of this rule should 
only be interpreted as an additional degree of freedom for those subtypes that
are not repeated.  A logically equivalent formulation of this rule would include all
repeated subtypes only in a fifth conjuctive subclause.
</note>
<example>
A shape_aspect subtype may be exchanged that is a combination of stratum_surface
and physical_unit_datum_feature, but not one that is a combination of
stratum_surface, physical_unit_datum_feature and physical_unit_datum.
</example>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_combination_shape_aspect FOR (shape_aspect);
WHERE
  WR1: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DERIVED_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR2: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MINIMALLY_DEFINED_BARE_DIE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERCONNECT_MODULE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_PART_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR3: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_BOND_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_INTERFACE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATUM_REFERENCE_FRAME',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DERIVED_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'FUNCTIONAL_UNIT_TERMINAL_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'JOIN_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAND_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'LAYER_CONNECTION_POINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MOUNTING_RESTRICTION_AREA',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGE_BODY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PART_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PASSAGE_TECHNOLOGY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_NETWORK',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'POSITIONAL_BOUNDARY_MEMBER',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRINTED_PART_TEMPLATE_TERMINAL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_MODIFICATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_SURFACE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TOLERANCE_ZONE_BOUNDARY',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'VIEWING_PLANE']
       * TYPEOF(sa)) <= 1))) = 0;

  WR4: SIZEOF (QUERY (sa <* shape_aspect |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_FEATURE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_DATUM_TARGET',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'PHYSICAL_UNIT_DATUM']
       * TYPEOF(sa)) <= 1))) = 0;

END_RULE; -- subtype_combination_shape_aspect
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system, derived_shape_aspect, 
device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interconnect_module_terminal, 
interface_mounted_join, join_shape_aspect, land_template_terminal, layer, layer_connection_point, 
mounting_restriction_area, package_body, package_terminal, packaged_connector_terminal_relationship, 
packaged_part_terminal, part_connected_terminals_definition, part_template_definition, 
passage_technology, physical_connectivity_definition, physical_connectivity_element, physical_network, 
positional_boundary, positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.
</formal.propositions.rul>

<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system,
device_terminal_map, fabrication_joint, functional_unit_terminal_definition, group_shape_aspect, 
interconnect_module_terminal, interface_mounted_join, join_shape_aspect, land_template_terminal, 
layer, layer_connection_point, mounting_restriction_area, package_body, package_terminal, 
packaged_connector_terminal_relationship, packaged_part_terminal, part_connected_terminals_definition, 
part_template_definition, passage_technology, physical_connectivity_definition, 
physical_connectivity_element, physical_network, physical_unit_datum, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.
</formal.propositions.rul>

<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, component_functional_terminal, component_interface_terminal, 
component_shape_aspect, component_terminal, datum_reference_frame, 
datum_system, derived_shape_aspect, device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interface_mounted_join, join_shape_aspect, 
land_template_terminal, layer, layer_connection_point, mounting_restriction_area, package_body, 
part_connected_terminals_definition, part_template_definition, passage_technology, 
physical_connectivity_definition, physical_connectivity_element, physical_network, 
physical_unit_datum_feature, physical_unit_datum_target, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.
</formal.propositions.rul>

<formal.propositions.rul>
Every instance of shape_aspect shall be at most one of physical_unit_datum_feature, 
physical_unit_datum_target, or physical_unit_datum.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<!--
*)
(*

WR1: Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system, derived_shape_aspect,
device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interconnect_module_terminal, 
interface_mounted_join, join_shape_aspect, land_template_terminal, layer, layer_connection_point, 
mounting_restriction_area, package_body, package_terminal, packaged_connector_terminal_relationship, 
packaged_part_terminal, part_connected_terminals_definition, part_template_definition, 
passage_technology, physical_connectivity_definition, physical_connectivity_element, physical_network, 
positional_boundary, positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.

WR2: Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, assembly_module_terminal, minimally_defined_bare_die_terminal, component_functional_terminal, 
component_interface_terminal, component_shape_aspect, component_terminal, 
datum_reference_frame, datum_system,
device_terminal_map, fabrication_joint, functional_unit_terminal_definition, group_shape_aspect, 
interconnect_module_terminal, interface_mounted_join, join_shape_aspect, land_template_terminal, 
layer, layer_connection_point, mounting_restriction_area, package_body, package_terminal, 
packaged_connector_terminal_relationship, packaged_part_terminal, part_connected_terminals_definition, 
part_template_definition, passage_technology, physical_connectivity_definition, 
physical_connectivity_element, physical_network, physical_unit_datum, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.

WR3: Every instance of shape_aspect shall be at most one of assembly_bond_definition, 
assembly_joint, component_functional_terminal, component_interface_terminal, 
component_shape_aspect, component_terminal, datum_reference_frame, 
datum_system, derived_shape_aspect, device_terminal_map, fabrication_joint, 
functional_unit_terminal_definition, group_shape_aspect, interface_mounted_join, join_shape_aspect, 
land_template_terminal, layer, layer_connection_point, mounting_restriction_area, package_body, 
part_connected_terminals_definition, part_template_definition, passage_technology, 
physical_connectivity_definition, physical_connectivity_element, physical_network, 
physical_unit_datum_feature, physical_unit_datum_target, positional_boundary, 
positional_boundary_member, printed_part_cross_section_template_terminal, 
printed_part_template_connected_terminals_definition, printed_part_template_terminal, 
sequential_laminate_passage_based_fabrication_joint, shape_modification, stratum_concept_relationship, 
stratum_feature, stratum_surface, tolerance_zone, tolerance_zone_boundary, or viewing_plane.

WR4: Every instance of shape_aspect shall be at most one of physical_unit_datum_feature, 
physical_unit_datum_target, or physical_unit_datum.

*)
(*
-->

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_action_request_assignment">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_action_request_assignment rule requires all
action_request_assignment entities to be at most one of change_request or
start_request.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_action_request_assignment FOR 
  (action_request_assignment);
WHERE
  WR1: SIZEOF (QUERY (ara <* action_request_assignment |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CHANGE_REQUEST',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'START_REQUEST']
       * TYPEOF(ara)) <= 1))) = 0;
END_RULE;  -- subtype_exclusive_action_request_assignment
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
An instance of action_request_assignment shall be at most one of type
change_request, or start_request.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_dimensional_location">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_dimensional_location rule requires all 
dimensional_location entities to be at most one of the following:
<list>
<list.item>angular_dimension_with_orientation</list.item>
<list.item>dimensional_location_with_direction</list.item>
<list.item>dimensional_location_with_path</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_dimensional_location FOR
  (dimensional_location);
WHERE  
  WR1: SIZEOF (QUERY (dl <* dimensional_location |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANGULAR_DIMENSION_WITH_ORIENTATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION_WITH_PATH']
       * TYPEOF(dl)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_dimensional_location
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of dimensional_location shall be at most one of 
angular_dimension_with_orientation, dimensional_location_with_direction, or 
dimensional_location_with_path.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_dimensional_size">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_dimensional_size rule requires all dimensional_size 
entities to be at most one of curve_dimension, or angular_size; and at most 
one of curve_dimension, or opposing_boundary_dimensional_size.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_dimensional_size FOR
  (dimensional_size);
WHERE  
  WR1: SIZEOF (QUERY (ds <* dimensional_size |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CURVE_DIMENSION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANGULAR_SIZE']
       * TYPEOF(ds)) <= 1) OR
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CURVE_DIMENSION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE']
       * TYPEOF(ds)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_dimensional_size
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of dimensional_size shall be at most one of
curve_dimension, or angular_size and at most one of curve_dimension,
or opposing_boundary_dimensional_size.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_mapped_item">
<RULE.DESCRIPTION>
The subtype_exclusive_mapped_item rule requires all mapped_item entities to
be at most one of annotation_text or annotation_symbol.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_mapped_item FOR (mapped_item);
WHERE
  WR1: SIZEOF (QUERY (mi <* mapped_item |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANNOTATION_TEXT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ANNOTATION_SYMBOL'] *
       TYPEOF(mi)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_mapped_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of mapped_item shall be at most one of type annotation_text
or annotation_symbol.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_measure_with_unit">
<RULE.DESCRIPTION>
The subtype_exclusive_measure_with_unit rule requires all measure_with_unit entities to be at most one of the defined subtypes.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of measure_with_unit shall be at most one of any subtype of measure_with_unit.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_product_definition">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_product_definition rule requires all product_definition
entities to be at most one of the following:
<list>
<list.item>component_definition</list.item>
<list.item>component_functional_unit</list.item>
<list.item>functional_unit</list.item>
<list.item>network_node_definition</list.item>
<list.item>physical_unit or stratum</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_product_definition FOR (product_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* product_definition |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BUS_STRUCTURAL_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_DEFINITION', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'NETWORK_NODE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_product_definition
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of product_definition shall be at most one of type
bus_structural_definition, component_definition,
component_functional_unit, functional_unit, network_node_definition,
physical_unit or stratum.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_product_definition_relationship">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_product_definition_relationship rule requires all
product_definition_relationship entities be at most one of the following:
<list>
<list.item>product_definition-usage</list.item>
<list.item>material_composition_relationship</list.item>
<list.item>supplied_part_relationship</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_product_definition_relationship FOR
  (product_definition_relationship);
WHERE
  WR1: SIZEOF (QUERY (pdr <* product_definition_relationship |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_USAGE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SUPPLIED_PART_RELATIONSHIP']
       * TYPEOF(pdr)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_product_definition_relationship
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of product_definition_relationship shall be at most one of
type product_definition_usage, product_material_composition_relationship, or
supplied_part_relationship.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_property_definition">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_property_definition rule requires all 
property_definition entities to be at most one of the following:
<list>
<list.item>dimensional_size_property</list.item>
<list.item>geometric_tolerance_group</list.item>
<list.item>material_property</list.item>
<list.item>physical_unit_geometric_tolerance</list.item>
<list.item>product_definition_shape</list.item>
<list.item>requirements_property</list.item>
<list.item>signal</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_property_definition FOR
  (property_definition);
WHERE
  WR1: SIZEOF (QUERY (pd <* property_definition |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_SIZE_PROPERTY',   
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_TOLERANCE_GROUP', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_PROPERTY', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRODUCT_DEFINITION_SHAPE', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'REQUIREMENTS_PROPERTY', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SIGNAL']
       * TYPEOF(pd)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_property_definition
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of property_definition shall be at most one of
dimensional_size_property, geometric_tolerance_group, material_property,
physical_unit_geometric_tolerance,
product_definition_shape, requirements_property, or signal.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_property_definition_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_property_definition_representation rule requires all
property_definition_representation entities to be at most one of
shape_definition_representation or material_property_representation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_property_definition_representation FOR 
  (property_definition_representation);
WHERE
  WR1: SIZEOF (QUERY (pdr <* property_definition_representation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_DEFINITION_REPRESENTATION',   
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MATERIAL_PROPERTY_REPRESENTATION']
       * TYPEOF(pdr)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_property_definition_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of property_definition_representation shall be at most one of
type shape_definition_representation or material_property_representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_representation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_representation rule requires all representation
entities to be at most one of the following:
<list>
<list.item>analytical_model_port</list.item>
<list.item>component_location</list.item>
<list.item>rule_function_definition</list.item>
<list.item>structured_text_representation_item</list.item>
<list.item>text_string_representation</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_representation FOR 
  (representation);
WHERE
  WR1: SIZEOF (QUERY (rep <* representation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'ANALYTICAL_MODEL_PORT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPONENT_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_FUNCTION_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_STRING_REPRESENTATION']
       * TYPEOF(rep)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_representation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of representation shall be at most one of type
analytical_model_port, component_location, rule_function_definition,
structured_text_representation_item, or text_string_representation.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_representation_context">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_representation_context rule requires all
representation_context entities to be at most two of 
geometric_representation_context or parametric_representation_context or
one of structured_text_representation_context.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_representation_context FOR 
  (representation_context);
LOCAL
 pass : BOOLEAN := TRUE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(representation_context) by 1;
  pass := (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRUCTURED_TEXT_REPRESENTATION_CONTEXT' IN 
                          TYPEOF(representation_context[i]))
          OR (SIZEOF (TYPEOF(representation_context[i])) <= 2 )) 
       AND 
          (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
         * TYPEOF(representation_context[i])) <= 2 )) 
      AND
          (NOT ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT' IN 
                        TYPEOF(representation_context[i]))
          OR (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'GEOMETRIC_REPRESENTATION_CONTEXT', 
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PARAMETRIC_REPRESENTATION_CONTEXT'] 
        * TYPEOF(representation_context[i])) <= 2 ));
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- subtype_exclusive_representation_context
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
An instance of representation_context shall be at most one of type
geometric_representation_context or parametric_representation_context or
structured_text_representation_context. 
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_exclusive_shape_aspect_relationship">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_exclusive_shape_aspect_relationship rule requires all 
shape_aspect_relationship entities to be at most one of the following:
<list>
<list.item>assembly_joint</list.item>
<list.item>device_terminal_map</list.item>
<list.item>dimensional_location</list.item>
<list.item>interface_mounted_join</list.item>
<list.item>make_from_connectivity_relationship</list.item>
<list.item>make_from_feature_relationship</list.item>
<list.item>packaged_connector_terminal_relationship</list.item>
<list.item>physical_connectivity_element</list.item>
<list.item>shape_aspect_deriving_relationship</list.item>
<list.item>stratum_concept_relationship</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_exclusive_shape_aspect_relationship FOR 
  (shape_aspect_relationship);
WHERE
  WR1: SIZEOF (QUERY (sar <* shape_aspect_relationship |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_JOINT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DEVICE_TERMINAL_MAP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIMENSIONAL_LOCATION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'INTERFACE_MOUNTED_JOIN',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_CONNECTIVITY_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_FEATURE_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_CONNECTIVITY_ELEMENT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SHAPE_ASPECT_DERIVING_RELATIONSHIP',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'STRATUM_CONCEPT_RELATIONSHIP']
       * TYPEOF(sar)) <= 1))) = 0;
END_RULE; -- subtype_exclusive_shape_aspect_relationship
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of shape_aspect_relationship shall be at most one of
assembly_joint, device_terminal_map, dimensional_location,
interface_mounted_join, make_from_connectivity_relationship,
make_from_feature_relationship, packaged_connector_terminal_relationship, 
physical_connectivity_element, shape_aspect_deriving_relationship,
or stratum_concept_relationship.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_action">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_action requires all action entities to be either:
<list>
<list.item>directed_action</list.item>
<list.item>executed_action</list.item>
<list.item>rule_action</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_action FOR (action);
WHERE
  WR1: SIZEOF (QUERY (act <* action |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DIRECTED_ACTION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXECUTED_ACTION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_ACTION'] * 
       TYPEOF(act)) = 1))) = 0;
END_RULE; -- subtype_mandatory_action
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of action shall be of type directed_action, executed_action or a
rule_action.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_address">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_address rule requires all address entities to be either
personal_address or organizational_address.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_address FOR (address);
WHERE
  WR1: SIZEOF (QUERY (add <* address |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PERSONAL_ADDRESS',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ORGANIZATIONAL_ADDRESS'] * 
       TYPEOF (add)) = 1))) = 0;
END_RULE; -- subtype_mandatory_address
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of colour shall be of type colour_rgb.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_composite_shape_aspect">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_composite_shape_aspect rule requires all composite_shape_aspect entities to 
be either composite_group_shape_aspect, or composite_unit_shape_aspect.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_composite_shape_aspect FOR
  (composite_shape_aspect);
WHERE  
  WR1: SIZEOF (QUERY (csa <* composite_shape_aspect |
       NOT (SIZEOF
       (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPOSITE_GROUP_SHAPE_ASPECT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'COMPOSITE_UNIT_SHAPE_ASPECT']
       * TYPEOF(csa)) = 1))) = 0;
END_RULE; -- subtype_mandatory_composite_shape_aspect
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of composite_shape_aspect shall be either a
composite_group_shape_aspect or a composite_unit_shape_aspect.
<note>
Other subtypes of composite_shape_aspect will form a complex instance with one of the above
designated subtypes.
</note>
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_compound_representation_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_compound_representation_item rule requires all compound_representation_item entities
to be data_set_representation_item or table_representation_item.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_compound_representation_item FOR (compound_representation_item);
WHERE
  WR1: SIZEOF (QUERY (tl <* compound_representation_item |
       NOT ((
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'DATA_SET_REPRESENTATION_ITEM' IN TYPEOF (tl)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TABLE_REPRESENTATION_ITEM' IN
       TYPEOF(tl))))) = 0;
END_RULE; -- subtype_mandatory_compound_representation_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of compound_representation_item shall be of type data_set_representation_item or of type table_representation_item.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_date">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_date rule requires all date entities to be calendar_date.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_date FOR (date);
WHERE
  WR1: SIZEOF (QUERY (d <* date |
       NOT (
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'CALENDAR_DATE'
       IN TYPEOF (d)))) = 0;
END_RULE; -- subtype_mandatory_date
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of date shall be of type calendar_date.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_externally_defined_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_externally_defined_item rule requires all
externally_defined_item entities to be either:
<list>
<list.item>bond_category</list.item>
<list.item>external_definition</list.item>
<list.item>externally_defined_curve_font</list.item>
<list.item>externally_defined_functional_unit</list.item>
<list.item>externally_defined_hatch_style</list.item>
<list.item>externally_defined_physical_unit</list.item>
<list.item>externally_defined_representation_item</list.item>
<list.item>externally_defined_symbol</list.item>
<list.item>externally_defined_text_font</list.item>
<list.item>externally_defined_tile</list.item>
<list.item>externally_defined_tile_style</list.item>
<list.item>part_template_definition</list.item>
<list.item>rule_definition</list.item>
<list.item>signal_category</list.item>
</list>
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_externally_defined_item FOR 
                                       (externally_defined_item);
WHERE
  WR1: SIZEOF (QUERY (edi <* externally_defined_item |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'BOND_CATEGORY',  
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_CURVE_FONT',
--       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
--       'EXTERNALLY_DEFINED_FUNCTIONAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_HATCH_STYLE',
--       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
--       'EXTERNALLY_DEFINED_PHYSICAL_UNIT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
       'EXTERNALLY_DEFINED_REPRESENTATION_ITEM',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_SYMBOL',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TEXT_FONT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TILE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'EXTERNALLY_DEFINED_TILE_STYLE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PART_TEMPLATE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RULE_DEFINITION',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'SIGNAL_CATEGORY'] * 
       TYPEOF (edi)) = 1))) = 0;
END_RULE; -- subtype_mandatory_externally_defined_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of externally_defined_item shall be of a type identified in the list in the description of this rule. 
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_geometric_tolerance">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_geometric_tolerance rule requires all geometric_tolerance entities to be 
physical_unit_geometric_tolerance.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_geometric_tolerance FOR
  (geometric_tolerance);
WHERE  
  WR1: SIZEOF (QUERY (gt <* geometric_tolerance |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE'] *
       TYPEOF (gt)) = 1))) = 0;
END_RULE; -- subtype_mandatory_geometric_tolerance
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of geometric_tolerance shall be a
physical_unit_geometric_tolerance.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_pre_defined_item">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_pre_defined_item rule requires all pre_defined_item
entities to be either pre_defined_text_font or pre_defined_curve_font.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item);
WHERE
  WR1: SIZEOF (QUERY (pdi <* pre_defined_item |
       NOT (SIZEOF 
       (['ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_TEXT_FONT',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'PRE_DEFINED_CURVE_FONT'] *
       TYPEOF(pdi)) = 1))) = 0;
END_RULE; -- subtype_mandatory_pre_defined_item
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of pre_defined_item shall be of type pre_defined_text_font
or pre_defined_curve_font.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_product_definition_usage">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_product_definition_usage rule requires all
product_definition_usage entities to be either assembly_component_usage or make_from_usage_option.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_product_definition_usage FOR
  (product_definition_usage);
WHERE
  WR1: SIZEOF (QUERY (pdu <* product_definition_usage |
       NOT (SIZEOF([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'ASSEMBLY_COMPONENT_USAGE',
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'MAKE_FROM_USAGE_OPTION'] * 
       TYPEOF(pdu)) = 1))) = 0;
END_RULE; -- subtype_mandatory_product_definition_usage
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of product_definition_usage shall be of type
assembly_component_usage or make_from_usage_option.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_runout_zone_orientation">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_runout_zone_orientation rule requires all runout_zone_orientation entities to 
be runout_zone_orientation_reference_direction.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_runout_zone_orientation FOR
  (runout_zone_orientation);
WHERE  
  WR1: SIZEOF (QUERY (rzo <* runout_zone_orientation |
       NOT (SIZEOF ([
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION'] *
       TYPEOF (rzo)) = 1))) = 0;
END_RULE; -- subtype_mandatory_runout_zone_orientation
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Every instance of runout_zone_orientation shall be a 
runout_zone_orientation_reference_direction.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="subtype_mandatory_text_literal">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The subtype_mandatory_text_literal rule requires all text_literal entities
to be text_literal_with_extent or text_literal_with_associated_curves.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE subtype_mandatory_text_literal FOR (text_literal);
WHERE
  WR1: SIZEOF (QUERY (tl <* text_literal |
       NOT ((
       'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL_WITH_EXTENT' IN TYPEOF (tl)) OR
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
       'TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN
       TYPEOF(tl))))) = 0;
END_RULE; -- subtype_mandatory_text_literal
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
Each instance of text_literal shall be of type text_literal_with_extent or of type text_literal_with associated_curves.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="supplied_product_version_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The supplied_product_version_unique_constraint rule constrains the
product_definition_formation_with_specified_source population members, that fill
the role of ARM supplied_product_version, to have unique supplier_part_numbers on
each supplier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE supplied_product_version_unique_constraint FOR
 ( product_definition_formation_with_specified_source );
LOCAL
  spv : BAG OF product_definition_formation_with_specified_source := 
QUERY( r <*
product_definition_formation_with_specified_source | 
(SIZEOF(QUERY( pd <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'PRODUCT_DEFINITION.FORMATION') |
(SIZEOF(QUERY( pdr <* USEDIN(pd, 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION') |
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'SUPPLIED_PART_RELATIONSHIP')
IN TYPEOF(pdr))))>0)))>0));
  aoa_bag : BAG OF applied_organization_assignment;
  o_bag : BAG OF organization := [];
  pdf_bag : BAG OF product_definition_formation_with_specified_source;
  spn_bag : BAG OF STRING;
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(spv) by 1;
  aoa_bag := QUERY( aoa <* USEDIN( spv[i], 
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS') | (aoa.role\organization_role.name = 'supplier') );
  REPEAT j := 1 to SIZEOF(aoa_bag) by 1;
    IF EXISTS( aoa_bag[j].assigned_organization ) THEN
      IF ( NOT ( aoa_bag[j].assigned_organization IN o_bag ) ) THEN
        o_bag := o_bag + aoa_bag[j].assigned_organization;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;

REPEAT i := 1 to SIZEOF(o_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  pdf_bag := QUERY( pdf <* spv | (SIZEOF(QUERY( aoa <* USEDIN(pdf,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|
((aoa.role\organization_role.name = 'supplier') AND (aoa.assigned_organization :=: 
                                              o_bag[i])) ) )>0) );
  spn_bag := [];
  REPEAT j := 1 to SIZEOF(pdf_bag) by 1;
    IF EXISTS( pdf_bag[j].of_product.id ) THEN
      IF ( pdf_bag[j].of_product.id IN spn_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        spn_bag := spn_bag + pdf_bag[j].of_product.id;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- supplied_product_version_unique_constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of product_definition_formation_with_specified_source that is referenced
by a product_definition that is referenced in a supplied_part_relationship that share a
common supplier must have a unique of_product.id attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="technology_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The technology_constraint rule constrains the definition and the use of a
property_definition when it is a technology.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each property_definition whose name = 'unit technology' shall be related to exactly one 
characterized_object that is an external definition.
</Informal.propositions.rul>
<Informal.propositions.rul>
IF property_definition name = 'unit technology' THEN 
property_definition shall be the definition for exactly one 
material_designation.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each property_definition whose name = 'unit technology' shall be the 
definition of exactly one property_definition_representation whose
used_representation is an items of an applied_document_reference whose 
assigned_document is a ee_specification.kind.product_data_type = 
'process specification'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="terminal_pair_port_equivalence_relationship_constraint">
<RULE.DESCRIPTION>
The terminal_pair_port_equivalence_relationship_constraint rule constrains
the rep_1 and rep_2 of a representation_relationship when it is a terminal
pair port equivalence relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each representation_relationship that has a name = 'terminal pair port
equivalence relationship' shall have its rep_2 satisfied by an
analytical_model_port.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each representation_relationship that has a name = 'terminal pair port 
equivalence relationship' shall have its rep_1 satisfied by an
analytical_model_port.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="thermal_requirement_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The thermal_requirement_allocation_constraint rule constrains the related
and relating product_definition of a product_definition_relationship when it
is a thermal requirement allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship whose {name = 'assembly requirement
allocation} {description = 'thermal requirement allocation'} shall have its
related_product_definition satisfied by a component_definition that {has
a description = 'thermal component'} {is the of_shape of a
component_shape_aspect}.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each product_definition_relationship whose {name = 'assembly requirement 
allocation} {description = 'thermal requirement allocation'} shall have its 
relating_product_definition satisfied by a product_definition that {has a
frame_of_reference.name = 'design requirement'} {is the definition of
a thermal requirement}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_specific_restraint_condition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_specific_restraint_condition_constraint rule constrains the use of a property_definition when it is used as a tolerance specific restraint condition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance specific restraint' shall relate, to specify its 'affected tolerance', to at least one property_definition that is either a physical_unit_geometric_tolerance, a dimensional_size_property, or is a property_definition of a dimensional_location and has a description of 'dimensional location property'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_and_viewing_plane_orienting_relationship_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_and_viewing_plane_orienting_relationship_constraint rule constrains the use of a shape_aspect_relationship when it is used as a tolerance zone and viewing plane orienting relationship.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall have a related_shape_aspect that is a viewing_plane.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall have a relating_shape_aspect that is a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall have exactly one property_definition with a description of 'viewing plane based orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect_relationship with a name of 'tolerance zone and viewing plane' shall specify a unique combination of relating_shape_aspect and related_shape_aspect.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_boundary_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_boundary_definition_constraint rule constrains the use of a property_definition when it is used as a tolerance zone boundary definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of either 'boundary zone definition with specified size' or 'conical tolerance zone boundary' shall be a property_definition of a tolerance_zone_boundary and that tolerance_zone_boundary shall be specified as one of the boundaries of exactly one tolerance_zone_definition.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_boundary_member_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_boundary_member_constraint rule constrains the use of a shape_aspect when it is used as a tolerance zone boundary member.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect that has a description of 'tolerance zone boundary member' shall not be on the boundary of the shape of the product.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect that has a description of 'tolerance zone boundary member' shall be related to exactly one tolerance_zone_explicit_opposing_boundary_set as a 'zone boundary member'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each shape_aspect with a description of 'tolerance zone boundary member' shall have at most one property_definition with a description of 'tolerance zone boundary member offset'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_boundary_member_offset_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_boundary_member_offset_constraint rule constrains the use of a property_definition when it is used as a tolerance zone boundary member offset.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall be a property_definition of a shape_aspect that is not on the boundary of the shape of the product and has a description of 'tolerance zone boundary member'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall be related as a 'profile tolerance zone boundary member offset' to exactly one property_definition that has a description boundary zone definition with specified size and a name of 'profile boundary with offsets'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall have a representation that contains exactly one length_measure_with_unit that has a name of 'tolerance zone boundary member offset value'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall have a name of either 'towards material' or 'away from material'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone boundary member offset' shall be related as a 'profile tolerance zone boundary member offset' to exactly one property_definition that has a description of 'boundary zone definition with specified size', a name of 'profile boundary with offsets', and is applied to a tolerance_zone_explicit_opposing_boundary_set, and that tolerance_zone_explicit_opposing_boundary_set shall be the same instance of tolerance_zone_explicit_opposing_boundary_set that is related as a 'zone boundary member' to the shape_aspect to which the instance of property_definition is applied.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_constraint rule constrains the use of a tolerance_zone when it is used as a tolerance zone.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone shall be the zone of exactly one tolerance_zone_definition and that tolerance_zone_definition shall have exactly one boundary and that boundary shall be a tolerance_zone_boundary.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_definition_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_definition_constraint rule constrains the use of a tolerance_zone_definition when it is used as a tolerance zone definition.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_definition shall have exactly one boundary that is a tolerance_zone_boundary and that tolerance_zone_boundary shall have exactly one property_definition that has a description of either 'boundary zone definition with specified size' or 'conical tolerance zone boundary'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each tolerance_zone_definition that specifies a tolerance_zone with a description that is not 'conical', shall have that tolerance_zone specify exactly one physical_unit_geometric_tolerance, as its defining_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_definition_with_per_unit_size_specification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_definition_with_per_unit_size_specification_constraint rule constrains the use of a tolerance_zone_definition when it is used as a tolerance zone definition with per unit size specification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_definition shall specify a tolerance_zone as its zone and that tolerance_zone shall have at most one property_definition that has a description of 'tolerance zone per unit size'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each tolerance_zone_definition in which the tolerance_zone, specified as its zone, has a property_definition with a description of 'tolerance zone per unit size', shall have that tolerance_zone specify a physical_unit_geometric_tolerance, as its defining_tolerance, and that physical_unit_geometric_tolerance either shall have a name of 'flatness' or 'straightness'; or shall be an angularity_tolerance, parallelism_tolerance, or perpendicularity_tolerance.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_definition_with_specified_orientation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_definition_with_specified_orientation_constraint rule constrains the use of a property_definition when it is used as a tolerance zone definition with specified orientation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' shall be a property_definition of a tolerance_zone.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' shall relate to exactly one property_definition that has a description of either 'datum axis related orientation', 'viewing plane based orientation', or 'datum based vector orientation' to specify its 'zone orientation'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' and that relates to exactly one property_definition that has a description of 'viewing plane based orientation', shall be applied to the same instance of tolerance_zone that is specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'tolerance zone and viewing plane' and to which the property_definition that has a description of 'viewing plane based orientation' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' and that relates to exactly one property_definition that has a description of 'datum axis related orientation', shall be applied to the same instance of tolerance_zone that is specified as the relating_shape_aspect by the shape_aspect_relationship that has a name of 'datum axis and tolerance zone' and to which the property_definition that has a description of 'datum axis related orientation' is applied.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone orientation' shall be a property_definition of a tolerance_zone and that tolerance_zone shall not specify as one of its defining_tolerance either a circular_runout_tolerance, a concentricity_tolerance, a surface_profile_tolerance, a symmetry_tolerance, a total_runout_tolerance, or a physical_unit_geometric_tolerance that has a name of either 'circularity', 'cylindricity', or 'flatness'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_form_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_form_constraint rule constrains the use of a tolerance_zone_form when it is used as a tolerance zone form.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each tolerance_zone_form shall be the form of at least one tolerance_zone.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="tolerance_zone_per_unit_size_specification_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The tolerance_zone_per_unit_size_specification_constraint rule constrains the use of a property_definition when it is used as a tolerance zone per unit size specification.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone per unit size' shall be a property_definition of a tolerance_zone and that tolerance_zone shall be specified as the zone by exactly one tolerance_zone_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'tolerance zone per unit size' shall have a representation that contains exactly one or two length_measure_with_unit that have a name of 'per unit size'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="topological_junction_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The topological_junction_constraint rule constrains the use of a shape_aspect
when it is a topological junction.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of a shape_aspect whose {description = 'topological junction'} 
shall be the related_shape_aspect of 
exactly one shape_aspect_relationship whose {name = 'topological junction 
scope'}.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="topological_junction_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The topological_junction_unique_constraint rule constrains the shape_aspect population members, that
fill the role of ARM topological_junction, to have unique names on each scope.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect with a description of 'topological junction' that
is referenced by a shape_aspect_relationship with a name of 'topological junction scope'
that references a common physical_connectivity_definition must have a unique name
attribute value.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="transmission_line_functional_unit_terminal_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The transmission_line_functional_unit_terminal_allocation_constraint rule
constrains the related and relating shape_aspect of a shape_aspect_relationship
when it is a transmission line functional unit terminal allocation.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect_relationship that has a name = 'transmission line functional
unit terminal allocation' shall have its relating_shape_aspect satisfied by a
component_functional_terminal that has a description = 'unit terminal'.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect_relationship that has a name = 'transmission line functional
unit terminal allocation' shall have its related_shape_aspect satisfied by a
component_terminal [that has a description = 'printed component join
terminal'] [that is the relating_shape_aspect of a shape_aspect_relationship
that has a name = 'terminal in component' and has a related_shape_aspect
that is a routed_printed_component that is related to a
product_definition_relationship that has a name = 'design functional unit
allocation' and a description = 'transmission line to routed printed
component allocation'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="transmission_line_functional_unit_terminal_allocation_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The transmission_line_functional_unit_terminal_allocation_unique_constraint rule constrains
shape_aspect_relationship population members, that fill the role of ARM
transmission_line_functional_unit_terminal_allocation, to have unique implementations on each
transmission_line_functional_unit_terminal.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE transmission_line_functional_unit_terminal_allocation_unique_constraint
 FOR ( shape_aspect_relationship );
LOCAL
  tlfuta : BAG OF shape_aspect_relationship := 
QUERY( r <* shape_aspect_relationship |
(r\shape_aspect_relationship.name = 'transmission line functional terminal allocation'));
  sa_bag : BAG OF shape_aspect;
  sar_bag : BAG OF shape_aspect_relationship;
  ut_bag : BAG OF shape_aspect := [];
  pass : BOOLEAN := TRUE;
END_LOCAL;

REPEAT i := 1 to SIZEOF(tlfuta) by 1;
  IF EXISTS( tlfuta[i].relating_shape_aspect ) THEN
    IF ( tlfuta[i].relating_shape_aspect\shape_aspect.description = 'unit terminal' )
                                                              THEN
      IF ( NOT ( tlfuta[i].relating_shape_aspect IN ut_bag ) ) THEN
        ut_bag := ut_bag + tlfuta[i].relating_shape_aspect;
      END_IF;
    END_IF;
  END_IF;
END_REPEAT;

REPEAT i := 1 to SIZEOF(ut_bag) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* tlfuta | 
((sar.related_shape_aspect\shape_aspect.description =
'printed component join terminal') AND 
(sar.relating_shape_aspect :=: ut_bag[i])) );
  sa_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect ) THEN
      IF ( sar_bag[j].related_shape_aspect IN sa_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        sa_bag := sa_bag + sar_bag[j].related_shape_aspect;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- transmission_line_functional_unit_terminal_allocation_unique_-
          -- constraint
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR">
<formal.propositions.rul>
Every instance of shape_aspect_relationship with a description of 'unit terminal' that
is references a common shape_aspect with a name of 'unit terminal' must have a unique
reference to a shape_aspect with a description of 'printed component join terminal'.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="transmission_line_functional_unit_to_routed_printed_component_allocation_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The
transmission_line_functional_unit_to_routed_printed_component_allocation_constraint
rule requires all product_definition_relationship entities that are used as
a transmission_line_functional_unit_to_routed_printed_component_allocation
entity to be related to a routed_printed_component.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each product_definition_relationship that has a name = 'design functional unit
allocation' and a description = 'transmission line to routed printed
component' shall participate as the definition of a property_definition
that is the relating_property_definition of a property_definition_relationship
that has a related_property_definition.definition that is a
routed_printed_component.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="true_profile_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The true_profile_constraint rule constrains the use of a property_definition when it is used as a true profile.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.Propositions rule.types="IP">
<Informal.propositions.rul>
Each instance of property_definition that has a description of 'true profile' shall be a property_definition of a shape_aspect that is either on the boundary of the shape of the product or is a part_template_definition.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'true profile' shall either relate to exactly one property_definition that has a description of 'dimension set' to specify its 'true profile specification', have exactly one document_reference where the assigned_document is an ee_specification, be represented by exactly one rule_function_definition, or have exactly one shape_representation with a name of '3d bound volume shape'.
</Informal.propositions.rul>

<Informal.propositions.rul>
Each instance of property_definition that has a description of 'true profile' shall be related as a 'basic profile' to at least one property_definition that has a description of 'boundary zone definition with specified size' and a name of either 'profile boundary' or 'profile boundary with offsets'.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="user_defined_dimension_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The user_defined_dimension_qualifier_constraint rule constrains the use of a measure_qualification when it is used as an user defined dimension qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'user defined dimension qualifier' shall have exactly one qualifier and that qualifier shall be a type_qualifier.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="user_defined_geometric_tolerance_qualifier_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The user_defined_geometric_tolerance_qualifier_constraint rule constrains the use of a measure_qualification when it is used as an user defined geometric tolerance qualifier.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each measure_qualification that has the name of 'user defined geometric tolerance qualifier' shall have exactly one qualifier and that qualifier shall be a type_qualifier.
</Informal.propositions.rul>

</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>
<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_approval">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The versioned_action_request_requires_approval rule specifies that each 
instance of versioned_action_request shall have exactly one approval.
An approval for a versioned_action_request is defined by the
applied_approval_assignment entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_approval FOR
  (versioned_action_request, applied_approval_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT (SIZEOF (QUERY (aaa <* applied_approval_assignment |
       varq IN aaa.items )) = 1 ))) = 0;
END_RULE; -- versioned_action_request_requires_approval
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request there shall be exactly
one instance of applied_approval_assignment that contains the instance of
versioned_action_request in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_date_or_date_and_time">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The versioned_action_request_requires_date_or_date_and_time rule specifies that
each instance of versioned_action_request shall have exactly one date or
date_and_time for it.  A date for a versioned_action_request is defined by the
applied_date_assignment entity and a date_and_time is defined by the
applied_date_and_time_assignment entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_date_or_date_and_time FOR
  (versioned_action_request, applied_date_and_time_assignment,
   applied_date_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (adata <* applied_date_and_time_assignment |
       varq IN adata.items )) = 1 ) OR
       (SIZEOF (QUERY (ada <* applied_date_assignment |
       varq IN ada.items )) = 1 )))) = 0;
END_RULE; -- versioned_action_request_requires_date_or_date_and_time
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request, exactly one instance of
applied_date_and_time_assignment or exactly one instance of
applied_date_assignment shall contain the instance of versioned_action_request
in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_person_organization">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The versioned_action_request_requires_person_organization rule specifies
that each instance of versioned_action_request shall have one or more
organizations or person_and_organizations assigned to it.  An
organization for a versioned_action_request is defined by the
applied_organization_assignment entity and a person_and_organization is defined 
by the applied_person_and_organization_assignment entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_person_organization FOR
  (versioned_action_request,
  applied_person_and_organization_assignment,
  applied_organization_assignment);
WHERE
  WR1: SIZEOF (QUERY (varq <* versioned_action_request |
       NOT ((SIZEOF (QUERY (apaoa <*
       applied_person_and_organization_assignment |
       varq IN apaoa.items )) >= 1 ) OR
       (SIZEOF (QUERY (aoa <*
       applied_organization_assignment |
       varq IN aoa.items )) >= 1 )))) = 0;
END_RULE; -- versioned_request_requires_person_organization
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request, there shall be at least one
instance of applied_person_and_organization_assignment or at least one
instance of applied_organization_assignment that contains the instance of
versioned_action_request in its set of items.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="versioned_action_request_requires_status">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

A versioned_action_request_requires_status rule specifies that each instance
of versioned_action_request shall have exactly one status.  The status of a
versioned_action_request is defined by the action_request_status entity.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE versioned_action_request_requires_status FOR
  (versioned_action_request, action_request_status);
WHERE
  WR1: SIZEOF (QUERY (ar <* versioned_action_request |
       NOT (SIZEOF (QUERY (ars <* action_request_status |
       ar :=: ars.assigned_request)) = 1))) = 0;
END_RULE; -- versioned_action_request_requires_status
(*
</EXPRESS.CODE>
<formal.propositions rule.types="WR"> 
<formal.propositions.rul>
For each instance of versioned_action_request there shall be exactly
one instance of action_request_status that contains an
assigned_request attribute value equal to that instance of
versioned_action_request.
</formal.propositions.rul>
</formal.propositions>
</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="via_template_terminal_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The via_template_terminal_constraint rule requires all shape_aspect entities
that are via template terminals to be related to a via template and a
connection zone.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
(*
</EXPRESS.CODE>
<Informal.propositions rule.types="IP">
<Informal.propositions.rul>
Each shape_aspect that has a description = 'via template terminal' shall 
participate as a related_shape_aspect for a shape_aspect_relationship with 
a name = 'access mechanism' that has a relating_shape_aspect that is a 
part_template_definition that has a description = 'via template' and has an 
of_shape that is a product_definition_shape that has a definition that is a 
characterized_object.
</Informal.propositions.rul>
<Informal.propositions.rul>
Each shape_aspect that has a description = 'via template terminal' shall 
participate as a relating_shape_aspect for a shape_aspect_relationship that 
has a related_shape_aspect that has a name = 'connection zone'.
</Informal.propositions.rul>
</Informal.propositions>

</RULE.DEF>
</RULE.DEF.CL4>

<RULE.DEF.CL4>
<RULE.DEF NAME="via_template_terminal_unique_constraint">
<RULE.DESCRIPTION>
<note> This rule may not have been updated to agree with the changes in clause 4.2.</note>

The via_template_terminal_unique_constraint rule constrains the shape_aspect population members, that
fill the role of ARM via_template_terminal, to have unique terminal names on each via_template.
</RULE.DESCRIPTION>
<EXPRESS.CODE>
*)
RULE via_template_terminal_unique_constraint FOR
 ( shape_aspect );
LOCAL
  vt : BAG OF shape_aspect := 
         QUERY( r <* shape_aspect | (r\shape_aspect.description = 'via template'));
  sar_bag : BAG OF shape_aspect_relationship;
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING;
END_LOCAL;

REPEAT i := 1 to SIZEOF(vt) by 1;
  IF ( NOT pass ) THEN ESCAPE;
  END_IF;
  sar_bag := QUERY( sar <* USEDIN( vt[i],
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.'
 + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT') |
((sar\shape_aspect_relationship.name = 'access mechanism') AND 
(sar.related_shape_aspect\shape_aspect.description = 
'via template terminal' )) );
  name_bag := [];
  REPEAT j := 1 to SIZEOF(sar_bag) by 1;
    IF EXISTS( sar_bag[j].related_shape_aspect\shape_aspect.name ) THEN
      IF ( sar_bag[j].related_shape_aspect\shape_aspect.name IN name_bag ) THEN
        pass := FALSE;
        ESCAPE;
      ELSE
        name_bag := name_bag + sar_bag[j].related_shape_aspect\shape_aspect.name;
      END_IF;
    END_IF;
  END_REPEAT;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- via_template_terminal_unique_constraint

RULE work_order_unique_constraint FOR
 ( directed_action );
LOCAL
  r : BAG OF directed_action := 
    QUERY( r <* directed_action | (SIZEOF(QUERY( aa <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'ACTION_ASSIGNMENT.ASSIGNED_ACTION' ) |
((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'CHANGE') IN TYPEOF(aa)) OR
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'START_WORK') IN TYPEOF(aa))))) > 0 ) );
  pass : BOOLEAN := TRUE;
  name_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(r) by 1;
  IF EXISTS( r[i].directive\action_directive.name ) THEN
    IF ( r[i].directive\action_directive.name IN name_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      name_bag := name_bag + r[i].directive\action_directive.name;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- work_order_unique_constraint

RULE work_request_unique_constraint FOR
 ( versioned_action_request );
LOCAL
  r : BAG OF versioned_action_request := 
QUERY( r <* versioned_action_request | 
(SIZEOF(QUERY( ara <* USEDIN(r,
'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST' ) |
((('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'CHANGE_REQUEST') IN TYPEOF(ara)) OR
(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
'START_REQUEST') IN TYPEOF(ara))))) > 0 ) );
  pass : BOOLEAN := TRUE;
  id_bag : BAG OF STRING := [];
END_LOCAL;

REPEAT i := 1 to SIZEOF(r) by 1;
  IF EXISTS( r[i].id ) THEN
    IF ( r[i].id IN id_bag ) THEN
      pass := FALSE;
      ESCAPE;
    ELSE
      id_bag := id_bag + r[i].id;
    END_IF;
  END_IF;
END_REPEAT;
WHERE
  WR1: pass;
END_RULE; -- work_request_unique_constraint

FUNCTION applied_date_correlation
  (e : applied_date_assignment;
  schema_name : STRING) : BOOLEAN;
  LOCAL
    d_role : STRING;
  END_LOCAL;
    d_role := e\date_assignment.role\date_role.name;
  CASE d_role OF
    'creation date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                (SIZEOF( [schema_name +
                                '.PRODUCT_DEFINITION',
                                schema_name +
                                '.DOCUMENT'] *
                                TYPEOF (x)) >= 1 )))
                                THEN RETURN(FALSE);
                              END_IF;
    'request date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.VERSIONED_ACTION_REQUEST'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'release date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign off date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification date'    : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification date'   : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification date' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION applied_date_time_correlation
  (e : applied_date_and_time_assignment;
  schema_name : STRING) : BOOLEAN;
  LOCAL
    dt_role : STRING;
  END_LOCAL;
    dt_role := e\date_and_time_assignment.role\date_time_role.name;
  CASE dt_role OF
    'creation date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                               (SIZEOF( [schema_name +
                                '.PRODUCT_DEFINITION',
                                schema_name +
                                '.DOCUMENT'] *
                                TYPEOF (x)) >= 1 )))
                                THEN RETURN(FALSE);
                              END_IF;
    'request date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.VERSIONED_ACTION_REQUEST'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'release date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'start date'          : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                SIZEOF (
                                [schema_name + '.CHANGE' ,
                                schema_name + '.START_WORK'] *
                                TYPEOF (x)) = 1))
                                THEN RETURN(FALSE);
                              END_IF;
    'sign off date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.APPROVAL_PERSON_ORGANIZATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'contract date'         : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CONTRACT'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'certification date'    : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name + '.CERTIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'classification date'   : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'declassification date' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.SECURITY_CLASSIFICATION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    'participant date and time' : IF SIZEOF (e.items) <>
                                SIZEOF (QUERY (x <* e.items |
                                schema_name +
                                '.RULE_ACTION'
                                IN TYPEOF (x)))
                                THEN RETURN(FALSE);
                              END_IF;
    OTHERWISE : RETURN(TRUE);
  END_CASE;
  RETURN (TRUE);
END_FUNCTION;

FUNCTION  bag_to_set

      ( the_bag : BAG OF GENERIC : intype ) : SET OF GENERIC : intype ;

LOCAL

      the_set : SET OF GENERIC : intype := [];
      i : INTEGER ;

END_LOCAL ;

      IF SIZEOF (the_bag) > 0 THEN
            REPEAT i := 1 TO HIINDEX (the_bag);
                  the_set := the_set + the_bag[i];
            END_REPEAT ;
      END_IF ;
      RETURN (the_set);

END_FUNCTION ;

FUNCTION component_definition_located_by_component_location 
                   (cl : component_2d_location) : component_definition; 
LOCAL
  pdr : BAG OF property_definition_representation := USEDIN (cl,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
END_LOCAL;
   REPEAT i := 1 TO HIINDEX(pdr) BY 1;
    IF(('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN 
                                  TYPEOF (pdr[i].definition.definition))
        AND
       ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
        'COMPONENT_DEFINITION' IN 
        TYPEOF (pdr[i].definition.definition\product_definition_relationship.
                                                  related_product_definition)))
     THEN 
      RETURN(pdr[i].definition.definition\product_definition_relationship.
                                                   related_product_definition);
    END_IF;
   END_REPEAT;
 RETURN (?);
END_FUNCTION;

FUNCTION consistent_bus_structural_definition
     (input_rel : SET [1:?] OF product_definition_relationship) : BOOLEAN;    

LOCAL  
        input : SET OF product_definition := [];
       vertex : SET OF product_definition := []; 
         edge : INTEGER := SIZEOF(input);
           vc : INTEGER := 0;
vertex_degree : INTEGER := 0;    
END_LOCAL;    

REPEAT i := 1 to SIZEOF(input_rel) BY 1;
      input := input + input_rel[i].related_product_definition;
END_REPEAT;

REPEAT i := 1 TO SIZEOF(input) BY 1;
      vertex := vertex + input[i]\product_definition_relationship.relating_product_definition;
      vertex := vertex + input[i]\product_definition_relationship.related_product_definition;
END_REPEAT;
     vc := SIZEOF(vertex);
    IF ( vc <> ( edge + 1 )) THEN 
      RETURN(FALSE);
    END_IF;
REPEAT i := 1 TO vc BY 1;
      vertex_degree := 0;
      REPEAT j := 1 to SIZEOF(input) BY 1;
        IF input[j]\product_definition_relationship.relating_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
        IF input[j]\product_definition_relationship.related_product_definition = vertex[i] THEN 
          vertex_degree := vertex_degree + 1;
        END_IF;
      END_REPEAT;
      IF (vertex_degree > 2) THEN
        RETURN(FALSE);
      END_IF;
END_REPEAT;    
RETURN(TRUE);  
END_FUNCTION; -- consistent_bus_structural_definition

FUNCTION cto2d_determinant_test (cto2d: cartesian_transformation_operator_2d;
                             expected_value: REAL; delta: REAL ) : BOOLEAN;

LOCAL
  det : REAL := 0.0;
  DRs : LIST [4:4] OF REAL := [];
END_LOCAL;
     DRs[1] := cto2d.u[1].direction_ratios[1];
     DRs[2] := cto2d.u[1].direction_ratios[2];
     DRs[3] := cto2d.u[2].direction_ratios[1];
     DRs[4] := cto2d.u[2].direction_ratios[2];
     det  :=  (DRs[1] * DRs[4]) - (DRs[2] * DRs[3]);
IF (Abs(expected_value - det) < Abs(delta) ) THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION instance_unique 

      ( the_bag : BAG OF GENERIC : intype ) : BOOLEAN;

LOCAL

      the_set : SET OF GENERIC : intype := [];
      i : INTEGER ;
      pass : BOOLEAN := TRUE;
END_LOCAL ;

      IF SIZEOF (the_bag) > 0 THEN
                  the_set := bag_to_set(the_bag);
      END_IF ;
      IF NOT(SIZEOF(the_set) = SIZEOF(the_bag)) THEN
       pass := FALSE;
      END_IF;

      RETURN (pass);

END_FUNCTION ;

FUNCTION is_assembly_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_assembly_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_assembly_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_assembly_module_usage ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'assembly module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design usage'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_bottom_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN(pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'bottom')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_bottom_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_bottom_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_bottom_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN(pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'bottom')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_bottom_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_bottom_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_ee_product_definition ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (NOT(is_laminate_component(pd)) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF(pd))) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'STRATUM' IN TYPEOF(pd))) AND 
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NETWORK_NODE_DEFINITION' IN TYPEOF(pd))) AND
   (NOT('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd)))
   ) 
THEN
    RETURN (TRUE);
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_interconnect_module_component_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_interconnect_module_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_interconnect_module_design ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical design'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_interconnect_module_macro_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'macro occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_interconnect_module_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF NOT(EXISTS(pd\product_definition.name)) THEN RETURN(FALSE); END_IF;
IF ((pd\product_definition.name = 'interconnect module') AND
   (pd.frame_of_reference\application_context_element.name = 'physical occurrence'))
THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_laminate_component ( pd : product_definition) : BOOLEAN; 
LOCAL
  pass : BOOLEAN := FALSE;
END_LOCAL;
IF (pd\product_definition.description = 'laminate component') THEN
    RETURN (TRUE);
ELSE
  IF ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PRINTED_COMPONENT' IN TYPEOF(pd)) THEN
    RETURN (TRUE);
  END_IF;
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_laminate_component_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_laminate_component(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_symmetrical_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'symmetrical')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_symmetrical_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_symmetrical_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_symmetrical_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'symmetrical')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_symmetrical_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_symmetrical_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_top_footprint_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'FOOTPRINT_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'FOOTPRINT_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'top')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_top_footprint_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_top_footprint_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION is_top_padstack_occurrence ( pd : product_definition) : BOOLEAN; 
LOCAL
  pds : SET OF property_definition := BAG_TO_SET(USEDIN ( pd,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION.DEFINITION'));
   fo : SET OF shape_aspect :=  [];
  sar : SET OF shape_aspect_relationship := [];
  dri : SET OF descriptive_representation_item := [];
  pdr : SET OF property_definition_representation := [];
 pass : BOOLEAN := FALSE;
END_LOCAL;
REPEAT i := 1 to SIZEOF(pds) by 1;
      fo := fo + BAG_TO_SET(QUERY( sa <* (USEDIN ( pds[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT.OF_SHAPE')) |
     'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PADSTACK_OCCURRENCE' IN TYPEOF(sa)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(fo) by 1;
      sar := sar + BAG_TO_SET(QUERY( sar <* (USEDIN ( fo[i],
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')) | 
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 
  'PADSTACK_DEFINITION' IN 
      TYPEOF(sar.relating_shape_aspect.of_shape.definition)) AND
  ('usage definition' = sar\shape_aspect_relationship.name)));
END_REPEAT;
REPEAT i := 1 to SIZEOF(sar) by 1;
      pdr := pdr + BAG_TO_SET(QUERY( pdr <* (
          USEDIN (sar[i].relating_shape_aspect.of_shape.definition,
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'REPRESENTATION' IN TYPEOF(pdr.used_representation)) AND
  (pdr.used_representation\representation.name = 'product definition context description')));
END_REPEAT;

REPEAT i := 1 to SIZEOF(pdr) by 1;
      dri := dri + (QUERY( dri <* pdr[i].used_representation.items |
     ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri)) AND
   (dri\representation_item.name = 'text') AND
   (dri.description = 'top')));
END_REPEAT;

IF (SIZEOF(dri) = 1) THEN
    RETURN (TRUE);
END_IF;
RETURN (pass);
END_FUNCTION;

FUNCTION is_top_padstack_occurrence_location ( cl: component_2d_location) : BOOLEAN; 
LOCAL
  pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN ( cl, 
  'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
END_LOCAL;
IF sizeof (pdrs) = 1 THEN
  IF (('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF 
     (pdrs[1].definition.definition)) AND
  ('ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' +
  'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF 
     (pdrs[1].definition.definition.related_product_definition)) AND
   is_top_padstack_occurrence(pdrs[1].definition.definition.related_product_definition)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
ELSE
    RETURN (FALSE);
END_IF;
END_FUNCTION;

FUNCTION valid_2d_wireframe_edge_curve
  (crv   : curve; schma : STRING) : BOOLEAN;

  -- recursively check for valid basic curve types
  IF SIZEOF ([schma + '.LINE',
              schma + '.B_SPLINE_CURVE',
              schma + '.CIRCLE',
              schma + '.HYPERBOLA',
              schma + '.ELLIPSE',
              schma + '.PARABOLA',
              schma + '.POLYLINE'] * TYPEOF (crv)) = 1
      THEN RETURN (TRUE);
  ELSE
    -- recursively check for valid basic curves for curve_replicas
    IF (schma + '.CURVE_REPLICA') IN TYPEOF (crv)
      THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\curve_replica.parent_curve, schma));
    -- recursively check for valid basis curves for offset_curves
    ELSE
      IF (schma + '.OFFSET_CURVE_2D') IN TYPEOF (crv)
        THEN RETURN (valid_2d_wireframe_edge_curve
                         (crv\offset_curve_2d.basis_curve, schma));
      END_IF;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
	
END_SCHEMA;

