SCHEMA ap210_electronic_assembly_interconnect_and_packaging_design_mim_lf;

CONSTANT
	dummy_gri : geometric_representation_item :=  representation_item('')|| geometric_representation_item();


	base_types : SET [0:?] OF STRING :=  [ 'NUMBER', 'COMPLEX_NUMBER_LITERAL', 'REAL', 'INTEGER', 'LOGICAL', 'BOOLEAN', 'STRING', 'BINARY', 'MATHS_SPACE', 'MATHS_FUNCTION', 'LIST', 'ELEMENTARY_SPACE_ENUMERATORS', 'ORDERING_TYPE', 'LOWER_UPPER', 'SYMMETRY_TYPE', 'ELEMENTARY_FUNCTION_ENUMERATORS', 'OPEN_CLOSED', 'SPACE_CONSTRAINT_TYPE', 'REPACKAGE_OPTIONS', 'EXTENSION_OPTIONS' ] ;


	cnlit : STRING :=  schema_prefix + 'COMPLEX_NUMBER_LITERAL' ;


	schema_prefix : STRING :=  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' ;


	the_binarys : elementary_space :=  make_elementary_space(es_binarys);


	the_booleans : elementary_space :=  make_elementary_space(es_booleans);


	the_complex_numbers : elementary_space :=  make_elementary_space(es_complex_numbers);


	the_complex_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_complex_numbers);


	the_empty_atom_based_tuple : atom_based_tuple :=  [ ] ;


	the_empty_atom_based_value : atom_based_value :=  the_empty_atom_based_tuple ;


	the_empty_maths_tuple : maths_tuple :=  [ ] ;


	the_empty_maths_value : maths_value :=  the_empty_maths_tuple ;


	the_empty_space : finite_space :=  make_finite_space([ ]);


	the_generics : elementary_space :=  make_elementary_space(es_generics);


	the_integer_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_integers);


	the_integers : elementary_space :=  make_elementary_space(es_integers);


	the_logicals : elementary_space :=  make_elementary_space(es_logicals);


	the_maths_spaces : elementary_space :=  make_elementary_space(es_maths_spaces);


	the_neg1_one_interval : finite_real_interval :=  make_finite_real_interval(- 1.0, closed, 1.0, closed);


	the_neghalfpi_halfpi_interval : finite_real_interval :=  make_finite_real_interval(- 0.5 * PI , closed, 0.5 * PI, closed);


	the_negpi_pi_interval : finite_real_interval :=  make_finite_real_interval(- PI , open, PI, closed);


	the_nonnegative_reals : real_interval_from_min :=  make_real_interval_from_min(0.0, closed);


	the_numbers : elementary_space :=  make_elementary_space(es_numbers);


	the_real_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_reals);


	the_reals : elementary_space :=  make_elementary_space(es_reals);


	the_strings : elementary_space :=  make_elementary_space(es_strings);


	the_tuples : extended_tuple_space :=  make_extended_tuple_space(the_zero_tuple_space, the_generics);


	the_zero_one_interval : finite_real_interval :=  make_finite_real_interval(0.0, closed, 1.0, closed);


	the_zero_pi_interval : finite_real_interval :=  make_finite_real_interval(0.0, closed, PI, closed);


	the_zero_tuple_space : listed_product_space :=  make_listed_product_space([ ]);


	dummy_tri : topological_representation_item :=  representation_item('')|| topological_representation_item();



END_CONSTANT;

TYPE supported_item = SELECT (
	action,
	action_directive,
	action_method);
END_TYPE; -- supported_item

TYPE action_items = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- action_items

TYPE aliasable_item = EXTENSIBLE SELECT ;
END_TYPE; -- aliasable_item

TYPE ap_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	package_terminal);
END_TYPE; -- ap_document_reference_item

TYPE ap210_managed_design_object = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON managed_design_object WITH (
	action,
	alternate_product_relationship,
	applied_approval_assignment,
	applied_date_and_time_assignment,
	applied_document_reference,
	applied_group_assignment,
	approval,
	approval_status,
	certification,
	characterized_object,
	composite_curve_segment,
	configuration_effectivity,
	configuration_item,
	contract,
	curve_style,
	curve_style_font,
	curve_style_font_and_scaling,
	date,
	dimension_related_tolerance_zone_element,
	dimensional_characteristic_representation,
	dimensional_size,
	document,
	document_usage_constraint,
	externally_defined_item,
	fill_area_style,
	fill_area_style_colour,
	geometric_tolerance,
	geometric_tolerance_relationship,
	group,
	layer_connection_point,
	material_designation,
	measure_with_unit,
	organization,
	person,
	person_and_organization,
	plus_minus_tolerance,
	pre_defined_item,
	product,
	product_concept,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	property_definition_relationship,
	property_definition_representation,
	representation,
	representation_context,
	representation_item,
	representation_relationship,
	runout_zone_orientation,
	security_classification,
	shape_aspect,
	shape_aspect_relationship,
	tolerance_value,
	tolerance_zone_form,
	versioned_action_request);
END_TYPE; -- ap210_managed_design_object

TYPE pdm_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH (
	product_definition_formation);
END_TYPE; -- pdm_action_items

TYPE pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH (
	action,
	action_directive,
	certification,
	configuration_effectivity,
	configuration_item,
	contract,
	date,
	directed_action,
	document,
	general_property_relationship,
	product,
	product_definition,
	product_definition_relationship,
	product_definition_formation,
	representation,
	security_classification,
	shape_aspect_relationship,
	versioned_action_request);
END_TYPE; -- pdm_approval_item

TYPE pdm_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON certification_item WITH (
	supplied_part_relationship,
	make_from_usage_option);
END_TYPE; -- pdm_certification_item

TYPE pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	material_designation);
END_TYPE; -- pdm_classification_item

TYPE pdm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH (
	alternate_product_relationship,
	directed_action,
	product,
	product_definition_formation);
END_TYPE; -- pdm_contract_item

TYPE pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	approval_person_organization,
	certification,
	contract,
	directed_action,
	document,
	product_definition,
	security_classification,
	versioned_action_request);
END_TYPE; -- pdm_date_and_time_item

TYPE pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	product_definition,
	versioned_action_request,
	directed_action,
	approval_person_organization,
	contract,
	document,
	security_classification,
	certification);
END_TYPE; -- pdm_date_item

TYPE pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	action_method,
	assembly_component_usage,
	characterized_object,
	coordinated_representation_item,
	configuration_item,
	descriptive_representation_item,
	externally_defined_item,
	material_designation,
	measure_representation_item,
	product,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	property_definition,
	representation,
	representation_item,
	shape_aspect);
END_TYPE; -- pdm_document_reference_item

TYPE pdm_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH (
	organizational_project);
END_TYPE; -- pdm_event_occurrence_item

TYPE pdm_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	product_definition,
	product_definition_formation,
	property_definition_representation,
	representation,
	representation_item,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- pdm_groupable_item

TYPE pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
	characterized_class,
	configuration_item,
	material_designation,
	person_and_organization,
	product,
	product_concept,
	product_definition_formation,
	organization);
END_TYPE; -- pdm_identification_item

TYPE pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH (
	applied_identification_assignment,
	configuration_item,
	contract,
	directed_action,
	document,
	versioned_action_request,
	product,
	product_definition,
	product_definition_formation,
	representation,
	security_classification);
END_TYPE; -- pdm_organization_item

TYPE pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH (
	configuration_item,
	contract,
	document,
	product,
	product_definition_formation,
	product_definition,
	directed_action,
	security_classification,
	versioned_action_request);
END_TYPE; -- pdm_person_and_organization_item

TYPE pdm_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH (
	descriptive_representation_item,
	configuration_item,
	product_definition,
	product_definition_formation,
	product,
	shape_aspect,
	representation);
END_TYPE; -- pdm_requirement_assigned_item

TYPE pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH (
	applied_promissory_usage_in_product_model_assignment,
	assembly_component_usage,
	document,
	make_from_usage_option,
	product_definition_formation,
	product_definition);
END_TYPE; -- pdm_security_classification_item

TYPE promissory_usage_in_product_model_assigned_item = SELECT (
	product_concept,
	product_definition);
END_TYPE; -- promissory_usage_in_product_model_assigned_item

TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- approval_item

TYPE date_and_time_item_approval = SELECT BASED_ON date_and_time_item WITH (
	approval_person_organization);
END_TYPE; -- date_and_time_item_approval

TYPE date_item_approval = SELECT BASED_ON date_item WITH (
	approval_person_organization);
END_TYPE; -- date_item_approval

TYPE acpr_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	requirements_property);
END_TYPE; -- acpr_groupable_item

TYPE description_attribute_select = SELECT (
	action_request_solution,
	application_context,
	approval_role,
	configuration_design,
	context_dependent_shape_representation,
	date_role,
	date_time_role,
	effectivity,
	external_source,
	organization_role,
	person_and_organization,
	person_and_organization_role,
	person_role,
	property_definition_representation,
	representation,
	time_role);
END_TYPE; -- description_attribute_select

TYPE id_attribute_select = SELECT (
	action,
	address,
	application_context,
	group,
	organizational_project,
	product_category,
	property_definition,
	representation,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- id_attribute_select

TYPE name_attribute_select = SELECT (
	action_request_solution,
	address,
	configuration_design,
	context_dependent_shape_representation,
	derived_unit,
	effectivity,
	person_and_organization,
	product_definition,
	product_definition_substitute,
	property_definition_representation);
END_TYPE; -- name_attribute_select

TYPE role_select = SELECT (
	action_assignment,
	action_request_assignment,
	approval_assignment,
	approval_date_time,
	certification_assignment,
	contract_assignment,
	document_reference,
	effectivity_assignment,
	external_referent_assignment,
	group_assignment,
	name_assignment,
	security_classification_assignment);
END_TYPE; -- role_select

TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- certification_item

TYPE c_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	coordinated_representation_item);
END_TYPE; -- c_document_reference_item

TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- classification_item

TYPE classification_select = EXTENSIBLE SELECT ;
END_TYPE; -- classification_select

TYPE complete_membership_select = EXTENSIBLE SELECT ;
END_TYPE; -- complete_membership_select

TYPE class_system_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	characterized_class);
END_TYPE; -- class_system_item

TYPE classification_classification_item = EXTENSIBLE SELECT BASED_ON classification_item WITH (
	class);
END_TYPE; -- classification_classification_item

TYPE classification_identification_item = EXTENSIBLE SELECT BASED_ON identification_item WITH (
	class);
END_TYPE; -- classification_identification_item

TYPE classification_item_extended = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	characterized_class,
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- classification_item_extended

TYPE classified_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- classified_item

TYPE id_for_class = SELECT BASED_ON identification_item WITH (
	characterized_class);
END_TYPE; -- id_for_class

TYPE version_for_class = SELECT BASED_ON versionable_item WITH (
	characterized_class);
END_TYPE; -- version_for_class

TYPE configuration_design_item = SELECT (
	product_definition,
	product_definition_formation);
END_TYPE; -- configuration_design_item

TYPE contract_item = EXTENSIBLE SELECT ;
END_TYPE; -- contract_item

TYPE date_and_time_item = EXTENSIBLE SELECT ;
END_TYPE; -- date_and_time_item

TYPE date_item = EXTENSIBLE SELECT ;
END_TYPE; -- date_item

TYPE ahead_or_behind = ENUMERATION OF (
	ahead,
	exact,
	behind );
END_TYPE; -- ahead_or_behind

TYPE date_time_or_event_occurrence = SELECT (
	date_time_select,
	event_occurrence);
END_TYPE; -- date_time_or_event_occurrence

TYPE date_time_select = SELECT (
	date,
	date_and_time,
	local_time);
END_TYPE; -- date_time_select

TYPE day_in_month_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 31 } ;
END_TYPE; -- day_in_month_number

TYPE day_in_week_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 7 } ;
END_TYPE; -- day_in_week_number

TYPE day_in_year_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 366 } ;
END_TYPE; -- day_in_year_number

TYPE hour_in_day = INTEGER;
WHERE
	WR1 :  { 0 <= SELF < 24 } ;
END_TYPE; -- hour_in_day

TYPE minute_in_hour = INTEGER;
WHERE
	WR1 :  { 0 <= SELF <= 59 } ;
END_TYPE; -- minute_in_hour

TYPE month_in_year_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 12 } ;
END_TYPE; -- month_in_year_number

TYPE second_in_minute = REAL;
WHERE
	WR1 :  { 0 <= SELF <= 60.0 } ;
END_TYPE; -- second_in_minute

TYPE week_in_year_number = INTEGER;
WHERE
	WR1 :  { 1 <= SELF <= 53 } ;
END_TYPE; -- week_in_year_number

TYPE year_number = INTEGER;
END_TYPE; -- year_number

TYPE managed_design_object = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- managed_design_object

TYPE dimension_identification_item = SELECT BASED_ON identification_item WITH (
	dimensional_size);
END_TYPE; -- dimension_identification_item

TYPE dimension_tolerance_document_reference_item = SELECT BASED_ON document_reference_item WITH (
	dimensional_size,
	externally_defined_dimension_definition);
END_TYPE; -- dimension_tolerance_document_reference_item

TYPE document_reference_item = EXTENSIBLE SELECT ;
END_TYPE; -- document_reference_item

TYPE document_location_select = SELECT BASED_ON external_identification_item WITH (
	product_definition);
END_TYPE; -- document_location_select

TYPE product_or_formation_or_definition = SELECT (
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- product_or_formation_or_definition

TYPE effectivity_item = EXTENSIBLE SELECT ;
END_TYPE; -- effectivity_item

TYPE representation_identification_item = SELECT BASED_ON identification_item WITH (
	shape_representation);
END_TYPE; -- representation_identification_item

TYPE representation_version_item = SELECT BASED_ON versionable_item WITH (
	shape_representation);
END_TYPE; -- representation_version_item

TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- event_occurrence_item

TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	event_occurrence);
END_TYPE; -- event_occurrence_date_and_time_item

TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	event_occurrence);
END_TYPE; -- event_occurrence_date_item

TYPE external_class_name_item = SELECT BASED_ON name_item WITH (
	external_class_library);
END_TYPE; -- external_class_name_item

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- external_identification_item

TYPE message = STRING;
END_TYPE; -- message

TYPE source_item = SELECT (
	identifier,
	message);
END_TYPE; -- source_item

TYPE file_identification_item = SELECT BASED_ON identification_item WITH (
	document_file);
END_TYPE; -- file_identification_item

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH (
	document_file);
END_TYPE; -- file_location_select

TYPE file_version_item = SELECT BASED_ON versionable_item WITH (
	document_file);
END_TYPE; -- file_version_item

TYPE fde_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	physical_connectivity_definition,
	physical_connectivity_element);
END_TYPE; -- fde_document_reference_item

TYPE boolean_operand = SELECT (
	solid_model,
	half_space_solid,
	csg_primitive,
	boolean_result,
	half_space_2d);
END_TYPE; -- boolean_operand

TYPE boolean_operator = ENUMERATION OF (
	union,
	intersection,
	difference );
END_TYPE; -- boolean_operator

TYPE csg_primitive = SELECT (
	sphere,
	ellipsoid,
	block,
	right_angular_wedge,
	faceted_primitive,
	rectangular_pyramid,
	torus,
	right_circular_cone,
	eccentric_cone,
	right_circular_cylinder,
	cyclide_segment_solid,
	primitive_2d);
END_TYPE; -- csg_primitive

TYPE csg_select = SELECT (
	boolean_result,
	csg_primitive);
END_TYPE; -- csg_select

TYPE geometric_set_select = SELECT (
	point,
	curve,
	surface);
END_TYPE; -- geometric_set_select

TYPE surface_model = SELECT (
	shell_based_surface_model,
	face_based_surface_model);
END_TYPE; -- surface_model

TYPE wireframe_model = SELECT (
	shell_based_wireframe_model,
	edge_based_wireframe_model);
END_TYPE; -- wireframe_model

TYPE axis2_placement = SELECT (
	axis2_placement_2d,
	axis2_placement_3d);
END_TYPE; -- axis2_placement

TYPE b_spline_curve_form = ENUMERATION OF (
	polyline_form,
	circular_arc,
	elliptic_arc,
	parabolic_arc,
	hyperbolic_arc,
	unspecified );
END_TYPE; -- b_spline_curve_form

TYPE b_spline_surface_form = ENUMERATION OF (
	plane_surf,
	cylindrical_surf,
	conical_surf,
	spherical_surf,
	toroidal_surf,
	surf_of_revolution,
	ruled_surf,
	generalised_cone,
	quadric_surf,
	surf_of_linear_extrusion,
	unspecified );
END_TYPE; -- b_spline_surface_form

TYPE curve_on_surface = SELECT (
	pcurve,
	surface_curve,
	composite_curve_on_surface);
END_TYPE; -- curve_on_surface

TYPE dimension_count = INTEGER;
WHERE
	WR1 :  SELF > 0 ;
END_TYPE; -- dimension_count

TYPE extent_enumeration = ENUMERATION OF (
	invalid,
	zero,
	finite_non_zero,
	infinite );
END_TYPE; -- extent_enumeration

TYPE knot_type = ENUMERATION OF (
	uniform_knots,
	quasi_uniform_knots,
	piecewise_bezier_knots,
	unspecified );
END_TYPE; -- knot_type

TYPE pcurve_or_surface = SELECT (
	pcurve,
	surface);
END_TYPE; -- pcurve_or_surface

TYPE preferred_surface_curve_representation = ENUMERATION OF (
	curve_3d,
	pcurve_s1,
	pcurve_s2 );
END_TYPE; -- preferred_surface_curve_representation

TYPE surface_boundary = SELECT (
	boundary_curve,
	degenerate_pcurve);
END_TYPE; -- surface_boundary

TYPE transition_code = ENUMERATION OF (
	discontinuous,
	continuous,
	cont_same_gradient,
	cont_same_gradient_same_curvature );
END_TYPE; -- transition_code

TYPE trimming_preference = ENUMERATION OF (
	cartesian,
	parameter,
	unspecified );
END_TYPE; -- trimming_preference

TYPE trimming_select = SELECT (
	cartesian_point,
	parameter_value);
END_TYPE; -- trimming_select

TYPE vector_or_direction = SELECT (
	vector,
	direction);
END_TYPE; -- vector_or_direction

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE; -- groupable_item

TYPE identification_item = EXTENSIBLE SELECT ;
END_TYPE; -- identification_item

TYPE versionable_item = EXTENSIBLE SELECT ;
END_TYPE; -- versionable_item

TYPE imtamr_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	component_definition,
	component_feature,
	component_interface_terminal,
	component_shape_aspect,
	component_terminal,
	laminate_component_interface_terminal);
END_TYPE; -- imtamr_document_reference_item

TYPE effectivity_item_for_replacement = SELECT BASED_ON effectivity_item WITH (
	product_definition_relationship);
END_TYPE; -- effectivity_item_for_replacement

TYPE limd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	inter_stratum_feature,
	stratum,
	stratum_feature);
END_TYPE; -- limd_document_reference_item

TYPE mri_aliasable_item = EXTENSIBLE SELECT BASED_ON aliasable_item WITH (
	approval_status,
	contract,
	organization,
	security_classification_level);
END_TYPE; -- mri_aliasable_item

TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH (
	certification,
	contract);
END_TYPE; -- mri_approval_item

TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH (
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	identification_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization);
END_TYPE; -- mri_attribute_language_item

TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	certification,
	contract,
	security_classification);
END_TYPE; -- mri_date_and_time_item

TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	certification,
	contract,
	security_classification);
END_TYPE; -- mri_date_item

TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
	approval_status,
	contract,
	organization,
	security_classification_level);
END_TYPE; -- mri_identification_item

TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH (
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	identification_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization);
END_TYPE; -- mri_multi_language_attribute_item

TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH (
	applied_identification_assignment,
	applied_security_classification_assignment,
	contract);
END_TYPE; -- mri_organization_item

TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH (
	applied_identification_assignment,
	applied_security_classification_assignment,
	contract);
END_TYPE; -- mri_person_and_organization_item

TYPE attribute_type = SELECT (
	label,
	text);
END_TYPE; -- attribute_type

TYPE mt_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	design_object);
END_TYPE; -- mt_groupable_item

TYPE characterized_material_property = SELECT (
	material_property_representation,
	product_material_composition_relationship);
END_TYPE; -- characterized_material_property

TYPE atom_based_tuple = LIST [0:?] OF atom_based_value;
END_TYPE; -- atom_based_tuple

TYPE atom_based_value = SELECT (
	maths_atom,
	atom_based_tuple);
END_TYPE; -- atom_based_value

TYPE dotted_express_identifier = STRING;
WHERE
	syntax :  dotted_identifiers_syntax(SELF);
END_TYPE; -- dotted_express_identifier

TYPE elementary_function_enumerators = ENUMERATION OF (
	ef_and,
	ef_or,
	ef_not,
	ef_xor,
	ef_negate_i,
	ef_add_i,
	ef_subtract_i,
	ef_multiply_i,
	ef_divide_i,
	ef_mod_i,
	ef_exponentiate_i,
	ef_eq_i,
	ef_ne_i,
	ef_gt_i,
	ef_lt_i,
	ef_ge_i,
	ef_le_i,
	ef_abs_i,
	ef_max_i,
	ef_min_i,
	ef_if_i,
	ef_negate_r,
	ef_reciprocal_r,
	ef_add_r,
	ef_subtract_r,
	ef_multiply_r,
	ef_divide_r,
	ef_mod_r,
	ef_exponentiate_r,
	ef_exponentiate_ri,
	ef_eq_r,
	ef_ne_r,
	ef_gt_r,
	ef_lt_r,
	ef_ge_r,
	ef_le_r,
	ef_abs_r,
	ef_max_r,
	ef_min_r,
	ef_acos_r,
	ef_asin_r,
	ef_atan2_r,
	ef_cos_r,
	ef_exp_r,
	ef_ln_r,
	ef_log2_r,
	ef_log10_r,
	ef_sin_r,
	ef_sqrt_r,
	ef_tan_r,
	ef_if_r,
	ef_form_c,
	ef_rpart_c,
	ef_ipart_c,
	ef_negate_c,
	ef_reciprocal_c,
	ef_add_c,
	ef_subtract_c,
	ef_multiply_c,
	ef_divide_c,
	ef_exponentiate_c,
	ef_exponentiate_ci,
	ef_eq_c,
	ef_ne_c,
	ef_conjugate_c,
	ef_abs_c,
	ef_arg_c,
	ef_cos_c,
	ef_exp_c,
	ef_ln_c,
	ef_sin_c,
	ef_sqrt_c,
	ef_tan_c,
	ef_if_c,
	ef_subscript_s,
	ef_eq_s,
	ef_ne_s,
	ef_gt_s,
	ef_lt_s,
	ef_ge_s,
	ef_le_s,
	ef_subsequence_s,
	ef_concat_s,
	ef_size_s,
	ef_format,
	ef_value,
	ef_like,
	ef_if_s,
	ef_subscript_b,
	ef_eq_b,
	ef_ne_b,
	ef_gt_b,
	ef_lt_b,
	ef_ge_b,
	ef_le_b,
	ef_subsequence_b,
	ef_concat_b,
	ef_size_b,
	ef_if_b,
	ef_subscript_t,
	ef_eq_t,
	ef_ne_t,
	ef_concat_t,
	ef_size_t,
	ef_entuple,
	ef_detuple,
	ef_insert,
	ef_remove,
	ef_if_t,
	ef_sum_it,
	ef_product_it,
	ef_add_it,
	ef_subtract_it,
	ef_scalar_mult_it,
	ef_dot_prod_it,
	ef_sum_rt,
	ef_product_rt,
	ef_add_rt,
	ef_subtract_rt,
	ef_scalar_mult_rt,
	ef_dot_prod_rt,
	ef_norm_rt,
	ef_sum_ct,
	ef_product_ct,
	ef_add_ct,
	ef_subtract_ct,
	ef_scalar_mult_ct,
	ef_dot_prod_ct,
	ef_norm_ct,
	ef_if,
	ef_ensemble,
	ef_member_of );
END_TYPE; -- elementary_function_enumerators

TYPE elementary_space_enumerators = ENUMERATION OF (
	es_numbers,
	es_complex_numbers,
	es_reals,
	es_integers,
	es_logicals,
	es_booleans,
	es_strings,
	es_binarys,
	es_maths_spaces,
	es_maths_functions,
	es_generics );
END_TYPE; -- elementary_space_enumerators

TYPE express_identifier = dotted_express_identifier;
WHERE
	syntax :  dot_count(SELF)= 0 ;
END_TYPE; -- express_identifier

TYPE extension_options = ENUMERATION OF (
	eo_none,
	eo_cont,
	eo_cont_right,
	eo_cont_left );
END_TYPE; -- extension_options

TYPE input_selector = positive_integer;
END_TYPE; -- input_selector

TYPE lower_upper = ENUMERATION OF (
	lower,
	upper );
END_TYPE; -- lower_upper

TYPE maths_atom = SELECT (
	maths_simple_atom,
	maths_enum_atom);
END_TYPE; -- maths_atom

TYPE maths_binary = BINARY;
END_TYPE; -- maths_binary

TYPE maths_boolean = BOOLEAN;
END_TYPE; -- maths_boolean

TYPE maths_enum_atom = SELECT (
	elementary_space_enumerators,
	ordering_type,
	lower_upper,
	symmetry_type,
	elementary_function_enumerators,
	open_closed,
	space_constraint_type,
	repackage_options,
	extension_options);
END_TYPE; -- maths_enum_atom

TYPE maths_expression = SELECT (
	atom_based_value,
	maths_tuple,
	generic_expression);
END_TYPE; -- maths_expression

TYPE maths_function_select = SELECT (
	maths_function,
	elementary_function_enumerators);
END_TYPE; -- maths_function_select

TYPE maths_integer = INTEGER;
END_TYPE; -- maths_integer

TYPE maths_logical = LOGICAL;
END_TYPE; -- maths_logical

TYPE maths_number = NUMBER;
END_TYPE; -- maths_number

TYPE maths_real = REAL;
END_TYPE; -- maths_real

TYPE maths_simple_atom = SELECT (
	maths_number,
	maths_real,
	maths_number,
	maths_logical,
	maths_boolean,
	maths_string,
	maths_binary);
END_TYPE; -- maths_simple_atom

TYPE maths_space_or_function = SELECT (
	maths_space,
	maths_function);
END_TYPE; -- maths_space_or_function

TYPE maths_string = STRING;
END_TYPE; -- maths_string

TYPE maths_tuple = LIST [0:?] OF maths_value;
END_TYPE; -- maths_tuple

TYPE maths_value = SELECT (
	atom_based_value,
	maths_tuple,
	generic_expression);
WHERE
	constancy :  NOT('GENERIC_EXPRESSION' IN stripped_typeof(SELF))OR expression_is_constant(SELF);
END_TYPE; -- maths_value

TYPE nonnegative_integer = INTEGER;
WHERE
	nonnegativity :  SELF >= 0 ;
END_TYPE; -- nonnegative_integer

TYPE one_or_two = positive_integer;
WHERE
	in_range : (SELF  = 1)OR(SELF = 2);
END_TYPE; -- one_or_two

TYPE open_closed = ENUMERATION OF (
	open,
	closed );
END_TYPE; -- open_closed

TYPE ordering_type = ENUMERATION OF (
	by_rows,
	by_columns );
END_TYPE; -- ordering_type

TYPE positive_integer = nonnegative_integer;
WHERE
	positivity :  SELF > 0 ;
END_TYPE; -- positive_integer

TYPE product_space = SELECT (
	uniform_product_space,
	listed_product_space);
END_TYPE; -- product_space

TYPE real_interval = SELECT (
	real_interval_from_min,
	real_interval_to_max,
	finite_real_interval,
	elementary_space);
WHERE
	WR1 :  NOT('ELEMENTARY_SPACE' IN stripped_typeof(SELF))OR(SELF \ elementary_space.space_id = es_reals);
END_TYPE; -- real_interval

TYPE repackage_options = ENUMERATION OF (
	ro_nochange,
	ro_wrap_as_tuple,
	ro_unwrap_tuple );
END_TYPE; -- repackage_options

TYPE space_constraint_type = ENUMERATION OF (
	sc_equal,
	sc_subspace,
	sc_member );
END_TYPE; -- space_constraint_type

TYPE symmetry_type = ENUMERATION OF (
	identity,
	skew,
	hermitian,
	skew_hermitian );
END_TYPE; -- symmetry_type

TYPE tuple_space = SELECT (
	product_space,
	extended_tuple_space);
END_TYPE; -- tuple_space

TYPE zero_or_one = nonnegative_integer;
WHERE
	in_range : (SELF  = 0)OR(SELF = 1);
END_TYPE; -- zero_or_one

TYPE amount_of_substance_measure = REAL;
END_TYPE; -- amount_of_substance_measure

TYPE area_measure = REAL;
END_TYPE; -- area_measure

TYPE celsius_temperature_measure = REAL;
END_TYPE; -- celsius_temperature_measure

TYPE context_dependent_measure = REAL;
END_TYPE; -- context_dependent_measure

TYPE count_measure = NUMBER;
END_TYPE; -- count_measure

TYPE descriptive_measure = STRING;
END_TYPE; -- descriptive_measure

TYPE electric_current_measure = REAL;
END_TYPE; -- electric_current_measure

TYPE length_measure = REAL;
END_TYPE; -- length_measure

TYPE luminous_intensity_measure = REAL;
END_TYPE; -- luminous_intensity_measure

TYPE mass_measure = REAL;
END_TYPE; -- mass_measure

TYPE measure_value = SELECT (
	amount_of_substance_measure,
	area_measure,
	celsius_temperature_measure,
	context_dependent_measure,
	count_measure,
	descriptive_measure,
	electric_current_measure,
	length_measure,
	luminous_intensity_measure,
	mass_measure,
	numeric_measure,
	parameter_value,
	plane_angle_measure,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	ratio_measure,
	solid_angle_measure,
	thermodynamic_temperature_measure,
	time_measure,
	volume_measure);
END_TYPE; -- measure_value

TYPE numeric_measure = NUMBER;
END_TYPE; -- numeric_measure

TYPE parameter_value = REAL;
END_TYPE; -- parameter_value

TYPE plane_angle_measure = REAL;
END_TYPE; -- plane_angle_measure

TYPE positive_length_measure = length_measure;
WHERE
	WR1 :  SELF > 0.0 ;
END_TYPE; -- positive_length_measure

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
	WR1 :  SELF > 0.0 ;
END_TYPE; -- positive_plane_angle_measure

TYPE positive_ratio_measure = ratio_measure;
WHERE
	WR1 :  SELF > 0.0 ;
END_TYPE; -- positive_ratio_measure

TYPE ratio_measure = REAL;
END_TYPE; -- ratio_measure

TYPE si_prefix = ENUMERATION OF (
	exa,
	peta,
	tera,
	giga,
	mega,
	kilo,
	hecto,
	deca,
	deci,
	centi,
	milli,
	micro,
	nano,
	pico,
	femto,
	atto );
END_TYPE; -- si_prefix

TYPE si_unit_name = ENUMERATION OF (
	metre,
	gram,
	second,
	ampere,
	kelvin,
	mole,
	candela,
	radian,
	steradian,
	hertz,
	newton,
	pascal,
	joule,
	watt,
	coulomb,
	volt,
	farad,
	ohm,
	siemens,
	weber,
	tesla,
	henry,
	degree_Celsius,
	lumen,
	lux,
	becquerel,
	gray,
	sievert );
END_TYPE; -- si_unit_name

TYPE solid_angle_measure = REAL;
END_TYPE; -- solid_angle_measure

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; -- thermodynamic_temperature_measure

TYPE time_measure = REAL;
END_TYPE; -- time_measure

TYPE unit = SELECT (
	derived_unit,
	named_unit);
END_TYPE; -- unit

TYPE volume_measure = REAL;
END_TYPE; -- volume_measure

TYPE model_parameter_assigned_item = SELECT (
	unit);
END_TYPE; -- model_parameter_assigned_item

TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	multi_language_attribute_assignment,
	attribute_value_assignment);
END_TYPE; -- attribute_language_item

TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- multi_language_attribute_item

TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- name_item

TYPE product_definition_or_assembly_relationship = SELECT (
	assembly_component_usage,
	product_definition);
END_TYPE; -- product_definition_or_assembly_relationship

TYPE organization_item = EXTENSIBLE SELECT ;
END_TYPE; -- organization_item

TYPE person_and_organization_item = EXTENSIBLE SELECT ;
END_TYPE; -- person_and_organization_item

TYPE person_organization_select = SELECT (
	organization,
	person,
	person_and_organization);
END_TYPE; -- person_organization_select

TYPE puuv_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	shape_aspect);
END_TYPE; -- puuv_document_reference_item

TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH (
	externally_defined_class);
END_TYPE; -- plib_class_identification_item

TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH (
	class);
END_TYPE; -- plib_class_organization_item

TYPE approximation_method = ENUMERATION OF (
	chordal_deviation,
	chordal_length );
END_TYPE; -- approximation_method

TYPE box_characteristic_select = SELECT (
	box_height,
	box_width,
	box_slant_angle,
	box_rotate_angle);
END_TYPE; -- box_characteristic_select

TYPE box_height = positive_ratio_measure;
END_TYPE; -- box_height

TYPE box_rotate_angle = plane_angle_measure;
END_TYPE; -- box_rotate_angle

TYPE box_slant_angle = plane_angle_measure;
END_TYPE; -- box_slant_angle

TYPE box_width = positive_ratio_measure;
END_TYPE; -- box_width

TYPE character_spacing_select = SELECT (
	length_measure,
	ratio_measure,
	measure_with_unit,
	descriptive_measure,
	pre_defined_character_spacing);
END_TYPE; -- character_spacing_select

TYPE character_style_select = SELECT (
	character_glyph_style_stroke,
	character_glyph_style_outline,
	text_style_for_defined_font);
END_TYPE; -- character_style_select

TYPE curve_font_or_scaled_curve_font_select = SELECT (
	curve_style_font_select,
	curve_style_font_and_scaling);
END_TYPE; -- curve_font_or_scaled_curve_font_select

TYPE curve_or_annotation_curve_occurrence = SELECT (
	curve,
	annotation_curve_occurrence);
END_TYPE; -- curve_or_annotation_curve_occurrence

TYPE curve_or_render = SELECT (
	curve_style,
	curve_style_rendering);
END_TYPE; -- curve_or_render

TYPE curve_style_font_select = SELECT (
	curve_style_font,
	pre_defined_curve_font,
	externally_defined_curve_font);
END_TYPE; -- curve_style_font_select

TYPE curve_tolerance_deviation = positive_length_measure;
END_TYPE; -- curve_tolerance_deviation

TYPE curve_tolerance_parameter = REAL;
END_TYPE; -- curve_tolerance_parameter

TYPE direction_count_select = SELECT (
	u_direction_count,
	v_direction_count);
END_TYPE; -- direction_count_select

TYPE fill_area_style_tile_shape_select = SELECT (
	fill_area_style_tile_curve_with_style,
	fill_area_style_tile_coloured_region,
	fill_area_style_tile_symbol_with_style,
	pre_defined_tile,
	externally_defined_tile);
END_TYPE; -- fill_area_style_tile_shape_select

TYPE fill_style_select = SELECT (
	fill_area_style_colour,
	pre_defined_tile_style,
	externally_defined_tile_style,
	fill_area_style_tiles,
	pre_defined_hatch_style,
	externally_defined_hatch_style,
	fill_area_style_hatching);
END_TYPE; -- fill_style_select

TYPE hiding_or_blanking_select = SELECT (
	presentation_area,
	presentation_view,
	product_data_representation_view,
	annotation_fill_area,
	area_dependent_annotation_representation,
	view_dependent_annotation_representation,
	annotation_text_with_delineation,
	character_glyph_symbol_stroke,
	character_glyph_symbol_outline,
	symbol_representation_with_blanking_box);
END_TYPE; -- hiding_or_blanking_select

TYPE invisibility_context = SELECT (
	presentation_layer_usage,
	presentation_representation,
	presentation_set);
END_TYPE; -- invisibility_context

TYPE invisible_item = SELECT (
	styled_item,
	presentation_layer_assignment,
	representation);
END_TYPE; -- invisible_item

TYPE marker_select = SELECT (
	marker_type,
	pre_defined_marker);
END_TYPE; -- marker_select

TYPE marker_type = ENUMERATION OF (
	dot,
	x,
	plus,
	asterisk,
	ring,
	square,
	triangle );
END_TYPE; -- marker_type

TYPE null_style = ENUMERATION OF (
	null );
END_TYPE; -- null_style

TYPE presentation_style_select = SELECT (
	pre_defined_presentation_style,
	point_style,
	curve_style,
	surface_style_usage,
	symbol_style,
	fill_area_style,
	text_style,
	approximation_tolerance,
	externally_defined_style,
	null_style);
END_TYPE; -- presentation_style_select

TYPE product_or_presentation_space = ENUMERATION OF (
	product_shape_space,
	presentation_area_space );
END_TYPE; -- product_or_presentation_space

TYPE rendering_properties_select = SELECT (
	surface_style_reflectance_ambient,
	surface_style_transparent);
END_TYPE; -- rendering_properties_select

TYPE shading_curve_method = ENUMERATION OF (
	constant_colour,
	linear_colour );
END_TYPE; -- shading_curve_method

TYPE shading_surface_method = ENUMERATION OF (
	constant_shading,
	colour_shading,
	dot_shading,
	normal_shading );
END_TYPE; -- shading_surface_method

TYPE size_select = SELECT (
	positive_length_measure,
	measure_with_unit,
	descriptive_measure,
	pre_defined_size);
END_TYPE; -- size_select

TYPE squared_or_rounded = ENUMERATION OF (
	squared,
	rounded );
END_TYPE; -- squared_or_rounded

TYPE style_context_select = SELECT (
	group,
	presentation_layer_assignment,
	representation,
	representation_item,
	presentation_set);
END_TYPE; -- style_context_select

TYPE surface_side = ENUMERATION OF (
	positive,
	negative,
	both );
END_TYPE; -- surface_side

TYPE surface_side_style_select = SELECT (
	surface_side_style,
	pre_defined_surface_side_style);
END_TYPE; -- surface_side_style_select

TYPE surface_style_element_select = SELECT (
	surface_style_fill_area,
	surface_style_boundary,
	surface_style_silhouette,
	surface_style_segmentation_curve,
	surface_style_control_grid,
	surface_style_parameter_line,
	surface_style_rendering);
END_TYPE; -- surface_style_element_select

TYPE surface_tolerance_deviation = positive_length_measure;
END_TYPE; -- surface_tolerance_deviation

TYPE surface_tolerance_parameter = REAL;
END_TYPE; -- surface_tolerance_parameter

TYPE symbol_style_select = SELECT (
	symbol_element_style,
	symbol_colour);
END_TYPE; -- symbol_style_select

TYPE text_justification = label;
END_TYPE; -- text_justification

TYPE tolerance_deviation_select = SELECT (
	curve_tolerance_deviation,
	surface_tolerance_deviation);
END_TYPE; -- tolerance_deviation_select

TYPE tolerance_parameter_select = SELECT (
	curve_tolerance_parameter,
	surface_tolerance_parameter);
END_TYPE; -- tolerance_parameter_select

TYPE tolerance_select = SELECT (
	approximation_tolerance_deviation,
	approximation_tolerance_parameter);
END_TYPE; -- tolerance_select

TYPE u_direction_count = INTEGER;
WHERE
	WR1 :  SELF > 1 ;
END_TYPE; -- u_direction_count

TYPE v_direction_count = INTEGER;
WHERE
	WR1 :  SELF > 1 ;
END_TYPE; -- v_direction_count

TYPE defined_glyph_select = SELECT (
	pre_defined_character_glyph,
	externally_defined_character_glyph);
END_TYPE; -- defined_glyph_select

TYPE defined_symbol_select = SELECT (
	pre_defined_symbol,
	externally_defined_symbol);
END_TYPE; -- defined_symbol_select

TYPE text_alignment = label;
END_TYPE; -- text_alignment

TYPE text_delineation = label;
END_TYPE; -- text_delineation

TYPE text_or_character = SELECT (
	annotation_text,
	annotation_text_character,
	defined_character_glyph,
	composite_text,
	text_literal);
END_TYPE; -- text_or_character

TYPE text_path = ENUMERATION OF (
	left,
	right,
	up,
	down );
END_TYPE; -- text_path

TYPE area_or_view = SELECT (
	presentation_area,
	presentation_view);
END_TYPE; -- area_or_view

TYPE central_or_parallel = ENUMERATION OF (
	central,
	parallel );
END_TYPE; -- central_or_parallel

TYPE layered_item = SELECT (
	presentation_representation,
	representation_item);
END_TYPE; -- layered_item

TYPE presentation_representation_select = SELECT (
	presentation_representation,
	presentation_set);
END_TYPE; -- presentation_representation_select

TYPE presentation_size_assignment_select = SELECT (
	presentation_view,
	presentation_area,
	area_in_set);
END_TYPE; -- presentation_size_assignment_select

TYPE font_select = SELECT (
	pre_defined_text_font,
	externally_defined_text_font);
END_TYPE; -- font_select

TYPE presentable_text = STRING;
END_TYPE; -- presentable_text

TYPE staircase_or_linear = ENUMERATION OF (
	staircase,
	linear );
END_TYPE; -- staircase_or_linear

TYPE pplt_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	printed_part_template_terminal);
END_TYPE; -- pplt_groupable_item

TYPE characterized_action_definition = SELECT (
	action,
	action_method,
	action_method_relationship,
	action_relationship);
END_TYPE; -- characterized_action_definition

TYPE characterized_resource_definition = SELECT (
	action_resource,
	action_resource_relationship,
	action_resource_requirement,
	action_resource_requirement_relationship);
END_TYPE; -- characterized_resource_definition

TYPE property_or_shape_select = SELECT (
	property_definition,
	shape_definition);
END_TYPE; -- property_or_shape_select

TYPE source = ENUMERATION OF (
	made,
	bought,
	not_known );
END_TYPE; -- source

TYPE characterized_definition = SELECT (
	characterized_object,
	characterized_product_definition,
	shape_definition);
END_TYPE; -- characterized_definition

TYPE characterized_product_definition = SELECT (
	product_definition,
	product_definition_relationship);
END_TYPE; -- characterized_product_definition

TYPE derived_property_select = SELECT (
	action_property,
	property_definition,
	resource_property);
END_TYPE; -- derived_property_select

TYPE shape_definition = SELECT (
	product_definition_shape,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- shape_definition

TYPE represented_definition = SELECT (
	general_property,
	property_definition,
	property_definition_relationship,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- represented_definition

TYPE pr_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	rule_action);
END_TYPE; -- pr_date_and_time_item

TYPE rule_superseded_item = SELECT (
	product_definition_formation);
END_TYPE; -- rule_superseded_item

TYPE project_as_date_and_time_item = SELECT BASED_ON date_and_time_item WITH (
	organizational_project);
END_TYPE; -- project_as_date_and_time_item

TYPE project_as_date_item = SELECT BASED_ON date_item WITH (
	organizational_project);
END_TYPE; -- project_as_date_item

TYPE project_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH (
	organizational_project);
END_TYPE; -- project_event_occurrence_item

TYPE project_item = EXTENSIBLE SELECT ;
END_TYPE; -- project_item

TYPE value_qualifier = SELECT (
	precision_qualifier,
	type_qualifier,
	uncertainty_qualifier);
END_TYPE; -- value_qualifier

TYPE compound_item_definition = SELECT (
	list_representation_item,
	set_representation_item);
END_TYPE; -- compound_item_definition

TYPE founded_item_select = SELECT (
	founded_item,
	representation_item);
END_TYPE; -- founded_item_select

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE; -- list_representation_item

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE; -- set_representation_item

TYPE transformation = SELECT (
	item_defined_transformation,
	functionally_defined_transformation);
END_TYPE; -- transformation

TYPE requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- requirement_assigned_item

TYPE requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- requirement_source_item

TYPE rd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	requirements_property);
END_TYPE; -- rd_document_reference_item

TYPE rd_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	requirements_property);
END_TYPE; -- rd_groupable_item

TYPE requirement_identification_and_version_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH (
	product,
	product_definition_formation);
END_TYPE; -- requirement_identification_and_version_mri_identification_item

TYPE security_classification_item = EXTENSIBLE SELECT ;
END_TYPE; -- security_classification_item

TYPE limit_condition = ENUMERATION OF (
	maximum_material_condition,
	least_material_condition,
	regardless_of_feature_size );
END_TYPE; -- limit_condition

TYPE angle_relator = ENUMERATION OF (
	equal,
	large,
	small );
END_TYPE; -- angle_relator

TYPE dimensional_characteristic = SELECT (
	dimensional_location,
	dimensional_size);
END_TYPE; -- dimensional_characteristic

TYPE shape_tolerance_select = SELECT (
	geometric_tolerance,
	plus_minus_tolerance);
END_TYPE; -- shape_tolerance_select

TYPE tolerance_method_definition = SELECT (
	tolerance_value,
	limits_and_fits);
END_TYPE; -- tolerance_method_definition

TYPE spr_document_reference_item = SELECT BASED_ON document_reference_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_document_reference_item

TYPE spr_organization_item = EXTENSIBLE SELECT BASED_ON organization_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_organization_item

TYPE spr_person_and_organization_item = EXTENSIBLE SELECT BASED_ON person_and_organization_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_person_and_organization_item

TYPE document_identifier_assigned_item = SELECT (
	document);
END_TYPE; -- document_identifier_assigned_item

TYPE sd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	configuration_item,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- sd_document_reference_item

TYPE identifier = STRING;
END_TYPE; -- identifier

TYPE label = STRING;
END_TYPE; -- label

TYPE text = STRING;
END_TYPE; -- text

TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
END_TYPE; -- list_of_reversible_topology_item

TYPE reversible_topology = SELECT (
	reversible_topology_item,
	list_of_reversible_topology_item,
	set_of_reversible_topology_item);
END_TYPE; -- reversible_topology

TYPE reversible_topology_item = SELECT (
	edge,
	path,
	face,
	face_bound,
	closed_shell,
	open_shell);
END_TYPE; -- reversible_topology_item

TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
END_TYPE; -- set_of_reversible_topology_item

TYPE shell = SELECT (
	vertex_shell,
	wire_shell,
	open_shell,
	closed_shell);
END_TYPE; -- shell

TYPE action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- action_request_item

ENTITY action;
	name : label;
	description : OPTIONAL text;
	chosen_method : action_method;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- action


ENTITY action_directive;
	name : label;
	description : OPTIONAL text;
	analysis : text;
	comment : text;
	requests : SET [1:?] OF versioned_action_request;
END_ENTITY; -- action_directive


ENTITY action_method;
	name : label;
	description : OPTIONAL text;
	consequence : text;
	purpose : text;
END_ENTITY; -- action_method


ENTITY action_method_relationship;
	name : label;
	description : OPTIONAL text;
	relating_method : action_method;
	related_method : action_method;
END_ENTITY; -- action_method_relationship


ENTITY action_relationship;
	name : label;
	description : OPTIONAL text;
	relating_action : action;
	related_action : action;
END_ENTITY; -- action_relationship


ENTITY action_request_solution;
	method : action_method;
	request : versioned_action_request;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- action_request_solution


ENTITY action_request_status;
	status : label;
	assigned_request : versioned_action_request;
END_ENTITY; -- action_request_status


ENTITY action_resource;
	name : label;
	description : OPTIONAL text;
	usage : SET [1:?] OF supported_item;
	kind : action_resource_type;
END_ENTITY; -- action_resource


ENTITY action_resource_relationship;
	name : label;
	description : OPTIONAL text;
	relating_resource : action_resource;
	related_resource : action_resource;
END_ENTITY; -- action_resource_relationship


ENTITY action_resource_type;
	name : label;
END_ENTITY; -- action_resource_type


ENTITY action_status;
	status : label;
	assigned_action : executed_action;
END_ENTITY; -- action_status


ENTITY directed_action
	SUBTYPE OF (executed_action);
	directive : action_directive;
END_ENTITY; -- directed_action


ENTITY executed_action
	SUBTYPE OF (action);
END_ENTITY; -- executed_action


ENTITY versioned_action_request;
	id : identifier;
	version : label;
	purpose : text;
	description : OPTIONAL text;
END_ENTITY; -- versioned_action_request


ENTITY versioned_action_request_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_versioned_action_request : versioned_action_request;
	related_versioned_action_request : versioned_action_request;
END_ENTITY; -- versioned_action_request_relationship


ENTITY applied_action_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF action_items;
END_ENTITY; -- applied_action_assignment


ENTITY advanced_brep_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FACETED_BREP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1)))> 0 ;
	WR3 :  SIZEOF(QUERY(msb <* QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN  TYPEOF(it)))| NOT(SIZEOF(QUERY(csh <* msb_shells(msb)| NOT(SIZEOF(QUERY(fcs <* csh \ connected_face_set.cfs_faces | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(fcs))))= 0)))= 0)))= 0 ;
	WR4 :  SIZEOF(QUERY(msb <* QUERY(it <* items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MANIFOLD_SOLID_BREP' IN  TYPEOF(it)))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(msb \ manifold_solid_brep.outer))))= 0 ;
	WR5 :  SIZEOF(QUERY(brv <* QUERY(it <* items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BREP_WITH_VOIDS' IN TYPEOF(it)))| NOT(SIZEOF(QUERY(csh <* brv \ brep_with_voids.voids | csh \ oriented_closed_shell.orientation))= 0)))= 0 ;
	WR6 :  SIZEOF(QUERY(mi <* QUERY(it <* items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it)))| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_BREP_SHAPE_REPRESENTATION' IN TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))))= 0 ;
END_ENTITY; -- advanced_brep_shape_representation


ENTITY curve_swept_solid_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_AREA_SOLID', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_DISK_SOLID', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_AREA_SOLID', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_DISK_SOLID', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1))> 0 ;
	WR3 :  SIZEOF(QUERY(mi <* QUERY(it <* items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it))| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_SWEPT_SOLID_SHAPE_REPRESENTATION' IN TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))))= 0 ;
	WR4 :  SIZEOF(QUERY(scsas <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE_SWEPT_AREA_SOLID' IN  TYPEOF(it))| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(scsas.directrix))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(scsas.directrix)))))= 0 ;
END_ENTITY; -- curve_swept_solid_shape_representation


ENTITY ruled_surface_swept_area_solid
	SUBTYPE OF (surface_curve_swept_area_solid);
WHERE
	WR1 :  'B_SPLINE_SURFACE' IN TYPEOF(SELF.reference_surface)AND(SELF.reference_surface \ b_spline_surface.u_degree = 1);
	WR2 : ('PCURVE' IN  TYPEOF(SELF.directrix))OR(('B_SPLINE_CURVE' IN TYPEOF(SELF.directrix \ surface_curve.curve_3d))AND(SELF.directrix \ surface_curve.curve_3d \ b_spline_curve.degree = SELF.reference_surface \ b_spline_surface.v_degree));
END_ENTITY; -- ruled_surface_swept_area_solid


ENTITY angularity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)< 3 ;
END_ENTITY; -- angularity_tolerance


ENTITY circular_runout_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 2 ;
END_ENTITY; -- circular_runout_tolerance


ENTITY coaxiality_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 2 ;
END_ENTITY; -- coaxiality_tolerance


ENTITY common_datum
	SUBTYPE OF (composite_shape_aspect, datum);
WHERE
	WR1 :  SIZEOF(SELF.component_relationships)= 2 ;
	WR2 :  SIZEOF(QUERY(sar <* SELF.component_relationships | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DATUM' IN  TYPEOF(sar.related_shape_aspect))AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMMON_DATUM' IN TYPEOF(sar.related_shape_aspect)))))= 0 ;
END_ENTITY; -- common_datum


ENTITY concentricity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)= 1 ;
END_ENTITY; -- concentricity_tolerance


ENTITY cylindricity_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- cylindricity_tolerance


ENTITY flatness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- flatness_tolerance


ENTITY line_profile_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3);
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF \ geometric_tolerance.toleranced_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar.name IN [ 'affected plane association', 'resulting intersection curve association' ])))= 1 ;
END_ENTITY; -- line_profile_tolerance


ENTITY parallelism_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)< 3 ;
END_ENTITY; -- parallelism_tolerance


ENTITY perpendicularity_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3 ;
END_ENTITY; -- perpendicularity_tolerance


ENTITY position_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3);
END_ENTITY; -- position_tolerance


ENTITY roundness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- roundness_tolerance


ENTITY straightness_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF));
END_ENTITY; -- straightness_tolerance


ENTITY surface_profile_tolerance
	SUBTYPE OF (geometric_tolerance);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3);
END_ENTITY; -- surface_profile_tolerance


ENTITY symmetry_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 3 ;
END_ENTITY; -- symmetry_tolerance


ENTITY total_runout_tolerance
	SUBTYPE OF (geometric_tolerance_with_datum_reference);
WHERE
	WR1 :  SIZEOF(SELF \ geometric_tolerance_with_datum_reference.datum_system)<= 2 ;
END_ENTITY; -- total_runout_tolerance


ENTITY geometrically_bounded_surface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_SET', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_SET', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1))> 0 ;
	WR3 :  SIZEOF(QUERY(mi <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it))| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRICALLY_BOUNDED_SURFACE_SHAPE_REPRESENTATION' IN  TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))AND(SIZEOF(QUERY(mr_it <* mi \ mapped_item.mapping_source.mapped_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_SET' IN TYPEOF(mr_it))))> 0))))= 0 ;
	WR4 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(pnt <* QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT' IN TYPEOF(gsel))| NOT(gbsf_check_point(pnt))))= 0)))= 0 ;
	WR5 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cv <* QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE' IN TYPEOF(gsel))| NOT(gbsf_check_curve(cv))))= 0)))= 0 ;
	WR6 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(sf <* QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE' IN TYPEOF(gsel))| NOT(gbsf_check_surface(sf))))= 0)))= 0 ;
	WR7 :  SIZEOF(QUERY(gs <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_SET' IN  TYPEOF(it))| SIZEOF(QUERY(gsel <* gs \ geometric_set.elements | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE' IN TYPEOF(gsel)))> 0))> 0 ;
END_ENTITY; -- geometrically_bounded_surface_shape_representation


ENTITY manifold_subsurface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1))> 0 ;
	WR3 :  SIZEOF(QUERY(mi <* QUERY(it <* items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it))| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))))= 0 ;
	WR4 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN  TYPEOF(it))| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OPEN_SHELL' IN TYPEOF(cfss))))= 0 ;
	WR5 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN  TYPEOF(it))| NOT((('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN  TYPEOF(cfss.parent_face_set))AND(SIZEOF(QUERY(fac <* cfss.parent_face_set.cfs_faces | NOT  advanced_face_properties(fac)))= 0))OR(SIZEOF(QUERY(fac <* cfss.parent_face_set.cfs_faces | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(fac))))= 0))))= 0 ;
	WR6 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN TYPEOF(it))|(SIZEOF(QUERY(fac <* cfss \ connected_face_set.cfs_faces | NOT advanced_face_properties(fac)))= 0)))= 0 ;
	WR7 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(fcs <* cfss \ connected_face_set.cfs_faces |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBFACE' IN  TYPEOF(fcs))AND NOT(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fcs.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_CURVE' IN  TYPEOF(oe.edge_element))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBEDGE' IN TYPEOF(oe.edge_element)))))= 0)))= 0)))= 0)))= 0 ;
	WR8 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUBSET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(fcs <* cfss \ connected_face_set.cfs_faces |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBFACE' IN  TYPEOF(fcs))AND  NOT(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fcs.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN  TYPEOF(oe.edge_start))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF(oe.edge_end)))))= 0)))= 0)))= 0)))= 0 ;
	WR9 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(fcs <* cfss \ connected_face_set.cfs_faces |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(fcs))AND(NOT(SIZEOF(QUERY(bnds <* fcs.bounds | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_LOOP' ] * TYPEOF(bnds.bound))= 1)))= 0))))= 0)))= 0 ;
	WR10 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUB_SET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(fcs <* cfss \ connected_face_set.cfs_faces |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBFACE' IN  TYPEOF(fcs))AND(NOT(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fcs.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONIC', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element \ edge_curve.edge_geometry))= 1)))= 0)))= 0))))= 0)))= 0 ;
	WR11 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUBSET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(fcs <* cfss \ connected_face_set.cfs_faces |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBFACE' IN  TYPEOF(fcs))AND(NOT(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fcs.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(oe.edge_element \ edge_curve.edge_geometry))AND(NOT((SIZEOF(QUERY(sc_ag <* oe.edge_element \ edge_curve.edge_geometry \ surface_curve.associated_geometry | NOT('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF(sc_ag))))= 0)))))= 0)))= 0))))= 0)))= 0 ;
	WR12 :  SIZEOF(QUERY(cfss <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONNECTED_FACE_SUBSET' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(fcs <* cfss \ connected_face_set.cfs_faces |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBFACE' IN  TYPEOF(fcs))AND(NOT(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fcs.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(oe.edge_element \ edge_curve.edge_geometry))AND(NOT(SIZEOF(oe \ oriented_edge.edge_element \ edge_curve.edge_geometry \ polyline.points)>= 3))))= 0)))= 0))))= 0)))= 0 ;
END_ENTITY; -- manifold_subsurface_shape_representation


ENTITY manifold_surface_shape_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' ] * TYPEOF(it))= 1))> 0 ;
	WR3 :  SIZEOF(QUERY(mi <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' IN  TYPEOF(it))| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN  TYPEOF(mi \ mapped_item.mapping_source.mapped_representation))AND(SIZEOF(QUERY(mr_it <* mi \ mapped_item.mapping_source.mapped_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(mr_it))))> 0))))= 0 ;
	WR4 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN TYPEOF(it))| NOT(SIZEOF(QUERY(sh <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OPEN_SHELL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CLOSED_SHELL' ] * TYPEOF(sh))= 1)))= 0)))= 0 ;
	WR5 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FACE_SURFACE' IN TYPEOF(fa))))= 0)))= 0)))= 0 ;
	WR6 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(fa))OR(msf_surface_check(fa \ face_surface.face_geometry)))))= 0)))= 0)))= 0 ;
	WR7 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN TYPEOF(fa))OR(SIZEOF(QUERY(bnds <* fa.bounds | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_LOOP' ] * TYPEOF(bnds.bound))= 1)))= 0))))= 0)))= 0)))= 0 ;
	WR8 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(fa))OR(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fa.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds \ path.edge_list | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF(oe.edge_element))))= 0)))= 0))))= 0)))= 0)))= 0 ;
	WR9 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(fa))OR(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fa.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe_cv <* QUERY(oe <* elp_fbnds \ path.edge_list | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF(oe.edge_element))| NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONIC', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_REPLICA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OFFSET_CURVE_3D', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' ] * TYPEOF(oe_cv.edge_element \ edge_curve.edge_geometry))= 1)))= 0)))= 0))))= 0)))= 0)))= 0 ;
	WR10 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(fa))OR(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fa.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds \ path.edge_list | NOT(msf_curve_check(oe.edge_element \ edge_curve.edge_geometry))))= 0)))= 0))))= 0)))= 0)))= 0 ;
	WR11 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(fa))OR(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fa.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds \ path.edge_list | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN  TYPEOF(oe.edge_element.edge_start))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF(oe.edge_element.edge_end)))))= 0)))= 0))))= 0)))= 0)))= 0 ;
	WR12 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(fa))OR(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* fa.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds \ path.edge_list | NOT((SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEGENERATE_PCURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_start \ vertex_point.vertex_geometry))= 1)AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEGENERATE_PCURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_SURFACE' ] * TYPEOF(oe.edge_element.edge_end \ vertex_point.vertex_geometry))= 1))))= 0)))= 0))))= 0)))= 0)))= 0 ;
	WR13 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(fa))OR(SIZEOF(QUERY(vlp_fbnds <* QUERY(bnds <* fa.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_LOOP' IN  TYPEOF(bnds.bound))| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN TYPEOF(vlp_fbnds \ vertex_loop.loop_vertex))))= 0))))= 0)))= 0)))= 0 ;
	WR14 :  SIZEOF(QUERY(sbsm <* QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(it))| NOT(SIZEOF(QUERY(cfs <* sbsm \ shell_based_surface_model.sbsm_boundary | NOT(SIZEOF(QUERY(fa <* cfs \ connected_face_set.cfs_faces | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(fa))OR(SIZEOF(QUERY(vlp_fbnds <* QUERY(bnds <* fa.bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_LOOP' IN TYPEOF(bnds.bound))| NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEGENERATE_PCURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_SURFACE' ] * TYPEOF(vlp_fbnds \ vertex_loop.loop_vertex \ vertex_point.vertex_geometry))= 1)))= 0))))= 0)))= 0)))= 0 ;
END_ENTITY; -- manifold_surface_shape_representation


ENTITY advanced_face
	SUBTYPE OF (face_surface);
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ELEMENTARY_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_SURFACE' ] * TYPEOF(face_geometry))= 1 ;
	WR2 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_CURVE' IN TYPEOF(oe \ oriented_edge.edge_element))))= 0)))= 0 ;
	WR3 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONIC', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF(oe.edge_element \ edge_curve.edge_geometry))= 1)))= 0)))= 0 ;
	WR4 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT((('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN  TYPEOF(oe \ edge.edge_start))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(oe \ edge.edge_start \ vertex_point.vertex_geometry)))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN  TYPEOF(oe \ edge.edge_end))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(oe \ edge.edge_end \ vertex_point.vertex_geometry))))))= 0)))= 0 ;
	WR5 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF(elp_fbnds.bound))))= 0 ;
	WR6 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_SURFACE' IN TYPEOF(face_geometry))OR(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONIC', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_CURVE' ] * TYPEOF(face_geometry \ swept_surface.swept_curve))= 1);
	WR7 :  SIZEOF(QUERY(vlp_fbnds <* QUERY(bnds <* bounds |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_LOOP' IN  TYPEOF(bnds.bound)))| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_POINT' IN  TYPEOF(vlp_fbnds \ face_bound.bound \ vertex_loop.loop_vertex))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT' IN TYPEOF(vlp_fbnds \ face_bound.bound \ vertex_loop.loop_vertex \ vertex_point.vertex_geometry)))))= 0 ;
	WR8 :  SIZEOF(QUERY(bnd <* bounds | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_LOOP' ] * TYPEOF(bnd.bound))= 1)))= 0 ;
	WR9 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(oe \ oriented_edge.edge_element \ edge_curve.edge_geometry))AND NOT(SIZEOF(QUERY(sc_ag <* oe.edge_element \ edge_curve.edge_geometry \ surface_curve.associated_geometry | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(sc_ag))))= 0)))= 0)))= 0 ;
	WR10 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_SURFACE' IN  TYPEOF(face_geometry))OR(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE' IN  TYPEOF(face_geometry \ swept_surface.swept_curve))OR(SIZEOF(face_geometry \ swept_surface.swept_curve \ polyline.points)>= 3)))AND(SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* bounds |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN  TYPEOF(bnds.bound)))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(oe \ oriented_edge.edge_element \ edge_curve.edge_geometry))AND NOT(SIZEOF(oe \ oriented_edge.edge_element \ edge_curve.edge_geometry \ polyline.points)>= 3)))= 0)))= 0);
END_ENTITY; -- advanced_face


ENTITY altered_package_terminal
	ABSTRACT SUPERTYPE OF (((shape_formed_terminal ANDOR surface_prepped_terminal) ANDOR length_trimmed_terminal))
	SUBTYPE OF (package_terminal);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'terminal to be altered'))= 1 ;
	WR2 : (SELF.of_shape.definition \ product_definition.description = 'altered package');
END_ENTITY; -- altered_package_terminal


ENTITY length_trimmed_terminal
	SUBTYPE OF (altered_package_terminal);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2))= 2))= 1)))= 0);
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum trimmed length')))= 1))= 1)))= 0);
	WR3 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum trimmed length')))= 1))= 1)))= 0);
END_ENTITY; -- length_trimmed_terminal


ENTITY shape_formed_terminal
	SUBTYPE OF (altered_package_terminal);
WHERE
	WR1 : (SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document))AND(ada.assigned_document.kind \ document_type.product_data_type = 'lead form specification')AND(SIZEOF(QUERY(dr <* USEDIN(ada.assigned_document, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT')| dr.relating_document.kind \ document_type.product_data_type = 'material specification'))= 1)))= 1);
END_ENTITY; -- shape_formed_terminal


ENTITY surface_prepped_terminal
	SUBTYPE OF (altered_package_terminal);
WHERE
	WR2 : (SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(ada.assigned_document))AND(ada.assigned_document.kind \ document_type.product_data_type = 'surface finish specification')))= 1);
END_ENTITY; -- surface_prepped_terminal


ENTITY across_port_variable
	SUBTYPE OF (port_variable);
END_ENTITY; -- across_port_variable


ENTITY analog_analytical_model_port
	SUBTYPE OF (analytical_model_port);
END_ENTITY; -- analog_analytical_model_port


ENTITY analytical_model
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 2 ;
	WR2 :  SIZEOF(QUERY(dr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| dr.assigned_document.kind \ document_type.product_data_type = 'language reference manual'))= 1 ;
	WR3 :  SIZEOF(QUERY(it <* SELF.items | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODEL_PARAMETER' IN TYPEOF(it))))= 0 ;
	WR4 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr \ representation_relationship.name = 'access mechanism')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL_PORT' IN TYPEOF(rr.rep_2))))>= 1 ;
END_ENTITY; -- analytical_model


ENTITY analytical_model_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ analytical_model_definition)))= 0 ;
END_ENTITY; -- analytical_model_definition


ENTITY analytical_model_make_from_relationship
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' ] * TYPEOF(SELF.rep_1))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' ] * TYPEOF(SELF.rep_2))= 1 ;
	WR3 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2)))))= 0 ;
	WR4 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| NOT((rr \ representation_relationship.name = 'associated make from')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAKE_FROM_MODEL_PORT_RELATIONSHIP' IN TYPEOF(rr.rep_2)))))= 0 ;
	WR5 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' ] * TYPEOF(SELF))= 0 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF \ analytical_model_make_from_relationship)))= 0 ;
END_ENTITY; -- analytical_model_make_from_relationship


ENTITY analytical_model_parameter
	SUBTYPE OF (model_parameter);
WHERE
	WR1 :  SIZEOF(QUERY(cri <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(cri))))= 1 ;
END_ENTITY; -- analytical_model_parameter


ENTITY analytical_model_port
	SUPERTYPE OF ((analytical_model_vector_port ANDOR ONEOF (analog_analytical_model_port, digital_analytical_model_port)))
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(am <* QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| rr \ representation_relationship.name = 'access mechanism')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(am.rep_1)))= 1 ;
END_ENTITY; -- analytical_model_port


ENTITY analytical_model_port_assignment
	SUBTYPE OF (property_definition_representation, representation_relationship);
END_ENTITY; -- analytical_model_port_assignment


ENTITY analytical_model_scalar_port
	SUBTYPE OF (analytical_model_vector_port);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'size')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COUNT_MEASURE' IN TYPEOF(it \ measure_with_unit.value_component))AND(it \ measure_with_unit.value_component = 1)))= 1 ;
END_ENTITY; -- analytical_model_scalar_port


ENTITY analytical_model_vector_port
	SUBTYPE OF (analytical_model_port);
WHERE
	WR1 : (SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'size')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COUNT_MEASURE' IN  TYPEOF(it \ measure_with_unit.value_component))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONTEXT_DEPENDENT_UNIT' IN TYPEOF(it \ measure_with_unit.unit_component))))= 1);
END_ENTITY; -- analytical_model_vector_port


ENTITY analytical_representation
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))>= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(rr.rep_1)))= 1 ;
END_ENTITY; -- analytical_representation


ENTITY digital_analytical_model_port
	SUBTYPE OF (analytical_model_port);
WHERE
	WR2 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'nominal signal flow direction')AND(it \ descriptive_representation_item.description IN [ 'input direction', 'output direction', 'bidirectional', 'unknown direction' ])))= 1 ;
	WR3 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'port type')AND(it \ descriptive_representation_item.description IN [ 'string property type', 'logical property type', 'boolean property type' ])))= 1 ;
END_ENTITY; -- digital_analytical_model_port


ENTITY make_from_model_port_relationship
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL_PORT' ] * TYPEOF(SELF.rep_1))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL_PORT' ] * TYPEOF(SELF.rep_2))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF \ make_from_model_port_relationship))= 0 ;
	WR4 :  rep_1 :<>: rep_2 ;
	WR5 :  SIZEOF(QUERY(rr1 <* USEDIN(SELF.rep_1, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(SIZEOF(QUERY(rr2 <* USEDIN(SELF.rep_2, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(rr1.rep_1 :=: rr2.rep_1)))= 0)))= 1 ;
	WR6 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL_MAKE_FROM_RELATIONSHIP')IN TYPEOF(rr.rep_1))))= 1 ;
END_ENTITY; -- make_from_model_port_relationship


ENTITY port_variable
	SUPERTYPE OF (ONEOF (across_port_variable, through_port_variable, transform_port_variable))
	SUBTYPE OF (representation, representation_item);
END_ENTITY; -- port_variable


ENTITY through_port_variable
	SUBTYPE OF (port_variable);
END_ENTITY; -- through_port_variable


ENTITY transform_port_variable
	SUBTYPE OF (port_variable);
WHERE
	WR1 : (SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'nominal signal flow direction')AND(it \ descriptive_representation_item.description IN [ 'input direction', 'output direction', 'unknown direction' ]))))= 1 ;
END_ENTITY; -- transform_port_variable


ENTITY applied_promissory_usage_in_product_model_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF promissory_usage_in_product_model_assigned_item;
WHERE
	WR1 :  SIZEOF(QUERY(pm <* items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_CONCEPT' IN TYPEOF(pm)))= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(pd)))= 1 ;
	WR3 :  SIZEOF(items)= 2 ;
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROMISSORY_USAGE_IN_PRODUCT_MODEL' IN TYPEOF(SELF \ group_assignment.assigned_group);
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))<= 1 ;
END_ENTITY; -- applied_promissory_usage_in_product_model_assignment


ENTITY promissory_usage_in_product_model
	SUBTYPE OF (group);
WHERE
	WR1 :  SIZEOF(QUERY(aga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PROMISSORY_USAGE_IN_PRODUCT_MODEL_ASSIGNMENT' IN TYPEOF(aga)))>= 1 ;
END_ENTITY; -- promissory_usage_in_product_model


ENTITY supplied_part_relationship
	SUBTYPE OF (product_definition_relationship);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN TYPEOF(SELF.related_product_definition.formation);
	WR2 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION' IN ROLESOF(SELF));
END_ENTITY; -- supplied_part_relationship


ENTITY application_context;
	application : label;
DERIVE
	description : text :=  get_description_value(SELF);
	id : identifier :=  get_id_value(SELF);
INVERSE
	context_elements: SET [1:?] OF application_context_element FOR frame_of_reference;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- application_context


ENTITY application_context_element
	SUPERTYPE OF (ONEOF (library_context, product_concept_context, product_context, product_definition_context));
	name : label;
	frame_of_reference : application_context;
END_ENTITY; -- application_context_element


ENTITY application_context_relationship;
	name : label;
	description : OPTIONAL text;
	relating_context : application_context;
	related_context : application_context;
END_ENTITY; -- application_context_relationship


ENTITY application_protocol_definition;
	status : label;
	application_interpreted_model_schema_name : label;
	application_protocol_year : year_number;
	application : application_context;
END_ENTITY; -- application_protocol_definition


ENTITY library_context
	SUBTYPE OF (application_context_element);
	library_reference : label;
END_ENTITY; -- library_context


ENTITY product_concept_context
	SUBTYPE OF (application_context_element);
	market_segment_type : label;
END_ENTITY; -- product_concept_context


ENTITY product_context
	SUBTYPE OF (application_context_element);
	discipline_type : label;
END_ENTITY; -- product_context


ENTITY product_definition_context
	SUBTYPE OF (application_context_element);
	life_cycle_stage : label;
END_ENTITY; -- product_definition_context


ENTITY applied_approval_assignment
	SUBTYPE OF (approval_assignment);
	items : SET [1:?] OF approval_item;
END_ENTITY; -- applied_approval_assignment


ENTITY approval;
	status : approval_status;
	level : label;
END_ENTITY; -- approval


ENTITY approval_date_time;
	date_time : date_time_select;
	dated_approval : approval;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- approval_date_time


ENTITY approval_person_organization;
	person_organization : person_organization_select;
	authorized_approval : approval;
	role : approval_role;
END_ENTITY; -- approval_person_organization


ENTITY approval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_approval : approval;
	related_approval : approval;
END_ENTITY; -- approval_relationship


ENTITY approval_role;
	role : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- approval_role


ENTITY approval_status;
	name : label;
END_ENTITY; -- approval_status


ENTITY group_product_definition
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'design requirement' ;
	WR2 : (NOT(SELF  \ product_definition.description = 'placement group'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))>= 1);
END_ENTITY; -- group_product_definition


ENTITY mounting_restriction_area
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  EXISTS(SELF.of_shape.definition \ product_definition.name);
	WR2 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition));
	WR3 :  SELF.of_shape.definition.frame_of_reference.name IN [ 'physical design' ] ;
	WR4 :  SELF.of_shape.definition \ product_definition.name = 'assembly module' ;
	WR5 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))))= 1)))= 0 ;
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'mounting surface')AND(sar.related_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature'))))= 1 ;
	WR7 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ shape_aspect || SELF \ mounting_restriction_area)))= 0 ;
END_ENTITY; -- mounting_restriction_area


ENTITY mounting_restriction_volume
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition));
	WR2 :  SELF.of_shape.definition.frame_of_reference.name IN [ 'physical design' ] ;
	WR3 :  SELF.of_shape.definition.name = 'assembly module' ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 3)))= 1)))= 0 ;
	WR5 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'mounting surface')AND(sar.related_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ shape_aspect || SELF \ mounting_restriction_volume)))= 0 ;
END_ENTITY; -- mounting_restriction_volume


ENTITY minimally_defined_connector
	SUBTYPE OF (packaged_part);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa))AND(sa.description = 'interface terminal')))>= 0)))>= 0 ;
END_ENTITY; -- minimally_defined_connector


ENTITY protocol_physical_layer_definition
	SUBTYPE OF (product_definition);
END_ENTITY; -- protocol_physical_layer_definition


ENTITY protocol_requirement_allocation_to_part_terminal
	SUBTYPE OF (requirement_assignment, requirement_allocation_group);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(SELF \ property_definition_relationship.relating_property_definition);
END_ENTITY; -- protocol_requirement_allocation_to_part_terminal


ENTITY component_mounting_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 : (SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROBE_ACCESS_AREA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND' ] * TYPEOF(SELF))= 0);
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = 'planar projected shape'))<= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = '3d bound volume shape'))<= 1)))= 0 ;
	WR5 : (NOT(SELF  \ shape_aspect.description IN [ 'component feature' ]))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design usage'))<= 1);
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
END_ENTITY; -- component_mounting_feature


ENTITY packaged_component
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1 ;
	WR2 :  SIZEOF(QUERY(pa <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'package alternate')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ] * TYPEOF(pa.relating_product_definition))= 1)AND(pa.relating_product_definition \ product_definition.description = 'altered package')))<= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'packaged component join terminal')))>= 1)))= 0 ;
	WR4 : (NOT(SELF  \ product_definition.description = 'packaged connector component'))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(ip.relating_product_definition))= 1)AND(TRUE)))= 1);
	WR5 : (NOT(SELF  \ product_definition.description = 'packaged connector component'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'packaged component join terminal')))>= 1)))= 0);
	WR6 : (NOT(SELF  \ product_definition.description = 'routed packaged component'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| SIZEOF(QUERY(pd <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))= 1))= 1))= 1)))= 0);
END_ENTITY; -- packaged_component


ENTITY routed_physical_component
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1 ;
	WR2 :  SELF \ product_definition.description :<>: 'laminate component' ;
END_ENTITY; -- routed_physical_component


ENTITY assembly_module_join_terminal
	SUBTYPE OF (assembly_module_terminal);
END_ENTITY; -- assembly_module_join_terminal


ENTITY assembly_definition
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  EXISTS(SELF \ product_definition.name);
	WR2 :  NOT EXISTS(SELF  \ product_definition.name)OR(SELF \ product_definition.name = 'assembly module');
	WR3 : (NOT(SELF.frame_of_reference.name = 'physical design'))OR(SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION' ] * TYPEOF(du.relating_product_definition))= 1)AND(du.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(du.relating_product_definition \ product_definition.name = 'assembly module')))= 1);
	WR4 : (NOT(SELF.frame_of_reference.name = 'physical design usage'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'pca terminal')))>= 2)))= 0);
END_ENTITY; -- assembly_definition


ENTITY assembly_module_interface_terminal
	SUBTYPE OF (assembly_module_terminal);
END_ENTITY; -- assembly_module_interface_terminal


ENTITY assembly_module_terminal
	SUPERTYPE OF (assembly_module_interface_terminal)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  EXISTS(SELF.of_shape.definition \ product_definition.name);
	WR2 :  NOT EXISTS(SELF.of_shape.definition \ product_definition.name)OR(SELF.of_shape.definition \ product_definition.name = 'assembly module');
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
	WR5 : (NOT(SELF  \ shape_aspect.description = 'pca terminal'))OR((SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION' ])>= 1)AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical design usage'));
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))= 1 ;
	WR7 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'interface terminal'))<= 1 ;
END_ENTITY; -- assembly_module_terminal


ENTITY cable_component
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1 ;
	WR2 :  SELF \ product_definition.description :<>: 'laminate component' ;
END_ENTITY; -- cable_component


ENTITY interconnect_module_component_surface_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 : (SELF \ shape_aspect.description IN [ 'interconnect module component surface feature' ]);
	WR3 :  SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| i_f.relating_shape_aspect \ shape_aspect.description IN [ 'interconnect module secondary surface', 'interconnect module primary surface', 'interconnect module cavity surface', 'interconnect module cutout surface', 'interconnect module edge surface', 'interconnect module edge segment surface' ]))= 1 ;
END_ENTITY; -- interconnect_module_component_surface_feature


ENTITY assembly_module_macro_component_join_terminal
	SUBTYPE OF (component_terminal);
WHERE
	WR1 :  NOT(SELF \ shape_aspect.description IN [ 'bare die component terminal', 'component termination passage join terminal', 'conductive interconnect element terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'land join terminal', 'minimally defined component terminal', 'non functional land join terminal', 'packaged component join terminal', 'printed component join terminal', 'package terminal occurrence', 'via terminal' ]);
END_ENTITY; -- assembly_module_macro_component_join_terminal


ENTITY interface_mounted_join
	SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(SELF.related_shape_aspect))AND(SELF.related_shape_aspect \ shape_aspect.description = 'packaged connector component interface terminal');
	WR2 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect))AND((SELF.relating_shape_aspect \ shape_aspect.description = 'packaged connector component interface terminal')OR(SELF.relating_shape_aspect \ shape_aspect.description = 'packaged connector component interface terminal')OR(SELF.relating_shape_aspect \ shape_aspect.description = 'packaged connector component interface terminal')OR(SELF.relating_shape_aspect \ shape_aspect.description = 'packaged connector component interface terminal')OR(SELF.relating_shape_aspect \ shape_aspect.description = 'packaged connector component interface terminal')OR(SELF.relating_shape_aspect \ shape_aspect.description = 'packaged connector component interface terminal'));
END_ENTITY; -- interface_mounted_join


ENTITY electromagnetic_compatibility_requirement_allocation
	SUPERTYPE OF (shield_allocation)
	SUBTYPE OF (requirement_assignment);
END_ENTITY; -- electromagnetic_compatibility_requirement_allocation


ENTITY shield_allocation
	SUBTYPE OF (electromagnetic_compatibility_requirement_allocation);
END_ENTITY; -- shield_allocation


ENTITY thermal_requirement_allocation
	SUBTYPE OF (requirement_assignment);
END_ENTITY; -- thermal_requirement_allocation


ENTITY assembly_bond_definition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1 ;
	WR2 :  SIZEOF(QUERY(aga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BOND_CATEGORY' IN TYPEOF(aga.assigned_group)))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 1'))= 1 ;
	WR4 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 2'))= 1 ;
	WR5 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SIZEOF(QUERY(prpc <* USEDIN(SELF.of_shape.definition.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'technology specific model'))>= 1));
	WR6 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.name = 'assembly bond model');
END_ENTITY; -- assembly_bond_definition


ENTITY assembly_joint
	SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
	WR1 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN  TYPEOF(SELF.relating_shape_aspect))AND(SELF.relating_shape_aspect \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'package terminal occurrence', 'packaged component join terminal' ]))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN  TYPEOF(SELF.relating_shape_aspect))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL' IN  TYPEOF(SELF.relating_shape_aspect))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
	WR2 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN  TYPEOF(SELF.related_shape_aspect))AND(SELF.related_shape_aspect \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'package terminal occurrence', 'packaged component join terminal' ]))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_COMPONENT_SURFACE_FEATURE' IN  TYPEOF(SELF.relating_shape_aspect))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL' IN  TYPEOF(SELF.related_shape_aspect))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_MOUNTING_FEATURE' IN TYPEOF(SELF.relating_shape_aspect));
	WR3 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with bonding'))OR(SIZEOF(QUERY(ddu <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'default definition usage')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect)))= 1);
	WR4 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with bonding'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'bond assembly position')AND(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'assembly position')))= 1)))= 1))<= 1);
	WR5 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with fasteners'))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
	WR6 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))OR is_assembly_module_design(SELF.of_shape.definition);
	WR7 : (NOT(SELF  \ shape_aspect_relationship.name = 'assembled with bonding'))OR(SIZEOF(QUERY(ddu <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'default definition usage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_BOND_DEFINITION' IN TYPEOF(ddu.relating_shape_aspect))AND(SIZEOF(QUERY(sar <* USEDIN(ddu.relating_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 1'))= 1)AND(SIZEOF(QUERY(sar <* USEDIN(ddu.relating_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'bonded feature 1'))= 1)))= 1);
	WR8 :  acyclic_shape_aspect_relationship(SELF , [ SELF \ shape_aspect_relationship.related_shape_aspect ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT');
END_ENTITY; -- assembly_joint


ENTITY component_mating_constraint_condition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name, of_shape;
END_ENTITY; -- component_mating_constraint_condition


ENTITY connection_zone_based_assembly_joint
	SUBTYPE OF (assembly_joint);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'zone 1'))= 1 ;
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'zone 2'))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar.relating_shape_aspect \ shape_aspect.description = 'connection zone'))= 2 ;
END_ENTITY; -- connection_zone_based_assembly_joint


ENTITY reference_packaged_part_assembly_implementation
	SUBTYPE OF (physical_unit);
WHERE
	WR1 : (SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1)AND(SELF \ product_definition.name = 'assembly module');
	WR2 : (NOT(SELF.frame_of_reference.name = 'physical design'))OR(SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_ASSEMBLY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_ASSEMBLY_DEFINITION' ] * TYPEOF(du.relating_product_definition))= 1)AND(du.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(du.relating_product_definition \ product_definition.name = 'assembly module')AND(SIZEOF(QUERY(prpc <* USEDIN(du.relating_product_definition.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1)))= 1);
END_ENTITY; -- reference_packaged_part_assembly_implementation


ENTITY bare_die
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  SIZEOF(QUERY(ifdu <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ property_definition_relationship.name = 'implemented function')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifdu.relating_product_definition))AND(ifdu.relating_product_definition.frame_of_reference.name = 'functional design usage')))= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(dut <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'device unit technology')| dut.relating_property_definition \ property_definition.name = 'unit technology'))= 1))= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE_TERMINAL' IN TYPEOF(sa)))>= 2)))= 0 ;
END_ENTITY; -- bare_die


ENTITY bare_die_bottom_surface
	SUBTYPE OF (bare_die_surface);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ bare_die_bottom_surface || SELF  \ part_mounting_feature || SELF \ bare_die_surface))= 0 ;
END_ENTITY; -- bare_die_bottom_surface


ENTITY bare_die_edge_segment_surface
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	wr1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	wr2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	wr3 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR4 :  SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed surface')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect))))= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ bare_die_edge_segment_surface))= 0 ;
END_ENTITY; -- bare_die_edge_segment_surface


ENTITY bare_die_edge_surface
	SUBTYPE OF (bare_die_surface);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ part_mounting_feature || SELF  \ bare_die_edge_surface || SELF \ bare_die_surface))= 0 ;
END_ENTITY; -- bare_die_edge_surface


ENTITY bare_die_surface
	ABSTRACT SUPERTYPE OF (ONEOF (bare_die_bottom_surface, bare_die_top_surface, bare_die_edge_surface))
	SUBTYPE OF (part_mounting_feature);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
END_ENTITY; -- bare_die_surface


ENTITY bare_die_terminal
	SUBTYPE OF (minimally_defined_bare_die_terminal);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'external connection area')| eca.related_shape_aspect \ shape_aspect.description = 'connection zone'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1 ;
	WR4 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'seating plane zone')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))<= 1 ;
END_ENTITY; -- bare_die_terminal


ENTITY bare_die_top_surface
	SUBTYPE OF (bare_die_surface);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ part_mounting_feature || SELF  \ bare_die_top_surface || SELF \ bare_die_surface))= 0 ;
END_ENTITY; -- bare_die_top_surface


ENTITY minimally_defined_bare_die_terminal
	SUPERTYPE OF (bare_die_terminal)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'external connection area')| eca.related_shape_aspect \ shape_aspect.description = 'connection zone'))<= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))<= 1 ;
	WR4 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
END_ENTITY; -- minimally_defined_bare_die_terminal


ENTITY description_attribute;
	attribute_value : text;
	described_item : description_attribute_select;
END_ENTITY; -- description_attribute


ENTITY id_attribute;
	attribute_value : identifier;
	identified_item : id_attribute_select;
END_ENTITY; -- id_attribute


ENTITY name_attribute;
	attribute_value : label;
	named_item : name_attribute_select;
END_ENTITY; -- name_attribute


ENTITY object_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- object_role


ENTITY role_association;
	role : object_role;
	item_with_role : role_select;
END_ENTITY; -- role_association


ENTITY cable_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CABLE_USAGE_VIEW' IN TYPEOF(SELF.of_shape.definition);
END_ENTITY; -- cable_terminal


ENTITY cable_usage_view
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CABLE_TERMINAL' IN TYPEOF(sa)))>= 1)))= 0 ;
	WR2 :  SELF.frame_of_reference.name IN [ 'physical design usage' ] ;
END_ENTITY; -- cable_usage_view


ENTITY applied_certification_assignment
	SUBTYPE OF (certification_assignment);
	items : SET [1:?] OF certification_item;
END_ENTITY; -- applied_certification_assignment


ENTITY certification;
	name : label;
	purpose : text;
	kind : certification_type;
END_ENTITY; -- certification


ENTITY certification_type;
	description : label;
END_ENTITY; -- certification_type


ENTITY characteristic_type
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name IN [ 'string property', 'logical property', 'boolean property', 'numeric property', 'physical property', 'externally defined property', 'polar complex numeric property', 'compound characteristic' ] ;
END_ENTITY; -- characteristic_type


ENTITY coordinated_representation_item
	SUBTYPE OF (representation, representation_item);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| SIZEOF(USEDIN(pdr, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATA_ENVIRONMENT.ELEMENTS'))<= 1))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 1 ;
	WR3 : (NOT(SELF  \ representation_item.name = 'tolerance'))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))>= 1);
	WR4 : (NOT(SELF  \ representation_item.name = 'plus minus tolerance'))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))= 3);
	WR5 : (NOT(SELF  \ representation_item.name = 'symmetrical tolerance'))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it)))= 2);
	WR6 : (NOT(SELF  \ representation_item.name = 'plus minus tolerance'))OR((SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'basic value')))= 1)AND(SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'plus value')))= 1)AND(SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'minus value')))= 1));
	WR7 : (NOT(SELF  \ representation_item.name = 'symmetrical tolerance'))OR((SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'basic value')))= 1)AND(SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'deviation value')))= 1));
END_ENTITY; -- coordinated_representation_item


ENTITY parameter_type
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name IN [ 'string property type', 'logical property type', 'physical property type', 'boolean property type' ] ;
END_ENTITY; -- parameter_type


ENTITY applied_classification_assignment
	SUBTYPE OF (classification_assignment);
	items : SET [1:?] OF classification_item;
END_ENTITY; -- applied_classification_assignment


ENTITY class
	SUBTYPE OF (group);
END_ENTITY; -- class


ENTITY class_by_extension
	SUBTYPE OF (class);
END_ENTITY; -- class_by_extension


ENTITY class_by_intension
	SUBTYPE OF (class);
END_ENTITY; -- class_by_intension


ENTITY classification
	SUBTYPE OF (classification_assignment);
	classified : classification_select;
DERIVE
	classifier : class :=  SELF \ classification_assignment.assigned_class ;
END_ENTITY; -- classification


ENTITY complete_membership
	SUBTYPE OF (classification_assignment);
DERIVE
	containing_set : class :=  SELF \ classification_assignment.assigned_class ;
END_ENTITY; -- complete_membership


ENTITY complete_membership_of_empty_set
	SUBTYPE OF (complete_membership);
END_ENTITY; -- complete_membership_of_empty_set


ENTITY complete_membership_of_non_empty_set
	SUBTYPE OF (complete_membership);
	members : SET [1:?] OF complete_membership_select;
END_ENTITY; -- complete_membership_of_non_empty_set


ENTITY characterized_class
	SUBTYPE OF (characterized_object, class);
END_ENTITY; -- characterized_class


ENTITY class_system
	SUBTYPE OF (group);
END_ENTITY; -- class_system


ENTITY component_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
END_ENTITY; -- component_feature


ENTITY component_feature_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ component_feature_relationship))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
END_ENTITY; -- component_feature_relationship


ENTITY component_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : (SELF  \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'component termination passage join terminal', 'conductive interconnect element terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'land join terminal', 'minimally defined component terminal', 'non functional land join terminal', 'packaged component join terminal', 'printed component join terminal', 'package terminal occurrence', 'via terminal' ])OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_MACRO_COMPONENT_JOIN_TERMINAL' IN TYPEOF(SELF));
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
	WR4 :  SIZEOF(QUERY(at <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated terminals')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(at.relating_shape_aspect)))<= 1 ;
	WR5 :  SIZEOF(QUERY(cr <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connectivity requirement')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_NETWORK' IN TYPEOF(cr.relating_shape_aspect)))<= 1 ;
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design usage'))<= 1 ;
	WR7 : (NOT(SELF  \ shape_aspect.description IN [ 'assembly module component terminal', 'bare die component terminal', 'package terminal occurrence', 'packaged component join terminal', 'printed component join terminal' ]))OR(SELF.product_definitional);
	WR8 : (NOT(SELF  \ shape_aspect.description = 'assembly module component terminal'))OR((SELF.of_shape.definition.frame_of_reference.name = 'physical occurrence')AND(EXISTS(SELF.of_shape.definition \ product_definition.name))AND(NOT(EXISTS(SELF.of_shape.definition \ product_definition.name))OR(SELF.of_shape.definition \ product_definition.name = 'assembly module')));
	WR9 : (NOT(SELF  \ shape_aspect.description = 'assembly module component terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))))= 1);
	WR10 : (NOT(SELF  \ shape_aspect.description = 'bare die component terminal'))OR(SELF.of_shape.definition \ product_definition.description = 'bare die component');
	WR11 : (NOT(SELF  \ shape_aspect.description = 'bare die component terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))))= 1);
	WR13 : (NOT(SELF  \ shape_aspect.description = 'component termination passage join terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| i_f.relating_shape_aspect \ shape_aspect.description = 'component termination passage template join terminal'))= 1);
	WR15 : (NOT(SELF  \ shape_aspect.description IN [ 'conductive interconnect element terminal', 'interconnect component join terminal', 'printed component join terminal' ]))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))<= 1);
	WR16 : (NOT(SELF  \ shape_aspect.description = 'interconnect module component terminal'))OR((SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence')AND(EXISTS(SELF.of_shape.definition \ product_definition.name))AND(NOT(EXISTS(SELF.of_shape.definition \ product_definition.name))OR(SELF.of_shape.definition \ product_definition.name = 'interconnect module')));
	WR17 : (NOT(SELF  \ shape_aspect.description = 'interconnect module component terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect)))= 1);
	WR18 : (NOT(SELF  \ shape_aspect.description IN  [ 'land join terminal', 'non functional land join terminal' ]))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(TRUE))))= 1);
	WR20 : (NOT(SELF  \ shape_aspect.description = 'minimally defined terminal'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'part terminal external reference'))= 1);
	WR22 : (NOT(SELF  \ shape_aspect.description = 'package terminal occurrence'))OR(SIZEOF(QUERY(ud <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'usage definition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(ud.relating_shape_aspect))))= 1);
	WR23 : (NOT(SELF  \ shape_aspect.description IN  [ 'package terminal occurrence', 'packaged component join terminal' ]))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence'));
	WR24 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(i_f.relating_shape_aspect \ shape_aspect.description = 'join terminal')))= 1);
	WR25 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2))<= 2))<= 1))<= 1);
	WR26 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'maximum wire length'))<= 1))<= 1))<= 1);
	WR27 : (NOT(SELF  \ shape_aspect.description = 'packaged component join terminal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'minimum wire length'))<= 1))<= 1))<= 1);
	WR28 : (NOT(SELF  \ shape_aspect.description = 'printed component join terminal'))OR((SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'layout occurrence')AND(SELF.of_shape.definition \ product_definition.name = 'interconnect module'));
	WR29 : (NOT(SELF  \ shape_aspect.description = 'printed component join terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(i_f.relating_shape_aspect \ shape_aspect.description = 'join terminal')))= 1);
	WR30 : (NOT(SELF  \ shape_aspect.description = 'printed component join terminal'))OR(SIZEOF(QUERY(i <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| pdr \ shape_aspect_relationship.name = 'implementation')|((SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(i.relating_shape_aspect))>= 1)AND(i.relating_shape_aspect \ shape_aspect.description = 'stratum feature template component'))))= 1);
	WR32 : (NOT(SELF  \ shape_aspect.description = 'via terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| i_f.relating_shape_aspect \ shape_aspect.description = 'via template terminal'))= 1);
	WR33 : (NOT(SELF  \ shape_aspect.description = 'interconnect component join terminal'))OR((SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence')AND NOT(SELF.of_shape.definition \ product_definition.description IN [ 'assembly module component', 'bare die component', 'interconnect module component', 'laminate component', 'packaged component' ]));
	WR34 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(dri <* pdr.used_representation.items |(dri \ representation_item.name = 'global swappable')AND(dri \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1))<= 1 ;
	WR35 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(dri <* pdr.used_representation.items |(dri \ representation_item.name = 'local swappable')AND(dri \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1))<= 1 ;
	WR36 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(dri <* pdr.used_representation.items | dri \ representation_item.name = 'swap code'))= 1))= 1))<= 1 ;
END_ENTITY; -- component_terminal


ENTITY make_from_feature_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.relating_shape_aspect))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.related_shape_aspect))= 1 ;
	WR3 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN  TYPEOF(SELF.relating_shape_aspect)))OR(SELF.relating_shape_aspect \ shape_aspect.description IN [ 'component feature', 'component termination passage interface terminal', 'land or non functional land interface terminal', 'printed connector component interface terminal' ]);
	WR4 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN  TYPEOF(SELF.related_shape_aspect)))OR(SELF.related_shape_aspect \ shape_aspect.description IN [ 'component feature', 'component termination passage interface terminal', 'land or non functional land interface terminal', 'printed connector component interface terminal' ]);
END_ENTITY; -- make_from_feature_relationship


ENTITY array_placement_group_component_definition
	SUPERTYPE OF (ONEOF (linear_array_placement_group_component_definition, rectangular_array_placement_group_component_definition))
	SUBTYPE OF (assembly_group_component_definition);
END_ENTITY; -- array_placement_group_component_definition


ENTITY array_placement_group_component_shape_aspect
	SUPERTYPE OF (ONEOF (linear_array_placement_group_component_shape_aspect, rectangular_array_placement_group_component_shape_aspect))
	SUBTYPE OF (assembly_group_component_shape_aspect);
END_ENTITY; -- array_placement_group_component_shape_aspect


ENTITY assembly_group_component_definition
	SUBTYPE OF (component_definition);
WHERE
	WR1 : (SIZEOF(QUERY(gc <* QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'group component')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(gc.related_product_definition))))>= 1)OR(SIZEOF(QUERY(agcsa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(agcsa))))= 0);
	WR2 : (SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(acu <* USEDIN(aj \ shape_aspect_relationship.relating_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))>= 1)))>= 1);
	WR3 : (SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(acu <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))= 0)))= 0);
	WR4 : (SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(cl <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_LOCATION' IN  TYPEOF(cl))AND(aj IN cl \ representation.items)))= 0)))= 0);
END_ENTITY; -- assembly_group_component_definition


ENTITY assembly_group_component_definition_placement_link
	SUBTYPE OF (product_definition, product_definition_relationship);
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.related_product_definition);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.relating_product_definition);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF  \ product_definition_relationship || SELF \ assembly_group_component_definition_placement_link))= 0 ;
	WR5 :  SELF \ product_definition.name = '' ;
	WR6 :  SELF \ product_definition_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))= 1 ;
END_ENTITY; -- assembly_group_component_definition_placement_link


ENTITY assembly_group_component_shape_aspect
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 : (SIZEOF(QUERY(gc <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'group component')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(gc.related_shape_aspect))))>= 1);
END_ENTITY; -- assembly_group_component_shape_aspect


ENTITY assembly_group_component_shape_aspect_placement_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ assembly_group_component_shape_aspect_placement_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))= 1 ;
END_ENTITY; -- assembly_group_component_shape_aspect_placement_link


ENTITY interfaced_group_component_definition
	SUBTYPE OF (assembly_group_component_definition);
WHERE
	WR1 : (SIZEOF(QUERY(gc <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'group component')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(gc.related_product_definition))))>= 1);
END_ENTITY; -- interfaced_group_component_definition


ENTITY linear_array_component_definition_link
	SUBTYPE OF (product_definition, product_definition_relationship);
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.related_product_definition);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.relating_product_definition);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF  \ product_definition_relationship || SELF \ linear_array_component_definition_link))= 0 ;
	WR5 :  SELF \ product_definition.name = '' ;
	WR6 :  SELF \ product_definition_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))= 1 ;
END_ENTITY; -- linear_array_component_definition_link


ENTITY linear_array_component_shape_aspect_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_ARRAY_PLACEMENT_GROUP_COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ linear_array_component_shape_aspect_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))= 1 ;
END_ENTITY; -- linear_array_component_shape_aspect_link


ENTITY linear_array_placement_group_component_definition
	SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY; -- linear_array_placement_group_component_definition


ENTITY linear_array_placement_group_component_shape_aspect
	SUBTYPE OF (array_placement_group_component_shape_aspect);
END_ENTITY; -- linear_array_placement_group_component_shape_aspect


ENTITY rectangular_array_placement_group_component_definition
	SUBTYPE OF (array_placement_group_component_definition);
END_ENTITY; -- rectangular_array_placement_group_component_definition


ENTITY rectangular_array_placement_group_component_shape_aspect
	SUBTYPE OF (array_placement_group_component_shape_aspect);
END_ENTITY; -- rectangular_array_placement_group_component_shape_aspect


ENTITY configurable_item
	SUBTYPE OF (configuration_item);
	item_concept_feature : SET [1:?] OF product_concept_feature_association;
END_ENTITY; -- configurable_item


ENTITY configuration_design;
	configuration : configuration_item;
	design : configuration_design_item;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
UNIQUE
	UR1 : configuration, design;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- configuration_design


ENTITY configuration_effectivity
	SUBTYPE OF (product_definition_effectivity);
	configuration : configuration_design;
UNIQUE
	UR1 : configuration, usage, id;
WHERE
	WR1 :  'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN TYPEOF(SELF \ product_definition_effectivity.usage);
END_ENTITY; -- configuration_effectivity


ENTITY configuration_item;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	item_concept : product_concept;
	purpose : OPTIONAL label;
END_ENTITY; -- configuration_item


ENTITY configuration_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_configuration_item : configuration_item;
	related_configuration_item : configuration_item;
END_ENTITY; -- configuration_item_relationship


ENTITY applied_contract_assignment
	SUBTYPE OF (contract_assignment);
	items : SET [1:?] OF contract_item;
END_ENTITY; -- applied_contract_assignment


ENTITY contract;
	name : label;
	purpose : text;
	kind : contract_type;
END_ENTITY; -- contract


ENTITY contract_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_contract : contract;
	related_contract : contract;
END_ENTITY; -- contract_relationship


ENTITY contract_type;
	description : label;
END_ENTITY; -- contract_type


ENTITY applied_date_and_time_assignment
	SUBTYPE OF (date_and_time_assignment);
	items : SET [1:?] OF date_and_time_item;
END_ENTITY; -- applied_date_and_time_assignment


ENTITY applied_date_assignment
	SUBTYPE OF (date_assignment);
	items : SET [1:?] OF date_item;
END_ENTITY; -- applied_date_assignment


ENTITY calendar_date
	SUBTYPE OF (date);
	day_component : day_in_month_number;
	month_component : month_in_year_number;
WHERE
	WR1 :  valid_calendar_date(SELF);
END_ENTITY; -- calendar_date


ENTITY coordinated_universal_time_offset;
	hour_offset : INTEGER;
	minute_offset : OPTIONAL INTEGER;
	sense : ahead_or_behind;
DERIVE
	actual_minute_offset : INTEGER :=  NVL(minute_offset, 0);
WHERE
	WR1 :  { 0 <= hour_offset < 24 } ;
	WR2 :  { 0 <= actual_minute_offset <= 59 } ;
	WR3 :  NOT(((hour_offset <> 0)OR(actual_minute_offset <> 0))AND(sense = exact));
END_ENTITY; -- coordinated_universal_time_offset


ENTITY date
	SUPERTYPE OF (ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date));
	year_component : year_number;
END_ENTITY; -- date


ENTITY date_and_time;
	date_component : date;
	time_component : local_time;
END_ENTITY; -- date_and_time


ENTITY date_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- date_role


ENTITY date_time_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- date_time_role


ENTITY event_occurrence;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence


ENTITY event_occurrence_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence_context_role


ENTITY event_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	relating_event : event_occurrence;
	related_event : event_occurrence;
END_ENTITY; -- event_occurrence_relationship


ENTITY event_occurrence_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence_role


ENTITY local_time;
	hour_component : hour_in_day;
	minute_component : OPTIONAL minute_in_hour;
	second_component : OPTIONAL second_in_minute;
	zone : coordinated_universal_time_offset;
WHERE
	WR1 :  valid_time(SELF);
END_ENTITY; -- local_time


ENTITY ordinal_date
	SUBTYPE OF (date);
	day_component : day_in_year_number;
WHERE
	WR1 : (NOT leap_year(SELF.year_component)AND  { 1 <= day_component <= 365 })OR(leap_year(SELF.year_component)AND { 1 <= day_component <= 366 });
END_ENTITY; -- ordinal_date


ENTITY relative_event_occurrence
	SUBTYPE OF (event_occurrence);
	base_event : event_occurrence;
	offset : time_measure_with_unit;
END_ENTITY; -- relative_event_occurrence


ENTITY time_interval;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- time_interval


ENTITY time_interval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_time_interval : time_interval;
	related_time_interval : time_interval;
END_ENTITY; -- time_interval_relationship


ENTITY time_interval_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- time_interval_role


ENTITY time_interval_with_bounds
	SUBTYPE OF (time_interval);
	primary_bound : OPTIONAL date_time_or_event_occurrence;
	secondary_bound : OPTIONAL date_time_or_event_occurrence;
	duration : OPTIONAL time_measure_with_unit;
WHERE
	WR1 :  NOT(EXISTS(secondary_bound)AND EXISTS(duration));
	WR2 :  EXISTS(primary_bound)OR EXISTS(secondary_bound);
END_ENTITY; -- time_interval_with_bounds


ENTITY time_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- time_role


ENTITY week_of_year_and_day_date
	SUBTYPE OF (date);
	week_component : week_in_year_number;
	day_component : OPTIONAL day_in_week_number;
END_ENTITY; -- week_of_year_and_day_date


ENTITY datum_difference_based_model_parameter
	SUBTYPE OF (model_parameter);
WHERE
	WR1 :  SIZEOF(QUERY(r <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|(SIZEOF(QUERY(prd2 <* QUERY(prd <* USEDIN(r, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|((('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION')IN  TYPEOF(prd))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION')IN  TYPEOF(prd \ property_definition_representation.definition))))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_DIFFERENCE' IN TYPEOF(prd2 \ property_definition_representation.definition \ property_definition.definition))))= 1)))= 1 ;
END_ENTITY; -- datum_difference_based_model_parameter


ENTITY datum_difference_functional_unit_usage_view_terminal_assignment
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect_relationship || SELF \ datum_difference_functional_unit_usage_view_terminal_assignment))= 0 ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_DIFFERENCE' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
END_ENTITY; -- datum_difference_functional_unit_usage_view_terminal_assignment


ENTITY add_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object addition')))= 1 ;
END_ENTITY; -- add_design_object_assignment


ENTITY add_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object addition')))= 1 ;
END_ENTITY; -- add_design_object_request_assignment


ENTITY change_from_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_assignment.assigned_action, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHANGE_TO_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
END_ENTITY; -- change_from_design_object_assignment


ENTITY change_from_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_request_assignment.assigned_action_request, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHANGE_TO_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
END_ENTITY; -- change_from_design_object_request_assignment


ENTITY change_to_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_assignment.assigned_action, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHANGE_FROM_DESIGN_OBJECT_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr))AND(pdr \ product_definition_relationship.name = 'design object change')))= 1 ;
END_ENTITY; -- change_to_design_object_assignment


ENTITY change_to_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(aa <* USEDIN(SELF \ action_request_assignment.assigned_action_request, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHANGE_FROM_DESIGN_OBJECT_REQUEST_ASSIGNMENT' IN TYPEOF(aa)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr))AND(pdr \ product_definition_relationship.name = 'design object change')))= 1 ;
END_ENTITY; -- change_to_design_object_request_assignment


ENTITY delete_design_object_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object deletion')))= 1 ;
END_ENTITY; -- delete_design_object_assignment


ENTITY delete_design_object_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(it))AND(it \ product_definition_relationship.name = 'design object deletion')))= 1 ;
END_ENTITY; -- delete_design_object_request_assignment


ENTITY frozen_assignment
	SUBTYPE OF (approval_assignment);
	items : SET [1:?] OF managed_design_object;
WHERE
	WR1 :  SELF \ approval_assignment.assigned_approval.status.name IN [ 'approved', 'not yet approved' ] ;
END_ENTITY; -- frozen_assignment


ENTITY directed_dimensional_location
	SUBTYPE OF (dimensional_location);
END_ENTITY; -- directed_dimensional_location


ENTITY externally_defined_dimension_definition
	SUBTYPE OF (dimensional_size, externally_defined_item);
WHERE
	WR1 : (SELF  \ externally_defined_item.item_id = 'external size dimension')AND(SELF \ externally_defined_item.source.source_id = 'external size dimension specification');
	WR2 :  1 >= SIZEOF(QUERY(adr <* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adr.assigned_document.description = 'external size dimension specification')));
END_ENTITY; -- externally_defined_dimension_definition


ENTITY applied_document_reference
	SUBTYPE OF (document_reference);
	items : SET [1:?] OF document_reference_item;
END_ENTITY; -- applied_document_reference


ENTITY applied_document_usage_constraint_assignment
	SUBTYPE OF (document_usage_constraint_assignment);
	items : SET [1:?] OF document_reference_item;
END_ENTITY; -- applied_document_usage_constraint_assignment


ENTITY document_product_equivalence
	SUBTYPE OF (document_product_association);
WHERE
	WR1 :  SELF \ document_product_association.name = 'equivalence' ;
	WR2 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT' IN TYPEOF(SELF  \ document_product_association.related_product))OR((SELF  \ document_product_association.relating_document.kind.product_data_type = 'configuration controlled document')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF \ document_product_association.related_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
	WR3 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product))OR((SELF  \ document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF.related_product \ product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
	WR4 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product))OR((SELF  \ document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF \ document_product_association.related_product \ product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
END_ENTITY; -- document_product_equivalence


ENTITY document;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	kind : document_type;
INVERSE
	representation_types: SET [0:?] OF document_representation_type FOR represented_document;
END_ENTITY; -- document


ENTITY document_product_association;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_product : product_or_formation_or_definition;
END_ENTITY; -- document_product_association


ENTITY document_relationship;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_document : document;
END_ENTITY; -- document_relationship


ENTITY document_representation_type;
	name : label;
	represented_document : document;
END_ENTITY; -- document_representation_type


ENTITY document_type;
	product_data_type : label;
END_ENTITY; -- document_type


ENTITY document_usage_constraint;
	source : document;
	subject_element : label;
	subject_element_value : text;
END_ENTITY; -- document_usage_constraint


ENTITY document_with_class
	SUBTYPE OF (document);
	class : identifier;
END_ENTITY; -- document_with_class


ENTITY applied_effectivity_assignment
	SUBTYPE OF (effectivity_assignment);
	items : SET [1:?] OF effectivity_item;
END_ENTITY; -- applied_effectivity_assignment


ENTITY dated_effectivity
	SUBTYPE OF (effectivity);
	effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
	effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY; -- dated_effectivity


ENTITY effectivity
	SUPERTYPE OF (ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity));
	id : identifier;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- effectivity


ENTITY effectivity_relationship;
	name : label;
	description : OPTIONAL text;
	related_effectivity : effectivity;
	relating_effectivity : effectivity;
END_ENTITY; -- effectivity_relationship


ENTITY lot_effectivity
	SUBTYPE OF (effectivity);
	effectivity_lot_id : identifier;
	effectivity_lot_size : measure_with_unit;
END_ENTITY; -- lot_effectivity


ENTITY serial_numbered_effectivity
	SUBTYPE OF (effectivity);
	effectivity_start_id : identifier;
	effectivity_end_id : OPTIONAL identifier;
END_ENTITY; -- serial_numbered_effectivity


ENTITY time_interval_based_effectivity
	SUBTYPE OF (effectivity);
	effectivity_period : time_interval;
END_ENTITY; -- time_interval_based_effectivity


ENTITY electrical_network
	SUBTYPE OF (functional_unit);
END_ENTITY; -- electrical_network


ENTITY applied_event_occurrence_assignment
	SUBTYPE OF (event_occurrence_assignment);
	items : SET [1:?] OF event_occurrence_item;
END_ENTITY; -- applied_event_occurrence_assignment


ENTITY experience;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience


ENTITY experience_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_experience : experience;
	related_experience : experience;
END_ENTITY; -- experience_relationship


ENTITY experience_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_type


ENTITY experience_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_experience_type : experience_type;
	related_experience_type : experience_type;
END_ENTITY; -- experience_type_relationship


ENTITY auxiliary_characteristic_dimension_representation
	SUBTYPE OF (dimensional_characteristic_representation);
END_ENTITY; -- auxiliary_characteristic_dimension_representation


ENTITY curve_dimension
	SUBTYPE OF (dimensional_size);
WHERE
	WR1 :  SELF \ dimensional_size.name <> 'angular' ;
END_ENTITY; -- curve_dimension


ENTITY datum_difference
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM' IN  TYPEOF(SELF  \ shape_aspect_relationship.relating_shape_aspect))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect));
	WR2 :  SELF  \ shape_aspect.name = SELF \ shape_aspect_relationship.name ;
	WR3 :  SELF  \ shape_aspect.description = SELF \ shape_aspect_relationship.description ;
	WR4 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR5 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ datum_difference)))= 0 ;
END_ENTITY; -- datum_difference


ENTITY datum_difference_based_characteristic
	SUBTYPE OF (representation_item);
WHERE
	WR1 :  SIZEOF(QUERY(r <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|(SIZEOF(QUERY(prd2 <* QUERY(prd <* USEDIN(r, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|((('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION')IN  TYPEOF(prd))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION')IN  TYPEOF(prd \ property_definition_representation.definition))))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_DIFFERENCE' IN TYPEOF(prd2 \ property_definition_representation.definition \ property_definition.definition))))= 1)))= 1 ;
END_ENTITY; -- datum_difference_based_characteristic


ENTITY dimensional_size_property
	SUBTYPE OF (dimensional_size, property_definition);
END_ENTITY; -- dimensional_size_property


ENTITY edge_segment_vertex
	SUBTYPE OF (physical_unit_datum);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ physical_unit_datum || SELF \ edge_segment_vertex))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| pd \ property_definition.description = 'shape element characterization'))= 1 ;
	WR3 :  SELF \ shape_aspect.of_shape \ property_definition.definition.frame_of_reference \ application_context_element.name IN [ 'physical design occurrence', 'physical design usage' ] ;
	WR4 :  SELF \ shape_aspect.name = 'single datum' ;
END_ENTITY; -- edge_segment_vertex


ENTITY geometric_tolerance_group
	SUBTYPE OF (property_definition);
WHERE
	WR1 :  SELF \ property_definition.description IN [ 'separate requirement', 'simultaneous requirement' ] ;
	WR2 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'group geometric tolerance')))>= 1);
	WR3 : (NOT(SELF  \ property_definition.description = 'simultaneous requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))>= 2);
	WR4 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.name = 'linear profile refinement')AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))= 0);
	WR5 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SURFACE_PROFILE_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.name = 'surface profile refinement')AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))= 0);
	WR6 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITION_TOLERANCE' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.name = 'feature relating position')AND(pdr \ property_definition_relationship.name = 'group geometric tolerance'))))= 0);
	WR7 : (NOT(SELF  \ property_definition.description = 'separate requirement'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'group geometric tolerance')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SURFACE_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITION_TOLERANCE' ] * TYPEOF(pdr.related_property_definition))> 0)))= 0);
END_ENTITY; -- geometric_tolerance_group


ENTITY linear_profile_tolerance
	SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
	WR1 : (NOT(SELF  \ geometric_tolerance.name = 'linear profile refinement'))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control')AND((gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile locating')OR(gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement')))))= 1);
	WR2 : (NOT(SELF  \ geometric_tolerance.name = 'linear profile locating'))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement'))AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control')))= 1);
	WR3 : (NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM' IN  TYPEOF(SELF))AND(SELF  \ geometric_tolerance.name = 'linear profile refinement')))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr.relating_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement')AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control')))= 0);
	WR4 : (NOT(SELF  \ geometric_tolerance.name = 'linear profile refinement'))OR(SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATING_GEOMETRIC_TOLERANCE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr.related_geometric_tolerance \ geometric_tolerance.name = 'linear profile refinement')AND(gtr \ geometric_tolerance_relationship.name = 'linear profile refining control'))))<= 1);
	WR5 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF));
END_ENTITY; -- linear_profile_tolerance


ENTITY opposing_boundary_dimensional_size
	SUBTYPE OF (dimensional_size);
WHERE
	WR1 :  SELF \ dimensional_size.name IN [ 'angular', 'linear' ] ;
END_ENTITY; -- opposing_boundary_dimensional_size


ENTITY physical_unit_datum
	SUPERTYPE OF (edge_segment_vertex)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'axis', 'plane', 'point', '' ] ;
	WR2 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR3 :  SELF \ shape_aspect.name IN [ 'single datum', 'common datum', '' ] ;
	WR4 : (NOT(SELF  \ shape_aspect.name = 'common datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum feature usage in  datum system')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_SYSTEM' IN TYPEOF(SAR))))>= 1);
	WR5 : (NOT(SELF  \ shape_aspect.name = 'common datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum feature usage in  common datum')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_SYSTEM' IN TYPEOF(SAR))))>= 2);
	WR6 : (NOT((SELF  \ shape_aspect.description = 'axis')AND(SELF  \ shape_aspect.name IN  [ 'common datum', 'single datum' ])))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT(sar \ shape_aspect_relationship.name = 'reference axis')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR))))= 1);
	WR7 : (NOT((SELF  \ shape_aspect.description = 'plane')AND(SELF  \ shape_aspect.name IN  [ 'common datum', 'single datum' ])))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT(sar \ shape_aspect_relationship.name = 'reference plane')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR))))= 1);
	WR8 : (NOT((SELF  \ shape_aspect.description = 'point')AND(SELF  \ shape_aspect.name IN  [ 'common datum', 'single datum' ])))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| NOT(sar \ shape_aspect_relationship.name = 'reference origin')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(SAR))))= 1);
	WR9 : (NOT(SELF  \ shape_aspect.name = 'single datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum usage in  datum system')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_SYSTEM' IN TYPEOF(SAR))))>= 1);
	WR10 : (NOT(SELF  \ shape_aspect.name = 'single datum'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'datum feature usage in single datum')AND(TRUE)))<= 1);
	WR11 :  NOT((SELF  \ shape_aspect.name IN  [ '' ])AND(SELF \ shape_aspect.description IN [ '' ]));
	WR12 : (NOT(SELF  \ shape_aspect.description = 'plane'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| pd \ property_definition.description = 'datum direction property'))<= 2);
END_ENTITY; -- physical_unit_datum


ENTITY physical_unit_datum_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')|(pd \ property_definition.description = 'datum feature identification'))))= 1 ;
	WR2 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name IN  [ 'datum feature usage in  common datum', 'datum feature usage in single datum' ]))>= 1);
	WR3 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'datum feature usage in single datum'))<= 1);
END_ENTITY; -- physical_unit_datum_feature


ENTITY physical_unit_datum_target_set
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'datum target usage'))>= 1);
	WR2 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'constituent'))= 0);
END_ENTITY; -- physical_unit_datum_target_set


ENTITY physical_unit_geometric_tolerance
	SUBTYPE OF (geometric_tolerance, property_definition);
WHERE
	WR1 :  SELF  \ geometric_tolerance.name = SELF \ property_definition.name ;
	WR2 :  SELF  \ geometric_tolerance.toleranced_shape_aspect = SELF \ property_definition.definition ;
	WR3 : (NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_SPECIFIED_DATUM_SYSTEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SURFACE_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITION_TOLERANCE' ] * TYPEOF(SELF))= 0))OR(SELF \ geometric_tolerance.name IN [ 'circularity', 'cylindricity', 'flatness', 'straightness' ]);
	WR4 : (NOT(SELF  \ geometric_tolerance.name = 'circularity'))OR(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
	WR5 : (NOT(SELF  \ geometric_tolerance.name = 'cylindricity'))OR(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
	WR6 : (NOT(SELF  \ geometric_tolerance.name = 'flatness'))OR(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODIFIED_GEOMETRIC_TOLERANCE' IN TYPEOF(SELF)));
	WR7 : (SIZEOF(QUERY(pugt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'group geometric tolerance')| pugt.relating_shape_aspect \ shape_aspect.description = 'simultaneous requirement'))<= 1);
END_ENTITY; -- physical_unit_geometric_tolerance


ENTITY positional_boundary
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'dimension related positional boundary', 'profile related positional boundary' ] ;
	WR2 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR3 : (NOT(SELF  \ shape_aspect.description = 'dimension related positional boundary'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'boundary member')))>= 1);
	WR4 : (NOT(SELF  \ shape_aspect.description = 'dimension related positional boundary'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar.related_shape_aspect.product_definitional = TRUE)AND(sar \ shape_aspect_relationship.name = 'constrained feature')))+ SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.related_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'constrained feature')))= 1);
	WR5 : (NOT(SELF  \ shape_aspect.description = 'dimension related positional boundary'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'dimension related positional boundary property')))= 1);
	WR6 : (NOT(SELF  \ shape_aspect.description = 'profile related positional boundary'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'profile related positional boundary property')))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'profile related positional boundary'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(sar.related_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'positional boundary and profile boundary member')))= 1);
END_ENTITY; -- positional_boundary


ENTITY positional_boundary_member
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'positional boundary member property')))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'boundary member')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'dimension related positional boundary')))= 1 ;
END_ENTITY; -- positional_boundary_member


ENTITY statistical_dimensional_location
	SUBTYPE OF (dimensional_location);
END_ENTITY; -- statistical_dimensional_location


ENTITY statistical_dimensional_size
	SUBTYPE OF (dimensional_size_property);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'substitutable dimension')))<= 1)))<= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'dimensional tolerance statistical control requirement')))<= 1)))<= 1 ;
	WR3 : (NOT(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_SIZE' IN  TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'substitutable dimension')))<= 1)))<= 1))OR(NOT(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_SIZE' IN  TYPEOF(pdr.related_property_definition))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STATISTICAL_DIMENSIONAL_SIZE' IN TYPEOF(pdr.related_property_definition)))AND(pdr \ property_definition_relationship.name = 'substitutable dimension')))<= 1)))<= 1));
END_ENTITY; -- statistical_dimensional_size


ENTITY statistical_geometric_tolerance
	SUBTYPE OF (physical_unit_geometric_tolerance);
WHERE
	WR1 :  SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr \ geometric_tolerance_relationship.name = 'substitutable geometric tolerance')))<= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'geometric tolerance statistical control requirement')))= 1 ;
	WR3 :  SIZEOF(QUERY(gtr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_RELATIONSHIP.RELATED_GEOMETRIC_TOLERANCE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STATISTICAL_GEOMETRIC_TOLERANCE' IN TYPEOF(gtr.relating_geometric_tolerance))AND(gtr \ geometric_tolerance_relationship.name = 'substitutable geometric tolerance')))<= 0 ;
END_ENTITY; -- statistical_geometric_tolerance


ENTITY tolerance_zone_boundary
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : (NOT(SELF  \ shape_aspect.description = 'conical'))OR(NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF))));
	WR2 : (NOT(SELF  \ shape_aspect.description = 'circular or  cylindrical or  spherical'))OR(NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF))));
	WR3 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR4 :  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_EXPLICIT_OPPOSING_BOUNDARY_SET' IN  TYPEOF(SELF))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_IMPLICIT_OPPOSING_BOUNDARY_SET' IN TYPEOF(SELF)));
	WR5 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'boundary zone definition with specified size')OR(pd \ property_definition.description = 'conical tolerance zone boundary')))= 1 ;
	WR6 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_DEFINITION.BOUNDARIES'))= 1 ;
END_ENTITY; -- tolerance_zone_boundary


ENTITY tolerance_zone_explicit_opposing_boundary_set
	SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY; -- tolerance_zone_explicit_opposing_boundary_set


ENTITY tolerance_zone_implicit_opposing_boundary_set
	SUBTYPE OF (tolerance_zone_boundary);
END_ENTITY; -- tolerance_zone_implicit_opposing_boundary_set


ENTITY viewing_plane
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description = 'affected plane' ;
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.' + 'DEFINITION')|(pd \ property_definition.description = 'viewing plane property'))))= 1 ;
	WR3 :  NOT SELF \ shape_aspect.product_definitional ;
END_ENTITY; -- viewing_plane


ENTITY value_range
	SUBTYPE OF (compound_representation_item);
WHERE
	WR1 : ('value_with_unit_mim.' + 'SET_REPRESENTATION_ITEM' IN TYPEOF(item_element))AND value_range_wr1(item_element);
	WR2 :  value_range_wr2(item_element);
	WR3 :  value_range_wr3(item_element);
END_ENTITY; -- value_range


ENTITY external_class_library
	SUBTYPE OF (external_source);
END_ENTITY; -- external_class_library


ENTITY externally_defined_class
	SUBTYPE OF (class, externally_defined_item);
END_ENTITY; -- externally_defined_class


ENTITY applied_external_identification_assignment
	SUBTYPE OF (external_identification_assignment);
	items : SET [1:?] OF external_identification_item;
END_ENTITY; -- applied_external_identification_assignment


ENTITY external_source;
	source_id : source_item;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- external_source


ENTITY external_source_relationship;
	name : label;
	description : OPTIONAL text;
	relating_source : external_source;
	related_source : external_source;
END_ENTITY; -- external_source_relationship


ENTITY externally_defined_item;
	item_id : source_item;
	source : external_source;
END_ENTITY; -- externally_defined_item


ENTITY externally_defined_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_item : externally_defined_item;
	related_item : externally_defined_item;
END_ENTITY; -- externally_defined_item_relationship


ENTITY pre_defined_item;
	name : label;
END_ENTITY; -- pre_defined_item


ENTITY connection_zone_based_fabrication_joint
	SUBTYPE OF (fabrication_joint);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'zone 1'))= 1 ;
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'zone 2'))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar.relating_shape_aspect \ shape_aspect.description = 'connection zone'))= 2 ;
END_ENTITY; -- connection_zone_based_fabrication_joint


ENTITY fabrication_joint
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN  TYPEOF(SELF.related_shape_aspect))AND(SELF.related_shape_aspect \ shape_aspect.description IN [ 'via terminal', 'printed component join terminal', 'non functional land join terminal', 'land join terminal', 'conductive interconnect element terminal', 'component termination passage join terminal' ]));
	WR2 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN  TYPEOF(SELF.relating_shape_aspect))AND(SELF.relating_shape_aspect \ shape_aspect.description IN [ 'via terminal', 'printed component join terminal', 'non functional land join terminal', 'land join terminal', 'conductive interconnect element terminal', 'component termination passage join terminal' ]));
	WR3 :  SIZEOF(QUERY(ajm <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'auxiliary joint material')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND' IN  TYPEOF(ajm.related_shape_aspect))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(ajm.related_shape_aspect))AND(ajm.related_shape_aspect \ shape_aspect.description = 'stratum feature template component'))))<= 1 ;
	WR4 :  acyclic_shape_aspect_relationship(SELF , [ SELF \ shape_aspect_relationship.related_shape_aspect ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FABRICATION_JOINT');
END_ENTITY; -- fabrication_joint


ENTITY connection_zone_interface_plane_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect_relationship || SELF  \ connection_zone_interface_plane_relationship || SELF \ shape_aspect))= 0 ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR3 :  SELF \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'plane' ;
	WR4 :  SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'connection zone' ;
	WR5 :  SELF \ shape_aspect_relationship.description IN [ 'area', 'edge' ] ;
	WR6 :  SELF  \ shape_aspect.of_shape = SELF \ shape_aspect_relationship.related_shape_aspect.of_shape ;
	WR7 :  SELF  \ shape_aspect.of_shape = SELF \ shape_aspect_relationship.relating_shape_aspect.of_shape ;
	WR8 :  SIZEOF(QUERY(dz <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'derived zone')| dz.related_shape_aspect \ shape_aspect.description = 'connection zone'))= 1 ;
END_ENTITY; -- connection_zone_interface_plane_relationship


ENTITY document_file
	SUBTYPE OF (document, characterized_object);
WHERE
	WR1 :  SELF \ characterized_object.name = '' ;
	WR2 :  NOT EXISTS(SELF \ characterized_object.description);
	WR3 :  SIZEOF(QUERY(drt <* SELF \ document.representation_types | drt.name IN [ 'digital', 'physical' ]))= 1 ;
END_ENTITY; -- document_file


ENTITY make_from_connectivity_relationship
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.relating_shape_aspect);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.related_shape_aspect);
END_ENTITY; -- make_from_connectivity_relationship


ENTITY physical_connectivity_definition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name, of_shape;
WHERE
	WR1 :  SIZEOF(QUERY(at <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated terminals')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(at.related_shape_aspect))AND((at.related_shape_aspect \ shape_aspect.description = 'assembly module component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'bare die component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'interconnect component join terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'interconnect module component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'minimally defined component terminal')OR(at.related_shape_aspect \ shape_aspect.description = 'packaged component join terminal'))))> 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'connectivity allocation'))= 1)))<= 1 ;
END_ENTITY; -- physical_connectivity_definition


ENTITY physical_connectivity_element
	SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
	WR1 : (SELF.relating_shape_aspect \ shape_aspect.description = 'topological junction')XOR(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' ] * TYPEOF(SELF.relating_shape_aspect))= 1);
	WR2 : (SELF.related_shape_aspect \ shape_aspect.description = 'topological junction')XOR(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' ] * TYPEOF(SELF.related_shape_aspect))= 1);
	WR3 :  SIZEOF(QUERY(se <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'structure element')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(se.relating_shape_aspect)))= 1 ;
	WR4 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical design');
END_ENTITY; -- physical_connectivity_element


ENTITY physical_unit_network_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SELF.frame_of_reference.name IN [ 'physical network design' ] ;
END_ENTITY; -- physical_unit_network_definition


ENTITY functional_specification
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(rr \ representation_relationship.name = 'functional characteristic category')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNAL_DEFINITION' IN TYPEOF(rr.rep_1.items [ 1 ]))))= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr \ representation_relationship.name = 'characterizing signal' + 'for functional specification')))= 1 ;
	WR3 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr \ representation_relationship.name = 'reference signal for' + 'functional specification')))= 1 ;
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ functional_specification))= 0 ;
	WR5 :  SELF \ representation.name = '' ;
	WR6 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.definition.definition))))= 0 ;
END_ENTITY; -- functional_specification


ENTITY functional_specification_definition
	SUBTYPE OF (functional_unit);
WHERE
	WR1 :  SELF.frame_of_reference \ application_context_element.name = 'functional network design' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_SPECIFICATION' IN TYPEOF(pdr.used_representation))))> 0)))> 0 ;
END_ENTITY; -- functional_specification_definition


ENTITY general_material_property
	SUBTYPE OF (general_property);
WHERE
	WR1 :  SIZEOF(QUERY(gpa <* USEDIN(SELF, 'MATERIAL_ASPECTS_MIM.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION')| NOT('MATERIAL_ASPECTS_MIM.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition))))= 0 ;
END_ENTITY; -- general_material_property


ENTITY block
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
END_ENTITY; -- block


ENTITY boolean_result
	SUBTYPE OF (geometric_representation_item);
	operator : boolean_operator;
	first_operand : boolean_operand;
	second_operand : boolean_operand;
END_ENTITY; -- boolean_result


ENTITY box_domain
	SUBTYPE OF (founded_item);
	corner : cartesian_point;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	zlength : positive_length_measure;
WHERE
	WR1 :  SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOXED_HALF_SPACE' IN TYPEOF(item))))= 0 ;
END_ENTITY; -- box_domain


ENTITY boxed_half_space
	SUBTYPE OF (half_space_solid);
	enclosure : box_domain;
END_ENTITY; -- boxed_half_space


ENTITY brep_2d
	SUBTYPE OF (solid_model);
	extent : face;
WHERE
	WR1 :  SIZEOF([ 'TOPOLOGY_SCHEMA.FACE_SURFACE', 'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE' ] * TYPEOF(SELF.extent))= 0 ;
	WR2 :  SIZEOF(QUERY(bnds <* extent.bounds | NOT('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))))= 0 ;
	WR3 :  SIZEOF(QUERY(bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))= 1 ;
	WR4 :  SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* extent.bounds | 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN  TYPEOF(bnds.bound))| NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound \ path.edge_list | NOT(('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element))AND(oe.edge_element \ geometric_representation_item.dim = 2))))= 0)))= 0 ;
END_ENTITY; -- brep_2d


ENTITY brep_with_voids
	SUBTYPE OF (manifold_solid_brep);
	voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY; -- brep_with_voids


ENTITY circular_area
	SUBTYPE OF (primitive_2d);
	centre : cartesian_point;
	radius : positive_length_measure;
END_ENTITY; -- circular_area


ENTITY convex_hexahedron
	SUBTYPE OF (faceted_primitive);
WHERE
	WR1 :  SIZEOF(points)= 8 ;
	WR2 :  above_plane(points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ])= 0.0 ;
	WR3 :  above_plane(points [ 5 ], points [ 8 ], points [ 7 ], points [ 6 ])= 0.0 ;
	WR4 :  above_plane(points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ])= 0.0 ;
	WR5 :  above_plane(points [ 4 ], points [ 3 ], points [ 7 ], points [ 8 ])= 0.0 ;
	WR6 :  above_plane(points [ 3 ], points [ 2 ], points [ 6 ], points [ 7 ])= 0.0 ;
	WR7 :  above_plane(points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ])= 0.0 ;
	WR8 :  same_side([ points [ 1 ], points [ 2 ], points [ 3 ] ], [ points [ 5 ], points [ 6 ], points [ 7 ], points [ 8 ] ]);
	WR9 :  same_side([ points [ 1 ], points [ 4 ], points [ 8 ] ], [ points [ 3 ], points [ 7 ], points [ 6 ], points [ 2 ] ]);
	WR10 :  same_side([ points [ 1 ], points [ 2 ], points [ 5 ] ], [ points [ 3 ], points [ 7 ], points [ 8 ], points [ 4 ] ]);
	WR11 :  same_side([ points [ 5 ], points [ 6 ], points [ 7 ] ], [ points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ] ]);
	WR12 :  same_side([ points [ 3 ], points [ 7 ], points [ 6 ] ], [ points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ] ]);
	WR13 :  same_side([ points [ 3 ], points [ 7 ], points [ 8 ] ], [ points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ] ]);
END_ENTITY; -- convex_hexahedron


ENTITY csg_solid
	SUBTYPE OF (solid_model);
	tree_root_expression : csg_select;
END_ENTITY; -- csg_solid


ENTITY cyclide_segment_solid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	radius1 : positive_length_measure;
	radius2 : positive_length_measure;
	cone_angle1 : plane_angle_measure;
	cone_angle2 : plane_angle_measure;
	turn_angle : plane_angle_measure;
END_ENTITY; -- cyclide_segment_solid


ENTITY eccentric_cone
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	height : positive_length_measure;
	x_offset : length_measure;
	y_offset : length_measure;
	ratio : REAL;
WHERE
	WR1 :  ratio >= 0.0 ;
END_ENTITY; -- eccentric_cone


ENTITY edge_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	ebwm_boundary : SET [1:?] OF connected_edge_set;
END_ENTITY; -- edge_based_wireframe_model


ENTITY ellipsoid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	semi_axis_3 : positive_length_measure;
END_ENTITY; -- ellipsoid


ENTITY elliptic_area
	SUBTYPE OF (primitive_2d);
	position : axis2_placement_2d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
END_ENTITY; -- elliptic_area


ENTITY extruded_area_solid
	SUBTYPE OF (swept_area_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 :  dot_product((SELF \ swept_area_solid.swept_area.basis_surface \ elementary_surface.position.p [ 3 ]), extruded_direction)<> 0.0 ;
END_ENTITY; -- extruded_area_solid


ENTITY extruded_face_solid
	SUBTYPE OF (swept_face_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 :  dot_product((SELF \ swept_face_solid.swept_face.face_geometry \ elementary_surface.position.p [ 3 ]), extruded_direction)<> 0.0 ;
END_ENTITY; -- extruded_face_solid


ENTITY face_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	fbsm_faces : SET [1:?] OF connected_face_set;
END_ENTITY; -- face_based_surface_model


ENTITY faceted_brep
	SUBTYPE OF (manifold_solid_brep);
END_ENTITY; -- faceted_brep


ENTITY faceted_primitive
	SUPERTYPE OF (ONEOF (tetrahedron, convex_hexahedron))
	SUBTYPE OF (geometric_representation_item);
	points : LIST [4:?] OF  UNIQUE cartesian_point;
WHERE
	WR1 :  points [ 1 ].dim = 3 ;
END_ENTITY; -- faceted_primitive


ENTITY geometric_curve_set
	SUBTYPE OF (geometric_set);
WHERE
	WR1 :  SIZEOF(QUERY(temp <* SELF \ geometric_set.elements | 'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp)))= 0 ;
END_ENTITY; -- geometric_curve_set


ENTITY geometric_set
	SUPERTYPE OF (ONEOF (geometric_curve_set, geometric_set_replica))
	SUBTYPE OF (geometric_representation_item);
	elements : SET [1:?] OF geometric_set_select;
END_ENTITY; -- geometric_set


ENTITY geometric_set_replica
	SUBTYPE OF (geometric_set);
	parent_set : geometric_set;
	transformation : cartesian_transformation_operator;
DERIVE
	SELF\geometric_set.elements : SET [1:?] OF geometric_set_select :=  build_transformed_set(transformation, parent_set);
WHERE
	WR1 :  acyclic_set_replica(SELF, parent_set);
END_ENTITY; -- geometric_set_replica


ENTITY half_space_2d
	SUBTYPE OF (geometric_representation_item);
	base_curve : curve;
	agreement_flag : BOOLEAN;
END_ENTITY; -- half_space_2d


ENTITY half_space_solid
	SUBTYPE OF (geometric_representation_item);
	base_surface : surface;
	agreement_flag : BOOLEAN;
END_ENTITY; -- half_space_solid


ENTITY manifold_solid_brep
	SUBTYPE OF (solid_model);
	outer : closed_shell;
END_ENTITY; -- manifold_solid_brep


ENTITY polygonal_area
	SUBTYPE OF (primitive_2d);
	bounds : LIST [3:?] OF  UNIQUE cartesian_point;
END_ENTITY; -- polygonal_area


ENTITY primitive_2d
	SUPERTYPE OF (ONEOF (circular_area, elliptic_area, rectangular_area, polygonal_area))
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- primitive_2d


ENTITY rectangle_domain
	SUBTYPE OF (founded_item);
	corner : cartesian_point;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
WHERE
	WR1 :  SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.RECTANGLED_HALF_SPACE' IN TYPEOF(item))))= 0 ;
END_ENTITY; -- rectangle_domain


ENTITY rectangled_half_space
	SUBTYPE OF (half_space_2d);
	enclosure : rectangle_domain;
END_ENTITY; -- rectangled_half_space


ENTITY rectangular_area
	SUBTYPE OF (primitive_2d);
	position : axis2_placement_2d;
	x : positive_length_measure;
	y : positive_length_measure;
END_ENTITY; -- rectangular_area


ENTITY rectangular_pyramid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- rectangular_pyramid


ENTITY revolved_area_solid
	SUBTYPE OF (swept_area_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line :=  representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY; -- revolved_area_solid


ENTITY revolved_face_solid
	SUBTYPE OF (swept_face_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line :=  representation_item('')|| geometric_representation_item()|| curve()|| line(axis.location, representation_item('')|| geometric_representation_item()|| vector(axis.z, 1.0));
END_ENTITY; -- revolved_face_solid


ENTITY right_angular_wedge
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
	ltx : length_measure;
WHERE
	WR1 : ((0.0 <= ltx)AND(ltx < x));
END_ENTITY; -- right_angular_wedge


ENTITY right_circular_cone
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 :  radius >= 0.0 ;
END_ENTITY; -- right_circular_cone


ENTITY right_circular_cylinder
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : positive_length_measure;
END_ENTITY; -- right_circular_cylinder


ENTITY sectioned_spine
	SUBTYPE OF (geometric_curve_set);
	cross_sections : LIST [2:?] OF curve;
	spine_points : LIST [2:?] OF point;
WHERE
	WR1 :  SIZEOF(SELF \ geometric_set.elements)= 1 ;
	WR2 :  'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF \ geometric_set.elements [ 1 ]);
	WR3 :  SIZEOF(cross_sections)= SIZEOF(spine_points);
	WR4 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- sectioned_spine


ENTITY shell_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	sbsm_boundary : SET [1:?] OF shell;
WHERE
	WR1 :  constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY; -- shell_based_surface_model


ENTITY shell_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	sbwm_boundary : SET [1:?] OF shell;
WHERE
	WR1 :  constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY; -- shell_based_wireframe_model


ENTITY solid_model
	SUPERTYPE OF (ONEOF (csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid, solid_replica, brep_2d, trimmed_volume))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- solid_model


ENTITY solid_replica
	SUBTYPE OF (solid_model);
	parent_solid : solid_model;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 :  acyclic_solid_replica(SELF, parent_solid);
	WR2 :  parent_solid \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- solid_replica


ENTITY sphere
	SUBTYPE OF (geometric_representation_item);
	radius : positive_length_measure;
	centre : point;
END_ENTITY; -- sphere


ENTITY surface_curve_swept_area_solid
	SUBTYPE OF (swept_area_solid);
	directrix : curve;
	start_param : REAL;
	end_param : REAL;
	reference_surface : surface;
WHERE
	WR1 : (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR(reference_surface IN(directrix \ surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_area_solid


ENTITY surface_curve_swept_face_solid
	SUBTYPE OF (swept_face_solid);
	directrix : curve;
	start_param : REAL;
	end_param : REAL;
	reference_surface : surface;
WHERE
	WR1 : (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR(reference_surface IN(directrix \ surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_face_solid


ENTITY swept_area_solid
	SUPERTYPE OF (ONEOF (revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid))
	SUBTYPE OF (solid_model);
	swept_area : curve_bounded_surface;
WHERE
	WR1 :  'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY; -- swept_area_solid


ENTITY swept_disk_solid
	SUBTYPE OF (solid_model);
	directrix : curve;
	radius : positive_length_measure;
	inner_radius : OPTIONAL positive_length_measure;
	start_param : REAL;
	end_param : REAL;
WHERE
	WR1 :  directrix.dim = 3 ;
	WR2 : (NOT EXISTS(inner_radius))OR(radius > inner_radius);
END_ENTITY; -- swept_disk_solid


ENTITY swept_face_solid
	SUPERTYPE OF (ONEOF (extruded_face_solid, revolved_face_solid, surface_curve_swept_face_solid))
	SUBTYPE OF (solid_model);
	swept_face : face_surface;
WHERE
	WR1 :  'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY; -- swept_face_solid


ENTITY tetrahedron
	SUBTYPE OF (faceted_primitive);
WHERE
	WR1 :  SIZEOF(points)= 4 ;
	WR2 :  above_plane(points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ])<> 0.0 ;
END_ENTITY; -- tetrahedron


ENTITY torus
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
WHERE
	WR1 :  major_radius > minor_radius ;
END_ENTITY; -- torus


ENTITY trimmed_volume
	SUBTYPE OF (solid_model);
	basis_volume : volume;
	u1 : parameter_value;
	u2 : parameter_value;
	v1 : parameter_value;
	v2 : parameter_value;
	w1 : parameter_value;
	w2 : parameter_value;
WHERE
	WR1 :  u1 <> u2 ;
	WR2 :  v1 <> v2 ;
	WR3 :  w1 <> w2 ;
END_ENTITY; -- trimmed_volume


ENTITY placed_datum_target_feature
	SUBTYPE OF (datum_target);
DERIVE
	representation_associations : SET [0:?] OF property_definition_representation :=  get_shape_aspect_property_definition_representations(SELF);
WHERE
	WR1 :  SELF.description IN [ 'point', 'line', 'rectangle', 'circle', 'circular line' ] ;
	WR2 :  SIZEOF(QUERY(pdr <* representation_associations | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))= 1 ;
	WR3 :  valid_datum_target_parameters(SELF);
END_ENTITY; -- placed_datum_target_feature


ENTITY shape_representation_with_parameters
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(i <* SELF.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLACEMENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' ] * TYPEOF(i))= 1))= SIZEOF(SELF.items);
END_ENTITY; -- shape_representation_with_parameters


ENTITY axis1_placement
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
DERIVE
	z : direction :=  NVL(normalise(axis), dummy_gri || direction([ 0.0, 0.0, 1.0 ]));
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- axis1_placement


ENTITY axis2_placement_2d
	SUBTYPE OF (placement);
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [2:2] OF direction :=  build_2axes(ref_direction);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- axis2_placement_2d


ENTITY axis2_placement_3d
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [3:3] OF direction :=  build_axes(axis, ref_direction);
WHERE
	WR1 :  SELF \ placement.location.dim = 3 ;
	WR2 : (NOT(EXISTS(axis)))OR(axis.dim = 3);
	WR3 : (NOT(EXISTS(ref_direction)))OR(ref_direction.dim = 3);
	WR4 : (NOT(EXISTS(axis)))OR(NOT(EXISTS(ref_direction)))OR(cross_product(axis, ref_direction).magnitude > 0.0);
END_ENTITY; -- axis2_placement_3d


ENTITY b_spline_curve
	SUPERTYPE OF ((ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve))
	SUBTYPE OF (bounded_curve);
	degree : INTEGER;
	control_points_list : LIST [2:?] OF cartesian_point;
	curve_form : b_spline_curve_form;
	closed_curve : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:??] OF cartesian_point :=  list_to_array(control_points_list, 0, upper_index_on_control_points);
	upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list)- 1);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.UNIFORM_CURVE' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.QUASI_UNIFORM_CURVE' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BEZIER_CURVE' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_curve


ENTITY b_spline_curve_with_knots
	SUBTYPE OF (b_spline_curve);
	knot_multiplicities : LIST [2:?] OF INTEGER;
	knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	upper_index_on_knots : INTEGER :=  SIZEOF(knots);
WHERE
	WR1 :  constraints_param_b_spline(degree, upper_index_on_knots, upper_index_on_control_points, knot_multiplicities, knots);
	WR2 :  SIZEOF(knot_multiplicities)= upper_index_on_knots ;
END_ENTITY; -- b_spline_curve_with_knots


ENTITY b_spline_surface
	SUPERTYPE OF ((ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface))
	SUBTYPE OF (bounded_surface);
	u_degree : INTEGER;
	v_degree : INTEGER;
	control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
	surface_form : b_spline_surface_form;
	u_closed : LOGICAL;
	v_closed : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:??] OF ARRAY [0:??] OF cartesian_point :=  make_array_of_array(control_points_list, 0, u_upper, 0, v_upper);
	u_upper : INTEGER :=  SIZEOF(control_points_list)- 1 ;
	v_upper : INTEGER :=  SIZEOF(control_points_list [ 1 ])- 1 ;
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.UNIFORM_SURFACE' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.QUASI_UNIFORM_SURFACE' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BEZIER_SURFACE' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_surface


ENTITY b_spline_surface_with_knots
	SUBTYPE OF (b_spline_surface);
	u_multiplicities : LIST [2:?] OF INTEGER;
	v_multiplicities : LIST [2:?] OF INTEGER;
	u_knots : LIST [2:?] OF parameter_value;
	v_knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	knot_u_upper : INTEGER :=  SIZEOF(u_knots);
	knot_v_upper : INTEGER :=  SIZEOF(v_knots);
WHERE
	WR1 :  constraints_param_b_spline(SELF  \ b_spline_surface.u_degree, knot_u_upper, SELF \ b_spline_surface.u_upper, u_multiplicities, u_knots);
	WR2 :  constraints_param_b_spline(SELF  \ b_spline_surface.v_degree, knot_v_upper, SELF \ b_spline_surface.v_upper, v_multiplicities, v_knots);
	WR3 :  SIZEOF(u_multiplicities)= knot_u_upper ;
	WR4 :  SIZEOF(v_multiplicities)= knot_v_upper ;
END_ENTITY; -- b_spline_surface_with_knots


ENTITY b_spline_volume
	SUPERTYPE OF ((ONEOF (b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume, bezier_volume) ANDOR rational_b_spline_volume))
	SUBTYPE OF (volume);
	u_degree : INTEGER;
	v_degree : INTEGER;
	w_degree : INTEGER;
	control_points_list : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF cartesian_point;
DERIVE
	control_points : ARRAY [0:??] OF ARRAY [0:??] OF ARRAY [0:??] OF cartesian_point :=  make_array_of_array_of_array(control_points_list, 0, u_upper, 0, v_upper, 0, w_upper);
	u_upper : INTEGER :=  SIZEOF(control_points_list)- 1 ;
	v_upper : INTEGER :=  SIZEOF(control_points_list [ 1 ])- 1 ;
	w_upper : INTEGER :=  SIZEOF(control_points_list [ 1 ] [ 1 ])- 1 ;
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BEZIER_VOLUME' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.UNIFORM_VOLUME' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.QUASI_UNIFORM_VOLUME' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_volume


ENTITY b_spline_volume_with_knots
	SUBTYPE OF (b_spline_volume);
	u_multiplicities : LIST [2:?] OF INTEGER;
	v_multiplicities : LIST [2:?] OF INTEGER;
	w_multiplicities : LIST [2:?] OF INTEGER;
	u_knots : LIST [2:?] OF parameter_value;
	v_knots : LIST [2:?] OF parameter_value;
	w_knots : LIST [2:?] OF parameter_value;
DERIVE
	knot_u_upper : INTEGER :=  SIZEOF(u_knots);
	knot_v_upper : INTEGER :=  SIZEOF(v_knots);
	knot_w_upper : INTEGER :=  SIZEOF(w_knots);
WHERE
	WR1 :  constraints_param_b_spline(SELF  \ b_spline_volume.u_degree, knot_u_upper, SELF \ b_spline_volume.u_upper, u_multiplicities, u_knots);
	WR2 :  constraints_param_b_spline(SELF  \ b_spline_volume.v_degree, knot_v_upper, SELF \ b_spline_volume.v_upper, v_multiplicities, v_knots);
	WR3 :  constraints_param_b_spline(SELF  \ b_spline_volume.w_degree, knot_w_upper, SELF \ b_spline_volume.w_upper, w_multiplicities, w_knots);
	WR4 :  SIZEOF(u_multiplicities)= knot_u_upper ;
	WR5 :  SIZEOF(v_multiplicities)= knot_v_upper ;
	WR6 :  SIZEOF(w_multiplicities)= knot_w_upper ;
END_ENTITY; -- b_spline_volume_with_knots


ENTITY bezier_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- bezier_curve


ENTITY bezier_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- bezier_surface


ENTITY bezier_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- bezier_volume


ENTITY block_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
END_ENTITY; -- block_volume


ENTITY boundary_curve
	SUBTYPE OF (composite_curve_on_surface);
WHERE
	WR1 :  SELF \ composite_curve.closed_curve ;
END_ENTITY; -- boundary_curve


ENTITY bounded_curve
	SUPERTYPE OF (ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve))
	SUBTYPE OF (curve);
END_ENTITY; -- bounded_curve


ENTITY bounded_pcurve
	SUBTYPE OF (pcurve, bounded_curve);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOUNDED_CURVE' IN TYPEOF(SELF \ pcurve.reference_to_curve.items [ 1 ]));
END_ENTITY; -- bounded_pcurve


ENTITY bounded_surface
	SUPERTYPE OF (ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface))
	SUBTYPE OF (surface);
END_ENTITY; -- bounded_surface


ENTITY bounded_surface_curve
	SUBTYPE OF (surface_curve, bounded_curve);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOUNDED_CURVE' IN TYPEOF(SELF \ surface_curve.curve_3d));
END_ENTITY; -- bounded_surface_curve


ENTITY cartesian_point
	SUPERTYPE OF (ONEOF (cylindrical_point, polar_point, spherical_point))
	SUBTYPE OF (point);
	coordinates : LIST [1:3] OF length_measure;
END_ENTITY; -- cartesian_point


ENTITY cartesian_transformation_operator
	SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))
	SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
	axis1 : OPTIONAL direction;
	axis2 : OPTIONAL direction;
	local_origin : cartesian_point;
	scale : OPTIONAL REAL;
DERIVE
	scl : REAL :=  NVL(scale, 1.0);
WHERE
	WR1 :  scl > 0.0 ;
END_ENTITY; -- cartesian_transformation_operator


ENTITY cartesian_transformation_operator_2d
	SUBTYPE OF (cartesian_transformation_operator);
DERIVE
	u : LIST [2:2] OF direction :=  base_axis(2, SELF  \ cartesian_transformation_operator.axis1, SELF \ cartesian_transformation_operator.axis2, ?);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- cartesian_transformation_operator_2d


ENTITY cartesian_transformation_operator_3d
	SUBTYPE OF (cartesian_transformation_operator);
	axis3 : OPTIONAL direction;
DERIVE
	u : LIST [3:3] OF direction :=  base_axis(3, SELF  \ cartesian_transformation_operator.axis1, SELF \ cartesian_transformation_operator.axis2, axis3);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- cartesian_transformation_operator_3d


ENTITY circle
	SUBTYPE OF (conic);
	radius : positive_length_measure;
END_ENTITY; -- circle


ENTITY circular_involute
	SUBTYPE OF (curve);
	position : axis2_placement;
	base_radius : positive_length_measure;
END_ENTITY; -- circular_involute


ENTITY clothoid
	SUBTYPE OF (curve);
	position : axis2_placement;
	clothoid_constant : length_measure;
END_ENTITY; -- clothoid


ENTITY composite_curve
	SUBTYPE OF (bounded_curve);
	segments : LIST [1:?] OF composite_curve_segment;
	self_intersect : LOGICAL;
DERIVE
	closed_curve : LOGICAL :=  segments [ n_segments ].transition <> discontinuous ;
	n_segments : INTEGER :=  SIZEOF(segments);
WHERE
	WR1 : ((NOT closed_curve)AND(SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous))= 1))OR((closed_curve)AND(SIZEOF(QUERY(temp <* segments | temp.transition = discontinuous))= 0));
END_ENTITY; -- composite_curve


ENTITY composite_curve_on_surface
	SUPERTYPE OF (boundary_curve)
	SUBTYPE OF (composite_curve);
DERIVE
	basis_surface : SET [0:2] OF surface :=  get_basis_surface(SELF);
WHERE
	WR1 :  SIZEOF(basis_surface)> 0 ;
	WR2 :  constraints_composite_curve_on_surface(SELF);
END_ENTITY; -- composite_curve_on_surface


ENTITY composite_curve_segment
	SUBTYPE OF (founded_item);
	transition : transition_code;
	same_sense : BOOLEAN;
	parent_curve : curve;
INVERSE
	using_curves: BAG [1:?] OF composite_curve FOR segments;
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY; -- composite_curve_segment


ENTITY conic
	SUPERTYPE OF (ONEOF (circle, ellipse, hyperbola, parabola))
	SUBTYPE OF (curve);
	position : axis2_placement;
END_ENTITY; -- conic


ENTITY conical_surface
	SUBTYPE OF (elementary_surface);
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 :  radius >= 0.0 ;
END_ENTITY; -- conical_surface


ENTITY curve
	SUPERTYPE OF (ONEOF (line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- curve


ENTITY curve_bounded_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	boundaries : SET [1:?] OF boundary_curve;
	implicit_outer : BOOLEAN;
WHERE
	WR1 : (NOT implicit_outer)OR(SIZEOF(QUERY(temp <* boundaries | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))= 0);
	WR2 : (NOT(implicit_outer))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
	WR3 :  SIZEOF(QUERY(temp <* boundaries | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))<= 1 ;
	WR4 :  SIZEOF(QUERY(temp <* boundaries |(temp \ composite_curve_on_surface.basis_surface [ 1 ] <> SELF.basis_surface)))= 0 ;
END_ENTITY; -- curve_bounded_surface


ENTITY curve_replica
	SUBTYPE OF (curve);
	parent_curve : curve;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 :  transformation.dim = parent_curve.dim ;
	WR2 :  acyclic_curve_replica(SELF, parent_curve);
END_ENTITY; -- curve_replica


ENTITY cylindrical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	z : length_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=  [ r * COS(theta), r * SIN(theta), z ] ;
WHERE
	WR1 :  r >= 0.0 ;
END_ENTITY; -- cylindrical_point


ENTITY cylindrical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY; -- cylindrical_surface


ENTITY cylindrical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	radius : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- cylindrical_volume


ENTITY degenerate_pcurve
	SUBTYPE OF (point);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 :  SIZEOF(reference_to_curve \ representation.items)= 1 ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE' IN TYPEOF(reference_to_curve \ representation.items [ 1 ]);
	WR3 :  reference_to_curve \ representation.items [ 1 ] \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- degenerate_pcurve


ENTITY degenerate_toroidal_surface
	SUBTYPE OF (toroidal_surface);
	select_outer : BOOLEAN;
WHERE
	WR1 :  major_radius < minor_radius ;
END_ENTITY; -- degenerate_toroidal_surface


ENTITY direction
	SUBTYPE OF (geometric_representation_item);
	direction_ratios : LIST [2:3] OF REAL;
WHERE
	WR1 :  SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0))> 0 ;
END_ENTITY; -- direction


ENTITY dupin_cyclide_surface
	SUBTYPE OF (elementary_surface);
	generalised_major_radius : positive_length_measure;
	generalised_minor_radius : positive_length_measure;
	skewness : length_measure;
WHERE
	WR1 :  skewness >= 0.0 ;
END_ENTITY; -- dupin_cyclide_surface


ENTITY eccentric_conical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	height : positive_length_measure;
	x_offset : length_measure;
	y_offset : length_measure;
	ratio : REAL;
WHERE
	WR1 :  ratio >= 0.0 ;
END_ENTITY; -- eccentric_conical_volume


ENTITY elementary_surface
	SUPERTYPE OF (ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))
	SUBTYPE OF (surface);
	position : axis2_placement_3d;
END_ENTITY; -- elementary_surface


ENTITY ellipse
	SUBTYPE OF (conic);
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
END_ENTITY; -- ellipse


ENTITY ellipsoid_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	semi_axis_3 : positive_length_measure;
END_ENTITY; -- ellipsoid_volume


ENTITY evaluated_degenerate_pcurve
	SUBTYPE OF (degenerate_pcurve);
	equivalent_point : cartesian_point;
END_ENTITY; -- evaluated_degenerate_pcurve


ENTITY fixed_reference_swept_surface
	SUBTYPE OF (swept_surface);
	directrix : curve;
	fixed_reference : direction;
END_ENTITY; -- fixed_reference_swept_surface


ENTITY geometric_representation_context
	SUBTYPE OF (representation_context);
	coordinate_space_dimension : dimension_count;
END_ENTITY; -- geometric_representation_context


ENTITY geometric_representation_item
	SUPERTYPE OF (ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge, ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid, half_space_2d, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set))
	SUBTYPE OF (representation_item);
DERIVE
	dim : dimension_count :=  dimension_of(SELF);
WHERE
	WR1 :  SIZEOF(QUERY(using_rep <* using_representations(SELF)| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(using_rep.context_of_items))))= 0 ;
END_ENTITY; -- geometric_representation_item


ENTITY hexahedron_volume
	SUBTYPE OF (volume);
	points : LIST [8:8] OF cartesian_point;
WHERE
	WR1 :  above_plane(points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ])= 0.0 ;
	WR2 :  above_plane(points [ 5 ], points [ 8 ], points [ 7 ], points [ 6 ])= 0.0 ;
	WR3 :  above_plane(points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ])= 0.0 ;
	WR4 :  above_plane(points [ 4 ], points [ 3 ], points [ 7 ], points [ 8 ])= 0.0 ;
	WR5 :  above_plane(points [ 3 ], points [ 2 ], points [ 6 ], points [ 7 ])= 0.0 ;
	WR6 :  above_plane(points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ])= 0.0 ;
	WR7 :  same_side([ points [ 1 ], points [ 2 ], points [ 3 ] ], [ points [ 5 ], points [ 6 ], points [ 7 ], points [ 8 ] ]);
	WR8 :  same_side([ points [ 1 ], points [ 4 ], points [ 8 ] ], [ points [ 3 ], points [ 7 ], points [ 6 ], points [ 2 ] ]);
	WR9 :  same_side([ points [ 1 ], points [ 2 ], points [ 5 ] ], [ points [ 3 ], points [ 7 ], points [ 8 ], points [ 4 ] ]);
	WR10 :  same_side([ points [ 5 ], points [ 6 ], points [ 7 ] ], [ points [ 1 ], points [ 2 ], points [ 3 ], points [ 4 ] ]);
	WR11 :  same_side([ points [ 3 ], points [ 7 ], points [ 6 ] ], [ points [ 1 ], points [ 4 ], points [ 8 ], points [ 5 ] ]);
	WR12 :  same_side([ points [ 3 ], points [ 7 ], points [ 8 ] ], [ points [ 1 ], points [ 5 ], points [ 6 ], points [ 2 ] ]);
	WR13 :  points [ 1 ].dim = 3 ;
END_ENTITY; -- hexahedron_volume


ENTITY hyperbola
	SUBTYPE OF (conic);
	semi_axis : positive_length_measure;
	semi_imag_axis : positive_length_measure;
END_ENTITY; -- hyperbola


ENTITY intersection_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 :  SIZEOF(SELF \ surface_curve.associated_geometry)= 2 ;
	WR2 :  associated_surface(SELF  \ surface_curve.associated_geometry [ 1 ])<> associated_surface(SELF \ surface_curve.associated_geometry [ 2 ]);
END_ENTITY; -- intersection_curve


ENTITY line
	SUBTYPE OF (curve);
	pnt : cartesian_point;
	dir : vector;
WHERE
	WR1 :  dir.dim = pnt.dim ;
END_ENTITY; -- line


ENTITY offset_curve_2d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
WHERE
	WR1 :  basis_curve.dim = 2 ;
END_ENTITY; -- offset_curve_2d


ENTITY offset_curve_3d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
	ref_direction : direction;
WHERE
	WR1 : (basis_curve.dim = 3)AND(ref_direction.dim = 3);
END_ENTITY; -- offset_curve_3d


ENTITY offset_surface
	SUBTYPE OF (surface);
	basis_surface : surface;
	distance : length_measure;
	self_intersect : LOGICAL;
END_ENTITY; -- offset_surface


ENTITY oriented_surface
	SUBTYPE OF (surface);
	orientation : BOOLEAN;
END_ENTITY; -- oriented_surface


ENTITY outer_boundary_curve
	SUBTYPE OF (boundary_curve);
END_ENTITY; -- outer_boundary_curve


ENTITY parabola
	SUBTYPE OF (conic);
	focal_dist : length_measure;
WHERE
	WR1 :  focal_dist <> 0.0 ;
END_ENTITY; -- parabola


ENTITY pcurve
	SUBTYPE OF (curve);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 :  SIZEOF(reference_to_curve \ representation.items)= 1 ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE' IN TYPEOF(reference_to_curve \ representation.items [ 1 ]);
	WR3 :  reference_to_curve \ representation.items [ 1 ] \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- pcurve


ENTITY placement
	SUPERTYPE OF (ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d))
	SUBTYPE OF (geometric_representation_item);
	location : cartesian_point;
END_ENTITY; -- placement


ENTITY plane
	SUBTYPE OF (elementary_surface);
END_ENTITY; -- plane


ENTITY point
	SUPERTYPE OF (ONEOF (cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica, degenerate_pcurve))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- point


ENTITY point_in_volume
	SUBTYPE OF (point);
	basis_volume : volume;
	point_parameter_u : parameter_value;
	point_parameter_v : parameter_value;
	point_parameter_w : parameter_value;
END_ENTITY; -- point_in_volume


ENTITY point_on_curve
	SUBTYPE OF (point);
	basis_curve : curve;
	point_parameter : parameter_value;
END_ENTITY; -- point_on_curve


ENTITY point_on_surface
	SUBTYPE OF (point);
	basis_surface : surface;
	point_parameter_u : parameter_value;
	point_parameter_v : parameter_value;
END_ENTITY; -- point_on_surface


ENTITY point_replica
	SUBTYPE OF (point);
	parent_pt : point;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 :  transformation.dim = parent_pt.dim ;
	WR2 :  acyclic_point_replica(SELF, parent_pt);
END_ENTITY; -- point_replica


ENTITY polar_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=  [ r * COS(theta), r * SIN(theta)] ;
WHERE
	WR1 :  r >= 0.0 ;
END_ENTITY; -- polar_point


ENTITY polyline
	SUBTYPE OF (bounded_curve);
	points : LIST [2:?] OF cartesian_point;
END_ENTITY; -- polyline


ENTITY pyramid_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- pyramid_volume


ENTITY quasi_uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- quasi_uniform_curve


ENTITY quasi_uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- quasi_uniform_surface


ENTITY quasi_uniform_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- quasi_uniform_volume


ENTITY rational_b_spline_curve
	SUBTYPE OF (b_spline_curve);
	weights_data : LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:??] OF REAL :=  list_to_array(weights_data, 0, upper_index_on_control_points);
WHERE
	WR1 :  SIZEOF(weights_data)= SIZEOF(SELF \ b_spline_curve.control_points_list);
	WR2 :  curve_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_curve


ENTITY rational_b_spline_surface
	SUBTYPE OF (b_spline_surface);
	weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:??] OF ARRAY [0:??] OF REAL :=  make_array_of_array(weights_data, 0, u_upper, 0, v_upper);
WHERE
	WR1 : (SIZEOF(weights_data)= SIZEOF(SELF  \ b_spline_surface.control_points_list))AND(SIZEOF(weights_data [ 1 ])= SIZEOF(SELF \ b_spline_surface.control_points_list [ 1 ]));
	WR2 :  surface_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_surface


ENTITY rational_b_spline_volume
	SUBTYPE OF (b_spline_volume);
	weights_data : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:??] OF ARRAY [0:??] OF ARRAY [0:??] OF REAL :=  make_array_of_array_of_array(weights_data, 0, u_upper, 0, v_upper, 0, w_upper);
WHERE
	WR1 : (SIZEOF(weights_data)= SIZEOF(SELF  \ b_spline_volume.control_points_list))AND(SIZEOF(weights_data [ 1 ])= SIZEOF(SELF  \ b_spline_volume.control_points_list [ 1 ]))AND(SIZEOF(weights_data [ 1 ] [ 1 ])= SIZEOF(SELF \ b_spline_volume.control_points_list [ 1 ] [ 1 ]));
	WR2 :  volume_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_volume


ENTITY rectangular_composite_surface
	SUBTYPE OF (bounded_surface);
	segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
DERIVE
	n_u : INTEGER :=  SIZEOF(segments);
	n_v : INTEGER :=  SIZEOF(segments [ 1 ]);
WHERE
	WR1 :  SIZEOF(QUERY(s <* segments | n_v <> SIZEOF(s)))= 0 ;
	WR2 :  constraints_rectangular_composite_surface(SELF);
END_ENTITY; -- rectangular_composite_surface


ENTITY rectangular_trimmed_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	u1 : parameter_value;
	u2 : parameter_value;
	v1 : parameter_value;
	v2 : parameter_value;
	usense : BOOLEAN;
	vsense : BOOLEAN;
WHERE
	WR1 :  u1 <> u2 ;
	WR2 :  v1 <> v2 ;
	WR3 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN  TYPEOF(basis_surface))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLANE' IN  TYPEOF(basis_surface))))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))OR(usense =(u2 > u1));
	WR4 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SPHERICAL_SURFACE' IN  TYPEOF(basis_surface))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))OR(vsense =(v2 > v1));
END_ENTITY; -- rectangular_trimmed_surface


ENTITY reparametrised_composite_curve_segment
	SUBTYPE OF (composite_curve_segment);
	param_length : parameter_value;
WHERE
	WR1 :  param_length > 0.0 ;
END_ENTITY; -- reparametrised_composite_curve_segment


ENTITY seam_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 :  SIZEOF(SELF \ surface_curve.associated_geometry)= 2 ;
	WR2 :  associated_surface(SELF  \ surface_curve.associated_geometry [ 1 ])= associated_surface(SELF \ surface_curve.associated_geometry [ 2 ]);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(SELF \ surface_curve.associated_geometry [ 1 ]);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(SELF \ surface_curve.associated_geometry [ 2 ]);
END_ENTITY; -- seam_curve


ENTITY spherical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	phi : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure :=  [ r * SIN(theta)* COS(phi), r * SIN(theta)* SIN(phi), r * COS(theta)] ;
WHERE
	WR1 :  r >= 0.0 ;
END_ENTITY; -- spherical_point


ENTITY spherical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY; -- spherical_surface


ENTITY spherical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	radius : positive_length_measure;
END_ENTITY; -- spherical_volume


ENTITY surface
	SUPERTYPE OF (ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- surface


ENTITY surface_curve
	SUPERTYPE OF ((ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve))
	SUBTYPE OF (curve);
	curve_3d : curve;
	associated_geometry : LIST [1:2] OF pcurve_or_surface;
	master_representation : preferred_surface_curve_representation;
DERIVE
	basis_surface : SET [1:2] OF surface :=  get_basis_surface(SELF);
WHERE
	WR1 :  curve_3d.dim = 3 ;
	WR2 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(associated_geometry [ 1 ]))OR(master_representation <> pcurve_s1);
	WR3 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(associated_geometry [ 2 ]))OR(master_representation <> pcurve_s2);
	WR4 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY; -- surface_curve


ENTITY surface_curve_swept_surface
	SUBTYPE OF (swept_surface);
	directrix : curve;
	reference_surface : surface;
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(directrix)))OR(reference_surface IN(directrix \ surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_surface


ENTITY surface_of_linear_extrusion
	SUBTYPE OF (swept_surface);
	extrusion_axis : vector;
END_ENTITY; -- surface_of_linear_extrusion


ENTITY surface_of_revolution
	SUBTYPE OF (swept_surface);
	axis_position : axis1_placement;
DERIVE
	axis_line : line :=  representation_item('')|| geometric_representation_item()|| curve()|| line(axis_position.location, representation_item('')|| geometric_representation_item()|| vector(axis_position.z, 1.0));
END_ENTITY; -- surface_of_revolution


ENTITY surface_patch
	SUBTYPE OF (founded_item);
	parent_surface : bounded_surface;
	u_transition : transition_code;
	v_transition : transition_code;
	u_sense : BOOLEAN;
	v_sense : BOOLEAN;
INVERSE
	using_surfaces: BAG [1:?] OF rectangular_composite_surface FOR segments;
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE' IN TYPEOF(parent_surface)));
END_ENTITY; -- surface_patch


ENTITY surface_replica
	SUBTYPE OF (surface);
	parent_surface : surface;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 :  acyclic_surface_replica(SELF, parent_surface);
END_ENTITY; -- surface_replica


ENTITY swept_surface
	SUPERTYPE OF (ONEOF (surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface, fixed_reference_swept_surface))
	SUBTYPE OF (surface);
	swept_curve : curve;
END_ENTITY; -- swept_surface


ENTITY tetrahedron_volume
	SUBTYPE OF (volume);
	point_1 : cartesian_point;
	point_2 : cartesian_point;
	point_3 : cartesian_point;
	point_4 : cartesian_point;
WHERE
	WR1 :  point_1.dim = 3 ;
	WR2 :  above_plane(point_1, point_2, point_3, point_4)<> 0.0 ;
END_ENTITY; -- tetrahedron_volume


ENTITY toroidal_surface
	SUBTYPE OF (elementary_surface);
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
END_ENTITY; -- toroidal_surface


ENTITY toroidal_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
WHERE
	WR1 :  minor_radius < major_radius ;
END_ENTITY; -- toroidal_volume


ENTITY trimmed_curve
	SUBTYPE OF (bounded_curve);
	basis_curve : curve;
	trim_1 : SET [1:2] OF trimming_select;
	trim_2 : SET [1:2] OF trimming_select;
	sense_agreement : BOOLEAN;
	master_representation : trimming_preference;
WHERE
	WR1 : (HIINDEX(trim_1)= 1)OR(TYPEOF(trim_1 [ 1 ])<> TYPEOF(trim_1 [ 2 ]));
	WR2 : (HIINDEX(trim_2)= 1)OR(TYPEOF(trim_2 [ 1 ])<> TYPEOF(trim_2 [ 2 ]));
END_ENTITY; -- trimmed_curve


ENTITY uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- uniform_curve


ENTITY uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- uniform_surface


ENTITY uniform_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- uniform_volume


ENTITY vector
	SUBTYPE OF (geometric_representation_item);
	orientation : direction;
	magnitude : length_measure;
WHERE
	WR1 :  magnitude >= 0.0 ;
END_ENTITY; -- vector


ENTITY volume
	SUPERTYPE OF (ONEOF (block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume))
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- volume


ENTITY wedge_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
	ltx : length_measure;
WHERE
	WR1 : ((0.0 <= ltx)AND(ltx < x));
END_ENTITY; -- wedge_volume


ENTITY applied_group_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF groupable_item;
END_ENTITY; -- applied_group_assignment


ENTITY group;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- group


ENTITY group_relationship;
	name : label;
	description : OPTIONAL text;
	relating_group : group;
	related_group : group;
END_ENTITY; -- group_relationship


ENTITY applied_identification_assignment
	SUBTYPE OF (identification_assignment);
	items : SET [1:?] OF identification_item;
END_ENTITY; -- applied_identification_assignment


ENTITY direct_stratum_component_join_implementation
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect_relationship || SELF \ direct_stratum_component_join_implementation))= 0 ;
END_ENTITY; -- direct_stratum_component_join_implementation


ENTITY indirect_stratum_component_join_implementation
	SUBTYPE OF (plated_inter_stratum_feature);
END_ENTITY; -- indirect_stratum_component_join_implementation


ENTITY interconnect_definition
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  EXISTS(SELF \ product_definition.name);
	WR2 :  NOT EXISTS(SELF  \ product_definition.name)OR(SELF \ product_definition.name = 'interconnect module');
	WR3 : (NOT(SELF.frame_of_reference.name = 'physical design'))OR(SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_INTERCONNECT_DEFINITION' ] * TYPEOF(du.relating_product_definition))= 1)AND(du.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(du.relating_product_definition \ product_definition.name = 'interconnect module')))= 1);
END_ENTITY; -- interconnect_definition


ENTITY interconnect_module_cutout_segment_surface
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR3 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR4 :  SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed surface')|('interconnect module cutout surface' = ce.relating_shape_aspect \ shape_aspect.description)))= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ interconnect_module_cutout_segment_surface))= 0 ;
END_ENTITY; -- interconnect_module_cutout_segment_surface


ENTITY interconnect_module_edge_segment_surface
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR3 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR4 :  SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed surface')|('interconnect module edge surface' = ce.relating_shape_aspect \ shape_aspect.description)))= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ interconnect_module_edge_segment_surface))= 0 ;
END_ENTITY; -- interconnect_module_edge_segment_surface


ENTITY interconnect_module_interface_terminal
	SUBTYPE OF (interconnect_module_terminal);
END_ENTITY; -- interconnect_module_interface_terminal


ENTITY interconnect_module_terminal
	SUPERTYPE OF (interconnect_module_interface_terminal)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  EXISTS(SELF.of_shape.definition \ product_definition.name);
	WR2 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical design usage')AND(SELF.of_shape.definition \ product_definition.name = 'interconnect module');
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1))>= 1 ;
	WR4 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
	WR5 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))<= 1 ;
END_ENTITY; -- interconnect_module_terminal


ENTITY interconnect_module_macro_component_join_terminal
	SUBTYPE OF (component_terminal);
WHERE
	WR1 :  NOT(SELF \ shape_aspect.description IN [ 'assembly module component terminal', 'bare die component terminal', 'component termination passage join terminal', 'conductive interconnect element terminal', 'interconnect component join terminal', 'land join terminal', 'minimally defined component terminal', 'non functional land join terminal', 'packaged component join terminal', 'printed component join terminal', 'package terminal occurrence', 'via terminal' ]);
END_ENTITY; -- interconnect_module_macro_component_join_terminal


ENTITY manifold_constraining_context_dependent_shape_representation
	SUBTYPE OF (context_dependent_shape_representation, representation_relationship);
END_ENTITY; -- manifold_constraining_context_dependent_shape_representation


ENTITY shape_representation_relationship_with_transformation
	SUBTYPE OF (shape_representation_relationship, representation_relationship_with_transformation);
END_ENTITY; -- shape_representation_relationship_with_transformation


ENTITY thermal_isolation_removal_template_definition
	SUBTYPE OF (part_template_definition);
END_ENTITY; -- thermal_isolation_removal_template_definition


ENTITY interconnect_module_design_object_category
	SUBTYPE OF (characterized_object);
WHERE
	WR1 :  SELF \ characterized_object.description IN [ 'cutout category', 'fill area category', 'inter stratum feature category', 'stratum feature category', 'via category' ] ;
END_ENTITY; -- interconnect_module_design_object_category


ENTITY component_interface_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'interconnect component interface terminal', 'packaged connector component interface terminal' ] ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))<= 1 ;
	WR4 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design usage'))<= 1 ;
	WR5 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERFACE_COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
	WR6 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence');
	WR7 : (NOT(SELF  \ shape_aspect.description = 'interconnect component interface terminal'))OR((SIZEOF(QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1)AND NOT(SELF.of_shape.definition \ product_definition.description IN [ 'assembly module component', 'bare die component', 'interconnect module component', 'laminate component', 'packaged component' ]));
	WR8 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(SELF.product_definitional);
	WR9 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_COMPONENT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.description = 'packaged connector component')AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical occurrence'));
	WR10 : (NOT(SELF  \ shape_aspect.description = 'packaged connector component interface terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(i_f.relating_shape_aspect \ shape_aspect.description = 'interface terminal')))= 1);
END_ENTITY; -- component_interface_terminal


ENTITY interface_component_definition
	SUBTYPE OF (component_definition);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL' IN  TYPEOF(sa))AND(sa \ shape_aspect.description IN [ 'interconnect component interface terminal', 'packaged connector component interface terminal' ])))>= 1))>= 1);
END_ENTITY; -- interface_component_definition


ENTITY abs_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- abs_function


ENTITY acos_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- acos_function


ENTITY and_expression
	SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY; -- and_expression


ENTITY asin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- asin_function


ENTITY atan_function
	SUBTYPE OF (binary_function_call);
END_ENTITY; -- atan_function


ENTITY binary_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (xor_expression, equals_expression))
	SUBTYPE OF (boolean_expression, binary_generic_expression);
END_ENTITY; -- binary_boolean_expression


ENTITY binary_function_call
	ABSTRACT SUPERTYPE OF (atan_function)
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- binary_function_call


ENTITY binary_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (minus_expression, div_expression, mod_expression, slash_expression, power_expression, binary_function_call))
	SUBTYPE OF (numeric_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF numeric_expression;
END_ENTITY; -- binary_numeric_expression


ENTITY boolean_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function, boolean_expression);
END_ENTITY; -- boolean_defined_function


ENTITY boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_boolean_expression, unary_boolean_expression, binary_boolean_expression, multiple_arity_boolean_expression, comparison_expression, interval_expression, boolean_defined_function))
	SUBTYPE OF (expression);
END_ENTITY; -- boolean_expression


ENTITY boolean_literal
	SUBTYPE OF (simple_boolean_expression, generic_literal);
	the_value : BOOLEAN;
END_ENTITY; -- boolean_literal


ENTITY boolean_variable
	SUBTYPE OF (simple_boolean_expression, variable);
END_ENTITY; -- boolean_variable


ENTITY comparison_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_equal


ENTITY comparison_expression
	ABSTRACT SUPERTYPE OF (ONEOF (comparison_equal, comparison_greater, comparison_greater_equal, comparison_less, comparison_less_equal, comparison_not_equal, like_expression))
	SUBTYPE OF (boolean_expression, binary_generic_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF expression;
WHERE
	WR1 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 2 ])))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOOLEAN_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOOLEAN_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 2 ])))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF \ binary_generic_expression.operands [ 2 ])));
END_ENTITY; -- comparison_expression


ENTITY comparison_greater
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_greater


ENTITY comparison_greater_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_greater_equal


ENTITY comparison_less
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_less


ENTITY comparison_less_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_less_equal


ENTITY comparison_not_equal
	SUBTYPE OF (comparison_expression);
END_ENTITY; -- comparison_not_equal


ENTITY concat_expression
	SUBTYPE OF (string_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF string_expression;
END_ENTITY; -- concat_expression


ENTITY cos_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- cos_function


ENTITY defined_function
	ABSTRACT SUPERTYPE OF ((ONEOF (numeric_defined_function, string_defined_function, boolean_defined_function) ANDOR SQL_mappable_defined_function));
END_ENTITY; -- defined_function


ENTITY div_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- div_expression


ENTITY equals_expression
	SUBTYPE OF (binary_boolean_expression);
END_ENTITY; -- equals_expression


ENTITY exp_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- exp_function


ENTITY expression
	ABSTRACT SUPERTYPE OF (ONEOF (numeric_expression, boolean_expression, string_expression))
	SUBTYPE OF (generic_expression);
END_ENTITY; -- expression


ENTITY format_function
	SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	format_string : generic_expression :=  SELF \ binary_generic_expression.operands [ 2 ] ;
	value_to_format : generic_expression :=  SELF \ binary_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION')IN  TYPEOF(value_to_format))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION')IN TYPEOF(format_string));
END_ENTITY; -- format_function


ENTITY index_expression
	SUBTYPE OF (string_expression, binary_generic_expression);
DERIVE
	index : generic_expression :=  SELF \ binary_generic_expression.operands [ 2 ] ;
	operand : generic_expression :=  SELF \ binary_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(operand))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index));
	WR2 :  is_int_expr(index);
END_ENTITY; -- index_expression


ENTITY int_literal
	SUBTYPE OF (literal_number);
	SELF\literal_number.the_value : INTEGER;
END_ENTITY; -- int_literal


ENTITY int_numeric_variable
	SUBTYPE OF (numeric_variable);
END_ENTITY; -- int_numeric_variable


ENTITY int_value_function
	SUBTYPE OF (value_function);
END_ENTITY; -- int_value_function


ENTITY integer_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (numeric_defined_function);
END_ENTITY; -- integer_defined_function


ENTITY interval_expression
	SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
DERIVE
	interval_high : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 3 ] ;
	interval_item : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	interval_low : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EXPRESSION' IN  TYPEOF(interval_low))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EXPRESSION' IN  TYPEOF(interval_item))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EXPRESSION' IN TYPEOF(interval_high));
	WR2 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_low))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_high))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_item)))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF.interval_low))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(SELF.interval_item))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(SELF.interval_high)));
END_ENTITY; -- interval_expression


ENTITY length_function
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : string_expression;
END_ENTITY; -- length_function


ENTITY like_expression
	SUBTYPE OF (comparison_expression);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(SELF  \ binary_generic_expression.operands [ 1 ]))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN TYPEOF(SELF \ binary_generic_expression.operands [ 2 ]));
END_ENTITY; -- like_expression


ENTITY literal_number
	ABSTRACT SUPERTYPE OF (ONEOF (int_literal, real_literal))
	SUBTYPE OF (simple_numeric_expression, generic_literal);
	the_value : NUMBER;
END_ENTITY; -- literal_number


ENTITY log10_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- log10_function


ENTITY log2_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- log2_function


ENTITY log_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- log_function


ENTITY maximum_function
	SUBTYPE OF (multiple_arity_function_call);
END_ENTITY; -- maximum_function


ENTITY minimum_function
	SUBTYPE OF (multiple_arity_function_call);
END_ENTITY; -- minimum_function


ENTITY minus_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- minus_expression


ENTITY minus_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- minus_function


ENTITY mod_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- mod_expression


ENTITY mult_expression
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY; -- mult_expression


ENTITY multiple_arity_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (and_expression, or_expression))
	SUBTYPE OF (boolean_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF boolean_expression;
END_ENTITY; -- multiple_arity_boolean_expression


ENTITY multiple_arity_function_call
	ABSTRACT SUPERTYPE OF (ONEOF (maximum_function, minimum_function))
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY; -- multiple_arity_function_call


ENTITY multiple_arity_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (plus_expression, mult_expression, multiple_arity_function_call))
	SUBTYPE OF (numeric_expression, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF numeric_expression;
END_ENTITY; -- multiple_arity_numeric_expression


ENTITY not_expression
	SUBTYPE OF (unary_boolean_expression);
	SELF\unary_generic_expression.operand : boolean_expression;
END_ENTITY; -- not_expression


ENTITY numeric_defined_function
	ABSTRACT SUPERTYPE OF (ONEOF (integer_defined_function, real_defined_function))
	SUBTYPE OF (numeric_expression, defined_function);
END_ENTITY; -- numeric_defined_function


ENTITY numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_numeric_expression, unary_numeric_expression, binary_numeric_expression, multiple_arity_numeric_expression, length_function, value_function, numeric_defined_function))
	SUBTYPE OF (expression);
DERIVE
	is_int : BOOLEAN :=  is_int_expr(SELF);
	sql_mappable : BOOLEAN :=  is_SQL_mappable(SELF);
END_ENTITY; -- numeric_expression


ENTITY numeric_variable
	SUPERTYPE OF (ONEOF (int_numeric_variable, real_numeric_variable))
	SUBTYPE OF (simple_numeric_expression, variable);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INT_NUMERIC_VARIABLE' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REAL_NUMERIC_VARIABLE' IN TYPEOF(SELF));
END_ENTITY; -- numeric_variable


ENTITY odd_function
	SUBTYPE OF (unary_boolean_expression);
	SELF\unary_generic_expression.operand : numeric_expression;
WHERE
	WR1 :  is_int_expr(SELF \ numeric_expression);
END_ENTITY; -- odd_function


ENTITY or_expression
	SUBTYPE OF (multiple_arity_boolean_expression);
END_ENTITY; -- or_expression


ENTITY plus_expression
	SUBTYPE OF (multiple_arity_numeric_expression);
END_ENTITY; -- plus_expression


ENTITY power_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- power_expression


ENTITY real_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (numeric_defined_function);
END_ENTITY; -- real_defined_function


ENTITY real_literal
	SUBTYPE OF (literal_number);
	SELF\literal_number.the_value : REAL;
END_ENTITY; -- real_literal


ENTITY real_numeric_variable
	SUBTYPE OF (numeric_variable);
END_ENTITY; -- real_numeric_variable


ENTITY simple_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (boolean_literal, boolean_variable))
	SUBTYPE OF (boolean_expression, simple_generic_expression);
END_ENTITY; -- simple_boolean_expression


ENTITY simple_numeric_expression
	ABSTRACT SUPERTYPE OF (ONEOF (literal_number, numeric_variable))
	SUBTYPE OF (numeric_expression, simple_generic_expression);
END_ENTITY; -- simple_numeric_expression


ENTITY simple_string_expression
	ABSTRACT SUPERTYPE OF (ONEOF (string_literal, string_variable))
	SUBTYPE OF (string_expression, simple_generic_expression);
END_ENTITY; -- simple_string_expression


ENTITY sin_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- sin_function


ENTITY slash_expression
	SUBTYPE OF (binary_numeric_expression);
END_ENTITY; -- slash_expression


ENTITY sql_mappable_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function);
END_ENTITY; -- SQL_mappable_defined_function


ENTITY square_root_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- square_root_function


ENTITY string_defined_function
	ABSTRACT SUPERTYPE
	SUBTYPE OF (defined_function, string_expression);
END_ENTITY; -- string_defined_function


ENTITY string_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_string_expression, index_expression, substring_expression, concat_expression, format_function, string_defined_function))
	SUBTYPE OF (expression);
END_ENTITY; -- string_expression


ENTITY string_literal
	SUBTYPE OF (simple_string_expression, generic_literal);
	the_value : STRING;
END_ENTITY; -- string_literal


ENTITY string_variable
	SUBTYPE OF (simple_string_expression, variable);
END_ENTITY; -- string_variable


ENTITY substring_expression
	SUBTYPE OF (string_expression, multiple_arity_generic_expression);
DERIVE
	index1 : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	index2 : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 3 ] ;
	operand : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_EXPRESSION' IN  TYPEOF(operand))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION' IN  TYPEOF(index1))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_EXPRESSION' IN TYPEOF(index2));
	WR2 :  SIZEOF(SELF \ multiple_arity_generic_expression.operands)= 3 ;
	WR3 :  is_int_expr(index1);
	WR4 :  is_int_expr(index2);
END_ENTITY; -- substring_expression


ENTITY tan_function
	SUBTYPE OF (unary_function_call);
END_ENTITY; -- tan_function


ENTITY unary_boolean_expression
	ABSTRACT SUPERTYPE OF (ONEOF (not_expression, odd_function))
	SUBTYPE OF (boolean_expression, unary_generic_expression);
END_ENTITY; -- unary_boolean_expression


ENTITY unary_function_call
	ABSTRACT SUPERTYPE OF (ONEOF (abs_function, minus_function, sin_function, cos_function, tan_function, asin_function, acos_function, exp_function, log_function, log2_function, log10_function, square_root_function))
	SUBTYPE OF (unary_numeric_expression);
END_ENTITY; -- unary_function_call


ENTITY unary_numeric_expression
	ABSTRACT SUPERTYPE OF (unary_function_call)
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : numeric_expression;
END_ENTITY; -- unary_numeric_expression


ENTITY value_function
	SUPERTYPE OF (int_value_function)
	SUBTYPE OF (numeric_expression, unary_generic_expression);
	SELF\unary_generic_expression.operand : string_expression;
END_ENTITY; -- value_function


ENTITY variable
	ABSTRACT SUPERTYPE OF (ONEOF (numeric_variable, boolean_variable, string_variable))
	SUBTYPE OF (generic_variable);
END_ENTITY; -- variable


ENTITY xor_expression
	SUBTYPE OF (binary_boolean_expression);
	SELF\binary_generic_expression.operands : LIST [2:2] OF boolean_expression;
END_ENTITY; -- xor_expression


ENTITY binary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:2] OF generic_expression;
END_ENTITY; -- binary_generic_expression


ENTITY environment;
	syntactic_representation : generic_variable;
	semantics : variable_semantics;
END_ENTITY; -- environment


ENTITY generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression));
WHERE
	WR1 :  is_acyclic(SELF);
END_ENTITY; -- generic_expression


ENTITY generic_literal
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
END_ENTITY; -- generic_literal


ENTITY generic_variable
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation: environment FOR syntactic_representation;
END_ENTITY; -- generic_variable


ENTITY multiple_arity_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:?] OF generic_expression;
END_ENTITY; -- multiple_arity_generic_expression


ENTITY simple_generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (generic_literal, generic_variable))
	SUBTYPE OF (generic_expression);
END_ENTITY; -- simple_generic_expression


ENTITY unary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operand : generic_expression;
END_ENTITY; -- unary_generic_expression


ENTITY variable_semantics
	ABSTRACT SUPERTYPE;
END_ENTITY; -- variable_semantics


ENTITY land
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(i_f.relating_shape_aspect)))= 1 ;
	WR2 :  SIZEOF(QUERY(aud <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'alternate usage definition')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(aud.relating_shape_aspect)))<= 1 ;
	WR3 :  SIZEOF(QUERY(sfi <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'stratum feature implementation')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))= 1 ;
	WR8 : (NOT(SELF  \ shape_aspect.description IN  [ 'component termination passage and  contact size dependent land', 'component termination passage and  contact size dependent' + 'non functional land', 'component termination passage dependent land', 'component termination passage dependent non functional land' ]))OR(SIZEOF(QUERY(rp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'reference passage')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_PASSAGE' IN TYPEOF(rp.relating_shape_aspect))AND(rp.relating_shape_aspect \ shape_aspect.description = 'component termination passage'))))= 1);
	WR9 : (NOT(SELF  \ shape_aspect.description IN  [ 'via and  contact size dependent land', 'via and  contact size dependent non functional land', 'via dependent land', 'via dependent non functional land' ]))OR(SIZEOF(QUERY(rv <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'reference via')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_PASSAGE' IN  TYPEOF(rv.relating_shape_aspect))AND(rv.relating_shape_aspect \ shape_aspect.description IN [ 'buried via', 'interfacial connection', 'bonded conductive base blind via', 'non conductive base blind via', 'plated conductive base blind via' ]))))= 1);
	WR10 : (NOT(SELF  \ shape_aspect.description = 'unsupported passage dependent non functional land'))OR(SIZEOF(QUERY(rp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'reference passage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(rp.relating_shape_aspect))AND(rp.relating_shape_aspect \ shape_aspect.description = 'unsupported passage')))= 1);
	WR11 : (NOT(SELF  \ shape_aspect.description IN  [ 'component termination passage dependent land', 'component termination passage dependent non functional land' ]))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'default component termination passage based'))))= 1);
	WR12 : (NOT(SELF  \ shape_aspect.description IN  [ 'component termination passage and  contact size dependent land', 'component termination passage and  contact size dependent ' + 'non functional land' ]))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'default attachment size and component termination ' + 'passage based'))))= 1);
	WR13 : (NOT(SELF  \ shape_aspect.description IN  [ 'contact size dependent land', 'contact size dependent non functional land' ]))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'default attachment size based'))))= 1);
	WR14 : (NOT(SELF  \ shape_aspect.description IN  [ 'via and  contact size dependent land', 'via and  contact size dependent non functional land' ]))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'default attachment size and via based'))))= 1);
	WR15 : (NOT(SELF  \ shape_aspect.description IN  [ 'via dependent land', 'via dependent non functional land' ]))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'default via based'))))= 1);
	WR16 : (NOT(SELF  \ shape_aspect.description = 'unsupported passage dependent ' + 'non functional land'))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'default unsupported passage based')))= 1);
END_ENTITY; -- land


ENTITY shape_definition_3d_intersection
	SUBTYPE OF (representation, shape_representation_relationship, representation_relationship_with_transformation);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SELF  \ representation_relationship.rep_1 :<>: SELF \ representation_relationship.rep_2 ;
	WR2 : (SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ shape_representation_relationship || SELF  \ representation_relationship_with_transformation || SELF  \ shape_definition_3d_intersection)))= 0)OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_CROSS_SECTION' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRE_DEFINED_PARALLEL_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_AXIS_SYMBOL_3D_2D_RELATIONSHIP' IN  TYPEOF(SELF))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRE_DEFINED_PERPENDICULAR_DATUM_PLANE_SYMBOL_3D_2D_RELATIONSHIP' IN TYPEOF(SELF));
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ITEM_DEFINED_TRANSFORMATION' IN TYPEOF(SELF \ representation_relationship_with_transformation.transformation_operator);
END_ENTITY; -- shape_definition_3d_intersection


ENTITY cutout_edge_segment
	SUPERTYPE OF (plated_cutout_edge_segment)
	SUBTYPE OF (inter_stratum_feature, shape_aspect_relationship);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'plated cutout edge segment', 'cutout edge segment' ] ;
	WR2 :  SIZEOF(QUERY(cc <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed cutout')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE' IN  TYPEOF(cc.relating_shape_aspect))AND(cc.relating_shape_aspect \ shape_aspect.description IN [ 'cutout', 'physical connectivity interrupting cutout', 'plated cutout' ]))))= 1 ;
	WR3 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect));
	WR4 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect));
	WR5 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
END_ENTITY; -- cutout_edge_segment


ENTITY edge_segment_cross_section
	SUBTYPE OF (shape_definition_3d_intersection);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ shape_representation_relationship || SELF  \ shape_definition_3d_intersection || SELF \ edge_segment_cross_section)))= 0 ;
END_ENTITY; -- edge_segment_cross_section


ENTITY inter_stratum_feature_edge_segment_template
	SUBTYPE OF (part_template_definition, shape_aspect_relationship);
WHERE
	WR1 : (SIZEOF(QUERY(ce <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE_EDGE_TEMPLATE' IN TYPEOF(ce.relating_shape_aspect))))= 1);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ part_template_definition || SELF  \ shape_aspect_relationship || SELF \ inter_stratum_feature_edge_segment_template))= 0 ;
END_ENTITY; -- inter_stratum_feature_edge_segment_template


ENTITY inter_stratum_feature_edge_template
	SUBTYPE OF (part_template_definition);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ part_template_definition || SELF \ inter_stratum_feature_edge_template))= 0 ;
	WR2 :  SELF \ shape_aspect.description = 'inter stratum feature edge template' ;
END_ENTITY; -- inter_stratum_feature_edge_template


ENTITY interconnect_module_edge_segment
	SUBTYPE OF (inter_stratum_feature, shape_aspect_relationship);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'plated interconnect module edge segment', 'interconnect module edge segment' ] ;
	WR2 :  SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect))AND(ji.relating_shape_aspect \ shape_aspect.name = 'inter stratum join')))<= 1 ;
	WR3 : (NOT(SELF  \ shape_aspect.description = 'plated interconnect module edge segment'))OR(SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed edge')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect))AND(ce.relating_shape_aspect \ shape_aspect.description = 'plated interconnect module edge')))= 1);
	WR4 : (NOT(SELF  \ shape_aspect.description = 'interconnect module edge segment'))OR(SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed edge')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect))AND(ce.relating_shape_aspect \ shape_aspect.description = 'interconnect module edge')))= 1);
	WR5 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR6 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR7 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
END_ENTITY; -- interconnect_module_edge_segment


ENTITY plated_cutout_edge_segment
	SUBTYPE OF (cutout_edge_segment, plated_inter_stratum_feature);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'plated cutout edge segment' ] ;
	WR2 :  SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect))AND(ji.relating_shape_aspect \ shape_aspect.name = 'inter stratum join')))<= 1 ;
	WR3 : (NOT(SELF  \ shape_aspect.description = 'plated cutout edge segment'))OR(SIZEOF(QUERY(cc <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed cutout')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect))AND(cc.relating_shape_aspect \ shape_aspect.description = 'plated cutout')))= 1);
END_ENTITY; -- plated_cutout_edge_segment


ENTITY plated_interconnect_module_edge_segment
	SUBTYPE OF (interconnect_module_edge_segment, plated_inter_stratum_feature);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'plated interconnect module edge segment' ] ;
	WR2 :  SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect))AND(ji.relating_shape_aspect \ shape_aspect.name = 'inter stratum join')))<= 1 ;
	WR3 : (NOT(SELF  \ shape_aspect.description = 'plated interconnect module edge segment'))OR(SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed edge')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect))AND(ce.relating_shape_aspect \ shape_aspect.description = 'plated interconnect module edge')))= 1);
END_ENTITY; -- plated_interconnect_module_edge_segment


ENTITY conductive_interconnect_element_terminal_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ conductive_interconnect_element_terminal_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF \ shape_aspect.of_shape.definition);
	WR8 :  SELF \ shape_aspect_relationship.related_shape_aspect.description = 'conductive interconnect element terminal' ;
	WR9 :  SELF \ shape_aspect_relationship.relating_shape_aspect.description = 'conductive interconnect element terminal' ;
	WR10 :  SELF \ shape_aspect.of_shape.definition \ product_definition.description = 'laminate component' ;
END_ENTITY; -- conductive_interconnect_element_terminal_link


ENTITY connected_area_component
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sfi <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'stratum feature implementation')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect)))= 1 ;
	WR2 :  SIZEOF(QUERY(sfi <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated layer connection point')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sfi.relating_shape_aspect)))>= 1 ;
	WR3 :  SELF \ shape_aspect.description = 'stratum feature template component' ;
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ component_shape_aspect || SELF \ connected_area_component))= 0 ;
END_ENTITY; -- connected_area_component


ENTITY electrical_isolation_component_shape_aspect
	SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
END_ENTITY; -- electrical_isolation_component_shape_aspect


ENTITY fiducial
	SUBTYPE OF (component_shape_aspect);
WHERE
	wr1 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION')IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.description = 'laminate component');
END_ENTITY; -- fiducial


ENTITY fiducial_stratum_feature
	SUBTYPE OF (stratum_feature);
END_ENTITY; -- fiducial_stratum_feature


ENTITY filled_area_material_removal_component_shape_aspect
	SUBTYPE OF (material_removal_component_shape_aspect);
END_ENTITY; -- filled_area_material_removal_component_shape_aspect


ENTITY footprint_occurrence
	SUBTYPE OF (assembly_group_component_definition);
END_ENTITY; -- footprint_occurrence


ENTITY footprint_occurrence_product_definition_relationship
	SUBTYPE OF (product_definition_relationship);
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 :  SELF \ product_definition_relationship.name = 'footprint occurrence sub assembly relationship' ;
END_ENTITY; -- footprint_occurrence_product_definition_relationship


ENTITY inter_stratum_feature
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'bonded conductive base blind via', 'buried via', 'component termination passage', 'interfacial connection', 'non conductive base blind via', 'plated conductive base blind via', 'plated cutout', 'partially plated cutout', 'plated cutout edge segment', 'partially plated interconnect module edge', 'plated interconnect module edge segment', 'plated interconnect module edge', 'unsupported passage', 'cutout', 'physical connectivity interrupting cutout', 'dielectric material passage', 'cutout edge segment', 'interconnect module edge segment', 'interconnect module edge' ] ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'feature of size')AND(it \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1)))= 1 ;
	WR3 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN  TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description IN [ 'inter stratum feature template', 'via template', 'component termination passage template', 'unsupported passage template' ])))= 1 ;
	WR4 : (NOT(SELF  \ shape_aspect.description = 'cutout edge segment'))OR(SIZEOF(QUERY(cc <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed cutout')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(cc.relating_shape_aspect))AND((cc.relating_shape_aspect \ shape_aspect.description = 'cutout')OR(cc.relating_shape_aspect \ shape_aspect.description = 'physical connectivity interrupting cutout')OR(cc.relating_shape_aspect \ shape_aspect.description = 'partially plated cutout'))))= 1);
	WR5 : (NOT(SELF  \ shape_aspect.description = 'interconnect module edge segment'))OR(SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed edge')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(ce.relating_shape_aspect))AND((ce.relating_shape_aspect \ shape_aspect.description = 'interconnect module edge')OR(ce.relating_shape_aspect \ shape_aspect.description = 'interconnect module edge'))))= 1);
	WR6 : (NOT(SELF  \ shape_aspect.description = 'dielectric material passage'))OR(SIZEOF(QUERY(pp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent passage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE' IN TYPEOF(pp.relating_shape_aspect))AND((pp.relating_shape_aspect \ shape_aspect.description = 'cutout')OR(pp.relating_shape_aspect \ shape_aspect.description = 'physical connectivity interrupting cutout')OR(pp.relating_shape_aspect \ shape_aspect.description = 'partially plated cutout'))))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'dielectric material passage'))OR((SIZEOF(QUERY(rp <* QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd))| rp \ property_definition.name = 'feature material'))<= 1)OR(SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))<= 1));
	WR8 : (NOT(SELF  \ shape_aspect.description = 'physical connectivity interrupting cutout'))OR(SIZEOF(QUERY(ice <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'interrupted connectivity elements')| ice.relating_shape_aspect \ shape_aspect.name = 'conductive interconnect element'))>= 1);
	WR9 : (NOT(SELF  \ shape_aspect.description = 'unsupported passage'))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'unsupported passage template')))= 1);
	WR10 : (NOT(SELF  \ shape_aspect.description = 'cutout edge segment'))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))= 1);
	WR11 : (NOT(SELF  \ shape_aspect.description = 'plated cutout edge segment'))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))= 1);
	WR12 : (NOT(SELF  \ shape_aspect.description = 'interconnect module edge segment'))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))= 1);
	WR13 : (NOT(SELF  \ shape_aspect.description = 'plated interconnect module edge segment'))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE_EDGE_SEGMENT_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))= 1);
END_ENTITY; -- inter_stratum_feature


ENTITY interconnect_module_join_terminal
	SUBTYPE OF (interconnect_module_terminal);
END_ENTITY; -- interconnect_module_join_terminal


ENTITY interface_access_component_shape_aspect
	SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- interface_access_component_shape_aspect


ENTITY interface_access_material_removal_component_shape_aspect
	SUBTYPE OF (material_removal_component_shape_aspect);
END_ENTITY; -- interface_access_material_removal_component_shape_aspect


ENTITY internal_probe_access_area
	SUBTYPE OF (probe_access_area);
END_ENTITY; -- internal_probe_access_area


ENTITY join_shape_aspect
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  NOT(SELF  \ shape_aspect.name IN  [ 'constrained intra layer join', 'inter stratum join', 'intra stratum join' ])OR(SIZEOF(QUERY(cp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connected point')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(cp.related_shape_aspect)))>= 2);
	WR2 :  SIZEOF(QUERY(nt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'network topology')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_NETWORK' IN TYPEOF(nt.relating_shape_aspect)))= 1 ;
	WR3 : (NOT(SELF  \ shape_aspect.name = 'intra stratum join'))OR(SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect))AND(ji.related_shape_aspect \ shape_aspect.description = 'conductor')))<= 1);
	WR4 : (NOT(SELF  \ shape_aspect.name = 'intra stratum join'))OR(SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect))AND(ji.related_shape_aspect \ shape_aspect.description = 'connected filled area')))<= 1);
	WR5 : (NOT(SELF  \ shape_aspect.name = 'inter stratum join'))OR(SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_CONCEPT_RELATIONSHIP' IN  TYPEOF(ji.related_shape_aspect))AND(ji.related_shape_aspect \ shape_aspect.description = 'physical network supporting stratum feature conductive join'))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_INTER_STRATUM_FEATURE' IN TYPEOF(ji.related_shape_aspect))))<= 1);
	WR6 :  NOT(SELF  \ shape_aspect.name = 'unrouted join')OR(SIZEOF(QUERY(cp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'unrouted terminals')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(cp.related_shape_aspect)))>= 2);
END_ENTITY; -- join_shape_aspect


ENTITY laminate_component_interface_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : (NOT(SELF  \ shape_aspect.description IN  [ 'component termination passage interface terminal', 'land interface terminal', 'printed connector component interface terminal', 'non functional land interface terminal' ]))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition));
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature'))= 1 ;
	WR4 : (NOT(SELF  \ shape_aspect.description = 'component termination passage interface terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')| i_f.relating_shape_aspect \ shape_aspect.description = 'component termination passage template interface terminal'))= 1);
	WR5 : (NOT(SELF  \ shape_aspect.description IN  [ 'land interface terminal', 'non functional land interface terminal' ]))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(TRUE))))= 1);
	WR8 : (NOT(SELF  \ shape_aspect.description = 'printed connector component interface terminal'))OR(SELF.product_definitional);
	WR9 : (NOT(SELF  \ shape_aspect.description = 'printed connector component interface terminal'))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_COMPONENT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.description = 'printed connector component'));
	WR10 : (NOT(SELF  \ shape_aspect.description = 'printed connector component interface terminal'))OR(SIZEOF(QUERY(i_f <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated feature')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(i_f.relating_shape_aspect))AND(i_f.relating_shape_aspect \ shape_aspect.description = 'interface terminal')))= 1);
	WR11 : (NOT(SELF  \ shape_aspect.description = 'printed connector component interface terminal'))OR(SIZEOF(QUERY(i <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| pdr \ shape_aspect_relationship.name = 'implementation')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' ] * TYPEOF(i.relating_shape_aspect))= 1)))= 1);
	WR12 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference \ application_context_element.name = 'layout occurrence');
END_ENTITY; -- laminate_component_interface_terminal


ENTITY laminate_group_component_make_from_relationship
	SUBTYPE OF (make_from_usage_option);
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' ] * TYPEOF(SELF.relating_product_definition))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' ] * TYPEOF(SELF.related_product_definition))= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|((pdr.name = 'stratum mapping')AND(pdr.related_property_definition \ property_definition.definition \ product_definition_relationship.name = 'stratum make from')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAKE_FROM_USAGE_OPTION' IN TYPEOF(pdr.related_property_definition \ property_definition.definition)))))> 0)))> 0 ;
END_ENTITY; -- laminate_group_component_make_from_relationship


ENTITY layer
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| SIZEOF(QUERY(duc <* USEDIN(ada.assigned_document, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| duc \ document_usage_constraint.subject_element = 'layer definition'))= 1))<= 1 ;
	WR2 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition_relationship.name = 'inter stratum extent');
END_ENTITY; -- layer


ENTITY layer_connection_point
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name, of_shape;
WHERE
	WR1 :  SELF \ shape_aspect.of_shape.definition \ product_definition.name = 'design layer' ;
	WR2 :  SIZEOF(QUERY(cp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connected point')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect))AND(cp.relating_shape_aspect.name = 'inter stratum join'))))<= 1 ;
	WR3 :  SIZEOF(QUERY(cp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connected point')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect))AND(cp.relating_shape_aspect.name = 'intra stratum join'))))= 1 ;
	WR4 :  NOT(SIZEOF(QUERY(cp <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connected point')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN  TYPEOF(cp.relating_shape_aspect))AND(cp.relating_shape_aspect.name = 'inter stratum join'))))= 1)OR(SIZEOF(QUERY(cp <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connected point')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(cp.relating_shape_aspect))AND(cp.relating_shape_aspect.name = 'intra stratum join'))))= 1);
	WR5 : (NOT(SELF  \ shape_aspect.description = 'dependently located'))OR(SIZEOF(QUERY(ado <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated design object')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL' ] * TYPEOF(ado.relating_shape_aspect))= 1)OR((SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' ] * TYPEOF(ado.relating_shape_aspect))= 1)AND(ado.relating_shape_aspect.description IN [ 'printed component join terminal', 'embedded component terminal' ]))))= 1);
	WR6 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'connection point location 2d')AND(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_POINT' IN TYPEOF(it))AND(it \ geometric_representation_item.dim = 2)))= 1)))<= 1)))= 0);
	WR7 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'connection point location 3d')AND(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_POINT' IN TYPEOF(it))AND(it \ geometric_representation_item.dim = 3)))= 1)))<= 1)))= 0);
	WR8 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))AND((pdr.used_representation \ representation.name = 'connection point location 2d')OR(pdr.used_representation \ representation.name = 'connection point location 3d'))))>= 1)))= 0);
	WR9 : (NOT(SELF  \ shape_aspect.description = 'dependently located'))OR(SIZEOF(QUERY(ado <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'reference zone')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' ] * TYPEOF(ado.relating_shape_aspect))= 1)OR((SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' ] * TYPEOF(ado.relating_shape_aspect))= 1)AND(ado.relating_shape_aspect.description IN [ 'connection zone' ]))))<= 1);
END_ENTITY; -- layer_connection_point


ENTITY layout_junction
	SUBTYPE OF (shape_aspect);
END_ENTITY; -- layout_junction


ENTITY material_removal_component_shape_aspect
	SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- material_removal_component_shape_aspect


ENTITY multi_layer_component_shape_aspect
	SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- multi_layer_component_shape_aspect


ENTITY multi_layer_material_removal_component_shape_aspect
	SUBTYPE OF (material_removal_component_shape_aspect);
END_ENTITY; -- multi_layer_material_removal_component_shape_aspect


ENTITY multi_layer_stratum_feature
	SUBTYPE OF (stratum_feature);
END_ENTITY; -- multi_layer_stratum_feature


ENTITY padstack_occurrence
	SUBTYPE OF (assembly_group_component_definition);
END_ENTITY; -- padstack_occurrence


ENTITY padstack_occurrence_product_definition_relationship
	SUBTYPE OF (property_definition, product_definition_relationship);
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 :  SIZEOF(TYPEOF(SELF))- SIZEOF(TYPEOF(SELF  \ property_definition || SELF  \ product_definition_relationship || SELF \ padstack_occurrence_product_definition_relationship))= 0 ;
	WR3 :  SELF \ product_definition_relationship.name = 'padstack occurrence sub assembly relationship' ;
END_ENTITY; -- padstack_occurrence_product_definition_relationship


ENTITY passage_padstack_definition
	SUBTYPE OF (padstack_definition);
END_ENTITY; -- passage_padstack_definition


ENTITY passage_technology
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name, of_shape;
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))<= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation'))= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT({ 1 <= SIZEOF(pcr.used_representation.items)<= 8 })))= 0)))= 0 ;
	WR5 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items | NOT(it \ representation_item.name IN [ 'maximum aspect ratio', 'plated passage', 'maximum allowed component terminal extent', 'minimum allowed component terminal extent', 'maximum as  finished deposition thickness', 'minimum as  finished deposition thickness', 'maximum as  finished passage extent', 'minimum as finished passage extent' ])))= 0)))= 0)))= 0 ;
	WR6 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RATIO_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum aspect ratio')AND(it \ measure_with_unit.value_component > 1.0)))<= 1)))= 0)))= 0 ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'plated passage')AND(it \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1)))= 0)))= 0 ;
	WR8 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum as finished passage extent')))<= 1)))= 0)))= 0 ;
	WR9 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum as finished deposition thickness')))<= 1)))= 0)))= 0 ;
	WR10 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum as finished deposition thickness')))<= 1)))= 0)))= 0 ;
	WR11 : (NOT(SELF  \ shape_aspect.description IN [ 'default component termination passage definition', 'default via definition' ]))OR(SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1);
	WR12 : (NOT(SELF  \ shape_aspect.description IN [ 'default component termination passage definition', 'default unsupported passage definition', 'default via definition' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum as finished passage extent')))= 1)))= 0)))= 0);
	WR13 : (NOT(SELF  \ shape_aspect.description = 'default component termination passage definition'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum as finished deposition thickness')))= 1)))= 0)))= 0);
	WR14 : (NOT(SELF  \ shape_aspect.description = 'default component termination passage definition'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum allowed component terminal extent')))= 1)))= 0)))= 0);
	WR15 : (NOT(SELF  \ shape_aspect.description = 'default component termination passage definition'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum allowed component terminal extent')))= 1)))= 0)))= 0);
	WR16 : (NOT(SELF  \ shape_aspect.description = 'default via definition'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum as finished deposition thickness')))= 1)))= 0)))= 0);
	WR17 :  SIZEOF(QUERY(rpt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'as finished inter stratum extent')|(rpt.related_shape_aspect.of_shape \ property_definition.description = 'finished stratum extent')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(rpt.related_shape_aspect.of_shape \ property_definition.definition))AND(rpt.related_shape_aspect.of_shape \ property_definition.definition \ product_definition_relationship.name = 'inter stratum extent'))))= 1 ;
END_ENTITY; -- passage_technology


ENTITY physical_network
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(cr <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'connectivity requirement')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(cr.related_shape_aspect))AND((cr.related_shape_aspect \ shape_aspect.description = 'component termination passage join terminal')OR(cr.related_shape_aspect \ shape_aspect.description = 'land join terminal')OR(cr.related_shape_aspect \ shape_aspect.description = 'non functional land join terminal')OR(cr.related_shape_aspect \ shape_aspect.description = 'printed component join terminal'))))>= 2 ;
	WR2 :  SIZEOF(QUERY(nt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'network topology')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(nt.related_shape_aspect)))>= 1 ;
	WR3 :  SIZEOF(QUERY(nt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'reference connected terminals')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(nt.relating_shape_aspect)))<= 1 ;
END_ENTITY; -- physical_network


ENTITY plated_inter_stratum_feature
	SUPERTYPE OF (plated_passage)
	SUBTYPE OF (inter_stratum_feature);
WHERE
	WR1 : (SELF  \ shape_aspect.description IN [ 'bonded conductive base blind via', 'buried via', 'component termination passage', 'interfacial connection', 'non conductive base blind via', 'join two physical connectivity definition supporting inter stratum feature', 'plated conductive base blind via', 'plated cutout', 'plated interconnect module edge' ])OR(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_CUTOUT_EDGE_SEGMENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_INTERCONNECT_MODULE_EDGE_SEGMENT' ] * TYPEOF(SELF))= 1);
	WR2 :  SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect))AND(ji.relating_shape_aspect \ shape_aspect.name = 'inter stratum join')))<= 1 ;
END_ENTITY; -- plated_inter_stratum_feature


ENTITY plated_passage
	SUBTYPE OF (plated_inter_stratum_feature);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'bonded conductive base blind via', 'buried via', 'component termination passage', 'interfacial connection', 'non conductive base blind via', 'plated conductive base blind via' ] ;
	WR2 : (NOT(SELF  \ shape_aspect.description = 'bonded conductive base blind via'))OR(SIZEOF(QUERY(fj <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'features join')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_CONCEPT_RELATIONSHIP' IN TYPEOF(fj.relating_shape_aspect))AND(fj.relating_shape_aspect \ shape_aspect.name = 'stratum feature conductive join')))= 1);
	WR3 : (NOT(SELF  \ shape_aspect.description = 'component termination passage'))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'component termination passage template')))= 1);
	WR6 : (NOT(SELF  \ shape_aspect.description IN  [ 'bonded conductive base blind via', 'buried via', 'interfacial connection', 'non conductive base blind via', 'plated conductive base blind via' ]))OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'via template')))= 1);
END_ENTITY; -- plated_passage


ENTITY probe_access_area
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 :  EXISTS(SELF.of_shape.definition \ product_definition.name);
	WR2 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.name = 'interconnect module');
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))= 1 ;
	WR4 :  SIZEOF(QUERY(pli <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'probed layout item')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(pli.related_shape_aspect)))= 1 ;
	WR5 : (NOT(SELF  \ shape_aspect.description = 'internal probe access area'))OR(SIZEOF(QUERY(i <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(i.relating_shape_aspect))))= 1);
END_ENTITY; -- probe_access_area


ENTITY stratum
	SUBTYPE OF (product_definition);
UNIQUE
	UR1 : id, formation;
WHERE
	WR1 :  EXISTS(SELF \ product_definition.name);
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))= 1))= 1 ;
	WR3 : (SIZEOF(QUERY(ada <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| SIZEOF(QUERY(duc <* USEDIN(ada.assigned_document, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| duc \ document_usage_constraint.subject_element = 'attachment region size'))= 1))<= 1)OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'stratum usage')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNAL_DEFINITION' IN TYPEOF(tu.relating_property_definition)))= 1))<= 1);
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = '3d bound volume shape'))<= 1)))= 0 ;
	WR5 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = 'planar projected shape'))<= 1)))= 0 ;
	WR6 :  SIZEOF(QUERY(acu <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(pdr))| acu \ product_definition_relationship.name = 'interconnect module stratum assembly relationship'))>= 1 ;
	WR7 :  NOT(SELF  \ product_definition.name = 'design layer')OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition))AND(tu.relating_property_definition.definition \ characterized_object.description = 'design layer')))= 1))= 1);
	WR8 :  NOT(SELF  \ product_definition.name = 'design layer')OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER_CONNECTION_POINT' IN TYPEOF(sa)))>= 1))>= 1);
	WR9 :  NOT(SELF  \ product_definition.name = 'documentation layer')OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition))AND(tu.relating_property_definition.definition \ characterized_object.description = 'documentation layer')))= 1))= 1);
	WR10 :  NOT(SELF  \ product_definition.name = 'design layer')OR((NOT(SELF  \ product_definition.description = 'primary design layer stratum')OR(SIZEOF(QUERY(imps <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(imps, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module primary surface')))>= 0))>= 0))= 1))OR(NOT(SELF  \ product_definition.description = 'non primary design layer stratum')OR(SIZEOF(QUERY(imps <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(imps, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module primary surface')))>= 0))>= 0))= 0)));
END_ENTITY; -- stratum


ENTITY stratum_concept_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))= 1))= 1 ;
	WR3 : (NOT(SELF  \ shape_aspect_relationship.name = 'dielectric crossover area'))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN  TYPEOF(SELF.relating_shape_aspect))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(SELF.related_shape_aspect)));
	WR4 : (NOT(SELF  \ shape_aspect_relationship.name = 'dielectric crossover area'))OR(SIZEOF(QUERY(rdc <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'resulting dielectric crossover')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(rdc.relating_shape_aspect))))= 1);
	WR5 : (NOT(SELF  \ shape_aspect_relationship.name = 'stratum feature conductive join'))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND' IN  TYPEOF(SELF.relating_shape_aspect))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.relating_shape_aspect))AND(SELF.relating_shape_aspect \ shape_aspect.description = 'stratum feature template component')));
	WR6 : (NOT(SELF  \ shape_aspect_relationship.name = 'stratum feature conductive join'))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND' IN  TYPEOF(SELF.related_shape_aspect))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(SELF.related_shape_aspect))AND(SELF.related_shape_aspect \ shape_aspect.description = 'stratum feature template component')));
	WR7 : (NOT(SELF  \ shape_aspect_relationship.name = 'stratum feature conductive join'))OR(SIZEOF(QUERY(fj <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'features join')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLATED_PASSAGE' IN TYPEOF(fj.related_shape_aspect))AND(fj.related_shape_aspect \ shape_aspect.description = 'bonded conductive base blind via')))<= 1);
	WR8 : (NOT((SELF  \ shape_aspect.description = 'physical network supporting stratum feature conductive join')AND(SELF  \ shape_aspect_relationship.name = 'stratum feature conductive join')))OR(SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect))AND(ji.relating_shape_aspect \ shape_aspect.name = 'inter stratum join')))= 1);
END_ENTITY; -- stratum_concept_relationship


ENTITY stratum_feature
	SUPERTYPE OF (fiducial_stratum_feature)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'feature of size')AND(it \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1)))= 0 ;
	WR3 : (NOT(EXISTS(SELF  \ shape_aspect.description)))OR(NOT(SELF  \ shape_aspect.description = 'conductor')OR(SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect))AND(ji.relating_shape_aspect \ shape_aspect.name = 'intra stratum join')))= 1));
	WR4 : (NOT(EXISTS(SELF  \ shape_aspect.description)))OR(NOT(SELF  \ shape_aspect.description = 'connected filled area')OR(SIZEOF(QUERY(ji <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'join implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(ji.relating_shape_aspect))AND(ji.relating_shape_aspect \ shape_aspect.name = 'intra stratum join')))= 1));
	WR5 : (NOT(EXISTS(SELF  \ shape_aspect.description)))OR(NOT(SELF  \ shape_aspect.description = 'conductor')OR(SELF \ shape_aspect.of_shape.definition.name = 'design layer'));
	WR6 : (NOT(EXISTS(SELF  \ shape_aspect.description)))OR(NOT(SELF  \ shape_aspect.description = 'connected filled area')OR(SELF \ shape_aspect.of_shape.definition.name = 'design layer'));
END_ENTITY; -- stratum_feature


ENTITY stratum_specific_part_template_location_in_padstack_definition
	SUBTYPE OF (assembly_component_usage, property_definition);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ assembly_component_usage || SELF  \ product_definition_usage || SELF  \ product_definition_relationship || SELF  \ stratum_specific_part_template_location_in_padstack_definition || SELF \ property_definition))= 0 ;
	WR2 :  SELF \ property_definition.name = '' ;
	WR3 :  SELF \ property_definition.description = '' ;
	WR4 :  SELF \ product_definition_relationship.name = 'part template location in padstack definition' ;
	WR5 :  SELF \ product_definition_relationship.description = '' ;
END_ENTITY; -- stratum_specific_part_template_location_in_padstack_definition


ENTITY stratum_surface
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'primary surface', 'secondary surface', 'average surface' ] ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN TYPEOF(SELF \ shape_aspect.of_shape.definition);
END_ENTITY; -- stratum_surface


ENTITY thermal_isolation_component_shape_aspect
	SUBTYPE OF (filled_area_material_removal_component_shape_aspect);
END_ENTITY; -- thermal_isolation_component_shape_aspect


ENTITY shape_modification
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(dim <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design intent')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(dim.relating_shape_aspect)))= 1 ;
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN  TYPEOF(pd))AND(pd \ property_definition.description = 'modification causal')))= 1)OR(SIZEOF(QUERY(mcf <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'modification causal feature')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' ] * TYPEOF(mcf.relating_shape_aspect))= 1)OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN TYPEOF(mcf.relating_shape_aspect.of_shape.definition))))= 1);
	WR3 : (NOT(SELF  \ shape_aspect.description IN  [ 'electrical isolation removal', 'thermal isolation removal' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'spacing requirement')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'spacing requirement')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition))))= 1)))= 1);
	WR4 : (NOT(SELF  \ shape_aspect.description IN  [ 'electrical isolation removal', 'thermal isolation removal' ]))OR(SIZEOF(QUERY(di <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'design intent')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN  TYPEOF(di.relating_shape_aspect))AND(di.relating_shape_aspect \ shape_aspect.description IN [ 'conductive filled area', 'connected filled area' ])))= 1);
	WR5 : (NOT(SELF  \ shape_aspect.description = 'thermal isolation removal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd))AND(pd \ property_definition.description = 'angular orientation requirement')))= 1);
	WR6 : (NOT(SELF  \ shape_aspect.description = 'thermal isolation removal'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pd))AND(pd \ property_definition.description = 'effective current capacity requirement')))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'material addition feature'))OR(SIZEOF(QUERY(dim <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material addition shape')|(dim.relating_shape_aspect \ shape_aspect.description = 'material addition feature template')))= 1);
END_ENTITY; -- shape_modification


ENTITY printed_component
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'layout occurrence' ;
	WR2 :  SELF \ product_definition.description = 'printed component' ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pt_occ <* QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| sa \ shape_aspect.description = 'part template occurrence')| SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(pt_occ, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN  TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description IN [ 'printed part template', 'printed part cross section template', 'printed connector template' ])))= 1))= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'printed component join terminal')))>= 1)))= 0 ;
	WR5 : (NOT(SELF  \ product_definition.description = 'printed connector component'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAMINATE_COMPONENT_INTERFACE_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'printed connector component interface terminal')))>= 1)))= 0);
	WR6 : (NOT(SELF  \ product_definition.description = 'printed connector component'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pt_occ <* QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| sa \ shape_aspect.description = 'part template occurrence')| SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(pt_occ, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'printed connector template')))= 1))= 1)))= 0);
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))AND(sar \ shape_aspect_relationship.name = 'stratum feature implementation')AND(sar.relating_shape_aspect.description = 'stratum feature template component'))))>= 1))>= 1))>= 1 ;
END_ENTITY; -- printed_component


ENTITY printed_component_link
	SUBTYPE OF (product_definition, product_definition_relationship);
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.related_product_definition);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.relating_product_definition);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF  \ product_definition_relationship || SELF \ printed_component_link))= 0 ;
	WR5 :  EXISTS(SELF \ product_definition.name);
	WR6 :  SELF \ product_definition.name = '' ;
	WR7 :  SELF \ product_definition_relationship.name = '' ;
	WR8 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))= 1 ;
END_ENTITY; -- printed_component_link


ENTITY routed_printed_component
	SUBTYPE OF (printed_component);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'printed part cross section template')AND(sar \ shape_aspect_relationship.name = 'instantiated template')))= 1)))= 1)))= 1 ;
	WR2 :  SIZEOF(QUERY(csa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN  TYPEOF(csa))AND(SIZEOF(QUERY(sar <* USEDIN(csa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(SIZEOF(QUERY(pdr <* USEDIN(sar, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(pdr))AND(pdr \ product_definition_relationship.name = 'inter stratum extent')))= 1)AND(sar \ shape_aspect_relationship.name = 'component extent')))= 1)))= 1 ;
END_ENTITY; -- routed_printed_component


ENTITY shape_item_relationship
	SUBTYPE OF (representation_item, representation_item_relationship);
UNIQUE
	UR1 : relating_representation_item, related_representation_item;
WHERE
	WR1 :  SELF  \ representation_item_relationship.relating_representation_item :<>: SELF \ representation_item_relationship.related_representation_item ;
	WR2 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation_item || SELF  \ representation_item_relationship || SELF \ shape_item_relationship)))= 0 ;
END_ENTITY; -- shape_item_relationship


ENTITY layout_macro_component
	SUBTYPE OF (printed_component);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pt_occ <* QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| sa \ shape_aspect.description = 'layout macro component shape aspect')| SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(pt_occ, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))= 1))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design definition')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYOUT_MACRO_DEFINITION' ] * TYPEOF(ip.relating_product_definition))= 1)))= 1 ;
	WR3 :  SELF \ product_definition.description <> 'printed connector component' ;
END_ENTITY; -- layout_macro_component


ENTITY layout_macro_definition
	SUBTYPE OF (interconnect_definition);
WHERE
	WR1 :  EXISTS(SELF \ product_definition.name);
	WR2 :  SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_INTERCONNECT_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_INTERCONNECT_DEFINITION' ] * TYPEOF(du.relating_product_definition))= 1)AND(du.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(du.relating_product_definition \ product_definition.name = 'interconnect module')))= 0 ;
	WR3 :  SELF.frame_of_reference \ application_context_element.name = 'physical design' ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pt_occ <* QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| sa \ shape_aspect.description = 'layout macro definition shape aspect')| SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(pt_occ, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'floor layout view')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYOUT_MACRO_FLOOR_PLAN_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))= 1))= 1)))= 0 ;
END_ENTITY; -- layout_macro_definition


ENTITY layout_macro_definition_terminal_to_usage_terminal_assignment
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect_relationship || SELF  \ layout_macro_definition_terminal_to_usage_terminal_assignment || SELF \ shape_aspect))= 0 ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR3 :  SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description IN [ 'component termination passage join terminal', 'conductive interconnect element terminal', 'land join terminal', 'non functional land join terminal', 'printed component join terminal', 'via terminal' ] ;
	WR4 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT'))<= 1 ;
END_ENTITY; -- layout_macro_definition_terminal_to_usage_terminal_assignment


ENTITY layout_macro_floor_plan_template
	SUBTYPE OF (part_template_definition);
WHERE
	WR1 :  NOT(SELF \ shape_aspect.description IN [ 'component termination passage template', 'component termination passage template', 'default trace template', 'inter stratum feature template', 'printed connector template', 'printed part cross section template', 'printed part template', 'trace template', 'unsupported passage template', 'via template', 'non conductive cross section template' ]);
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'access maps')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYOUT_MACRO_DEFINITION_TERMINAL_TO_USAGE_TERMINAL_ASSIGNMENT' IN TYPEOF(sar.relating_shape_aspect)))))>= 1 ;
END_ENTITY; -- layout_macro_floor_plan_template


ENTITY location;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location


ENTITY location_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_location : location;
	related_location : location;
END_ENTITY; -- location_relationship


ENTITY action_assignment
	ABSTRACT SUPERTYPE;
	assigned_action : action;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- action_assignment


ENTITY action_method_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_method : action_method;
	role : action_method_role;
END_ENTITY; -- action_method_assignment


ENTITY action_method_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- action_method_role


ENTITY action_request_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_request : versioned_action_request;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- action_request_assignment


ENTITY approval_assignment
	ABSTRACT SUPERTYPE;
	assigned_approval : approval;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- approval_assignment


ENTITY attribute_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	attribute_name : label;
	role : classification_role;
END_ENTITY; -- attribute_classification_assignment


ENTITY attribute_value_assignment
	ABSTRACT SUPERTYPE;
	attribute_name : label;
	attribute_value : attribute_type;
	role : attribute_value_role;
END_ENTITY; -- attribute_value_assignment


ENTITY attribute_value_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- attribute_value_role


ENTITY certification_assignment
	ABSTRACT SUPERTYPE;
	assigned_certification : certification;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- certification_assignment


ENTITY classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	role : classification_role;
END_ENTITY; -- classification_assignment


ENTITY classification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- classification_role


ENTITY contract_assignment
	ABSTRACT SUPERTYPE;
	assigned_contract : contract;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- contract_assignment


ENTITY date_and_time_assignment
	ABSTRACT SUPERTYPE;
	assigned_date_and_time : date_and_time;
	role : date_time_role;
END_ENTITY; -- date_and_time_assignment


ENTITY date_assignment
	ABSTRACT SUPERTYPE;
	assigned_date : date;
	role : date_role;
END_ENTITY; -- date_assignment


ENTITY document_reference
	ABSTRACT SUPERTYPE;
	assigned_document : document;
	source : label;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- document_reference


ENTITY document_usage_constraint_assignment
	ABSTRACT SUPERTYPE;
	assigned_document_usage : document_usage_constraint;
	role : document_usage_role;
END_ENTITY; -- document_usage_constraint_assignment


ENTITY document_usage_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- document_usage_role


ENTITY effectivity_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity : effectivity;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- effectivity_assignment


ENTITY effectivity_context_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity_assignment : effectivity_assignment;
	role : effectivity_context_role;
END_ENTITY; -- effectivity_context_assignment


ENTITY effectivity_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- effectivity_context_role


ENTITY event_occurrence_assignment
	ABSTRACT SUPERTYPE;
	assigned_event_occurrence : event_occurrence;
	role : event_occurrence_role;
END_ENTITY; -- event_occurrence_assignment


ENTITY event_occurrence_context_assignment
	ABSTRACT SUPERTYPE;
	assigned_event_occurrence_assignment : event_occurrence_assignment;
	role : event_occurrence_context_role;
END_ENTITY; -- event_occurrence_context_assignment


ENTITY experience_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_experience : experience;
	role : experience_role;
END_ENTITY; -- experience_assignment


ENTITY experience_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_role


ENTITY experience_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_experience_type : experience_type;
	role : experience_type_role;
END_ENTITY; -- experience_type_assignment


ENTITY experience_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_type_role


ENTITY external_identification_assignment
	ABSTRACT SUPERTYPE
	SUBTYPE OF (identification_assignment);
	source : external_source;
END_ENTITY; -- external_identification_assignment


ENTITY external_referent_assignment
	ABSTRACT SUPERTYPE;
	assigned_name : label;
DERIVE
	role : object_role :=  get_role(SELF);
UNIQUE
	UR1 : assigned_name;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- external_referent_assignment


ENTITY group_assignment
	ABSTRACT SUPERTYPE;
	assigned_group : group;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- group_assignment


ENTITY identification_assignment
	ABSTRACT SUPERTYPE;
	assigned_id : identifier;
	role : identification_role;
END_ENTITY; -- identification_assignment


ENTITY identification_assignment_relationship;
	name : label;
	description : OPTIONAL text;
	relating_identification_assignment : identification_assignment;
	related_identification_assignment : identification_assignment;
END_ENTITY; -- identification_assignment_relationship


ENTITY identification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- identification_role


ENTITY library_assignment
	ABSTRACT SUPERTYPE
	SUBTYPE OF (external_referent_assignment);
	frame_of_reference : library_context;
UNIQUE
	UR1 : frame_of_reference;
END_ENTITY; -- library_assignment


ENTITY location_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_location : location;
	role : location_role;
END_ENTITY; -- location_assignment


ENTITY location_representation_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	represented_location : location;
	role : location_representation_role;
END_ENTITY; -- location_representation_assignment


ENTITY location_representation_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location_representation_role


ENTITY location_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location_role


ENTITY name_assignment
	ABSTRACT SUPERTYPE;
	assigned_name : label;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- name_assignment


ENTITY organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_organization : organization;
	role : organization_role;
END_ENTITY; -- organization_assignment


ENTITY organization_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_organization_type : organization_type;
	role : organization_type_role;
END_ENTITY; -- organization_type_assignment


ENTITY organization_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization_type_role


ENTITY organizational_project_assignment
	ABSTRACT SUPERTYPE;
	assigned_organizational_project : organizational_project;
	role : organizational_project_role;
END_ENTITY; -- organizational_project_assignment


ENTITY organizational_project_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organizational_project_role


ENTITY person_and_organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_person_and_organization : person_and_organization;
	role : person_and_organization_role;
END_ENTITY; -- person_and_organization_assignment


ENTITY person_assignment
	ABSTRACT SUPERTYPE;
	assigned_person : person;
	role : person_role;
END_ENTITY; -- person_assignment


ENTITY person_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_person_type : person_type;
	role : person_type_role;
END_ENTITY; -- person_type_assignment


ENTITY person_type_definition_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_person_type_definition : person_type_definition;
	role : person_type_definition_role;
END_ENTITY; -- person_type_definition_assignment


ENTITY person_type_definition_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type_definition_role


ENTITY person_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type_role


ENTITY position_in_organization_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_position_in_organization : position_in_organization;
	role : position_in_organization_role;
END_ENTITY; -- position_in_organization_assignment


ENTITY position_in_organization_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_role


ENTITY position_in_organization_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_position_in_organization_type : position_in_organization_type;
	role : position_in_organization_type_role;
END_ENTITY; -- position_in_organization_type_assignment


ENTITY position_in_organization_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_type_role


ENTITY qualification_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_qualification : qualification;
	role : qualification_role;
END_ENTITY; -- qualification_assignment


ENTITY qualification_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_role


ENTITY qualification_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_qualification_type : qualification_type;
	role : qualification_type_role;
END_ENTITY; -- qualification_type_assignment


ENTITY qualification_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_type_role


ENTITY security_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_security_classification : security_classification;
DERIVE
	role : object_role :=  get_role(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1 ;
END_ENTITY; -- security_classification_assignment


ENTITY time_assignment
	ABSTRACT SUPERTYPE;
	assigned_time : local_time;
	role : time_role;
END_ENTITY; -- time_assignment


ENTITY time_interval_assignment
	ABSTRACT SUPERTYPE;
	assigned_time_interval : time_interval;
	role : time_interval_role;
END_ENTITY; -- time_interval_assignment


ENTITY dependent_material_removal_feature_template
	SUBTYPE OF (part_template_definition);
WHERE
	WR1 :  SELF \ shape_aspect.description = 'material removal feature template' ;
	WR2 :  SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN  TYPEOF(am.relating_shape_aspect))AND(am.relating_shape_aspect.description IN [ 'default attachment size and  component termination passage based', 'default attachment size based', 'default attachment size and via based', 'default component termination passage based', 'default via based', 'default unsupported passage based' ]))))= 1 ;
END_ENTITY; -- dependent_material_removal_feature_template


ENTITY design_object
	SUBTYPE OF (characterized_object, group);
END_ENTITY; -- design_object


ENTITY electrical_isolation_removal_template_definition
	SUBTYPE OF (part_template_definition);
END_ENTITY; -- electrical_isolation_removal_template_definition


ENTITY grouped_requirements_property
	SUBTYPE OF (group, requirements_property);
WHERE
	WR1 : (NOT(SELF  \ group.name = 'item restricted requirements property'))OR(SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga))| SIZEOF(aga.items)= 1))= 1);
	WR2 : (NOT(SELF  \ group.name = 'layout spacing requirements property'))OR(SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN  TYPEOF(ga))|(SIZEOF(aga.items)= 2)AND(SIZEOF(QUERY(rp <* QUERY(it <* aga.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_OBJECT' IN  TYPEOF(it))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_OBJECT' IN  TYPEOF(rp))AND(rp \ characterized_object.name IN [ 'assembly module assembly component', 'assembly module component terminal', 'assembly module component', 'assembly module macro component join terminal', 'assembly module macro component', 'assembly module', 'bare die component terminal', 'bare die component', 'bonded conductive base blind via', 'buried via', 'cable component', 'component feature', 'component mounting feature', 'component termination passage and  contact size dependent land', 'component termination passage and  contact size dependent non functional land', 'component termination passage dependent land', 'component termination passage dependent non functional land', 'component termination passage interface terminal', 'component termination passage join terminal', 'component termination passage', 'conductive interconnect element terminal', 'conductive interconnect element with  pre defined transitions', 'conductive interconnect element with user defined single transition', 'connected area component', 'contact size dependent land', 'contact size dependent non functional land', 'cutout edge segment', 'cutout', 'dielectric material passage', 'electrical isolation laminate component', 'embedded component terminal', 'fiducial', 'fill area', 'filled area material removal laminate component', 'inter stratum feature', 'interconnect component interface terminal', 'interconnect component join terminal', 'interconnect module assembly component', 'interconnect module component stratum based terminal', 'interconnect module component surface feature', 'interconnect module component terminal', 'interconnect module component', 'interconnect module edge segment', 'interconnect module edge', 'interconnect module macro component join terminal', 'interconnect module macro component', 'interface access material removal laminate component', 'interface access stratum feature template component', 'interface component', 'interfacial connection', 'internal probe access area', 'join two physical connectivity definition supporting inter stratum feature', 'join two physical connectivity definition supporting printed component', 'laminate component', 'laminate text component', 'laminate text string component', 'land interface terminal', 'land join terminal', 'land', 'material removal laminate component', 'minimally defined component terminal', 'movable packaged component join terminal', 'multi layer material removal laminate component', 'multi layer stratum feature template component', 'non conductive base blind via', 'non functional land interface terminal', 'non functional land join terminal', 'non functional land', 'packaged component join terminal', 'packaged component', 'packaged connector component interface terminal', 'packaged connector component', 'partially plated cutout', 'partially plated interconnect module edge', 'physical component', 'physical connectivity interrupting cutout', 'physical laminate component', 'physical network supporting inter stratum feature', 'plated conductive base blind via', 'plated cutout edge segment', 'plated cutout', 'plated interconnect module edge segment', 'plated interconnect module edge', 'plated passage or unsupported passage', 'plated passage', 'primary stratum indicator symbol', 'printed component join terminal', 'printed connector component interface terminal', 'probe access area', 'routed interconnect component', 'routed physical component', 'special symbol laminate component', 'stratum feature template component', 'stratum feature', 'thermal isolation laminate component', 'unrouted conductive interconnect element', 'unsupported passage dependent non functional land', 'unsupported passage', 'via and  contact size dependent land', 'via and contact size dependent non functional land', 'via dependent land', 'via dependent non functional land', 'via terminal', 'via' ])))= 2)))= 1);
	WR3 : (NOT(SELF  \ group.name = 'layout spacing requirements property'))OR(SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN  TYPEOF(ga))|(SIZEOF(QUERY(rp <* QUERY(it <* aga.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_OBJECT' IN  TYPEOF(it))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_OBJECT' IN TYPEOF(rp))AND(rp \ characterized_object.description = 'dependent design object category')))= 1)))= 1);
	WR4 : (NOT(SELF  \ group.name = 'layout spacing requirements property'))OR(SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN  TYPEOF(ga))|(SIZEOF(QUERY(rp <* QUERY(it <* aga.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_OBJECT' IN  TYPEOF(it))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_OBJECT' IN TYPEOF(rp))AND(rp \ characterized_object.description = 'reference design object category')))= 1)))= 1);
END_ENTITY; -- grouped_requirements_property


ENTITY land_physical_template
	SUBTYPE OF (part_template_definition);
WHERE
	WR1 :  SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| SIZEOF(QUERY(duc <* USEDIN(ada.assigned_document, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| duc \ document_usage_constraint.subject_element = 'pre defined classification code'))= 1))<= 1 ;
	WR2 :  SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated definition')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_TEMPLATE_TERMINAL' IN TYPEOF(am.related_shape_aspect)))>= 1 ;
	WR3 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN [ 'default attachment size based', 'default attachment size and  component termination passage based', 'default attachment size and  via based' ]))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'minimum attachment region size')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))))<= 1));
	WR4 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN [ 'default attachment size based', 'default attachment size and  component termination passage based', 'default attachment size and  via based' ]))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'maximum attachment region size')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))))<= 1));
	WR5 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN  [ 'default component termination passage based', 'default attachment size and  component termination passage based' ]))OR(SIZEOF(QUERY(tu <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'technology usage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect))AND(tu.related_shape_aspect \ shape_aspect.description = 'default component termination passage definition')))= 1));
	WR6 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN  [ 'default attachment size and  component termination passage based', 'default attachment size based', 'default attachment size and via based', 'default component termination passage based', 'default via based', 'default unsupported passage based' ]))OR(SIZEOF(QUERY(ost <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'of stratum technology')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(ost.relating_shape_aspect.of_shape.definition)))= 1));
	WR7 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN [ 'default attachment size and  component termination passage based', 'default attachment size and via based', 'default component termination passage based', 'default via based', 'default unsupported passage based' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2))= 2))= 1)))= 0));
	WR8 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN [ 'default attachment size and  component termination passage based', 'default attachment size and  via based', 'default component termination passage based', 'default via based', 'default unsupported passage based' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum fabrication allowance')))= 1))= 1)))= 0));
	WR9 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN [ 'default attachment size and  component termination passage based', 'default attachment size and  via based', 'default component termination passage based', 'default via based', 'default unsupported passage based' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum annular ring')))= 1))= 1)))= 0));
	WR10 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN  [ 'default attachment size and  component termination passage based', 'default attachment size and via based', 'default component termination passage based', 'default via based', 'default unsupported passage based' ]))OR(SIZEOF(QUERY(tu <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'technology usage')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect)))= 1));
	WR11 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description IN  [ 'default via based', 'default attachment size and  via based' ]))OR(SIZEOF(QUERY(tu <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'technology usage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect))AND(tu.related_shape_aspect \ shape_aspect.description = 'default via definition')))= 1));
	WR12 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR((NOT(SELF  \ shape_aspect.description = 'default unsupported passage'))OR(SIZEOF(QUERY(tu <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'technology usage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(tu.related_shape_aspect))AND(tu.related_shape_aspect \ shape_aspect.description = 'default unsupported passage definition')))= 1));
END_ENTITY; -- land_physical_template


ENTITY land_template_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ] ;
	WR2 :  SIZEOF(QUERY(tcz <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'terminal connection zone')AND(sar \ shape_aspect_relationship.description IN [ 'edge curve', 'edge point', 'surface area', 'surface point' ]))| tcz.related_shape_aspect \ shape_aspect.description = 'connection zone'))>= 0 ;
END_ENTITY; -- land_template_terminal


ENTITY stratum_technology
	SUBTYPE OF (characterized_object);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'stiffness class representation'))<= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation'))= 1)))= 1 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(scr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'stratum class representation')| NOT(SIZEOF(QUERY(it <* scr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'laminate stiffness class')AND(it \ descriptive_representation_item.description IN [ 'fluid like', 'conformal coat', 'stiff laminate' ])))= 1)))= 0)))= 0 ;
	WR5 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT({ 2 <= SIZEOF(pcr.used_representation.items)<= 8 })))= 0)))= 0 ;
	WR6 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items | NOT(it \ representation_item.name IN [ 'layer purpose', 'layer position', 'maximum feature size requirement', 'minimum finished feature spacing', 'minimum finished feature size', 'maximum thickness', 'minimum thickness' ])))= 0)))= 0)))= 0 ;
	WR7 :  NOT(EXISTS(SELF  \ characterized_object.description))OR(NOT(SELF  \ characterized_object.description = 'design layer')OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum finished feature size')))= 1)))= 0)))= 0));
	WR8 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum thickness')))= 1)))= 0)))= 0 ;
	WR9 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum thickness')))= 1)))= 0)))= 0 ;
	WR10 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum feature size requirement')))<= 1)))= 0)))= 0 ;
	WR11 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum finished feature spacing')))<= 1)))= 0)))= 0 ;
	WR12 :  NOT(EXISTS(SELF  \ characterized_object.description))OR((NOT(SELF  \ characterized_object.description = 'documentation layer'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'layer purpose')))= 1)))= 0)))= 0));
	WR13 :  NOT(EXISTS(SELF  \ characterized_object.description))OR((NOT(SELF  \ characterized_object.description = 'design layer'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum finished feature spacing')))= 1)))= 0)))= 0));
	WR14 :  NOT(EXISTS(SELF  \ characterized_object.description))OR((NOT(SELF  \ characterized_object.description = 'design layer'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'layer purpose')AND(it \ descriptive_representation_item.description IN [ 'power or ground', 'other signal', 'lands only' ])))= 1)))= 0)))= 0));
	WR15 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pcr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'physical characteristics representation')| NOT(SIZEOF(QUERY(it <* pcr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'layer position')AND(it \ descriptive_representation_item.description IN [ 'primary', 'secondary', 'internal', 'external', 'all' ])))= 1)))= 0)))= 0 ;
	WR16 :  NOT(EXISTS(SELF  \ characterized_object.description))OR(SELF \ characterized_object.description IN [ 'design layer', 'documentation layer' ]);
END_ENTITY; -- stratum_technology


ENTITY stratum_technology_link
	SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
	WR1 :  SELF  \ property_definition_relationship.related_property_definition.definition :<>: SELF \ property_definition_relationship.relating_property_definition.definition ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(SELF \ property_definition_relationship.related_property_definition.definition);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(SELF \ property_definition_relationship.relating_property_definition.definition);
	WR5 :  SELF \ property_definition.name = '' ;
	WR6 :  SELF \ property_definition.description = '' ;
	WR7 :  SELF \ property_definition_relationship.name = '' ;
	WR8 :  SELF \ property_definition_relationship.description = '' ;
	WR9 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF  \ property_definition.definition))AND(SELF \ property_definition.definition.description = 'printed part template');
	WR10 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| pdr.name = 'precedent stratum technology link'))<= 1 ;
	WR11 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr.name = 'precedent stratum technology link'))<= 1 ;
END_ENTITY; -- stratum_technology_link


ENTITY material_designation;
	name : label;
	definitions : SET [1:?] OF characterized_definition;
END_ENTITY; -- material_designation


ENTITY material_designation_characterization;
	name : label;
	description : text;
	designation : material_designation;
	property : characterized_material_property;
END_ENTITY; -- material_designation_characterization


ENTITY material_property
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : name, definition;
WHERE
	WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN  TYPEOF(SELF  \ property_definition.definition))OR(SIZEOF(bag_to_set(USEDIN(SELF , 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))- QUERY(temp <* bag_to_set(USEDIN(SELF, 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' + 'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp))))= 0);
END_ENTITY; -- material_property


ENTITY product_material_composition_relationship
	SUBTYPE OF (product_definition_relationship);
	class : label;
	constituent_amount : SET [1:?] OF measure_with_unit;
	composition_basis : label;
	determination_method : text;
END_ENTITY; -- product_material_composition_relationship


ENTITY property_definition_relationship;
	name : label;
	description : text;
	relating_property_definition : property_definition;
	related_property_definition : property_definition;
END_ENTITY; -- property_definition_relationship


ENTITY data_environment;
	name : label;
	description : text;
	elements : SET [1:?] OF property_definition_representation;
END_ENTITY; -- data_environment


ENTITY data_environment_relationship;
	name : label;
	description : text;
	relating_data_environment : data_environment;
	related_data_environment : data_environment;
END_ENTITY; -- data_environment_relationship


ENTITY material_property_representation
	SUBTYPE OF (property_definition_representation);
	dependent_environment : data_environment;
END_ENTITY; -- material_property_representation


ENTITY abstracted_expression_function
	SUBTYPE OF (maths_function, quantifier_expression);
DERIVE
	expr : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
	SELF\quantifier_expression.variables : LIST [1:?] OF  UNIQUE generic_variable :=  remove_first(SELF \ multiple_arity_generic_expression.operands);
WHERE
	WR1 :  SIZEOF(QUERY(operand <* SELF \ multiple_arity_generic_expression.operands | NOT(has_values_space(operand))))= 0 ;
END_ENTITY; -- abstracted_expression_function


ENTITY application_defined_function
	SUBTYPE OF (maths_function);
	explicit_domain : tuple_space;
	explicit_range : tuple_space;
	parameters : LIST [0:?] OF maths_value;
WHERE
	WR1 :  expression_is_constant(explicit_domain);
	WR2 :  expression_is_constant(explicit_range);
END_ENTITY; -- application_defined_function


ENTITY atom_based_literal
	SUBTYPE OF (generic_literal);
	lit_value : atom_based_value;
END_ENTITY; -- atom_based_literal


ENTITY b_spline_basis
	SUBTYPE OF (maths_function, generic_literal);
	degree : nonnegative_integer;
	repeated_knots : LIST [2:?] OF REAL;
DERIVE
	num_basis : positive_integer :=  SIZEOF(repeated_knots)- order ;
	order : positive_integer :=  degree + 1 ;
WHERE
	WR1 :  num_basis >= order ;
	WR2 :  nondecreasing(repeated_knots);
	WR3 :  repeated_knots [ order ] < repeated_knots [ num_basis + 1 ] ;
END_ENTITY; -- b_spline_basis


ENTITY b_spline_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	basis : LIST [1:?] OF b_spline_basis;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	coef : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_table(coef);
	WR2 : (space_dimension(coef.range)= 1)AND(number_superspace_of(factor1(coef.range))= the_reals);
	WR3 :  SIZEOF(basis)<= SIZEOF(shape_of_array(coef));
	WR4 :  compare_basis_and_coef(basis, coef);
END_ENTITY; -- b_spline_function


ENTITY banded_matrix
	SUBTYPE OF (linearized_table_function);
	default_entry : maths_value;
	below : INTEGER;
	above : INTEGER;
	order : ordering_type;
WHERE
	WR1 :  SIZEOF(SELF \ explicit_table_function.shape)= 2 ;
	WR2 :  - below <= above ;
	WR3 :  member_of(default_entry, factor1(SELF \ linearized_table_function.source.range));
END_ENTITY; -- banded_matrix


ENTITY basic_sparse_matrix
	SUBTYPE OF (explicit_table_function, multiple_arity_generic_expression);
	default_entry : maths_value;
	order : ordering_type;
	SELF\multiple_arity_generic_expression.operands : LIST [3:3] OF maths_function;
DERIVE
	index : maths_function :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
	loc : maths_function :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	val : maths_function :=  SELF \ multiple_arity_generic_expression.operands [ 3 ] ;
WHERE
	WR1 :  function_is_1d_table(index);
	WR2 :  function_is_1d_table(loc);
	WR3 :  function_is_1d_table(val);
	WR4 :  check_sparse_index_domain(index.domain, index_base, shape, order);
	WR5 :  check_sparse_index_to_loc(index.range, loc.domain);
	WR6 :  loc.domain = val.domain ;
	WR7 :  check_sparse_loc_range(loc.range, index_base, shape, order);
	WR8 :  member_of(default_entry, val.range);
END_ENTITY; -- basic_sparse_matrix


ENTITY binary_literal
	SUBTYPE OF (generic_literal);
	lit_value : BINARY;
END_ENTITY; -- binary_literal


ENTITY bound_variable_semantics
	SUBTYPE OF (variable_semantics);
END_ENTITY; -- bound_variable_semantics


ENTITY cartesian_complex_number_region
	SUBTYPE OF (maths_space, generic_literal);
	real_constraint : real_interval;
	imag_constraint : real_interval;
WHERE
	WR1 :  min_exists(real_constraint)OR  max_exists(real_constraint)OR  min_exists(imag_constraint)OR max_exists(imag_constraint);
END_ENTITY; -- cartesian_complex_number_region


ENTITY complex_number_literal
	SUBTYPE OF (generic_literal);
	real_part : REAL;
	imag_part : REAL;
END_ENTITY; -- complex_number_literal


ENTITY constant_function
	SUBTYPE OF (maths_function, generic_literal);
	sole_output : maths_value;
	source_of_domain : maths_space_or_function;
WHERE
	WR1 :  no_cyclic_domain_reference(source_of_domain, [ SELF ]);
	WR2 :  expression_is_constant(domain_from(source_of_domain));
END_ENTITY; -- constant_function


ENTITY definite_integral_expression
	SUBTYPE OF (quantifier_expression);
	lower_limit_neg_infinity : BOOLEAN;
	upper_limit_pos_infinity : BOOLEAN;
DERIVE
	integrand : generic_expression :=  SELF \ multiple_arity_generic_expression.operands [ 1 ] ;
	variable_of_integration : maths_variable :=  SELF \ multiple_arity_generic_expression.operands [ 2 ] ;
	SELF\quantifier_expression.variables : LIST [1:1] OF  UNIQUE generic_variable :=  [ variable_of_integration ] ;
WHERE
	WR1 :  has_values_space(integrand);
	WR2 :  space_is_continuum(values_space_of(integrand));
	WR3 :  definite_integral_expr_check(SELF \ multiple_arity_generic_expression.operands, lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY; -- definite_integral_expression


ENTITY definite_integral_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	variable_of_integration : input_selector;
	lower_limit_neg_infinity : BOOLEAN;
	upper_limit_pos_infinity : BOOLEAN;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	integrand : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  space_is_continuum(integrand.range);
	WR2 :  definite_integral_check(integrand.domain, variable_of_integration, lower_limit_neg_infinity, upper_limit_pos_infinity);
END_ENTITY; -- definite_integral_function


ENTITY dependent_variable_definition
	SUBTYPE OF (unary_generic_expression);
	name : label;
	description : text;
END_ENTITY; -- dependent_variable_definition


ENTITY elementary_function
	SUBTYPE OF (maths_function, generic_literal);
	func_id : elementary_function_enumerators;
END_ENTITY; -- elementary_function


ENTITY elementary_space
	SUBTYPE OF (maths_space, generic_literal);
	space_id : elementary_space_enumerators;
END_ENTITY; -- elementary_space


ENTITY explicit_table_function
	ABSTRACT SUPERTYPE OF (ONEOF (listed_real_data, listed_integer_data, listed_logical_data, listed_string_data, listed_complex_number_data, listed_data, externally_listed_data, linearized_table_function, basic_sparse_matrix))
	SUBTYPE OF (maths_function);
	index_base : zero_or_one;
	shape : LIST [1:?] OF positive_integer;
END_ENTITY; -- explicit_table_function


ENTITY expression_denoted_function
	SUBTYPE OF (maths_function, unary_generic_expression);
DERIVE
	expr : generic_expression :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 : (schema_prefix + 'FUNCTION_SPACE')IN TYPEOF(values_space_of(expr));
END_ENTITY; -- expression_denoted_function


ENTITY extended_tuple_space
	SUBTYPE OF (maths_space, generic_literal);
	base : product_space;
	extender : maths_space;
WHERE
	WR1 :  expression_is_constant(base)AND expression_is_constant(extender);
	WR2 :  no_cyclic_space_reference(SELF, [ ]);
	WR3 :  extender <> the_empty_space ;
END_ENTITY; -- extended_tuple_space


ENTITY externally_listed_data
	SUBTYPE OF (explicit_table_function, generic_literal, externally_defined_item);
	value_range : maths_space;
WHERE
	WR1 :  expression_is_constant(value_range);
END_ENTITY; -- externally_listed_data


ENTITY finite_function
	SUBTYPE OF (maths_function, generic_literal);
	pairs : SET [1:?] OF LIST [2:2] OF maths_value;
WHERE
	WR1 :  VALUE_UNIQUE(list_selected_components(pairs, 1));
END_ENTITY; -- finite_function


ENTITY finite_integer_interval
	SUBTYPE OF (maths_space, generic_literal);
	min : INTEGER;
	max : INTEGER;
DERIVE
	size : positive_integer :=  max - min + 1 ;
WHERE
	WR1 :  min <= max ;
END_ENTITY; -- finite_integer_interval


ENTITY finite_real_interval
	SUBTYPE OF (maths_space, generic_literal);
	min : REAL;
	min_closure : open_closed;
	max : REAL;
	max_closure : open_closed;
WHERE
	WR1 :  min < max ;
END_ENTITY; -- finite_real_interval


ENTITY finite_space
	SUBTYPE OF (maths_space, generic_literal);
	members : SET [0:?] OF maths_value;
WHERE
	WR1 :  VALUE_UNIQUE(members);
	WR2 :  SIZEOF(QUERY(expr <* QUERY(member <* members | 'ISO13584_GENERIC_EXPRESSIONS_SCHEMA.GENERIC_EXPRESSION' IN TYPEOF(member))| NOT expression_is_constant(expr)))= 0 ;
	WR3 :  no_cyclic_space_reference(SELF, [ ]);
END_ENTITY; -- finite_space


ENTITY free_variable_semantics
	SUBTYPE OF (variable_semantics);
END_ENTITY; -- free_variable_semantics


ENTITY function_application
	SUBTYPE OF (multiple_arity_generic_expression);
	func : maths_function_select;
	arguments : LIST [1:?] OF maths_expression;
DERIVE
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression :=  [ convert_to_maths_function(func)] + convert_to_operands(arguments);
WHERE
	WR1 :  function_applicability(func, arguments);
END_ENTITY; -- function_application


ENTITY function_space
	SUBTYPE OF (maths_space, generic_literal);
	domain_constraint : space_constraint_type;
	domain_argument : maths_space;
	range_constraint : space_constraint_type;
	range_argument : maths_space;
WHERE
	WR1 :  expression_is_constant(domain_argument)AND expression_is_constant(range_argument);
	WR2 : (domain_argument <> the_empty_space)AND(range_argument <> the_empty_space);
	WR3 : (domain_constraint <> sc_member)OR NOT member_of(the_empty_space, domain_argument);
	WR4 : (range_constraint <> sc_member)OR NOT member_of(the_empty_space, range_argument);
	WR5 :  NOT(any_space_satisfies(domain_constraint, domain_argument)AND any_space_satisfies(range_constraint, range_argument));
END_ENTITY; -- function_space


ENTITY general_linear_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	sum_index : one_or_two;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	mat : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_2d_table(mat);
	WR2 : (space_dimension(mat.range)= 1)AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY; -- general_linear_function


ENTITY homogeneous_linear_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	sum_index : one_or_two;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	mat : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_2d_table(mat);
	WR2 : (space_dimension(mat.range)= 1)AND subspace_of_es(factor1(mat.range), es_numbers);
END_ENTITY; -- homogeneous_linear_function


ENTITY imported_curve_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : curve;
	parametric_domain : tuple_space;
WHERE
	WR1 :  expression_is_constant(parametric_domain);
END_ENTITY; -- imported_curve_function


ENTITY imported_point_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : point;
END_ENTITY; -- imported_point_function


ENTITY imported_surface_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : surface;
	parametric_domain : tuple_space;
WHERE
	WR1 :  expression_is_constant(parametric_domain);
END_ENTITY; -- imported_surface_function


ENTITY imported_volume_function
	SUBTYPE OF (maths_function, generic_literal);
	geometry : volume;
	parametric_domain : tuple_space;
WHERE
	WR1 :  expression_is_constant(parametric_domain);
END_ENTITY; -- imported_volume_function


ENTITY integer_interval_from_min
	SUBTYPE OF (maths_space, generic_literal);
	min : INTEGER;
END_ENTITY; -- integer_interval_from_min


ENTITY integer_interval_to_max
	SUBTYPE OF (maths_space, generic_literal);
	max : INTEGER;
END_ENTITY; -- integer_interval_to_max


ENTITY integer_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [1:?] OF INTEGER;
END_ENTITY; -- integer_tuple_literal


ENTITY linearized_table_function
	SUPERTYPE OF (ONEOF (standard_table_function, regular_table_function, triangular_matrix, symmetric_matrix, banded_matrix))
	SUBTYPE OF (explicit_table_function, unary_generic_expression);
	first : INTEGER;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	source : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  function_is_1d_array(source);
	WR2 :  member_of(first, source.domain);
END_ENTITY; -- linearized_table_function


ENTITY listed_complex_number_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [2:?] OF REAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)/ 2 ] ;
WHERE
	WR1 :  NOT ODD(SIZEOF(values));
END_ENTITY; -- listed_complex_number_data


ENTITY listed_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF maths_value;
	value_range : maths_space;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
WHERE
	WR1 :  expression_is_constant(value_range);
	WR2 :  SIZEOF(QUERY(val <* values | NOT(member_of(val, value_range))))= 0 ;
END_ENTITY; -- listed_data


ENTITY listed_integer_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF INTEGER;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_integer_data


ENTITY listed_logical_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF LOGICAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_logical_data


ENTITY listed_product_space
	SUBTYPE OF (maths_space, generic_literal);
	factors : LIST [0:?] OF maths_space;
WHERE
	WR1 :  SIZEOF(QUERY(space <* factors | NOT(expression_is_constant(space))))= 0 ;
	WR2 :  no_cyclic_space_reference(SELF, [ ]);
	WR3 :  NOT(the_empty_space IN factors);
END_ENTITY; -- listed_product_space


ENTITY listed_real_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF REAL;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_real_data


ENTITY listed_string_data
	SUBTYPE OF (explicit_table_function, generic_literal);
	values : LIST [1:?] OF STRING;
DERIVE
	SELF\explicit_table_function.shape : LIST [1:?] OF positive_integer :=  [ SIZEOF(values)] ;
END_ENTITY; -- listed_string_data


ENTITY logical_literal
	SUBTYPE OF (generic_literal);
	lit_value : LOGICAL;
END_ENTITY; -- logical_literal


ENTITY mathematical_description;
	described : maths_expression;
	describing : STRING;
	encoding : label;
END_ENTITY; -- mathematical_description


ENTITY maths_boolean_variable
	SUBTYPE OF (maths_variable, boolean_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_booleans);
END_ENTITY; -- maths_boolean_variable


ENTITY maths_enum_literal
	SUBTYPE OF (generic_literal);
	lit_value : maths_enum_atom;
END_ENTITY; -- maths_enum_literal


ENTITY maths_function
	ABSTRACT SUPERTYPE OF (ONEOF (finite_function, constant_function, selector_function, elementary_function, restriction_function, repackaging_function, reindexed_array_function, series_composed_function, parallel_composed_function, explicit_table_function, homogeneous_linear_function, general_linear_function, b_spline_basis, b_spline_function, rationalize_function, partial_derivative_function, definite_integral_function, abstracted_expression_function, expression_denoted_function, imported_point_function, imported_curve_function, imported_surface_function, imported_volume_function, application_defined_function))
	SUBTYPE OF (generic_expression);
DERIVE
	domain : tuple_space :=  derive_function_domain(SELF);
	range : tuple_space :=  derive_function_range(SELF);
END_ENTITY; -- maths_function


ENTITY maths_integer_variable
	SUBTYPE OF (maths_variable, int_numeric_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_integers);
END_ENTITY; -- maths_integer_variable


ENTITY maths_real_variable
	SUBTYPE OF (maths_variable, real_numeric_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_reals);
END_ENTITY; -- maths_real_variable


ENTITY maths_space
	ABSTRACT SUPERTYPE OF (ONEOF (elementary_space, finite_integer_interval, integer_interval_from_min, integer_interval_to_max, finite_real_interval, real_interval_from_min, real_interval_to_max, cartesian_complex_number_region, polar_complex_number_region, finite_space, uniform_product_space, listed_product_space, extended_tuple_space, function_space))
	SUBTYPE OF (generic_expression);
END_ENTITY; -- maths_space


ENTITY maths_string_variable
	SUBTYPE OF (maths_variable, string_variable);
WHERE
	WR1 :  subspace_of_es(SELF \ maths_variable.values_space, es_strings);
END_ENTITY; -- maths_string_variable


ENTITY maths_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [0:?] OF maths_value;
END_ENTITY; -- maths_tuple_literal


ENTITY maths_variable
	SUBTYPE OF (generic_variable);
	values_space : maths_space;
	name : label;
WHERE
	WR1 :  expression_is_constant(values_space);
END_ENTITY; -- maths_variable


ENTITY parallel_composed_function
	SUBTYPE OF (maths_function, multiple_arity_generic_expression);
	source_of_domain : maths_space_or_function;
	prep_functions : LIST [1:?] OF maths_function;
	final_function : maths_function_select;
DERIVE
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF generic_expression :=  convert_to_operands_prcmfn(source_of_domain, prep_functions, final_function);
WHERE
	WR1 :  no_cyclic_domain_reference(source_of_domain, [ SELF ]);
	WR2 :  expression_is_constant(domain_from(source_of_domain));
	WR3 :  parallel_composed_function_domain_check(domain_from(source_of_domain), prep_functions);
	WR4 :  parallel_composed_function_composability_check(prep_functions, final_function);
END_ENTITY; -- parallel_composed_function


ENTITY partial_derivative_expression
	SUBTYPE OF (unary_generic_expression);
	d_variables : LIST [1:?] OF maths_variable;
	extension : extension_options;
DERIVE
	derivand : generic_expression :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  has_values_space(derivand);
	WR2 :  space_is_continuum(values_space_of(derivand));
	WR3 :  SIZEOF(QUERY(vbl <* d_variables |(NOT  subspace_of(values_space_of(vbl), the_reals))AND(NOT subspace_of(values_space_of(vbl), the_complex_numbers))))= 0 ;
END_ENTITY; -- partial_derivative_expression


ENTITY partial_derivative_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	d_variables : LIST [1:?] OF input_selector;
	extension : extension_options;
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	derivand : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 :  space_is_continuum(derivand.range);
	WR2 :  partial_derivative_check(derivand.domain, d_variables);
END_ENTITY; -- partial_derivative_function


ENTITY polar_complex_number_literal
	SUBTYPE OF (generic_literal);
	radius : REAL;
	angle : REAL;
WHERE
	WR1 :  radius >= 0 ;
	WR2 :  { 0 <= angle < 2 * PI } ;
END_ENTITY; -- polar_complex_number_literal


ENTITY polar_complex_number_region
	SUBTYPE OF (maths_space, generic_literal);
	centre : complex_number_literal;
	distance_constraint : real_interval;
	direction_constraint : finite_real_interval;
WHERE
	WR1 :  min_exists(distance_constraint)AND(real_min(distance_constraint)>= 0.0);
	WR2 :  { - PI  <= direction_constraint.min < PI } ;
	WR3 :  direction_constraint.max - direction_constraint.min <= 2.0 * PI ;
	WR4 : (direction_constraint.max - direction_constraint.min < 2.0 * PI)OR(direction_constraint.min_closure = open);
	WR5 : (direction_constraint.max - direction_constraint.min < 2.0 * PI)OR(direction_constraint.max_closure = open)OR(direction_constraint.min = - PI);
	WR6 : (real_min(distance_constraint)> 0.0)OR  max_exists(distance_constraint)OR(direction_constraint.max - direction_constraint.min < 2.0 * PI)OR(direction_constraint.max_closure = open);
END_ENTITY; -- polar_complex_number_region


ENTITY quantifier_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (multiple_arity_generic_expression);
	variables : LIST [1:?] OF  UNIQUE generic_variable;
WHERE
	WR1 :  SIZEOF(QUERY(vrbl <* variables | NOT(vrbl IN SELF \ multiple_arity_generic_expression.operands)))= 0 ;
	WR2 :  SIZEOF(QUERY(vrbl <* variables | NOT((schema_prefix + 'BOUND_VARIABLE_SEMANTICS')IN TYPEOF(vrbl.interpretation.semantics))))= 0 ;
END_ENTITY; -- quantifier_expression


ENTITY rationalize_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	SELF\unary_generic_expression.operand : maths_function;
DERIVE
	fun : maths_function :=  SELF \ unary_generic_expression.operand ;
WHERE
	WR1 : (space_dimension(fun.domain)= 1)AND(space_dimension(fun.range)= 1);
	WR2 :  number_tuple_subspace_check(factor1(fun.range));
	WR3 :  space_dimension(factor1(fun.range))> 1 ;
END_ENTITY; -- rationalize_function


ENTITY real_interval_from_min
	SUBTYPE OF (maths_space, generic_literal);
	min : REAL;
	min_closure : open_closed;
END_ENTITY; -- real_interval_from_min


ENTITY real_interval_to_max
	SUBTYPE OF (maths_space, generic_literal);
	max : REAL;
	max_closure : open_closed;
END_ENTITY; -- real_interval_to_max


ENTITY real_tuple_literal
	SUBTYPE OF (generic_literal);
	lit_value : LIST [1:?] OF REAL;
END_ENTITY; -- real_tuple_literal


ENTITY regular_table_function
	SUBTYPE OF (linearized_table_function);
	increments : LIST [1:?] OF INTEGER;
WHERE
	WR1 :  SIZEOF(increments)= SIZEOF(SELF \ explicit_table_function.shape);
	WR2 :  extremal_position_check(SELF);
END_ENTITY; -- regular_table_function


ENTITY reindexed_array_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	starting_indices : LIST [1:?] OF INTEGER;
	SELF\unary_generic_expression.operand : maths_function;
WHERE
	WR1 :  function_is_array(SELF \ unary_generic_expression.operand);
	WR2 :  SIZEOF(starting_indices)= SIZEOF(shape_of_array(SELF \ unary_generic_expression.operand));
END_ENTITY; -- reindexed_array_function


ENTITY repackaging_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	input_repack : repackage_options;
	output_repack : repackage_options;
	selected_output : nonnegative_integer;
	SELF\unary_generic_expression.operand : maths_function;
WHERE
	WR1 : (input_repack <> ro_wrap_as_tuple)OR((space_dimension(operand.domain)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN TYPEOF(factor1(operand.domain))));
	WR2 : (output_repack <> ro_unwrap_tuple)OR((space_dimension(operand.range)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN TYPEOF(factor1(operand.range))));
	WR3 :  selected_output <= space_dimension(repackage(operand.range, output_repack));
END_ENTITY; -- repackaging_function


ENTITY restriction_function
	SUBTYPE OF (maths_function, unary_generic_expression);
	SELF\unary_generic_expression.operand : maths_space;
END_ENTITY; -- restriction_function


ENTITY selector_function
	SUBTYPE OF (maths_function, generic_literal);
	selector : input_selector;
	source_of_domain : maths_space_or_function;
WHERE
	WR1 :  no_cyclic_domain_reference(source_of_domain, [ SELF ]);
	WR2 :  expression_is_constant(domain_from(source_of_domain));
END_ENTITY; -- selector_function


ENTITY series_composed_function
	SUBTYPE OF (maths_function, multiple_arity_generic_expression);
	SELF\multiple_arity_generic_expression.operands : LIST [2:?] OF maths_function;
WHERE
	WR1 :  composable_sequence(SELF \ multiple_arity_generic_expression.operands);
END_ENTITY; -- series_composed_function


ENTITY standard_table_function
	SUBTYPE OF (linearized_table_function);
	order : ordering_type;
WHERE
	WR1 :  extremal_position_check(SELF);
END_ENTITY; -- standard_table_function


ENTITY strict_triangular_matrix
	SUBTYPE OF (triangular_matrix);
	main_diagonal_value : maths_value;
END_ENTITY; -- strict_triangular_matrix


ENTITY symmetric_banded_matrix
	SUBTYPE OF (symmetric_matrix);
	default_entry : maths_value;
	above : nonnegative_integer;
WHERE
	WR1 :  member_of(default_entry, factor1(SELF \ linearized_table_function.source.range));
END_ENTITY; -- symmetric_banded_matrix


ENTITY symmetric_matrix
	SUBTYPE OF (linearized_table_function);
	symmetry : symmetry_type;
	triangle : lower_upper;
	order : ordering_type;
WHERE
	WR1 :  SIZEOF(SELF \ explicit_table_function.shape)= 2 ;
	WR2 :  SELF  \ explicit_table_function.shape [ 1 ] = SELF \ explicit_table_function.shape [ 2 ] ;
	WR3 :  NOT(symmetry = skew)OR((space_dimension(SELF  \ linearized_table_function.source.range)= 1)AND subspace_of_es(factor1(SELF \ linearized_table_function.source.range), es_numbers));
	WR4 :  NOT((symmetry = hermitian)OR(symmetry = skew_hermitian))OR((space_dimension(SELF  \ linearized_table_function.source.range)= 1)AND subspace_of_es(factor1(SELF \ linearized_table_function.source.range), es_complex_numbers));
END_ENTITY; -- symmetric_matrix


ENTITY triangular_matrix
	SUBTYPE OF (linearized_table_function);
	default_entry : maths_value;
	lo_up : lower_upper;
	order : ordering_type;
WHERE
	WR1 :  SIZEOF(SELF \ explicit_table_function.shape)= 2 ;
	WR2 :  member_of(default_entry, SELF \ maths_function.range);
END_ENTITY; -- triangular_matrix


ENTITY uniform_product_space
	SUBTYPE OF (maths_space, generic_literal);
	base : maths_space;
	exponent : positive_integer;
WHERE
	WR1 :  expression_is_constant(base);
	WR2 :  no_cyclic_space_reference(SELF, [ ]);
	WR3 :  base <> the_empty_space ;
END_ENTITY; -- uniform_product_space


ENTITY amount_of_substance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- amount_of_substance_measure_with_unit


ENTITY amount_of_substance_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 1.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- amount_of_substance_unit


ENTITY area_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AREA_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- area_measure_with_unit


ENTITY area_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 2.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- area_unit


ENTITY celsius_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- celsius_temperature_measure_with_unit


ENTITY context_dependent_unit
	SUBTYPE OF (named_unit);
	name : label;
END_ENTITY; -- context_dependent_unit


ENTITY conversion_based_unit
	SUBTYPE OF (named_unit);
	name : label;
	conversion_factor : measure_with_unit;
END_ENTITY; -- conversion_based_unit


ENTITY derived_unit;
	elements : SET [1:?] OF derived_unit_element;
DERIVE
	name : label :=  get_name_value(SELF);
WHERE
	WR1 : (SIZEOF(elements)> 1)OR((SIZEOF(elements)= 1)AND(elements [ 1 ].exponent <> 1.0));
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- derived_unit


ENTITY derived_unit_element;
	unit : named_unit;
	exponent : REAL;
END_ENTITY; -- derived_unit_element


ENTITY dimensional_exponents;
	length_exponent : REAL;
	mass_exponent : REAL;
	time_exponent : REAL;
	electric_current_exponent : REAL;
	thermodynamic_temperature_exponent : REAL;
	amount_of_substance_exponent : REAL;
	luminous_intensity_exponent : REAL;
END_ENTITY; -- dimensional_exponents


ENTITY electric_current_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- electric_current_measure_with_unit


ENTITY electric_current_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 1.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- electric_current_unit


ENTITY global_unit_assigned_context
	SUBTYPE OF (representation_context);
	units : SET [1:?] OF unit;
END_ENTITY; -- global_unit_assigned_context


ENTITY length_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- length_measure_with_unit


ENTITY length_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 1.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- length_unit


ENTITY luminous_intensity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- luminous_intensity_measure_with_unit


ENTITY luminous_intensity_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY; -- luminous_intensity_unit


ENTITY mass_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MASS_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- mass_measure_with_unit


ENTITY mass_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 1.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- mass_unit


ENTITY measure_with_unit
	SUPERTYPE OF (ONEOF (length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit));
	value_component : measure_value;
	unit_component : unit;
WHERE
	WR1 :  valid_units(SELF);
END_ENTITY; -- measure_with_unit


ENTITY named_unit
	SUPERTYPE OF ((ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit, ratio_unit)));
	dimensions : dimensional_exponents;
END_ENTITY; -- named_unit


ENTITY plane_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- plane_angle_measure_with_unit


ENTITY plane_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- plane_angle_unit


ENTITY ratio_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- ratio_measure_with_unit


ENTITY ratio_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- ratio_unit


ENTITY si_unit
	SUBTYPE OF (named_unit);
	prefix : OPTIONAL si_prefix;
	name : si_unit_name;
DERIVE
	SELF\named_unit.dimensions : dimensional_exponents :=  dimensions_for_si_unit(name);
END_ENTITY; -- si_unit


ENTITY solid_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- solid_angle_measure_with_unit


ENTITY solid_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- solid_angle_unit


ENTITY thermodynamic_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- thermodynamic_temperature_measure_with_unit


ENTITY thermodynamic_temperature_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 0.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 1.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- thermodynamic_temperature_unit


ENTITY time_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TIME_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- time_measure_with_unit


ENTITY time_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 0.0)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.0)AND(SELF  \ named_unit.dimensions.time_exponent = 1.0)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.0)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- time_unit


ENTITY volume_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
END_ENTITY; -- volume_measure_with_unit


ENTITY volume_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF  \ named_unit.dimensions.length_exponent = 3.000000)AND(SELF  \ named_unit.dimensions.mass_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.time_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.electric_current_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000)AND(SELF  \ named_unit.dimensions.amount_of_substance_exponent = 0.000000)AND(SELF \ named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY; -- volume_unit


ENTITY category_model_parameter
	SUBTYPE OF (model_parameter);
END_ENTITY; -- category_model_parameter


ENTITY model_parameter
	SUBTYPE OF (descriptive_representation_item, group_assignment, general_property);
	items : OPTIONAL SET [1:1] OF model_parameter_assigned_item;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 1 ;
	WR2 :  SIZEOF(QUERY(aga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PARAMETER_TYPE' IN  TYPEOF(aga.assigned_group))AND(aga.assigned_group \ group.name IN [ 'string property type', 'logical property type', 'physical property type', 'boolean property type' ])))= 1 ;
END_ENTITY; -- model_parameter


ENTITY parameter_assignment_override
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF \ parameter_assignment_override)))= 0 ;
	WR2 :  SELF  \ representation_relationship.rep_1 <> SELF \ representation_relationship.rep_2 ;
	WR3 :  SELF \ representation_relationship.name = '' ;
	WR4 :  SELF \ representation.name = '' ;
	WR5 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_1);
	WR6 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_2);
END_ENTITY; -- parameter_assignment_override


ENTITY parameter_assignment_representation
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(SELF.items)= 2 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF(TYPEOF(it)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODEL_PARAMETER' ])= 1)))= 1 ;
	WR3 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF(TYPEOF(it)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COORDINATED_REPRESENTATION_ITEM' ])= 1)))<= 1 ;
	WR4 :  SIZEOF(QUERY(it <* SELF.items |(SIZEOF(QUERY(aga <* USEDIN(it, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')|(SIZEOF(TYPEOF(aga \ group_assignment.assigned_group)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHARACTERISTIC_TYPE' ])= 1)))= 1)))<= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ parameter_assignment_representation))= 0 ;
END_ENTITY; -- parameter_assignment_representation


ENTITY product_specific_parameter_value_assignment
	SUBTYPE OF (characterized_object, product_related_product_category);
WHERE
	WR1 :  SIZEOF(SELF \ product_related_product_category.products)= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'assigned parameter')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' ] * TYPEOF(pdr.used_representation))= 1)))= 1)))= 1 ;
	WR3 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHARACTERIZED_PRODUCT_CATEGORY' IN TYPEOF(SELF));
	WR4 :  SELF  \ characterized_object.name = SELF \ product_category.name ;
END_ENTITY; -- product_specific_parameter_value_assignment


ENTITY schema_based_model_parameter
	SUBTYPE OF (model_parameter);
END_ENTITY; -- schema_based_model_parameter


ENTITY attribute_language_assignment
	SUBTYPE OF (attribute_classification_assignment);
	items : SET [1:?] OF attribute_language_item;
	SELF\attribute_classification_assignment.assigned_class : language;
WHERE
	WR1 :  SELF \ attribute_classification_assignment.role.name IN [ 'primary', 'translated' ] ;
	WR2 :  SELF \ attribute_classification_assignment.attribute_name <> '' ;
END_ENTITY; -- attribute_language_assignment


ENTITY language
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name <> '' ;
END_ENTITY; -- language


ENTITY multi_language_attribute_assignment
	SUBTYPE OF (attribute_value_assignment);
	items : SET [1:?] OF multi_language_attribute_item;
DERIVE
	translation_language : language :=  language_indication [ 1 ] \ attribute_classification_assignment.assigned_class ;
INVERSE
	language_indication: SET [1:1] OF attribute_language_assignment FOR items;
WHERE
	WR1 : (SELF \ attribute_value_assignment.role.name = 'alternate language');
	WR2 :  SIZEOF(QUERY(ala <* language_indication |(ala \ attribute_classification_assignment.attribute_name = 'attribute_value')AND(ala \ attribute_classification_assignment.role.name = 'translated')))= 1 ;
	WR3 :  SELF \ attribute_value_assignment.attribute_name <> '' ;
	WR4 :  SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')|(ata \ attribute_value_assignment.attribute_name = SELF \ attribute_value_assignment.attribute_name)AND(ata.translation_language :=: translation_language)))> 1))= 0 ;
	WR5 :  SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')|(ata \ attribute_classification_assignment.role.name = 'primary')AND(ata \ attribute_classification_assignment.attribute_name = SELF \ attribute_value_assignment.attribute_name)AND(ata \ attribute_classification_assignment.assigned_class :=: translation_language)))> 0))= 0 ;
END_ENTITY; -- multi_language_attribute_assignment


ENTITY applied_name_assignment
	SUBTYPE OF (name_assignment);
	item : name_item;
END_ENTITY; -- applied_name_assignment


ENTITY bus_element_link
	SUBTYPE OF (product_definition, product_definition_relationship);
UNIQUE
	UR1 : related_product_definition, relating_product_definition;
WHERE
	WR1 :  SELF  \ product_definition_relationship.related_product_definition :<>: SELF \ product_definition_relationship.relating_product_definition ;
	WR2 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN  TYPEOF(SELF  \ product_definition_relationship.related_product_definition))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.related_product_definition));
	WR3 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN  TYPEOF(SELF  \ product_definition_relationship.relating_product_definition))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(SELF \ product_definition_relationship.relating_product_definition));
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF  \ product_definition_relationship || SELF \ bus_element_link))= 0 ;
	WR5 :  NOT EXISTS(SELF  \ product_definition.name)OR(SELF \ product_definition.name = '');
	WR6 :  SELF \ product_definition_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'))>= 1 ;
END_ENTITY; -- bus_element_link


ENTITY bus_structural_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SIZEOF(QUERY(bce <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'bus composition')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_ELEMENT_LINK' IN TYPEOF(bce.related_product_definition)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment'))<= 1))<= 1 ;
	WR3 :  consistent_bus_structural_definition(bag_to_set(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_ELEMENT_LINK' IN TYPEOF(pdr.related_product_definition))));
END_ENTITY; -- bus_structural_definition


ENTITY component_functional_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition);
	WR2 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated terminal')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(it.relating_shape_aspect)))= 1 ;
	WR3 :  SIZEOF(QUERY(futba <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit terminal bus assignment')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(futba.relating_property_definition.definition)))<= 1 ;
	WR4 :  SIZEOF(QUERY(futna <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit terminal node assignment')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(futna.relating_property_definition.definition)))<= 1 ;
END_ENTITY; -- component_functional_terminal


ENTITY component_functional_unit
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'functional occurrence' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_TERMINAL' IN TYPEOF(sa)))>= 1))>= 1 ;
	WR3 :  SIZEOF(QUERY(ifu <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated functional unit')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition)))= 1 ;
	WR4 :  SIZEOF(QUERY(nc <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'network composition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(nc.relating_product_definition))AND(nc.relating_product_definition.frame_of_reference.name = 'functional network design')))= 1 ;
END_ENTITY; -- component_functional_unit


ENTITY network_node_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'functional network design' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(funtdna <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition node assignment')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(funtdna.related_property_definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(funtdna.related_property_definition.definition))))<= 1))<= 1 ;
	WR3 :  SIZEOF(QUERY(funn <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(funn.relating_product_definition))AND(funn.relating_product_definition.frame_of_reference.name = 'functional network design')))= 1 ;
END_ENTITY; -- network_node_definition


ENTITY functional_terminal_group
	SUBTYPE OF (group);
UNIQUE
	UR1 : name;
END_ENTITY; -- functional_terminal_group


ENTITY functional_unit
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name IN [ 'functional design usage', 'functional network design' ] ;
	WR2 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR3 :  SIZEOF(QUERY(adta <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))= 1 ;
	WR4 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR5 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR6 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR7 : (NOT(SELF.frame_of_reference.name = 'functional network design'))OR(SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')| du.relating_product_definition.frame_of_reference.name = 'functional design usage'))= 1);
	WR8 : (NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'THERMAL_NETWORK', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ELECTRICAL_NETWORK' ] * TYPEOF(SELF))= 1))OR(SELF.frame_of_reference.name = 'functional network design');
END_ENTITY; -- functional_unit


ENTITY functional_unit_terminal_definition
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'functional design usage');
	WR2 :  SIZEOF(QUERY(pd2 <* QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION' IN  TYPEOF(pd))| SIZEOF(QUERY(funtdba <* QUERY(pdr <* USEDIN(pd2, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(funtdba.relating_property_definition.definition)))<= 1))<= 1 ;
	WR3 :  SIZEOF(QUERY(pd2 <* QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION' IN  TYPEOF(pd))| SIZEOF(QUERY(funtdna <* QUERY(pdr <* USEDIN(pd2, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'functional unit network terminal definition node assignment')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN TYPEOF(funtdna.relating_property_definition.definition)))<= 1))<= 1 ;
END_ENTITY; -- functional_unit_terminal_definition


ENTITY make_from_functional_unit_terminal_definition_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : relating_shape_aspect, related_shape_aspect;
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' ] * TYPEOF(SELF.relating_shape_aspect))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' ] * TYPEOF(SELF.related_shape_aspect))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ make_from_functional_unit_terminal_definition_relationship))= 0 ;
	WR4 :  relating_shape_aspect.of_shape :<>: related_shape_aspect.of_shape ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect.description = '' ;
	WR7 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR8 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'))= 0 ;
	WR9 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_MAKE_FROM_RELATIONSHIP')IN TYPEOF(sar.of_shape \ property_definition.definition))))= 1 ;
END_ENTITY; -- make_from_functional_unit_terminal_definition_relationship


ENTITY scalar_terminal_definition_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : related_shape_aspect, relating_shape_aspect;
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ scalar_terminal_definition_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SELF \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'scalar terminal' ;
	WR8 :  SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'scalar terminal' ;
END_ENTITY; -- scalar_terminal_definition_link


ENTITY group_shape_aspect
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(SELF \ shape_aspect.of_shape.definition);
	WR2 :  NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ])OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(SELF  \ shape_aspect.of_shape.definition))AND(EXISTS(SELF  \ shape_aspect.of_shape.definition \ product_definition.name))AND(NOT EXISTS(SELF  \ shape_aspect.of_shape.definition \ product_definition.name)OR(SELF \ shape_aspect.of_shape.definition \ product_definition.name = 'interconnect module')));
	WR3 : ((NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'constrained object')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_DESIGN_OBJECT_CATEGORY')IN TYPEOF(pdr.related_property_definition.definition)))))= 1)))= 1));
	WR4 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'design specific purpose')))= 1))= 1)))= 0);
	WR5 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'keepout')AND(it \ descriptive_representation_item.description IN [ 'true', 'false' ])))= 1))= 1)))= 0);
	WR6 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))= 1))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description IN  [ 'interconnect module constraint region' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'requirement')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY')IN TYPEOF(pdr.relating_property_definition)))))= 1)))= 1);
	WR8 : (NOT(SELF  \ shape_aspect.description = 'termination constraint'))OR(SIZEOF(QUERY(ctm <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'constrained termination member')| ctm.related_shape_aspect \ shape_aspect.description = 'mating connector termination'))>= 2);
	WR9 :  EXISTS(SELF \ shape_aspect.description);
	WR10 : (NOT(SELF  \ shape_aspect.description IN  [ 'placement group' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'requirement')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY')IN TYPEOF(pdr.relating_property_definition))AND(pdr.relating_property_definition \ property_definition.name = 'requirement'))))= 1)))= 1);
	WR11 : (NOT(SELF  \ shape_aspect.description IN  [ 'termination constraint' ]))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'termination usage constraint')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY')IN TYPEOF(pdr.relating_property_definition))AND(pdr.relating_property_definition \ property_definition.name = 'termination usage constraint'))))= 1)))= 1);
END_ENTITY; -- group_shape_aspect


ENTITY reference_graphic_registration_mark
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = FALSE ;
END_ENTITY; -- reference_graphic_registration_mark


ENTITY seating_plane
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF \ seating_plane))= 0 ;
END_ENTITY; -- seating_plane


ENTITY functional_orientation_feature
	SUBTYPE OF (shape_aspect);
END_ENTITY; -- functional_orientation_feature


ENTITY guided_wave_terminal
	SUBTYPE OF (package_terminal);
END_ENTITY; -- guided_wave_terminal


ENTITY package
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'physical design usage' ;
	WR2 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'package'))> 0 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY' IN TYPEOF(sa)))= 1)))<= 1 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(sa)))>= 1)))>= 1 ;
	WR5 : (NOT(SELF  \ product_definition.description = 'altered package'))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'package alteration')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ] * TYPEOF(pdr.relating_product_definition))= 1)))= 1);
	WR6 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'package mounting data'))= 1)))= 1 ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body height above seating plane'))= 1)))= 1)))= 1 ;
	WR8 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body height below seating plane'))= 1)))= 1)))<= 1 ;
	WR9 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body clearance above seating plane'))= 1)))= 1)))<= 1 ;
	WR10 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum body clearance below seating plane'))= 1)))= 1)))<= 1 ;
	WR11 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'minimum body clearance above seating plane'))= 1)))= 1)))<= 1 ;
	WR12 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'minimum body clearance below seating plane'))= 1)))= 1)))<= 1 ;
	WR13 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'maximum lead length below seating plane'))= 1)))= 1)))<= 1 ;
	WR14 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'package mounting data')AND(SIZEOF(QUERY(item <* USEDIN(pdr.used_representation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| item \ representation_item.name = 'least lead length below seating plane'))= 1)))= 1)))<= 1 ;
	WR15 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(sa))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'package seating plane')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(sar.related_shape_aspect)))))= 1))))= 1)))= 1 ;
	WR16 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(sa))))= 1)))= 1 ;
	WR17 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(sa))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'of datum reference plane')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_REFERENCE_FRAME' IN TYPEOF(sar.related_shape_aspect)))))= 1))))= 1)))<= 1 ;
	WR18 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRIMARY_REFERENCE_TERMINAL' IN TYPEOF(sa))))= 1)))<= 1 ;
END_ENTITY; -- package


ENTITY package_body
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ])= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))= 1 ;
END_ENTITY; -- package_body


ENTITY package_body_bottom_surface
	SUBTYPE OF (package_body_surface);
END_ENTITY; -- package_body_bottom_surface


ENTITY package_body_edge_segment_surface
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	wr1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	wr2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EDGE_SEGMENT_VERTEX' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	wr3 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
	WR4 :  SIZEOF(QUERY(ce <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed surface')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_EDGE_SURFACE' IN TYPEOF(ce.relating_shape_aspect))))= 1 ;
	WR5 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ package_body_edge_segment_surface))= 0 ;
END_ENTITY; -- package_body_edge_segment_surface


ENTITY package_body_edge_surface
	SUBTYPE OF (package_body_surface);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional ;
	WR2 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ part_mounting_feature || SELF  \ package_body_edge_surface || SELF \ package_body_surface))= 0 ;
END_ENTITY; -- package_body_edge_surface


ENTITY package_body_surface
	ABSTRACT SUPERTYPE OF (ONEOF (package_body_top_surface, package_body_edge_surface, package_body_bottom_surface))
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ])= 1 ;
	WR2 :  SELF \ shape_aspect.product_definitional ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(TYPEOF(sar \ shape_aspect_relationship.relating_shape_aspect)= [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY' ])))= 1 ;
END_ENTITY; -- package_body_surface


ENTITY package_body_top_surface
	SUBTYPE OF (package_body_surface);
END_ENTITY; -- package_body_top_surface


ENTITY package_terminal
	SUPERTYPE OF (((guided_wave_terminal ANDOR wire_terminal) ANDOR primary_reference_terminal))
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1)))= 0 ;
	WR2 :  SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ])= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND(sar \ shape_aspect_relationship.name = 'terminal core material')AND(sar.relating_shape_aspect.of_shape.definition.frame_of_reference \ application_context_element.name = 'material definition')))<= 1 ;
	WR4 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND(sar \ shape_aspect_relationship.name = 'terminal surface material')AND(sar.relating_shape_aspect.of_shape.definition.frame_of_reference \ application_context_element.name = 'material definition')))= 1 ;
	WR5 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
	WR6 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'external connection zone')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))>= 0 ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'maximum terminal diametrical extent'))<= 1))<= 1))<= 1 ;
	WR8 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(lmwu <* QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)| lmwu \ representation_item.name = 'minimum terminal diametrical extent'))<= 1))<= 1))<= 1 ;
	WR9 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))<= 1 ;
	WR10 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))<= 1 ;
	WR11 :  SIZEOF(QUERY(eca <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'seating plane zone')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONNECTION_ZONE_INTERFACE_PLANE_RELATIONSHIP' IN TYPEOF(eca.related_shape_aspect)))<= 1 ;
END_ENTITY; -- package_terminal


ENTITY primary_orientation_feature
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = TRUE ;
	WR2 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
	WR3 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
END_ENTITY; -- primary_orientation_feature


ENTITY primary_reference_terminal
	SUBTYPE OF (package_terminal);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feaure'))<= 1 ;
END_ENTITY; -- primary_reference_terminal


ENTITY secondary_orientation_feature
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 :  SIZEOF((TYPEOF(SELF))* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRIMARY_ORIENTATION_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEATING_PLANE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VIEWING_PLANE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ])= 0 ;
	WR2 :  SELF.product_definitional = TRUE ;
	WR3 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
	WR4 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
END_ENTITY; -- secondary_orientation_feature


ENTITY tertiary_orientation_feature
	SUBTYPE OF (physical_unit_datum_feature);
WHERE
	WR1 :  SIZEOF((TYPEOF(SELF))* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRIMARY_ORIENTATION_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SECONDARY_ORIENTATION_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEATING_PLANE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VIEWING_PLANE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ])= 0 ;
	WR2 :  SELF.product_definitional = TRUE ;
	WR3 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
	WR4 :  SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated body vertical extent')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1 ;
END_ENTITY; -- tertiary_orientation_feature


ENTITY wire_terminal
	SUBTYPE OF (package_terminal);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF(QUERY(it <* pdr.used_representation.items |(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM')IN  TYPEOF(it))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_UNIT')IN TYPEOF(it \ measure_with_unit.unit_component))))= 2)))= 1))))= 0);
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'maximum wire terminal length')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_UNIT')IN TYPEOF(it \ measure_with_unit.unit_component))))= 1)))= 1))))= 0);
	WR3 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(it))AND(it \ representation_item.name = 'minimum wire terminal length')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_UNIT')IN TYPEOF(it \ measure_with_unit.unit_component))))= 1)))= 1))))= 0);
	WR4 : (SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'internal connection zone')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1);
END_ENTITY; -- wire_terminal


ENTITY packaged_connector
	SUBTYPE OF (packaged_part);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sa))))= 1)))>= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'interface plane'))= 1)))= 1)))<= 1 ;
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEATING_PLANE' IN TYPEOF(sa))))= 1)))<= 1 ;
END_ENTITY; -- packaged_connector


ENTITY packaged_connector_terminal_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 : (SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ])= 1)AND(SELF.of_shape.definition \ product_definition.description = 'packaged connector');
	WR2 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF  \ shape_aspect_relationship.related_shape_aspect))AND(SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'interface terminal'));
	WR3 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF  \ shape_aspect_relationship.related_shape_aspect))AND(SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'join terminal'));
END_ENTITY; -- packaged_connector_terminal_relationship


ENTITY packaged_part
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sa)))>= 0)))= 0 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_DESIGNATION.DEFINITIONS'))<= 1 ;
	WR3 :  SIZEOF(QUERY(ifu <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'implemented function')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(ifu.relating_product_definition))AND(ifu.relating_product_definition.frame_of_reference.name = 'functional design usage')))<= 1 ;
	WR4 :  NOT(EXISTS(SELF  \ product_definition.description))OR((NOT(SELF  \ product_definition.description = 'altered packaged part'))OR(SIZEOF(QUERY(bpp <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'base packaged part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(bpp.relating_product_definition))= 1)AND(bpp.relating_product_definition.frame_of_reference.name = 'physical design usage')))>= 1));
	WR5 :  SIZEOF(QUERY(upkg <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'used package')| SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGE' ] * TYPEOF(upkg.relating_product_definition))= 1))>= 1 ;
	WR6 :  SELF.frame_of_reference.name = 'physical design usage' ;
END_ENTITY; -- packaged_part


ENTITY packaged_part_terminal
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ] ;
	WR2 : (SIZEOF(TYPEOF(SELF.of_shape.definition)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ])= 1)AND(SELF.of_shape.definition \ product_definition.frame_of_reference.name = 'physical design usage');
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(top <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'terminal of package')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(top.related_shape_aspect)))>= 1 ;
	WR5 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
	WR6 : (NOT(SELF  \ shape_aspect.description = 'interface terminal'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))AND(sar.relating_shape_aspect \ shape_aspect.description = 'join terminal')))>= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'join terminal'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP' IN TYPEOF(sar))AND(sar.relating_shape_aspect \ shape_aspect.description = 'interface terminal')))<= 1);
END_ENTITY; -- packaged_part_terminal


ENTITY device_terminal_map
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : related_shape_aspect, relating_shape_aspect;
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(SELF.relating_shape_aspect);
END_ENTITY; -- device_terminal_map


ENTITY fiducial_part_feature
	SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- fiducial_part_feature


ENTITY part_interface_access_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'interface_access area')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1 ;
END_ENTITY; -- part_interface_access_feature


ENTITY part_mating_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'mating area')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1 ;
END_ENTITY; -- part_mating_feature


ENTITY part_mounting_feature
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'mounting area')AND(sar.related_shape_aspect \ shape_aspect.description = 'connection zone')))= 1 ;
END_ENTITY; -- part_mounting_feature


ENTITY part_tooling_feature
	SUPERTYPE OF ((ONEOF (fiducial_part_feature, tool_registration_mark) ANDOR test_point_part_feature))
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.product_definitional = TRUE ;
END_ENTITY; -- part_tooling_feature


ENTITY test_point_part_feature
	SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- test_point_part_feature


ENTITY thermal_feature
	SUBTYPE OF (shape_aspect);
END_ENTITY; -- thermal_feature


ENTITY tool_registration_mark
	SUBTYPE OF (part_tooling_feature);
END_ENTITY; -- tool_registration_mark


ENTITY composite_array_shape_aspect
	SUPERTYPE OF (ONEOF (linear_composite_array_shape_aspect, rectangular_composite_array_shape_aspect))
	SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_array_shape_aspect


ENTITY composite_array_shape_aspect_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ composite_array_shape_aspect_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))= 1 ;
END_ENTITY; -- composite_array_shape_aspect_link


ENTITY linear_composite_array_shape_aspect
	SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY; -- linear_composite_array_shape_aspect


ENTITY linear_composite_array_shape_aspect_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_COMPOSITE_ARRAY_SHAPE_ASPECT' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ linear_composite_array_shape_aspect_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))= 1 ;
END_ENTITY; -- linear_composite_array_shape_aspect_link


ENTITY rectangular_composite_array_shape_aspect
	SUBTYPE OF (composite_array_shape_aspect);
END_ENTITY; -- rectangular_composite_array_shape_aspect


ENTITY design_layer_type_specific_padstack_definition
	SUBTYPE OF (padstack_definition);
END_ENTITY; -- design_layer_type_specific_padstack_definition


ENTITY footprint_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ footprint_definition)))= 0 ;
	WR7 :  SELF.frame_of_reference.name IN [ 'layout design usage' ] ;
	WR8 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'template model'))= 1 ;
END_ENTITY; -- footprint_definition


ENTITY padstack_definition
	SUPERTYPE OF (ONEOF (design_layer_type_specific_padstack_definition, stratum_type_independent_padstack_definition))
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ padstack_definition)))= 0 ;
	WR7 :  SELF.frame_of_reference.name IN [ 'layout design usage' ] ;
	WR9 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'template model'))= 1 ;
END_ENTITY; -- padstack_definition


ENTITY stratum_type_independent_padstack_definition
	SUBTYPE OF (padstack_definition);
END_ENTITY; -- stratum_type_independent_padstack_definition


ENTITY part_text_template_definition
	SUBTYPE OF (part_template_definition);
WHERE
	WR1 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEXT_LITERAL' IN TYPEOF(it)))= 1))= 1)))= 0);
	WR2 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum font vertical extent')))= 1))= 1)))= 0);
	WR3 : (SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum font horizontal extent')))= 1))= 1)))= 0);
END_ENTITY; -- part_text_template_definition


ENTITY reference_packaged_part_interconnect_implementation
	SUBTYPE OF (physical_unit);
WHERE
	WR1 :  EXISTS(SELF \ product_definition.name);
	WR2 : (SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1)AND(SELF \ product_definition.name = 'interconnect module');
	WR3 :  SIZEOF(QUERY(du <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design usage')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PHYSICAL_UNIT' ] * TYPEOF(du.relating_product_definition))= 1)AND(du.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(du.relating_product_definition \ product_definition.name = 'interconnect module')AND(SIZEOF(QUERY(prpc <* USEDIN(du.relating_product_definition.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1)))<= 1 ;
	WR4 :  SELF.frame_of_reference.name = 'physical design' ;
END_ENTITY; -- reference_packaged_part_interconnect_implementation


ENTITY part_connected_terminals_definition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' ] * TYPEOF(mct.related_shape_aspect))= 1))>= 2 ;
END_ENTITY; -- part_connected_terminals_definition


ENTITY applied_organization_assignment
	SUBTYPE OF (organization_assignment);
	items : SET [1:?] OF organization_item;
END_ENTITY; -- applied_organization_assignment


ENTITY applied_person_and_organization_assignment
	SUBTYPE OF (person_and_organization_assignment);
	items : SET [1:?] OF person_and_organization_item;
END_ENTITY; -- applied_person_and_organization_assignment


ENTITY person_and_organization_address
	SUBTYPE OF (organizational_address, personal_address);
	SELF\organizational_address.organizations : SET [1:1] OF organization;
	SELF\personal_address.people : SET [1:1] OF person;
WHERE
	WR1 :  SIZEOF(QUERY(pao <* USEDIN(SELF  \ personal_address.people [ 1 ], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON')| pao.the_organization :=: SELF \ organizational_address.organizations [ 1 ]))= 1 ;
END_ENTITY; -- person_and_organization_address


ENTITY address;
	internal_location : OPTIONAL label;
	street_number : OPTIONAL label;
	street : OPTIONAL label;
	postal_box : OPTIONAL label;
	town : OPTIONAL label;
	region : OPTIONAL label;
	postal_code : OPTIONAL label;
	country : OPTIONAL label;
	facsimile_number : OPTIONAL label;
	telephone_number : OPTIONAL label;
	electronic_mail_address : OPTIONAL label;
	telex_number : OPTIONAL label;
DERIVE
	name : label :=  get_name_value(SELF);
	url : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  EXISTS(internal_location)OR  EXISTS(street_number)OR  EXISTS(street)OR  EXISTS(postal_box)OR  EXISTS(town)OR  EXISTS(region)OR  EXISTS(postal_code)OR  EXISTS(country)OR  EXISTS(facsimile_number)OR  EXISTS(telephone_number)OR  EXISTS(electronic_mail_address)OR EXISTS(telex_number);
END_ENTITY; -- address


ENTITY organization;
	id : OPTIONAL identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization


ENTITY organization_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organization : organization;
	related_organization : organization;
END_ENTITY; -- organization_relationship


ENTITY organization_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- organization_role


ENTITY organization_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization_type


ENTITY organization_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_organization_type : organization_type;
	related_organization_type : organization_type;
END_ENTITY; -- organization_type_relationship


ENTITY organizational_address
	SUBTYPE OF (address);
	organizations : SET [1:?] OF organization;
	description : OPTIONAL text;
END_ENTITY; -- organizational_address


ENTITY organizational_project;
	name : label;
	description : OPTIONAL text;
	responsible_organizations : SET [1:?] OF organization;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- organizational_project


ENTITY organizational_project_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organizational_project : organizational_project;
	related_organizational_project : organizational_project;
END_ENTITY; -- organizational_project_relationship


ENTITY person;
	id : identifier;
	last_name : OPTIONAL label;
	first_name : OPTIONAL label;
	middle_names : OPTIONAL LIST [1:?] OF label;
	prefix_titles : OPTIONAL LIST [1:?] OF label;
	suffix_titles : OPTIONAL LIST [1:?] OF label;
WHERE
	WR1 :  EXISTS(last_name)OR EXISTS(first_name);
END_ENTITY; -- person


ENTITY person_and_organization;
	the_person : person;
	the_organization : organization;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- person_and_organization


ENTITY person_and_organization_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- person_and_organization_role


ENTITY person_role;
	name : label;
DERIVE
	description : text :=  get_description_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- person_role


ENTITY person_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type


ENTITY person_type_definition;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	formation : person_type_definition_formation;
END_ENTITY; -- person_type_definition


ENTITY person_type_definition_formation;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	of_person_type : person_type;
END_ENTITY; -- person_type_definition_formation


ENTITY person_type_definition_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_person_type_definition : person_type_definition;
	related_person_type_definition : person_type_definition;
END_ENTITY; -- person_type_definition_relationship


ENTITY personal_address
	SUBTYPE OF (address);
	people : SET [1:?] OF person;
	description : OPTIONAL text;
END_ENTITY; -- personal_address


ENTITY position_in_organization;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization


ENTITY position_in_organization_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_position_in_organization : position_in_organization;
	related_position_in_organization : position_in_organization;
END_ENTITY; -- position_in_organization_relationship


ENTITY position_in_organization_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_type


ENTITY part_template_definition
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.of_shape \ property_definition.definition.frame_of_reference \ application_context_element.name = 'template definition' ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'part template analytical model')))<= 1)))= 0 ;
	WR3 : (NOT(SELF  \ shape_aspect.description = 'component termination passage template'))OR(SIZEOF(QUERY(ctpt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(ctpt.relating_shape_aspect))AND(ctpt.relating_shape_aspect \ shape_aspect.description = 'default component termination passage definition')))= 1);
	WR4 : (NOT(SELF  \ shape_aspect.description = 'component termination passage template'))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'access mechanism')| am.related_shape_aspect \ shape_aspect.description IN [ 'component termination passage template interface terminal', 'component termination passage template join terminal' ]))>= 2);
	WR5 : (NOT(SELF  \ shape_aspect.description = 'default trace template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))= 1))= 1);
	WR6 : (NOT(SELF  \ shape_aspect.description = 'inter stratum feature template'))OR(SIZEOF(QUERY(isfpt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(isfpt.relating_shape_aspect))))= 1);
	WR7 : (NOT(SELF  \ shape_aspect.description = 'printed connector template'))OR(SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name IN [ 'connector' ]))>= 1);
	WR8 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'transmission line model')))= 1)))= 0);
	WR9 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2))= 2))= 1)))= 0);
	WR10 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'maximum width')))= 1))= 1)))= 0);
	WR11 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'minimum width')))= 1))= 1)))= 0);
	WR12 : (NOT(SELF  \ shape_aspect.description = 'printed part template'))OR(SIZEOF(QUERY(impl_func <* QUERY(pdr <* USEDIN(SELF.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'implemented function')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT' IN TYPEOF(impl_func.relating_product_definition))AND(impl_func.relating_product_definition.frame_of_reference.name = 'functional design usage')))= 1);
	WR13 : (NOT(SELF  \ shape_aspect.description = 'printed part template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated definition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(ad.related_shape_aspect))AND(ad.related_shape_aspect \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ])))>= 2);
	WR14 : (NOT(SELF  \ shape_aspect.description = 'trace template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'curve style parameters'))= 1)))= 1);
	WR15 : (NOT(SELF  \ shape_aspect.description = 'unsupported passage template'))OR(SIZEOF(QUERY(upt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(upt.relating_shape_aspect))AND(upt.relating_shape_aspect \ shape_aspect.description = 'default unsupported passage definition')))= 1);
	WR16 : (NOT(SELF  \ shape_aspect.description = 'via template'))OR(SIZEOF(QUERY(vpt <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'inter stratum feature passage technology')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY' IN TYPEOF(vpt.relating_shape_aspect))AND(vpt.relating_shape_aspect \ shape_aspect.description = 'default via definition')))= 1);
	WR17 : (NOT(SELF  \ shape_aspect.description = 'via template'))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'access mechanism')| am.related_shape_aspect \ shape_aspect.description = 'via template terminal'))>= 2);
	WR18 :  EXISTS(SELF \ shape_aspect.name);
	WR19 : (NOT(SELF  \ shape_aspect.description = 'non conductive cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition))))= 1))= 1);
	WR20 : (NOT(SELF  \ shape_aspect.description = 'non conductive cross section template'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(it))= 2)AND(it \ representation_item.name = 'nominal width')))= 1))= 1)))= 0);
	WR21 : (NOT(SELF  \ shape_aspect.description = 'printed connector template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated definition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(ad.related_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ])))>= 2);
	WR22 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'horizontal material link')| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'left')))))= 0);
	WR27 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'horizontal material link')| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'right')))))= 0);
	WR28 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'vertical material link')| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'bottom')))))= 0);
	WR29 : (NOT(SELF  \ shape_aspect.description = 'printed part cross section template'))OR(SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'vertical material link')| NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(ad.relating_shape_aspect))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect))AND(ad.relating_shape_aspect \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'top')))))= 0);
	WR30 :  SELF \ shape_aspect.name = 'NULL' ;
END_ENTITY; -- part_template_definition


ENTITY physical_node_requirement_to_implementing_component_allocation
	SUBTYPE OF (shape_aspect_relationship, shape_aspect);
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(SELF.related_shape_aspect.of_shape \ property_definition.definition))AND(NOT(SELF.related_shape_aspect.of_shape \ property_definition.definition \ product_definition.description IN [ 'laminate component' ]));
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(SELF.relating_shape_aspect);
	WR3 :  acyclic_shape_aspect_relationship(SELF , [ SELF \ shape_aspect_relationship.related_shape_aspect ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_NODE_REQUIREMENT_TO_IMPLEMENTING_COMPONENT_ALLOCATION');
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ physical_node_requirement_to_implementing_component_allocation))= 0 ;
END_ENTITY; -- physical_node_requirement_to_implementing_component_allocation


ENTITY component_2d_location
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'placement fixed')AND((it \ descriptive_representation_item.description = 'true')OR(it \ descriptive_representation_item.description = 'false'))))= 1 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))))= 1 ;
	WR3 : (NOT(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(it)))= 1);
	WR4 : (NOT(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 3))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)))= 1);
	WR5 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM' IN TYPEOF(it))))= 1 ;
	WR6 :  NOT(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN  TYPEOF(it)))= 1)OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(SIZEOF(QUERY(mi <* USEDIN(cto2d, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM.MAPPING_TARGET')|((SIZEOF(QUERY(cl <* USEDIN(mi, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|(cl = SELF)))= 1))))>= 1)))= 1);
	WR7 :  NOT(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN  TYPEOF(it)))= 1)OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(cto2d))AND(SIZEOF(QUERY(mi <* USEDIN(cto2d, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM.MAPPING_TARGET')|((SIZEOF(QUERY(cl <* USEDIN(mi, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|(cl = SELF)))= 1))))= 1)))= 1);
	WR8 :  NOT((SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)AND(SELF.context_of_items.context_type = 'component surface')AND((SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(pdr.definition.definition))AND(pdr.name = 'mounting surface assembly joint')AND(pdr.definition.definition.relating_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')AND(SIZEOF(QUERY(sar <* USEDIN(pdr.definition.definition.relating_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module primary surface')OR(sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module edge surface')OR(sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module edge segment surface'))))= 1))))= 1)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, 1.0, 0.001))))= 1);
	WR9 :  NOT((SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)AND(SELF.context_of_items.context_type = 'component surface')AND((SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(pdr.definition.definition))AND(pdr.name = 'mounting surface assembly joint')AND(pdr.definition.definition.relating_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')AND(SIZEOF(QUERY(sar <* USEDIN(pdr.definition.definition.relating_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module secondary surface'))= 1))))= 1)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, - 1.0, 0.001))))= 1);
	WR10 : (NOT(is_laminate_component_location(SELF)))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition))AND(pdr.definition.definition.relating_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')))= 0);
	WR11 : (NOT(is_laminate_component_location(SELF)AND(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, 1.0, 0.001))))= 1);
	WR12 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition))AND(pdr.definition.definition \ shape_aspect.description = 'interconnect module component surface feature')))= 0 ;
	WR13 : (NOT((SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)AND(SELF.context_of_items.context_type = 'component stacked')))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition))AND(pdr.definition.definition.relating_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')))= 0);
	WR14 :  NOT((SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)AND(SELF.context_of_items.context_type = 'component edge'))OR((NOT(is_laminate_component_location(SELF)))AND((SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(pdr.definition.definition))AND(pdr.name = 'reference terminal assembly joint')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN  TYPEOF(pdr.definition.definition.related_shape_aspect))AND(pdr.definition.definition.related_shape_aspect \ shape_aspect.description IN  [ 'packaged component join terminal', 'package terminal occurrence' ])AND(SIZEOF(QUERY(sar <* USEDIN(pdr.definition.definition.related_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'instantiated feature')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRIMARY_REFERENCE_TERMINAL' IN  TYPEOF(sar.relating_shape_aspect))))= 1)AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))AND(component_definition_located_by_component_location(SELF)= pdr.definition.definition.related_shape_aspect.of_shape.definition))))= 1))AND((SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(pdr.definition.definition))AND(pdr.name = 'mounting surface assembly joint')AND(pdr.definition.definition.relating_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')AND(SIZEOF(QUERY(sar <* USEDIN(pdr.definition.definition.relating_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module edge surface')OR(sar.relating_shape_aspect \ shape_aspect.description = 'interconnect module edge segment surface')))= 1)AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_MOUNTING_FEATURE' IN  TYPEOF(pdr.definition.definition.related_shape_aspect))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))AND(component_definition_located_by_component_location(SELF)= pdr.definition.definition.related_shape_aspect.of_shape.definition))))= 1)));
	WR15 :  NOT((SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)AND(SELF.context_of_items.context_type = 'component stacked'))OR((NOT(is_laminate_component_location(SELF)))AND((SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(pdr.definition.definition))AND('mounting joint' = pdr.name)AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_MOUNTING_FEATURE' IN  TYPEOF(pdr.definition.definition.related_shape_aspect))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.definition.definition.related_shape_aspect.of_shape.definition))AND(component_definition_located_by_component_location(SELF):=: pdr.definition.definition.related_shape_aspect.of_shape.definition)AND(component_definition_located_by_component_location(SELF):<>: pdr.definition.definition.relating_shape_aspect.of_shape.definition))))= 1)));
	WR16 : (NOT(is_interconnect_module_component_location(SELF)))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition))AND(pdr.definition.definition.relating_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')))= 0);
	WR17 :  NOT((SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)AND(SELF.context_of_items.context_type = 'component stacked'))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND((cto2d_determinant_test(cto2d, 1.0, 0.001))OR(cto2d_determinant_test(cto2d, - 1.0, 0.001)))))= 1);
	WR18 :  SIZEOF(QUERY(it <* SELF \ representation.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR19 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it))AND(it \ representation_item.name = 'origin')))= 0 ;
	WR20 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM' IN  TYPEOF(it))AND  NOT(((it \ representation_item.name = 'component assembly 2d position')OR(it \ representation_item.name = 'component assembly 3d position'))AND(it.mapping_source.mapping_origin \ representation_item.name = 'origin')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN  TYPEOF(it.mapping_source.mapping_origin))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it.mapping_source.mapping_origin))))))= 0 ;
	WR21 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr.definition.definition))))= 1 ;
	WR22 : (NOT(is_top_footprint_occurrence_location(SELF)AND(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, 1.0, 0.001))))= 1);
	WR23 : (NOT(is_bottom_footprint_occurrence_location(SELF)AND(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, - 1.0, 0.001))))= 1);
	WR24 : (NOT(is_symmetrical_footprint_occurrence_location(SELF)AND(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, 1.0, 0.001))))= 1);
	WR25 : (NOT(is_top_padstack_occurrence_location(SELF)AND(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, 1.0, 0.001))))= 1);
	WR26 : (NOT(is_bottom_padstack_occurrence_location(SELF)AND(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, - 1.0, 0.001))))= 1);
	WR27 : (NOT(is_symmetrical_padstack_occurrence_location(SELF)AND(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(cto2d_determinant_test(cto2d, 1.0, 0.001))))= 1);
END_ENTITY; -- component_2d_location


ENTITY component_3d_location
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'placement fixed')AND((it \ descriptive_representation_item.description = 'true')OR(it \ descriptive_representation_item.description = 'false'))))= 1 ;
	WR2 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))))= 1 ;
	WR3 : (NOT(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(it)))= 1);
	WR4 : (NOT(SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 3))OR(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it)))= 1);
	WR5 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM' IN TYPEOF(it))))= 1 ;
	WR6 :  NOT(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN  TYPEOF(it)))= 1)OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D' IN TYPEOF(cto2d))AND(SIZEOF(QUERY(mi <* USEDIN(cto2d, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM.MAPPING_TARGET')|((SIZEOF(QUERY(cl <* USEDIN(mi, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|(cl = SELF)))= 1))))>= 1)))= 1);
	WR7 :  NOT(SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN  TYPEOF(it)))= 1)OR(SIZEOF(QUERY(cto2d <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(cto2d))AND(SIZEOF(QUERY(mi <* USEDIN(cto2d, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM.MAPPING_TARGET')|((SIZEOF(QUERY(cl <* USEDIN(mi, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|(cl = SELF)))= 1))))= 1)))= 1);
	WR12 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition))AND(pdr.definition.definition \ shape_aspect.description = 'interconnect module component surface feature')))= 0 ;
	WR13 : (NOT((SELF.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)AND(SELF.context_of_items.context_type = 'component stacked')))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN TYPEOF(pdr.definition.definition))AND(pdr.definition.definition.relating_shape_aspect \ shape_aspect.description = 'interconnect module component surface feature')))= 0);
	WR18 :  SIZEOF(QUERY(it <* SELF \ representation.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_TRANSFORMATION_OPERATOR_2D', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' ] * TYPEOF(it))= 1)))= 0 ;
	WR19 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it))AND(it \ representation_item.name = 'origin')))= 0 ;
	WR20 :  SIZEOF(QUERY(it <* SELF.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAPPED_ITEM' IN  TYPEOF(it))AND  NOT(((it \ representation_item.name = 'component assembly 2d position')OR(it \ representation_item.name = 'component assembly 3d position'))AND(it.mapping_source.mapping_origin \ representation_item.name = 'origin')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN  TYPEOF(it.mapping_source.mapping_origin))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(it.mapping_source.mapping_origin))))))= 0 ;
	WR21 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr.definition.definition))))= 1 ;
END_ENTITY; -- component_3d_location


ENTITY component_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = 'planar projected shape'))<= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = '3d bound volume shape'))<= 1)))= 0 ;
	WR3 : (NOT(SELF  \ product_definition.description = 'bare die component'))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_BARE_DIE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_BARE_DIE' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1);
	WR4 :  NOT(is_assembly_module_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(ip.relating_product_definition \ product_definition.name = 'assembly module')))= 1);
	WR5 :  NOT(is_assembly_module_occurrence(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' IN TYPEOF(sa))AND(sa \ shape_aspect.description = 'assembly module component terminal')))>= 2))>= 1);
	WR6 :  NOT(is_interconnect_module_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')AND(SELF \ product_definition.name = 'interconnect module')))= 1);
	WR7 : (NOT(SELF  \ product_definition.description = 'mating connector'))OR((('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN  TYPEOF(SELF))AND(SIZEOF(QUERY(doc <* SELF  \ product_definition_with_associated_documents.documentation_ids | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EE_SPECIFICATION' IN  TYPEOF(doc)))= 1))OR(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pt_occ <* QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| sa \ shape_aspect.description = 'part template occurrence')| SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(pt_occ, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'printed connector template')))= 1))= 1)))= 0)OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PACKAGED_PART', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PACKAGED_PART' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition \ product_definition.description = 'packaged connector')))= 1));
	WR8 : (NOT(SELF  \ product_definition.description = 'mating connector'))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'mating connector placement'))= 1))= 1);
	WR9 : (NOT(SELF  \ product_definition.description = 'mating connector'))OR((SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdr)))= 0)AND(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN TYPEOF(pdr)))= 0));
	WR10 :  SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| NOT(NOT(pdr \ product_definition_relationship.name = 'instantiated part')OR(SELF.formation :=: pdr.relating_product_definition.formation))))= 0 ;
	WR11 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))|(sr_pdr.used_representation \ representation.name = 'part template non planar 2d shape')OR(sr_pdr.used_representation \ representation.name = 'non planar 2d shape')OR(sr_pdr.used_representation \ representation.name = 'open shell based surface')))<= 1)))= 0 ;
	WR13 :  NOT(is_assembly_module_macro_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design definition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design')AND(ip.relating_product_definition \ product_definition.name = 'assembly module')))= 1);
	WR14 :  NOT(is_interconnect_module_macro_occurrence(SELF))OR(SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'design definition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(ip.relating_product_definition))AND(ip.relating_product_definition.frame_of_reference.name = 'physical design')AND(ip.relating_product_definition \ product_definition.name = 'interconnect module')))= 1);
	WR15 :  SIZEOF(QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'instantiated definition')AND(NOT(SELF.formation :=: pdr.relating_product_definition.formation)))))= 0 ;
	WR16 : (NOT(SELF  \ product_definition.description = 'routed interconnect component'))OR((SIZEOF(QUERY(ip <* QUERY(pdr <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'instantiated part')|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' ] * TYPEOF(ip.relating_product_definition))= 1)AND(ip.relating_product_definition.frame_of_reference.name = 'physical design usage')))= 1)AND(SELF.frame_of_reference.name = 'physical occurrence'));
END_ENTITY; -- component_definition


ENTITY component_shape_aspect
	SUPERTYPE OF (thermal_component_shape_aspect)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
	WR2 : (SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FIDUCIAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONNECTED_AREA_COMPONENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'THERMAL_COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTEGRAL_SHIELD', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROBE_ACCESS_AREA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND' ] * TYPEOF(SELF))>= 1)OR(SELF \ shape_aspect.description IN [ 'part template occurrence', 'laminate component', 'laminate text component', 'laminate text string component', 'conductive interconnect element with  pre defined transitions', 'join 2 physical connectivity definition supporting', 'conductive interconnect element with user defined single transition', 'special symbol laminate component', 'primary stratum indicator symbol', 'stratum feature template component' ]);
	WR3 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = 'planar projected shape'))<= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))| sr_pdr.used_representation \ representation.name = '3d bound volume shape'))<= 1)))= 0 ;
	WR5 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'laminate text component', 'laminate text string component', 'special symbol laminate component', 'primary stratum indicator symbol', 'stratum feature template component' ])OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.description = 'laminate component')));
	WR6 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description = 'laminate text component')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEXT_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))))= 1));
	WR7 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'stratum feature template component' ])OR(SIZEOF(QUERY(sfi <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'stratum feature implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect))))= 1));
	WR8 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'conductive interconnect element with  pre defined transitions', 'join 2 physical connectivity definition supporting', 'conductive interconnect element with ' + 'user defined single transition' ])OR(SIZEOF(QUERY(cc <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'composed conductor')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(cc.related_shape_aspect))))= 1));
	WR10 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'special symbol laminate component', 'primary stratum indicator symbol' ])OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(it.relating_shape_aspect))AND(it.related_shape_aspect \ shape_aspect.description = 'special symbol part template'))))= 1));
	WR11 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description = 'stratum feature template component')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN  TYPEOF(it.relating_shape_aspect))AND(it.relating_shape_aspect \ shape_aspect.description = 'stratum feature template'))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_PHYSICAL_TEMPLATE' IN TYPEOF(it.relating_shape_aspect))))<= 1));
	WR12 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description IN  [ 'laminate text component' ])OR(SIZEOF(QUERY(sfi <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'stratum feature implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(sfi.relating_shape_aspect))))>= 1));
	WR13 :  NOT((SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTER_STRATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FIDUCIAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONNECTED_AREA_COMPONENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'THERMAL_COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_REMOVAL_COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTEGRAL_SHIELD', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROBE_ACCESS_AREA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND' ] * TYPEOF(SELF))>= 1)OR(SELF  \ shape_aspect.description IN  [ 'laminate component', 'laminate text component', 'laminate text string component', 'conductive interconnect element with  pre defined transitions', 'join 2 physical connectivity definition supporting', 'conductive interconnect element with user defined single transition', 'special symbol laminate component', 'primary stratum indicator symbol', 'stratum feature template component' ]))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(SELF.of_shape.definition))AND(SELF.of_shape.definition \ product_definition.frame_of_reference \ application_context_element.name = 'layout occurrence'));
	WR14 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'instantiated template'))<= 1 ;
	WR15 :  NOT(EXISTS(SELF  \ shape_aspect.description))OR(NOT(SELF  \ shape_aspect.description = 'join 2 physical connectivity definition supporting')OR(SIZEOF(QUERY(propd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(ri <* QUERY(propdr <* USEDIN(propd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| propdr \ property_definition_relationship.name = 'requirement implementation')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP' IN  TYPEOF(ri.relating_property_definition.definition))AND(ri.relating_property_definition.definition \ shape_aspect_relationship.name = 'ordered physical connectivity definition')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN  TYPEOF(ri.relating_property_definition.definition.related_shape_aspect))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(ri.relating_property_definition.definition.relating_shape_aspect))))= 1)))= 1));
END_ENTITY; -- component_shape_aspect


ENTITY thermal_component
	SUBTYPE OF (component_definition);
END_ENTITY; -- thermal_component


ENTITY thermal_component_shape_aspect
	SUBTYPE OF (component_shape_aspect);
END_ENTITY; -- thermal_component_shape_aspect


ENTITY connector_based_interconnect_definition
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : name, definition;
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_INTERCONNECT_DEFINITION' IN TYPEOF(SELF \ property_definition.definition);
END_ENTITY; -- connector_based_interconnect_definition


ENTITY physical_interconnection_definition
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : name, definition;
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_INTERCONNECT_DEFINITION' IN TYPEOF(SELF \ property_definition.definition);
END_ENTITY; -- physical_interconnection_definition


ENTITY physical_unit_interconnect_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ physical_unit_interconnect_definition)))= 0 ;
	WR7 :  SELF.frame_of_reference.name IN [ 'physical interconnect design' ] ;
END_ENTITY; -- physical_unit_interconnect_definition


ENTITY connection_zone_map_identification
	SUBTYPE OF (shape_aspect, representation_relationship);
WHERE
	WR1 :  SELF  \ representation_relationship.rep_2 :<>: SELF \ representation_relationship.rep_1 ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF \ representation_relationship.rep_1);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'USAGE_VIEW_CONNECTION_ZONE_TERMINAL_SHAPE_RELATIONSHIP' IN TYPEOF(SELF \ representation_relationship.rep_2);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ representation_relationship || SELF \ connection_zone_map_identification))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ representation_relationship.name = '' ;
	WR7 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FOOTPRINT_DEFINITION' IN TYPEOF(SELF.of_shape.definition);
END_ENTITY; -- connection_zone_map_identification


ENTITY make_from_part_feature_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : relating_shape_aspect, related_shape_aspect;
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.relating_shape_aspect))= 0 ;
	WR2 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' ] * TYPEOF(SELF.related_shape_aspect))= 0 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ make_from_part_feature_relationship))= 0 ;
	WR4 :  SELF.related_shape_aspect.product_definitional = TRUE ;
	WR5 :  SELF.relating_shape_aspect.product_definitional = TRUE ;
	WR6 :  SELF \ shape_aspect.name = '' ;
	WR7 :  SELF \ shape_aspect.description = '' ;
	WR8 :  SELF \ shape_aspect.product_definitional = FALSE ;
	WR9 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'))= 0 ;
	WR10 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESIGN_MAKE_FROM_RELATIONSHIP')IN TYPEOF(sar.of_shape \ property_definition.definition))))= 1 ;
END_ENTITY; -- make_from_part_feature_relationship


ENTITY part_feature_template_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ part_feature_template_definition)))= 0 ;
	WR7 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'template model'))>= 1 ;
END_ENTITY; -- part_feature_template_definition


ENTITY physical_unit
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SELF.frame_of_reference.name IN [ 'physical design', 'physical design usage' ] ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(dut <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'physical unit technology')| dut.relating_property_definition \ property_definition.name = 'unit technology'))= 1))<= 1 ;
	WR8 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN TYPEOF(sa)))>= 1)))= 0);
	WR9 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'maximum negative component height'))<= 1)))= 0);
	WR10 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| pdr.used_representation \ representation.name = 'maximum positive component height'))<= 1)))= 0);
	WR11 :  NOT(is_assembly_module_usage(SELF))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')))= 1);
	WR12 :  NOT(is_assembly_module_design(SELF))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')|(is_laminate_component(pdr.related_product_definition))))= 0);
	WR14 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')))<= 1);
	WR15 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd1 <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(pd1))AND(SIZEOF(QUERY(cd <* USEDIN(pd1, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHARACTERIZED_DEFINITION' IN TYPEOF(cd))AND(SIZEOF(QUERY(pd2 <* USEDIN(cd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd2 \ property_definition.name = 'located interconnect module thickness')AND(SIZEOF(USEDIN(pd2, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))> 1)))= 1)))= 1)))<= 1);
	WR16 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')))<= 1);
	WR17 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'minimum thickness over metal requirement')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR18 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'maximum thickness over metal requirement')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR19 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'minimum thickness over dielectric requirement')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR20 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'interconnect module usage view physical characteristics')AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'maximum thickness over dielectric requirement')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pdr.used_representation))))<= 1)))<= 1);
	WR21 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|((pd \ property_definition.name = 'restraint')OR(pd \ property_definition.name = 'tolerance specific restraint'))))<= 1);
	WR22 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(sa \ shape_aspect.description = 'interconnect module primary surface')))<= 1)))= 0);
	WR23 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(sa \ shape_aspect.description = 'interconnect module secondary surface')))<= 1)))= 0);
	WR24 :  NOT(is_interconnect_module_usage(SELF))OR(SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(sa \ shape_aspect.description = 'interconnect module edge surface')))<= 1)))= 0);
	WR25 :  NOT(is_assembly_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'assembly module')AND(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(sa))))> 0)))= 0)))OR(SIZEOF(QUERY(pd <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(sa))AND(SIZEOF(QUERY(acu <* USEDIN(sa \ shape_aspect_relationship.relating_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))>= 1)))>= 1)))>= 1));
	WR26 :  NOT(is_assembly_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'assembly module')))AND(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(acu <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(acu))AND(acu \ product_definition_relationship.relating_product_definition = SELF)))= 0)))= 0));
	WR27 :  NOT(is_assembly_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'assembly module')))AND(SIZEOF(QUERY(aj <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))))= 0)OR(SIZEOF(QUERY(aj <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT' IN  TYPEOF(aj))AND(SIZEOF(QUERY(cl <* USEDIN(aj \ shape_aspect_relationship.related_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_LOCATION' IN  TYPEOF(cl))AND(aj IN cl \ representation.items)))= 0)))= 0));
	WR28 :  NOT(is_interconnect_module_design(SELF))OR((NOT((SELF.frame_of_reference.name = 'physical design')AND(SELF  \ product_definition.name = 'interconnect module')))OR(SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATING_PRODUCT_DEFINITION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN  TYPEOF(pdr))AND(pdr \ product_definition_relationship.name = 'interconnect module stratum assembly relationship')AND(pdr.related_product_definition \ product_definition.description = 'primary design layer stratum')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN TYPEOF(pdr.related_product_definition)))))= 1));
END_ENTITY; -- physical_unit


ENTITY usage_view_connection_zone_terminal_shape_relationship
	SUBTYPE OF (representation, representation_relationship_with_transformation);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' ] * TYPEOF(SELF.rep_1))= 1 ;
	WR2 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' ] * TYPEOF(SELF.rep_2))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ representation_relationship_with_transformation || SELF \ usage_view_connection_zone_terminal_shape_relationship)))= 0 ;
	WR4 :  SELF  \ representation_relationship.rep_1 <> SELF \ representation_relationship.rep_2 ;
END_ENTITY; -- usage_view_connection_zone_terminal_shape_relationship


ENTITY evaluated_characteristic
	SUBTYPE OF (representation, representation_relationship);
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ representation_relationship_with_transformation || SELF \ evaluated_characteristic)))= 0 ;
	WR2 :  SELF  \ representation_relationship.rep_1 <> SELF \ representation_relationship.rep_2 ;
	WR3 :  SELF \ representation_relationship.name = '' ;
	WR4 :  SELF \ representation.name = '' ;
	WR5 :  SELF \ representation_relationship.rep_1.name = 'planned characteristic' ;
END_ENTITY; -- evaluated_characteristic


ENTITY evaluation_product_definition
	SUBTYPE OF (product_definition);
END_ENTITY; -- evaluation_product_definition


ENTITY known_source
	SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY; -- known_source


ENTITY pre_defined_parallel_datum_axis_symbol_3d_2d_relationship
	SUBTYPE OF (shape_definition_3d_intersection);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ shape_representation_relationship || SELF  \ shape_definition_3d_intersection || SELF \ pre_defined_parallel_datum_axis_symbol_3d_2d_relationship)))= 0 ;
END_ENTITY; -- pre_defined_parallel_datum_axis_symbol_3d_2d_relationship


ENTITY pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship
	SUBTYPE OF (shape_definition_3d_intersection);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ shape_representation_relationship || SELF  \ shape_definition_3d_intersection || SELF \ pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship)))= 0 ;
END_ENTITY; -- pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship


ENTITY pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship
	SUBTYPE OF (shape_definition_3d_intersection);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ representation || SELF  \ representation_relationship || SELF  \ shape_representation_relationship || SELF  \ shape_definition_3d_intersection || SELF \ pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship)))= 0 ;
END_ENTITY; -- pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship


ENTITY approximation_tolerance;
	tolerance : tolerance_select;
END_ENTITY; -- approximation_tolerance


ENTITY approximation_tolerance_deviation;
	tessellation_type : approximation_method;
	tolerances : SET [1:2] OF tolerance_deviation_select;
	definition_space : product_or_presentation_space;
WHERE
	WR1 : (HIINDEX(SELF.tolerances)= 1)XOR(TYPEOF(SELF.tolerances [ 1 ])<> TYPEOF(SELF.tolerances [ 2 ]));
END_ENTITY; -- approximation_tolerance_deviation


ENTITY approximation_tolerance_parameter;
	tolerances : SET [1:2] OF tolerance_parameter_select;
WHERE
	WR1 : (HIINDEX(SELF.tolerances)= 1)XOR(TYPEOF(SELF.tolerances [ 1 ])<> TYPEOF(SELF.tolerances [ 2 ]));
END_ENTITY; -- approximation_tolerance_parameter


ENTITY character_glyph_style_outline;
	outline_style : curve_style;
END_ENTITY; -- character_glyph_style_outline


ENTITY character_glyph_style_outline_with_characteristics
	SUBTYPE OF (character_glyph_style_outline);
	characteristics : fill_area_style;
END_ENTITY; -- character_glyph_style_outline_with_characteristics


ENTITY character_glyph_style_stroke;
	stroke_style : curve_style;
END_ENTITY; -- character_glyph_style_stroke


ENTITY context_dependent_invisibility
	SUBTYPE OF (invisibility);
	presentation_context : invisibility_context;
END_ENTITY; -- context_dependent_invisibility


ENTITY context_dependent_over_riding_styled_item
	SUBTYPE OF (over_riding_styled_item);
	style_context : SET [1:2] OF style_context_select;
WHERE
	WR1 : (SIZEOF(QUERY(sc <* SELF.style_context | 'REPRESENTATION_SCHEMA.REPRESENTATION' IN  TYPEOF(sc)))= 1)AND(SIZEOF(QUERY(sc <* SELF.style_context | 'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(sc)))= 1);
END_ENTITY; -- context_dependent_over_riding_styled_item


ENTITY curve_style;
	name : label;
	curve_font : curve_font_or_scaled_curve_font_select;
	curve_width : size_select;
	curve_colour : colour;
END_ENTITY; -- curve_style


ENTITY curve_style_curve_pattern
	SUBTYPE OF (geometric_representation_item);
	pattern : annotation_curve_occurrence;
	pattern_length : positive_length_measure;
END_ENTITY; -- curve_style_curve_pattern


ENTITY curve_style_curve_pattern_set
	SUBTYPE OF (curve_style_font, geometric_representation_item);
	pattern_set : SET [1:?] OF curve_style_curve_pattern;
END_ENTITY; -- curve_style_curve_pattern_set


ENTITY curve_style_font;
	name : label;
	pattern_list : LIST [1:?] OF curve_style_font_pattern;
END_ENTITY; -- curve_style_font


ENTITY curve_style_font_and_scaling;
	name : label;
	curve_font : curve_style_font_select;
	curve_font_scaling : REAL;
END_ENTITY; -- curve_style_font_and_scaling


ENTITY curve_style_font_pattern;
	visible_segment_length : positive_length_measure;
	invisible_segment_length : positive_length_measure;
END_ENTITY; -- curve_style_font_pattern


ENTITY curve_style_rendering;
	rendering_method : shading_curve_method;
	rendering_properties : surface_rendering_properties;
END_ENTITY; -- curve_style_rendering


ENTITY curve_style_wide
	SUBTYPE OF (curve_style_font);
	interior_style : fill_area_style;
END_ENTITY; -- curve_style_wide


ENTITY curve_style_with_ends_and_corners
	SUBTYPE OF (curve_style);
	curve_ends : squared_or_rounded;
	curve_corners : squared_or_rounded;
END_ENTITY; -- curve_style_with_ends_and_corners


ENTITY curve_style_with_extension
	SUBTYPE OF (curve_style);
	curve_extensions : length_measure;
END_ENTITY; -- curve_style_with_extension


ENTITY draughting_pre_defined_curve_font
	SUBTYPE OF (pre_defined_curve_font);
WHERE
	WR1 :  SELF.name IN [ 'continuous', 'chain', 'chain double dash', 'dashed', 'dotted' ] ;
END_ENTITY; -- draughting_pre_defined_curve_font


ENTITY externally_defined_curve_font
	SUBTYPE OF (externally_defined_item);
END_ENTITY; -- externally_defined_curve_font


ENTITY externally_defined_hatch_style
	SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY; -- externally_defined_hatch_style


ENTITY externally_defined_style
	SUBTYPE OF (externally_defined_item);
END_ENTITY; -- externally_defined_style


ENTITY externally_defined_tile
	SUBTYPE OF (externally_defined_item);
END_ENTITY; -- externally_defined_tile


ENTITY externally_defined_tile_style
	SUBTYPE OF (externally_defined_item, geometric_representation_item);
END_ENTITY; -- externally_defined_tile_style


ENTITY fill_area_style;
	name : label;
	fill_styles : SET [1:?] OF fill_style_select;
WHERE
	WR1 :  SIZEOF(QUERY(fill_style <* SELF.fill_styles | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FILL_AREA_STYLE_COLOUR' IN TYPEOF(fill_style)))<= 1 ;
END_ENTITY; -- fill_area_style


ENTITY fill_area_style_colour;
	name : label;
	fill_colour : colour;
END_ENTITY; -- fill_area_style_colour


ENTITY fill_area_style_hatching
	SUBTYPE OF (geometric_representation_item);
	hatch_line_appearance : curve_style;
	start_of_next_hatch_line : one_direction_repeat_factor;
	point_of_reference_hatch_line : cartesian_point;
	pattern_start : cartesian_point;
	hatch_line_angle : plane_angle_measure;
END_ENTITY; -- fill_area_style_hatching


ENTITY fill_area_style_tile_coloured_region
	SUBTYPE OF (geometric_representation_item);
	closed_curve : curve_or_annotation_curve_occurrence;
	region_colour : colour;
END_ENTITY; -- fill_area_style_tile_coloured_region


ENTITY fill_area_style_tile_curve_with_style
	SUBTYPE OF (geometric_representation_item);
	styled_curve : annotation_curve_occurrence;
END_ENTITY; -- fill_area_style_tile_curve_with_style


ENTITY fill_area_style_tile_symbol_with_style
	SUBTYPE OF (geometric_representation_item);
	symbol : annotation_symbol_occurrence;
END_ENTITY; -- fill_area_style_tile_symbol_with_style


ENTITY fill_area_style_tiles
	SUBTYPE OF (geometric_representation_item);
	tiling_pattern : two_direction_repeat_factor;
	tiles : SET [1:?] OF fill_area_style_tile_shape_select;
	tiling_scale : positive_ratio_measure;
END_ENTITY; -- fill_area_style_tiles


ENTITY invisibility;
	invisible_items : SET [1:?] OF invisible_item;
END_ENTITY; -- invisibility


ENTITY occlusion_precedence;
	higher_precedence : hiding_or_blanking_select;
	lower_precedence : hiding_or_blanking_select;
	occlusion_context : representation;
WHERE
	WR1 :  acyclic_occlusion_precedence(SELF , [ SELF.lower_precedence ]);
END_ENTITY; -- occlusion_precedence


ENTITY one_direction_repeat_factor
	SUBTYPE OF (geometric_representation_item);
	repeat_factor : vector;
END_ENTITY; -- one_direction_repeat_factor


ENTITY over_riding_styled_item
	SUBTYPE OF (styled_item);
	over_ridden_style : styled_item;
END_ENTITY; -- over_riding_styled_item


ENTITY point_style;
	name : label;
	marker : marker_select;
	marker_size : size_select;
	marker_colour : colour;
END_ENTITY; -- point_style


ENTITY pre_defined_character_spacing
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_character_spacing


ENTITY pre_defined_curve_font
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_curve_font


ENTITY pre_defined_hatch_style
	SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY; -- pre_defined_hatch_style


ENTITY pre_defined_marker
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_marker


ENTITY pre_defined_presentation_style
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_presentation_style


ENTITY pre_defined_size
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_size


ENTITY pre_defined_surface_side_style
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_surface_side_style


ENTITY pre_defined_tile
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_tile


ENTITY pre_defined_tile_style
	SUBTYPE OF (pre_defined_item, geometric_representation_item);
END_ENTITY; -- pre_defined_tile_style


ENTITY presentation_style_assignment;
	styles : SET [1:?] OF presentation_style_select;
WHERE
	WR1 :  SIZEOF(QUERY(style1 <* SELF.styles | NOT(SIZEOF(QUERY(style2 <*(SELF.styles - style1)| NOT((TYPEOF(style1)<> TYPEOF(style2))OR(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SURFACE_STYLE_USAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_STYLE' ] * TYPEOF(style1))= 1))))= 0)))= 0 ;
	WR2 :  SIZEOF(QUERY(style1 <* SELF.styles | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_STYLE_USAGE' IN TYPEOF(style1)))<= 2 ;
END_ENTITY; -- presentation_style_assignment


ENTITY presentation_style_by_context
	SUBTYPE OF (presentation_style_assignment);
	style_context : style_context_select;
END_ENTITY; -- presentation_style_by_context


ENTITY styled_item
	SUBTYPE OF (representation_item);
	styles : SET [1:?] OF presentation_style_assignment;
	item : representation_item;
WHERE
	WR1 : (SIZEOF(SELF.styles)= 1)XOR(SIZEOF(QUERY(pres_style <* SELF.styles | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(pres_style))))= 0);
END_ENTITY; -- styled_item


ENTITY surface_rendering_properties;
	rendered_colour : colour;
END_ENTITY; -- surface_rendering_properties


ENTITY surface_side_style;
	name : label;
	styles : SET [1:7] OF surface_style_element_select;
WHERE
	WR1 :  SIZEOF(QUERY(style1 <* SELF.styles | SIZEOF(QUERY(style2 <* SELF.styles - style1 | TYPEOF(style1)= TYPEOF(style2)))> 0))= 0 ;
END_ENTITY; -- surface_side_style


ENTITY surface_style_boundary;
	style_of_boundary : curve_or_render;
END_ENTITY; -- surface_style_boundary


ENTITY surface_style_control_grid;
	style_of_control_grid : curve_or_render;
END_ENTITY; -- surface_style_control_grid


ENTITY surface_style_fill_area;
	fill_area : fill_area_style;
END_ENTITY; -- surface_style_fill_area


ENTITY surface_style_parameter_line;
	style_of_parameter_lines : curve_or_render;
	direction_counts : SET [1:2] OF direction_count_select;
WHERE
	WR1 : (HIINDEX(SELF.direction_counts)= 1)XOR(TYPEOF(SELF.direction_counts [ 1 ])<> TYPEOF(SELF.direction_counts [ 2 ]));
END_ENTITY; -- surface_style_parameter_line


ENTITY surface_style_reflectance_ambient;
	ambient_reflectance : REAL;
END_ENTITY; -- surface_style_reflectance_ambient


ENTITY surface_style_reflectance_ambient_diffuse
	SUBTYPE OF (surface_style_reflectance_ambient);
	diffuse_reflectance : REAL;
END_ENTITY; -- surface_style_reflectance_ambient_diffuse


ENTITY surface_style_reflectance_ambient_diffuse_specular
	SUBTYPE OF (surface_style_reflectance_ambient_diffuse);
	specular_reflectance : REAL;
	specular_exponent : REAL;
	specular_colour : colour;
END_ENTITY; -- surface_style_reflectance_ambient_diffuse_specular


ENTITY surface_style_rendering;
	rendering_method : shading_surface_method;
	surface_colour : colour;
END_ENTITY; -- surface_style_rendering


ENTITY surface_style_rendering_with_properties
	SUBTYPE OF (surface_style_rendering);
	properties : SET [1:2] OF rendering_properties_select;
WHERE
	WR1 : (HIINDEX(SELF.properties)= 1)XOR(TYPEOF(SELF.properties [ 1 ])<> TYPEOF(SELF.properties [ 2 ]));
END_ENTITY; -- surface_style_rendering_with_properties


ENTITY surface_style_segmentation_curve;
	style_of_segmentation_curve : curve_or_render;
END_ENTITY; -- surface_style_segmentation_curve


ENTITY surface_style_silhouette;
	style_of_silhouette : curve_or_render;
END_ENTITY; -- surface_style_silhouette


ENTITY surface_style_transparent;
	transparency : REAL;
WHERE
	WR1 :  { 0.0 <= transparency <= 1.0 } ;
END_ENTITY; -- surface_style_transparent


ENTITY surface_style_usage;
	side : surface_side;
	style : surface_side_style_select;
END_ENTITY; -- surface_style_usage


ENTITY symbol_colour;
	colour_of_symbol : colour;
END_ENTITY; -- symbol_colour


ENTITY symbol_element_style;
	style_of_symbol : presentation_style_assignment;
WHERE
	WR1 :  SIZEOF(QUERY(style <* SELF.style_of_symbol.styles | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMBOL_STYLE' IN TYPEOF(style)))= 0 ;
	WR2 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRESENTATION_STYLE_BY_CONTEXT' IN TYPEOF(SELF.style_of_symbol));
END_ENTITY; -- symbol_element_style


ENTITY symbol_style;
	name : label;
	style_of_symbol : symbol_style_select;
END_ENTITY; -- symbol_style


ENTITY text_style;
	name : label;
	character_appearance : character_style_select;
END_ENTITY; -- text_style


ENTITY text_style_for_defined_font;
	text_colour : colour;
END_ENTITY; -- text_style_for_defined_font


ENTITY text_style_with_box_characteristics
	SUBTYPE OF (text_style);
	characteristics : SET [1:4] OF box_characteristic_select;
WHERE
	WR1 :  SIZEOF(QUERY(c1 <* SELF.characteristics | SIZEOF(QUERY(c2 <* SELF.characteristics - c1 | TYPEOF(c1)= TYPEOF(c2)))> 0))= 0 ;
END_ENTITY; -- text_style_with_box_characteristics


ENTITY text_style_with_justification
	SUBTYPE OF (text_style);
	justification : text_justification;
END_ENTITY; -- text_style_with_justification


ENTITY text_style_with_mirror
	SUBTYPE OF (text_style);
	mirror_placement : axis2_placement;
END_ENTITY; -- text_style_with_mirror


ENTITY text_style_with_spacing
	SUBTYPE OF (text_style);
	character_spacing : character_spacing_select;
END_ENTITY; -- text_style_with_spacing


ENTITY two_direction_repeat_factor
	SUBTYPE OF (one_direction_repeat_factor);
	second_repeat_factor : vector;
END_ENTITY; -- two_direction_repeat_factor


ENTITY annotation_curve_occurrence
	SUBTYPE OF (annotation_occurrence);
WHERE
	WR1 :  'GEOMETRY_SCHEMA.CURVE' IN TYPEOF(SELF \ styled_item.item);
END_ENTITY; -- annotation_curve_occurrence


ENTITY annotation_fill_area
	SUBTYPE OF (geometric_representation_item);
	boundaries : SET [1:?] OF curve;
END_ENTITY; -- annotation_fill_area


ENTITY annotation_fill_area_occurrence
	SUBTYPE OF (annotation_occurrence);
	fill_style_target : point;
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_FILL_AREA' IN TYPEOF(SELF.item);
END_ENTITY; -- annotation_fill_area_occurrence


ENTITY annotation_occurrence
	SUPERTYPE OF (ONEOF (annotation_point_occurrence, annotation_curve_occurrence, annotation_fill_area_occurrence, annotation_text_occurrence, annotation_symbol_occurrence))
	SUBTYPE OF (styled_item);
WHERE
	WR1 :  'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
END_ENTITY; -- annotation_occurrence


ENTITY annotation_occurrence_relationship;
	name : label;
	description : text;
	relating_annotation_occurrence : annotation_occurrence;
	related_annotation_occurrence : annotation_occurrence;
END_ENTITY; -- annotation_occurrence_relationship


ENTITY annotation_point_occurrence
	SUBTYPE OF (annotation_occurrence);
WHERE
	WR1 :  'GEOMETRY_SCHEMA.POINT' IN TYPEOF(SELF \ styled_item.item);
END_ENTITY; -- annotation_point_occurrence


ENTITY annotation_symbol
	SUBTYPE OF (mapped_item);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMBOL_REPRESENTATION_MAP' IN TYPEOF(SELF \ mapped_item.mapping_source);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMBOL_TARGET' IN TYPEOF(SELF \ mapped_item.mapping_target);
	WR3 :  'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
END_ENTITY; -- annotation_symbol


ENTITY annotation_symbol_occurrence
	SUBTYPE OF (annotation_occurrence);
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_SYMBOL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEFINED_SYMBOL' ] * TYPEOF(SELF \ styled_item.item))> 0 ;
END_ENTITY; -- annotation_symbol_occurrence


ENTITY annotation_table
	SUBTYPE OF (annotation_symbol);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TABLE_REPRESENTATION' IN TYPEOF(SELF \ mapped_item.mapping_source.mapped_representation);
END_ENTITY; -- annotation_table


ENTITY annotation_table_occurrence
	SUBTYPE OF (annotation_symbol_occurrence);
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TABLE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEFINED_TABLE' ] * TYPEOF(SELF \ styled_item.item))> 0 ;
END_ENTITY; -- annotation_table_occurrence


ENTITY annotation_text
	SUBTYPE OF (mapped_item);
WHERE
	WR1 :  'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF(SELF \ mapped_item.mapping_target);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TEXT_STRING_REPRESENTATION' IN TYPEOF(SELF \ mapped_item.mapping_source.mapped_representation);
	WR3 :  'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
END_ENTITY; -- annotation_text


ENTITY annotation_text_character
	SUBTYPE OF (mapped_item);
	alignment : text_alignment;
WHERE
	WR1 :  'PRESENTATION_RESOURCE_SCHEMA.CHARACTER_GLYPH_SYMBOL' IN TYPEOF(SELF \ mapped_item.mapping_source.mapped_representation);
	WR2 :  'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF(SELF \ mapped_item.mapping_target);
	WR3 :  'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
END_ENTITY; -- annotation_text_character


ENTITY annotation_text_occurrence
	SUBTYPE OF (annotation_occurrence);
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TEXT_LITERAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT_CHARACTER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEFINED_CHARACTER_GLYPH', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_TEXT' ] * TYPEOF(SELF \ styled_item.item))> 0 ;
END_ENTITY; -- annotation_text_occurrence


ENTITY annotation_text_with_associated_curves
	SUBTYPE OF (annotation_text);
	associated_curves : SET [1:?] OF curve;
END_ENTITY; -- annotation_text_with_associated_curves


ENTITY annotation_text_with_blanking_box
	SUBTYPE OF (annotation_text);
	blanking : planar_box;
END_ENTITY; -- annotation_text_with_blanking_box


ENTITY annotation_text_with_delineation
	SUBTYPE OF (annotation_text);
	delineation : text_delineation;
END_ENTITY; -- annotation_text_with_delineation


ENTITY annotation_text_with_extent
	SUBTYPE OF (annotation_text);
	extent : planar_extent;
END_ENTITY; -- annotation_text_with_extent


ENTITY composite_text
	SUBTYPE OF (geometric_representation_item);
	collected_text : SET [2:?] OF text_or_character;
WHERE
	WR1 :  acyclic_composite_text(SELF , SELF.collected_text);
END_ENTITY; -- composite_text


ENTITY composite_text_with_associated_curves
	SUBTYPE OF (composite_text);
	associated_curves : SET [1:?] OF curve;
END_ENTITY; -- composite_text_with_associated_curves


ENTITY composite_text_with_blanking_box
	SUBTYPE OF (composite_text);
	blanking : planar_box;
END_ENTITY; -- composite_text_with_blanking_box


ENTITY composite_text_with_delineation
	SUBTYPE OF (composite_text);
	delineation : text_delineation;
END_ENTITY; -- composite_text_with_delineation


ENTITY composite_text_with_extent
	SUBTYPE OF (composite_text);
	extent : planar_extent;
END_ENTITY; -- composite_text_with_extent


ENTITY defined_character_glyph
	SUBTYPE OF (geometric_representation_item);
	definition : defined_glyph_select;
	placement : axis2_placement;
END_ENTITY; -- defined_character_glyph


ENTITY defined_symbol
	SUBTYPE OF (geometric_representation_item);
	definition : defined_symbol_select;
	target : symbol_target;
END_ENTITY; -- defined_symbol


ENTITY defined_table
	SUBTYPE OF (defined_symbol);
END_ENTITY; -- defined_table


ENTITY externally_defined_character_glyph
	SUBTYPE OF (externally_defined_item);
END_ENTITY; -- externally_defined_character_glyph


ENTITY externally_defined_symbol
	SUBTYPE OF (externally_defined_item);
END_ENTITY; -- externally_defined_symbol


ENTITY pre_defined_character_glyph
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_character_glyph


ENTITY pre_defined_symbol
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_symbol


ENTITY symbol_representation
	SUBTYPE OF (representation);
END_ENTITY; -- symbol_representation


ENTITY symbol_representation_map
	SUBTYPE OF (representation_map);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMBOL_REPRESENTATION' IN TYPEOF(SELF \ representation_map.mapped_representation);
	WR2 :  'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN TYPEOF(SELF \ representation_map.mapping_origin);
END_ENTITY; -- symbol_representation_map


ENTITY symbol_representation_relationship
	SUBTYPE OF (representation_relationship_with_transformation);
WHERE
	WR1 :  acyclic_symbol_representation_relationship(SELF , [ SELF \ representation_relationship.rep_2 ]);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMBOL_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_1);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMBOL_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_2);
END_ENTITY; -- symbol_representation_relationship


ENTITY symbol_representation_with_blanking_box
	SUBTYPE OF (symbol_representation);
	blanking : planar_box;
WHERE
	WR1 :  item_in_context(SELF.blanking, SELF \ representation.context_of_items);
END_ENTITY; -- symbol_representation_with_blanking_box


ENTITY symbol_target
	SUBTYPE OF (geometric_representation_item);
	placement : axis2_placement;
	x_scale : positive_ratio_measure;
	y_scale : positive_ratio_measure;
END_ENTITY; -- symbol_target


ENTITY table_record_field_representation
	SUBTYPE OF (symbol_representation);
WHERE
	WR1 : (SIZEOF(USEDIN(SELF , 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2'))> 0)OR(SIZEOF(QUERY(map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_MAP.' + 'MAPPED_REPRESENTATION')| SIZEOF(QUERY(mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.' + 'MAPPED_ITEM.' + 'MAPPING_SOURCE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TABLE_RECORD_REPRESENTATION' IN TYPEOF(using_representations(mi))))> 0))> 0);
END_ENTITY; -- table_record_field_representation


ENTITY table_record_field_representation_with_clipping_box
	SUBTYPE OF (table_record_field_representation);
	clipping_box : planar_box;
WHERE
	WR1 :  item_in_context(SELF.clipping_box, SELF \ representation.context_of_items);
END_ENTITY; -- table_record_field_representation_with_clipping_box


ENTITY table_record_representation
	SUBTYPE OF (symbol_representation);
WHERE
	WR1 : (SIZEOF(USEDIN(SELF , 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2'))> 0)OR(SIZEOF(QUERY(map_item <* USEDIN(SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_MAP.' + 'MAPPED_REPRESENTATION')| SIZEOF(QUERY(mi <* USEDIN(map_item, 'REPRESENTATION_SCHEMA.' + 'MAPPED_ITEM.' + 'MAPPING_SOURCE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TABLE_REPRESENTATION' IN TYPEOF(using_representations(mi))))> 0))> 0);
END_ENTITY; -- table_record_representation


ENTITY table_representation
	SUBTYPE OF (symbol_representation);
END_ENTITY; -- table_representation


ENTITY table_representation_relationship
	SUBTYPE OF (symbol_representation_relationship);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TABLE_RECORD_REPRESENTATION' IN  TYPEOF(SELF  \ representation_relationship.rep_1))XOR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TABLE_RECORD_FIELD_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_2));
	WR2 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TABLE_REPRESENTATION' IN  TYPEOF(SELF  \ representation_relationship.rep_1))XOR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TABLE_RECORD_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_2));
	WR3 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TABLE_RECORD_FIELD_REPRESENTATION' IN  TYPEOF(SELF  \ representation_relationship.rep_1))XOR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TABLE_RECORD_FIELD_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_2));
END_ENTITY; -- table_representation_relationship


ENTITY table_text_relationship
	SUBTYPE OF (annotation_occurrence_relationship);
	field : table_record_field_representation;
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TABLE_OCCURRENCE' IN TYPEOF(SELF \ annotation_occurrence_relationship.relating_annotation_occurrence);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TABLE' IN TYPEOF(SELF \ annotation_occurrence_relationship.relating_annotation_occurrence \ styled_item.item);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT_OCCURRENCE' IN TYPEOF(SELF \ annotation_occurrence_relationship.related_annotation_occurrence);
	WR4 :  field_in_table(SELF.field, SELF \ annotation_occurrence_relationship.relating_annotation_occurrence);
END_ENTITY; -- table_text_relationship


ENTITY text_literal
	SUBTYPE OF (geometric_representation_item);
	literal : presentable_text;
	placement : axis2_placement;
	alignment : text_alignment;
	path : text_path;
	font : font_select;
END_ENTITY; -- text_literal


ENTITY text_literal_with_associated_curves
	SUBTYPE OF (text_literal);
	associated_curves : SET [1:?] OF curve;
END_ENTITY; -- text_literal_with_associated_curves


ENTITY text_literal_with_blanking_box
	SUBTYPE OF (text_literal);
	blanking : planar_box;
END_ENTITY; -- text_literal_with_blanking_box


ENTITY text_literal_with_delineation
	SUBTYPE OF (text_literal);
	delineation : text_delineation;
END_ENTITY; -- text_literal_with_delineation


ENTITY text_literal_with_extent
	SUBTYPE OF (text_literal);
	extent : planar_extent;
END_ENTITY; -- text_literal_with_extent


ENTITY text_string_representation
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(item <* SELF \ representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TEXT_LITERAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT_CHARACTER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEFINED_CHARACTER_GLYPH', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_TEXT', 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' ] * TYPEOF(item))= 0))= 0 ;
	WR2 :  SIZEOF(QUERY(item <* SELF \ representation.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TEXT_LITERAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT_CHARACTER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEFINED_CHARACTER_GLYPH', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_TEXT' ] * TYPEOF(item))= 0)))>= 1 ;
	WR3 :  SIZEOF(QUERY(a2p <* QUERY(item <* SELF  \ representation.items | 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' IN  TYPEOF(item))| NOT((SIZEOF(QUERY(at <* QUERY(item <* SELF  \ representation.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANNOTATION_TEXT' IN  TYPEOF(item))|(at \ mapped_item.mapping_target :=: a2p)))>= 1)OR(SIZEOF(QUERY(atc <* QUERY(item <* SELF \ representation.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANNOTATION_TEXT_CHARACTER' IN TYPEOF(item))|(atc \ mapped_item.mapping_target :=: a2p)))>= 1))))= 0 ;
END_ENTITY; -- text_string_representation


ENTITY area_dependent_annotation_representation
	SUBTYPE OF (presentation_representation);
WHERE
	WR1 :  SIZEOF(QUERY(item <* SELF \ representation.items | NOT(SIZEOF([ 'PRESENTATION_DEFINITION_SCHEMA.' + 'ANNOTATION_OCCURRENCE', 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' ] * TYPEOF(item))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(item <* SELF \ representation.items |('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN TYPEOF(item))))>= 1 ;
END_ENTITY; -- area_dependent_annotation_representation


ENTITY area_in_set;
	area : presentation_area;
	in_set : presentation_set;
END_ENTITY; -- area_in_set


ENTITY background_colour
	SUBTYPE OF (colour);
	presentation : area_or_view;
UNIQUE
	UR1 : presentation;
END_ENTITY; -- background_colour


ENTITY camera_image
	SUBTYPE OF (mapped_item);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CAMERA_USAGE' IN TYPEOF(SELF \ mapped_item.mapping_source);
	WR2 :  'PRESENTATION_RESOURCE_SCHEMA.PLANAR_BOX' IN TYPEOF(SELF \ mapped_item.mapping_target);
	WR3 :  'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_ITEM' IN TYPEOF(SELF);
END_ENTITY; -- camera_image


ENTITY camera_image_3d_with_scale
	SUBTYPE OF (camera_image);
DERIVE
	scale : positive_ratio_measure := ((SELF  \ mapped_item.mapping_target \ planar_extent.size_in_x)/(SELF \ mapped_item.mapping_source.mapping_origin \ camera_model_d3.perspective_of_volume.view_window.size_in_x));
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CAMERA_MODEL_D3' IN TYPEOF(SELF \ mapped_item.mapping_source.mapping_origin));
	WR2 :  aspect_ratio(SELF  \ mapped_item.mapping_target)= aspect_ratio(SELF \ mapped_item.mapping_source.mapping_origin \ camera_model_d3.perspective_of_volume.view_window);
	WR3 :  SELF  \ mapped_item.mapping_source.mapping_origin \ camera_model_d3.perspective_of_volume.front_plane_clipping AND SELF \ mapped_item.mapping_source.mapping_origin \ camera_model_d3.perspective_of_volume.view_volume_sides_clipping ;
	WR4 : (SELF  \ mapped_item.mapping_target \ planar_extent.size_in_x > 0)AND(SELF \ mapped_item.mapping_target \ planar_extent.size_in_y > 0);
	WR5 : (SELF  \ mapped_item.mapping_source.mapping_origin \ camera_model_d3.perspective_of_volume.view_window.size_in_x > 0)AND(SELF \ mapped_item.mapping_source.mapping_origin \ camera_model_d3.perspective_of_volume.view_window.size_in_y > 0);
	WR6 : ('GEOMETRY_SCHEMA.' + 'AXIS2_PLACEMENT_2D' IN  TYPEOF(SELF  \ mapped_item.mapping_target \ planar_box.placement))AND NOT('GEOMETRY_SCHEMA.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(SELF \ mapped_item.mapping_target \ planar_box.placement));
END_ENTITY; -- camera_image_3d_with_scale


ENTITY camera_model
	SUPERTYPE OF (ONEOF (camera_model_d2, camera_model_d3))
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 : (SIZEOF(USEDIN(SELF , 'REPRESENTATION_SCHEMA.' + 'ITEM_DEFINED_TRANSFORMATION.' + 'TRANSFORM_ITEM_1'))+ SIZEOF(USEDIN(SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_MAP.MAPPING_ORIGIN')))> 0 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'PRESENTATION_APPEARANCE_SCHEMA.' + 'STYLED_ITEM.ITEM'))= 0 ;
END_ENTITY; -- camera_model


ENTITY camera_model_d2
	SUBTYPE OF (camera_model);
	view_window : planar_box;
	view_window_clipping : BOOLEAN;
WHERE
	WR1 :  SELF \ geometric_representation_item.dim = 2 ;
END_ENTITY; -- camera_model_d2


ENTITY camera_model_d2_shape_clipping
	SUBTYPE OF (camera_model_d2);
	shape_clipping : curve;
END_ENTITY; -- camera_model_d2_shape_clipping


ENTITY camera_model_d3
	SUBTYPE OF (camera_model);
	view_reference_system : axis2_placement_3d;
	perspective_of_volume : view_volume;
WHERE
	WR1 : (dot_product(SELF.view_reference_system.p [ 3 ], SELF.perspective_of_volume.view_window.placement.p [ 3 ])= 1.0)AND(SELF.view_reference_system.location.coordinates [ 3 ] = SELF.perspective_of_volume.view_window.placement.location.coordinates [ 3 ]);
	WR2 :  SELF \ geometric_representation_item.dim = 3 ;
END_ENTITY; -- camera_model_d3


ENTITY camera_model_d3_multi_clipping
	SUBTYPE OF (camera_model_d3);
	shape_clipping : SET [1:?] OF plane;
END_ENTITY; -- camera_model_d3_multi_clipping


ENTITY camera_model_d3_with_hlhsr
	SUBTYPE OF (camera_model_d3);
	hidden_line_surface_removal : BOOLEAN;
END_ENTITY; -- camera_model_d3_with_hlhsr


ENTITY camera_model_with_light_sources
	SUBTYPE OF (camera_model_d3);
	sources : SET [1:?] OF light_source;
END_ENTITY; -- camera_model_with_light_sources


ENTITY camera_usage
	SUBTYPE OF (representation_map);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION' IN TYPEOF(SELF \ representation_map.mapped_representation));
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CAMERA_MODEL' IN TYPEOF(SELF \ representation_map.mapping_origin);
END_ENTITY; -- camera_usage


ENTITY graphical_transformation
	SUBTYPE OF (item_defined_transformation);
WHERE
	WR1 :  'GEOMETRY_SCHEMA.AXIS2_PLACEMENT_2D' IN TYPEOF(SELF \ item_defined_transformation.transform_item_1);
	WR2 :  'PRESENTATION_RESOURCE_SCHEMA.PRESENTATION_SCALED_PLACEMENT' IN TYPEOF(SELF \ item_defined_transformation.transform_item_2);
END_ENTITY; -- graphical_transformation


ENTITY light_source
	SUPERTYPE OF (ONEOF (light_source_ambient, light_source_directional, light_source_positional, light_source_spot))
	SUBTYPE OF (geometric_representation_item);
	light_colour : colour;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'PRESENTATION_APPEARANCE_SCHEMA.' + 'STYLED_ITEM.ITEM'))= 0 ;
END_ENTITY; -- light_source


ENTITY light_source_ambient
	SUBTYPE OF (light_source);
END_ENTITY; -- light_source_ambient


ENTITY light_source_directional
	SUBTYPE OF (light_source);
	orientation : direction;
END_ENTITY; -- light_source_directional


ENTITY light_source_positional
	SUBTYPE OF (light_source);
	position : cartesian_point;
	constant_attenuation : REAL;
	distance_attenuation : REAL;
END_ENTITY; -- light_source_positional


ENTITY light_source_spot
	SUBTYPE OF (light_source);
	position : cartesian_point;
	orientation : direction;
	concentration_exponent : REAL;
	constant_attenuation : REAL;
	distance_attenuation : REAL;
	spread_angle : positive_plane_angle_measure;
END_ENTITY; -- light_source_spot


ENTITY presentation_area
	SUBTYPE OF (presentation_representation);
WHERE
	WR1 : ((SIZEOF(QUERY(ais <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AREA_IN_SET.AREA')| SIZEOF(USEDIN(ais, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRESENTATION_SIZE.UNIT'))= 1))> 0)OR(SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRESENTATION_SIZE.UNIT'))= 1));
END_ENTITY; -- presentation_area


ENTITY presentation_layer_assignment;
	name : label;
	description : text;
	assigned_items : SET [1:?] OF layered_item;
END_ENTITY; -- presentation_layer_assignment


ENTITY presentation_layer_usage;
	assignment : presentation_layer_assignment;
	presentation : presentation_representation;
UNIQUE
	UR1 : assignment, presentation;
END_ENTITY; -- presentation_layer_usage


ENTITY presentation_representation
	SUBTYPE OF (representation);
WHERE
	WR1 :  SELF \ representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2 ;
	WR2 :  'GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF \ representation.context_of_items);
END_ENTITY; -- presentation_representation


ENTITY presentation_representation_relationship
	SUBTYPE OF (representation_relationship_with_transformation);
WHERE
	WR1 :  'PRESENTATION_DEFINITION_SCHEMA.PRESENTATION_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_1);
	WR2 :  'PRESENTATION_DEFINITION_SCHEMA.PRESENTATION_REPRESENTATION' IN TYPEOF(SELF \ representation_relationship.rep_2);
	WR3 :  acyclic_presentation_representation_relationship(SELF , [ SELF \ representation_relationship.rep_2 ]);
	WR4 :  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRESENTATION_AREA' IN TYPEOF(SELF  \ representation_relationship.rep_1))AND NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DATA_REPRESENTATION_VIEW', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VIEW_DEPENDENT_ANNOTATION_REPRESENTATION' ] * TYPEOF(SELF \ representation_relationship.rep_2))= 0));
	WR5 :  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRESENTATION_VIEW' IN TYPEOF(SELF  \ representation_relationship.rep_1))AND NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRESENTATION_AREA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRESENTATION_VIEW', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AREA_DEPENDENT_ANNOTATION_REPRESENTATION' ] * TYPEOF(SELF \ representation_relationship.rep_2))= 0));
	WR6 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRESENTATION_VIEW' IN  TYPEOF(SELF  \ representation_relationship.rep_2)))XOR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRESENTATION_AREA' IN TYPEOF(SELF \ representation_relationship.rep_1));
	WR7 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DATA_REPRESENTATION_VIEW' IN(TYPEOF(SELF  \ representation_relationship.rep_1)+ TYPEOF(SELF  \ representation_relationship.rep_2))))XOR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRESENTATION_VIEW' IN  TYPEOF(SELF  \ representation_relationship.rep_1))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT_DATA_REPRESENTATION_VIEW' IN TYPEOF(SELF \ representation_relationship.rep_2));
	WR8 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GRAPHICAL_TRANSFORMATION' IN TYPEOF(SELF \ representation_relationship_with_transformation.transformation_operator);
END_ENTITY; -- presentation_representation_relationship


ENTITY presentation_set;
INVERSE
	areas: SET [1:?] OF area_in_set FOR in_set;
END_ENTITY; -- presentation_set


ENTITY presentation_size;
	unit : presentation_size_assignment_select;
	size : planar_box;
WHERE
	WR1 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRESENTATION_REPRESENTATION' IN  TYPEOF(SELF.unit))AND  item_in_context(SELF.size, SELF.unit \ representation.context_of_items))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AREA_IN_SET' IN TYPEOF(SELF.unit))AND(SIZEOF(QUERY(ais <* SELF.unit \ area_in_set.in_set.areas | NOT item_in_context(SELF.size, ais.area \ representation.context_of_items)))= 0));
END_ENTITY; -- presentation_size


ENTITY presentation_view
	SUBTYPE OF (presentation_representation);
END_ENTITY; -- presentation_view


ENTITY presented_item
	ABSTRACT SUPERTYPE;
END_ENTITY; -- presented_item


ENTITY presented_item_representation;
	presentation : presentation_representation_select;
	item : presented_item;
END_ENTITY; -- presented_item_representation


ENTITY product_data_representation_view
	SUBTYPE OF (presentation_representation);
WHERE
	WR1 :  SIZEOF(QUERY(item <* SELF \ representation.items | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CAMERA_IMAGE', 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' ] * TYPEOF(item))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(item <* SELF \ representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CAMERA_IMAGE' IN TYPEOF(item))))>= 1 ;
END_ENTITY; -- product_data_representation_view


ENTITY representation_item_dependent_layer_assignment
	SUBTYPE OF (presentation_layer_assignment);
	item_context : representation_item;
END_ENTITY; -- representation_item_dependent_layer_assignment


ENTITY view_dependent_annotation_representation
	SUBTYPE OF (presentation_representation);
WHERE
	WR1 :  SIZEOF(QUERY(item <* SELF \ representation.items | NOT(SIZEOF([ 'PRESENTATION_DEFINITION_SCHEMA.' + 'ANNOTATION_OCCURRENCE', 'GEOMETRY_SCHEMA.AXIS2_PLACEMENT' ] * TYPEOF(item))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(item <* SELF \ representation.items |('PRESENTATION_DEFINITION_SCHEMA.ANNOTATION_OCCURRENCE' IN TYPEOF(item))))>= 1 ;
END_ENTITY; -- view_dependent_annotation_representation


ENTITY view_volume
	SUBTYPE OF (founded_item);
	projection_type : central_or_parallel;
	projection_point : cartesian_point;
	view_plane_distance : length_measure;
	front_plane_distance : length_measure;
	front_plane_clipping : BOOLEAN;
	back_plane_distance : length_measure;
	back_plane_clipping : BOOLEAN;
	view_volume_sides_clipping : BOOLEAN;
	view_window : planar_box;
END_ENTITY; -- view_volume


ENTITY character_glyph_font_usage;
	character : character_glyph_symbol;
	font : text_font;
END_ENTITY; -- character_glyph_font_usage


ENTITY character_glyph_symbol
	SUBTYPE OF (symbol_representation);
	character_box : planar_extent;
	baseline_ratio : ratio_measure;
DERIVE
	box_height : length_measure :=  character_box.size_in_y ;
WHERE
	WR1 :  { 0.0 <= baseline_ratio <= 1.0 } ;
	WR2 :  item_in_context(SELF.character_box, SELF \ representation.context_of_items);
	WR3 :  'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' IN TYPEOF(SELF.box_height);
END_ENTITY; -- character_glyph_symbol


ENTITY character_glyph_symbol_outline
	SUBTYPE OF (character_glyph_symbol);
	outlines : SET [1:?] OF annotation_fill_area;
WHERE
	WR1 :  SELF.outlines <= SELF \ representation.items ;
END_ENTITY; -- character_glyph_symbol_outline


ENTITY character_glyph_symbol_stroke
	SUBTYPE OF (character_glyph_symbol);
	strokes : SET [1:?] OF curve;
WHERE
	WR1 :  SELF.strokes <= SELF \ representation.items ;
END_ENTITY; -- character_glyph_symbol_stroke


ENTITY colour;
END_ENTITY; -- colour


ENTITY colour_associated
	SUBTYPE OF (colour);
	name : label;
	variable_to_be_shown : SET [1:?] OF REAL;
	mapping : colour_association_table;
END_ENTITY; -- colour_associated


ENTITY colour_association_table;
	discrete_states_with_colours : LIST [1:?] OF state_variable_with_colour;
	interpolation_type : staircase_or_linear;
END_ENTITY; -- colour_association_table


ENTITY colour_rgb
	SUBTYPE OF (colour_specification);
	red : REAL;
	green : REAL;
	blue : REAL;
WHERE
	WR1 :  { 0.0 <= red <= 1.0 } ;
	WR2 :  { 0.0 <= green <= 1.0 } ;
	WR3 :  { 0.0 <= blue <= 1.0 } ;
END_ENTITY; -- colour_rgb


ENTITY colour_specification
	SUBTYPE OF (colour);
	name : label;
END_ENTITY; -- colour_specification


ENTITY draughting_pre_defined_colour
	SUBTYPE OF (pre_defined_colour);
WHERE
	WR1 :  SELF.name IN [ 'red', 'green', 'blue', 'yellow', 'magenta', 'cyan', 'black', 'white' ] ;
END_ENTITY; -- draughting_pre_defined_colour


ENTITY draughting_pre_defined_text_font
	SUBTYPE OF (pre_defined_text_font);
WHERE
	WR1 :  SELF.name IN [ 'ISO 3098-1 font A', 'ISO 3098-1 font B' ] ;
END_ENTITY; -- draughting_pre_defined_text_font


ENTITY externally_defined_text_font
	SUBTYPE OF (externally_defined_item);
END_ENTITY; -- externally_defined_text_font


ENTITY planar_box
	SUBTYPE OF (planar_extent);
	placement : axis2_placement;
END_ENTITY; -- planar_box


ENTITY planar_extent
	SUBTYPE OF (geometric_representation_item);
	size_in_x : length_measure;
	size_in_y : length_measure;
END_ENTITY; -- planar_extent


ENTITY pre_defined_colour
	SUBTYPE OF (pre_defined_item, colour);
END_ENTITY; -- pre_defined_colour


ENTITY pre_defined_text_font
	SUBTYPE OF (pre_defined_item);
END_ENTITY; -- pre_defined_text_font


ENTITY presentation_scaled_placement
	SUBTYPE OF (geometric_representation_item);
	placement : axis2_placement;
	scaling : positive_ratio_measure;
END_ENTITY; -- presentation_scaled_placement


ENTITY state_variable_with_colour;
	state_variable : REAL;
	associated_colour : colour_specification;
END_ENTITY; -- state_variable_with_colour


ENTITY text_font;
	id : identifier;
	name : label;
	description : text;
INVERSE
	glyphs: SET [1:?] OF character_glyph_font_usage FOR font;
END_ENTITY; -- text_font


ENTITY text_font_family;
	id : identifier;
	name : label;
	description : text;
INVERSE
	fonts: SET [1:?] OF text_font_in_family FOR family;
END_ENTITY; -- text_font_family


ENTITY text_font_in_family;
	font : text_font;
	family : text_font_family;
END_ENTITY; -- text_font_in_family


ENTITY printed_connector_template_terminal_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : relating_shape_aspect, related_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'connector')AND(sar.relating_shape_aspect \ shape_aspect.description = 'printed connector template'))))= 1 ;
	WR2 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF  \ shape_aspect_relationship.relating_shape_aspect))AND(SELF \ shape_aspect_relationship.relating_shape_aspect \ shape_aspect.description = 'interface terminal'));
	WR3 : (('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(SELF  \ shape_aspect_relationship.related_shape_aspect))AND(SELF \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'join terminal'));
	WR4 :  SELF  \ shape_aspect_relationship.relating_shape_aspect :<>: SELF \ shape_aspect_relationship.related_shape_aspect ;
END_ENTITY; -- printed_connector_template_terminal_relationship


ENTITY printed_part_cross_section_template_terminal
	SUBTYPE OF (printed_part_template_terminal);
WHERE
	WR1 :  SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'cross section definition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(am.relating_shape_aspect))AND(am.relating_shape_aspect \ shape_aspect.description = 'printed part cross section template')))= 1 ;
	WR2 :  SIZEOF(QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN  TYPEOF(ga.assigned_group))AND(ga.assigned_group.name IN [ 'area edge segment', 'curve edge segment' ]))))= 1 ;
	WR3 :  SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to left of terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))<= 1 ;
	WR4 :  SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to right of terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))<= 1 ;
	WR5 :  SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to top of terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))<= 1 ;
	WR6 :  SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to bottom of terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))<= 1 ;
	WR7 :  NOT((SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  left of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1)AND(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  right of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'material to  right of  terminal')OR(sar \ shape_aspect_relationship.name = 'material to left of terminal'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))= 2);
	WR8 :  NOT((SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  left of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1)AND(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  top of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'material to  top of  terminal')OR(sar \ shape_aspect_relationship.name = 'material to left of terminal'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))= 2);
	WR9 :  NOT((SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  left of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1)AND(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  bottom of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'material to  bottom of  terminal')OR(sar \ shape_aspect_relationship.name = 'material to left of terminal'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))= 2);
	WR10 :  NOT((SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  top of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1)AND(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  right of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'material to  right of  terminal')OR(sar \ shape_aspect_relationship.name = 'material to top of terminal'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))= 2);
	WR11 :  NOT((SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  bottom of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1)AND(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  right of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'material to  right of  terminal')OR(sar \ shape_aspect_relationship.name = 'material to bottom of terminal'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))= 2);
	WR12 :  NOT((SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  top of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1)AND(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'material to  bottom of  terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN  TYPEOF(am.relating_shape_aspect))))= 1))OR(SIZEOF(QUERY(am <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'material to  top of  terminal')OR(sar \ shape_aspect_relationship.name = 'material to bottom of terminal'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL_LINK' IN TYPEOF(am.relating_shape_aspect))))= 2);
END_ENTITY; -- printed_part_cross_section_template_terminal


ENTITY printed_part_template_connected_terminals_definition
	SUBTYPE OF (shape_aspect);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(mct.related_shape_aspect))AND(mct.related_shape_aspect \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ])))>= 2 ;
END_ENTITY; -- printed_part_template_connected_terminals_definition


ENTITY printed_part_template_link
	SUBTYPE OF (stratum_technology_link, shape_aspect_relationship);
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ property_definition_relationship || SELF  \ printed_part_template_link || SELF  \ property_definition || SELF  \ stratum_technology_link || SELF \ shape_aspect_relationship))= 0 ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR5 :  SELF \ shape_aspect_relationship.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.description = '' ;
	WR7 :  SELF \ shape_aspect_relationship.related_shape_aspect.description = 'printed part template' ;
	WR8 :  SELF \ shape_aspect_relationship.relating_shape_aspect.description = 'printed part template' ;
END_ENTITY; -- printed_part_template_link


ENTITY printed_part_template_material
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| SIZEOF(QUERY(tu <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'technology usage')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_TECHNOLOGY' IN TYPEOF(tu.relating_property_definition.definition)))= 1))= 1 ;
	WR2 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sr_pdr <* QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION' IN  TYPEOF(pdr.used_representation))|((sr_pdr.used_representation \ representation.name = 'physical characteristics representation')AND(SIZEOF(sr_pdr.used_representation.items)= 2)AND(SIZEOF(QUERY(it <* sr_pdr.used_representation.items | it \ representation_item.name IN [ 'maximum width', 'minimum width' ]))= 2))))= 1)))= 0 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ product_definition || SELF \ printed_part_template_material))= 0 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa))AND(sa.description = 'top'))))<= 1)))= 0 ;
	WR5 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa))AND(sa.description = 'bottom'))))<= 1)))= 0 ;
	WR6 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa))AND(sa.description = 'left'))))<= 1)))= 0 ;
	WR7 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(sa <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(sa))AND(sa.description = 'right'))))<= 1)))= 0 ;
END_ENTITY; -- printed_part_template_material


ENTITY printed_part_template_material_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : related_shape_aspect, relating_shape_aspect;
WHERE
	WR1 :  SELF  \ shape_aspect_relationship.related_shape_aspect :<>: SELF \ shape_aspect_relationship.relating_shape_aspect ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(SELF \ shape_aspect_relationship.related_shape_aspect);
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEMPLATE_MATERIAL_CROSS_SECTION_BOUNDARY' IN TYPEOF(SELF \ shape_aspect_relationship.relating_shape_aspect);
	WR4 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF  \ shape_aspect_relationship || SELF \ printed_part_template_material_link))= 0 ;
	WR5 :  SELF \ shape_aspect.name = '' ;
	WR6 :  SELF \ shape_aspect_relationship.name = '' ;
	WR7 :  SELF  \ shape_aspect_relationship.related_shape_aspect.of_shape :<>: SELF \ shape_aspect_relationship.relating_shape_aspect.of_shape ;
	WR8 :  SELF \ shape_aspect_relationship.relating_shape_aspect.description IN [ 'bottom', 'right' ] ;
	WR9 :  SELF \ shape_aspect_relationship.related_shape_aspect.description IN [ 'top', 'left' ] ;
END_ENTITY; -- printed_part_template_material_link


ENTITY printed_part_template_terminal
	SUPERTYPE OF (printed_part_cross_section_template_terminal)
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SELF \ shape_aspect.description IN [ 'interface terminal', 'join terminal' ] ;
	WR2 :  SIZEOF(QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL_CONNECTION_ZONE_CATEGORY' IN TYPEOF(ga.assigned_group)))= 1 ;
	WR3 :  SIZEOF(QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')| sar.related_shape_aspect \ shape_aspect.description = 'connection zone'))>= 1 ;
	WR4 :  SIZEOF(QUERY(pd <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation)))>= 1)))= 0 ;
	WR5 :  SIZEOF(QUERY(ad <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'associated definition')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(ad.relating_shape_aspect))AND((ad.relating_shape_aspect \ shape_aspect.description = 'printed part template')OR(ad.relating_shape_aspect \ shape_aspect.description = 'printed connector template'))))= 1 ;
	WR6 :  SIZEOF(QUERY(mct <* QUERY(sar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'member connected terminal')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION' IN TYPEOF(mct.relating_shape_aspect)))<= 1 ;
END_ENTITY; -- printed_part_template_terminal


ENTITY printed_part_template_terminal_connection_zone_category
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name IN [ 'area edge segment', 'curve edge segment', 'surface area', 'surface point' ] ;
END_ENTITY; -- printed_part_template_terminal_connection_zone_category


ENTITY template_material_cross_section_boundary
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ shape_aspect || SELF \ template_material_cross_section_boundary))= 0 ;
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(SELF.of_shape \ property_definition.definition);
	WR3 :  SELF \ shape_aspect.description IN [ 'top', 'left', 'right', 'bottom' ] ;
END_ENTITY; -- template_material_cross_section_boundary


ENTITY action_property_representation;
	name : label;
	description : text;
	property : action_property;
	representation : representation;
END_ENTITY; -- action_property_representation


ENTITY resource_property_representation;
	name : label;
	description : text;
	property : resource_property;
	representation : representation;
END_ENTITY; -- resource_property_representation


ENTITY action_property;
	name : label;
	description : text;
	definition : characterized_action_definition;
END_ENTITY; -- action_property


ENTITY action_property_relationship;
	name : label;
	description : text;
	relating_action_property : action_property;
	related_action_property : action_property;
WHERE
	WR1 :  relating_action_property :<>: related_action_property ;
END_ENTITY; -- action_property_relationship


ENTITY action_resource_requirement;
	name : label;
	description : text;
	kind : resource_requirement_type;
	operations : SET [1:?] OF characterized_action_definition;
END_ENTITY; -- action_resource_requirement


ENTITY action_resource_requirement_relationship;
	name : label;
	description : text;
	relating_action_resource_requirement : action_resource_requirement;
	related_action_resource_requirement : action_resource_requirement;
WHERE
	WR1 :  relating_action_resource_requirement :<>: related_action_resource_requirement ;
END_ENTITY; -- action_resource_requirement_relationship


ENTITY process_product_association;
	name : label;
	description : text;
	defined_product : characterized_product_definition;
	process : product_definition_process;
END_ENTITY; -- process_product_association


ENTITY process_property_association;
	name : label;
	description : text;
	process : property_process;
	property_or_shape : property_or_shape_select;
END_ENTITY; -- process_property_association


ENTITY product_definition_process
	SUBTYPE OF (action);
	identification : identifier;
INVERSE
	product_definitions: SET [1:?] OF process_product_association FOR process;
END_ENTITY; -- product_definition_process


ENTITY property_process
	SUBTYPE OF (action);
	identification : identifier;
INVERSE
	properties: SET [1:?] OF process_property_association FOR process;
END_ENTITY; -- property_process


ENTITY replacement_relationship
	SUBTYPE OF (action_relationship);
WHERE
	WR1 :  acyclic_action_relationship(SELF , [ SELF \ action_relationship.related_action ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REPLACEMENT_RELATIONSHIP');
END_ENTITY; -- replacement_relationship


ENTITY requirement_for_action_resource
	SUBTYPE OF (action_resource_requirement);
	resources : SET [1:?] OF action_resource;
END_ENTITY; -- requirement_for_action_resource


ENTITY resource_property;
	name : label;
	description : text;
	resource : characterized_resource_definition;
END_ENTITY; -- resource_property


ENTITY resource_property_relationship;
	name : label;
	description : text;
	relating_resource_property : resource_property;
	related_resource_property : resource_property;
WHERE
	WR1 :  relating_resource_property :<>: related_resource_property ;
END_ENTITY; -- resource_property_relationship


ENTITY resource_requirement_type;
	name : label;
	description : text;
END_ENTITY; -- resource_requirement_type


ENTITY resource_requirement_type_relationship;
	name : label;
	description : text;
	relating_requirement_type : resource_requirement_type;
	related_requirement_type : resource_requirement_type;
WHERE
	WR1 :  relating_requirement_type :<>: related_requirement_type ;
END_ENTITY; -- resource_requirement_type_relationship


ENTITY concept_feature_operator;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- concept_feature_operator


ENTITY concept_feature_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept_feature : product_concept_feature;
	related_product_concept_feature : product_concept_feature;
END_ENTITY; -- concept_feature_relationship


ENTITY concept_feature_relationship_with_condition
	SUBTYPE OF (concept_feature_relationship);
	conditional_operator : concept_feature_operator;
END_ENTITY; -- concept_feature_relationship_with_condition


ENTITY conditional_concept_feature
	SUBTYPE OF (product_concept_feature);
	condition : concept_feature_relationship_with_condition;
END_ENTITY; -- conditional_concept_feature


ENTITY product_concept;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	market_context : product_concept_context;
UNIQUE
	UR1 : id;
END_ENTITY; -- product_concept


ENTITY product_concept_feature;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- product_concept_feature


ENTITY product_concept_feature_association;
	name : label;
	description : OPTIONAL text;
	concept : product_concept;
	feature : product_concept_feature;
END_ENTITY; -- product_concept_feature_association


ENTITY product_concept_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept : product_concept;
	related_product_concept : product_concept;
END_ENTITY; -- product_concept_relationship


ENTITY product;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	frame_of_reference : SET [1:?] OF product_context;
END_ENTITY; -- product


ENTITY product_category;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- product_category


ENTITY product_category_relationship;
	name : label;
	description : OPTIONAL text;
	category : product_category;
	sub_category : product_category;
WHERE
	WR1 :  acyclic_product_category_relationship(SELF , [ SELF.sub_category ]);
END_ENTITY; -- product_category_relationship


ENTITY product_definition;
	id : identifier;
	description : OPTIONAL text;
	formation : product_definition_formation;
	frame_of_reference : product_definition_context;
DERIVE
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- product_definition


ENTITY product_definition_context_association;
	definition : product_definition;
	frame_of_reference : product_definition_context;
	role : product_definition_context_role;
END_ENTITY; -- product_definition_context_association


ENTITY product_definition_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- product_definition_context_role


ENTITY product_definition_effectivity
	SUBTYPE OF (effectivity);
	usage : product_definition_relationship;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'))= 0 ;
END_ENTITY; -- product_definition_effectivity


ENTITY product_definition_formation;
	id : identifier;
	description : OPTIONAL text;
	of_product : product;
UNIQUE
	UR1 : id, of_product;
END_ENTITY; -- product_definition_formation


ENTITY product_definition_formation_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition_formation : product_definition_formation;
	related_product_definition_formation : product_definition_formation;
END_ENTITY; -- product_definition_formation_relationship


ENTITY product_definition_formation_with_specified_source
	SUBTYPE OF (product_definition_formation);
	make_or_buy : source;
END_ENTITY; -- product_definition_formation_with_specified_source


ENTITY product_definition_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition : product_definition;
	related_product_definition : product_definition;
END_ENTITY; -- product_definition_relationship


ENTITY product_definition_substitute;
	description : OPTIONAL text;
	context_relationship : product_definition_relationship;
	substitute_definition : product_definition;
DERIVE
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  context_relationship.related_product_definition :<>: substitute_definition ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- product_definition_substitute


ENTITY product_definition_with_associated_documents
	SUBTYPE OF (product_definition);
	documentation_ids : SET [1:?] OF document;
END_ENTITY; -- product_definition_with_associated_documents


ENTITY product_related_product_category
	SUBTYPE OF (product_category);
	products : SET [1:?] OF product;
END_ENTITY; -- product_related_product_category


ENTITY product_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product : product;
	related_product : product;
END_ENTITY; -- product_relationship


ENTITY externally_defined_product_definition
	SUPERTYPE OF (library_defined_product_definition)
	SUBTYPE OF (product_definition, externally_defined_item);
END_ENTITY; -- externally_defined_product_definition


ENTITY library_defined_product_definition
	SUBTYPE OF (externally_defined_product_definition);
DERIVE
	library : external_source :=  SELF \ externally_defined_item.source ;
END_ENTITY; -- library_defined_product_definition


ENTITY characterized_object;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- characterized_object


ENTITY characterized_object_relationship;
	name : label;
	description : OPTIONAL text;
	relating_object : characterized_object;
	related_object : characterized_object;
END_ENTITY; -- characterized_object_relationship


ENTITY general_property;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- general_property


ENTITY general_property_association;
	name : label;
	description : OPTIONAL text;
	base_definition : general_property;
	derived_definition : derived_property_select;
WHERE
	WR1 :  SIZEOF(USEDIN(derived_definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION'))= 1 ;
	WR2 :  derived_definition.name = base_definition.name ;
END_ENTITY; -- general_property_association


ENTITY general_property_relationship;
	name : label;
	description : OPTIONAL text;
	relating_property : general_property;
	related_property : general_property;
END_ENTITY; -- general_property_relationship


ENTITY product_definition_shape
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : definition;
WHERE
	WR1 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CHARACTERIZED_OBJECT' ] * TYPEOF(SELF \ property_definition.definition))> 0 ;
END_ENTITY; -- product_definition_shape


ENTITY property_definition;
	name : label;
	description : OPTIONAL text;
	definition : characterized_definition;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- property_definition


ENTITY shape_aspect;
	name : label;
	description : OPTIONAL text;
	of_shape : product_definition_shape;
	product_definitional : LOGICAL;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- shape_aspect


ENTITY shape_aspect_relationship;
	name : label;
	description : OPTIONAL text;
	relating_shape_aspect : shape_aspect;
	related_shape_aspect : shape_aspect;
DERIVE
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
END_ENTITY; -- shape_aspect_relationship


ENTITY context_dependent_shape_representation;
	representation_relation : shape_representation_relationship;
	represented_product_relation : product_definition_shape;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(SELF.represented_product_relation.definition);
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- context_dependent_shape_representation


ENTITY item_identified_representation_usage;
	name : label;
	description : OPTIONAL text;
	definition : represented_definition;
	used_representation : representation;
	identified_item : representation_item;
WHERE
	WR1 :  SELF.used_representation IN using_representations(SELF.identified_item);
END_ENTITY; -- item_identified_representation_usage


ENTITY property_definition_representation;
	definition : represented_definition;
	used_representation : representation;
DERIVE
	description : text :=  get_description_value(SELF);
	name : label :=  get_name_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1 ;
END_ENTITY; -- property_definition_representation


ENTITY shape_definition_representation
	SUBTYPE OF (property_definition_representation);
WHERE
	WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(SELF.definition))OR('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF(SELF.definition.definition));
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
END_ENTITY; -- shape_definition_representation


ENTITY shape_representation
	SUBTYPE OF (representation);
END_ENTITY; -- shape_representation


ENTITY shape_representation_relationship
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_REPRESENTATION' IN(TYPEOF(SELF  \ representation_relationship.rep_1)+ TYPEOF(SELF \ representation_relationship.rep_2));
END_ENTITY; -- shape_representation_relationship


ENTITY rule_action
	SUBTYPE OF (action);
WHERE
	WR1 :  SIZEOF(QUERY(aaa <* QUERY(aa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ACTION_ASSIGNMENT' IN  TYPEOF(aa))| SIZEOF(QUERY(it <* aaa.items |(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it))AND(it \ product_definition_formation.description = 'rule version'))))= 1))= 1 ;
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'participant date and time'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'participant date'))= 1 ;
	WR3 : (NOT(SELF  \ action.name = 'rule justification'))OR(SIZEOF(QUERY(ja <* QUERY(ar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| ar \ action_relationship.name = 'justified action')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_ACTION' IN TYPEOF(ja.relating_action)))= 1);
	WR4 : (NOT(SELF  \ action.name = 'rule modification'))OR(SIZEOF(QUERY(mr <* QUERY(ar <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_RELATIONSHIP.RELATED_ACTION')| ar \ action_relationship.name = 'modification rationale')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_ACTION' IN TYPEOF(mr.relating_action))AND(mr.relating_action \ action.name = 'rule change request')))= 1);
	WR5 : (NOT(SELF  \ action.name = 'rule replacement from'))OR(SIZEOF(QUERY(rrfa <* QUERY(aa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_REPLACEMENT_FROM_ASSIGNMENT' IN  TYPEOF(aa))| SIZEOF(QUERY(it <* rrfa.items |(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it))AND(it \ product_definition_formation.description = 'rule version'))))= 1))= 1);
	WR6 : (NOT(SELF  \ action.name = 'rule replacement to'))OR(SIZEOF(QUERY(rrta <* QUERY(aa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_REPLACEMENT_TO_ASSIGNMENT' IN  TYPEOF(aa))| SIZEOF(QUERY(it <* rrta.items |(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF(it))AND(it \ product_definition_formation.description = 'rule version'))))= 1))= 1);
END_ENTITY; -- rule_action


ENTITY rule_boolean_function_definition
	SUBTYPE OF (rule_function_definition);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODEL_PARAMETER' IN TYPEOF(it)))>= 1 ;
END_ENTITY; -- rule_boolean_function_definition


ENTITY rule_complex_clause
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr.rep_1)))>= 1 ;
	WR2 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_complex_clause))= 0 ;
END_ENTITY; -- rule_complex_clause


ENTITY rule_conclusion_definition
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_SIMPLE_CLAUSE' IN TYPEOF(rr \ representation_relationship.rep_1)))>= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_conclusion_definition))= 0 ;
END_ENTITY; -- rule_conclusion_definition


ENTITY rule_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SELF \ product_definition.formation.description = 'rule version' ;
END_ENTITY; -- rule_definition


ENTITY rule_function_definition
	SUPERTYPE OF (rule_boolean_function_definition)
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(it <* SELF.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MODEL_PARAMETER' IN TYPEOF(it)))>= 1 ;
	WR2 :  SIZEOF(QUERY(adf <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adf \ document_reference.assigned_document.kind \ document_type.product_data_type = 'reference document')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EE_SPECIFICATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT' ] * TYPEOF(adf \ document_reference.assigned_document))>= 1)))= 1 ;
	WR3 :  SIZEOF(QUERY(adf <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adf \ document_reference.assigned_document.kind \ document_type.product_data_type = 'source code')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(adf \ document_reference.assigned_document))))= 1 ;
END_ENTITY; -- rule_function_definition


ENTITY rule_function_domain_parameter
	SUBTYPE OF (model_parameter);
WHERE
	WR1 :  SIZEOF(QUERY(cri <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri))))= 1 ;
END_ENTITY; -- rule_function_domain_parameter


ENTITY rule_function_range_parameter
	SUBTYPE OF (model_parameter);
WHERE
	WR1 :  SIZEOF(QUERY(cri <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(cri))))= 1 ;
END_ENTITY; -- rule_function_range_parameter


ENTITY rule_general_clause
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))>= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_FUNCTION_DEFINITION' IN TYPEOF(rr.rep_1)))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_general_clause))= 0 ;
END_ENTITY; -- rule_general_clause


ENTITY rule_premise_definition
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_DEFINITION' IN TYPEOF(pdr.definition.definition)))= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_COMPLEX_CLAUSE' IN TYPEOF(rr \ representation_relationship.rep_1)))>= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_premise_definition))= 0 ;
END_ENTITY; -- rule_premise_definition


ENTITY rule_set
	SUBTYPE OF (product_definition);
END_ENTITY; -- rule_set


ENTITY rule_set_group
	SUBTYPE OF (product_definition);
WHERE
	WR1 :  SIZEOF(QUERY(rsge <* QUERY(gr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| gr \ product_definition_relationship.name = 'rule set group element')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_SET' IN TYPEOF(rsge.related_product_definition)))>= 1 ;
END_ENTITY; -- rule_set_group


ENTITY rule_simple_clause
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PARAMETER_ASSIGNMENT_REPRESENTATION' IN TYPEOF(rr.rep_2)))>= 1 ;
	WR2 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_BOOLEAN_FUNCTION_DEFINITION' IN TYPEOF(rr.rep_1)))= 1 ;
	WR3 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ representation || SELF \ rule_simple_clause))= 0 ;
END_ENTITY; -- rule_simple_clause


ENTITY rule_superseded_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF rule_superseded_item;
END_ENTITY; -- rule_superseded_assignment


ENTITY rule_supersedence
	SUBTYPE OF (rule_action);
END_ENTITY; -- rule_supersedence


ENTITY alternate_product_relationship;
	name : label;
	definition : OPTIONAL text;
	alternate : product;
	base : product;
	basis : text;
UNIQUE
	UR1 : alternate, base;
WHERE
	WR1 :  alternate :<>: base ;
END_ENTITY; -- alternate_product_relationship


ENTITY assembly_component_usage
	SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence))
	SUBTYPE OF (product_definition_usage);
	reference_designator : OPTIONAL identifier;
END_ENTITY; -- assembly_component_usage


ENTITY assembly_component_usage_substitute;
	name : label;
	definition : OPTIONAL text;
	base : assembly_component_usage;
	substitute : assembly_component_usage;
UNIQUE
	UR1 : base, substitute;
WHERE
	WR1 :  base.relating_product_definition :=: substitute.relating_product_definition ;
	WR2 :  base :<>: substitute ;
END_ENTITY; -- assembly_component_usage_substitute


ENTITY assembly_component_usage_substitute_with_ranking
	SUBTYPE OF (assembly_component_usage_substitute);
	ranking : INTEGER;
	ranking_rationale : text;
END_ENTITY; -- assembly_component_usage_substitute_with_ranking


ENTITY make_from_usage_option
	SUBTYPE OF (product_definition_usage);
	ranking : INTEGER;
	ranking_rationale : text;
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT('NUMBER' IN TYPEOF(quantity.value_component)))OR(quantity.value_component > 0);
END_ENTITY; -- make_from_usage_option


ENTITY make_from_usage_option_group;
	members : SET [2:?] OF make_from_usage_option;
WHERE
	WR1 :  SIZEOF(QUERY(example <* members | example.related_product_definition :=: members [ 1 ].related_product_definition))= SIZEOF(members);
END_ENTITY; -- make_from_usage_option_group


ENTITY next_assembly_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- next_assembly_usage_occurrence


ENTITY product_definition_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	occurrence : product_definition;
	occurrence_usage : assembly_component_usage;
WHERE
	WR1 :  occurrence_usage.relating_product_definition :<>: occurrence ;
	WR2 :  occurrence_usage.related_product_definition :<>: occurrence ;
	WR3 :  occurrence.formation :=: occurrence_usage.related_product_definition.formation ;
END_ENTITY; -- product_definition_occurrence_relationship


ENTITY product_definition_usage
	SUPERTYPE OF (ONEOF (make_from_usage_option, assembly_component_usage))
	SUBTYPE OF (product_definition_relationship);
UNIQUE
	UR1 : id, relating_product_definition, related_product_definition;
WHERE
	WR1 :  acyclic_product_definition_relationship(SELF , [ SELF \ product_definition_relationship.related_product_definition ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY; -- product_definition_usage


ENTITY promissory_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- promissory_usage_occurrence


ENTITY quantified_assembly_component_usage
	SUBTYPE OF (assembly_component_usage);
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT('NUMBER' IN TYPEOF(quantity.value_component)))OR(quantity.value_component > 0);
END_ENTITY; -- quantified_assembly_component_usage


ENTITY specified_higher_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
	upper_usage : assembly_component_usage;
	next_usage : next_assembly_usage_occurrence;
UNIQUE
	UR1 : upper_usage, next_usage;
WHERE
	WR1 :  SELF :<>: upper_usage ;
	WR2 :  SELF \ product_definition_relationship.relating_product_definition :=: upper_usage.relating_product_definition ;
	WR3 :  SELF \ product_definition_relationship.related_product_definition :=: next_usage.related_product_definition ;
	WR4 : (upper_usage.related_product_definition :=: next_usage.relating_product_definition)OR(SIZEOF(QUERY(pdr <* USEDIN(upper_usage.related_product_definition, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')| pdr.relating_product_definition :=: next_usage.relating_product_definition))= 1);
	WR5 :  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE' ] * TYPEOF(upper_usage))= 1 ;
END_ENTITY; -- specified_higher_usage_occurrence


ENTITY applied_organizational_project_assignment
	SUBTYPE OF (organizational_project_assignment);
	items : SET [1:?] OF project_item;
END_ENTITY; -- applied_organizational_project_assignment


ENTITY qualification;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification


ENTITY qualification_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_qualification : qualification;
	related_qualification : qualification;
END_ENTITY; -- qualification_relationship


ENTITY qualification_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_type


ENTITY qualification_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_qualification_type : qualification_type;
	related_qualification_type : qualification_type;
END_ENTITY; -- qualification_type_relationship


ENTITY descriptive_representation_item
	SUBTYPE OF (representation_item);
	description : text;
END_ENTITY; -- descriptive_representation_item


ENTITY expanded_uncertainty
	SUBTYPE OF (standard_uncertainty);
	coverage_factor : REAL;
END_ENTITY; -- expanded_uncertainty


ENTITY measure_qualification;
	name : label;
	description : text;
	qualified_measure : measure_with_unit;
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 :  SIZEOF(QUERY(temp <* qualifiers | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)))< 2 ;
END_ENTITY; -- measure_qualification


ENTITY measure_representation_item
	SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY; -- measure_representation_item


ENTITY precision_qualifier;
	precision_value : INTEGER;
END_ENTITY; -- precision_qualifier


ENTITY qualified_representation_item
	SUBTYPE OF (representation_item);
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 :  SIZEOF(QUERY(temp <* qualifiers | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(temp)))< 2 ;
END_ENTITY; -- qualified_representation_item


ENTITY qualitative_uncertainty
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : text;
END_ENTITY; -- qualitative_uncertainty


ENTITY standard_uncertainty
	SUPERTYPE OF (expanded_uncertainty)
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : REAL;
END_ENTITY; -- standard_uncertainty


ENTITY type_qualifier;
	name : label;
END_ENTITY; -- type_qualifier


ENTITY uncertainty_qualifier
	SUPERTYPE OF (ONEOF (standard_uncertainty, qualitative_uncertainty));
	measure_name : label;
	description : text;
END_ENTITY; -- uncertainty_qualifier


ENTITY compound_representation_item
	SUBTYPE OF (representation_item);
	item_element : compound_item_definition;
END_ENTITY; -- compound_representation_item


ENTITY definitional_representation
	SUBTYPE OF (representation);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF \ representation.context_of_items);
END_ENTITY; -- definitional_representation


ENTITY founded_item;
END_ENTITY; -- founded_item


ENTITY functionally_defined_transformation;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- functionally_defined_transformation


ENTITY global_uncertainty_assigned_context
	SUBTYPE OF (representation_context);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- global_uncertainty_assigned_context


ENTITY item_defined_transformation;
	name : label;
	description : OPTIONAL text;
	transform_item_1 : representation_item;
	transform_item_2 : representation_item;
END_ENTITY; -- item_defined_transformation


ENTITY mapped_item
	SUBTYPE OF (representation_item);
	mapping_source : representation_map;
	mapping_target : representation_item;
WHERE
	WR1 :  acyclic_mapped_representation(using_representations(SELF ), [ SELF ]);
END_ENTITY; -- mapped_item


ENTITY parametric_representation_context
	SUBTYPE OF (representation_context);
END_ENTITY; -- parametric_representation_context


ENTITY representation;
	name : label;
	items : SET [1:?] OF representation_item;
	context_of_items : representation_context;
DERIVE
	description : text :=  get_description_value(SELF);
	id : identifier :=  get_id_value(SELF);
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1 ;
END_ENTITY; -- representation


ENTITY representation_context;
	context_identifier : identifier;
	context_type : text;
INVERSE
	representations_in_context: SET [1:?] OF representation FOR context_of_items;
END_ENTITY; -- representation_context


ENTITY representation_item;
	name : label;
WHERE
	WR1 :  SIZEOF(using_representations(SELF))> 0 ;
END_ENTITY; -- representation_item


ENTITY representation_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_representation_item : representation_item;
	related_representation_item : representation_item;
END_ENTITY; -- representation_item_relationship


ENTITY representation_map;
	mapping_origin : representation_item;
	mapped_representation : representation;
INVERSE
	map_usage: SET [1:?] OF mapped_item FOR mapping_source;
WHERE
	WR1 :  item_in_context(SELF.mapping_origin, SELF.mapped_representation.context_of_items);
END_ENTITY; -- representation_map


ENTITY representation_relationship;
	name : label;
	description : OPTIONAL text;
	rep_1 : representation;
	rep_2 : representation;
END_ENTITY; -- representation_relationship


ENTITY representation_relationship_with_transformation
	SUBTYPE OF (representation_relationship);
	transformation_operator : transformation;
WHERE
	WR1 :  SELF  \ representation_relationship.rep_1.context_of_items :<>: SELF \ representation_relationship.rep_2.context_of_items ;
END_ENTITY; -- representation_relationship_with_transformation


ENTITY uncertainty_assigned_representation
	SUBTYPE OF (representation);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- uncertainty_assigned_representation


ENTITY uncertainty_measure_with_unit
	SUBTYPE OF (measure_with_unit);
	name : label;
	description : OPTIONAL text;
WHERE
	WR1 :  valid_measure_value(SELF \ measure_with_unit.value_component);
END_ENTITY; -- uncertainty_measure_with_unit


ENTITY value_representation_item
	SUBTYPE OF (representation_item);
	value_component : measure_value;
WHERE
	WR1 :  SIZEOF(QUERY(rep <* using_representations(SELF)| NOT('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN TYPEOF(rep.context_of_items))))= 0 ;
END_ENTITY; -- value_representation_item


ENTITY assigned_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY; -- assigned_requirement


ENTITY requirement_assigned_object
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_assigned_item;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY; -- requirement_assigned_object


ENTITY requirement_assignment
	SUBTYPE OF (characterized_object, group);
END_ENTITY; -- requirement_assignment


ENTITY requirement_source
	SUBTYPE OF (group);
END_ENTITY; -- requirement_source


ENTITY source_for_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_source_item;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY; -- source_for_requirement


ENTITY sourced_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY; -- sourced_requirement


ENTITY material_electrical_conductivity_category
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.name IN [ 'conductive', 'non conductive', 'resistive', 'semi conductive' ] ;
END_ENTITY; -- material_electrical_conductivity_category


ENTITY requirement_allocation_group
	SUBTYPE OF (group, property_definition_relationship);
WHERE
	WR1 : (SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga))|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONFIGURATION_ITEM' ] * TYPEOF(aga.items))= 1)))= 1);
	WR2 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(SELF \ property_definition_relationship.relating_property_definition);
	WR4 :  NOT(SELF  \ property_definition_relationship.related_property_definition.description = 'test requirement')OR(SIZEOF(QUERY(aga <* QUERY(ga <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(ga))|(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION' ] * TYPEOF(aga.items))= 1)))>= 1);
END_ENTITY; -- requirement_allocation_group


ENTITY requirement_definition
	SUBTYPE OF (product_definition);
WHERE
	WR1 : (NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_WITH_ASSOCIATED_DOCUMENTS' IN TYPEOF(SELF)))OR(SIZEOF(QUERY(docs <* SELF \ product_definition_with_associated_documents.documentation_ids | docs.kind \ document_type.product_data_type = 'CAD filename'))<= 1);
	WR2 :  SIZEOF(QUERY(adta <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')| adta.role \ date_time_role.name = 'creation date'))+ SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_ASSIGNMENT.ITEMS')| ada.role \ date_role.name = 'creation date'))= 1 ;
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1 ;
	WR4 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'creator'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'creator'))>= 1 ;
	WR5 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1 ;
	WR6 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ product_definition || SELF \ requirement_definition)))= 0 ;
	WR7 :  SIZEOF(QUERY(prpc <* USEDIN(SELF.formation.of_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.' + 'PRODUCTS')| prpc \ product_category.name = 'requirements model'))>= 1 ;
END_ENTITY; -- requirement_definition


ENTITY requirements_property
	SUBTYPE OF (property_definition);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'requirements property composition'))<= 1 ;
	WR2 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| SIZEOF(QUERY(it <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(it))AND(it \ representation_item.name = 'requirements description')))= 1))<= 1 ;
	WR3 :  SIZEOF(QUERY(dr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(dr.assigned_document)))>= 1 ;
	WR4 :  NOT(EXISTS(SELF  \ property_definition.description))OR(NOT(SELF  \ property_definition.description IN  [ 'constraint', 'part based constraint' ])OR(SIZEOF(QUERY(dc <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'design constraint')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_DEFINITION' IN TYPEOF(dc.relating_property_definition.definition)))= 1));
	WR5 :  NOT(EXISTS(SELF  \ property_definition.description))OR(NOT(SELF  \ property_definition.description = 'part based constraint')OR(SIZEOF(QUERY(cp <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'constraining part')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF(cp.relating_property_definition.definition))AND(cp.relating_property_definition.definition \ product_definition_relationship.name = 'constraining part')AND(cp.relating_property_definition.definition.related_product_definition.frame_of_reference.name = 'design requirement')))= 1));
	WR6 :  NOT(EXISTS(SELF  \ property_definition.description))OR(NOT(SELF  \ property_definition.description = 'interface requirement')OR(SIZEOF(QUERY(itnha <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')| pdr \ property_definition_relationship.name = 'interface to next higher assembly')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN  TYPEOF(itnha.relating_property_definition.definition))AND(itnha.relating_property_definition.definition.frame_of_reference.name = 'design requirement')AND(SIZEOF(QUERY(hai <* QUERY(pdr <* USEDIN(itnha.relating_property_definition.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'higher assembly interface')| SIZEOF(QUERY(pdr <* USEDIN(hai, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdr)))= 1))= 1)))= 1));
END_ENTITY; -- requirements_property


ENTITY applied_security_classification_assignment
	SUBTYPE OF (security_classification_assignment);
	items : SET [1:?] OF security_classification_item;
END_ENTITY; -- applied_security_classification_assignment


ENTITY security_classification;
	name : label;
	purpose : text;
	security_level : security_classification_level;
END_ENTITY; -- security_classification


ENTITY security_classification_level;
	name : label;
END_ENTITY; -- security_classification_level


ENTITY interconnect_module_stratum_based_terminal
	SUBTYPE OF (interconnect_module_terminal);
END_ENTITY; -- interconnect_module_stratum_based_terminal


ENTITY sequential_laminate_passage_based_fabrication_joint
	SUBTYPE OF (shape_aspect);
END_ENTITY; -- sequential_laminate_passage_based_fabrication_joint


ENTITY apex
	SUBTYPE OF (derived_shape_aspect);
END_ENTITY; -- apex


ENTITY centre_of_symmetry
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(sadr <* SELF \ derived_shape_aspect.deriving_relationships | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMMETRIC_SHAPE_ASPECT' IN TYPEOF(sadr \ shape_aspect_relationship.related_shape_aspect))))= 0 ;
END_ENTITY; -- centre_of_symmetry


ENTITY composite_shape_aspect
	SUBTYPE OF (shape_aspect);
INVERSE
	component_relationships: SET [2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
END_ENTITY; -- composite_shape_aspect


ENTITY datum
	SUBTYPE OF (shape_aspect);
	identification : identifier;
INVERSE
	established_by_relationships: SET [1:?] OF shape_aspect_relationship FOR related_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(x <* SELF \ datum.established_by_relationships | SIZEOF(TYPEOF(x \ shape_aspect_relationship.relating_shape_aspect)* [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DATUM_TARGET' ])<> 1))= 0 ;
END_ENTITY; -- datum


ENTITY datum_feature
	SUBTYPE OF (shape_aspect);
INVERSE
	feature_basis_relationship: shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(sar <* bag_to_set(USEDIN(SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' + 'RELATING_SHAPE_ASPECT'))| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DATUM' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 0 ;
	WR2 :  SELF \ shape_aspect.product_definitional = TRUE ;
END_ENTITY; -- datum_feature


ENTITY datum_reference;
	precedence : INTEGER;
	referenced_datum : datum;
WHERE
	WR1 :  precedence > 0 ;
END_ENTITY; -- datum_reference


ENTITY datum_target
	SUBTYPE OF (shape_aspect);
	target_id : identifier;
INVERSE
	target_basis_relationship: shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(sar <* bag_to_set(USEDIN(SELF, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' + 'RELATING_SHAPE_ASPECT'))| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DATUM' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 0 ;
	WR2 :  SELF \ shape_aspect.product_definitional = TRUE ;
END_ENTITY; -- datum_target


ENTITY derived_shape_aspect
	SUPERTYPE OF (ONEOF (apex, centre_of_symmetry, geometric_alignment, geometric_intersection, parallel_offset, perpendicular_to, extension, tangent))
	SUBTYPE OF (shape_aspect);
INVERSE
	deriving_relationships: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(dr <* SELF \ derived_shape_aspect.deriving_relationships | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_DERIVING_RELATIONSHIP' IN TYPEOF(dr))))= 0 ;
END_ENTITY; -- derived_shape_aspect


ENTITY extension
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- extension


ENTITY geometric_alignment
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)> 1 ;
END_ENTITY; -- geometric_alignment


ENTITY geometric_intersection
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)> 1 ;
END_ENTITY; -- geometric_intersection


ENTITY parallel_offset
	SUBTYPE OF (derived_shape_aspect);
	offset : measure_with_unit;
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- parallel_offset


ENTITY perpendicular_to
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- perpendicular_to


ENTITY referenced_modified_datum
	SUBTYPE OF (datum_reference);
	modifier : limit_condition;
END_ENTITY; -- referenced_modified_datum


ENTITY shape_aspect_deriving_relationship
	SUBTYPE OF (shape_aspect_relationship);
WHERE
	WR1 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DERIVED_SHAPE_ASPECT' IN TYPEOF(SELF \ SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
END_ENTITY; -- shape_aspect_deriving_relationship


ENTITY symmetric_shape_aspect
	SUBTYPE OF (shape_aspect);
INVERSE
	basis_relationships: SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
WHERE
	WR1 :  SIZEOF(QUERY(x <* SELF \ symmetric_shape_aspect.basis_relationships | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF(x \ shape_aspect_relationship.related_shape_aspect)))>= 1 ;
END_ENTITY; -- symmetric_shape_aspect


ENTITY tangent
	SUBTYPE OF (derived_shape_aspect);
WHERE
	WR1 :  SIZEOF(SELF \ derived_shape_aspect.deriving_relationships)= 1 ;
END_ENTITY; -- tangent


ENTITY composite_group_shape_aspect
	SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_group_shape_aspect


ENTITY composite_unit_shape_aspect
	SUBTYPE OF (composite_shape_aspect);
END_ENTITY; -- composite_unit_shape_aspect


ENTITY angular_location
	SUBTYPE OF (dimensional_location);
	angle_selection : angle_relator;
END_ENTITY; -- angular_location


ENTITY angular_size
	SUBTYPE OF (dimensional_size);
	angle_selection : angle_relator;
END_ENTITY; -- angular_size


ENTITY dimensional_characteristic_representation;
	dimension : dimensional_characteristic;
	representation : shape_dimension_representation;
END_ENTITY; -- dimensional_characteristic_representation


ENTITY dimensional_location
	SUPERTYPE OF (ONEOF (angular_location, dimensional_location_with_path))
	SUBTYPE OF (shape_aspect_relationship);
END_ENTITY; -- dimensional_location


ENTITY dimensional_location_with_path
	SUBTYPE OF (dimensional_location);
	path : shape_aspect;
END_ENTITY; -- dimensional_location_with_path


ENTITY dimensional_size
	SUPERTYPE OF (ONEOF (angular_size, dimensional_size_with_path));
	applies_to : shape_aspect;
	name : label;
WHERE
	WR1 :  applies_to.product_definitional = TRUE ;
END_ENTITY; -- dimensional_size


ENTITY dimensional_size_with_path
	SUBTYPE OF (dimensional_size);
	path : shape_aspect;
END_ENTITY; -- dimensional_size_with_path


ENTITY shape_dimension_representation
	SUBTYPE OF (shape_representation);
WHERE
	WR1 :  SIZEOF(QUERY(temp <* SELF \ representation.items | NOT('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(temp))))= 0 ;
	WR2 :  SIZEOF(SELF \ representation.items)<= 3 ;
	WR3 :  SIZEOF(QUERY(pos_mri <* QUERY(real_mri <* SELF \ representation.items | 'REAL' IN TYPEOF(real_mri \ measure_with_unit.value_component))| NOT(pos_mri \ measure_with_unit.value_component > 0.0)))= 0 ;
END_ENTITY; -- shape_dimension_representation


ENTITY keepout_design_object_category
	SUBTYPE OF (characterized_object);
WHERE
	WR1 :  SELF \ characterized_object.description IN [ 'assembly module assembly component category', 'component feature category', 'assembly ee material category', 'interconnect ee material category', 'interconnect module assembly component category', 'via category', 'inter stratum feature category', 'cutout category', 'fill area category', 'laminate component category', 'stratum feature category' ] ;
END_ENTITY; -- keepout_design_object_category


ENTITY dimension_related_tolerance_zone_element;
	related_dimension : dimensional_location;
	related_element : tolerance_zone_definition;
END_ENTITY; -- dimension_related_tolerance_zone_element


ENTITY geometric_tolerance;
	name : label;
	description : text;
	magnitude : measure_with_unit;
	toleranced_shape_aspect : shape_aspect;
WHERE
	WR1 : ('NUMBER' IN TYPEOF(magnitude \ measure_with_unit.value_component))AND(magnitude \ measure_with_unit.value_component >= 0.0);
END_ENTITY; -- geometric_tolerance


ENTITY geometric_tolerance_relationship;
	name : label;
	description : text;
	relating_geometric_tolerance : geometric_tolerance;
	related_geometric_tolerance : geometric_tolerance;
END_ENTITY; -- geometric_tolerance_relationship


ENTITY geometric_tolerance_with_datum_reference
	SUBTYPE OF (geometric_tolerance);
	datum_system : SET [1:?] OF datum_reference;
END_ENTITY; -- geometric_tolerance_with_datum_reference


ENTITY geometric_tolerance_with_defined_unit
	SUBTYPE OF (geometric_tolerance);
	unit_size : measure_with_unit;
WHERE
	WR1 : ('NUMBER' IN TYPEOF(unit_size \ measure_with_unit.value_component))AND(unit_size \ measure_with_unit.value_component > 0.0);
END_ENTITY; -- geometric_tolerance_with_defined_unit


ENTITY limits_and_fits;
	form_variance : label;
	zone_variance : label;
	grade : label;
	source : text;
END_ENTITY; -- limits_and_fits


ENTITY modified_geometric_tolerance
	SUBTYPE OF (geometric_tolerance);
	modifier : limit_condition;
END_ENTITY; -- modified_geometric_tolerance


ENTITY plus_minus_tolerance;
	range : tolerance_method_definition;
	toleranced_dimension : dimensional_characteristic;
UNIQUE
	UR1 : toleranced_dimension;
END_ENTITY; -- plus_minus_tolerance


ENTITY projected_zone_definition
	SUBTYPE OF (tolerance_zone_definition);
	projection_end : shape_aspect;
	projected_length : measure_with_unit;
WHERE
	WR1 : ('NUMBER' IN TYPEOF(projected_length \ measure_with_unit.value_component))AND(projected_length \ measure_with_unit.value_component > 0.0);
	WR2 : (derive_dimensional_exponents(projected_length \ measure_with_unit.unit_component)= dimensional_exponents(1, 0, 0, 0, 0, 0, 0));
END_ENTITY; -- projected_zone_definition


ENTITY runout_zone_definition
	SUBTYPE OF (tolerance_zone_definition);
	orientation : runout_zone_orientation;
END_ENTITY; -- runout_zone_definition


ENTITY runout_zone_orientation;
	angle : measure_with_unit;
END_ENTITY; -- runout_zone_orientation


ENTITY runout_zone_orientation_reference_direction
	SUBTYPE OF (runout_zone_orientation);
	orientation_defining_relationship : shape_aspect_relationship;
END_ENTITY; -- runout_zone_orientation_reference_direction


ENTITY statistical_distribution_for_tolerance
	SUBTYPE OF (representation);
WHERE
	WR1 :  SIZEOF(QUERY(item <* SELF \ representation.items | NOT('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(item))))= 0 ;
END_ENTITY; -- statistical_distribution_for_tolerance


ENTITY tolerance_value;
	lower_bound : measure_with_unit;
	upper_bound : measure_with_unit;
WHERE
	WR1 :  upper_bound \ measure_with_unit.value_component > lower_bound \ measure_with_unit.value_component ;
	WR2 :  upper_bound \ measure_with_unit.unit_component = lower_bound \ measure_with_unit.unit_component ;
END_ENTITY; -- tolerance_value


ENTITY tolerance_with_statistical_distribution;
	associated_tolerance : shape_tolerance_select;
	tolerance_allocation : statistical_distribution_for_tolerance;
END_ENTITY; -- tolerance_with_statistical_distribution


ENTITY tolerance_zone
	SUBTYPE OF (shape_aspect);
	defining_tolerance : SET [1:?] OF geometric_tolerance;
	form : tolerance_zone_form;
END_ENTITY; -- tolerance_zone


ENTITY tolerance_zone_definition
	SUPERTYPE OF (ONEOF (projected_zone_definition, runout_zone_definition));
	zone : tolerance_zone;
	boundaries : SET [1:?] OF shape_aspect;
END_ENTITY; -- tolerance_zone_definition


ENTITY tolerance_zone_form;
	name : label;
END_ENTITY; -- tolerance_zone_form


ENTITY discrete_shield
	SUBTYPE OF (component_definition);
WHERE
	WR1 :  SELF.frame_of_reference.name = 'physical occurrence' ;
	WR2 :  SIZEOF(QUERY(si <* QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr \ product_definition_relationship.name = 'shielded item')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(si.relating_product_definition)))>= 1 ;
END_ENTITY; -- discrete_shield


ENTITY integral_shield
	SUBTYPE OF (component_shape_aspect);
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(pdr.relating_property_definition))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT' IN TYPEOF(pdr.relating_property_definition)))AND(pdr \ property_definition_relationship.name = 'shielded item')))>= 1 ;
END_ENTITY; -- integral_shield


ENTITY composite_signal_property_relationship
	SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
	WR1 :  SELF  \ property_definition_relationship.related_property_definition.definition :<>: SELF \ property_definition_relationship.relating_property_definition.definition ;
	WR2 :  SIZEOF(TYPEOF(SELF)- TYPEOF(SELF  \ property_definition_relationship || SELF  \ composite_signal_property_relationship || SELF \ property_definition))= 0 ;
	WR3 :  SELF \ property_definition_relationship.related_property_definition.name = 'signal property' ;
	WR4 :  SELF \ property_definition_relationship.relating_property_definition.name = 'composite signal property' ;
	WR5 :  SELF \ property_definition.name = '' ;
	WR6 :  SELF \ property_definition.description = '' ;
	WR7 :  SELF \ property_definition_relationship.name = '' ;
	WR8 :  SELF \ property_definition_relationship.description = '' ;
	WR9 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHARACTERIZED_OBJECT' IN TYPEOF(SELF  \ property_definition.definition))AND(SELF \ property_definition.definition.description = 'aggregate operation');
	WR10 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNAL_DEFINITION' IN TYPEOF(SELF \ property_definition.definition);
END_ENTITY; -- composite_signal_property_relationship


ENTITY signal
	SUBTYPE OF (characterized_object);
WHERE
	WR1 :  SIZEOF(QUERY(aca <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_CLASSIFICATION_ASSIGNMENT.ITEMS')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SIGNAL_CATEGORY' IN TYPEOF(aca.assigned_group)))>= 1 ;
	WR2 : (SIZEOF(QUERY(ada <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')| SIZEOF(QUERY(duc <* USEDIN(ada.assigned_document, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')| duc \ document_usage_constraint.subject_element = 'signal category'))= 1))= 1);
	WR3 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))= 1 ;
END_ENTITY; -- signal


ENTITY signal_category
	SUBTYPE OF (group);
WHERE
	WR1 :  SELF \ group.description IN [ 'signal characteristic category', 'signal property category' ] ;
END_ENTITY; -- signal_category


ENTITY document_identifier
	SUBTYPE OF (group);
UNIQUE
	UR1 : name, description;
WHERE
	WR1 :  SIZEOF(USEDIN(SELF, 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING.' + 'DOCUMENT_IDENTIFIER_ASSIGNMENT'))> 0 ;
END_ENTITY; -- document_identifier


ENTITY document_identifier_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF document_identifier_assigned_item;
	SELF\group_assignment.assigned_group : document_identifier;
END_ENTITY; -- document_identifier_assignment


ENTITY ee_specification
	SUBTYPE OF (document);
WHERE
	WR1 :  SIZEOF(QUERY(apoa <* USEDIN(SELF , 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ person_and_organization_role.name = 'document source'))+ SIZEOF(QUERY(apoa <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')| apoa.role \ organization_role.name = 'document source'))>= 1 ;
	WR2 :  SELF \ document.kind \ document_type.product_data_type IN [ 'assembly technology specification', 'design specification', 'fabrication technology specification', 'interface specification', 'language reference manual', 'lead form specification', 'material specification', 'reference document', 'source code', 'font registration document', 'process specification', 'surface finish specification', 'test specification' ] ;
END_ENTITY; -- ee_specification


ENTITY structured_text_representation_context
	SUBTYPE OF (representation_context);
WHERE
	WR1 :  SIZEOF(QUERY(rep <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.CONTEXT_OF_ITEMS')| NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rep))))= 0 ;
END_ENTITY; -- structured_text_representation_context


ENTITY structured_text_representation_item
	SUBTYPE OF (representation, descriptive_representation_item);
WHERE
	WR1 :  SIZEOF(QUERY(rr <* USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION_RELATIONSHIP.REP_2')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM' IN TYPEOF(rr.rep_1)))<= 1 ;
	WR2 :  SIZEOF(USEDIN(SELF, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))>= 1 ;
	WR3 : (SIZEOF(QUERY(it <* SELF \ representation.items | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_REPRESENTATION_ITEM' IN TYPEOF(it)))= 1);
END_ENTITY; -- structured_text_representation_item


ENTITY solid_curve_font
	SUBTYPE OF (pre_defined_curve_font);
END_ENTITY; -- solid_curve_font


ENTITY thermal_network
	SUBTYPE OF (functional_unit);
END_ENTITY; -- thermal_network


ENTITY closed_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY; -- closed_shell


ENTITY connected_edge_set
	SUBTYPE OF (topological_representation_item);
	ces_edges : SET [1:?] OF edge;
END_ENTITY; -- connected_edge_set


ENTITY connected_face_set
	SUPERTYPE OF (ONEOF (closed_shell, open_shell))
	SUBTYPE OF (topological_representation_item);
	cfs_faces : SET [1:?] OF face;
END_ENTITY; -- connected_face_set


ENTITY connected_face_sub_set
	SUBTYPE OF (connected_face_set);
	parent_face_set : connected_face_set;
END_ENTITY; -- connected_face_sub_set


ENTITY edge
	SUPERTYPE OF (ONEOF (edge_curve, oriented_edge, subedge))
	SUBTYPE OF (topological_representation_item);
	edge_start : vertex;
	edge_end : vertex;
END_ENTITY; -- edge


ENTITY edge_curve
	SUBTYPE OF (edge, geometric_representation_item);
	edge_geometry : curve;
	same_sense : BOOLEAN;
END_ENTITY; -- edge_curve


ENTITY edge_loop
	SUBTYPE OF (loop, path);
DERIVE
	ne : INTEGER :=  SIZEOF(SELF \ path.edge_list);
WHERE
	WR1 : (SELF  \ path.edge_list [ 1 ].edge_start):=:(SELF \ path.edge_list [ ne ].edge_end);
END_ENTITY; -- edge_loop


ENTITY face
	SUPERTYPE OF (ONEOF (face_surface, subface, oriented_face))
	SUBTYPE OF (topological_representation_item);
	bounds : SET [1:?] OF face_bound;
WHERE
	WR1 :  NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
	WR2 :  SIZEOF(QUERY(temp <* bounds | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(temp)))<= 1 ;
END_ENTITY; -- face


ENTITY face_bound
	SUBTYPE OF (topological_representation_item);
	bound : loop;
	orientation : BOOLEAN;
END_ENTITY; -- face_bound


ENTITY face_outer_bound
	SUBTYPE OF (face_bound);
END_ENTITY; -- face_outer_bound


ENTITY face_surface
	SUBTYPE OF (face, geometric_representation_item);
	face_geometry : surface;
	same_sense : BOOLEAN;
WHERE
	WR1 :  NOT('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
END_ENTITY; -- face_surface


ENTITY loop
	SUPERTYPE OF (ONEOF (vertex_loop, edge_loop, poly_loop))
	SUBTYPE OF (topological_representation_item);
END_ENTITY; -- loop


ENTITY open_path
	SUBTYPE OF (path);
DERIVE
	ne : INTEGER :=  SIZEOF(SELF \ path.edge_list);
WHERE
	WR1 : (SELF  \ path.edge_list [ 1 ].edge_element.edge_start):<>:(SELF \ path.edge_list [ ne ].edge_element.edge_end);
END_ENTITY; -- open_path


ENTITY open_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY; -- open_shell


ENTITY oriented_closed_shell
	SUBTYPE OF (closed_shell);
	closed_shell_element : closed_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=  conditional_reverse(SELF.orientation, SELF.closed_shell_element.cfs_faces);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(SELF.closed_shell_element));
END_ENTITY; -- oriented_closed_shell


ENTITY oriented_edge
	SUBTYPE OF (edge);
	edge_element : edge;
	orientation : BOOLEAN;
DERIVE
	SELF\edge.edge_end : vertex :=  boolean_choose(SELF.orientation, SELF.edge_element.edge_end, SELF.edge_element.edge_start);
	SELF\edge.edge_start : vertex :=  boolean_choose(SELF.orientation, SELF.edge_element.edge_start, SELF.edge_element.edge_end);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
END_ENTITY; -- oriented_edge


ENTITY oriented_face
	SUBTYPE OF (face);
	face_element : face;
	orientation : BOOLEAN;
DERIVE
	SELF\face.bounds : SET [1:?] OF face_bound :=  conditional_reverse(SELF.orientation, SELF.face_element.bounds);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
END_ENTITY; -- oriented_face


ENTITY oriented_open_shell
	SUBTYPE OF (open_shell);
	open_shell_element : open_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face :=  conditional_reverse(SELF.orientation, SELF.open_shell_element.cfs_faces);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(SELF.open_shell_element));
END_ENTITY; -- oriented_open_shell


ENTITY oriented_path
	SUBTYPE OF (path);
	path_element : path;
	orientation : BOOLEAN;
DERIVE
	SELF\path.edge_list : LIST [1:?] OF  UNIQUE oriented_edge :=  conditional_reverse(SELF.orientation, SELF.path_element.edge_list);
WHERE
	WR1 :  NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
END_ENTITY; -- oriented_path


ENTITY path
	SUPERTYPE OF (ONEOF (open_path, edge_loop, oriented_path))
	SUBTYPE OF (topological_representation_item);
	edge_list : LIST [1:?] OF  UNIQUE oriented_edge;
WHERE
	WR1 :  path_head_to_tail(SELF);
END_ENTITY; -- path


ENTITY poly_loop
	SUBTYPE OF (loop, geometric_representation_item);
	polygon : LIST [3:?] OF  UNIQUE cartesian_point;
END_ENTITY; -- poly_loop


ENTITY seam_edge
	SUBTYPE OF (oriented_edge);
	pcurve_reference : pcurve;
WHERE
	WR1 : ('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_CURVE' IN  TYPEOF(edge_element))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SEAM_CURVE' IN TYPEOF(edge_element \ edge_curve.edge_geometry));
	WR2 :  pcurve_reference IN edge_element \ edge_curve.edge_geometry \ surface_curve.associated_geometry ;
END_ENTITY; -- seam_edge


ENTITY subedge
	SUBTYPE OF (edge);
	parent_edge : edge;
END_ENTITY; -- subedge


ENTITY subface
	SUBTYPE OF (face);
	parent_face : face;
WHERE
	WR1 :  NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))+ list_to_set(list_face_loops(parent_face))));
END_ENTITY; -- subface


ENTITY topological_representation_item
	SUPERTYPE OF (ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set, (loop ANDOR path)))
	SUBTYPE OF (representation_item);
END_ENTITY; -- topological_representation_item


ENTITY vertex
	SUBTYPE OF (topological_representation_item);
END_ENTITY; -- vertex


ENTITY vertex_loop
	SUBTYPE OF (loop);
	loop_vertex : vertex;
END_ENTITY; -- vertex_loop


ENTITY vertex_point
	SUBTYPE OF (vertex, geometric_representation_item);
	vertex_geometry : point;
END_ENTITY; -- vertex_point


ENTITY vertex_shell
	SUBTYPE OF (topological_representation_item);
	vertex_shell_extent : vertex_loop;
END_ENTITY; -- vertex_shell


ENTITY wire_shell
	SUBTYPE OF (topological_representation_item);
	wire_shell_extent : SET [1:?] OF loop;
WHERE
	WR1 :  NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY; -- wire_shell


ENTITY absorbed_dose_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ absorbed_dose_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = gray ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- absorbed_dose_measure_with_unit


ENTITY activity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ activity_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = becquerel ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- activity_measure_with_unit


ENTITY capacitance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ capacitance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = farad ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- capacitance_measure_with_unit


ENTITY conductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ conductance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = siemens ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- conductance_measure_with_unit


ENTITY dose_equivalent_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ dose_equivalent_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = sievert ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- dose_equivalent_measure_with_unit


ENTITY electric_charge_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ electric_charge_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = coulomb ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- electric_charge_measure_with_unit


ENTITY electromotive_force_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ electromotive_force_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = volt ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- electromotive_force_measure_with_unit


ENTITY energy_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ energy_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = joule ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- energy_measure_with_unit


ENTITY expression_conversion_based_unit
	SUBTYPE OF (context_dependent_unit, variable_semantics);
INVERSE
	associated_variable_environment: environment FOR semantics;
END_ENTITY; -- expression_conversion_based_unit


ENTITY force_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ force_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = newton ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- force_measure_with_unit


ENTITY frequency_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ frequency_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = hertz ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- frequency_measure_with_unit


ENTITY illuminance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ illuminance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = lux ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- illuminance_measure_with_unit


ENTITY inductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ inductance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = henry ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- inductance_measure_with_unit


ENTITY luminous_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ luminous_flux_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = lumen ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- luminous_flux_measure_with_unit


ENTITY magnetic_flux_density_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ magnetic_flux_density_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = tesla ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- magnetic_flux_density_measure_with_unit


ENTITY magnetic_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ magnetic_flux_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = weber ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- magnetic_flux_measure_with_unit


ENTITY power_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ power_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = watt ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- power_measure_with_unit


ENTITY pressure_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ pressure_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = pascal ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- pressure_measure_with_unit


ENTITY resistance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ measure_with_unit || SELF \ resistance_measure_with_unit)))= 0 ;
	WR2 :  SELF \ measure_with_unit.unit_component \ si_unit.name = ohm ;
	WR3 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SI_UNIT' IN TYPEOF(SELF \ measure_with_unit.unit_component);
	WR4 :  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_MEASURE' IN TYPEOF(SELF \ measure_with_unit.value_component);
END_ENTITY; -- resistance_measure_with_unit


ENTITY scattering_parameter
	SUBTYPE OF (polar_complex_number_literal);
WHERE
	WR1 :  SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF  \ polar_complex_number_literal || SELF \ scattering_parameter)))= 0 ;
END_ENTITY; -- scattering_parameter


ENTITY applied_action_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF action_request_item;
END_ENTITY; -- applied_action_request_assignment


SUBTYPE_CONSTRAINT component_definition_subtypes FOR component_definition;
	(ONEOF (printed_component, packaged_component, routed_physical_component) ANDOR thermal_component ANDOR cable_component);
END_SUBTYPE_CONSTRAINT; -- component_definition_subtypes

SUBTYPE_CONSTRAINT component_terminal_subtypes FOR component_terminal;
	ONEOF (assembly_module_macro_component_join_terminal, interconnect_module_macro_component_join_terminal);
END_SUBTYPE_CONSTRAINT; -- component_terminal_subtypes

SUBTYPE_CONSTRAINT model_parameter_subtypes FOR model_parameter;
	ONEOF (analytical_model_parameter, category_model_parameter, rule_function_domain_parameter, rule_function_range_parameter);
END_SUBTYPE_CONSTRAINT; -- model_parameter_subtypes

SUBTYPE_CONSTRAINT physical_unit_subtypes FOR physical_unit;
	ONEOF (bare_die, package, packaged_part, assembly_definition, interconnect_definition, reference_packaged_part_assembly_implementation, reference_packaged_part_interconnect_implementation);
END_SUBTYPE_CONSTRAINT; -- physical_unit_subtypes

SUBTYPE_CONSTRAINT shape_definition_3d_intersection_subtypes FOR shape_definition_3d_intersection;
	ONEOF (edge_segment_cross_section, pre_defined_parallel_datum_axis_symbol_3d_2d_relationship, pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship, pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship);
END_SUBTYPE_CONSTRAINT; -- shape_definition_3d_intersection_subtypes

SUBTYPE_CONSTRAINT assembly_module_terminal_subtypes FOR assembly_module_terminal;
	ONEOF (assembly_module_interface_terminal, assembly_module_join_terminal);
END_SUBTYPE_CONSTRAINT; -- assembly_module_terminal_subtypes

SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
	ONEOF (classification, complete_membership);
END_SUBTYPE_CONSTRAINT; -- classification_or_complete_membership

SUBTYPE_CONSTRAINT component_shape_aspect_subtypes FOR component_shape_aspect;
	(ONEOF (land, connected_area_component, inter_stratum_feature) ANDOR thermal_component_shape_aspect);
END_SUBTYPE_CONSTRAINT; -- component_shape_aspect_subtypes

SUBTYPE_CONSTRAINT plated_inter_stratum_feature_subtypes FOR plated_inter_stratum_feature;
	ONEOF (plated_passage, plated_cutout_edge_segment, plated_interconnect_module_edge_segment);
END_SUBTYPE_CONSTRAINT; -- plated_inter_stratum_feature_subtypes

SUBTYPE_CONSTRAINT interconnect_module_terminal_subtypes FOR interconnect_module_terminal;
	ONEOF (interconnect_module_interface_terminal, interconnect_module_join_terminal);
END_SUBTYPE_CONSTRAINT; -- interconnect_module_terminal_subtypes

SUBTYPE_CONSTRAINT pdds_shape_definition_3d_intersection_subtypes FOR shape_definition_3d_intersection;
	ONEOF (pre_defined_parallel_datum_axis_symbol_3d_2d_relationship, pre_defined_perpendicular_datum_axis_symbol_3d_2d_relationship, pre_defined_perpendicular_datum_plane_symbol_3d_2d_relationship);
END_SUBTYPE_CONSTRAINT; -- pdds_shape_definition_3d_intersection_subtypes

RULE analytical_model_port_unique_constraint FOR (analytical_model_port);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 amp_bag : BAG  OF  analytical_model_port;
 rr_bag : BAG  OF  representation_relationship;
 pass : BOOLEAN := TRUE;
 am_bag : BAG OF analytical_model;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(analytical_model_port)BY  1;
 IF  EXISTS(analytical_model_port [ i ] \ representation.name)THEN  IF(NOT(analytical_model_port [ i ] \ representation.name IN  name_bag))THEN  name_bag := name_bag + analytical_model_port [ i ] \ representation.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 amp_bag := QUERY(amp <* analytical_model_port |(amp \ representation.name = name_bag [ i ]));
 am_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(amp_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 rr_bag := QUERY(rr <* USEDIN(amp_bag [ j ], 'ANALYTICAL_MODEL_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|((rr \ representation_relationship.name = 'access mechanism')AND('ANALYTICAL_MODEL_MIM.' + 'ANALYTICAL_MODEL' IN  TYPEOF(rr.rep_1))));
 REPEAT k := 1 TO SIZEOF(rr_bag)BY 1;
 IF  EXISTS(rr_bag [ k ].rep_1)THEN  IF(rr_bag [ k ].rep_1 IN am_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE am_bag := am_bag + rr_bag [ k ].rep_1;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- analytical_model_port_unique_constraint

RULE application_context_requires_ap_definition FOR (application_context, application_protocol_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(ac <* application_context | NOT(SIZEOF(QUERY(apd <* application_protocol_definition |(ac :=: apd \ application_protocol_definition.application)AND(apd \ application_protocol_definition.application_interpreted_model_schema_name = 'electronic_assembly_interconnect_and_packaging_design')))= 1)))= 0 ;
END_RULE; -- application_context_requires_ap_definition

RULE dependent_instantiable_tolerance_value FOR (tolerance_value);
 
WHERE
	WR1 :  SIZEOF(QUERY(tv <* tolerance_value | NOT(SIZEOF(USEDIN(tv, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_tolerance_value

RULE ee_product_definition_unique_constraint FOR (product_definition_with_associated_documents, physical_unit, functional_unit);
 LOCAL
 pdwad : BAG  OF  product_definition := QUERY(r <* product_definition_with_associated_documents |(TRUE));
 pu : BAG  OF  product_definition := QUERY(r <* physical_unit |(TRUE));
 fu : BAG  OF  product_definition := QUERY(r <* functional_unit |(TRUE));
 epd : BAG  OF  product_definition;
 pdf_bag : BAG  OF  product_definition_formation;
 pd_bag : BAG  OF  product_definition;
 pass1 : BOOLEAN  := TRUE ;
 lcs_bag : BAG  OF  STRING ;
 pass2 : BOOLEAN := TRUE;
 id_bag : BAG OF STRING;
 END_LOCAL
;
 epd := pdwad + pu + fu;
 REPEAT  i := 1 TO  SIZEOF(epd)BY  1;
 IF  EXISTS(epd [ i ].formation)THEN  IF(NOT(epd [ i ].formation IN  pdf_bag))THEN  pdf_bag := pdf_bag + epd [ i ].formation;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pdf_bag)BY  1;
 IF(NOT(pass1 OR  pass2))THEN  ESCAPE ;
 END_IF ;
 lcs_bag := [ ];
 id_bag := [ ];
 pd_bag := QUERY(pd <* epd |(pd.formation :=: pdf_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(pd_bag)BY 1;
 IF(NOT(pass1 OR pass2))THEN  ESCAPE ;
 END_IF ;
 IF(pass2)THEN  IF  EXISTS(pd_bag [ j ].id)THEN  IF(pd_bag [ j ].id IN id_bag)THEN pass2 := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + pd_bag [ j ].id;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass2 ;
END_RULE; -- ee_product_definition_unique_constraint

RULE no_shape_for_make_from FOR (make_from_usage_option);
 
WHERE
	WR1 :  SIZEOF(QUERY(mfuo <* make_from_usage_option | NOT(SIZEOF(QUERY(pd <* USEDIN(mfuo, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)))= 0)))= 0 ;
END_RULE; -- no_shape_for_make_from

RULE origin_constraint FOR (placement);
 LOCAL
 origin_2d : SET  OF  axis2_placement_2d := QUERY(pl <* placement |((pl \ representation_item.name = 'origin')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.AXIS2_PLACEMENT_2D' IN  TYPEOF(pl))));
 origin_3d : SET OF axis2_placement_3d := QUERY(pl <* placement |((pl \ representation_item.name = 'origin')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.AXIS2_PLACEMENT_3D' IN TYPEOF(pl))));
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(origin_2d)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 IF(NOT((origin_2d [ i ].location.coordinates [ 1 ] = 0.0)AND(origin_2d [ i ].location.coordinates [ 2 ] = 0.0)AND  NOT  EXISTS(origin_2d [ i ].ref_direction)))THEN  pass := FALSE ;
 END_IF ;
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(origin_3d)BY 1;
 IF(NOT  pass)THEN  ESCAPE;
 END_IF ;
 IF NOT((origin_3d [ i ].location.coordinates [ 1 ] = 0.0)AND(origin_3d [ i ].location.coordinates [ 2 ] = 0.0)AND(origin_3d [ i ].location.coordinates [ 3 ] = 0.0)AND(NOT(EXISTS(origin_3d [ i ].ref_direction)))AND(NOT(EXISTS(origin_3d [ i ].axis))))THEN pass := FALSE;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- origin_constraint

RULE part_feature_unique_constraint FOR (composite_shape_aspect, shape_aspect, primary_orientation_feature, tertiary_orientation_feature, secondary_orientation_feature, package_body, part_tooling_feature, thermal_feature, part_mounting_feature, package_terminal, assembly_module_terminal, bare_die_terminal, interconnect_module_terminal, minimally_defined_bare_die_terminal, packaged_part_terminal, package_body_surface);
 LOCAL
 csa : BAG  OF  shape_aspect := QUERY(r <* composite_shape_aspect |(r \ shape_aspect.description = 'part group feature'));
 sa : BAG  OF  shape_aspect := QUERY(r <* shape_aspect |(r \ shape_aspect.description IN  [ 'part generic feature', 'polarity indication feature', 'interconnect module edge segment surface', 'interconnect module cavity surface', 'interconnect module cutout surface', 'interconnect module edge surface', 'interconnect module primary surface', 'interconnect module secondary surface', 'interconnect module surface feature' ]));
 pof : BAG  OF  shape_aspect := QUERY(r <* primary_orientation_feature |(TRUE));
 sof : BAG  OF  shape_aspect := QUERY(r <* secondary_orientation_feature |(TRUE));
 tof : BAG  OF  shape_aspect := QUERY(r <* tertiary_orientation_feature |(TRUE));
 pb : BAG  OF  shape_aspect := QUERY(r <* package_body |(TRUE));
 ptf : BAG  OF  shape_aspect := QUERY(r <* part_tooling_feature |(TRUE));
 tf : BAG  OF  shape_aspect := QUERY(r <* thermal_feature |(TRUE));
 pmf : BAG  OF  shape_aspect := QUERY(r <* part_mounting_feature |(TRUE));
 pt : BAG  OF  shape_aspect := QUERY(r <* package_terminal |(TRUE));
 amt : BAG  OF  shape_aspect := QUERY(r <* assembly_module_terminal |(TRUE));
 bdt : BAG  OF  shape_aspect := QUERY(r <* bare_die_terminal |(TRUE));
 imt : BAG  OF  shape_aspect := QUERY(r <* interconnect_module_terminal |(TRUE));
 mdbdt : BAG  OF  shape_aspect := QUERY(r <* minimally_defined_bare_die_terminal |(TRUE));
 ppt : BAG  OF  shape_aspect := QUERY(r <* packaged_part_terminal |(TRUE));
 pbs : BAG  OF  shape_aspect := QUERY(r <* package_body_surface |(TRUE));
 pf : BAG  OF  shape_aspect := [ ];
 pu_bag : BAG  OF  physical_unit := [ ];
 sa_bag : BAG  OF  shape_aspect;
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING;
 END_LOCAL
;
 sa := csa + sa + pof + sof + tof + pb + ptf + tf + pmf + pt + amt + bdt + imt + mdbdt + ppt + pbs;
 REPEAT  i := 1 TO  SIZEOF(sa)BY  1;
 IF  EXISTS(sa [ i ])THEN  IF(NOT(sa [ i ] IN  pf))THEN  pf := pf + sa [ i ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pf)BY  1;
 IF  EXISTS(pf [ i ].of_shape.definition)THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(pf [ i ].of_shape.definition))AND(pf [ i ].of_shape.definition.frame_of_reference.name = 'physical design usage'))THEN  IF(NOT(pf [ i ].of_shape.definition IN  pu_bag))THEN  pu_bag := pu_bag + pf [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 name_bag := [ ];
 sa_bag := QUERY(sa <* pf |(sa.of_shape.definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(sa_bag)BY 1;
 IF  EXISTS(sa_bag [ j ] \ shape_aspect.name)THEN  IF(sa_bag [ j ] \ shape_aspect.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + sa_bag [ j ] \ shape_aspect.name;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- part_feature_unique_constraint

RULE restrict_manifold_surface_shape_representation FOR (manifold_surface_shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |(mssr \ representation.name IN  [ 'stratum feature non planar 2d shape', 'open shell based surface', 'design intent modification non planar 2d shape', 'part template non planar 2d shape' ])AND(NOT(SIZEOF(QUERY(sbsm <* mssr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHELL_BASED_SURFACE_MODEL' IN  TYPEOF(sbsm))AND(SIZEOF(QUERY(os <* sbsm \ shell_based_surface_model.sbsm_boundary | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'OPEN_SHELL' IN TYPEOF(os)))= 1)))= 1))))= 0 ;
END_RULE; -- restrict_manifold_surface_shape_representation

RULE shape_representation_requires_origin FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation | NOT((SIZEOF(QUERY(it <* sr \ representation.items |(((it \ representation_item.name = 'origin')OR(it \ representation_item.name = 'orientation'))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN  TYPEOF(it))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN  TYPEOF(it))))))= 1)OR(SIZEOF(QUERY(it <* sr \ representation.items |(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STYLED_ITEM' IN TYPEOF(it)))))>= 1)OR(SIZEOF(QUERY(it <* sr \ representation.items |(((it \ representation_item.name = 'origin')OR(it \ representation_item.name = 'orientation'))AND((sr \ representation.name = 'zone shape')OR(sr.context_of_items \ representation_context.context_type = 'connection zone colour')))))= 0))))= 0 ;
END_RULE; -- shape_representation_requires_origin

RULE subtype_combination_shape_aspect FOR (shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_BOND_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MINIMALLY_DEFINED_BARE_DIE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_REFERENCE_FRAME', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DERIVED_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DEVICE_TERMINAL_MAP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FABRICATION_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERFACE_MOUNTED_JOIN', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER_CONNECTION_POINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MOUNTING_RESTRICTION_AREA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_ELEMENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_NETWORK', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_MODIFICATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_CONCEPT_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_BOUNDARY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VIEWING_PLANE' ] * TYPEOF(sa))<= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_BOND_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MINIMALLY_DEFINED_BARE_DIE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_REFERENCE_FRAME', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DEVICE_TERMINAL_MAP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FABRICATION_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERFACE_MOUNTED_JOIN', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER_CONNECTION_POINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MOUNTING_RESTRICTION_AREA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_ELEMENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_NETWORK', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_MODIFICATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_CONCEPT_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_BOUNDARY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VIEWING_PLANE' ] * TYPEOF(sa))<= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_BOND_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DATUM_REFERENCE_FRAME', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DERIVED_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DEVICE_TERMINAL_MAP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FABRICATION_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERFACE_MOUNTED_JOIN', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAND_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER_CONNECTION_POINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MOUNTING_RESTRICTION_AREA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_CONNECTED_TERMINALS_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PASSAGE_TECHNOLOGY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_ELEMENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_NETWORK', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM_TARGET', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_CROSS_SECTION_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_CONNECTED_TERMINALS_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SEQUENTIAL_LAMINATE_PASSAGE_BASED_FABRICATION_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_MODIFICATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_CONCEPT_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TOLERANCE_ZONE_BOUNDARY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VIEWING_PLANE' ] * TYPEOF(sa))<= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM_FEATURE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM_TARGET', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_DATUM' ] * TYPEOF(sa))<= 1)))= 0 ;
END_RULE; -- subtype_combination_shape_aspect

RULE subtype_exclusive_mapped_item FOR (mapped_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(mi <* mapped_item | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANNOTATION_TEXT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANNOTATION_SYMBOL' ] * TYPEOF(mi))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_mapped_item

RULE subtype_exclusive_product_definition FOR (product_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NETWORK_NODE_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' ] * TYPEOF(pd))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_product_definition

RULE subtype_exclusive_property_definition FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_SIZE_PROPERTY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE_GROUP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_PROPERTY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SIGNAL' ] * TYPEOF(pd))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_property_definition

RULE subtype_exclusive_representation FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANALYTICAL_MODEL_PORT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_LOCATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_FUNCTION_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRUCTURED_TEXT_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEXT_STRING_REPRESENTATION' ] * TYPEOF(rep))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_representation

RULE subtype_exclusive_representation_context FOR (representation_context);
 LOCAL
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(representation_context)BY 1;
 pass :=(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'STRUCTURED_TEXT_REPRESENTATION_CONTEXT' IN  TYPEOF(representation_context [ i ]))OR(SIZEOF(TYPEOF(representation_context [ i ]))<= 2))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'GEOMETRIC_REPRESENTATION_CONTEXT' IN  TYPEOF(representation_context [ i ]))OR(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'GEOMETRIC_REPRESENTATION_CONTEXT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'PARAMETRIC_REPRESENTATION_CONTEXT' ] * TYPEOF(representation_context [ i ]))<= 2))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'PARAMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(representation_context [ i ]))OR(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'GEOMETRIC_REPRESENTATION_CONTEXT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM.' + 'PARAMETRIC_REPRESENTATION_CONTEXT' ] * TYPEOF(representation_context [ i ]))<= 2));
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- subtype_exclusive_representation_context

RULE subtype_exclusive_shape_aspect_relationship FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_JOINT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DEVICE_TERMINAL_MAP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_LOCATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERFACE_MOUNTED_JOIN', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAKE_FROM_CONNECTIVITY_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAKE_FROM_FEATURE_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_CONNECTOR_TERMINAL_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_ELEMENT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_DERIVING_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_CONCEPT_RELATIONSHIP' ] * TYPEOF(sar))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_shape_aspect_relationship

RULE subtype_mandatory_action FOR (action);
 
WHERE
	WR1 :  SIZEOF(QUERY(act <* action | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIRECTED_ACTION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXECUTED_ACTION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_ACTION' ] * TYPEOF(act))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_action

RULE subtype_mandatory_externally_defined_item FOR (externally_defined_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(edi <* externally_defined_item | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BOND_CATEGORY', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_CURVE_FONT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_HATCH_STYLE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_SYMBOL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_TEXT_FONT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_TILE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_TILE_STYLE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RULE_DEFINITION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SIGNAL_CATEGORY' ] * TYPEOF(edi))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_externally_defined_item

RULE subtype_mandatory_pre_defined_item FOR (pre_defined_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdi <* pre_defined_item | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRE_DEFINED_TEXT_FONT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRE_DEFINED_CURVE_FONT' ] * TYPEOF(pdi))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_pre_defined_item

RULE subtype_mandatory_text_literal FOR (text_literal);
 
WHERE
	WR1 :  SIZEOF(QUERY(tl <* text_literal | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEXT_LITERAL_WITH_EXTENT' IN  TYPEOF(tl))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TEXT_LITERAL_WITH_ASSOCIATED_CURVES' IN TYPEOF(tl)))))= 0 ;
END_RULE; -- subtype_mandatory_text_literal

RULE approval_requires_approval_date_time FOR (approval, approval_date_time);
 
WHERE
	WR1 :  SIZEOF(QUERY(app <* approval | NOT(SIZEOF(QUERY(adt <* approval_date_time | app :=: adt.dated_approval))= 1)))= 0 ;
END_RULE; -- approval_requires_approval_date_time

RULE approval_requires_approval_person_organization FOR (approval, approval_person_organization);
 
WHERE
	WR1 :  SIZEOF(QUERY(app <* approval | NOT(SIZEOF(QUERY(apo <* approval_person_organization | app :=: apo.authorized_approval))>= 1)))= 0 ;
END_RULE; -- approval_requires_approval_person_organization

RULE approval_role_constraint FOR (approval_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(apr <* approval_role | NOT(apr \ approval_role.role = 'authorizer')))= 0 ;
END_RULE; -- approval_role_constraint

RULE approvals_are_assigned FOR (approval, approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(app <* approval | NOT(SIZEOF(QUERY(aa <* approval_assignment | app :=: aa.assigned_approval))>= 1)))= 0 ;
END_RULE; -- approvals_are_assigned

RULE assembly_composition_relationship_unique_constraint FOR (assembly_component_usage);
 LOCAL
 acr : BAG  OF  assembly_component_usage := QUERY(acu <* assembly_component_usage |(acu \ product_definition_relationship.name = 'assembly composition'));
 pu_bag : BAG  OF  physical_unit := [ ];
 acu_bag : BAG  OF  assembly_component_usage;
 pass : BOOLEAN := TRUE;
 cd_bag : BAG OF component_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(acr)BY  1;
 IF  EXISTS(acr [ i ].relating_product_definition)THEN  IF((acr [ i ].relating_product_definition.frame_of_reference.name = 'physical design')AND('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(acr [ i ].relating_product_definition)))THEN  IF(NOT(acr [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + acr [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 cd_bag := [ ];
 acu_bag := QUERY(acu <* acr |(acu.relating_product_definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(acu_bag)BY 1;
 IF  EXISTS(acu_bag [ j ].related_product_definition)THEN  IF('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(acu_bag [ j ].related_product_definition))THEN  IF(acu_bag [ j ].related_product_definition IN cd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE cd_bag := cd_bag + acu_bag [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- assembly_composition_relationship_unique_constraint

RULE certification_requires_date_or_date_and_time FOR (certification, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(cert <* certification | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment | cert IN  adata.items))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment | cert IN ada.items))= 1))))= 0 ;
END_RULE; -- certification_requires_date_or_date_and_time

RULE certification_unique_constraint FOR (certification);
 LOCAL
 r : BAG  OF  certification := QUERY(r <* certification | TRUE );
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ] \ certification.name)THEN  IF(r [ i ] \ certification.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + r [ i ] \ certification.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- certification_unique_constraint

RULE configuration_item_requires_person_organization FOR (configuration_item, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(ci <* configuration_item | NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | ci IN  apaoa.items))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | ci IN aoa.items))= 1))))= 0 ;
END_RULE; -- configuration_item_requires_person_organization

RULE contract_unique_constraint FOR (contract);
 LOCAL
 r : BAG  OF  contract := QUERY(r <* contract | TRUE );
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ] \ contract.name)THEN  IF(r [ i ] \ contract.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + r [ i ] \ contract.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- contract_unique_constraint

RULE date_and_time_require_minute_and_second FOR (date_and_time);
 
WHERE
	WR1 :  SIZEOF(QUERY(dat <* date_and_time | NOT(EXISTS(dat.time_component.minute_component))))= 0 ;
	WR2 :  SIZEOF(QUERY(dat <* date_and_time | NOT(EXISTS(dat.time_component.second_component))))= 0 ;
END_RULE; -- date_and_time_require_minute_and_second

RULE date_constraint FOR (date);
 
WHERE
	WR1 :  SIZEOF(QUERY(d <* date | d.year_component < 1856))= 0 ;
END_RULE; -- date_constraint

RULE dependent_instantiable_action_directive FOR (action_directive);
 
WHERE
	WR1 :  SIZEOF(QUERY(ad <* action_directive | NOT(SIZEOF(USEDIN(ad, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_action_directive

RULE dependent_instantiable_approval_status FOR (approval_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ast <* approval_status | NOT(SIZEOF(USEDIN(ast, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_approval_status

RULE dependent_instantiable_certification_type FOR (certification_type);
 
WHERE
	WR1 :  SIZEOF(QUERY(ct <* certification_type | NOT(SIZEOF(USEDIN(ct, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_certification_type

RULE dependent_instantiable_contract_type FOR (contract_type);
 
WHERE
	WR1 :  SIZEOF(QUERY(ct <* contract_type | NOT(SIZEOF(USEDIN(ct, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_contract_type

RULE dependent_instantiable_date FOR (date);
 
WHERE
	WR1 :  SIZEOF(QUERY(dt <* date | NOT(SIZEOF(USEDIN(dt, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_date

RULE dependent_instantiable_date_role FOR (date_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(dr <* date_role | NOT(SIZEOF(USEDIN(dr, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_date_role

RULE dependent_instantiable_date_time_role FOR (date_time_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(dtr <* date_time_role | NOT(SIZEOF(USEDIN(dtr, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_date_time_role

RULE dependent_instantiable_document_type FOR (document_type);
 
WHERE
	WR1 :  SIZEOF(QUERY(dt <* document_type | NOT(SIZEOF(USEDIN(dt, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_document_type

RULE dependent_instantiable_named_unit FOR (named_unit);
 
WHERE
	WR1 :  SIZEOF(QUERY(nu <* named_unit | NOT(SIZEOF(USEDIN(nu, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_named_unit

RULE dependent_instantiable_organization_role FOR (organization_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(org <* organization_role | NOT(SIZEOF(USEDIN(org, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_organization_role

RULE dependent_instantiable_parametric_representation_context FOR (parametric_representation_context);
 
WHERE
	WR1 :  SIZEOF(QUERY(prc <* parametric_representation_context | NOT(SIZEOF(USEDIN(prc, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_parametric_representation_context

RULE dependent_instantiable_person_and_organization_role FOR (person_and_organization_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(poar <* person_and_organization_role | NOT(SIZEOF(USEDIN(poar, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_person_and_organization_role

RULE dependent_instantiable_representation_item FOR (representation_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(ri <* representation_item | NOT(SIZEOF(USEDIN(ri, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_representation_item

RULE dependent_instantiable_security_classification_level FOR (security_classification_level);
 
WHERE
	WR1 :  SIZEOF(QUERY(scl <* security_classification_level | NOT(SIZEOF(USEDIN(scl, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_security_classification_level

RULE dependent_instantiable_shape_representation FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation | NOT(SIZEOF(USEDIN(sr, ''))>= 1)))= 0 ;
END_RULE; -- dependent_instantiable_shape_representation

RULE directed_action_requires_approval FOR (directed_action, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(da <* directed_action | NOT(SIZEOF(QUERY(aaa <* applied_approval_assignment | da IN aaa.items))= 1)))= 0 ;
END_RULE; -- directed_action_requires_approval

RULE directed_action_requires_date_or_date_and_time FOR (directed_action, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(da <* directed_action | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment |(da IN  adata.items)AND(adata.role \ date_time_role.name = 'start date')))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment |(da IN ada.items)AND(ada.role \ date_role.name = 'start date')))= 1))))= 0 ;
END_RULE; -- directed_action_requires_date_or_date_and_time

RULE ee_document_constraint FOR (document);
 
WHERE
	WR1 :  SIZEOF(QUERY(doc <* document |(SIZEOF(QUERY(adata <* USEDIN(doc, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')|(adata.role \ date_time_role.name = 'creation date')))= 0)))= 0 ;
	WR2 :  SIZEOF(QUERY(doc <* document | NOT((SIZEOF(QUERY(aoa <* USEDIN(doc, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'publisher')))= 1)OR(SIZEOF(QUERY(apaoa <* USEDIN(doc, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(apaoa.role \ person_and_organization_role.name = 'publisher')))= 1))))= 0 ;
	WR3 :  SIZEOF(QUERY(doc <* document | NOT(SIZEOF(USEDIN(doc, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS'))= 1)))= 0 ;
END_RULE; -- ee_document_constraint

RULE ee_document_unique_constraint FOR (document, document_identifier_assignment);
 LOCAL
 pass : BOOLEAN := TRUE;
 rev_exists_bag : BAG  OF  document := [ ];
 dia_bag : BAG  OF  document_identifier_assignment := [ ];
 desc_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(document)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 IF  NOT(EXISTS(document [ i ].description))THEN  pass := FALSE ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(document_identifier_assignment)BY  1;
 IF(NOT  pass)THEN  ESCAPE;
 END_IF ;
 desc_bag := [ ];
 REPEAT j := 1 TO SIZEOF(document_identifier_assignment [ i ].items)BY 1;
 desc_bag := desc_bag + document_identifier_assignment [ i ].items [ j ] \ document.description;
 END_REPEAT ;
 IF NOT(VALUE_UNIQUE(desc_bag))THEN pass := FALSE;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_document_unique_constraint

RULE ee_material_unique_constraint FOR (material_designation);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 md_bag : BAG  OF  material_designation;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 doc_bag : BAG OF ee_specification;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(material_designation)BY  1;
 IF  EXISTS(material_designation [ i ].name)THEN  IF(NOT(material_designation [ i ].name IN  name_bag))THEN  name_bag := name_bag + material_designation [ i ].name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 md_bag := QUERY(md <* material_designation |(md \ material_designation.name = name_bag [ i ]));
 doc_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(md_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := QUERY(adr <* USEDIN(md_bag [ j ],('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'DOCUMENT')IN  TYPEOF(adr.assigned_document)));
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN doc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE doc_bag := doc_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_material_unique_constraint

RULE ee_product_configuration_unique_constraint FOR (configuration_item);
 LOCAL
 id_bag : BAG  OF  STRING := [ ];
 ci_bag : BAG  OF  configuration_item;
 cd_bag : BAG  OF  configuration_design;
 pass : BOOLEAN := TRUE;
 pdf_bag : BAG OF product_definition_formation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(configuration_item)BY  1;
 IF  EXISTS(configuration_item [ i ].id)THEN  IF(NOT(configuration_item [ i ].id IN  id_bag))THEN  id_bag := id_bag + configuration_item [ i ].id;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(id_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdf_bag := [ ];
 ci_bag := QUERY(ci <* configuration_item |(ci.id = id_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(ci_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 cd_bag := USEDIN(ci_bag [ j ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'CONFIGURATION_DESIGN.CONFIGURATION');
 REPEAT k := 1 TO SIZEOF(cd_bag)BY 1;
 IF  EXISTS(cd_bag [ k ].design)THEN  IF(cd_bag [ k ].design IN pdf_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pdf_bag := pdf_bag + cd_bag [ k ].design;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_product_configuration_unique_constraint

RULE ee_product_constraint FOR (product);
 
WHERE
	WR1 :  SIZEOF(QUERY(prod <* product | NOT((SIZEOF(QUERY(aoa <* USEDIN(prod, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'design owner')))= 1)OR(SIZEOF(QUERY(apaoa <* USEDIN(prod, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(apaoa.role \ person_and_organization_role.name = 'design owner')))= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(p <* product | SIZEOF(USEDIN(p, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'))= 0))= 0 ;
END_RULE; -- ee_product_constraint

RULE ee_product_definition_constraint FOR (product_definition_with_associated_documents);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(QUERY(adata <* USEDIN(pdwad, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS')|(adata.role \ date_time_role.name = 'creation date')))= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(QUERY(aoa <* USEDIN(pdwad, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'creator')))= 1)OR(SIZEOF(QUERY(apaoa <* USEDIN(pdwad, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(apaoa.role \ person_and_organization_role.name = 'creator')))= 1))))= 0 ;
	WR3 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(USEDIN(pdwad, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 1))))= 0 ;
	WR4 :  SIZEOF(QUERY(pdwad <* product_definition_with_associated_documents | NOT((SIZEOF(USEDIN(pdwad, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 1))))= 0 ;
END_RULE; -- ee_product_definition_constraint

RULE ee_product_model_unique_constraint FOR (product_concept);
 LOCAL
 r : BAG  OF  product_concept := QUERY(r <* product_concept | TRUE );
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ].id)THEN  IF(r [ i ] \ product_concept.id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + r [ i ].id;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_product_model_unique_constraint

RULE ee_product_unique_constraint FOR (product);
 LOCAL
 id_bag : BAG  OF  STRING := [ ];
 p_bag : BAG  OF  product;
 aoa_bag : BAG  OF  applied_organization_assignment;
 apaoa_bag : BAG  OF  applied_person_and_organization_assignment;
 pass : BOOLEAN := TRUE;
 o_bag : BAG  OF  organization;
 pao_bag : BAG OF person_and_organization;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(product)BY  1;
 IF  EXISTS(product [ i ].id)THEN  IF(NOT(product [ i ].id IN  id_bag))THEN  id_bag := id_bag + product [ i ].id;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(id_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 o_bag := [ ];
 pao_bag := [ ];
 p_bag := QUERY(p <* product |(p.id = id_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(p_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 aoa_bag := QUERY(aoa <* USEDIN(p_bag [ j ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'ORGANIZATION' IN  TYPEOF(aoa.assigned_organization))AND(aoa.role \ organization_role.name = 'design owner')));
 REPEAT  k := 1 TO  SIZEOF(aoa_bag)BY  1;
 IF  EXISTS(aoa_bag [ k ].assigned_organization)THEN  IF(aoa_bag [ k ].assigned_organization IN  o_bag)THEN  pass := FALSE ;
 ESCAPE ;
 ELSE  o_bag := o_bag + aoa_bag [ k ].assigned_organization;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 apaoa_bag := QUERY(apaoa <* USEDIN(p_bag [ j ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS')|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PERSON_AND_ORGANIZATION' IN  TYPEOF(apaoa.assigned_person_and_organization))AND(apaoa.role \ person_and_organization_role.name = 'design owner')));
 REPEAT k := 1 TO SIZEOF(apaoa_bag)BY 1;
 IF  EXISTS(apaoa_bag [ k ].assigned_person_and_organization)THEN  IF(apaoa_bag [ k ].assigned_person_and_organization IN pao_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pao_bag := pao_bag + apaoa_bag [ k ].assigned_person_and_organization;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- ee_product_unique_constraint

RULE ee_product_version_supersedence_constraint FOR (product_definition_formation_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |((pdfr \ product_definition_formation_relationship.name = 'product version supersedence')AND(NOT(pdfr.relating_product_definition_formation.of_product :=: pdfr.related_product_definition_formation.of_product)))))= 0 ;
END_RULE; -- ee_product_version_supersedence_constraint

RULE next_higher_assembly_relationship_constraint FOR (next_assembly_usage_occurrence);
 
WHERE
	WR1 :  SIZEOF(QUERY(nauo <* next_assembly_usage_occurrence | NOT(SIZEOF(QUERY(pd <* USEDIN(nauo, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|((SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_LOCATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 3)))<= 1)AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_LOCATION' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))<= 1))))<= 1)))= 0 ;
END_RULE; -- next_higher_assembly_relationship_constraint

RULE next_higher_assembly_relationship_unique_constraint FOR (next_assembly_usage_occurrence);
 LOCAL
 pu_bag : BAG  OF  physical_unit := [ ];
 nauo_bag : BAG  OF  next_assembly_usage_occurrence;
 pass : BOOLEAN := TRUE;
 refdes_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(next_assembly_usage_occurrence)BY  1;
 IF  EXISTS(next_assembly_usage_occurrence [ i ].relating_product_definition)THEN  IF((next_assembly_usage_occurrence [ i ].relating_product_definition.frame_of_reference.name = 'physical design')AND('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(next_assembly_usage_occurrence [ i ].relating_product_definition)))THEN  IF(NOT(next_assembly_usage_occurrence [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + next_assembly_usage_occurrence [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 refdes_bag := [ ];
 nauo_bag := QUERY(nauo <* next_assembly_usage_occurrence |(nauo.relating_product_definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(nauo_bag)BY 1;
 IF  EXISTS(nauo_bag [ j ].reference_designator)THEN  IF(nauo_bag [ j ].reference_designator IN refdes_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE refdes_bag := refdes_bag + nauo_bag [ j ].reference_designator;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- next_higher_assembly_relationship_unique_constraint

RULE organization_unique_constraint FOR (organization);
 LOCAL
 r : BAG  OF  organization := QUERY(r <* organization | TRUE );
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ].id)THEN  IF(r [ i ] \ organization.id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + r [ i ].id;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- organization_unique_constraint

RULE planned_effectivity_constraint FOR (configuration_effectivity);
 
WHERE
	WR1 :  SIZEOF(QUERY(ce <* configuration_effectivity | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF(ce.usage))AND(ce.usage \ product_definition_relationship.name = 'assembly composition'))))= 0 ;
	WR2 :  SIZEOF(QUERY(ce <* configuration_effectivity | SIZEOF(USEDIN(ce, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS'))= 0))= 0 ;
END_RULE; -- planned_effectivity_constraint

RULE planned_effectivity_unique_constraint FOR (configuration_effectivity);
 LOCAL
 ce_bag : BAG  OF  configuration_effectivity;
 ci_bag : BAG  OF  configuration_item := [ ];
 pass : BOOLEAN := TRUE;
 acu_bag : BAG OF assembly_component_usage;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(configuration_effectivity)BY  1;
 IF  EXISTS(configuration_effectivity [ i ].configuration.configuration)THEN  IF(NOT(configuration_effectivity [ i ].configuration.configuration IN  ci_bag))THEN  ci_bag := ci_bag + configuration_effectivity [ i ].configuration.configuration;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(ci_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 ce_bag := QUERY(r <* configuration_effectivity |((r.configuration.configuration :=: ci_bag [ i ])AND(r.usage \ product_definition_relationship.name = 'assembly composition')AND('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'ASSEMBLY_COMPONENT_USAGE' IN  TYPEOF(r.usage))));
 acu_bag := [ ];
 REPEAT j := 1 TO SIZEOF(ce_bag)BY 1;
 IF  EXISTS(ce_bag [ j ].usage)THEN  IF(ce_bag [ j ].usage IN acu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE acu_bag := acu_bag + ce_bag [ j ].usage;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- planned_effectivity_unique_constraint

RULE product_association_constraint FOR (product_definition_formation_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdfr <* product_definition_formation_relationship |(pdfr \ product_definition_formation_relationship.name = 'product association')AND(SIZEOF(QUERY(adr <* USEDIN(pdfr, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EE_SPECIFICATION' IN TYPEOF(adr.assigned_document))))= 0)))= 0 ;
END_RULE; -- product_association_constraint

RULE product_association_unique_constraint FOR (product_definition_formation_relationship);
 LOCAL
 pdfr : BAG  OF  product_definition_formation_relationship := QUERY(r <* product_definition_formation_relationship |(r \ product_definition_formation_relationship.name = 'product association'));
 pdf_bag : BAG  OF  product_definition_formation := [ ];
 pdfr_bag : BAG  OF  product_definition_formation_relationship;
 pass : BOOLEAN := TRUE;
 adr_bag : BAG  OF  applied_document_reference;
 es_bag : BAG OF ee_specification;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pdfr)BY  1;
 IF  EXISTS(pdfr [ i ].relating_product_definition_formation)THEN  IF(NOT(pdfr [ i ].relating_product_definition_formation IN  pdf_bag))THEN  pdf_bag := pdf_bag + pdfr [ i ].relating_product_definition_formation;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pdf_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdfr_bag := QUERY(r <* pdfr |(r.relating_product_definition_formation :=: pdf_bag [ i ]));
 es_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(pdfr_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := QUERY(adr <* USEDIN(pdfr_bag [ j ],('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS'))|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'EE_SPECIFICATION')IN  TYPEOF(adr.assigned_document)));
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN es_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE es_bag := es_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- product_association_unique_constraint

RULE product_concept_requires_configuration_item FOR (product_concept, configuration_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(pc <* product_concept | NOT(SIZEOF(QUERY(ci <* configuration_item | pc :=: ci.item_concept))>= 1)))= 0 ;
END_RULE; -- product_concept_requires_configuration_item

RULE product_definition_formation_requires_approval FOR (product_definition, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition |(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN  TYPEOF(pd)))AND(NOT(SIZEOF(QUERY(aaa <* applied_approval_assignment | pd.formation IN aaa.items))= 1))))= 0 ;
END_RULE; -- product_definition_formation_requires_approval

RULE product_definition_formation_requires_person_organization FOR (product_definition, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition |(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN  TYPEOF(pd)))AND(NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment |(pd.formation IN  apaoa.items)AND(apaoa.role \ person_and_organization_role.name = 'creator')))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment |(pd.formation IN aoa.items)AND(aoa.role \ organization_role.name = 'creator')))= 1)))))= 0 ;
END_RULE; -- product_definition_formation_requires_person_organization

RULE product_requires_person_organization FOR (product, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(prod <* product | NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | prod IN  apaoa.items))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | prod IN aoa.items))= 1))))= 0 ;
END_RULE; -- product_requires_person_organization

RULE product_requires_product_definition_formation FOR (product, product_definition_formation);
 
WHERE
	WR1 :  SIZEOF(QUERY(prod <* product | NOT(SIZEOF(QUERY(pdf <* product_definition_formation | prod :=: pdf.of_product))>= 1)))= 0 ;
END_RULE; -- product_requires_product_definition_formation

RULE restrict_action_request_status FOR (action_request_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ars <* action_request_status | NOT(ars \ action_request_status.status IN [ 'proposed', 'in work', 'issued', 'hold' ])))= 0 ;
END_RULE; -- restrict_action_request_status

RULE restrict_approval_status FOR (approval_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ast <* approval_status | NOT(ast \ approval_status.name IN [ 'approved', 'not yet approved', 'disapproved', 'withdrawn' ])))= 0 ;
END_RULE; -- restrict_approval_status

RULE restrict_date_role FOR (date_role);
 
WHERE
	WR1 :  SIZEOF(QUERY(dr <* date_role | NOT(dr \ date_role.name IN [ 'creation date', 'request date', 'release date', 'start date', 'contract date', 'certification date', 'sign off date', 'classification date', 'declassification date' ])))= 0 ;
END_RULE; -- restrict_date_role

RULE security_classification_constraint FOR (security_classification, applied_date_and_time_assignment, applied_date_assignment, applied_person_and_organization_assignment, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(sc <* security_classification | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment |(sc IN  adata.items)AND('classification date' = adata.role \ date_time_role.name)))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment |(sc IN ada.items)AND('classification date' = ada.role \ date_role.name)))= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(sc <* security_classification | SIZEOF(QUERY(apa <* applied_person_and_organization_assignment |(sc IN apa.items)AND(apa.role \ person_and_organization_role.name = 'classification officer')))= 0))= 0 ;
	WR3 :  SIZEOF(QUERY(sc <* security_classification | SIZEOF(QUERY(aaa <* applied_approval_assignment |(sc IN aaa.items)))= 0))= 0 ;
END_RULE; -- security_classification_constraint

RULE subtype_exclusive_action_request_assignment FOR (action_request_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(ara <* action_request_assignment | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHANGE_REQUEST', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'START_REQUEST' ] * TYPEOF(ara))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_action_request_assignment

RULE subtype_exclusive_product_definition_relationship FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_USAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SUPPLIED_PART_RELATIONSHIP' ] * TYPEOF(pdr))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_product_definition_relationship

RULE subtype_exclusive_property_definition_representation FOR (property_definition_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_representation | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_DEFINITION_REPRESENTATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MATERIAL_PROPERTY_REPRESENTATION' ] * TYPEOF(pdr))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_property_definition_representation

RULE subtype_mandatory_address FOR (address);
 
WHERE
	WR1 :  SIZEOF(QUERY(add <* address | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PERSONAL_ADDRESS', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ORGANIZATIONAL_ADDRESS' ] * TYPEOF(add))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_address

RULE subtype_mandatory_date FOR (date);
 
WHERE
	WR1 :  SIZEOF(QUERY(d <* date | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CALENDAR_DATE' IN TYPEOF(d))))= 0 ;
END_RULE; -- subtype_mandatory_date

RULE subtype_mandatory_product_definition_usage FOR (product_definition_usage);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdu <* product_definition_usage | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_COMPONENT_USAGE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAKE_FROM_USAGE_OPTION' ] * TYPEOF(pdu))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_product_definition_usage

RULE supplied_product_version_unique_constraint FOR (product_definition_formation_with_specified_source);
 LOCAL
 spv : BAG  OF  product_definition_formation_with_specified_source := QUERY(r <* product_definition_formation_with_specified_source |(SIZEOF(QUERY(pd <* USEDIN(r, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION.FORMATION')|(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'SUPPLIED_PART_RELATIONSHIP')IN  TYPEOF(pdr))))> 0)))> 0));
 aoa_bag : BAG  OF  applied_organization_assignment;
 o_bag : BAG  OF  organization := [ ];
 pdf_bag : BAG  OF  product_definition_formation_with_specified_source;
 spn_bag : BAG OF STRING;
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(spv)BY  1;
 aoa_bag := QUERY(aoa <* USEDIN(spv [ i ], 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|(aoa.role \ organization_role.name = 'supplier'));
 REPEAT  j := 1 TO  SIZEOF(aoa_bag)BY  1;
 IF  EXISTS(aoa_bag [ j ].assigned_organization)THEN  IF(NOT(aoa_bag [ j ].assigned_organization IN  o_bag))THEN  o_bag := o_bag + aoa_bag [ j ].assigned_organization;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(o_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdf_bag := QUERY(pdf <* spv |(SIZEOF(QUERY(aoa <* USEDIN(pdf, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS')|((aoa.role \ organization_role.name = 'supplier')AND(aoa.assigned_organization :=: o_bag [ i ]))))> 0));
 spn_bag := [ ];
 REPEAT j := 1 TO SIZEOF(pdf_bag)BY 1;
 IF  EXISTS(pdf_bag [ j ].of_product.id)THEN  IF(pdf_bag [ j ].of_product.id IN spn_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE spn_bag := spn_bag + pdf_bag [ j ].of_product.id;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- supplied_product_version_unique_constraint

RULE versioned_action_request_requires_approval FOR (versioned_action_request, applied_approval_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(varq <* versioned_action_request | NOT(SIZEOF(QUERY(aaa <* applied_approval_assignment | varq IN aaa.items))= 1)))= 0 ;
END_RULE; -- versioned_action_request_requires_approval

RULE versioned_action_request_requires_date_or_date_and_time FOR (versioned_action_request, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(varq <* versioned_action_request | NOT((SIZEOF(QUERY(adata <* applied_date_and_time_assignment | varq IN  adata.items))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment | varq IN ada.items))= 1))))= 0 ;
END_RULE; -- versioned_action_request_requires_date_or_date_and_time

RULE versioned_action_request_requires_person_organization FOR (versioned_action_request, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(varq <* versioned_action_request | NOT((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | varq IN  apaoa.items))>= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | varq IN aoa.items))>= 1))))= 0 ;
END_RULE; -- versioned_action_request_requires_person_organization

RULE versioned_action_request_requires_status FOR (versioned_action_request, action_request_status);
 
WHERE
	WR1 :  SIZEOF(QUERY(ar <* versioned_action_request | NOT(SIZEOF(QUERY(ars <* action_request_status | ar :=: ars.assigned_request))= 1)))= 0 ;
END_RULE; -- versioned_action_request_requires_status

RULE work_request_unique_constraint FOR (versioned_action_request);
 LOCAL
 r : BAG  OF  versioned_action_request := QUERY(r <* versioned_action_request |(SIZEOF(QUERY(ara <* USEDIN(r, 'AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST')|((('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'CHANGE_REQUEST')IN  TYPEOF(ara))OR(('AP210_PRODUCT_DATA_MANAGEMENT_MIM.' + 'START_REQUEST')IN  TYPEOF(ara)))))> 0));
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ].id)THEN  IF(r [ i ].id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + r [ i ].id;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- work_request_unique_constraint

RULE component_placement_restriction_assignment_constraint FOR (representation);
 LOCAL
 cpra : SET OF representation := QUERY(cpra <* representation | cpra.name = 'component placement restriction assignment');
 i : INTEGER;
 pass1 : BOOLEAN  := TRUE ;
 pass2 : BOOLEAN  := TRUE;
 mra : BOOLEAN  := FALSE ;
 mrv : BOOLEAN := FALSE ;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(cpra);
 IF  NOT(pass1)THEN  ESCAPE ;
 END_IF ;
 IF  NOT((SIZEOF(QUERY(rr <* USEDIN(cpra [ i ], 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr.name = 'component placement restriction assignment area')AND(SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2, 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'MOUNTING_RESTRICTION_AREA' IN  TYPEOF(pdr.definition.definition))))= 1)))<= 1)OR(SIZEOF(QUERY(rr <* USEDIN(cpra [ i ], 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr.name = 'component placement restriction assignment volume')AND(SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2, 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'MOUNTING_RESTRICTION_VOLUME' IN  TYPEOF(pdr.definition.definition))))= 1)))<= 1))THEN  pass1 := FALSE ;
 END_IF ;
 mra :=(SIZEOF(QUERY(rr <* USEDIN(cpra [ i ], 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr.name = 'component placement restriction assignment area')AND(SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2, 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'MOUNTING_RESTRICTION_AREA' IN  TYPEOF(pdr.definition.definition))))= 1)))= 1);
 mrv :=(SIZEOF(QUERY(rr <* USEDIN(cpra [ i ], 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr.name = 'component placement restriction assignment volume')AND(SIZEOF(QUERY(pdr <* USEDIN(rr.rep_2, 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'MOUNTING_RESTRICTION_VOLUME' IN  TYPEOF(pdr.definition.definition))))= 1)))= 1);
 IF  NOT(mra OR mrv)THEN  pass1 := FALSE ;
 END_IF ;
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(cpra);
 IF  NOT(pass1)THEN  ESCAPE ;
 END_IF ;
 IF  NOT(pass2)THEN  ESCAPE;
 END_IF ;
 IF NOT(SIZEOF(QUERY(pdr <* USEDIN(cpra [ i ], 'ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('ASSEMBLY_COMPONENT_PLACEMENT_REQUIREMENTS_MIM.' + 'GROUPED_REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.definition))AND(pdr.definition \ group.name = 'item restricted requirements property')))= 1)THEN pass2 := FALSE;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- component_placement_restriction_assignment_constraint

RULE placement_group_area_assignment_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'area impacted group')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MOUNTING_RESTRICTION_AREA' IN TYPEOF(sar.related_shape_aspect))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'area impacted group')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_SHAPE_ASPECT' IN  TYPEOF(sar.relating_shape_aspect))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(sar.relating_shape_aspect))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_PRODUCT_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))AND(sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name = 'design requirement')))))= 0 ;
END_RULE; -- placement_group_area_assignment_constraint

RULE placement_group_volume_assignment_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'volume impacted group')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MOUNTING_RESTRICTION_VOLUME' IN TYPEOF(sar.related_shape_aspect))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'volume impacted group')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_SHAPE_ASPECT' IN  TYPEOF(sar.relating_shape_aspect))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(sar.relating_shape_aspect))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_PRODUCT_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_CONTEXT' IN TYPEOF(sar.relating_shape_aspect.of_shape.definition.frame_of_reference))AND(sar.relating_shape_aspect.of_shape.definition.frame_of_reference.name = 'design requirement')))))= 0 ;
END_RULE; -- placement_group_volume_assignment_constraint

RULE mating_connector_termination_constraint FOR (shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(sa <* shape_aspect |(sa \ shape_aspect.description = 'mating connector termination')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(sa.of_shape.definition))AND(sa.of_shape.definition \ product_definition.description = 'mating connector'))))= 0 ;
END_RULE; -- mating_connector_termination_constraint

RULE mating_connector_termination_unique_constraint FOR (shape_aspect);
 LOCAL
 mct : BAG  OF  shape_aspect := QUERY(sa <* shape_aspect |(sa \ shape_aspect.description = 'mating connector termination'));
 cd_bag : BAG  OF  component_definition := [ ];
 sa_bag : BAG  OF  shape_aspect;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 ppt_bag : BAG OF packaged_part_terminal;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(mct)BY  1;
 IF  EXISTS(mct [ i ].of_shape.definition)THEN  IF(('ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(mct [ i ].of_shape.definition))AND(mct [ i ].of_shape.definition \ product_definition.description = 'mating connector'))THEN  IF(NOT(mct [ i ].of_shape.definition IN  cd_bag))THEN  cd_bag := cd_bag + mct [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ppt_bag := [ ];
 sa_bag := QUERY(sa <* mct |(sa.of_shape.definition :=: cd_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(sa_bag [ j ], 'ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'instantiated terminal')AND('ASSEMBLY_FUNCTIONAL_INTERFACE_REQUIREMENT_MIM.' + 'PACKAGED_PART_TERMINAL' IN  TYPEOF(sar.relating_shape_aspect))));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ k ].relating_shape_aspect)THEN  IF(sar_bag [ k ].relating_shape_aspect IN ppt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE ppt_bag := ppt_bag + sar_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- mating_connector_termination_unique_constraint

RULE component_external_reference_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'design owner'))))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'part number'))))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'revision code'))))= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'product definition id'))))= 1)))= 0 ;
	WR5 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'component external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'reference designation'))))= 1)))= 0 ;
END_RULE; -- component_external_reference_constraint

RULE component_feature_external_reference_unique_constraint FOR (descriptive_representation_item);
 LOCAL
 cfer : BAG  OF  descriptive_representation_item := QUERY(dri <* descriptive_representation_item |(dri \ representation_item.name = 'component feature external reference'));
 desc_bag : BAG  OF  STRING := [ ];
 dri_bag : BAG  OF  descriptive_representation_item;
 rep_bag : BAG  OF  representation;
 pass : BOOLEAN := TRUE;
 r_bag : BAG OF representation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(cfer)BY  1;
 IF  EXISTS(cfer [ i ] \ descriptive_representation_item.description)THEN  IF(NOT(cfer [ i ] \ descriptive_representation_item.description IN  desc_bag))THEN  desc_bag := desc_bag + cfer [ i ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(desc_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 r_bag := [ ];
 dri_bag := QUERY(dri <* cfer |(dri \ descriptive_representation_item.description = desc_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(dri_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 rep_bag := QUERY(r <* USEDIN(dri_bag [ j ], 'ASSEMBLY_MODULE_DESIGN_MIM.' + 'REPRESENTATION.ITEMS')|(r \ representation.name = 'component external reference'));
 REPEAT k := 1 TO SIZEOF(rep_bag)BY 1;
 IF  EXISTS(rep_bag [ k ])THEN  IF(rep_bag [ k ] IN r_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE r_bag := r_bag + rep_bag [ k ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_feature_external_reference_unique_constraint

RULE component_mounting_clearance_relationship_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'mounting clearance')AND(SIZEOF(QUERY(lmwu <* rep.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'minimum height')))= 0)))= 0 ;
END_RULE; -- component_mounting_clearance_relationship_constraint

RULE component_overlap_relationship_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'overlap clearance')AND(SIZEOF(QUERY(lmwu <* rep.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'minimum clearance')))= 0)))= 0 ;
END_RULE; -- component_overlap_relationship_constraint

RULE component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 cttamta : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'component feature to  physical usage view assignment'));
 pass : BOOLEAN := TRUE;
 amt_bag : BAG OF assembly_module_join_terminal := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(cttamta)BY 1;
 IF  EXISTS(cttamta [ i ].relating_shape_aspect)THEN  IF('ASSEMBLY_MODULE_MACRO_DEFINITION_MIM.' + 'ASSEMBLY_MODULE_JOIN_TERMINAL' IN  TYPEOF(cttamta [ i ].relating_shape_aspect))THEN  IF(cttamta [ i ].relating_shape_aspect IN amt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE amt_bag := amt_bag + cttamta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_terminal_to_assembly_module_join_terminal_assignment_unique_constraint

RULE interconnect_component_interface_terminal_unique_constraint FOR (component_interface_terminal);
 LOCAL
 icit : BAG  OF  component_interface_terminal := QUERY(cit <* component_interface_terminal |(cit \ shape_aspect.description = 'interconnect component interface terminal'));
 icd_bag : BAG  OF  interface_component_definition := [ ];
 cit_bag : BAG  OF  component_interface_terminal;
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(icit)BY  1;
 IF  EXISTS(icit [ i ].of_shape.definition)THEN  IF('ASSEMBLY_MODULE_WITH_INTERCONNECT_COMPONENT_MIM.' + 'INTERFACE_COMPONENT_DEFINITION' IN  TYPEOF(icit [ i ].of_shape.definition))THEN  IF(NOT(icit [ i ].of_shape.definition IN  icd_bag))THEN  icd_bag := icd_bag + icit [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(icd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 name_bag := [ ];
 cit_bag := QUERY(cit <* icit |(cit.of_shape.definition :=: icd_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(cit_bag)BY 1;
 IF  EXISTS(cit_bag [ j ] \ shape_aspect.name)THEN  IF(cit_bag [ j ] \ shape_aspect.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + cit_bag [ j ] \ shape_aspect.name;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- interconnect_component_interface_terminal_unique_constraint

RULE interconnect_component_join_terminal_unique_constraint FOR (component_terminal);
 LOCAL
 icjt : BAG  OF  component_terminal := QUERY(ct <* component_terminal |(ct \ shape_aspect.description = 'interconnect component join terminal'));
 cd_bag : BAG  OF  component_definition := [ ];
 ct_bag : BAG  OF  component_terminal;
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(icjt)BY  1;
 IF  EXISTS(icjt [ i ].of_shape.definition)THEN  IF('ASSEMBLY_MODULE_WITH_INTERCONNECT_COMPONENT_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(icjt [ i ].of_shape.definition))THEN  IF(NOT(icjt [ i ].of_shape.definition IN  cd_bag))THEN  cd_bag := cd_bag + icjt [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 name_bag := [ ];
 ct_bag := QUERY(ct <* icjt |(ct.of_shape.definition :=: cd_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(ct_bag)BY 1;
 IF  EXISTS(ct_bag [ j ] \ shape_aspect.name)THEN  IF(ct_bag [ j ] \ shape_aspect.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + ct_bag [ j ] \ shape_aspect.name;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- interconnect_component_join_terminal_unique_constraint

RULE mating_connector_placement_relationship_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'mating connector placement')AND(SIZEOF(QUERY(p <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLACEMENT' IN TYPEOF(p))AND(p \ representation_item.name = 'connector placement')))= 0)))= 0 ;
END_RULE; -- mating_connector_placement_relationship_constraint

RULE next_higher_assembly_interface_requirement_constraint FOR (specified_higher_usage_occurrence);
 
WHERE
	WR1 :  SIZEOF(QUERY(shuo <* specified_higher_usage_occurrence | NOT(SIZEOF(QUERY(pd <* USEDIN(shuo, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = '3d bound volume shape')))= 0)))= 0)))= 0 ;
END_RULE; -- next_higher_assembly_interface_requirement_constraint

RULE interface_component_allocation_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'interface component allocation')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition \ product_definition.description = 'mating connector'))))= 0 ;
END_RULE; -- interface_component_allocation_constraint

RULE default_assembly_bond_shape_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'default assembly bond shape')AND NOT(SIZEOF(QUERY(pdr <* USEDIN(sr, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(pdr.definition.definition))))= 1)))= 0 ;
END_RULE; -- default_assembly_bond_shape_constraint

RULE bare_die_unique_constraint FOR (bare_die);
 LOCAL
 bd : BAG  OF  physical_unit := QUERY(r <* bare_die |(r.frame_of_reference.name = 'physical design usage'));
 pu : BAG  OF  physical_unit;
 pdr_bag : BAG  OF  product_definition_relationship;
 fu_bag : BAG  OF  functional_unit := [ ];
 pu_bag : BAG  OF  physical_unit;
 ut_bag : BAG  OF  property_definition;
 pass : BOOLEAN := TRUE;
 pd_bag : BAG OF property_definition;
 END_LOCAL
;
 pu := bd;
 REPEAT  i := 1 TO  SIZEOF(pu)BY  1;
 pdr_bag := QUERY(pdr <* USEDIN(pu [ i ], 'BARE_DIE_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional design usage')AND('BARE_DIE_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(pdr.relating_product_definition))));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF  EXISTS(pdr_bag [ j ].relating_product_definition)THEN  IF(NOT(pdr_bag [ j ].relating_product_definition IN  fu_bag))THEN  fu_bag := fu_bag + pdr_bag [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fu_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pu_bag := QUERY(r <* pu |(SIZEOF(QUERY(pdr <* USEDIN(fu_bag [ i ], 'BARE_DIE_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'implemented function')AND(pdr.related_product_definition :=: r))))> 0));
 pd_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 ut_bag := QUERY(pd <* USEDIN(pu_bag [ j ], 'BARE_DIE_MIM.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.name = 'unit technology'));
 REPEAT k := 1 TO SIZEOF(ut_bag)BY 1;
 IF  EXISTS(ut_bag [ k ])THEN  IF(ut_bag [ k ] IN pd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pd_bag := pd_bag + ut_bag [ k ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- bare_die_unique_constraint

RULE restrict_classification_assignments FOR (applied_classification_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(aia <* applied_classification_assignment | NOT class_assignment_is_valid(aia)))= 0 ;
END_RULE; -- restrict_classification_assignments

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(gr <* group_relationship |(gr.name = 'class hierarchy')AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CLASS' IN  TYPEOF(gr.related_group))OR NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CLASS' IN TYPEOF(gr.relating_group)))))= 0 ;
END_RULE; -- restrict_group_relationship_for_classification_hierarchy

RULE component_feature_unique_constraint FOR (component_terminal, component_interface_terminal);
 LOCAL
 ct : BAG  OF  shape_aspect := QUERY(ct <* component_terminal |(ct \ shape_aspect.description IN  [ 'assembly module component terminal', 'bare die component terminal', 'interconnect component join terminal', 'interconnect module component terminal', 'interconnect module component stratum based terminal', 'minimally defined component terminal', 'packaged component join terminal' ]));
 cit : BAG  OF  shape_aspect := QUERY(cit <* component_interface_terminal |(cit \ shape_aspect.description IN  [ 'interconnect component interface terminal', 'packaged connector component interface terminal' ]));
 cf : BAG  OF  shape_aspect;
 cd_bag : BAG  OF  component_definition := [ ];
 sa_bag : BAG  OF  shape_aspect;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 def_bag : BAG OF shape_aspect;
 END_LOCAL
;
 cf := ct + cit;
 REPEAT  i := 1 TO  SIZEOF(cf)BY  1;
 IF  EXISTS(cf [ i ].of_shape.definition)THEN  IF('COMPONENT_FEATURE_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(cf [ i ].of_shape.definition))THEN  IF(NOT(cf [ i ].of_shape.definition IN  cd_bag))THEN  cd_bag := cd_bag + cf [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 def_bag := [ ];
 sa_bag := QUERY(sa <* cf |(sa.of_shape.definition :=: cd_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(sa_bag [ j ], 'COMPONENT_FEATURE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'instantiated feature'));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ k ].relating_shape_aspect)THEN  IF(sar_bag [ k ].relating_shape_aspect IN def_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE def_bag := def_bag + sar_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_feature_unique_constraint

RULE add_design_object_management_relationship_unique_constraint FOR (add_design_object_assignment, add_design_object_request_assignment);
 LOCAL
 pdr_bag : BAG  OF  product_definition_relationship := [ ];
 pd_bag : BAG  OF  product_definition := [ ];
 adoa_bag : BAG  OF  add_design_object_assignment;
 adora_bag : BAG  OF  add_design_object_request_assignment;
 pass : BOOLEAN := TRUE;
 mdo_bag : BAG OF managed_design_object;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(add_design_object_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(add_design_object_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(add_design_object_assignment [ i ].items [ j ]))AND(add_design_object_assignment [ i ].items [ j ].name = 'design object addition'))THEN  IF  EXISTS(add_design_object_assignment [ i ].items [ j ].related_product_definition)THEN  IF(NOT(add_design_object_assignment [ i ].items [ j ].related_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + add_design_object_assignment [ i ].items [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(add_design_object_request_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(add_design_object_request_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(add_design_object_request_assignment [ i ].items [ j ]))AND(add_design_object_request_assignment [ i ].items [ j ].name = 'design object addition'))THEN  IF  EXISTS(add_design_object_request_assignment [ i ].items [ j ].related_product_definition)THEN  IF(NOT(add_design_object_request_assignment [ i ].items [ j ].related_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + add_design_object_request_assignment [ i ].items [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object addition'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 adoa_bag := QUERY(adoa <* add_design_object_assignment |(pdr_bag [ j ] IN  adoa.items));
 REPEAT  k := 1 TO  SIZEOF(adoa_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(adoa_bag [ k ].items)BY  1;
 IF  EXISTS(adoa_bag [ k ].items [ l ])THEN  IF(adoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + adoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 adora_bag := QUERY(adora <* add_design_object_request_assignment |(pdr_bag [ j ] IN  adora.items));
 REPEAT  k := 1 TO  SIZEOF(adora_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(adora_bag [ k ].items)BY 1;
 IF(adora_bag [ k ].items [ l ] IN mdo_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE mdo_bag := mdo_bag + adora_bag [ k ].items [ l ];
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- add_design_object_management_relationship_unique_constraint

RULE change_design_object_management_relationship_unique_constraint FOR (change_from_design_object_assignment, change_from_design_object_request_assignment, change_to_design_object_assignment, change_to_design_object_request_assignment);
 LOCAL
 pd_bag : BAG  OF  product_definition := [ ];
 pdr_bag : BAG  OF  product_definition_relationship;
 ctdoa_bag : BAG  OF  change_to_design_object_assignment;
 ctdora_bag : BAG  OF  change_to_design_object_request_assignment;
 cfdoa_bag : BAG  OF  change_from_design_object_assignment;
 cfdora_bag : BAG  OF  change_from_design_object_request_assignment;
 pass1 : BOOLEAN  := TRUE ;
 pass2 : BOOLEAN := TRUE;
 mdo_bag : BAG OF managed_design_object;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(change_from_design_object_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(change_from_design_object_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(change_from_design_object_assignment [ i ].items [ j ]))AND(change_from_design_object_assignment [ i ].items [ j ].name = 'design object change'))THEN  IF  EXISTS(change_from_design_object_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(change_from_design_object_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + change_from_design_object_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(change_from_design_object_request_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(change_from_design_object_request_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(change_from_design_object_request_assignment [ i ].items [ j ]))AND(change_from_design_object_request_assignment [ i ].items [ j ].name = 'design object change'))THEN  IF  EXISTS(change_from_design_object_request_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(change_from_design_object_request_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + change_from_design_object_request_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT(pass1 AND pass2))THEN  ESCAPE ;
 END_IF ;
 IF(pass1)THEN  mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object change'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 ctdoa_bag := QUERY(ctdoa <* change_to_design_object_assignment |(pdr_bag [ j ] IN  ctdoa.items));
 REPEAT  k := 1 TO  SIZEOF(ctdoa_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(ctdoa_bag [ k ].items)BY  1;
 IF  EXISTS(ctdoa_bag [ k ].items [ l ])THEN  IF(ctdoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + ctdoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 ctdora_bag := QUERY(ctdora <* change_to_design_object_request_assignment |(pdr_bag [ j ] IN  ctdora.items));
 REPEAT  k := 1 TO  SIZEOF(ctdora_bag)BY  1;
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(ctdora_bag [ k ].items)BY  1;
 IF  EXISTS(ctdora_bag [ k ].items [ l ])THEN  IF(ctdora_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + ctdora_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_IF ;
 IF(pass2)THEN  mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object change'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass2)THEN  ESCAPE ;
 END_IF ;
 cfdoa_bag := QUERY(cfdoa <* change_from_design_object_assignment |(pdr_bag [ j ] IN  cfdoa.items));
 REPEAT  k := 1 TO  SIZEOF(cfdoa_bag)BY  1;
 IF(NOT  pass2)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(cfdoa_bag [ k ].items)BY  1;
 IF  EXISTS(cfdoa_bag [ k ].items [ l ])THEN  IF(cfdoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass2 := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + cfdoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass2)THEN  ESCAPE ;
 END_IF ;
 cfdora_bag := QUERY(cfdora <* change_from_design_object_request_assignment |(pdr_bag [ j ] IN  cfdora.items));
 REPEAT  k := 1 TO  SIZEOF(cfdora_bag)BY  1;
 IF(NOT pass2)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(cfdora_bag [ k ].items)BY 1;
 IF  EXISTS(cfdora_bag [ k ].items [ l ])THEN  IF(cfdora_bag [ k ].items [ l ] IN mdo_bag)THEN pass2 := FALSE;
 ESCAPE;
 ELSE mdo_bag := mdo_bag + cfdora_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- change_design_object_management_relationship_unique_constraint

RULE delete_design_object_management_relationship_unique_constraint FOR (delete_design_object_assignment, delete_design_object_request_assignment);
 LOCAL
 pdr_bag : BAG  OF  product_definition_relationship := [ ];
 pd_bag : BAG  OF  product_definition := [ ];
 ddoa_bag : BAG  OF  delete_design_object_assignment;
 ddora_bag : BAG  OF  delete_design_object_request_assignment;
 pass : BOOLEAN := TRUE;
 mdo_bag : BAG OF managed_design_object;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(delete_design_object_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(delete_design_object_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(delete_design_object_assignment [ i ].items [ j ]))AND(delete_design_object_assignment [ i ].items [ j ].name = 'design object deletion'))THEN  IF  EXISTS(delete_design_object_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(delete_design_object_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + delete_design_object_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(delete_design_object_request_assignment)BY  1;
 REPEAT  j := 1 TO  SIZEOF(delete_design_object_request_assignment [ i ].items)BY  1;
 IF(('DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(delete_design_object_request_assignment [ i ].items [ j ]))AND(delete_design_object_request_assignment [ i ].items [ j ].name = 'design object deletion'))THEN  IF  EXISTS(delete_design_object_request_assignment [ i ].items [ j ].relating_product_definition)THEN  IF(NOT(delete_design_object_request_assignment [ i ].items [ j ].relating_product_definition IN  pd_bag))THEN  pd_bag := pd_bag + delete_design_object_request_assignment [ i ].items [ j ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 mdo_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ i ], 'DESIGN_MANAGEMENT_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION')|(pdr \ product_definition_relationship.name = 'design object deletion'));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ddoa_bag := QUERY(ddoa <* delete_design_object_assignment |(pdr_bag [ j ] IN  ddoa.items));
 REPEAT  k := 1 TO  SIZEOF(ddoa_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(ddoa_bag [ k ].items)BY  1;
 IF  EXISTS(ddoa_bag [ k ].items [ l ])THEN  IF(ddoa_bag [ k ].items [ l ] IN  mdo_bag)THEN  pass := FALSE ;
 ESCAPE ;
 ELSE  mdo_bag := mdo_bag + ddoa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ddora_bag := QUERY(ddora <* delete_design_object_request_assignment |(pdr_bag [ j ] IN  ddora.items));
 REPEAT  k := 1 TO  SIZEOF(ddora_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(ddora_bag [ k ].items)BY 1;
 IF  EXISTS(ddora_bag [ k ].items [ l ])THEN  IF(ddora_bag [ k ].items [ l ] IN mdo_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE mdo_bag := mdo_bag + ddora_bag [ k ].items [ l ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- delete_design_object_management_relationship_unique_constraint

RULE component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 cttamta : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'component feature to  physical usage view assignment'));
 pass : BOOLEAN := TRUE;
 amt_bag : BAG OF assembly_module_interface_terminal := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(cttamta)BY 1;
 IF  EXISTS(cttamta [ i ].relating_shape_aspect)THEN  IF('DESIGN_SPECIFIC_ASSIGNMENT_TO_ASSEMBLY_USAGE_VIEW_MIM.' + 'ASSEMBLY_MODULE_INTERFACE_TERMINAL' IN  TYPEOF(cttamta [ i ].relating_shape_aspect))THEN  IF(cttamta [ i ].relating_shape_aspect IN amt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE amt_bag := amt_bag + cttamta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_terminal_to_assembly_module_interface_terminal_assignment_unique_constraint

RULE component_terminal_to_pca_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 cttamta : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'component feature to  physical usage view assignment'));
 pass : BOOLEAN := TRUE;
 amt_bag : BAG OF assembly_module_terminal := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(cttamta)BY 1;
 IF  EXISTS(cttamta [ i ].relating_shape_aspect)THEN  IF(('DESIGN_SPECIFIC_ASSIGNMENT_TO_ASSEMBLY_USAGE_VIEW_MIM.' + 'SHAPE_ASPECT' IN  TYPEOF(cttamta [ i ].relating_shape_aspect))AND(cttamta [ i ].relating_shape_aspect \ shape_aspect.description = 'pca terminal'))THEN  IF(cttamta [ i ].relating_shape_aspect IN amt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE amt_bag := amt_bag + cttamta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_terminal_to_pca_terminal_assignment_unique_constraint

RULE component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 cttimta : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'component feature to  physical usage view assignment'));
 pass : BOOLEAN := TRUE;
 imt_bag : BAG OF interconnect_module_interface_terminal := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(cttimta)BY 1;
 IF  EXISTS(cttimta [ i ].relating_shape_aspect)THEN  IF('DESIGN_SPECIFIC_ASSIGNMENT_TO_INTERCONNECT_USAGE_VIEW_MIM.' + 'INTERCONNECT_MODULE_INTERFACE_TERMINAL' IN  TYPEOF(cttimta [ i ].relating_shape_aspect))THEN  IF(cttimta [ i ].relating_shape_aspect IN imt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE imt_bag := imt_bag + cttimta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_terminal_to_interconnect_module_interface_terminal_assignment_unique_constraint

RULE component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 cttimta : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'component feature to  physical usage view assignment'));
 pass : BOOLEAN := TRUE;
 imt_bag : BAG OF interconnect_module_join_terminal := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(cttimta)BY 1;
 IF  EXISTS(cttimta [ i ].relating_shape_aspect)THEN  IF('DESIGN_SPECIFIC_ASSIGNMENT_TO_INTERCONNECT_USAGE_VIEW_MIM.' + 'INTERCONNECT_MODULE_JOIN_TERMINAL' IN  TYPEOF(cttimta [ i ].relating_shape_aspect))THEN  IF(cttimta [ i ].relating_shape_aspect IN imt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE imt_bag := imt_bag + cttimta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_terminal_to_interconnect_module_join_terminal_assignment_unique_constraint

RULE marking_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |((rep \ representation.name = 'marking')AND(SIZEOF(QUERY(pdr <* USEDIN(rep, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN  TYPEOF(pdr.definition))))> 0))AND  NOT(SIZEOF(QUERY(place <* rep.items |(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLACEMENT' IN TYPEOF(place))AND(place \ representation_item.name = 'marking location'))))= 1)))= 0 ;
END_RULE; -- marking_constraint

RULE boundary_size_characteristic_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |((rep \ representation.name = 'diametrical boundary size')OR(rep \ representation.name = 'opposing boundary set size'))AND(NOT(SIZEOF(QUERY(lmwu <* rep.items |(lmwu \ representation_item.name = 'tolerance value')))= 1))))= 0 ;
END_RULE; -- boundary_size_characteristic_constraint

RULE directed_axis_constraint FOR (derived_shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(dsa <* derived_shape_aspect |(dsa \ shape_aspect.description = 'directed axis')AND  NOT(SIZEOF(QUERY(sar <* USEDIN(dsa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'derived axis')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CENTRE_OF_SYMMETRY' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))AND(sar \ shape_aspect_relationship.related_shape_aspect \ shape_aspect.description = 'axis')))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(dsa <* derived_shape_aspect |(dsa \ shape_aspect.description = 'directed axis')AND  NOT(SIZEOF(QUERY(sar <* USEDIN(dsa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'end shape aspect')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(dsa <* derived_shape_aspect |(dsa \ shape_aspect.description = 'directed axis')AND  NOT(SIZEOF(QUERY(sar <* USEDIN(dsa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'start shape aspect')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT' IN TYPEOF(sar \ shape_aspect_relationship.related_shape_aspect))))= 1)))= 0 ;
END_RULE; -- directed_axis_constraint

RULE directed_axis_unique_constraint FOR (derived_shape_aspect);
 LOCAL
 da : BAG  OF  derived_shape_aspect := QUERY(r <* derived_shape_aspect |(r \ shape_aspect.description = 'directed axis'));
 sar_bag : BAG  OF  shape_aspect_relationship;
 cos_bag : BAG  OF  centre_of_symmetry := [ ];
 sar2_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 sa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(da)BY  1;
 sar_bag := QUERY(sar <* USEDIN(da [ i ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'derived axis')AND(sar.related_shape_aspect \ shape_aspect.description = 'axis')AND('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'CENTRE_OF_SYMMETRY' IN  TYPEOF(sar.related_shape_aspect))));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(NOT(sar_bag [ j ].related_shape_aspect IN  cos_bag))THEN  cos_bag := cos_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cos_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 sa_bag := [ ];
 sar_bag := QUERY(sar <* USEDIN(cos_bag [ i ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'derived axis')AND(sar.relating_shape_aspect IN  da)));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar2_bag := QUERY(sar <* USEDIN(sar_bag [ j ].relating_shape_aspect, 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'start shape aspect'));
 REPEAT k := 1 TO SIZEOF(sar2_bag)BY 1;
 IF  EXISTS(sar2_bag [ k ].related_shape_aspect)THEN  IF(sar2_bag [ k ].related_shape_aspect IN sa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sa_bag := sa_bag + sar2_bag [ k ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- directed_axis_unique_constraint

RULE direction_element_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'direction element')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'element direction vector')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.description = 'datum direction_property')))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'direction element')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'half datum plane direction vector')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.description = 'datum direction_property')))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'direction element')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'direction component')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION' IN TYPEOF(pdr.related_property_definition))AND(pdr.related_property_definition \ property_definition.description = 'datum based vector orientation')))= 1)))= 0 ;
END_RULE; -- direction_element_constraint

RULE edge_segment_vertex_constraint FOR (shape_aspect_relationship, edge_segment_vertex);
 LOCAL
 sar : BAG  OF  shape_aspect_relationship := [ ];
 esv : BAG OF edge_segment_vertex := edge_segment_vertex;
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(esv)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 sar := QUERY(sar <* shape_aspect_relationship | esv [ i ] = sar \ shape_aspect_relationship.related_shape_aspect);
 pass :=(SIZEOF(sar)= 2);
 REPEAT j := 2 TO SIZEOF(sar)BY 1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pass :=((sar [ j ]):<>:(sar [ j - 1 ]));
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pass :=(TYPEOF(sar [ j ])= TYPEOF(sar [ j - 1 ]));
 IF(NOT pass)THEN ESCAPE;
 END_IF;
 pass :=(sar [ j ].relating_shape_aspect :=: sar [ j - 1 ].relating_shape_aspect);
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- edge_segment_vertex_constraint

RULE edge_segment_vertex_unique_constraint FOR (edge_segment_vertex);
 LOCAL
 esv : BAG  OF  edge_segment_vertex := QUERY(r <* edge_segment_vertex |(r \ shape_aspect.name = 'single datum'));
 pd_bag : BAG  OF  property_definition;
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 desc_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(esv)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pd_bag := QUERY(pd <* USEDIN(esv [ i ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'PROPERTY_DEFINITION.DEFINITION')|(pd \ property_definition.description = 'shape element characterization'));
 REPEAT  j := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := USEDIN(pd_bag [ j ], 'EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION');
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF((pdr_bag [ k ].used_representation \ representation.name = 'shape element characterization')AND('EXTENDED_GEOMETRIC_TOLERANCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(pdr_bag [ k ].used_representation.items [ 1 ])))THEN  IF  EXISTS(pdr_bag [ k ].used_representation.items [ 1 ] \ descriptive_representation_item.description)THEN  IF(pdr_bag [ k ].used_representation.items [ 1 ] \ descriptive_representation_item.description IN desc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE desc_bag := desc_bag + pdr_bag [ k ].used_representation.items [ 1 ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- edge_segment_vertex_unique_constraint

RULE geometric_tolerance_qualifier_constraint FOR (measure_qualification);
 
WHERE
	WR1 :  SIZEOF(QUERY(mq <* measure_qualification |((mq \ measure_qualification.name = 'predefined geometric tolerance qualifier')OR(mq \ measure_qualification.name = 'user defined geometric tolerance qualifier'))AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_WITH_UNIT' IN  TYPEOF(mq.qualified_measure))AND(SIZEOF(QUERY(pugt <* USEDIN(mq.qualified_measure, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GEOMETRIC_TOLERANCE.MAGNITUDE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' IN TYPEOF(pugt))))= 0))))= 0 ;
END_RULE; -- geometric_tolerance_qualifier_constraint

RULE positional_boundary_member_definition_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary member property')AND NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY_MEMBER' IN TYPEOF(pd.definition)))))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary member property')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_SIZE_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'boundary member associated dimension')))= 1)))= 0 ;
END_RULE; -- positional_boundary_member_definition_constraint

RULE positional_boundary_offset_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary offset')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP' IN TYPEOF(pd.definition))AND(pd.definition \ shape_aspect_relationship.name = 'positional boundary and profile boundary member'))))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'positional boundary offset')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|(pdr \ property_definition_relationship.name = 'boundary offset')AND(pdr.relating_property_definition \ property_definition.name = 'profile related positional boundary property')))= 1)))= 0 ;
END_RULE; -- positional_boundary_offset_constraint

RULE profile_related_positional_boundary_definition_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'profile related positional boundary property')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITIONAL_BOUNDARY' IN TYPEOF(pd.definition))AND(pd.definition \ shape_aspect.description = 'profile related positional boundary'))))= 0 ;
	WR2 :  SIZEOF(QUERY(pd <* property_definition |(pd \ property_definition.description = 'profile related positional boundary property')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|(pdr.related_property_definition \ property_definition.description = 'positional boundary offset')AND(pdr \ property_definition_relationship.name = 'boundary offset')))= 1)))= 0 ;
END_RULE; -- profile_related_positional_boundary_definition_constraint

RULE projected_zone_and_base_relationship_constraint FOR (projected_zone_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pzd <* projected_zone_definition | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PART_TEMPLATE_DEFINITION' IN TYPEOF(pzd.projection_end))OR(pzd.projection_end.product_definitional = TRUE))))= 0 ;
END_RULE; -- projected_zone_and_base_relationship_constraint

RULE projected_zone_height_characteristic_constraint FOR (projected_zone_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pzd <* projected_zone_definition | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(pzd.projected_length))))= 0 ;
END_RULE; -- projected_zone_height_characteristic_constraint

RULE restraint_condition_constraint FOR (property_definition);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* property_definition |((pd \ property_definition.description = 'restraint')OR(pd \ property_definition.description = 'tolerance specific restraint'))AND(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATING_PROPERTY_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))AND(pdr \ property_definition_relationship.name = 'restraint description')))= 0)))= 0 ;
END_RULE; -- restraint_condition_constraint

RULE shape_element_deriving_relationship_unique_constraint FOR (shape_aspect_deriving_relationship);
 LOCAL
 sa_bag : BAG  OF  shape_aspect := [ ];
 sadr_bag : BAG  OF  shape_aspect_deriving_relationship;
 pass : BOOLEAN := TRUE;
 rsa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(shape_aspect_deriving_relationship)BY  1;
 IF  EXISTS(shape_aspect_deriving_relationship [ i ].relating_shape_aspect)THEN  IF(NOT(shape_aspect_deriving_relationship [ i ].relating_shape_aspect IN  sa_bag))THEN  sa_bag := sa_bag + shape_aspect_deriving_relationship [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sadr_bag := QUERY(r <* shape_aspect_deriving_relationship |(r.relating_shape_aspect :=: sa_bag [ i ]));
 rsa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sadr_bag)BY 1;
 IF  EXISTS(sadr_bag [ j ].related_shape_aspect)THEN  IF(sadr_bag [ j ].related_shape_aspect IN rsa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rsa_bag := rsa_bag + sadr_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- shape_element_deriving_relationship_unique_constraint

RULE subtype_exclusive_dimensional_location FOR (dimensional_location);
 
WHERE
	WR1 :  SIZEOF(QUERY(dl <* dimensional_location | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANGULAR_DIMENSION_WITH_ORIENTATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_LOCATION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DIMENSIONAL_LOCATION_WITH_PATH' ] * TYPEOF(dl))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_dimensional_location

RULE subtype_exclusive_dimensional_size FOR (dimensional_size);
 
WHERE
	WR1 :  SIZEOF(QUERY(ds <* dimensional_size | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CURVE_DIMENSION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANGULAR_SIZE' ] * TYPEOF(ds))<= 1)OR NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CURVE_DIMENSION', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'OPPOSING_BOUNDARY_DIMENSIONAL_SIZE' ] * TYPEOF(ds))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_dimensional_size

RULE subtype_mandatory_extended_geometric_tolerance FOR (geometric_tolerance);
 
WHERE
	WR1 :  SIZEOF(QUERY(gt <* geometric_tolerance | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT_GEOMETRIC_TOLERANCE' ] * TYPEOF(gt))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_extended_geometric_tolerance

RULE subtype_mandatory_runout_zone_orientation FOR (runout_zone_orientation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rzo <* runout_zone_orientation | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RUNOUT_ZONE_ORIENTATION_REFERENCE_DIRECTION' ] * TYPEOF(rzo))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_runout_zone_orientation

RULE subtype_exclusiveness_representation_item FOR (representation_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(cri <* representation_item | NOT(type_check_function(cri, [ 'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM', 'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM', 'REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM' ], 3))))= 0 ;
END_RULE; -- subtype_exclusiveness_representation_item

RULE connection_zone_constraint FOR (shape_aspect, representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sa <* shape_aspect |(sa \ shape_aspect.description = 'connection zone')AND NOT(SIZEOF(USEDIN(sa, ''))>= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(sa <* shape_aspect |(sa \ shape_aspect.description = 'connection zone')AND NOT(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name IN [ 'connection', 'minimum attachment region size', 'maximum attachment region size', 'external connection area', 'external connection zone', 'internal connection zone', 'mounting area', 'terminal connection zone' ])))>= 1)))= 0 ;
END_RULE; -- connection_zone_constraint

RULE fill_area_occurrence_constraint FOR (annotation_fill_area_occurrence);
 
WHERE
	WR1 :  SIZEOF(QUERY(afao <* annotation_fill_area_occurrence | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ANNOTATION_FILL_AREA' IN TYPEOF(afao.item))))= 0 ;
	WR2 :  SIZEOF(QUERY(afao <* annotation_fill_area_occurrence | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CARTESIAN_POINT' IN TYPEOF(afao.fill_style_target))))= 0 ;
	WR3 :  SIZEOF(QUERY(afao <* annotation_fill_area_occurrence | SIZEOF(QUERY(psa <* afao.styles | SIZEOF(QUERY(cs <* psa.styles |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CURVE_STYLE' IN TYPEOF(cs))))= 0))= 0))= 0 ;
END_RULE; -- fill_area_occurrence_constraint

RULE fill_area_style_constraint FOR (fill_area_style);
 
WHERE
	WR1 :  SIZEOF(QUERY(fas <* fill_area_style | NOT(SIZEOF(fas.fill_styles)= 1)))= 0 ;
END_RULE; -- fill_area_style_constraint

RULE fill_area_style_unique_constraint FOR (fill_area_style);
 LOCAL
 r : BAG  OF  fill_area_style := QUERY(r <* fill_area_style | TRUE );
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ] \ fill_area_style.name)THEN  IF(r [ i ] \ fill_area_style.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + r [ i ] \ fill_area_style.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- fill_area_style_unique_constraint

RULE radius_edge_feature_shape_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'radius edge feature shape')AND(SIZEOF(QUERY(lmwu <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'maximum radius length')))= 0)))= 0 ;
	WR2 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'radius edge feature shape')AND(SIZEOF(QUERY(lmwu <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'minimum radius length')))= 0)))= 0 ;
END_RULE; -- radius_edge_feature_shape_constraint

RULE step_edge_feature_shape_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'step edge feature shape')AND  NOT(SIZEOF(QUERY(lmwu <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'maximum step depth')))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'step edge feature shape')AND  NOT(SIZEOF(QUERY(lmwu <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'maximum step width')))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'step edge feature shape')AND  NOT(SIZEOF(QUERY(lmwu <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'minimum step depth')))= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'step edge feature shape')AND  NOT(SIZEOF(QUERY(lmwu <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(lmwu))AND(lmwu \ representation_item.name = 'minimum step width')))= 1)))= 0 ;
END_RULE; -- step_edge_feature_shape_constraint

RULE design_functional_unit_allocation_to_assembly_joint_unique_constraint FOR (product_definition_relationship);
 LOCAL
 dfuataj : BAG  OF  product_definition_relationship := QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to  assembly joint'));
 pass : BOOLEAN := TRUE;
 pd_bag : BAG OF product_definition := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(dfuataj)BY 1;
 IF  EXISTS(dfuataj [ i ].relating_product_definition)THEN  IF(dfuataj [ i ].relating_product_definition.id = 'design composition path')THEN  IF(dfuataj [ i ].relating_product_definition IN pd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pd_bag := pd_bag + dfuataj [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- design_functional_unit_allocation_to_assembly_joint_unique_constraint

RULE design_functional_unit_allocation_to_assembly_component_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to assembly component')AND(NOT((pdr.relating_product_definition \ product_definition.description = 'design definition path')AND(pdr.relating_product_definition.id = 'design composition path')))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to assembly component')AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr.related_product_definition)))))= 0 ;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_constraint

RULE design_functional_unit_allocation_to_assembly_component_unique_constraint FOR (product_definition_relationship);
 LOCAL
 dfuatac : BAG  OF  product_definition_relationship := QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to  assembly component'));
 cd_bag : BAG  OF  component_definition := [ ];
 pdr_bag : BAG  OF  product_definition_relationship;
 pass : BOOLEAN := TRUE;
 id_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(dfuatac)BY  1;
 IF  EXISTS(dfuatac [ i ].related_product_definition)THEN  IF('FUNCTIONAL_DECOMPOSITION_TO_DESIGN_MIM.' + 'COMPONENT_DEFINITION' IN  TYPEOF(dfuatac [ i ].related_product_definition))THEN  IF(NOT(dfuatac [ i ].related_product_definition IN  cd_bag))THEN  cd_bag := cd_bag + dfuatac [ i ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(cd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* dfuatac |(pdr.related_product_definition :=: cd_bag [ i ]));
 id_bag := [ ];
 REPEAT j := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ j ].id)THEN  IF(pdr_bag [ j ].id IN id_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE id_bag := id_bag + pdr_bag [ j ].id;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- design_functional_unit_allocation_to_assembly_component_unique_constraint

RULE reference_composition_path_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference composition path')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition \ product_definition.description = 'reference definition path')AND(pdr.relating_product_definition.frame_of_reference.name = 'functional occurrence'))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference composition path')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN TYPEOF(pdr.related_product_definition))AND(pdr.related_product_definition.frame_of_reference.name = 'functional occurrence'))))= 0 ;
END_RULE; -- reference_composition_path_constraint

RULE reference_functional_unit_assignment_to_part_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference functional unit assignment to part')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN  TYPEOF(pdr.related_product_definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLICATION_CONTEXT_ELEMENT' IN TYPEOF(pdr.related_product_definition.frame_of_reference))AND((pdr.relating_product_definition.frame_of_reference.name = 'physical design')OR(pdr.relating_product_definition.frame_of_reference.name = 'physical design usage')))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'reference functional unit assignment to part')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION' IN TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition \ product_definition.description = 'design definition path')AND(pdr.relating_product_definition.id = 'reference composition path'))))= 0 ;
END_RULE; -- reference_functional_unit_assignment_to_part_constraint

RULE reference_functional_unit_assignment_to_part_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 sar : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'reference functional unit assignment to  part'));
 d_bag : BAG  OF  STRING := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 pd_bag : BAG OF product_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 IF  EXISTS(sar [ i ] \ shape_aspect_relationship.description)THEN  IF(NOT(sar [ i ] \ shape_aspect_relationship.description IN  d_bag))THEN  d_bag := d_bag + sar [ i ] \ shape_aspect_relationship.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(d_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(r <* sar |(r \ shape_aspect_relationship.description = d_bag [ i ]));
 pd_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect.of_shape.definition)THEN  IF(sar_bag [ j ].related_shape_aspect.of_shape.definition IN pd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pd_bag := pd_bag + sar_bag [ j ].related_shape_aspect.of_shape.definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- reference_functional_unit_assignment_to_part_unique_constraint

RULE design_functional_unit_allocation_to_fabrication_joint_unique_constraint FOR (product_definition_relationship);
 LOCAL
 dfuatfj : BAG  OF  product_definition_relationship := QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'design functional unit allocation to  fabrication joint'));
 pass : BOOLEAN := TRUE;
 pd_bag : BAG OF product_definition := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(dfuatfj)BY 1;
 IF  EXISTS(dfuatfj [ i ].relating_product_definition)THEN  IF(dfuatfj [ i ].relating_product_definition.id = 'design composition path')THEN  IF(dfuatfj [ i ].relating_product_definition IN pd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pd_bag := pd_bag + dfuatfj [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- design_functional_unit_allocation_to_fabrication_joint_unique_constraint

RULE transmission_line_functional_unit_terminal_allocation_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 tlfuta : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'transmission line functional terminal allocation'));
 sa_bag : BAG  OF  shape_aspect;
 sar_bag : BAG  OF  shape_aspect_relationship;
 ut_bag : BAG OF shape_aspect := [ ];
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(tlfuta)BY  1;
 IF  EXISTS(tlfuta [ i ].relating_shape_aspect)THEN  IF(tlfuta [ i ].relating_shape_aspect \ shape_aspect.description = 'unit terminal')THEN  IF(NOT(tlfuta [ i ].relating_shape_aspect IN  ut_bag))THEN  ut_bag := ut_bag + tlfuta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(ut_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* tlfuta |((sar.related_shape_aspect \ shape_aspect.description = 'printed component join terminal')AND(sar.relating_shape_aspect :=: ut_bag [ i ])));
 sa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(sar_bag [ j ].related_shape_aspect IN sa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sa_bag := sa_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- transmission_line_functional_unit_terminal_allocation_unique_constraint

RULE aggregate_connectivity_requirement_unique_constraint FOR (product_definition_relationship);
 LOCAL
 acr : BAG  OF  product_definition_relationship := QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'aggregate connectivity requirement'));
 pass : BOOLEAN := TRUE;
 pd_bag : BAG OF product_definition := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(acr)BY 1;
 IF  EXISTS(acr [ i ].related_product_definition)THEN  IF(acr [ i ].id = 'design composition path')THEN  IF(acr [ i ].related_product_definition IN pd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pd_bag := pd_bag + acr [ i ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- aggregate_connectivity_requirement_unique_constraint

RULE physical_connectivity_definition_relationship_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'physical connectivity definition change')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.related_shape_aspect))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'physical connectivity definition change')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))))= 0 ;
	WR3 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'physical connectivity definition change')AND(SIZEOF(QUERY(rpd <* USEDIN(sar, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rpd))))= 0)))= 0 ;
END_RULE; -- physical_connectivity_definition_relationship_constraint

RULE physical_connectivity_element_unique_constraint FOR (physical_connectivity_element);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 pce_bag : BAG  OF  physical_connectivity_element;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 pcd_bag : BAG OF physical_connectivity_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(physical_connectivity_element)BY  1;
 IF  EXISTS(physical_connectivity_element [ i ] \ shape_aspect.name)THEN  IF(NOT(physical_connectivity_element [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + physical_connectivity_element [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pcd_bag := [ ];
 pce_bag := QUERY(pce <* physical_connectivity_element |(pce \ shape_aspect.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(pce_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(pce_bag [ j ], 'FUNCTIONAL_DESIGN_ELABORATION_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'structure element')AND('FUNCTIONAL_DESIGN_ELABORATION_MIM.' + 'PHYSICAL_CONNECTIVITY_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect))));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].relating_shape_aspect)THEN  IF(sar_bag [ j ].relating_shape_aspect IN pcd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pcd_bag := pcd_bag + sar_bag [ j ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- physical_connectivity_element_unique_constraint

RULE subtype_exclusiveness_geometric_tolerance FOR (geometric_tolerance);
 
WHERE
	WR1 :  SIZEOF(QUERY(gt <* geometric_tolerance | NOT(type_check_function(gt, [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FLATNESS_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POSITION_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TOTAL_RUNOUT_TOLERANCE' ], 3))))= 0 ;
END_RULE; -- subtype_exclusiveness_geometric_tolerance

RULE subtype_mandatory_geometric_tolerance FOR (geometric_tolerance);
 
WHERE
	WR1 :  SIZEOF(QUERY(gt <* geometric_tolerance | NOT(type_check_function(gt, [ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FLATNESS_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POSITION_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TOTAL_RUNOUT_TOLERANCE' ], 0))))= 0 ;
END_RULE; -- subtype_mandatory_geometric_tolerance

RULE compatible_dimension FOR (cartesian_point, direction, representation_context, geometric_representation_context);
 
WHERE
	WR1 :  SIZEOF(QUERY(x <* cartesian_point | SIZEOF(QUERY(y <* geometric_representation_context | item_in_context(x, y)AND(HIINDEX(x.coordinates)<> y.coordinate_space_dimension)))> 0))= 0 ;
	WR2 :  SIZEOF(QUERY(x <* direction | SIZEOF(QUERY(y <* geometric_representation_context | item_in_context(x, y)AND(HIINDEX(x.direction_ratios)<> y.coordinate_space_dimension)))> 0))= 0 ;
END_RULE; -- compatible_dimension

RULE design_intent_modification_planar_position_constraint FOR (mapped_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(mi <* mapped_item |(mi \ representation_item.name = 'design intent modification planar position')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target))))= 0 ;
	WR2 :  SIZEOF(QUERY(mi <* mapped_item |(mi \ representation_item.name = 'design intent modification planar position')AND(SIZEOF(QUERY(rep <* USEDIN(mi, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')| SIZEOF(USEDIN(rep, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'))= 0))= 0)))= 0 ;
	WR3 :  SIZEOF(QUERY(mi <* mapped_item |(mi \ representation_item.name = 'design intent modification planar position')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_source.mapped_representation))))= 0 ;
END_RULE; -- design_intent_modification_planar_position_constraint

RULE design_intent_modification_3d_position_constraint FOR (mapped_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(mi <* mapped_item |(mi \ representation_item.name = 'positioned design intent modification 3d shape')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))))= 0 ;
END_RULE; -- design_intent_modification_3d_position_constraint

RULE explicitly_located_layer_connection_point_unique_constraint FOR (layer_connection_point);
 LOCAL
 ellcp : BAG  OF  layer_connection_point := QUERY(lcp <* layer_connection_point |(lcp \ shape_aspect.description = 'explicitly located'));
 s_bag : BAG  OF  stratum := [ ];
 lcp_bag : BAG  OF  layer_connection_point;
 pd_bag : BAG  OF  property_definition;
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 cp_bag : BAG OF cartesian_point;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(ellcp)BY  1;
 IF  EXISTS(ellcp [ i ].of_shape.definition)THEN  IF('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'STRATUM' IN  TYPEOF(ellcp [ i ].of_shape.definition))THEN  IF(NOT(ellcp [ i ].of_shape.definition IN  s_bag))THEN  s_bag := s_bag + ellcp [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(s_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 cp_bag := [ ];
 lcp_bag := QUERY(lcp <* ellcp |(lcp.of_shape.definition :=: s_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(lcp_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pd_bag := USEDIN(lcp_bag [ j ], 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'PROPERTY_DEFINITION.DEFINITION');
 REPEAT  k := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ k ], 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|((pdr.used_representation \ representation.name = 'connection point location')AND('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'CARTESIAN_POINT' IN  TYPEOF(pdr.used_representation.items [ 1 ]))));
 REPEAT l := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ l ].used_representation.items [ 1 ])THEN  IF(pdr_bag [ l ].used_representation.items [ 1 ] IN cp_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE cp_bag := cp_bag + pdr_bag [ l ].used_representation.items [ 1 ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- explicitly_located_layer_connection_point_unique_constraint

RULE junction_vertex_allocation_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'junction vertex allocation')AND  NOT((('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LAYER_CONNECTION_POINT' IN  TYPEOF(sar.related_shape_aspect))AND(sar.related_shape_aspect \ shape_aspect.description = 'explicitly located'))OR(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'JOIN_SHAPE_ASPECT' IN TYPEOF(sar.related_shape_aspect))AND(sar.related_shape_aspect \ shape_aspect.name = 'inter stratum join')))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'junction vertex allocation')AND NOT(sar.relating_shape_aspect \ shape_aspect.description = 'topological junction')))= 0 ;
END_RULE; -- junction_vertex_allocation_constraint

RULE junction_vertex_allocation_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 jva : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'junction vertex allocation'));
 pass : BOOLEAN := TRUE;
 sa_bag : BAG OF shape_aspect := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(jva)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF  EXISTS(jva [ i ].relating_shape_aspect)THEN  IF(jva [ i ].relating_shape_aspect \ shape_aspect.description = 'topological junction')THEN  IF(jva [ i ].relating_shape_aspect IN sa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sa_bag := sa_bag + jva [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- junction_vertex_allocation_unique_constraint

RULE physical_connectivity_abstraction_map_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 pcam : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'physical to  topological abstraction map'));
 pce_bag : BAG  OF  physical_connectivity_element := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 csa_bag : BAG OF component_shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pcam)BY  1;
 IF  EXISTS(pcam [ i ].related_shape_aspect)THEN  IF('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'PHYSICAL_CONNECTIVITY_ELEMENT' IN  TYPEOF(pcam [ i ].related_shape_aspect))THEN  IF(NOT(pcam [ i ].related_shape_aspect IN  pce_bag))THEN  pce_bag := pce_bag + pcam [ i ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pce_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 csa_bag := [ ];
 sar_bag := QUERY(sar <* pcam |(sar.related_shape_aspect :=: pce_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF(('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'COMPONENT_SHAPE_ASPECT' IN  TYPEOF(sar_bag [ j ].relating_shape_aspect))AND(sar_bag [ j ].relating_shape_aspect \ shape_aspect.description IN  [ 'conductive interconnect element with  pre defined transitions', 'conductive interconnect element with user defined single transition' ]))THEN  IF  EXISTS(sar_bag [ j ].relating_shape_aspect)THEN  IF(sar_bag [ j ].relating_shape_aspect IN csa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE csa_bag := csa_bag + sar_bag [ j ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- physical_connectivity_abstraction_map_unique_constraint

RULE topological_junction_unique_constraint FOR (shape_aspect);
 LOCAL
 tj : BAG  OF  shape_aspect := QUERY(r <* shape_aspect |(r \ shape_aspect.description = 'topological junction'));
 sar_bag : BAG  OF  shape_aspect_relationship;
 s_bag : BAG  OF  shape_aspect := [ ];
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(tj)BY  1;
 sar_bag := QUERY(sar <* USEDIN(tj [ i ], 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'topological junction scope')AND(('INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'PHYSICAL_CONNECTIVITY_DEFINITION')IN  TYPEOF(sar.relating_shape_aspect))));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF  EXISTS(sar_bag [ j ].relating_shape_aspect)THEN  IF(NOT(sar_bag [ j ].relating_shape_aspect IN  s_bag))THEN  s_bag := s_bag + sar_bag [ j ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(s_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(s_bag [ i ], 'INTERCONNECT_MODULE_CONNECTION_ROUTING_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'topological junction scope'));
 name_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect \ shape_aspect.name)THEN  IF(sar_bag [ j ].related_shape_aspect \ shape_aspect.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + sar_bag [ j ].related_shape_aspect \ shape_aspect.name;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- topological_junction_unique_constraint

RULE component_feature_to_layout_feature_relationship_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'component feature to layout feature')AND NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL' ] * TYPEOF(sar.relating_shape_aspect))> 0)))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'component feature to layout feature')AND NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' ] * TYPEOF(sar.related_shape_aspect))> 0)))= 0 ;
END_RULE; -- component_feature_to_layout_feature_relationship_constraint

RULE interconnect_module_surface_feature_constraint FOR (shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(sa <* shape_aspect |((sa \ shape_aspect.description = 'interconnect module edge segment surface')OR(sa \ shape_aspect.description = 'interconnect module cavity surface')OR(sa \ shape_aspect.description = 'interconnect module cutout surface')OR(sa \ shape_aspect.description = 'interconnect module edge surface')OR(sa \ shape_aspect.description = 'interconnect module primary surface')OR(sa \ shape_aspect.description = 'interconnect module secondary surface')OR(sa \ shape_aspect.description = 'interconnect module surface feature'))AND  NOT((sa.of_shape.definition \ product_definition.name = 'interconnect module')AND(sa.of_shape.definition.frame_of_reference.name = 'physical design usage')AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN  TYPEOF(sa.of_shape.definition))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_PHYSICAL_UNIT' IN  TYPEOF(sa.of_shape.definition))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LIBRARY_DEFINED_PHYSICAL_UNIT' IN TYPEOF(sa.of_shape.definition))))))= 0 ;
END_RULE; -- interconnect_module_surface_feature_constraint

RULE located_interconnect_module_thickness_requirement_unique_constraint FOR (property_definition_representation);
 LOCAL
 limrt : BAG  OF  property_definition_representation := QUERY(pdr <* property_definition_representation |(pdr.definition \ property_definition.name = 'located interconnect module thickness')AND('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' + 'SHAPE_ASPECT' IN  TYPEOF(pdr.definition.definition)));
 pu_bag : BAG  OF  physical_unit := [ ];
 pdr_bag : BAG  OF  property_definition_representation;
 rr_bag : BAG  OF  representation_relationship;
 pass : BOOLEAN := TRUE;
 ri_bag : BAG OF representation_item;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(limrt)BY  1;
 IF  EXISTS(limrt [ i ].definition.definition.of_shape.definition)THEN  IF(('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(limrt [ i ].definition.definition.of_shape.definition)))THEN  IF(NOT(limrt [ i ].definition.definition.of_shape.definition IN  pu_bag))THEN  pu_bag := pu_bag + limrt [ i ].definition.definition.of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ri_bag := [ ];
 pdr_bag := QUERY(pdr <* limrt |(pdr.definition.definition.of_shape.definition :=: pu_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 rr_bag := QUERY(rr <* USEDIN(pdr_bag [ j ].used_representation, 'INTERCONNECT_MODULE_USAGE_VIEW_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_2')|(rr \ representation_relationship.name = 'reference location'));
 REPEAT  k := 1 TO  SIZEOF(rr_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(rr_bag [ k ].rep_1.items)BY 1;
 IF(('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' + 'AXIS2_PLACEMENT_2D' IN  TYPEOF(rr_bag [ k ].rep_1.items [ l ]))OR('INTERCONNECT_MODULE_USAGE_VIEW_MIM.' + 'AXIS2_PLACEMENT_3D' IN  TYPEOF(rr_bag [ k ].rep_1.items [ l ])))THEN  IF  EXISTS(rr_bag [ k ].rep_1.items [ l ])THEN  IF(rr_bag [ k ].rep_1.items [ l ] IN ri_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE ri_bag := ri_bag + rr_bag [ k ].rep_1.items [ l ];
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- located_interconnect_module_thickness_requirement_unique_constraint

RULE interconnect_module_constraint_region_constraint FOR (group_shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(gsa <* group_shape_aspect | NOT(gsa \ shape_aspect.description = 'interconnect module constraint region')OR  NOT(SIZEOF(QUERY(pd <* USEDIN(gsa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')| NOT(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CSG_2D_SHAPE_REPRESENTATION' IN TYPEOF(pdr.used_representation))OR(pdr.used_representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 3))))= 1)))= 0)))= 0 ;
END_RULE; -- interconnect_module_constraint_region_constraint

RULE layout_spacing_requirement_non_conforming_design_object_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'layout spacing requirement violation')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' ] * TYPEOF(sar.related_shape_aspect))= 0)))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'layout spacing requirement violation')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_INTERFACE_TERMINAL', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' ] * TYPEOF(sar.relating_shape_aspect))= 0)))= 0 ;
	WR3 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'layout spacing requirement violation')AND  NOT(SIZEOF(QUERY(grp <* USEDIN(sar, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP' IN TYPEOF(grp))AND(grp \ group.name = 'layout spacing requirements property')))= 1)))= 0 ;
END_RULE; -- layout_spacing_requirement_non_conforming_design_object_constraint

RULE product_definition_replacement_requires_effectivity_assignment FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr.name = 'definition replacement')AND(SIZEOF(USEDIN(pdr, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS'))= 0)))= 0 ;
END_RULE; -- product_definition_replacement_requires_effectivity_assignment

RULE restrict_assembly_category FOR (product_definition);
 LOCAL
 assembly_definitions : SET OF product_definition := [ ];
 END_LOCAL
;
 assembly_definitions := QUERY(pd <* product_definition | SIZEOF(QUERY(pdca <* USEDIN(pd, 'ITEM_DEFINITION_STRUCTURE_MIM.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION')| pdca.frame_of_reference.name = 'assembly definition'))> 0);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* assembly_definitions | NOT('assembly' IN categories_of_product(pd.formation.of_product))))= 0 ;
END_RULE; -- restrict_assembly_category

RULE restrict_product_definitions_for_part_definition_relationship FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr.name IN [ 'geometrical relationship', 'definition replacement' ])AND((pdr.relating_product_definition.frame_of_reference.name <> 'part definition')OR(pdr.related_product_definition.frame_of_reference.name <> 'part definition'))))= 0 ;
END_RULE; -- restrict_product_definitions_for_part_definition_relationship

RULE planar_curve_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(NOT(NOT(sr \ representation.name IN [ 'planar projected shape', 'bevel edge feature shape', 'step edge feature shape', 'radius edge feature shape' ])OR(sr \ representation.context_of_items \ geometric_representation_context.coordinate_space_dimension = 2)))))= 0 ;
END_RULE; -- planar_curve_constraint

RULE stratum_interconnect_module_planar_position_constraint FOR (mapped_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(mi <* mapped_item |(mi \ representation_item.name = 'planar positioned stratum shape in  interconnect module')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(mi.mapping_target))))= 0 ;
END_RULE; -- stratum_interconnect_module_planar_position_constraint

RULE stratum_planar_shape_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation | NOT(NOT((sr \ representation.name = 'planar projected shape')AND(SIZEOF(QUERY(pdr <* USEDIN(sr, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN  TYPEOF(pdr.definition.definition))))= 1))OR(SIZEOF(QUERY(a2p2d <* sr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_2D' IN TYPEOF(a2p2d))))>= 0))))= 0 ;
END_RULE; -- stratum_planar_shape_constraint

RULE stratum_interconnect_module_3d_position_constraint FOR (mapped_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(mi <* mapped_item |(mi \ representation_item.name = '3d positioned stratum shape in  interconnect module')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))))= 0 ;
END_RULE; -- stratum_interconnect_module_3d_position_constraint

RULE stratum_surface_in_stratum_3d_position_constraint FOR (mapped_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(mi <* mapped_item |(mi \ representation_item.name = 'stratum surface in  stratum 3d position')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(mi.mapping_target))))= 0 ;
END_RULE; -- stratum_surface_in_stratum_3d_position_constraint

RULE adjacent_stratum_surface_definition_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'adjacent stratum surface definition')AND(NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_SURFACE' IN  TYPEOF(sar.related_shape_aspect))AND(sar.related_shape_aspect \ shape_aspect.description IN [ 'secondary surface' ])))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'adjacent stratum surface definition')AND(NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_SURFACE' IN  TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description IN [ 'primary surface' ])))))= 0 ;
END_RULE; -- adjacent_stratum_surface_definition_constraint

RULE adjacent_stratum_surface_definition_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 assd : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.description = 'adjacent stratum surface definition'));
 pass1 : BOOLEAN  := TRUE ;
 name_bag : BAG  OF  STRING := [ ];
 pss_bag : BAG  OF  stratum_surface := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass2 : BOOLEAN := TRUE;
 sss_bag : BAG OF stratum_surface;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(assd)BY  1;
 IF  EXISTS(assd [ i ] \ shape_aspect_relationship.name)THEN  IF(assd [ i ] \ shape_aspect_relationship.name IN  name_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  name_bag := name_bag + assd [ i ] \ shape_aspect_relationship.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(assd)BY  1;
 IF  EXISTS(assd [ i ].relating_shape_aspect)THEN  IF('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'STRATUM_SURFACE' IN  TYPEOF(assd [ i ].relating_shape_aspect))THEN  IF(NOT(assd [ i ].relating_shape_aspect IN  pss_bag))THEN  pss_bag := pss_bag + assd [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pss_bag)BY  1;
 IF(NOT pass2)THEN  ESCAPE ;
 END_IF ;
 sss_bag := [ ];
 sar_bag := QUERY(sar <* assd |(sar.relating_shape_aspect :=: pss_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'STRATUM_SURFACE' IN  TYPEOF(assd [ j ].related_shape_aspect))THEN  IF(sar_bag [ j ].related_shape_aspect IN sss_bag)THEN pass2 := FALSE;
 ESCAPE;
 ELSE sss_bag := sss_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- adjacent_stratum_surface_definition_unique_constraint

RULE component_termination_passage_template_terminal_unique_constraint FOR (shape_aspect);
 LOCAL
 ctptt : BAG  OF  shape_aspect := QUERY(sa <* shape_aspect |((sa \ shape_aspect.description = 'component termination passage template interface terminal')OR(sa \ shape_aspect.description = 'component termination passage template join terminal')));
 name_bag : BAG  OF  STRING := [ ];
 sa_bag : BAG  OF  shape_aspect;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 ptd_bag : BAG OF part_template_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(ctptt)BY  1;
 IF  EXISTS(ctptt [ i ] \ shape_aspect.name)THEN  IF(NOT(ctptt [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + ctptt [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ptd_bag := [ ];
 sa_bag := QUERY(sa <* ctptt |(sa \ shape_aspect.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(sa_bag [ j ], 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'access mechanism')AND('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'PART_TEMPLATE_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.name = 'component termination passage template')));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ k ].relating_shape_aspect)THEN  IF(sar_bag [ k ].relating_shape_aspect IN ptd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE ptd_bag := ptd_bag + sar_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_termination_passage_template_terminal_unique_constraint

RULE conductive_interconnect_element_terminal_unique_constraint FOR (component_terminal);
 LOCAL
 ciet : BAG  OF  component_terminal := QUERY(ct <* component_terminal |(ct \ shape_aspect.description = 'conductive interconnect element terminal'));
 name_bag : BAG  OF  STRING := [ ];
 ct_bag : BAG  OF  component_terminal;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 csa_bag : BAG OF component_shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(ciet)BY  1;
 IF  EXISTS(ciet [ i ] \ shape_aspect.name)THEN  IF(NOT(ciet [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + ciet [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ct_bag := QUERY(ct <* ciet |(ct \ shape_aspect.name = name_bag [ i ]));
 csa_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(ct_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(ct_bag [ j ], 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'associated component')AND(sar.relating_shape_aspect \ shape_aspect.description IN  [ 'conductive interconnect element with  pre defined transitions', 'conductive interconnect element with user defined single transition' ])AND('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'COMPONENT_SHAPE_ASPECT' IN  TYPEOF(sar.relating_shape_aspect))));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ k ].relating_shape_aspect)THEN  IF(sar_bag [ k ].relating_shape_aspect IN csa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE csa_bag := csa_bag + sar_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- conductive_interconnect_element_terminal_unique_constraint

RULE default_passage_based_land_physical_template_unique_constraint FOR (land_physical_template);
 LOCAL
 dpblpt : BAG  OF  land_physical_template := QUERY(lpt <* land_physical_template |(lpt \ shape_aspect.description IN  [ 'default via based', 'default attachment size and  via based', 'default unsupported passage based', 'default component termination passage based', 'default attachment size and  component termination passage based' ]));
 sar_bag : BAG  OF  shape_aspect_relationship;
 pt_bag : BAG  OF  passage_technology := [ ];
 pdr_bag : BAG  OF  property_definition_relationship;
 pass : BOOLEAN := TRUE;
 st_bag : BAG OF stratum_technology;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(dpblpt)BY  1;
 sar_bag := QUERY(sar <* USEDIN(dpblpt [ i ], 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'technology usage')AND('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'PASSAGE_TECHNOLOGY' IN  TYPEOF(sar.related_shape_aspect))));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(NOT(sar_bag [ j ].related_shape_aspect IN  pt_bag))THEN  pt_bag := pt_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pt_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 st_bag := [ ];
 sar_bag := QUERY(sar <* USEDIN(pt_bag [ i ], 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'technology usage')AND(sar.relating_shape_aspect IN  dpblpt)));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(sar_bag [ j ].relating_shape_aspect \ shape_aspect.of_shape, 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION')|((pdr \ property_definition_relationship.name = 'technology usage')AND('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'STRATUM_TECHNOLOGY' IN  TYPEOF(pdr.relating_property_definition.definition))));
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ k ].relating_property_definition.definition)THEN  IF(pdr_bag [ k ].relating_property_definition.definition IN st_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE st_bag := st_bag + pdr_bag [ k ].relating_property_definition.definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- default_passage_based_land_physical_template_unique_constraint

RULE inter_stratum_extent_constraint FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.name = 'inter stratum extent')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN  TYPEOF(pdr.related_product_definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN TYPEOF(pdr.relating_product_definition)))))= 0 ;
END_RULE; -- inter_stratum_extent_constraint

RULE interconnect_module_stratum_assembly_relationship_constraint FOR (assembly_component_usage);
 
WHERE
	WR1 :  SIZEOF(QUERY(acu <* assembly_component_usage |(acu \ product_definition_relationship.name = 'interconnect module stratum assembly relationship')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(acu.relating_product_definition))))= 0 ;
	WR2 :  SIZEOF(QUERY(acu <* assembly_component_usage |(acu \ product_definition_relationship.name = 'interconnect module stratum assembly relationship')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN TYPEOF(acu.related_product_definition))))= 0 ;
END_RULE; -- interconnect_module_stratum_assembly_relationship_constraint

RULE interconnect_module_stratum_assembly_relationship_unique_constraint FOR (assembly_component_usage);
 LOCAL
 imsar : BAG  OF  assembly_component_usage := QUERY(acu <* assembly_component_usage |(acu \ product_definition_relationship.name = 'interconnect module stratum assembly relationship'));
 pu_bag : BAG  OF  physical_unit := [ ];
 acu_bag : BAG  OF  assembly_component_usage;
 pass : BOOLEAN := TRUE;
 refdes_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(imsar)BY  1;
 IF  EXISTS(imsar [ i ].relating_product_definition)THEN  IF((imsar [ i ].relating_product_definition.frame_of_reference.name = 'physical design')AND('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(imsar [ i ].relating_product_definition)))THEN  IF(NOT(imsar [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + imsar [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 refdes_bag := [ ];
 acu_bag := QUERY(acu <* imsar |(acu.relating_product_definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(acu_bag)BY 1;
 IF  EXISTS(acu_bag [ j ].reference_designator)THEN  IF(acu_bag [ j ].reference_designator IN refdes_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE refdes_bag := refdes_bag + acu_bag [ j ].reference_designator;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- interconnect_module_stratum_assembly_relationship_unique_constraint

RULE internal_stratum_access_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 isa : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'internal stratum access'));
 paa_bag : BAG  OF  probe_access_area := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 pp_bag : BAG OF plated_passage;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(isa)BY  1;
 IF  EXISTS(isa [ i ].relating_shape_aspect)THEN  IF((isa [ i ].relating_shape_aspect \ shape_aspect.description = 'internal probe access area')AND('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'PROBE_ACCESS_AREA' IN  TYPEOF(isa [ i ].relating_shape_aspect)))THEN  IF(NOT(isa [ i ].relating_shape_aspect IN  paa_bag))THEN  paa_bag := paa_bag + isa [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(paa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pp_bag := [ ];
 sar_bag := QUERY(sar <* isa |((sar.relating_shape_aspect :=: paa_bag [ i ])AND('LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'PLATED_PASSAGE' IN  TYPEOF(sar.related_shape_aspect))AND(sar.related_shape_aspect \ shape_aspect.description IN  [ 'bonded conductive base blind via', 'buried via', 'interfacial connection', 'non conductive base blind via', 'plated conductive base blind via' ])));
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(sar_bag [ j ].related_shape_aspect IN pp_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pp_bag := pp_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- internal_stratum_access_unique_constraint

RULE stratum_feature_unique_constraint FOR (stratum_feature);
 LOCAL
 sf_bag : BAG  OF  stratum_feature;
 s_bag : BAG  OF  stratum := [ ];
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(stratum_feature)BY  1;
 IF  EXISTS(stratum_feature [ i ].of_shape.definition)THEN  IF(NOT(stratum_feature [ i ].of_shape.definition IN  s_bag))THEN  s_bag := s_bag + stratum_feature [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(s_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sf_bag := QUERY(r <* stratum_feature |(r.of_shape.definition :=: s_bag [ i ]));
 name_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sf_bag)BY 1;
 IF  EXISTS(sf_bag [ j ] \ shape_aspect.name)THEN  IF(sf_bag [ j ] \ shape_aspect.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + sf_bag [ j ] \ shape_aspect.name;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- stratum_feature_unique_constraint

RULE stratum_surface_unique_constraint FOR (stratum_surface);
 LOCAL
 ss_bag : BAG  OF  stratum_surface;
 s_bag : BAG  OF  stratum := [ ];
 pass : BOOLEAN := TRUE;
 desc_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(stratum_surface)BY  1;
 IF  EXISTS(stratum_surface [ i ].of_shape.definition)THEN  IF(NOT(stratum_surface [ i ].of_shape.definition IN  s_bag))THEN  s_bag := s_bag + stratum_surface [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(s_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 ss_bag := QUERY(r <* stratum_surface |(r.of_shape.definition :=: s_bag [ i ]));
 desc_bag := [ ];
 REPEAT j := 1 TO SIZEOF(ss_bag)BY 1;
 IF  EXISTS(ss_bag [ j ] \ shape_aspect.description)THEN  IF(ss_bag [ j ] \ shape_aspect.description IN desc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE desc_bag := desc_bag + ss_bag [ j ] \ shape_aspect.description;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- stratum_surface_unique_constraint

RULE via_template_terminal_unique_constraint FOR (shape_aspect);
 LOCAL
 vt : BAG  OF  shape_aspect := QUERY(r <* shape_aspect |(r \ shape_aspect.description = 'via template'));
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(vt)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(vt [ i ], 'LAYERED_INTERCONNECT_MODULE_DESIGN_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'access mechanism')AND(sar.related_shape_aspect \ shape_aspect.description = 'via template terminal')));
 name_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect \ shape_aspect.name)THEN  IF(sar_bag [ j ].related_shape_aspect \ shape_aspect.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + sar_bag [ j ].related_shape_aspect \ shape_aspect.name;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- via_template_terminal_unique_constraint

RULE design_intent_modification_sequence_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'shape modification sequence')AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar.relating_shape_aspect)))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'shape modification sequence')AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_MODIFICATION' IN TYPEOF(sar.related_shape_aspect)))))= 0 ;
END_RULE; -- design_intent_modification_sequence_constraint

RULE design_intent_modification_sequence_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 dims : BAG  OF  shape_aspect_relationship := QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'shape modification sequence'));
 pm_bag : BAG  OF  shape_modification := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 sm_bag : BAG OF shape_modification;
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(dims)BY  1;
 IF  EXISTS(dims [ i ].relating_shape_aspect)THEN  IF('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTEND_MODIFICATIONS_MIM.' + 'SHAPE_MODIFICATION' IN  TYPEOF(dims [ i ].relating_shape_aspect))THEN  IF(NOT(dims [ i ].relating_shape_aspect IN  pm_bag))THEN  pm_bag := pm_bag + dims [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pm_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* dims |(sar.relating_shape_aspect :=: pm_bag [ i ]));
 sm_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF('LAYERED_INTERCONNECT_MODULE_WITH_DESIGN_INTEND_MODIFICATIONS_MIM.' + 'SHAPE_MODIFICATION' IN  TYPEOF(sar_bag [ j ].related_shape_aspect))THEN  IF(sar_bag [ j ].related_shape_aspect IN sm_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sm_bag := sm_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- design_intent_modification_sequence_unique_constraint

RULE feature_shape_definition_constraint FOR (shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(sr <* shape_representation |(sr \ representation.name = 'zone shape')AND(sr.context_of_items.coordinate_space_dimension = 3)AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MANIFOLD_SUBSURFACE_SHAPE_REPRESENTATION' IN TYPEOF(sr))))= 0 ;
END_RULE; -- feature_shape_definition_constraint

RULE land_physical_template_unique_constraint FOR (land_physical_template);
 LOCAL
 adr_bag : BAG  OF  applied_document_reference;
 duc : BAG  OF  document_usage_constraint;
 pass : BOOLEAN := TRUE;
 duc_bag : BAG OF document_usage_constraint := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(land_physical_template)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := USEDIN(land_physical_template [ i ], 'MANUFACTURING_TECHNOLOGY_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
 REPEAT  j := 1 TO  SIZEOF(adr_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 duc := QUERY(r <* USEDIN(adr_bag [ j ].assigned_document, 'MANUFACTURING_TECHNOLOGY_MIM.' + 'DOCUMENT_USAGE_CONSTRAINT.SOURCE')|(r \ document_usage_constraint.subject_element = 'predefined classification code'));
 REPEAT k := 1 TO SIZEOF(duc)BY 1;
 IF  EXISTS(duc [ k ])THEN  IF(duc [ k ] IN duc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE duc_bag := duc_bag + duc [ k ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- land_physical_template_unique_constraint

RULE land_template_terminal_unique_constraint FOR (land_template_terminal);
 LOCAL
 ltt : BAG  OF  land_template_terminal := QUERY(sa <* land_template_terminal |(sa \ shape_aspect.description IN  [ 'interface terminal', 'join terminal' ]));
 name_bag : BAG  OF  STRING := [ ];
 ltt_bag : BAG  OF  land_template_terminal;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 lpt_bag : BAG OF land_physical_template;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(ltt)BY  1;
 IF  EXISTS(ltt [ i ] \ shape_aspect.name)THEN  IF(NOT(ltt [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + ltt [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 lpt_bag := [ ];
 ltt_bag := QUERY(sa <* ltt |(sa \ shape_aspect.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(ltt_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(ltt_bag [ j ], 'MANUFACTURING_TECHNOLOGY_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'associated definition')AND('MANUFACTURING_TECHNOLOGY_MIM.' + 'LAND_PHYSICAL_TEMPLATE' IN  TYPEOF(sar.relating_shape_aspect))));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ k ].relating_shape_aspect)THEN  IF(sar_bag [ k ].relating_shape_aspect IN lpt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE lpt_bag := lpt_bag + sar_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- land_template_terminal_unique_constraint

RULE layout_spacing_requirement_occurrence_unique_constraint FOR (grouped_requirements_property, characterized_object);
 LOCAL
 lsro : BAG  OF  grouped_requirements_property := QUERY(grp <* grouped_requirements_property |(grp \ group.name = 'layout spacing requirements property'));
 ddo : BAG  OF  characterized_object := QUERY(co <* characterized_object |(co \ characterized_object.description = 'dependent design object category'));
 ga_bag : BAG  OF  group_assignment := [ ];
 ddname_bag : BAG  OF  STRING  := [ ];
 co_bag : BAG  OF  characterized_object := [ ];
 pdb : LIST OF  property_definition := [ ];
 pd_bag : BAG  OF  property_definition := [ ];
 grp_bag : BAG  OF  grouped_requirements_property := [ ];
 rga_bag : BAG  OF  group_assignment := [ ];
 pass : BOOLEAN := TRUE;
 rdname_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(lsro)BY  1;
 ga_bag := QUERY(aga <* USEDIN(lsro [ i ], 'MANUFACTURING_TECHNOLOGY_MIM.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')| 'MANUFACTURING_TECHNOLOGY_MIM.' + 'APPLIED_GROUP_ASSIGNMENT' IN  TYPEOF(aga));
 REPEAT  j := 1 TO  SIZEOF(ga_bag)BY  1;
 REPEAT  k := 1 TO  SIZEOF(ga_bag [ j ].items)BY  1;
 IF('MANUFACTURING_TECHNOLOGY_MIM.' + 'PROPERTY_DEFINITION' IN  TYPEOF(ga_bag [ j ].items [ k ]))THEN  pdb [ i ] := ga_bag [ j ].items [ k ];
 ELSE  pdb := [ ];
 END_IF ;
 IF((pdb :<>: [ ])AND('MANUFACTURING_TECHNOLOGY_MIM.' + 'CHARACTERIZED_OBJECT' IN  TYPEOF(pdb [ 1 ] \ property_definition.definition))AND(pdb [ 1 ] \ property_definition.definition \ characterized_object.description = 'dependent design object category'))THEN  IF  EXISTS(pdb [ 1 ] \ property_definition.definition \ characterized_object.name)THEN  IF(NOT(pdb [ 1 ] \ property_definition.definition \ characterized_object.name IN  ddname_bag))THEN  ddname_bag := ddname_bag + pdb [ 1 ] \ property_definition.definition \ characterized_object.name;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(ddname_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 rdname_bag := [ ];
 co_bag := QUERY(co <* ddo |(co \ characterized_object.name = ddname_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(co_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pd_bag := USEDIN(co_bag [ j ], 'MANUFACTURING_TECHNOLOGY_MIM.' + 'PROPERTY_DEFINITION.DEFINITION');
 REPEAT  k := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ga_bag := QUERY(ga <* USEDIN(pd_bag [ k ], 'MANUFACTURING_TECHNOLOGY_MIM.' + 'APPLIED_GROUP_ASSIGNMENT.ITEMS')|('MANUFACTURING_TECHNOLOGY_MIM.' + 'GROUPED_REQUIREMENTS_PROPERTY' IN  TYPEOF(ga.assigned_group)));
 REPEAT  l := 1 TO  SIZEOF(ga_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 IF(NOT(ga_bag [ l ].assigned_group IN  grp_bag))THEN  grp_bag := grp_bag + ga_bag [ l ].assigned_group;
 END_IF ;
 END_REPEAT ;
 REPEAT  l := 1 TO  SIZEOF(grp_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 rga_bag := USEDIN(grp_bag [ l ], 'MANUFACTURING_TECHNOLOGY_MIM.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP');
 REPEAT  m := 1 TO  SIZEOF(rga_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT n := 1 TO SIZEOF(rga_bag [ m ].items)BY 1;
 IF('MANUFACTURING_TECHNOLOGY_MIM.' + 'PROPERTY_DEFINITION' IN  TYPEOF(rga_bag [ n ].items [ m ]))THEN  pdb [ 1 ] := rga_bag [ n ].items [ m ];
 ELSE  pdb := [ ];
 END_IF ;
 IF((pdb :<>: [ ])AND('MANUFACTURING_TECHNOLOGY_MIM.' + 'CHARACTERIZED_OBJECT' IN  TYPEOF(pdb [ 1 ] \ property_definition.definition))AND(pdb [ 1 ] \ property_definition.definition \ characterized_object.description = 'reference design object category'))THEN  IF  EXISTS(pdb [ 1 ] \ property_definition.definition \ characterized_object.name)THEN  IF(pdb [ 1 ] \ property_definition.definition \ characterized_object.name IN rdname_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rdname_bag := rdname_bag + pdb [ 1 ] \ property_definition.definition \ characterized_object.name;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- layout_spacing_requirement_occurrence_unique_constraint

RULE model_parameter_unique_constraint FOR (model_parameter);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 mp_bag : BAG  OF  model_parameter;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 d_bag : BAG OF document;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(model_parameter)BY  1;
 IF  EXISTS(model_parameter [ i ] \ representation_item.name)THEN  IF(NOT(model_parameter [ i ] \ representation_item.name IN  name_bag))THEN  name_bag := name_bag + model_parameter [ i ] \ representation_item.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 mp_bag := QUERY(mp <* model_parameter |(mp \ representation_item.name = name_bag [ i ]));
 d_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(mp_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := USEDIN(mp_bag [ j ], 'MODEL_PARAMETER_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS');
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN d_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE d_bag := d_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- model_parameter_unique_constraint

RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(ala1 <* attribute_language_assignment | SIZEOF(QUERY(it <* ala1.items | SIZEOF(QUERY(ala2 <* USEDIN(it, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')|(ala1 \ attribute_classification_assignment.attribute_name = ala2 \ attribute_classification_assignment.attribute_name)AND(ala1 \ attribute_classification_assignment.assigned_class :=: ala2 \ attribute_classification_assignment.assigned_class)))> 1))> 0))= 0 ;
END_RULE; -- restrict_language_assignment_per_attribute

RULE bus_structural_definition_unique_constraint FOR (bus_structural_definition, product_definition_formation, product);
 LOCAL
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(bus_structural_definition)BY 1;
 IF  EXISTS(bus_structural_definition [ i ].formation.of_product.name)THEN  IF(bus_structural_definition [ i ].formation.of_product.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + bus_structural_definition [ i ] \ product_definition.formation.of_product.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- bus_structural_definition_unique_constraint

RULE functional_unit_network_node_definition_unique_constraint FOR (network_node_definition);
 LOCAL
 funnd : BAG  OF  network_node_definition := QUERY(nnd <* network_node_definition |(nnd.frame_of_reference.name = 'functional network design'));
 name_bag : BAG  OF  STRING := [ ];
 nnd_bag : BAG  OF  network_node_definition;
 pdr_bag : BAG  OF  product_definition_relationship;
 pass : BOOLEAN := TRUE;
 fu_bag : BAG OF functional_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(funnd)BY  1;
 IF  EXISTS(funnd [ i ] \ product_definition.name)THEN  IF(NOT(funnd [ i ] \ product_definition.name IN  name_bag))THEN  name_bag := name_bag + funnd [ i ] \ product_definition.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 fu_bag := [ ];
 nnd_bag := QUERY(nnd <* funnd |(nnd \ product_definition.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(nnd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(nnd_bag [ j ], 'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|(('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(pdr.relating_product_definition))AND(pdr \ product_definition_relationship.name = 'functional unit network node')));
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ k ].relating_product_definition)THEN  IF(pdr_bag [ k ].relating_product_definition IN fu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE fu_bag := fu_bag + pdr_bag [ k ].relating_product_definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_unit_network_node_definition_unique_constraint

RULE functional_unit_network_terminal_definition_bus_assignment_constraint FOR (property_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_relationship |(pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* property_definition_relationship |(pdr \ property_definition_relationship.name = 'functional unit network terminal definition bus assignment')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_SHAPE' IN  TYPEOF(pdr.related_property_definition.definition))AND(SIZEOF(QUERY(futd <* USEDIN(pdr.related_property_definition.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION.OF_SHAPE' IN TYPEOF(futd))))> 0))))= 0 ;
END_RULE; -- functional_unit_network_terminal_definition_bus_assignment_constraint

RULE functional_unit_terminal_bus_assignment_constraint FOR (property_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_relationship |(pdr \ property_definition_relationship.name = 'functional unit terminal bus assignment')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN TYPEOF(pdr.relating_property_definition.definition))))= 0 ;
END_RULE; -- functional_unit_terminal_bus_assignment_constraint

RULE functional_unit_unique_constraint FOR (component_functional_unit);
 LOCAL
 fu : BAG  OF  component_functional_unit := QUERY(cfu <* component_functional_unit |(cfu.frame_of_reference.name = 'functional occurrence'));
 id_bag : BAG  OF  STRING := [ ];
 cfu_bag : BAG  OF  component_functional_unit;
 pdr_bag : BAG  OF  product_definition_relationship;
 pass : BOOLEAN := TRUE;
 fu_bag : BAG OF functional_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(fu)BY  1;
 IF  EXISTS(fu [ i ].id)THEN  IF(NOT(fu [ i ].id IN  id_bag))THEN  id_bag := id_bag + fu [ i ].id;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(id_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 fu_bag := [ ];
 cfu_bag := QUERY(cfu <* fu |(cfu.id = id_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(cfu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(cfu_bag [ j ], 'NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'network composition')AND('NETWORK_FUNCTIONAL_DESIGN_VIEW_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(pdr.relating_product_definition))AND(pdr.relating_product_definition.frame_of_reference.name = 'functional network design')));
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ k ].relating_product_definition)THEN  IF(pdr_bag [ k ].relating_product_definition IN fu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE fu_bag := fu_bag + pdr_bag [ k ].relating_product_definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_unit_unique_constraint

RULE functional_unit_usage_view_terminal_definition_unique_constraint FOR (functional_unit_terminal_definition);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 futd_bag : BAG  OF  functional_unit_terminal_definition;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 fu_bag : BAG OF functional_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(functional_unit_terminal_definition)BY  1;
 IF  EXISTS(functional_unit_terminal_definition [ i ] \ shape_aspect.name)THEN  IF(NOT(functional_unit_terminal_definition [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + functional_unit_terminal_definition [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 fu_bag := [ ];
 futd_bag := QUERY(futd <* functional_unit_terminal_definition |((futd \ shape_aspect.name = name_bag [ i ])AND('NETWORK_FUNCTIONAL_USAGE_VIEW_MIM.' + 'FUNCTIONAL_UNIT' IN  TYPEOF(futd.of_shape.definition))AND(futd.of_shape.definition.frame_of_reference.name = 'functional design usage')));
 REPEAT j := 1 TO SIZEOF(futd_bag)BY 1;
 IF  EXISTS(futd_bag [ j ].of_shape.definition)THEN  IF(futd_bag [ j ].of_shape.definition IN fu_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE fu_bag := fu_bag + futd_bag [ j ].of_shape.definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_unit_usage_view_terminal_definition_unique_constraint

RULE package_unique_constraint FOR (package);
 LOCAL
 p : BAG  OF  physical_unit := QUERY(r <* package |(r.frame_of_reference.name = 'physical design usage'));
 pu : BAG  OF  physical_unit;
 pd_bag : BAG  OF  property_definition;
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 r_bag : BAG OF representation := [ ];
 END_LOCAL
;
 pu := p;
 REPEAT  i := 1 TO  SIZEOF(pu)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pd_bag := USEDIN(pu [ i ], 'PACKAGE_MIM.' + 'PROPERTY_DEFINITION.DEFINITION');
 REPEAT  j := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := QUERY(pdr <* USEDIN(pd_bag [ j ], 'PACKAGE_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation \ representation.name = 'registered case style'));
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ k ].used_representation)THEN  IF(pdr_bag [ k ].used_representation IN r_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE r_bag := r_bag + pdr_bag [ k ].used_representation;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- package_unique_constraint

RULE polarity_indication_feature_constraint FOR (shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(NOT(sa \ shape_aspect.description = 'polarity indication feature')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'associated body vertical extent'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_BOTTOM_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1))))= 0 ;
	WR2 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(NOT(sa \ shape_aspect.description = 'polarity indication feature')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'associated body vertical extent'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_BODY_TOP_SURFACE' IN TYPEOF(it.relating_shape_aspect))))<= 1))))= 0 ;
	WR3 :  SIZEOF(QUERY(sa <* shape_aspect | NOT(NOT(sa \ shape_aspect.description = 'polarity indication feature')OR(SIZEOF(QUERY(it <* QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'associated terminal'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGE_TERMINAL' IN TYPEOF(it.relating_shape_aspect))))= 1))))= 0 ;
END_RULE; -- polarity_indication_feature_constraint

RULE packaged_connector_terminal_relationship_unique_constraint FOR (packaged_connector_terminal_relationship);
 LOCAL
 pu_bag : BAG  OF  physical_unit := [ ];
 pctr_bag : BAG  OF  packaged_connector_terminal_relationship;
 it_bag : BAG  OF  packaged_part_terminal;
 jt_bag : BAG OF packaged_part_terminal;
 pass1 : BOOLEAN  := TRUE ;
 pass2 : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(packaged_connector_terminal_relationship)BY  1;
 IF  EXISTS(packaged_connector_terminal_relationship [ i ].of_shape.definition)THEN  IF('PACKAGED_CONNECTOR_MODEL_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(packaged_connector_terminal_relationship [ i ].of_shape.definition))THEN  IF(NOT(packaged_connector_terminal_relationship [ i ].of_shape.definition IN  pu_bag))THEN  pu_bag := pu_bag + packaged_connector_terminal_relationship [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT(pass1 OR  pass2))THEN  ESCAPE ;
 END_IF ;
 it_bag := [ ];
 jt_bag := [ ];
 pctr_bag := QUERY(r <* packaged_connector_terminal_relationship |(r.of_shape.definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(pctr_bag)BY 1;
 IF(NOT(pass1 OR pass2))THEN  ESCAPE ;
 END_IF ;
 IF(pass1 AND('PACKAGED_CONNECTOR_MODEL_MIM.' + 'PACKAGED_PART_TERMINAL' IN  TYPEOF(pctr_bag [ j ].relating_shape_aspect))AND(pctr_bag [ j ].relating_shape_aspect \ shape_aspect.description = 'join terminal'))THEN  IF  EXISTS(pctr_bag [ j ].relating_shape_aspect)THEN  IF(pctr_bag [ j ].relating_shape_aspect IN  jt_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  jt_bag := jt_bag + pctr_bag [ j ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 IF(pass2 AND('PACKAGED_CONNECTOR_MODEL_MIM.' + 'PACKAGED_PART_TERMINAL' IN  TYPEOF(pctr_bag [ j ].related_shape_aspect))AND(pctr_bag [ j ].related_shape_aspect \ shape_aspect.description = 'interface terminal'))THEN  IF  EXISTS(pctr_bag [ j ].related_shape_aspect)THEN  IF(pctr_bag [ j ].related_shape_aspect IN it_bag)THEN pass2 := FALSE;
 ESCAPE;
 ELSE it_bag := it_bag + pctr_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- packaged_connector_terminal_relationship_unique_constraint

RULE packaged_part_unique_constraint FOR (packaged_part);
 LOCAL
 pp : SET OF  physical_unit := packaged_part;
 pdr_bag : BAG  OF  product_definition_relationship;
 pdf_bag : BAG OF product_definition_formation := [ ];
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pp)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pdf_bag := [ ];
 pdr_bag := QUERY(pdr <* USEDIN(pp [ i ], 'PACKAGED_PART_BLACK_BOX_MODEL_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|((pdr \ product_definition_relationship.name = 'used package')AND(('PACKAGED_PART_BLACK_BOX_MODEL_MIM.' + 'PACKAGE' IN  TYPEOF(pdr.relating_product_definition)))));
 pdf_bag := pdf_bag + pdr_bag [ 1 ].relating_product_definition.formation;
 REPEAT k := 1 TO SIZEOF(pdr_bag)BY 1;
 IF(NOT  pass)THEN  ESCAPE;
 END_IF ;
 IF  EXISTS(pdr_bag [ k ].relating_product_definition.formation)THEN  IF NOT(pdr_bag [ k ].relating_product_definition.formation IN pdf_bag)THEN pass := FALSE;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- packaged_part_unique_constraint

RULE device_terminal_map_relationship_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'device terminal map relationship')AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DEVICE_TERMINAL_MAP' IN TYPEOF(sar.relating_shape_aspect)))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'device terminal map relationship')AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DEVICE_TERMINAL_MAP' IN TYPEOF(sar.related_shape_aspect)))))= 0 ;
END_RULE; -- device_terminal_map_relationship_constraint

RULE part_device_terminal_model_port_assignment_unique_constraint FOR (property_definition_representation);
 LOCAL
 amp_bag : BAG  OF  analytical_model_port := [ ];
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 sa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(property_definition_representation)BY  1;
 IF  EXISTS(property_definition_representation [ i ].used_representation)THEN  IF('PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'ANALYTICAL_MODEL_PORT' IN  TYPEOF(property_definition_representation [ i ].used_representation))THEN  IF(NOT(property_definition_representation [ i ].used_representation IN  amp_bag))THEN  amp_bag := amp_bag + property_definition_representation [ i ].used_representation;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(amp_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sa_bag := [ ];
 pdr_bag := QUERY(pdr <* property_definition_representation |(pdr.used_representation :=: amp_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ j ].definition.definition)THEN  IF(pdr_bag [ j ].definition.definition IN sa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sa_bag := sa_bag + pdr_bag [ j ].definition.definition;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- part_device_terminal_model_port_assignment_unique_constraint

RULE part_device_terminal_unique_constraint FOR (shape_aspect);
 LOCAL
 pdr_bag : BAG  OF  product_definition_relationship := [ ];
 sa_bag : BAG  OF  shape_aspect;
 pd_bag : BAG  OF  property_definition;
 sa : BAG  OF  bare_die_terminal;
 pass : BOOLEAN := TRUE;
 bdt_bag : BAG OF bare_die_terminal;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(shape_aspect)BY  1;
 IF  EXISTS(shape_aspect [ i ].of_shape.definition)THEN  IF(('PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'PRODUCT_DEFINITION_RELATIONSHIP' IN  TYPEOF(shape_aspect [ i ].of_shape.definition))AND(shape_aspect [ i ].of_shape.definition.description = 'part device'))THEN  IF(NOT(shape_aspect [ i ].of_shape.definition IN  pdr_bag))THEN  pdr_bag := pdr_bag + shape_aspect [ i ].of_shape.definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pdr_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 bdt_bag := [ ];
 sa_bag := QUERY(sa <* shape_aspect |(sa.of_shape.definition :=: pdr_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pd_bag := QUERY(pd <* USEDIN(sa_bag [ j ].of_shape.definition.related_product_definition, 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'PROPERTY_DEFINITION.DEFINITION')|(SIZEOF([ 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'BARE_DIE' ] * TYPEOF(pd.definition))> 0));
 REPEAT  k := 1 TO  SIZEOF(pd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sa := QUERY(bdt <* USEDIN(pd_bag [ k ], 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'SHAPE_ASPECT.OF_SHAPE')|('PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'BARE_DIE_TERMINAL' IN  TYPEOF(bdt)));
 REPEAT l := 1 TO SIZEOF(sa)BY 1;
 IF  EXISTS(sa [ l ])THEN  IF(sa [ l ] IN bdt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE bdt_bag := bdt_bag + sa [ l ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- part_device_terminal_unique_constraint

RULE part_device_unique_constraint FOR (product_definition_relationship);
 LOCAL
 pd : BAG  OF  product_definition_relationship := QUERY(pdr <* product_definition_relationship |(pdr \ product_definition_relationship.description = 'part device'));
 pu_bag : BAG  OF  physical_unit := [ ];
 pdr_bag : BAG  OF  product_definition_relationship;
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pd)BY  1;
 IF  EXISTS(pd [ i ].relating_product_definition)THEN  IF((pd [ i ].relating_product_definition.frame_of_reference.name = 'physical design usage')AND(SIZEOF([ 'PACKAGED_PART_WHITE_BOX_MODEL_MIM.' + 'PACKAGED_PART' ] * TYPEOF(pd [ i ].relating_product_definition))> 0))THEN  IF(NOT(pd [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + pd [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 name_bag := [ ];
 pdr_bag := QUERY(pdr <* pd |(pdr.relating_product_definition :=: pu_bag [ i ]));
 REPEAT j := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ j ] \ product_definition_relationship.name)THEN  IF(pdr_bag [ j ] \ product_definition_relationship.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + pdr_bag [ j ] \ product_definition_relationship.name;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- part_device_unique_constraint

RULE package_external_reference_constraint FOR (representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'design owner'))))= 1)))= 0 ;
	WR2 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'part number'))))= 1)))= 0 ;
	WR3 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'revision code'))))= 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(rep <* representation |(rep \ representation.name = 'package external reference')AND(SIZEOF(QUERY(dri <* rep.items | NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'product definition id'))))= 1)))= 0 ;
END_RULE; -- package_external_reference_constraint

RULE package_terminal_external_reference_constraint FOR (descriptive_representation_item);
 
WHERE
	WR1 :  SIZEOF(QUERY(dri <* descriptive_representation_item |(dri \ representation_item.name = 'package terminal external reference')AND(SIZEOF(QUERY(rep <* USEDIN(dri, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION.ITEMS')|(rep \ representation.name = 'package external reference')))= 0)))= 0 ;
END_RULE; -- package_terminal_external_reference_constraint

RULE package_terminal_external_reference_unique_constraint FOR (descriptive_representation_item);
 LOCAL
 pter : BAG  OF  descriptive_representation_item := QUERY(dri <* descriptive_representation_item |(dri \ representation_item.name = 'package terminal external reference'));
 desc_bag : BAG  OF  STRING := [ ];
 dri_bag : BAG  OF  descriptive_representation_item;
 rep_bag : BAG  OF  representation;
 pass : BOOLEAN := TRUE;
 r_bag : BAG OF representation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pter)BY  1;
 IF  EXISTS(pter [ i ] \ descriptive_representation_item.description)THEN  IF(NOT(pter [ i ] \ descriptive_representation_item.description IN  desc_bag))THEN  desc_bag := desc_bag + pter [ i ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(desc_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 r_bag := [ ];
 dri_bag := QUERY(dri <* pter |(dri \ descriptive_representation_item.description = desc_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(dri_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 rep_bag := QUERY(r <* USEDIN(dri_bag [ j ], 'PART_EXTERNAL_REFERENCE_MIM.' + 'REPRESENTATION.ITEMS')|(r \ representation.name = 'package external reference'));
 REPEAT k := 1 TO SIZEOF(rep_bag)BY 1;
 IF  EXISTS(rep_bag [ k ])THEN  IF(rep_bag [ k ] IN r_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE r_bag := r_bag + rep_bag [ k ];
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- package_terminal_external_reference_unique_constraint

RULE part_terminal_external_reference_unique_constraint FOR (representation);
 LOCAL
 pter : BAG  OF  representation := QUERY(r <* representation |(r \ representation.name = 'part terminal external reference'));
 fn_bag : BAG  OF  STRING  := [ ];
 ft_bag : BAG  OF  STRING := [ ];
 r_bag : BAG  OF  representation;
 pdr_bag : BAG  OF  property_definition_representation;
 pass : BOOLEAN := TRUE;
 ptd_bag : BAG OF part_template_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pter)BY  1;
 REPEAT  j := 1 TO  SIZEOF(pter [ i ].items)BY  1;
 IF('PART_EXTERNAL_REFERENCE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(pter [ i ].items [ j ]))THEN  IF((pter [ i ].items [ j ] \ representation_item.name = 'feature name')AND(NOT(pter [ i ].items [ j ] \ descriptive_representation_item.description IN  fn_bag)))THEN  fn_bag := fn_bag + pter [ i ].items [ j ] \ descriptive_representation_item.description;
 END_IF ;
 IF((pter [ i ].items [ j ] \ representation_item.name = 'feature type')AND(NOT(pter [ i ].items [ j ] \ descriptive_representation_item.description IN  ft_bag)))THEN  ft_bag := ft_bag + pter [ i ].items [ j ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fn_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT  j := 1 TO  SIZEOF(ft_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 r_bag := QUERY(r <* pter |((SIZEOF(QUERY(ri <* r.items |((ri \ descriptive_representation_item.description = ft_bag [ j ])AND(ri \ representation_item.name = 'feature type'))))> 0)AND(SIZEOF(QUERY(ri <* r.items |((ri \ descriptive_representation_item.description = fn_bag [ i ])AND(ri \ representation_item.name = 'feature name'))))> 0)));
 ptd_bag := [ ];
 REPEAT  k := 1 TO  SIZEOF(r_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 pdr_bag := USEDIN(r_bag [ k ], 'PART_EXTERNAL_REFERENCE_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
 REPEAT l := 1 TO SIZEOF(pdr_bag)BY 1;
 IF  EXISTS(pdr_bag [ l ].definition.definition)THEN  IF('PART_EXTERNAL_REFERENCE_MIM.' + 'PHYSICAL_UNIT' IN  TYPEOF(pdr_bag [ l ].definition.definition))THEN  IF(pdr_bag [ l ].definition.definition IN ptd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE ptd_bag := ptd_bag + pdr_bag [ l ].definition.definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- part_terminal_external_reference_unique_constraint

RULE restrict_part_occurrence FOR (product_definition);
 LOCAL
 part_occurrences : SET OF product_definition := [ ];
 END_LOCAL
;
 part_occurrences := QUERY(pd <* product_definition |(pd.frame_of_reference.name = 'part occurrence'));
 
WHERE
	wr1 :  SIZEOF(QUERY(pd <* part_occurrences |(NOT(pd.name IN [ 'single instance', 'selected instance', 'quantified instance', 'specified instance' ]))))= 0 ;
	wr2 :  SIZEOF(QUERY(pd <* part_occurrences |(SIZEOF(QUERY(pdr <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| pdr.name = 'definition usage'))<> 1)AND(SIZEOF(QUERY(cd <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN')|(cd.name = 'occurrence usage definition')AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF(cd.configuration)))))<> 1)))= 0 ;
	wr3 :  SIZEOF(QUERY(pd <* part_occurrences |(SIZEOF(QUERY(cd <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_USAGE' IN TYPEOF(cd))))= 0)AND(SIZEOF(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE'))= 0)))= 0 ;
	wr4 :  SIZEOF(QUERY(pd <* part_occurrences |(pd.name = 'selected instance')AND NOT valid_selected_instance_representation(pd)))= 0 ;
	wr5 :  SIZEOF(QUERY(pd <* part_occurrences |(pd.name = 'quantified instance')AND(SIZEOF(QUERY(ppd <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION')|(ppd.name = 'occurrence quantity')AND(SIZEOF(QUERY(pdr <* USEDIN(ppd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation.name = 'quantity')AND(SIZEOF(pdr.used_representation.items)= 1)AND(SIZEOF(QUERY(i <* pdr.used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i))AND(i.name = 'quantity measure')))= 1)))= 1)))= 0)))= 0 ;
	wr6 :  SIZEOF(QUERY(pd <* part_occurrences |(pd.name = 'specified instance')AND(SIZEOF(QUERY(pdor <* USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdor.occurrence_usage)))= 0)))= 0 ;
END_RULE; -- restrict_part_occurrence

RULE restrict_part_occurrence_category FOR (product_definition);
 LOCAL
 part_occurrences : SET OF product_definition := [ ];
 END_LOCAL
;
 part_occurrences := QUERY(pd <* product_definition |(pd.frame_of_reference.name = 'part occurrence'));
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* part_occurrences |(SIZEOF(QUERY(prpc <* USEDIN(pd.formation.of_product, 'PRODUCT_OCCURRENCE_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name IN [ 'part', 'raw material', 'tool' ]))= 0)))= 0 ;
END_RULE; -- restrict_part_occurrence_category

RULE restrict_product_definitions_for_definition_usage FOR (product_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* product_definition_relationship |(pdr.name = 'definition usage')AND((pdr.relating_product_definition.frame_of_reference.name <> 'part definition')OR(pdr.related_product_definition.frame_of_reference.name <> 'part occurrence'))))= 0 ;
END_RULE; -- restrict_product_definitions_for_definition_usage

RULE selected_instance_usage_requires_representation FOR (assembly_component_usage);
 LOCAL
 selected_instance_usages : SET OF assembly_component_usage := [ ];
 END_LOCAL
;
 selected_instance_usages := QUERY(acr <* assembly_component_usage |(acr.name = 'selected instance usage'));
 
WHERE
	WR1 :  SIZEOF(QUERY(acr <* selected_instance_usages | NOT valid_selected_instance_representation(acr)))= 0 ;
END_RULE; -- selected_instance_usage_requires_representation

RULE part_template_non_planar_2d_shape_constraint FOR (manifold_surface_shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |(mssr \ representation.name = 'part template non planar 2d shape')AND NOT(SIZEOF(QUERY(a2p3d <* mssr.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AXIS2_PLACEMENT_3D' IN TYPEOF(a2p3d))))= 1)))= 0 ;
END_RULE; -- part_template_non_planar_2d_shape_constraint

RULE functional_usage_view_to_part_terminal_assignment_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'functional terminal allocation')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'scalar terminal'))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'functional terminal allocation')AND NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_MODULE_TERMINAL' IN  TYPEOF(sar.related_shape_aspect))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BARE_DIE_TERMINAL' IN  TYPEOF(sar.related_shape_aspect))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INTERCONNECT_MODULE_TERMINAL' IN  TYPEOF(sar.related_shape_aspect))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PACKAGED_PART_TERMINAL' IN TYPEOF(sar.related_shape_aspect)))))= 0 ;
END_RULE; -- functional_usage_view_to_part_terminal_assignment_constraint

RULE functional_usage_view_to_part_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 fuvtpta : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'functional terminal allocation'));
 futd_bag : BAG  OF  functional_unit_terminal_definition := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 sa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(fuvtpta)BY  1;
 IF  EXISTS(fuvtpta [ i ].relating_shape_aspect)THEN  IF(fuvtpta [ i ].relating_shape_aspect \ shape_aspect.description = 'scalar terminal')THEN  IF(NOT(fuvtpta [ i ].relating_shape_aspect IN  futd_bag))THEN  futd_bag := futd_bag + fuvtpta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(futd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* fuvtpta |((sar.relating_shape_aspect :=: futd_bag [ i ])AND(SIZEOF([ 'PART_TERMINAL_MIM.' + 'ASSEMBLY_MODULE_TERMINAL', 'PART_TERMINAL_MIM.' + 'BARE_DIE_TERMINAL', 'PART_TERMINAL_MIM.' + 'INTERCONNECT_MODULE_TERMINAL', 'PART_TERMINAL_MIM.' + 'PACKAGED_PART_TERMINAL' ] * TYPEOF(sar.related_shape_aspect))> 0)));
 sa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(sar_bag [ j ].related_shape_aspect IN sa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE sa_bag := sa_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_usage_view_to_part_terminal_assignment_unique_constraint

RULE component_part_2d_geometric_representation_relationship_constraint FOR (shape_representation_relationship);
 LOCAL
 rr : SET OF representation_relationship := QUERY(srr <* shape_representation_relationship | srr \ representation_relationship.name = 'component part planar shape');
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(rr)BY 1;
 IF((rr [ i ].rep_1.context_of_items.coordinate_space_dimension)<>(rr [ i ].rep_2.context_of_items.coordinate_space_dimension))THEN pass := FALSE;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_part_2d_geometric_representation_relationship_constraint

RULE component_part_3d_geometric_representation_relationship_constraint FOR (shape_representation_relationship);
 LOCAL
 rr : SET OF representation_relationship := QUERY(srr <* shape_representation_relationship | srr \ representation_relationship.name = 'component part 3d shape');
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(rr)BY 1;
 IF((rr [ i ].rep_1.context_of_items.coordinate_space_dimension)<>(rr [ i ].rep_2.context_of_items.coordinate_space_dimension))THEN pass := FALSE;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- component_part_3d_geometric_representation_relationship_constraint

RULE part_feature_constraint FOR (shape_aspect, product_definition, shape_aspect_relationship);
 LOCAL
 pass : BOOLEAN := TRUE;
 name_bag : BAG  OF  STRING := [ ];
 sa : BAG  OF  shape_aspect := [ ];
 pd : BAG OF product_definition := QUERY(pd <* product_definition | pd.frame_of_reference \ application_context_element.name = 'physical design usage');
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pd)BY  1;
 name_bag := [ ];
 sa := QUERY(sa <* shape_aspect |((sa.of_shape \ property_definition.definition = pd [ i ])AND(sa.product_definitional)AND(NOT(sa \ shape_aspect.description = 'connection zone'))));
 REPEAT j := 1 TO SIZEOF(sa)BY 1;
 IF(NOT pass)THEN  ESCAPE;
 END_IF ;
 IF sa [ j ] \ shape_aspect.name IN name_bag THEN pass := FALSE;
 ELSE name_bag := name_bag + sa [ j ] \ shape_aspect.name;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'precedent feature')AND(sar.related_shape_aspect = sar.relating_shape_aspect)))= 0 ;
	WR3 :  SIZEOF(QUERY(sa <* shape_aspect |((sa \ shape_aspect.description = 'part group feature')OR(sa \ shape_aspect.description = 'part generic feature')OR(sa \ shape_aspect.description = 'polarity indication feature'))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feature'))> 1)))= 0 ;
	WR4 :  SIZEOF(QUERY(sa <* shape_aspect |((sa \ shape_aspect.description = 'interconnect module edge segment surface')OR(sa \ shape_aspect.description = 'interconnect module cavity surface')OR(sa \ shape_aspect.description = 'interconnect module cutout surface')OR(sa \ shape_aspect.description = 'interconnect module edge surface')OR(sa \ shape_aspect.description = 'interconnect module primary surface')OR(sa \ shape_aspect.description = 'interconnect module secondary surface')OR(sa \ shape_aspect.description = 'interconnect module surface feature'))AND(SIZEOF(QUERY(sar <* USEDIN(sa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')| sar \ shape_aspect_relationship.name = 'precedent feature'))> 0)))= 0 ;
END_RULE; -- part_feature_constraint

RULE product_definition_requires_date_or_date_and_time FOR (product_definition, applied_date_and_time_assignment, applied_date_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition | NOT(NOT(is_ee_product_definition(pd))OR((SIZEOF(QUERY(adata <* applied_date_and_time_assignment | pd IN  adata.items))= 1)OR(SIZEOF(QUERY(ada <* applied_date_assignment | pd IN ada.items))= 1)))))= 0 ;
END_RULE; -- product_definition_requires_date_or_date_and_time

RULE product_definition_requires_person_organization FOR (product_definition, applied_person_and_organization_assignment, applied_organization_assignment);
 
WHERE
	WR1 :  SIZEOF(QUERY(pd <* product_definition | NOT(NOT(is_ee_product_definition(pd))OR((SIZEOF(QUERY(apaoa <* applied_person_and_organization_assignment | pd IN  apaoa.items))= 1)OR(SIZEOF(QUERY(aoa <* applied_organization_assignment | pd IN aoa.items))= 1)))))= 0 ;
END_RULE; -- product_definition_requires_person_organization

RULE promissory_usage_relationship_constraint FOR (promissory_usage_occurrence);
 
WHERE
	WR1 :  SIZEOF(QUERY(puo <* promissory_usage_occurrence |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PHYSICAL_UNIT' IN TYPEOF(puo.relating_product_definition))AND(puo.relating_product_definition.frame_of_reference.name = 'physical design')))= 0 ;
	WR2 :  SIZEOF(QUERY(puo <* promissory_usage_occurrence | SIZEOF(USEDIN(puo, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS'))= 0))= 0 ;
END_RULE; -- promissory_usage_relationship_constraint

RULE promissory_usage_relationship_unique_constraint FOR (promissory_usage_occurrence);
 LOCAL
 pu_bag : BAG  OF  physical_unit := [ ];
 puo_bag : BAG  OF  promissory_usage_occurrence;
 pass : BOOLEAN := TRUE;
 comp_bag : BAG OF physical_unit;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(promissory_usage_occurrence)BY  1;
 IF  EXISTS(promissory_usage_occurrence [ i ].relating_product_definition)THEN  IF((('PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 'PHYSICAL_UNIT')IN  TYPEOF(promissory_usage_occurrence [ i ].relating_product_definition))AND(promissory_usage_occurrence [ i ].relating_product_definition.frame_of_reference.name = 'physical design'))THEN  IF(NOT(promissory_usage_occurrence [ i ].relating_product_definition IN  pu_bag))THEN  pu_bag := pu_bag + promissory_usage_occurrence [ i ].relating_product_definition;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(pu_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 puo_bag := QUERY(puo <* promissory_usage_occurrence |(puo.relating_product_definition :=: pu_bag [ i ]));
 comp_bag := [ ];
 REPEAT j := 1 TO SIZEOF(puo_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF((('PHYSICAL_UNIT_USAGE_VIEW_MIM.' + 'PHYSICAL_UNIT')IN  TYPEOF(puo_bag [ j ].related_product_definition))AND(puo_bag [ j ].related_product_definition.frame_of_reference.name IN  [ 'physical design', 'physical design usage' ]))THEN  IF  EXISTS(puo_bag [ j ].related_product_definition)THEN  IF(puo_bag [ j ].related_product_definition IN comp_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE comp_bag := comp_bag + puo_bag [ j ].related_product_definition;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- promissory_usage_relationship_unique_constraint

RULE symbol_representation_rule FOR (presentation_representation_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(each_1 <* presentation_representation_relationship | NOT('PRESENTATION_DEFINITION_SCHEMA.' + 'SYMBOL_REPRESENTATION_RELATIONSHIP' IN  TYPEOF(each_1))AND(SIZEOF(QUERY(each_2 <* [ each_1 \ representation_relationship.rep_1, each_1 \ representation_relationship.rep_2 ] | 'PRESENTATION_DEFINITION_SCHEMA.SYMBOL_REPRESENTATION' IN TYPEOF(each_2)))> 0)))= 0 ;
END_RULE; -- symbol_representation_rule

RULE functional_usage_view_to_printed_part_template_terminal_assignment_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'functional terminal allocation')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FUNCTIONAL_UNIT_TERMINAL_DEFINITION' IN TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'scalar terminal'))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'functional terminal allocation')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))AND((sar.related_shape_aspect \ shape_aspect.description = 'interface terminal')OR(sar.related_shape_aspect \ shape_aspect.description = 'join terminal')))))= 0 ;
END_RULE; -- functional_usage_view_to_printed_part_template_terminal_assignment_constraint

RULE functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 fuvtpptta : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name = 'functional terminal allocation'));
 futd_bag : BAG  OF  functional_unit_terminal_definition := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 pptt_bag : BAG OF printed_part_template_terminal;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(fuvtpptta)BY  1;
 IF  EXISTS(fuvtpptta [ i ].relating_shape_aspect)THEN  IF(fuvtpptta [ i ].relating_shape_aspect \ shape_aspect.description = 'scalar terminal')THEN  IF(NOT(fuvtpptta [ i ].relating_shape_aspect IN  futd_bag))THEN  futd_bag := futd_bag + fuvtpptta [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(futd_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 pptt_bag := [ ];
 sar_bag := QUERY(sar <* fuvtpptta |((sar.relating_shape_aspect :=: futd_bag [ i ])AND(sar.related_shape_aspect \ shape_aspect.description IN  [ 'interface terminal', 'join terminal' ])AND('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(sar.related_shape_aspect))));
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(sar_bag [ j ].related_shape_aspect IN pptt_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE pptt_bag := pptt_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- functional_usage_view_to_printed_part_template_terminal_assignment_unique_constraint

RULE printed_connector_template_terminal_relationship_unique_constraint FOR (printed_connector_template_terminal_relationship);
 LOCAL
 ptd_bag : BAG  OF  part_template_definition := [ ];
 pcttr_bag : BAG  OF  printed_connector_template_terminal_relationship;
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass1 : BOOLEAN  := TRUE ;
 jt_bag : BAG  OF  printed_part_template_terminal;
 pass2 : BOOLEAN := TRUE;
 it_bag : BAG OF printed_part_template_terminal;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(printed_connector_template_terminal_relationship)BY  1;
 sar_bag := QUERY(sar <* USEDIN(printed_connector_template_terminal_relationship [ i ], 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'connector')AND('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 'PART_TEMPLATE_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect))AND(sar.relating_shape_aspect \ shape_aspect.description = 'printed connector template')));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF  EXISTS(sar_bag [ j ].relating_shape_aspect)THEN  IF(NOT(sar_bag [ j ].relating_shape_aspect IN  ptd_bag))THEN  ptd_bag := ptd_bag + sar_bag [ j ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(ptd_bag)BY  1;
 IF(NOT(pass1 OR  pass2))THEN  ESCAPE ;
 END_IF ;
 it_bag := [ ];
 jt_bag := [ ];
 sar_bag := QUERY(sar <* USEDIN(ptd_bag [ i ], 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'connector'));
 REPEAT  j := 1 TO  SIZEOF(sar_bag)BY  1;
 IF(NOT(pass1 OR  pass2))THEN  ESCAPE ;
 END_IF ;
 pcttr_bag := QUERY(pcttr <* printed_connector_template_terminal_relationship |(pcttr :=: sar_bag [ j ].related_shape_aspect));
 REPEAT k := 1 TO SIZEOF(pcttr_bag)BY 1;
 IF(NOT(pass1 OR pass2))THEN  ESCAPE ;
 END_IF ;
 IF(pass1 AND('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(pcttr_bag [ k ].relating_shape_aspect))AND(pcttr_bag [ k ].relating_shape_aspect \ shape_aspect.description = 'join terminal'))THEN  IF  EXISTS(pcttr_bag [ k ].relating_shape_aspect)THEN  IF(pcttr_bag [ k ].relating_shape_aspect IN  jt_bag)THEN  pass1 := FALSE ;
 ESCAPE ;
 ELSE  jt_bag := jt_bag + pcttr_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF ;
 IF(pass2 AND('PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN  TYPEOF(pcttr_bag [ k ].related_shape_aspect))AND(pcttr_bag [ k ].related_shape_aspect \ shape_aspect.description = 'interface terminal'))THEN  IF  EXISTS(pcttr_bag [ k ].related_shape_aspect)THEN  IF(pcttr_bag [ k ].related_shape_aspect IN it_bag)THEN pass2 := FALSE;
 ESCAPE;
 ELSE it_bag := it_bag + pcttr_bag [ k ].related_shape_aspect;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- printed_connector_template_terminal_relationship_unique_constraint

RULE printed_part_template_terminal_relationship_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'printed part template terminal relationship')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.related_shape_aspect))))= 0 ;
	WR2 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'printed part template terminal relationship')AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_TERMINAL' IN TYPEOF(sar.relating_shape_aspect))))= 0 ;
END_RULE; -- printed_part_template_terminal_relationship_constraint

RULE printed_part_template_terminal_unique_constraint FOR (printed_part_template_terminal);
 LOCAL
 pptt : BAG  OF  printed_part_template_terminal := QUERY(r <* printed_part_template_terminal |(r \ shape_aspect.description IN  [ 'interface terminal', 'join terminal' ]));
 name_bag : BAG  OF  STRING := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 sa_bag : BAG  OF  shape_aspect;
 pass : BOOLEAN := TRUE;
 ptd_bag : BAG OF part_template_definition;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pptt)BY  1;
 IF  EXISTS(pptt [ i ] \ shape_aspect.name)THEN  IF(NOT(pptt [ i ] \ shape_aspect.name IN  name_bag))THEN  name_bag := name_bag + pptt [ i ] \ shape_aspect.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ptd_bag := [ ];
 sa_bag := QUERY(sa <* pptt |(sa \ shape_aspect.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(sar <* USEDIN(sa_bag [ j ], 'PRINTED_PHYSICAL_LAYOUT_TEMPLATE_MIM.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT')|((sar \ shape_aspect_relationship.name = 'associated definition')AND(sar.relating_shape_aspect \ shape_aspect.description = 'printed part template')));
 REPEAT k := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ k ].relating_shape_aspect)THEN  IF(sar_bag [ k ].relating_shape_aspect IN ptd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE ptd_bag := ptd_bag + sar_bag [ k ].relating_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- printed_part_template_terminal_unique_constraint

RULE rule_action_unique_constraint FOR (rule_action);
 LOCAL
 adta : BAG  OF  applied_date_and_time_assignment;
 adta_bag : BAG  OF  applied_date_and_time_assignment := [ ];
 ra_bag : BAG  OF  rule_action;
 aaa_bag : BAG  OF  applied_action_assignment;
 pass : BOOLEAN := TRUE;
 rd_bag : BAG OF product_definition_formation;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(rule_action)BY  1;
 adta := USEDIN(rule_action [ i ], 'PRODUCT_RULE_MIM.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS');
 REPEAT  j := 1 TO  SIZEOF(adta)BY  1;
 IF  EXISTS(adta [ j ])THEN  IF(NOT(adta [ j ] IN  adta_bag))THEN  adta_bag := adta_bag + adta [ j ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(adta_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 ra_bag := QUERY(r <* rule_action |(r IN  adta_bag [ i ].items));
 rd_bag := [ ];
 REPEAT  j := 1 TO  SIZEOF(ra_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 aaa_bag := QUERY(aa <* USEDIN(ra_bag [ j ], 'PRODUCT_RULE_MIM.' + 'ACTION_ASSIGNMENT.ASSIGNED_ACTION')|(('PRODUCT_RULE_MIM.' + 'APPLIED_ACTION_ASSIGNMENT')IN  TYPEOF(aa)));
 REPEAT  k := 1 TO  SIZEOF(aaa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT l := 1 TO SIZEOF(aaa_bag [ k ].items)BY 1;
 IF  EXISTS(aaa_bag [ k ].items [ l ])THEN  IF(('PRODUCT_RULE_MIM.' + 'PRODUCT_DEFINITION_FORMATION' IN  TYPEOF(aaa_bag [ k ].items [ l ]))AND(aaa_bag [ k ].items [ l ] \ product_definition_formation.description = 'rule version'))THEN  IF(aaa_bag [ k ].items [ l ] IN rd_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rd_bag := rd_bag + aaa_bag [ k ].items [ l ];
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_action_unique_constraint

RULE rule_conclusion_definition_unique_constraint FOR (rule_conclusion_definition, representation, representation_relationship);
 LOCAL
 r : BAG  OF  representation := QUERY(r <* representation | r \ representation.name = 'rule definition');
 rr : BAG  OF  representation_relationship := [ ];
 pass : BOOLEAN := TRUE;
 count : INTEGER := 0;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(r)BY  1;
 count := 0;
 name_bag := [ ];
 IF  NOT pass THEN  ESCAPE;
 END_IF ;
 rr := USEDIN(r [ i ], 'PRODUCT_RULE_MIM.' + 'REPRESENTATION_RELATIONSHIP.REP_1');
 REPEAT j := 1 TO SIZEOF(rr)BY 1;
 IF  'PRODUCT_RULE_MIM.' + 'RULE_CONCLUSION_DEFINITION' IN  TYPEOF(rr [ j ].rep_2)THEN  IF  EXISTS(rr [ j ].rep_2 \ representation.name)THEN  IF rr [ j ].rep_2 \ representation.name IN name_bag THEN pass := FALSE;
 ELSE name_bag := name_bag + rr [ j ].rep_2 \ representation.name;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_conclusion_definition_unique_constraint

RULE rule_function_unique_constraint FOR (rule_function_definition);
 LOCAL
 name_bag : BAG  OF  STRING := [ ];
 rfd_bag : BAG  OF  rule_function_definition;
 adr_bag : BAG  OF  applied_document_reference;
 pass : BOOLEAN := TRUE;
 doc_bag : BAG OF document;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(rule_function_definition)BY  1;
 IF  EXISTS(rule_function_definition [ i ] \ representation.name)THEN  IF(NOT(rule_function_definition [ i ] \ representation.name IN  name_bag))THEN  name_bag := name_bag + rule_function_definition [ i ] \ representation.name;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(name_bag)BY  1;
 IF(NOT  pass)THEN  ESCAPE ;
 END_IF ;
 doc_bag := [ ];
 rfd_bag := QUERY(am <* rule_function_definition |(am \ representation.name = name_bag [ i ]));
 REPEAT  j := 1 TO  SIZEOF(rfd_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 adr_bag := QUERY(adr <* USEDIN(rfd_bag [ j ], 'PRODUCT_RULE_MIM.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adr.assigned_document.kind \ document_type.product_data_type = 'reference document'));
 REPEAT k := 1 TO SIZEOF(adr_bag)BY 1;
 IF  EXISTS(adr_bag [ k ].assigned_document)THEN  IF(adr_bag [ k ].assigned_document IN doc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE doc_bag := doc_bag + adr_bag [ k ].assigned_document;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_function_unique_constraint

RULE rule_premise_definition_unique_constraint FOR (rule_premise_definition, representation, representation_relationship);
 LOCAL
 rr : BAG  OF  representation_relationship := [ ];
 rpd : BAG OF rule_premise_definition := [ ];
 pass : BOOLEAN := TRUE;
 count : INTEGER := 0;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(rule_premise_definition)BY  1;
 count := 0;
 IF  NOT  pass THEN  ESCAPE ;
 END_IF ;
 rr := USEDIN(rule_premise_definition [ i ], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_2');
 REPEAT j := 1 TO SIZEOF(rr)BY 1;
 IF  NOT pass THEN  ESCAPE;
 END_IF ;
 IF(rr [ j ] \ representation_relationship.rep_1 \ representation.description IN [ 'rule definition' ])THEN  count := count + 1;
 END_IF ;
 IF count = 2 THEN pass := FALSE;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- rule_premise_definition_unique_constraint

RULE operational_requirement_occurrence_relationship_constraint FOR (property_definition_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(pdr <* property_definition_relationship |((pdr \ property_definition_relationship.name = 'and operation')OR(pdr \ property_definition_relationship.name = 'or operation'))AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.related_property_definition))))= 0 ;
	WR2 :  SIZEOF(QUERY(pdr <* property_definition_relationship |((pdr \ property_definition_relationship.name = 'and operation')OR(pdr \ property_definition_relationship.name = 'or operation'))AND NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(pdr.relating_property_definition))))= 0 ;
END_RULE; -- operational_requirement_occurrence_relationship_constraint

RULE requirements_property_constraint FOR (product_definition, descriptive_representation_item, requirements_property);
 LOCAL
 ri : BAG  OF  descriptive_representation_item := QUERY(dri <* descriptive_representation_item | dri \ representation_item.name = 'requirements name');
 pd : BAG  OF  product_definition := QUERY(tpd <* product_definition |('REQUIREMENT_DECOMPOSITION_MIM.' + 'APPLICATION_CONTEXT_ELEMENT' IN  TYPEOF(tpd.frame_of_reference))AND(tpd.frame_of_reference.name IN  [ 'requirement', 'design requirement', 'assembly requirement' ])AND(tpd.name = 'requirements model'));
 r : BAG  OF  representation := [ ];
 pdr : BAG  OF  property_definition_representation := [ ];
 pass1 : BOOLEAN  := TRUE ;
 rp : BAG OF property_definition := [ ];
 pass2 : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(ri)BY  1;
 r := [ ];
 pdr := [ ];
 r :=(USEDIN(ri [ i ], 'REQUIREMENT_DECOMPOSITION_MIM.' + 'REPRESENTATION.ITEMS'));
 pass1 :=(SIZEOF(r)= 1);
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 pdr :=(USEDIN(r [ 1 ], 'REQUIREMENT_DECOMPOSITION_MIM.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 pass1 :=(SIZEOF(pdr)= 1);
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 pass1 :=('REQUIREMENT_DECOMPOSITION_MIM.' + 'REQUIREMENTS_PROPERTY' IN  TYPEOF(pdr [ 1 ].definition));
 IF(NOT  pass1)THEN  ESCAPE ;
 END_IF ;
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pd)BY 1;
 rp := [ ];
 IF(NOT pass2)THEN ESCAPE;
 END_IF;
 rp := QUERY(rp <* USEDIN(pd [ i ], 'REQUIREMENT_DECOMPOSITION_MIM.' + 'PROPERTY_DEFINITION.DEFINITION')| 'REQUIREMENT_DECOMPOSITION_MIM.' + 'REQUIREMENTS_PROPERTY' IN TYPEOF(rp));
 pass2 :=(SIZEOF(rp)= 1);
 END_REPEAT;
 
WHERE
	WR1 :  pass1 ;
	WR2 :  pass2 ;
END_RULE; -- requirements_property_constraint

RULE requirements_property_unique_constraint FOR (descriptive_representation_item, requirements_property);
 LOCAL
 desc_bag : BAG  OF  STRING := [ ];
 pass1 : BOOLEAN := TRUE;
 pdr : BAG  OF  property_definition_representation := [ ];
 rep : BAG  OF  representation := [ ];
 pd : BAG OF product_definition := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(requirements_property)BY 1;
 IF(NOT pass1)THEN  ESCAPE;
 END_IF ;
 IF('REQUIREMENT_DECOMPOSITION_MIM.' + 'PRODUCT_DEFINITION' IN TYPEOF(requirements_property [ i ].definition))THEN  pd := pd + requirements_property [ i ].definition;
 END_IF ;
 END_REPEAT;
 IF(instance_unique(pd)= FALSE)THEN pass1 := FALSE;
 END_IF;
 
WHERE
	WR1 :  pass1 ;
END_RULE; -- requirements_property_unique_constraint

RULE composite_shape_element_constraint FOR (composite_shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(csa <* composite_shape_aspect | SIZEOF(QUERY(sar <* USEDIN(csa, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar \ shape_aspect_relationship.name = 'composing')))< 2))= 0 ;
	WR2 :  SIZEOF(QUERY(csa <* composite_shape_aspect | NOT((SIZEOF(TYPEOF(csa))> 2)OR(csa \ shape_aspect.description <> '')OR(csa \ shape_aspect.name <> ''))))= 0 ;
END_RULE; -- composite_shape_element_constraint

RULE shape_element_composing_relationship_constraint FOR (shape_aspect_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(sar <* shape_aspect_relationship |(sar \ shape_aspect_relationship.name = 'composing')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPOSITE_SHAPE_ASPECT' IN TYPEOF(sar.relating_shape_aspect))))= 0 ;
END_RULE; -- shape_element_composing_relationship_constraint

RULE shape_element_constituent_relationship_unique_constraint FOR (shape_aspect_relationship);
 LOCAL
 sar : BAG  OF  shape_aspect_relationship := QUERY(r <* shape_aspect_relationship |(r \ shape_aspect_relationship.name IN  [ 'constituent', 'composing', 'bare die terminal surface constituent relationship', 'interconnect module terminal surface constituent relationship', 'package terminal surface constituent relationship' ]));
 sa_bag : BAG  OF  shape_aspect := [ ];
 sar_bag : BAG  OF  shape_aspect_relationship;
 pass : BOOLEAN := TRUE;
 rsa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 IF  EXISTS(sar [ i ].relating_shape_aspect)THEN  IF(NOT(sar [ i ].relating_shape_aspect IN  sa_bag))THEN  sa_bag := sa_bag + sar [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 sar_bag := QUERY(r <* sar |(r \ shape_aspect_relationship.relating_shape_aspect :=: sa_bag [ i ]));
 rsa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(sar_bag)BY 1;
 IF  EXISTS(sar_bag [ j ].related_shape_aspect)THEN  IF(sar_bag [ j ].related_shape_aspect IN rsa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rsa_bag := rsa_bag + sar_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- shape_element_constituent_relationship_unique_constraint

RULE shape_element_locating_relationship_unique_constraint FOR (dimensional_location);
 LOCAL
 sa_bag : BAG  OF  shape_aspect := [ ];
 dl_bag : BAG  OF  dimensional_location;
 pass : BOOLEAN := TRUE;
 rsa_bag : BAG OF shape_aspect;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(dimensional_location)BY  1;
 IF  EXISTS(dimensional_location [ i ].relating_shape_aspect)THEN  IF(NOT(dimensional_location [ i ].relating_shape_aspect IN  sa_bag))THEN  sa_bag := sa_bag + dimensional_location [ i ].relating_shape_aspect;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sa_bag)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 dl_bag := QUERY(r <* dimensional_location |(r.relating_shape_aspect :=: sa_bag [ i ]));
 rsa_bag := [ ];
 REPEAT j := 1 TO SIZEOF(dl_bag)BY 1;
 IF  EXISTS(dl_bag [ j ].related_shape_aspect)THEN  IF(dl_bag [ j ].related_shape_aspect IN rsa_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE rsa_bag := rsa_bag + dl_bag [ j ].related_shape_aspect;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- shape_element_locating_relationship_unique_constraint

RULE subtype_mandatory_composite_shape_aspect FOR (composite_shape_aspect);
 
WHERE
	WR1 :  SIZEOF(QUERY(csa <* composite_shape_aspect | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPOSITE_GROUP_SHAPE_ASPECT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPOSITE_UNIT_SHAPE_ASPECT' ] * TYPEOF(csa))= 1)))= 0 ;
END_RULE; -- subtype_mandatory_composite_shape_aspect

RULE product_requires_category FOR (product);
 
WHERE
	WR1 :  SIZEOF(QUERY(p <* product | SIZEOF(USEDIN(p, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS'))= 0))= 0 ;
END_RULE; -- product_requires_category

RULE stratum_average_surface_shape_constraint FOR (manifold_surface_shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |(mssr \ representation.name = 'stratum average surface shape')AND  NOT(SIZEOF(QUERY(pdr <* USEDIN(mssr, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_SURFACE' IN TYPEOF(pdr.definition.definition))AND(pdr.definition.definition \ shape_aspect.description = 'average surface')))= 1)))= 0 ;
END_RULE; -- stratum_average_surface_shape_constraint

RULE stratum_feature_non_planar_2d_shape_constraint FOR (manifold_surface_shape_representation);
 
WHERE
	WR1 :  SIZEOF(QUERY(mssr <* manifold_surface_shape_representation |(mssr \ representation.name = 'stratum feature non planar 2d shape')AND NOT(SIZEOF(QUERY(pdr <* USEDIN(mssr, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM_FEATURE' IN TYPEOF(pdr.definition.definition))))= 1)))= 0 ;
END_RULE; -- stratum_feature_non_planar_2d_shape_constraint

RULE stratum_feature_shape_stratum_average_surface_shape_relationship_constraint FOR (representation_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(rr <* representation_relationship |(rr \ representation_relationship.name = 'stratum feature shape stratum average surface shape relationship')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))AND(rr.rep_2 \ representation.name = 'stratum feature non planar 2d shape'))))= 0 ;
	WR2 :  SIZEOF(QUERY(rr <* representation_relationship |(rr \ representation_relationship.name = 'stratum feature shape stratum average surface shape relationship')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))AND(rr.rep_1 \ representation.name = 'stratum average surface shape'))))= 0 ;
END_RULE; -- stratum_feature_shape_stratum_average_surface_shape_relationship_constraint

RULE stratum_feature_shape_stratum_surface_shape_relationship_constraint FOR (representation_relationship);
 
WHERE
	WR1 :  SIZEOF(QUERY(rr <* representation_relationship |(rr \ representation_relationship.name = 'stratum feature shape stratum surface shape relationship')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_2))AND(rr.rep_2 \ representation.name = 'stratum feature non planar 2d shape'))))= 0 ;
	WR2 :  SIZEOF(QUERY(rr <* representation_relationship |(rr \ representation_relationship.name = 'stratum feature shape stratum surface shape relationship')AND  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MANIFOLD_SURFACE_SHAPE_REPRESENTATION' IN TYPEOF(rr.rep_1))AND(rr.rep_1 \ representation.name = 'stratum surface shape'))))= 0 ;
END_RULE; -- stratum_feature_shape_stratum_surface_shape_relationship_constraint

RULE curve_style_font_and_scaling_unique_constraint FOR (curve_style_font_and_scaling);
 LOCAL
 r : BAG  OF  curve_style_font_and_scaling := QUERY(r <* curve_style_font_and_scaling | TRUE );
 pass : BOOLEAN := TRUE;
 name_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(r)BY 1;
 IF  EXISTS(r [ i ] \ curve_style_font_and_scaling.name)THEN  IF(r [ i ] \ curve_style_font_and_scaling.name IN name_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE name_bag := name_bag + r [ i ] \ curve_style_font_and_scaling.name;
 END_IF ;
 END_IF;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- curve_style_font_and_scaling_unique_constraint

RULE curve_style_requires_length_measure_with_unit FOR (curve_style);
 
WHERE
	WR1 :  SIZEOF(QUERY(cs <* curve_style | NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT' IN TYPEOF(cs))))= 0 ;
END_RULE; -- curve_style_requires_length_measure_with_unit

RULE curve_style_unique_constraint FOR (representation);
 LOCAL
 cs : BAG  OF  representation := QUERY(r <* representation |((r \ representation.name = 'curve style parameters')AND(r.context_of_items \ representation_context.context_type = 'curve style parametric context')));
 pass : BOOLEAN := TRUE;
 desc_bag : BAG OF STRING := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(cs)BY  1;
 IF(NOT pass)THEN  ESCAPE ;
 END_IF ;
 REPEAT j := 1 TO SIZEOF(cs [ i ].items)BY 1;
 IF(('STYLED_CURVE_MIM.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(cs [ i ].items [ j ]))AND(cs [ i ].items [ j ] \ representation_item.name = 'curve style name'))THEN  IF  EXISTS(cs [ i ].items [ j ] \ descriptive_representation_item.description)THEN  IF(cs [ i ].items [ j ] \ descriptive_representation_item.description IN desc_bag)THEN pass := FALSE;
 ESCAPE;
 ELSE desc_bag := desc_bag + cs [ i ].items [ j ] \ descriptive_representation_item.description;
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 
WHERE
	WR1 :  pass ;
END_RULE; -- curve_style_unique_constraint

RULE subtype_exclusive_measure_with_unit FOR (measure_with_unit);
 
WHERE
	WR1 :  SIZEOF(QUERY(mwu <* measure_with_unit | NOT(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ABSORBED_DOSE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTIVITY_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'AREA_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CAPACITANCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONDUCTANCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOSE_EQUIVALENT_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ELECTRIC_CHARGE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ELECTRIC_CURRENT_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ELECTROMOTIVE_FORCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ENERGY_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FORCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FREQUENCY_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ILLUMINANCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'INDUCTANCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LENGTH_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LUMINOUS_FLUX_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LUMINOUS_INTENSITY_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MAGNETIC_FLUX_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'MASS_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PLANE_ANGLE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POWER_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRESSURE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RATIO_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'RESISTANCE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SOLID_ANGLE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TIME_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'UNCERTAINTY_MEASURE_WITH_UNIT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VOLUME_MEASURE_WITH_UNIT' ] * TYPEOF(mwu))<= 1)))= 0 ;
END_RULE; -- subtype_exclusive_measure_with_unit

FUNCTION acyclic_action_method_relationship
	(relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF action_method_relationship;
 END_LOCAL
;
 IF  relation.relating_method IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD'))| specific_relation IN TYPEOF(am));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_action_method_relationship(x [ i ], relatives + relation.relating_method, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_action_method_relationship

FUNCTION acyclic_action_relationship
	(relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF action_relationship;
 END_LOCAL
;
 IF  relation.relating_action IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION'))| specific_relation IN TYPEOF(actn));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_action_relationship(x [ i ], relatives + relation.relating_action, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_action_relationship

FUNCTION acyclic_action_resource_relationship
	(relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF action_resource_relationship;
 END_LOCAL
;
 IF  relation.relating_resource IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE'))| specific_relation IN TYPEOF(ar));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_action_resource_relationship(x [ i ], relatives + relation.relating_resource, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_action_resource_relationship

FUNCTION acyclic_versioned_action_request_relationship
	(relation : versioned_action_request_relationship; relatives : SET [0:?] OF versioned_action_request; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF versioned_action_request_relationship;
 END_LOCAL
;
 IF  relation.relating_versioned_action_request IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST'))| specific_relation IN TYPEOF(varr));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_versioned_action_request_relationship(x [ i ], relatives + relation.relating_versioned_action_request, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_versioned_action_request_relationship

FUNCTION gbsf_check_curve
	(cv : representation_item) : BOOLEAN;
 IF  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOUNDED_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONIC', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_REPLICA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OFFSET_CURVE_3D' ] * TYPEOF(cv))> 1 THEN  RETURN(FALSE );
 END_IF ;
 IF  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CIRCLE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ELLIPSE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TRIMMED_CURVE' ] * TYPEOF(cv))= 1 THEN  RETURN(TRUE );
 ELSE  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_CURVE' IN  TYPEOF(cv))AND(cv \ b_spline_curve.self_intersect = FALSE)OR(cv \ b_spline_curve.self_intersect = UNKNOWN))THEN  RETURN(TRUE );
 ELSE  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_CURVE' IN  TYPEOF(cv))AND(cv \ composite_curve.self_intersect = FALSE)OR(cv \ composite_curve.self_intersect = UNKNOWN))THEN  RETURN(SIZEOF(QUERY(seg <* cv \ composite_curve.segments | NOT(gbsf_check_curve(seg.parent_curve))))= 0);
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_REPLICA' IN  TYPEOF(cv)THEN  RETURN(gbsf_check_curve(cv \ curve_replica.parent_curve));
 ELSE  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN  TYPEOF(cv))AND((cv \ offset_curve_3d.self_intersect = FALSE)OR(cv \ offset_curve_3d.self_intersect = UNKNOWN))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE' IN  TYPEOF(cv \ offset_curve_3d.basis_curve))))THEN  RETURN(gbsf_check_curve(cv \ offset_curve_3d.basis_curve));
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN  TYPEOF(cv)THEN  RETURN((gbsf_check_curve(cv \ pcurve.reference_to_curve \ representation.items [ 1 ]))AND(gbsf_check_surface(cv \ pcurve.basis_surface)));
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE' IN  TYPEOF(cv)THEN  IF(SIZEOF(cv \ polyline.points)>= 3)THEN  RETURN(TRUE );
 END_IF ;
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(cv)THEN  IF  gbsf_check_curve(cv \ surface_curve.curve_3d)THEN  REPEAT i := 1 TO SIZEOF(cv \ surface_curve.associated_geometry);
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE' IN  TYPEOF(cv \ surface_curve.associated_geometry [ i ])THEN  IF  NOT  gbsf_check_surface(cv \ surface_curve.associated_geometry [ i ])THEN  RETURN(FALSE );
 END_IF ;
 ELSE IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(cv \ surface_curve.associated_geometry [ i ])THEN  IF NOT gbsf_check_curve(cv \ surface_curve.associated_geometry [ i ])THEN RETURN(FALSE );
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT;
 RETURN(TRUE);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- gbsf_check_curve

FUNCTION gbsf_check_point
	(pnt : point) : BOOLEAN;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(pnt)THEN  RETURN(TRUE);
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_CURVE' IN  TYPEOF(pnt)THEN  RETURN(gbsf_check_curve(pnt \ point_on_curve.basis_curve));
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_ON_SURFACE' IN  TYPEOF(pnt)THEN  RETURN(gbsf_check_surface(pnt \ point_on_surface.basis_surface));
 ELSE IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(pnt)THEN RETURN((gbsf_check_curve(pnt \ degenerate_pcurve.reference_to_curve \ representation.items [ 1 ]))AND(gbsf_check_surface(pnt \ degenerate_pcurve.basis_surface)));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- gbsf_check_point

FUNCTION gbsf_check_surface
	(sf : surface) : BOOLEAN;
 IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN  TYPEOF(sf))AND(sf \ b_spline_surface.self_intersect = FALSE)OR(sf \ b_spline_surface.self_intersect = UNKNOWN))THEN  RETURN(TRUE );
 ELSE  IF  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SPHERICAL_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TOROIDAL_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_BOUNDED_SURFACE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' ] * TYPEOF(sf))= 1 THEN  RETURN(TRUE );
 ELSE  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OFFSET_SURFACE' IN  TYPEOF(sf))AND(sf \ offset_surface.self_intersect = FALSE)OR(sf \ offset_surface.self_intersect = UNKNOWN))THEN  RETURN(gbsf_check_surface(sf \ offset_surface.basis_surface));
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.RECTANGULAR_COMPOSITE_SURFACE' IN  TYPEOF(sf)THEN  REPEAT  i := 1 TO  SIZEOF(sf \ rectangular_composite_surface.segments);
 REPEAT j := 1 TO SIZEOF(sf \ rectangular_composite_surface.segments [ i ]);
 IF  NOT(gbsf_check_surface(sf \ rectangular_composite_surface.segments [ i ] [ j ].parent_surface))THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_REPEAT;
 RETURN(TRUE);
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_REPLICA' IN  TYPEOF(sf)THEN  RETURN(gbsf_check_surface(sf \ surface_replica.parent_surface));
 ELSE IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(sf)THEN RETURN(gbsf_check_curve(sf \ swept_surface.swept_curve));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- gbsf_check_surface

FUNCTION advanced_face_properties
	(testface : face) : BOOLEAN;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ADVANCED_FACE' IN  TYPEOF(testface)THEN  RETURN(TRUE);
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBFACE' IN TYPEOF(testface))THEN RETURN(advanced_face_properties(testface.parent_face));
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- advanced_face_properties

FUNCTION msf_curve_check
	(cv : representation_item) : BOOLEAN;
 IF  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOUNDED_CURVE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONIC', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_REPLICA', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OFFSET_CURVE_3D' ] * TYPEOF(cv))> 1 THEN  RETURN(FALSE );
 END_IF ;
 IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_CURVE' IN  TYPEOF(cv))AND(cv \ b_spline_curve.self_intersect = FALSE)OR(cv \ b_spline_curve.self_intersect = UNKNOWN))THEN  RETURN(TRUE );
 ELSE  IF  SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONIC', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LINE' ] * TYPEOF(cv))= 1 THEN  RETURN(TRUE );
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_REPLICA' IN  TYPEOF(cv)THEN  RETURN(msf_curve_check(cv \ curve_replica.parent_curve));
 ELSE  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OFFSET_CURVE_3D' IN  TYPEOF(cv))AND((cv \ offset_curve_3d.self_intersect = FALSE)OR(cv \ offset_curve_3d.self_intersect = UNKNOWN))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE' IN  TYPEOF(cv \ offset_curve_3d.basis_curve))))THEN  RETURN(msf_curve_check(cv \ offset_curve_3d.basis_curve));
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN  TYPEOF(cv)THEN  RETURN((msf_curve_check(cv \ pcurve.reference_to_curve \ representation.items [ 1 ]))AND(msf_surface_check(cv \ pcurve.basis_surface)));
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(cv)THEN  IF  msf_curve_check(cv \ surface_curve.curve_3d)THEN  REPEAT i := 1 TO SIZEOF(cv \ surface_curve.associated_geometry);
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE' IN  TYPEOF(cv \ surface_curve.associated_geometry [ i ])THEN  IF  NOT  msf_surface_check(cv \ surface_curve.associated_geometry [ i ])THEN  RETURN(FALSE );
 END_IF ;
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN  TYPEOF(cv \ surface_curve.associated_geometry [ i ])THEN  IF  NOT msf_curve_check(cv \ surface_curve.associated_geometry [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 END_IF ;
 END_REPEAT;
 RETURN(TRUE );
 END_IF ;
 ELSE IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLYLINE' IN TYPEOF(cv)THEN  IF(SIZEOF(cv \ polyline.points)>= 3)THEN RETURN(TRUE);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- msf_curve_check

FUNCTION msf_surface_check
	(surf : surface) : BOOLEAN;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ELEMENTARY_SURFACE' IN  TYPEOF(surf)THEN  RETURN(TRUE );
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SWEPT_SURFACE' IN  TYPEOF(surf)THEN  RETURN(msf_curve_check(surf \ swept_surface.swept_curve));
 ELSE  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OFFSET_SURFACE' IN  TYPEOF(surf))AND(surf \ offset_surface.self_intersect = FALSE)OR(surf \ offset_surface.self_intersect = UNKNOWN))THEN  RETURN(msf_surface_check(surf \ offset_surface.basis_surface));
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_REPLICA' IN  TYPEOF(surf)THEN  RETURN(msf_surface_check(surf \ surface_replica.parent_surface));
 ELSE IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN TYPEOF(surf))AND(surf \ b_spline_surface.self_intersect = FALSE)OR(surf \ b_spline_surface.self_intersect = UNKNOWN))THEN RETURN(TRUE);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- msf_surface_check

FUNCTION valid_2d_wireframe_edge_curve
	(crv : curve; schma : STRING) : BOOLEAN;
 IF  SIZEOF([ schma + '.LINE', schma + '.B_SPLINE_CURVE', schma + '.CIRCLE', schma + '.HYPERBOLA', schma + '.ELLIPSE', schma + '.PARABOLA', schma + '.POLYLINE' ] * TYPEOF(crv))= 1 THEN  RETURN(TRUE);
 ELSE  IF(schma + '.CURVE_REPLICA')IN  TYPEOF(crv)THEN  RETURN(valid_2d_wireframe_edge_curve(crv \ curve_replica.parent_curve, schma));
 ELSE IF(schma + '.OFFSET_CURVE_2D')IN TYPEOF(crv)THEN RETURN(valid_2d_wireframe_edge_curve(crv \ offset_curve_2d.basis_curve, schma));
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- valid_2d_wireframe_edge_curve

FUNCTION acyclic_approval_relationship
	(relation : approval_relationship; relatives : SET [1:?] OF approval; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF approval_relationship;
 END_LOCAL
;
 IF  relation.relating_approval IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL'))| specific_relation IN TYPEOF(app));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_approval_relationship(x [ i ], relatives + relation.relating_approval, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_approval_relationship

FUNCTION get_description_value
	(obj : description_attribute_select) : text;
 LOCAL
 description_bag : BAG OF description_attribute :=(USEDIN(obj, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
 END_LOCAL
;
 IF SIZEOF(description_bag)= 1 THEN RETURN(description_bag [ 1 ].attribute_value);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_description_value

FUNCTION get_id_value
	(obj : id_attribute_select) : identifier;
 LOCAL
 id_bag : BAG OF id_attribute :=(USEDIN(obj, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
 END_LOCAL
;
 IF SIZEOF(id_bag)= 1 THEN RETURN(id_bag [ 1 ].attribute_value);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_id_value

FUNCTION get_name_value
	(obj : name_attribute_select) : label;
 LOCAL
 name_bag : BAG OF name_attribute :=(USEDIN(obj, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
 END_LOCAL
;
 IF SIZEOF(name_bag)= 1 THEN RETURN(name_bag [ 1 ].attribute_value);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_name_value

FUNCTION get_role
	(obj : role_select) : object_role;
 LOCAL
 role_bag : BAG OF role_association :=(USEDIN(obj, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
 END_LOCAL
;
 IF SIZEOF(role_bag)= 1 THEN RETURN(role_bag [ 1 ].role);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- get_role

FUNCTION class_assignment_is_valid
	(aia : applied_classification_assignment) : BOOLEAN;
 LOCAL
 item : classification_item;
 role : classification_role;
 END_LOCAL
;
 role := aia.role;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CLASS_SYSTEM' IN  TYPEOF(aia.assigned_class))THEN  IF(role.name <> 'class system membership')THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := LOINDEX(aia.items)TO  HIINDEX(aia.items);
 item := aia.items [ i ];
 IF(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CLASS_SYSTEM_ITEM' ] * TYPEOF(item))= 0)THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHARACTERIZED_CLASS' IN  TYPEOF(aia.assigned_class))THEN  IF  NOT(role.name IN [ 'definitional', 'non-definitional', '' ])THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := LOINDEX(aia.items)TO HIINDEX(aia.items);
 item := aia.items [ i ];
 IF(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CLASSIFIED_ITEM' ] * TYPEOF(item))= 0)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- class_assignment_is_valid

FUNCTION acyclic_contract_relationship
	(relation : contract_relationship; relatives : SET [1:?] OF contract; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF contract_relationship;
 END_LOCAL
;
 IF  relation.relating_contract IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT'))| specific_relation IN TYPEOF(cont));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_contract_relationship(x [ i ], relatives + relation.relating_contract, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_contract_relationship

FUNCTION acyclic_event_occurrence_relationship
	(relation : event_occurrence_relationship; relatives : SET [1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF event_occurrence_relationship;
 END_LOCAL
;
 IF  relation.relating_event IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT'))| specific_relation IN TYPEOF(evnt));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_event_occurrence_relationship(x [ i ], relatives + relation.relating_event, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_event_occurrence_relationship

FUNCTION acyclic_time_interval_relationship
	(relation : time_interval_relationship; relatives : SET [1:?] OF time_interval; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF time_interval_relationship;
 END_LOCAL
;
 IF  relation.relating_time_interval IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL'))| specific_relation IN TYPEOF(ti));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_time_interval_relationship(x [ i ], relatives + relation.relating_time_interval, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_time_interval_relationship

FUNCTION leap_year
	(year : year_number) : BOOLEAN;
 IF((((year MOD  4)= 0)AND((year MOD  100)<> 0))OR((year MOD 400)= 0))THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- leap_year

FUNCTION valid_calendar_date
	(date : calendar_date) : LOGICAL;
 CASE date.month_component OF 1 : RETURN({ 1 <= date.day_component <= 31 });
 2 : BEGIN IF(leap_year(date.year_component))THEN RETURN({ 1 <= date.day_component <= 29 });
 ELSE RETURN({ 1 <= date.day_component <= 28 });
 END_IF;
 END;
 3 : RETURN({ 1 <= date.day_component <= 31 });
 4 : RETURN({ 1 <= date.day_component <= 30 });
 5 : RETURN({ 1 <= date.day_component <= 31 });
 6 : RETURN({ 1 <= date.day_component <= 30 });
 7 : RETURN({ 1 <= date.day_component <= 31 });
 8 : RETURN({ 1 <= date.day_component <= 31 });
 9 : RETURN({ 1 <= date.day_component <= 30 });
 10 : RETURN({ 1 <= date.day_component <= 31 });
 11 : RETURN({ 1 <= date.day_component <= 30 });
 12 : RETURN({ 1 <= date.day_component <= 31 });
 END_CASE;
 RETURN(FALSE);
 END_FUNCTION; -- valid_calendar_date

FUNCTION valid_time
	(time : local_time) : BOOLEAN;
 IF EXISTS(time.second_component)THEN RETURN(EXISTS(time.minute_component));
 ELSE RETURN(TRUE);
 END_IF;
 END_FUNCTION; -- valid_time

FUNCTION acyclic_document_relationship
	(relation : document_relationship; relatives : SET [1:?] OF document; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF document_relationship;
 END_LOCAL
;
 IF  relation.relating_document IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT'))| specific_relation IN TYPEOF(doc));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_document_relationship(x [ i ], relatives + relation.relating_document, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_document_relationship

FUNCTION acyclic_effectivity_relationship
	(relation : effectivity_relationship; relatives : SET [1:?] OF effectivity; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF effectivity_relationship;
 END_LOCAL
;
 IF  relation.relating_effectivity IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY'))| specific_relation IN TYPEOF(eff));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_effectivity_relationship(x [ i ], relatives + relation.relating_effectivity, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_effectivity_relationship

FUNCTION acyclic_experience_relationship
	(relation : experience_relationship; relatives : SET [0:?] OF experience; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF experience_relationship;
 END_LOCAL
;
 IF  relation.relating_experience IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE'))| specific_relation IN TYPEOF(expr));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_experience_relationship(x [ i ], relatives + relation.relating_experience, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_experience_relationship

FUNCTION acyclic_experience_type_relationship
	(relation : experience_type_relationship; relatives : SET [0:?] OF experience_type; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF experience_type_relationship;
 END_LOCAL
;
 IF  relation.relating_experience_type IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE'))| specific_relation IN TYPEOF(exptyp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_experience_type_relationship(x [ i ], relatives + relation.relating_experience_type, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_experience_type_relationship

FUNCTION value_range_wr1
	(agg : compound_item_definition) : BOOLEAN;
 BEGIN IF(SIZEOF(agg)= 2)AND((SIZEOF(QUERY(i1 <* agg |('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i1))))= 2)OR(SIZEOF(QUERY(i2 <* agg |('REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF(i2))))= 2))THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END;
 END_FUNCTION; -- value_range_wr1

FUNCTION value_range_wr2
	(agg : compound_item_definition) : BOOLEAN;
 BEGIN IF(SIZEOF(QUERY(i <* agg |(i.name = 'upper limit')))= 1)AND(SIZEOF(QUERY(i <* agg |(i.name = 'lower limit')))= 1)THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END;
 END_FUNCTION; -- value_range_wr2

FUNCTION value_range_wr3
	(agg : compound_item_definition) : BOOLEAN;
 BEGIN IF(SIZEOF(QUERY(i1 <* agg |('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i1))AND(SIZEOF(QUERY(i2 <* agg |('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i2))AND(i1 :<>: i2)AND(i1 \ measure_with_unit.unit_component :=: i2 \ measure_with_unit.unit_component)))= 1)))= 2)THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END;
 END_FUNCTION; -- value_range_wr3

FUNCTION acyclic_external_source_relationship
	(relation : external_source_relationship; relatives : SET [1:?] OF external_source; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF external_source_relationship;
 END_LOCAL
;
 IF  relation.relating_source IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE'))| specific_relation IN TYPEOF(es));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_external_source_relationship(x [ i ], relatives + relation.relating_source, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_external_source_relationship

FUNCTION acyclic_externally_defined_item_relationship
	(relation : externally_defined_item_relationship; relatives : SET [1:?] OF externally_defined_item; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF externally_defined_item_relationship;
 END_LOCAL
;
 IF  relation.relating_item IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM'))| specific_relation IN TYPEOF(edi));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_externally_defined_item_relationship(x [ i ], relatives + relation.relating_item, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_externally_defined_item_relationship

FUNCTION acyclic_set_replica
	(rep : geometric_set_replica; parent : geometric_set) : BOOLEAN;
 IF  NOT(('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_set_replica(rep, parent \ geometric_set_replica.parent_set));
 END_IF;
 END_FUNCTION; -- acyclic_set_replica

FUNCTION acyclic_solid_replica
	(rep : solid_replica; parent : solid_model) : BOOLEAN;
 IF  NOT(('GEOMETRY_SCHEMA.SOLID_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_solid_replica(rep, parent \ solid_replica.parent_solid));
 END_IF;
 END_FUNCTION; -- acyclic_solid_replica

FUNCTION build_transformed_set
	(tr : cartesian_transformation_operator; gset : geometric_set) : SET [0:?] OF geometric_set_select;
 LOCAL
 s : SET  [ 1 : ? ] OF  geometric_set_select := gset.elements;
 trset : SET [ 0 : ? ] OF geometric_set_select := [ ];
 END_LOCAL
;
 REPEAT j := 1 TO SIZEOF(s);
 IF('GEOMETRY_SCHEMA.CURVE' IN  TYPEOF(s [ j ]))THEN  trset := trset + dummy_gri || curve()|| curve_replica(s [ j ], tr);
 ELSE  IF('GEOMETRY_SCHEMA.POINT' IN  TYPEOF(s [ j ]))THEN  trset := trset + dummy_gri || point()|| point_replica(s [ j ], tr);
 ELSE IF('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s [ j ]))THEN trset := trset + dummy_gri || surface()|| surface_replica(s [ j ], tr || cartesian_transformation_operator_3d(?));
 END_IF ;
 END_IF ;
 END_IF;
 END_REPEAT;
 RETURN(trset);
 END_FUNCTION; -- build_transformed_set

FUNCTION constraints_geometry_shell_based_surface_model
	(m : shell_based_surface_model) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
 IF(NOT('TOPOLOGY_SCHEMA.OPEN_SHELL' IN  TYPEOF(m.sbsm_boundary [ j ]))AND(NOT('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(m.sbsm_boundary [ j ]))))THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- constraints_geometry_shell_based_surface_model

FUNCTION constraints_geometry_shell_based_wireframe_model
	(m : shell_based_wireframe_model) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
 IF(NOT('TOPOLOGY_SCHEMA.WIRE_SHELL' IN  TYPEOF(m.sbwm_boundary [ j ]))AND(NOT('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(m.sbwm_boundary [ j ]))))THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

FUNCTION msb_shells
	(brep : manifold_solid_brep) : SET [1:?] OF closed_shell;
 IF SIZEOF(QUERY(msbtype <* TYPEOF(brep)| msbtype LIKE '*BREP_WITH_VOIDS'))>= 1 THEN RETURN(brep \ brep_with_voids.voids + brep.outer);
 ELSE RETURN([ brep.outer ]);
 END_IF;
 END_FUNCTION; -- msb_shells

FUNCTION get_shape_aspect_property_definition_representations
	(s_a_instance : shape_aspect) : SET [0:?] OF property_definition_representation;
 LOCAL
 pd_set : SET  OF  property_definition := [ ];
 pdr_set : SET OF property_definition_representation := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(USEDIN(s_a_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set +(QUERY(pdr <* USEDIN(pd_set [ i ], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION')| 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_shape_aspect_property_definition_representations

FUNCTION valid_datum_target_parameters
	(pdf : placed_datum_target_feature) : BOOLEAN;
 LOCAL
 rep_set : SET  OF  representation := [ ];
 parameter_representations : SET OF  representation;
 END_LOCAL
;
 REPEAT i := 1 TO HIINDEX(pdf.representation_associations);
 rep_set := rep_set + pdf.representation_associations [ i ].used_representation;
 END_REPEAT;
 parameter_representations := QUERY(rep <* rep_set |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN  TYPEOF(rep)));
 IF(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'orientation')AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLACEMENT' IN TYPEOF(i))))= 1)))<> 1)THEN RETURN(FALSE );
 END_IF;
 CASE pdf \ shape_aspect.description OF 'point' : RETURN(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(srwp.items)= 1)))= 1);
 'circle' : RETURN((SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(srwp.items)= 2)))= 1)AND(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target diameter')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1));
 'line' : RETURN(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target length')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1);
 'rectangle' : RETURN((SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(srwp.items)= 3)))= 1)AND(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target length')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1)AND(SIZEOF(QUERY(srwp <* parameter_representations |(SIZEOF(QUERY(i <* srwp.items |(i.name = 'target width')AND(SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE_WITH_UNIT' ] * TYPEOF(i))= 2)))= 1)))= 1));
 OTHERWISE : RETURN(FALSE);
 END_CASE;
 END_FUNCTION; -- valid_datum_target_parameters

FUNCTION above_plane
	(p1 : cartesian_point; p2 : cartesian_point; p3 : cartesian_point; p4 : cartesian_point) : REAL;
 LOCAL
 dir2, dir3, dir4 : direction := dummy_gri || direction([ 1.0, 0.0, 0.0 ]);
 val, mag : REAL;
 END_LOCAL
;
 IF(p1.dim <> 3)THEN RETURN(?);
 END_IF;
 REPEAT i := 1 TO 3;
 dir2.direction_ratios [ i ] := p2.coordinates [ i ] - p1.coordinates [ i ];
 dir3.direction_ratios [ i ] := p3.coordinates [ i ] - p1.coordinates [ i ];
 dir4.direction_ratios [ i ] := p4.coordinates [ i ] - p1.coordinates [ i ];
 mag := dir4.direction_ratios [ i ] * dir4.direction_ratios [ i ];
 END_REPEAT;
 mag := SQRT(mag);
 val := mag * dot_product(dir4, cross_product(dir2, dir3).orientation);
 RETURN(val);
 END_FUNCTION; -- above_plane

FUNCTION acyclic_curve_replica
	(rep : curve_replica; parent : curve) : BOOLEAN;
 IF  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CURVE_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_curve_replica(rep, parent \ curve_replica.parent_curve));
 END_IF;
 END_FUNCTION; -- acyclic_curve_replica

FUNCTION acyclic_point_replica
	(rep : point_replica; parent : point) : BOOLEAN;
 IF  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POINT_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_point_replica(rep, parent \ point_replica.parent_pt));
 END_IF;
 END_FUNCTION; -- acyclic_point_replica

FUNCTION acyclic_surface_replica
	(rep : surface_replica; parent : surface) : BOOLEAN;
 IF  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_REPLICA')IN TYPEOF(parent))THEN  RETURN(TRUE);
 END_IF ;
 IF(parent :=: rep)THEN RETURN(FALSE);
 ELSE RETURN(acyclic_surface_replica(rep, parent \ surface_replica.parent_surface));
 END_IF;
 END_FUNCTION; -- acyclic_surface_replica

FUNCTION associated_surface
	(arg : pcurve_or_surface) : surface;
 LOCAL
 surf : surface;
 END_LOCAL
;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN TYPEOF(arg)THEN surf := arg.basis_surface;
 ELSE surf := arg;
 END_IF;
 RETURN(surf);
 END_FUNCTION; -- associated_surface

FUNCTION base_axis
	(dim : INTEGER; axis1 : direction; axis2 : direction; axis3 : direction) : LIST [2:3] OF direction;
 LOCAL
 u : LIST [ 2 : 3 ] OF direction;
 factor : REAL;
 d1, d2 : direction;
 END_LOCAL
;
 IF(dim = 3)THEN  d1 := NVL(normalise(axis3), dummy_gri || direction([ 0.0, 0.0, 1.0 ]));
 d2 := first_proj_axis(d1, axis1);
 u := [ d2, second_proj_axis(d1, d2, axis2), d1 ];
 ELSE  IF  EXISTS(axis1)THEN  d1 := normalise(axis1);
 u := [ d1, orthogonal_complement(d1)];
 IF  EXISTS(axis2)THEN  factor := dot_product(axis2, u [ 2 ]);
 IF(factor < 0.0)THEN  u [ 2 ].direction_ratios [ 1 ] := - u [ 2 ].direction_ratios [ 1 ];
 u [ 2 ].direction_ratios [ 2 ] := - u [ 2 ].direction_ratios [ 2 ];
 END_IF ;
 END_IF ;
 ELSE  IF EXISTS(axis2)THEN d1 := normalise(axis2);
 u := [ orthogonal_complement(d1), d1 ];
 u [ 1 ].direction_ratios [ 1 ] := - u [ 1 ].direction_ratios [ 1 ];
 u [ 1 ].direction_ratios [ 2 ] := - u [ 1 ].direction_ratios [ 2 ];
 ELSE u := [ dummy_gri || direction([ 1.0, 0.0 ]), dummy_gri || direction([ 0.0, 1.0 ])];
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(u);
 END_FUNCTION; -- base_axis

FUNCTION build_2axes
	(ref_direction : direction) : LIST [2:2] OF direction;
 LOCAL
 d : direction := NVL(normalise(ref_direction), dummy_gri || direction([ 1.0, 0.0 ]));
 END_LOCAL
;
 RETURN([ d, orthogonal_complement(d)]);
 END_FUNCTION; -- build_2axes

FUNCTION build_axes
	(axis : direction; ref_direction : direction) : LIST [3:3] OF direction;
 LOCAL
 d1, d2 : direction;
 END_LOCAL
;
 d1 := NVL(normalise(axis), dummy_gri || direction([ 0.0, 0.0, 1.0 ]));
 d2 := first_proj_axis(d1, ref_direction);
 RETURN([ d2, normalise(cross_product(d1, d2)).orientation, d1 ]);
 END_FUNCTION; -- build_axes

FUNCTION constraints_composite_curve_on_surface
	(c : composite_curve_on_surface) : BOOLEAN;
 LOCAL
 n_segments : INTEGER := SIZEOF(c.segments);
 END_LOCAL
;
 REPEAT k := 1 TO n_segments;
 IF(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN  TYPEOF(c \ composite_curve.segments [ k ].parent_curve)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(c \ composite_curve.segments [ k ].parent_curve)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c \ composite_curve.segments [ k ].parent_curve)))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- constraints_composite_curve_on_surface

FUNCTION constraints_param_b_spline
	(degree : INTEGER; up_knots : INTEGER; up_cp : INTEGER; knot_mult : LIST [0:?] OF INTEGER; knots : LIST [0:?] OF parameter_value) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 k, sum : INTEGER;
 END_LOCAL
;
 sum := knot_mult [ 1 ];
 REPEAT  i := 2 TO  up_knots;
 sum := sum + knot_mult [ i ];
 END_REPEAT ;
 IF(degree < 1)OR(up_knots < 2)OR(up_cp < degree)OR(sum <>(degree + up_cp + 2))THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 k := knot_mult [ 1 ];
 IF(k < 1)OR(k > degree + 1)THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 REPEAT i := 2 TO up_knots;
 IF(knot_mult [ i ] < 1)OR(knots [ i ] <= knots [ i - 1 ])THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 k := knot_mult [ i ];
 IF(i < up_knots)AND(k > degree)THEN  result := FALSE ;
 RETURN(result);
 END_IF ;
 IF(i = up_knots)AND(k > degree + 1)THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- constraints_param_b_spline

FUNCTION constraints_rectangular_composite_surface
	(s : rectangular_composite_surface) : BOOLEAN;
 REPEAT  i := 1 TO  s.n_u;
 REPEAT  j := 1 TO  s.n_v;
 IF  NOT(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.B_SPLINE_SURFACE' IN  TYPEOF(s.segments [ i ] [ j ].parent_surface))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF(s.segments [ i ] [ j ].parent_surface)))THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  s.n_u - 1;
 REPEAT  j := 1 TO  s.n_v;
 IF  s.segments [ i ] [ j ].u_transition = discontinuous THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_REPEAT ;
 REPEAT  i := 1 TO  s.n_u;
 REPEAT j := 1 TO s.n_v - 1;
 IF s.segments [ i ] [ j ].v_transition = discontinuous THEN RETURN(FALSE);
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- constraints_rectangular_composite_surface

FUNCTION cross_product
	(arg1 : direction; arg2 : direction) : vector;
 LOCAL
 mag : REAL ;
 res : direction;
 v1, v2 : LIST [ 3 : 3 ] OF REAL;
 result : vector;
 END_LOCAL
;
 IF(NOT  EXISTS(arg1)OR(arg1.dim = 2))OR(NOT EXISTS(arg2)OR(arg2.dim = 2))THEN  RETURN(?);
 ELSE  BEGIN v1 := normalise(arg1).direction_ratios;
 v2 := normalise(arg2).direction_ratios;
 res := dummy_gri || direction([(v1 [ 2 ] * v2 [ 3 ] - v1 [ 3 ] * v2 [ 2 ]),(v1 [ 3 ] * v2 [ 1 ] - v1 [ 1 ] * v2 [ 3 ]),(v1 [ 1 ] * v2 [ 2 ] - v1 [ 2 ] * v2 [ 1 ])]);
 mag := 0.0;
 REPEAT i := 1 TO 3;
 mag := mag + res.direction_ratios [ i ] * res.direction_ratios [ i ];
 END_REPEAT;
 IF(mag > 0.0)THEN result := dummy_gri || vector(res, SQRT(mag));
 ELSE result := dummy_gri || vector(arg1, 0.0);
 END_IF ;
 RETURN(result);
 END;
 END_IF;
 END_FUNCTION; -- cross_product

FUNCTION curve_weights_positive
	(b : rational_b_spline_curve) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT i := 0 TO b.upper_index_on_control_points;
 IF b.weights [ i ] <= 0.0 THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- curve_weights_positive

FUNCTION default_b_spline_curve_weights
	(up_cp : INTEGER) : ARRAY [0:??] OF REAL;
 RETURN([ 1 : up_cp + 1 ]);
 END_FUNCTION; -- default_b_spline_curve_weights

FUNCTION default_b_spline_knot_mult
	(degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST [2:?] OF INTEGER;
 LOCAL
 knot_mult : LIST [ 1 : up_knots ] OF INTEGER;
 END_LOCAL
;
 IF  uniform = uniform_knots THEN  knot_mult := [ 1 : up_knots ];
 ELSE  IF  uniform = quasi_uniform_knots THEN  knot_mult := [ 1 : up_knots ];
 knot_mult [ 1 ] := degree + 1;
 knot_mult [ up_knots ] := degree + 1;
 ELSE  IF uniform = piecewise_bezier_knots THEN knot_mult := [ degree : up_knots ];
 knot_mult [ 1 ] := degree + 1;
 knot_mult [ up_knots ] := degree + 1;
 ELSE knot_mult := [ 0 : up_knots ];
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(knot_mult);
 END_FUNCTION; -- default_b_spline_knot_mult

FUNCTION default_b_spline_knots
	(degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST [2:?] OF parameter_value;
 LOCAL
 knots : LIST [ 1 : up_knots ] OF parameter_value := [ 0 : up_knots ];
 ishift : INTEGER := 1;
 END_LOCAL
;
 IF(uniform = uniform_knots)THEN  ishift := degree + 1;
 END_IF ;
 IF(uniform = uniform_knots)OR(uniform = quasi_uniform_knots)OR(uniform = piecewise_bezier_knots)THEN REPEAT i := 1 TO up_knots;
 knots [ i ] := i - ishift;
 END_REPEAT;
 END_IF;
 RETURN(knots);
 END_FUNCTION; -- default_b_spline_knots

FUNCTION default_b_spline_surface_weights
	(u_upper : INTEGER; v_upper : INTEGER) : ARRAY [0:??] OF ARRAY [0:??] OF REAL;
 RETURN([ [ 1 : v_upper + 1 ] : u_upper + 1 ]);
 END_FUNCTION; -- default_b_spline_surface_weights

FUNCTION dimension_of
	(item : geometric_representation_item) : dimension_count;
 LOCAL
 x : SET OF representation;
 y : representation_context;
 dim : dimension_count;
 END_LOCAL
;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(item)THEN  dim := SIZEOF(item \ cartesian_point.coordinates);
 RETURN(dim);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DIRECTION' IN  TYPEOF(item)THEN  dim := SIZEOF(item \ direction.direction_ratios);
 RETURN(dim);
 END_IF ;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN TYPEOF(item)THEN dim := SIZEOF(item \ vector.orientation \ direction.direction_ratios);
 RETURN(dim);
 END_IF;
 x := using_representations(item);
 y := x [ 1 ].context_of_items;
 dim := y \ geometric_representation_context.coordinate_space_dimension;
 RETURN(dim);
 END_FUNCTION; -- dimension_of

FUNCTION dot_product
	(arg1 : direction; arg2 : direction) : REAL;
 LOCAL
 scalar : REAL;
 vec1, vec2 : direction;
 ndim : INTEGER;
 END_LOCAL
;
 IF  NOT  EXISTS(arg1)OR NOT EXISTS(arg2)THEN  scalar := ?;
 ELSE  IF(arg1.dim <> arg2.dim)THEN scalar := ?;
 ELSE BEGIN vec1 := normalise(arg1);
 vec2 := normalise(arg2);
 ndim := arg1.dim;
 scalar := 0.0;
 REPEAT i := 1 TO ndim;
 scalar := scalar + vec1.direction_ratios [ i ] * vec2.direction_ratios [ i ];
 END_REPEAT;
 END;
 END_IF ;
 END_IF;
 RETURN(scalar);
 END_FUNCTION; -- dot_product

FUNCTION first_proj_axis
	(z_axis : direction; arg : direction) : direction;
 LOCAL
 x_axis : direction;
 v : direction;
 z : direction;
 x_vec : vector;
 END_LOCAL
;
 IF(NOT  EXISTS(z_axis))THEN  RETURN(?);
 ELSE  z := normalise(z_axis);
 IF  NOT EXISTS(arg)THEN  IF((z.direction_ratios <> [ 1.0, 0.0, 0.0 ])AND(z.direction_ratios <> [ - 1.0, 0.0, 0.0 ]))THEN  v := dummy_gri || direction([ 1.0, 0.0, 0.0 ]);
 ELSE  v := dummy_gri || direction([ 0.0, 1.0, 0.0 ]);
 END_IF ;
 ELSE  IF(arg.dim <> 3)THEN  RETURN(?);
 END_IF ;
 IF((cross_product(arg, z).magnitude)= 0.0)THEN RETURN(?);
 ELSE v := normalise(arg);
 END_IF ;
 END_IF ;
 x_vec := scalar_times_vector(dot_product(v, z), z);
 x_axis := vector_difference(v, x_vec).orientation;
 x_axis := normalise(x_axis);
 END_IF;
 RETURN(x_axis);
 END_FUNCTION; -- first_proj_axis

FUNCTION get_basis_surface
	(c : curve_on_surface) : SET [0:2] OF surface;
 LOCAL
 surfs : SET [ 0 : 2 ] OF surface;
 n : INTEGER;
 END_LOCAL
;
 surfs := [ ];
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PCURVE' IN  TYPEOF(c)THEN  surfs := [ c \ pcurve.basis_surface ];
 ELSE IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SURFACE_CURVE' IN  TYPEOF(c)THEN  n := SIZEOF(c \ surface_curve.associated_geometry);
 REPEAT  i := 1 TO  n;
 surfs := surfs + associated_surface(c \ surface_curve.associated_geometry [ i ]);
 END_REPEAT ;
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)THEN  n := SIZEOF(c \ composite_curve.segments);
 surfs := get_basis_surface(c \ composite_curve.segments [ 1 ].parent_curve);
 IF n > 1 THEN REPEAT i := 2 TO n;
 surfs := surfs * get_basis_surface(c \ composite_curve.segments [ i ].parent_curve);
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(surfs);
 END_FUNCTION; -- get_basis_surface

FUNCTION list_to_array
	(lis : LIST [0:?] OF GENERIC; low : INTEGER; u : INTEGER) : ARRAY [??:??] OF GENERIC;
 LOCAL
 n : INTEGER;
 res : ARRAY [ low : u ] OF GENERIC : T;
 END_LOCAL
;
 n := SIZEOF(lis);
 IF(n <>(u - low + 1))THEN RETURN(?);
 ELSE res := [ lis [ 1 ] : n ];
 REPEAT i := 2 TO n;
 res [ low + i - 1 ] := lis [ i ];
 END_REPEAT;
 RETURN(res);
 END_IF;
 END_FUNCTION; -- list_to_array

FUNCTION make_array_of_array
	(lis : LIST [1:?] OF LIST [1:?] OF GENERIC; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER) : ARRAY [??:??] OF ARRAY [??:??] OF GENERIC;
 LOCAL
 res : ARRAY  [ low1 : u1 ] OF  ARRAY [ low2 : u2 ] OF GENERIC : T;
 END_LOCAL
;
 IF(u1 - low1 + 1)<> SIZEOF(lis)THEN  RETURN(?);
 END_IF ;
 IF(u2 - low2 + 1)<> SIZEOF(lis [ 1 ])THEN  RETURN(?);
 END_IF ;
 res := [ list_to_array(lis [ 1 ], low2, u2):(u1 - low1 + 1)];
 REPEAT i := 2 TO HIINDEX(lis);
 IF(u2 - low2 + 1)<> SIZEOF(lis [ i ])THEN RETURN(?);
 END_IF;
 res [ low1 + i - 1 ] := list_to_array(lis [ i ], low2, u2);
 END_REPEAT;
 RETURN(res);
 END_FUNCTION; -- make_array_of_array

FUNCTION make_array_of_array_of_array
	(lis : LIST [1:?] OF LIST [1:?] OF LIST [1:?] OF GENERIC; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER; low3 : INTEGER; u3 : INTEGER) : ARRAY [??:??] OF ARRAY [??:??] OF ARRAY [??:??] OF GENERIC;
 LOCAL
 res : ARRAY  [ low1 : u1 ] OF  ARRAY  [ low2 : u2 ] OF  ARRAY [ low3 : u3 ] OF GENERIC : T;
 END_LOCAL
;
 IF(u1 - low1 + 1)<> SIZEOF(lis)THEN  RETURN(?);
 END_IF ;
 IF(u2 - low2 + 1)<> SIZEOF(lis [ 1 ])THEN  RETURN(?);
 END_IF ;
 res := [ make_array_of_array(lis [ 1 ], low2, u2, low3, u3):(u1 - low1 + 1)];
 REPEAT i := 2 TO HIINDEX(lis);
 IF(u2 - low2 + 1)<> SIZEOF(lis [ i ])THEN RETURN(?);
 END_IF;
 res [ low1 + i - 1 ] := make_array_of_array(lis [ i ], low2, u2, low3, u3);
 END_REPEAT;
 RETURN(res);
 END_FUNCTION; -- make_array_of_array_of_array

FUNCTION normalise
	(arg : vector_or_direction) : vector_or_direction;
 LOCAL
 ndim : INTEGER;
 v : direction;
 result : vector_or_direction;
 vec : vector;
 mag : REAL;
 END_LOCAL
;
 IF  NOT EXISTS(arg)THEN  result := ?;
 ELSE  ndim := arg.dim;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN  TYPEOF(arg)THEN  BEGIN v := dummy_gri || direction(arg.orientation.direction_ratios);
 IF  arg.magnitude = 0.0 THEN  RETURN(?);
 ELSE  vec := dummy_gri || vector(v, 1.0);
 END_IF ;
 END;
 ELSE  v := dummy_gri || direction(arg.direction_ratios);
 END_IF ;
 mag := 0.0;
 REPEAT  i := 1 TO  ndim;
 mag := mag + v.direction_ratios [ i ] * v.direction_ratios [ i ];
 END_REPEAT ;
 IF  mag > 0.0 THEN  mag := SQRT(mag);
 REPEAT i := 1 TO ndim;
 v.direction_ratios [ i ] := v.direction_ratios [ i ] / mag;
 END_REPEAT;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg)THEN vec.orientation := v;
 result := vec;
 ELSE  result := v;
 END_IF ;
 ELSE RETURN(?);
 END_IF ;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- normalise

FUNCTION orthogonal_complement
	(vec : direction) : direction;
 LOCAL
 result : direction;
 END_LOCAL
;
 IF(vec.dim <> 2)OR NOT EXISTS(vec)THEN RETURN(?);
 ELSE result := dummy_gri || direction([ - vec.direction_ratios [ 2 ], vec.direction_ratios [ 1 ] ]);
 RETURN(result);
 END_IF;
 END_FUNCTION; -- orthogonal_complement

FUNCTION same_side
	(plane_pts : LIST [3:3] OF cartesian_point; test_points : LIST [2:?] OF cartesian_point) : BOOLEAN;
 LOCAL
 val1, val2 : REAL;
 n : INTEGER;
 END_LOCAL
;
 IF(plane_pts [ 1 ].dim = 2)OR(test_points [ 1 ].dim = 2)THEN  RETURN(?);
 END_IF ;
 n := SIZEOF(test_points);
 val1 := above_plane(plane_pts [ 1 ], plane_pts [ 2 ], plane_pts [ 3 ], test_points [ 1 ]);
 REPEAT i := 2 TO n;
 val2 := above_plane(plane_pts [ 1 ], plane_pts [ 2 ], plane_pts [ 3 ], test_points [ i ]);
 IF(val1 * val2 <= 0.0)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- same_side

FUNCTION scalar_times_vector
	(scalar : REAL; vec : vector_or_direction) : vector;
 LOCAL
 v : direction;
 mag : REAL;
 result : vector;
 END_LOCAL
;
 IF  NOT  EXISTS(scalar)OR NOT EXISTS(vec)THEN  RETURN(?);
 ELSE  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN TYPEOF(vec)THEN  v := dummy_gri || direction(vec.orientation.direction_ratios);
 mag := scalar * vec.magnitude;
 ELSE v := dummy_gri || direction(vec.direction_ratios);
 mag := scalar;
 END_IF ;
 IF(mag < 0.0)THEN REPEAT i := 1 TO SIZEOF(v.direction_ratios);
 v.direction_ratios [ i ] := - v.direction_ratios [ i ];
 END_REPEAT;
 mag := - mag;
 END_IF ;
 result := dummy_gri || vector(normalise(v), mag);
 END_IF;
 RETURN(result);
 END_FUNCTION; -- scalar_times_vector

FUNCTION second_proj_axis
	(z_axis : direction; x_axis : direction; arg : direction) : direction;
 LOCAL
 y_axis : vector;
 v : direction;
 temp : vector;
 END_LOCAL
;
 IF NOT EXISTS(arg)THEN v := dummy_gri || direction([ 0.0, 1.0, 0.0 ]);
 ELSE v := arg;
 END_IF;
 temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
 y_axis := vector_difference(v, temp);
 temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
 y_axis := vector_difference(y_axis, temp);
 y_axis := normalise(y_axis);
 RETURN(y_axis.orientation);
 END_FUNCTION; -- second_proj_axis

FUNCTION surface_weights_positive
	(b : rational_b_spline_surface) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 0 TO  b.u_upper;
 REPEAT j := 0 TO b.v_upper;
 IF(b.weights [ i ] [ j ] <= 0.0)THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT ;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- surface_weights_positive

FUNCTION vector_difference
	(arg1 : vector_or_direction; arg2 : vector_or_direction) : vector;
 LOCAL
 result : vector;
 res, vec1, vec2 : direction;
 mag, mag1, mag2 : REAL;
 ndim : INTEGER;
 END_LOCAL
;
 IF((NOT  EXISTS(arg1))OR(NOT EXISTS(arg2)))OR(arg1.dim <> arg2.dim)THEN  RETURN(?);
 ELSE  BEGIN IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN  mag1 := arg1.magnitude;
 vec1 := arg1.orientation;
 ELSE  mag1 := 1.0;
 vec1 := arg1;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN  mag2 := arg2.magnitude;
 vec2 := arg2.orientation;
 ELSE  mag2 := 1.0;
 vec2 := arg2;
 END_IF ;
 vec1 := normalise(vec1);
 vec2 := normalise(vec2);
 ndim := SIZEOF(vec1.direction_ratios);
 mag := 0.0;
 res := dummy_gri || direction(vec1.direction_ratios);
 REPEAT i := 1 TO ndim;
 res.direction_ratios [ i ] := mag1 * vec1.direction_ratios [ i ] + mag2 * vec2.direction_ratios [ i ];
 mag := mag +(res.direction_ratios [ i ] * res.direction_ratios [ i ]);
 END_REPEAT;
 IF(mag > 0.0)THEN result := dummy_gri || vector(res, SQRT(mag));
 ELSE result := dummy_gri || vector(vec1, 0.0);
 END_IF ;
 END;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- vector_difference

FUNCTION vector_sum
	(arg1 : vector_or_direction; arg2 : vector_or_direction) : vector;
 LOCAL
 result : vector;
 res, vec1, vec2 : direction;
 mag, mag1, mag2 : REAL;
 ndim : INTEGER;
 END_LOCAL
;
 IF((NOT  EXISTS(arg1))OR(NOT EXISTS(arg2)))OR(arg1.dim <> arg2.dim)THEN  RETURN(?);
 ELSE  BEGIN IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN  mag1 := arg1.magnitude;
 vec1 := arg1.orientation;
 ELSE  mag1 := 1.0;
 vec1 := arg1;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN  mag2 := arg2.magnitude;
 vec2 := arg2.orientation;
 ELSE  mag2 := 1.0;
 vec2 := arg2;
 END_IF ;
 vec1 := normalise(vec1);
 vec2 := normalise(vec2);
 ndim := SIZEOF(vec1.direction_ratios);
 mag := 0.0;
 res := dummy_gri || direction(vec1.direction_ratios);
 REPEAT i := 1 TO ndim;
 res.direction_ratios [ i ] := mag1 * vec1.direction_ratios [ i ] + mag2 * vec2.direction_ratios [ i ];
 mag := mag +(res.direction_ratios [ i ] * res.direction_ratios [ i ]);
 END_REPEAT;
 IF(mag > 0.0)THEN result := dummy_gri || vector(res, SQRT(mag));
 ELSE result := dummy_gri || vector(vec1, 0.0);
 END_IF ;
 END;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- vector_sum

FUNCTION volume_weights_positive
	(b : rational_b_spline_volume) : BOOLEAN;
 LOCAL
 result : BOOLEAN := TRUE;
 END_LOCAL
;
 REPEAT  i := 0 TO  b.u_upper;
 REPEAT  j := 0 TO  b.v_upper;
 REPEAT k := 0 TO b.w_upper;
 IF(b.weights [ i ] [ j ] [ k ] <= 0.0)THEN result := FALSE;
 RETURN(result);
 END_IF;
 END_REPEAT ;
 END_REPEAT ;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- volume_weights_positive

FUNCTION acyclic_group_relationship
	(relation : group_relationship; relatives : SET [1:?] OF group; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF group_relationship;
 END_LOCAL
;
 IF  relation.relating_group IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP'))| specific_relation IN TYPEOF(grp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_group_relationship(x [ i ], relatives + relation.relating_group, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_group_relationship

FUNCTION is_int_expr
	(arg : numeric_expression) : BOOLEAN;
 LOCAL
 i : INTEGER;
 END_LOCAL
;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INT_LITERAL' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REAL_LITERAL' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INT_NUMERIC_VARIABLE' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REAL_NUMERIC_VARIABLE' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ABS_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(is_int_expr(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MINUS_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(is_int_expr(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ASIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ACOS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ATAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EXP_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LOG_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LOG2_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LOG10_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SQUARE_ROOT_FUNCTION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MULT_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAXIMUM_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MINIMUM_FUNCTION' IN  TYPEOF(arg))THEN  REPEAT i := 1 TO SIZEOF(arg \ multiple_arity_numeric_expression.operands);
 IF  NOT is_int_expr(arg \ multiple_arity_numeric_expression.operands [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE );
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MINUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POWER_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(is_int_expr(arg \ binary_numeric_expression.operands [ 1 ])AND is_int_expr(arg \ binary_numeric_expression.operands [ 2 ]));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DIV_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MOD_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SLASH_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VALUE_FUNCTION' IN  TYPEOF(arg)THEN  IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INT_VALUE_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 ELSE RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INTEGER_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REAL_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_DEFINED_FUNCTION' IN TYPEOF(arg)THEN RETURN(FALSE );
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- is_int_expr

FUNCTION is_sql_mappable
	(arg : expression) : BOOLEAN;
 LOCAL
 i : INTEGER;
 END_LOCAL
;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SIMPLE_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SQL_MAPPABLE_DEFINED_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MINUS_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ABS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ASIN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ACOS_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ATAN_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EXP_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LOG_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LOG2_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LOG10_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SQUARE_ROOT_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VALUE_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_FUNCTION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MULT_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAXIMUM_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MINIMUM_FUNCTION' IN  TYPEOF(arg))THEN  REPEAT  i := 1 TO  SIZEOF(arg \ multiple_arity_numeric_expression.operands);
 IF  NOT  is_SQL_mappable(arg \ multiple_arity_numeric_expression.operands [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(TRUE );
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MINUS_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SLASH_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(is_SQL_mappable(arg \ binary_numeric_expression.operands [ 1 ])AND  is_SQL_mappable(arg \ binary_numeric_expression.operands [ 2 ]));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DIV_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MOD_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POWER_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SIMPLE_BOOLEAN_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NOT_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ UNARY_GENERIC_EXPRESSION.OPERAND));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ODD_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.XOR_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AND_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OR_EXPRESSION' IN  TYPEOF(arg))THEN  REPEAT i := 1 TO SIZEOF(arg \ MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS);
 IF  NOT is_SQL_mappable(arg \ MULTIPLE_ARITY_BOOLEAN_EXPRESSION.OPERANDS [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EQUALS_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ BINARY_GENERIC_EXPRESSION.OPERANDS [ 1 ])AND  is_SQL_mappable(arg \ BINARY_GENERIC_EXPRESSION.OPERANDS [ 2 ]));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPARISON_EQUAL' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPARISON_GREATER' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPARISON_GREATER_EQUAL' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPARISON_LESS' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPARISON_LESS_EQUAL' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPARISON_NOT_EQUAL' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LIKE_EXPRESSION' IN  TYPEOF(arg))THEN  RETURN(is_SQL_mappable(arg \ COMPARISON_EXPRESSION.OPERANDS [ 1 ])AND  is_SQL_mappable(arg \ COMPARISON_EXPRESSION.OPERANDS [ 2 ]));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INTERVAL_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(is_SQL_mappable(arg \ interval_expression.interval_low)AND  is_SQL_mappable(arg \ interval_expression.interval_high)AND is_SQL_mappable(arg \ interval_expression.interval_item));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.NUMERIC_DEFINED_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BOOLEAN_DEFINED_FUNCTION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.STRING_DEFINED_FUNCTION' IN  TYPEOF(arg))THEN  RETURN(FALSE );
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SIMPLE_STRING_EXPRESSION' IN  TYPEOF(ARG)THEN  RETURN(TRUE);
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INDEX_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBSTRING_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONCAT_EXPRESSION' IN  TYPEOF(arg))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FORMAT_FUNCTION' IN TYPEOF(arg))THEN RETURN(FALSE );
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- is_SQL_mappable

FUNCTION used_functions
	(arg : expression) : SET [0:?] OF defined_function;
 LOCAL
 result : SET OF defined_function := [ ];
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DEFINED_FUNCTION' IN  TYPEOF(arg))THEN  RETURN([ arg ]);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.UNARY_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ unary_numeric_expression.operand));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BINARY_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ binary_numeric_expression.operands [ 1 ])+ used_functions(arg \ binary_numeric_expression.operands [ 2 ]));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MULTIPLE_ARITY_NUMERIC_EXPRESSION' IN  TYPEOF(arg)THEN  REPEAT  i := 1 TO  SIZEOF(arg \ multiple_arity_numeric_expression.operands);
 result := result + used_functions(arg \ multiple_arity_numeric_expression.operands [ i ]);
 END_REPEAT ;
 RETURN(result);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.UNARY_GENERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ unary_generic_expression.operand));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BINARY_BOOLEAN_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ binary_generic_expression.operands [ 1 ])+ used_functions(arg \ binary_generic_expression.operands [ 2 ]));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MULTIPLE_ARITY_BOOLEAN_EXPRESSION' IN  TYPEOF(arg)THEN  REPEAT  i := 1 TO  SIZEOF(arg \ multiple_arity_Boolean_expression.operands);
 result := result + used_functions(arg \ multiple_arity_Boolean_expression.operands [ i ]);
 END_REPEAT ;
 RETURN(result);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPARISON_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ comparison_expression.operands [ 1 ])+ used_functions(arg \ comparison_expression.operands [ 2 ]));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INTERVAL_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ interval_expression.interval_low)+ used_functions(arg \ interval_expression.interval_high)+ used_functions(arg \ interval_expression.interval_item));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.INDEX_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ index_expression.operand)+ used_functions(arg \ index_expression.index));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SUBSTRING_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ substring_expression.operand)+ used_functions(arg \ substring_expression.index1)+ used_functions(arg \ substring_expression.index2));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CONCAT_EXPRESSION' IN  TYPEOF(arg)THEN  REPEAT i := 1 TO SIZEOF(arg \ concat_expression.operands);
 result := result + used_functions(arg \ concat_expression.operands [ i ]);
 END_REPEAT;
 RETURN(result);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FORMAT_FUNCTION' IN  TYPEOF(arg)THEN  RETURN(used_functions(arg \ format_function.value_to_format)+ used_functions(arg \ format_function.format_string));
 END_IF ;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LIKE_EXPRESSION' IN TYPEOF(arg)THEN RETURN(used_functions(arg \ like_expression.operands [ 1 ])+ used_functions(arg \ like_expression.operands [ 2 ]));
 END_IF;
 RETURN([ ]);
 END_FUNCTION; -- used_functions

FUNCTION acyclic
	(arg1 : generic_expression; arg2 : SET [0:?] OF generic_expression) : BOOLEAN;
 LOCAL
 result : BOOLEAN;
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SIMPLE_GENERIC_EXPRESSION' IN  TYPEOF(arg1))THEN  RETURN(TRUE );
 END_IF ;
 IF  arg1 IN  arg2 THEN  RETURN(FALSE);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.UNARY_GENERIC_EXPRESSION' IN  TYPEOF(arg1)THEN  RETURN(acyclic(arg1 \ unary_generic_expression.operand, arg2 + [ arg1 ]));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BINARY_GENERIC_EXPRESSION' IN  TYPEOF(arg1)THEN  RETURN(acyclic(arg1 \ binary_generic_expression.operands [ 1 ], arg2 + [ arg1 ])AND  acyclic(arg1 \ binary_generic_expression.operands [ 2 ], arg2 + [ arg1 ]));
 END_IF ;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg1)THEN result := TRUE;
 REPEAT i := 1 TO SIZEOF(arg1 \ multiple_arity_generic_expression.operands);
 result := result AND acyclic(arg1 \ multiple_arity_generic_expression.operands [ i ], arg2 + [ arg1 ]);
 END_REPEAT;
 RETURN(result);
 END_IF;
 END_FUNCTION; -- acyclic

FUNCTION is_acyclic
	(arg : generic_expression) : BOOLEAN;
 RETURN(acyclic(arg, [ ]));
 END_FUNCTION; -- is_acyclic

FUNCTION used_variables
	(arg : generic_expression) : SET [0:?] OF generic_variable;
 LOCAL
 result : SET OF generic_variable := [ ];
 END_LOCAL
;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.GENERIC_VARIABLE' IN  TYPEOF(arg)THEN  RETURN([ arg ]);
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.UNARY_GENERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_variables(arg \ unary_generic_expression.operand));
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.BINARY_GENERIC_EXPRESSION' IN  TYPEOF(arg)THEN  RETURN(used_variables(arg \ binary_generic_expression.operands [ 1 ])+ used_variables(arg \ binary_generic_expression.operands [ 2 ]));
 END_IF ;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' IN TYPEOF(arg)THEN REPEAT i := 1 TO SIZEOF(arg \ multiple_arity_generic_expression.operands);
 result := result + used_variables(arg \ multiple_arity_generic_expression.operands [ i ]);
 END_REPEAT;
 RETURN(result);
 END_IF;
 RETURN([ ]);
 END_FUNCTION; -- used_variables

FUNCTION acyclic_location_relationship
	(relation : location_relationship; relatives : SET [0:?] OF location; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF location_relationship;
 END_LOCAL
;
 IF  relation.relating_location IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION'))| specific_relation IN TYPEOF(lctn));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_location_relationship(x [ i ], relatives + relation.relating_location, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_location_relationship

FUNCTION acyclic_identification_assignment_relationship
	(relation : identification_assignment_relationship; relatives : SET [1:?] OF identification_assignment; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF identification_assignment_relationship;
 END_LOCAL
;
 IF  relation.relating_identification_assignment IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT'))| specific_relation IN TYPEOF(ia));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_identification_assignment_relationship(x [ i ], relatives + relation.relating_identification_assignment, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_identification_assignment_relationship

FUNCTION acyclic_property_definition_relationship
	(relation : property_definition_relationship; relatives : SET [1:?] OF property_definition; specific_relation : STRING) : LOGICAL;
 LOCAL
 x : SET OF property_definition_relationship;
 END_LOCAL
;
 IF  relation.relating_property_definition IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_property_definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_RELATIONSHIP.' + 'RELATED_PROPERTY_DEFINITION'))| specific_relation IN TYPEOF(pd));
 REPEAT I := 1 TO HIINDEX(x);
 IF NOT acyclic_property_definition_relationship(x [ i ], relatives + relation.relating_property_definition, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_property_definition_relationship

FUNCTION all_members_of_es
	(sv : SET [0:?] OF maths_value; es : elementary_space_enumerators) : LOGICAL;
 LOCAL
 v : maths_value;
 key_type : STRING  := '';
 types : SET OF  STRING;
 ge : generic_expression;
 cum : LOGICAL := TRUE ;
 vspc : maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(sv)OR NOT  EXISTS(es)THEN  RETURN(FALSE );
 END_IF ;
 CASE es OF es_numbers : key_type := 'NUMBER';
 es_complex_numbers : key_type := 'COMPLEX_NUMBER_LITERAL';
 es_reals : key_type := 'REAL';
 es_integers : key_type := 'INTEGER';
 es_logicals : key_type := 'LOGICAL';
 es_booleans : key_type := 'BOOLEAN';
 es_strings : key_type := 'STRING';
 es_binarys : key_type := 'BINARY';
 es_maths_spaces : key_type := 'MATHS_SPACE';
 es_maths_functions : key_type := 'MATHS_FUNCTION';
 es_generics : RETURN(TRUE);
 END_CASE;
 REPEAT i := 1 TO SIZEOF(sv);
 IF  NOT  EXISTS(sv [ i ])THEN  RETURN(FALSE );
 END_IF ;
 v := simplify_maths_value(sv [ i ]);
 types := stripped_typeof(v);
 IF  key_type IN  types THEN  SKIP ;
 END_IF ;
 IF(es = es_numbers)AND('COMPLEX_NUMBER_LITERAL' IN types)THEN  SKIP;
 END_IF ;
 IF  SIZEOF(base_types * types)> 0 THEN  RETURN(FALSE );
 END_IF ;
 ge := v;
 IF  has_values_space(ge)THEN  vspc := values_space_of(ge);
 IF  NOT  subspace_of_es(vspc, es)THEN  IF  NOT compatible_spaces(vspc, make_elementary_space(es))THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END_IF ;
 ELSE cum := UNKNOWN;
 END_IF ;
 IF cum = FALSE  THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(cum);
 END_FUNCTION; -- all_members_of_es

FUNCTION angle
	(a : REAL) : REAL;
 REPEAT  WHILE  a > PI ;
 a := a - 2.0 * PI ;
 END_REPEAT ;
 REPEAT WHILE a <= - PI ;
 a := a + 2.0 * PI;
 END_REPEAT;
 RETURN(a);
 END_FUNCTION; -- angle

FUNCTION angle2
	(a : REAL) : REAL;
 REPEAT  WHILE  a > PI ;
 a := a - 2.0 * PI ;
 END_REPEAT ;
 REPEAT WHILE a <= - PI ;
 a := a + 2.0 * PI;
 END_REPEAT;
 RETURN(a);
 END_FUNCTION; -- angle2

FUNCTION any_space_satisfies
	(sc : space_constraint_type; spc : maths_space) : BOOLEAN;
 LOCAL
 spc_id : elementary_space_enumerators;
 END_LOCAL
;
 IF(sc = sc_equal)OR  NOT('ELEMENTARY_SPACE' IN stripped_typeof(spc))THEN  RETURN(FALSE);
 END_IF ;
 spc_id := spc \ elementary_space.space_id;
 IF  sc = sc_subspace THEN  RETURN(bool(spc_id = es_generics));
 END_IF ;
 IF sc = sc_member THEN RETURN(bool((spc_id = es_generics)OR(spc_id = es_maths_spaces)));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- any_space_satisfies

FUNCTION assoc_product_space
	(ts1 : tuple_space; ts2 : tuple_space) : tuple_space;
 LOCAL
 types1 : SET  OF  STRING  := stripped_typeof(ts1);
 types2 : SET OF  STRING := stripped_typeof(ts2);
 up1, up2 : uniform_product_space := make_uniform_product_space(the_reals, 1);
 lp1, lp2, lps : listed_product_space := the_zero_tuple_space;
 et1, et2, ets : extended_tuple_space := the_tuples;
 use_up1, use_up2, use_lp1, use_lp2 : BOOLEAN;
 factors : LIST OF maths_space := [ ];
 tspace : tuple_space;
 END_LOCAL
;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types1 THEN  up1 := ts1;
 use_up1 := TRUE ;
 use_lp1 := FALSE ;
 ELSE  IF  'LISTED_PRODUCT_SPACE' IN  types1 THEN  lp1 := ts1;
 use_up1 := FALSE ;
 use_lp1 := TRUE ;
 ELSE  IF  NOT('EXTENDED_TUPLE_SPACE' IN  types1)THEN  RETURN(?);
 END_IF ;
 et1 := ts1;
 use_up1 := FALSE ;
 use_lp1 := FALSE ;
 END_IF ;
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types2 THEN  up2 := ts2;
 use_up2 := TRUE ;
 use_lp2 := FALSE ;
 ELSE  IF  'LISTED_PRODUCT_SPACE' IN  types2 THEN  lp2 := ts2;
 use_up2 := FALSE ;
 use_lp2 := TRUE;
 ELSE  IF  NOT('EXTENDED_TUPLE_SPACE' IN types2)THEN  RETURN(?);
 END_IF ;
 et2 := ts2;
 use_up2 := FALSE ;
 use_lp2 := FALSE;
 END_IF ;
 END_IF ;
 IF  use_up1 THEN  IF  use_up2 THEN  IF  up1.base = up2.base THEN  tspace := make_uniform_product_space(up1.base, up1.exponent + up2.exponent);
 ELSE  factors := [ up1.base : up1.exponent, up2.base : up2.exponent ];
 tspace := make_listed_product_space(factors);
 END_IF ;
 ELSE  IF  use_lp2 THEN  factors := [ up1.base : up1.exponent ];
 factors := factors + lp2.factors;
 tspace := make_listed_product_space(factors);
 ELSE  tspace := assoc_product_space(up1, et2.base);
 tspace := make_extended_tuple_space(tspace, et2.extender);
 END_IF ;
 END_IF ;
 ELSE  IF  use_lp1 THEN  IF  use_up2 THEN  factors := [ up2.base : up2.exponent ];
 factors := lp1.factors + factors;
 tspace := make_listed_product_space(factors);
 ELSE  IF  use_lp2 THEN  tspace := make_listed_product_space(lp1.factors + lp2.factors);
 ELSE  tspace := assoc_product_space(lp1, et2.base);
 tspace := make_extended_tuple_space(tspace, et2.extender);
 END_IF ;
 END_IF ;
 ELSE  IF  use_up2 THEN  IF  et1.extender = up2.base THEN  tspace := assoc_product_space(et1.base, up2);
 tspace := make_extended_tuple_space(tspace, et1.extender);
 ELSE  RETURN(?);
 END_IF ;
 ELSE  IF  use_lp2 THEN  factors := lp2.factors;
 REPEAT i := 1 TO SIZEOF(factors);
 IF  et1.extender <> factors [ i ] THEN  RETURN(?);
 END_IF ;
 END_REPEAT;
 tspace := assoc_product_space(et1.base, lp2);
 tspace := make_extended_tuple_space(tspace, et1.extender);
 ELSE  IF et1.extender = et2.extender THEN tspace := assoc_product_space(et1, et2.base);
 ELSE RETURN(?);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF;
 RETURN(tspace);
 END_FUNCTION; -- assoc_product_space

FUNCTION atan2
	(y : REAL; x : REAL) : REAL;
 LOCAL
 r : REAL;
 END_LOCAL
;
 IF(y = 0.0)AND(x = 0.0)THEN  RETURN(?);
 END_IF ;
 r := ATAN(y, x);
 IF  x < 0.0 THEN  IF y < 0.0 THEN r := r - PI ;
 ELSE r := r + PI;
 END_IF ;
 END_IF;
 RETURN(r);
 END_FUNCTION; -- atan2

FUNCTION bool
	(lgcl : LOGICAL) : BOOLEAN;
 IF  NOT EXISTS(lgcl)THEN  RETURN(FALSE );
 END_IF ;
 IF lgcl <> TRUE  THEN RETURN(FALSE);
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- bool

FUNCTION check_sparse_index_domain
	(idxdom : tuple_space; base : zero_or_one; shape : LIST [1:?] OF positive_integer; order : ordering_type) : BOOLEAN;
 LOCAL
 mthspc : maths_space;
 interval : finite_integer_interval;
 i : INTEGER;
 END_LOCAL
;
 mthspc := factor1(idxdom);
 interval := mthspc;
 IF order = by_rows THEN i := 1;
 ELSE i := 2;
 END_IF;
 RETURN(bool((interval.min <= base)AND(interval.max >= base + shape [ i ])));
 END_FUNCTION; -- check_sparse_index_domain

FUNCTION check_sparse_index_to_loc
	(index_range : tuple_space; loc_domain : tuple_space) : BOOLEAN;
 LOCAL
 temp : maths_space;
 idx_rng_itvl, loc_dmn_itvl : finite_integer_interval;
 END_LOCAL
;
 temp := factor1(index_range);
 IF(schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(temp)THEN  temp := factor1(temp);
 END_IF ;
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  TYPEOF(temp))THEN  RETURN(FALSE );
 END_IF ;
 idx_rng_itvl := temp;
 temp := factor1(loc_domain);
 IF(schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(temp)THEN  temp := factor1(temp);
 END_IF ;
 IF NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN RETURN(FALSE);
 END_IF;
 loc_dmn_itvl := temp;
 RETURN(bool((loc_dmn_itvl.min <= idx_rng_itvl.min)AND(idx_rng_itvl.max <= loc_dmn_itvl.max + 1)));
 END_FUNCTION; -- check_sparse_index_to_loc

FUNCTION check_sparse_loc_range
	(locrng : tuple_space; base : zero_or_one; shape : LIST [1:?] OF positive_integer; order : ordering_type) : BOOLEAN;
 LOCAL
 mthspc : maths_space;
 interval : finite_integer_interval;
 i : INTEGER;
 END_LOCAL
;
 IF  space_dimension(locrng)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 mthspc := factor1(locrng);
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(mthspc))THEN  RETURN(FALSE);
 END_IF ;
 interval := mthspc;
 IF order = by_rows THEN i := 2;
 ELSE i := 1;
 END_IF;
 RETURN(bool((interval.min >= base)AND(interval.max <= base + shape [ i ] - 1)));
 END_FUNCTION; -- check_sparse_loc_range

FUNCTION compare_basis_and_coef
	(basis : LIST [1:?] OF b_spline_basis; coef : maths_function) : BOOLEAN;
 LOCAL
 shape : LIST OF positive_integer;
 END_LOCAL
;
 IF  NOT  EXISTS(basis)OR NOT  EXISTS(coef)THEN  RETURN(FALSE );
 END_IF ;
 shape := shape_of_array(coef);
 IF  NOT EXISTS(shape)THEN  RETURN(FALSE );
 END_IF ;
 IF  SIZEOF(shape)< SIZEOF(basis)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(basis);
 IF(basis [ i ].num_basis = shape [ i ])<> TRUE  THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- compare_basis_and_coef

FUNCTION compare_list_and_value
	(lv : LIST [0:?] OF GENERIC; op : elementary_function_enumerators; v : GENERIC:G) : BOOLEAN;
 IF  NOT  EXISTS(lv)OR  NOT  EXISTS(op)OR NOT  EXISTS(v)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(lv);
 IF NOT compare_values(lv [ i ], op, v)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- compare_list_and_value

FUNCTION compare_values
	(v1 : GENERIC:G; op : elementary_function_enumerators; v2 : GENERIC:G) : BOOLEAN;
 LOCAL
 logl : LOGICAL := UNKNOWN;
 END_LOCAL
;
 IF  NOT  EXISTS(v1)OR  NOT  EXISTS(op)OR NOT EXISTS(v2)THEN  RETURN(FALSE );
 END_IF ;
 CASE op OF ef_eq_i : logl :=(v1 = v2);
 ef_ne_i : logl :=(v1 <> v2);
 ef_gt_i : logl :=(v1 > v2);
 ef_lt_i : logl :=(v1 < v2);
 ef_ge_i : logl :=(v1 >= v2);
 ef_le_i : logl :=(v1 <= v2);
 END_CASE;
 IF  EXISTS(logl)THEN  IF logl = TRUE  THEN RETURN(TRUE);
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- compare_values

FUNCTION compatible_complex_number_regions
	(sp1 : maths_space; sp2 : maths_space) : BOOLEAN;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(sp1);
 crgn1, crgn2 : cartesian_complex_number_region;
 prgn1, prgn2, prgn1c2, prgn2c1 : polar_complex_number_region;
 sp1_is_crgn, sp2_is_crgn : BOOLEAN;
 END_LOCAL
;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  typenames THEN  sp1_is_crgn := TRUE ;
 crgn1 := sp1;
 ELSE  IF  'POLAR_COMPLEX_NUMBER_REGION' IN  typenames THEN  sp1_is_crgn := FALSE ;
 prgn1 := sp1;
 ELSE  RETURN(TRUE );
 END_IF ;
 END_IF ;
 typenames := stripped_typeof(sp2);
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  typenames THEN  sp2_is_crgn := TRUE ;
 crgn2 := sp2;
 ELSE  IF  'POLAR_COMPLEX_NUMBER_REGION' IN typenames THEN  sp2_is_crgn := FALSE ;
 prgn2 := sp2;
 ELSE RETURN(TRUE );
 END_IF ;
 END_IF ;
 IF  sp1_is_crgn AND  sp2_is_crgn THEN  RETURN(compatible_intervals(crgn1.real_constraint, crgn2.real_constraint)AND  compatible_intervals(crgn1.imag_constraint, crgn2.imag_constraint));
 END_IF ;
 IF  NOT  sp1_is_crgn AND  NOT  sp2_is_crgn AND(prgn1.centre.real_part = prgn2.centre.real_part)AND(prgn1.centre.imag_part = prgn2.centre.imag_part)THEN  IF  NOT  compatible_intervals(prgn1.distance_constraint, prgn2.distance_constraint)THEN  RETURN(FALSE );
 END_IF ;
 IF  compatible_intervals(prgn1.direction_constraint, prgn2.direction_constraint)THEN  RETURN(TRUE);
 END_IF ;
 IF(prgn1.direction_constraint.max > PI)AND(prgn2.direction_constraint.max < PI)THEN  RETURN(compatible_intervals(prgn2.direction_constraint, make_finite_real_interval(- PI , open, prgn1.direction_constraint.max - 2.0 * PI , prgn1.direction_constraint.max_closure)));
 END_IF ;
 IF(prgn2.direction_constraint.max > PI)AND(prgn1.direction_constraint.max < PI)THEN  RETURN(compatible_intervals(prgn1.direction_constraint, make_finite_real_interval(- PI , open, prgn2.direction_constraint.max - 2.0 * PI, prgn2.direction_constraint.max_closure)));
 END_IF ;
 RETURN(FALSE);
 END_IF ;
 IF  sp1_is_crgn AND  NOT  sp2_is_crgn THEN  crgn2 := enclose_pregion_in_cregion(prgn2);
 prgn1 := enclose_cregion_in_pregion(crgn1, prgn2.centre);
 RETURN(compatible_complex_number_regions(crgn1, crgn2)AND  compatible_complex_number_regions(prgn1, prgn2));
 END_IF ;
 IF NOT sp1_is_crgn AND  sp2_is_crgn THEN crgn1 := enclose_pregion_in_cregion(prgn1);
 prgn2 := enclose_cregion_in_pregion(crgn2, prgn1.centre);
 RETURN(compatible_complex_number_regions(crgn1, crgn2)AND  compatible_complex_number_regions(prgn1, prgn2));
 END_IF;
 prgn1c2 := enclose_pregion_in_pregion(prgn1, prgn2.centre);
 prgn2c1 := enclose_pregion_in_pregion(prgn2, prgn1.centre);
 RETURN(compatible_complex_number_regions(prgn1, prgn2c1)AND compatible_complex_number_regions(prgn1c2, prgn2));
 END_FUNCTION; -- compatible_complex_number_regions

FUNCTION compatible_es_values
	(esval1 : elementary_space_enumerators; esval2 : elementary_space_enumerators) : BOOLEAN;
 LOCAL
 esval1_is_numeric, esval2_is_numeric : LOGICAL;
 END_LOCAL
;
 IF(esval1 = esval2)OR(esval1 = es_generics)OR(esval2 = es_generics)THEN  RETURN(TRUE );
 END_IF ;
 esval1_is_numeric :=(esval1 >= es_numbers)AND(esval1 <= es_integers);
 esval2_is_numeric :=(esval2 >= es_numbers)AND(esval2 <= es_integers);
 IF(esval1_is_numeric AND(esval2 = es_numbers))OR(esval2_is_numeric AND(esval1 = es_numbers))THEN  RETURN(TRUE );
 END_IF ;
 IF  esval1_is_numeric XOR esval2_is_numeric THEN  RETURN(FALSE );
 END_IF ;
 IF((esval1 = es_logicals)AND(esval2 = es_booleans))OR((esval1 = es_booleans)AND(esval2 = es_logicals))THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- compatible_es_values

FUNCTION compatible_intervals
	(sp1 : maths_space; sp2 : maths_space) : BOOLEAN;
 LOCAL
 amin, amax : REAL;
 END_LOCAL
;
 IF  min_exists(sp1)AND  max_exists(sp2)THEN  amin := real_min(sp1);
 amax := real_max(sp2);
 IF  amin > amax THEN  RETURN(FALSE );
 END_IF ;
 IF  amin = amax THEN  RETURN(min_included(sp1)AND  max_included(sp2));
 END_IF ;
 END_IF ;
 IF  min_exists(sp2)AND  max_exists(sp1)THEN  amin := real_min(sp2);
 amax := real_max(sp1);
 IF  amin > amax THEN  RETURN(FALSE);
 END_IF ;
 IF amin = amax THEN RETURN(min_included(sp2)AND max_included(sp1));
 END_IF ;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- compatible_intervals

FUNCTION compatible_spaces
	(sp1 : maths_space; sp2 : maths_space) : BOOLEAN;
 LOCAL
 types1 : SET  OF  STRING  := stripped_typeof(sp1);
 types2 : SET OF  STRING := stripped_typeof(sp2);
 lgcl : LOGICAL := UNKNOWN ;
 m, n : INTEGER;
 s1, s2 : maths_space;
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  types1 THEN  REPEAT  i := 1 TO  SIZEOF(sp1 \ finite_space.members);
 lgcl := member_of(sp1 \ finite_space.members [ i ], sp2);
 IF  lgcl <> FALSE  THEN  RETURN(TRUE );
 END_IF ;
 END_REPEAT ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_SPACE' IN  types2 THEN  REPEAT  i := 1 TO  SIZEOF(sp2 \ finite_space.members);
 lgcl := member_of(sp2 \ finite_space.members [ i ], sp1);
 IF  lgcl <> FALSE  THEN  RETURN(TRUE );
 END_IF ;
 END_REPEAT ;
 RETURN(FALSE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types1 THEN  IF  sp1 \ elementary_space.space_id = es_generics THEN  RETURN(TRUE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types2 THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, sp2 \ elementary_space.space_id));
 END_IF ;
 IF('FINITE_INTEGER_INTERVAL' IN  types2)OR('INTEGER_INTERVAL_FROM_MIN' IN  types2)OR('INTEGER_INTERVAL_TO_MAX' IN  types2)THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, es_integers));
 END_IF ;
 IF('FINITE_REAL_INTERVAL' IN  types2)OR('REAL_INTERVAL_FROM_MIN' IN  types2)OR('REAL_INTERVAL_TO_MAX' IN  types2)THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, es_reals));
 END_IF ;
 IF('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types2)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types2)THEN  RETURN(compatible_es_values(sp1 \ elementary_space.space_id, es_complex_numbers));
 END_IF ;
 IF  'TUPLE_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types2 THEN  RETURN(bool(sp1 \ elementary_space.space_id = es_maths_functions));
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types2 THEN  IF  sp2 \ elementary_space.space_id = es_generics THEN  RETURN(TRUE );
 END_IF ;
 IF('FINITE_INTEGER_INTERVAL' IN  types1)OR('INTEGER_INTERVAL_FROM_MIN' IN  types1)OR('INTEGER_INTERVAL_TO_MAX' IN  types1)THEN  RETURN(compatible_es_values(sp2 \ elementary_space.space_id, es_integers));
 END_IF ;
 IF('FINITE_REAL_INTERVAL' IN  types1)OR('REAL_INTERVAL_FROM_MIN' IN  types1)OR('REAL_INTERVAL_TO_MAX' IN  types1)THEN  RETURN(compatible_es_values(sp2 \ elementary_space.space_id, es_reals));
 END_IF ;
 IF('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types1)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types1)THEN  RETURN(compatible_es_values(sp2 \ elementary_space.space_id, es_complex_numbers));
 END_IF ;
 IF  'TUPLE_SPACE' IN  types1 THEN  RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types1 THEN  RETURN(bool(sp2 \ elementary_space.space_id = es_maths_functions));
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  subspace_of_es(sp1, es_integers)THEN  IF  subspace_of_es(sp2, es_integers)THEN  RETURN(compatible_intervals(sp1, sp2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp2, es_integers)THEN  RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp1, es_reals)THEN  IF  subspace_of_es(sp2, es_reals)THEN  RETURN(compatible_intervals(sp1, sp2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp2, es_reals)THEN  RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp1, es_complex_numbers)THEN  IF  subspace_of_es(sp2, es_complex_numbers)THEN  RETURN(compatible_complex_number_regions(sp1, sp2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(sp2, es_complex_numbers)THEN  RETURN(FALSE );
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types1 THEN  IF  'UNIFORM_PRODUCT_SPACE' IN  types2 THEN  IF  sp1 \ uniform_product_space.exponent <> sp2 \ uniform_product_space.exponent THEN  RETURN(FALSE );
 END_IF ;
 RETURN(compatible_spaces(sp1 \ uniform_product_space.base, sp2 \ uniform_product_space.base));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types2 THEN  n := SIZEOF(sp2 \ listed_product_space.factors);
 IF  sp1 \ uniform_product_space.exponent <> n THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  n;
 IF  NOT  compatible_spaces(sp1 \ uniform_product_space.base, sp2 \ listed_product_space.factors [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(TRUE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  m := sp1 \ uniform_product_space.exponent;
 n := space_dimension(sp2 \ extended_tuple_space.base);
 IF  m < n THEN  RETURN(FALSE );
 END_IF ;
 IF  m = n THEN  RETURN(compatible_spaces(sp1, sp2 \ extended_tuple_space.base));
 END_IF ;
 RETURN(compatible_spaces(sp1, assoc_product_space(sp2 \ extended_tuple_space.base, make_uniform_product_space(sp2 \ extended_tuple_space.extender, m - n))));
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types1 THEN  n := SIZEOF(sp1 \ listed_product_space.factors);
 IF  'UNIFORM_PRODUCT_SPACE' IN  types2 THEN  IF  n <> sp2 \ uniform_product_space.exponent THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  n;
 IF  NOT  compatible_spaces(sp2 \ uniform_product_space.base, sp1 \ listed_product_space.factors [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(TRUE );
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types2 THEN  IF  n <> SIZEOF(sp2 \ listed_product_space.factors)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO n;
 IF  NOT  compatible_spaces(sp1 \ listed_product_space.factors [ i ], sp2 \ listed_product_space.factors [ i ])THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  m := space_dimension(sp2 \ extended_tuple_space.base);
 IF  n < m THEN  RETURN(FALSE );
 END_IF ;
 IF  n = m THEN  RETURN(compatible_spaces(sp1, sp2 \ extended_tuple_space.base));
 END_IF ;
 RETURN(compatible_spaces(sp1, assoc_product_space(sp2 \ extended_tuple_space.base, make_uniform_product_space(sp2 \ extended_tuple_space.extender, n - m))));
 END_IF ;
 IF(schema_prefix + 'FUNCTION_SPACE')IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types1 THEN  IF('UNIFORM_PRODUCT_SPACE' IN  types2)OR('LISTED_PRODUCT_SPACE' IN  types2)THEN  RETURN(compatible_spaces(sp2, sp1));
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  IF  NOT compatible_spaces(sp1 \ extended_tuple_space.extender, sp2 \ extended_tuple_space.extender)THEN  RETURN(FALSE );
 END_IF ;
 n := space_dimension(sp1 \ extended_tuple_space.base);
 m := space_dimension(sp2 \ extended_tuple_space.base);
 IF  n < m THEN  RETURN(compatible_spaces(assoc_product_space(sp1 \ extended_tuple_space.base, make_uniform_product_space(sp1 \ extended_tuple_space.extender, m - n)), sp2 \ extended_tuple_space.base));
 END_IF ;
 IF  n = m THEN  RETURN(compatible_spaces(sp1 \ extended_tuple_space.base, sp2 \ extended_tuple_space.base));
 END_IF ;
 IF  n > m THEN  RETURN(compatible_spaces(sp1 \ extended_tuple_space.base, assoc_product_space(sp2 \ extended_tuple_space.base, make_uniform_product_space(sp2 \ extended_tuple_space.extender, n - m))));
 END_IF ;
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types1 THEN  IF  'FUNCTION_SPACE' IN types2 THEN  s1 := sp1 \ function_space.domain_argument;
 s2 := sp2 \ function_space.domain_argument;
 CASE  sp1 \ function_space.domain_constraint OF  sc_equal : BEGIN  CASE  sp2 \ function_space.domain_constraint OF  sc_equal : lgcl := subspace_of(s1, s2)AND  subspace_of(s2, s1);
 sc_subspace : lgcl := subspace_of(s1, s2);
 sc_member : lgcl := member_of(s1, s2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  sp2 \ function_space.domain_constraint OF  sc_equal : lgcl := subspace_of(s2, s1);
 sc_subspace : lgcl := compatible_spaces(s1, s2);
 sc_member : lgcl := UNKNOWN ;
 END_CASE ;
 END ;
 sc_member : BEGIN  CASE  sp2 \ function_space.domain_constraint OF  sc_equal : lgcl := member_of(s2, s1);
 sc_subspace : lgcl := UNKNOWN ;
 sc_member : lgcl := compatible_spaces(s1, s2);
 END_CASE ;
 END ;
 END_CASE ;
 IF  lgcl = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 s1 := sp1 \ function_space.range_argument;
 s2 := sp2 \ function_space.range_argument;
 CASE  sp1 \ function_space.range_constraint OF  sc_equal : BEGIN  CASE  sp2 \ function_space.range_constraint OF  sc_equal : lgcl := subspace_of(s1, s2)AND subspace_of(s2, s1);
 sc_subspace : lgcl := subspace_of(s1, s2);
 sc_member : lgcl := member_of(s1, s2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  sp2 \ function_space.range_constraint OF  sc_equal : lgcl := subspace_of(s2, s1);
 sc_subspace : lgcl := compatible_spaces(s1, s2);
 sc_member : lgcl := UNKNOWN ;
 END_CASE ;
 END ;
 sc_member : BEGIN CASE sp2 \ function_space.range_constraint OF sc_equal : lgcl := member_of(s2, s1);
 sc_subspace : lgcl := UNKNOWN;
 sc_member : lgcl := compatible_spaces(s1, s2);
 END_CASE ;
 END;
 END_CASE;
 IF lgcl = FALSE  THEN RETURN(FALSE);
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 RETURN(TRUE );
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- compatible_spaces

FUNCTION composable_sequence
	(operands : LIST [2:?] OF maths_function) : BOOLEAN;
 REPEAT i := 1 TO SIZEOF(operands)- 1;
 IF NOT compatible_spaces(operands [ i ].range, operands [ i + 1 ].domain)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- composable_sequence

FUNCTION convert_to_literal
	(val : maths_atom) : generic_literal;
 LOCAL
 types : SET OF STRING := TYPEOF(val);
 END_LOCAL
;
 IF  'INTEGER' IN  types THEN  RETURN(make_int_literal(val));
 END_IF ;
 IF  'REAL' IN  types THEN  RETURN(make_real_literal(val));
 END_IF ;
 IF  'BOOLEAN' IN  types THEN  RETURN(make_boolean_literal(val));
 END_IF ;
 IF  'STRING' IN  types THEN  RETURN(make_string_literal(val));
 END_IF ;
 IF  'LOGICAL' IN  types THEN  RETURN(make_logical_literal(val));
 END_IF ;
 IF  'BINARY' IN  types THEN  RETURN(make_binary_literal(val));
 END_IF ;
 IF(schema_prefix + 'MATHS_ENUM_ATOM')IN types THEN RETURN(make_maths_enum_literal(val));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- convert_to_literal

FUNCTION convert_to_maths_function
	(func : maths_function_select) : maths_function;
 LOCAL
 efenum : elementary_function_enumerators;
 mthfun : maths_function;
 END_LOCAL
;
 IF(schema_prefix + 'MATHS_FUNCTION')IN TYPEOF(func)THEN mthfun := func;
 ELSE efenum := func;
 mthfun := make_elementary_function(efenum);
 END_IF;
 RETURN(mthfun);
 END_FUNCTION; -- convert_to_maths_function

FUNCTION convert_to_maths_value
	(val : GENERIC:G) : maths_value;
 LOCAL
 types : SET OF STRING := TYPEOF(val);
 ival : maths_integer;
 rval : maths_real;
 nval : maths_number;
 tfval : maths_boolean;
 lval : maths_logical;
 sval : maths_string;
 bval : maths_binary;
 tval : maths_tuple := the_empty_maths_tuple;
 mval : maths_value;
 END_LOCAL
;
 IF(schema_prefix + 'MATHS_VALUE')IN  types THEN  RETURN(val);
 END_IF ;
 IF  'INTEGER' IN  types THEN  ival := val;
 RETURN(ival);
 END_IF ;
 IF  'REAL' IN  types THEN  rval := val;
 RETURN(rval);
 END_IF ;
 IF  'NUMBER' IN  types THEN  nval := val;
 RETURN(nval);
 END_IF ;
 IF  'BOOLEAN' IN  types THEN  tfval := val;
 RETURN(tfval);
 END_IF ;
 IF  'LOGICAL' IN  types THEN  lval := val;
 RETURN(lval);
 END_IF ;
 IF  'STRING' IN  types THEN  sval := val;
 RETURN(sval);
 END_IF ;
 IF  'BINARY' IN  types THEN  bval := val;
 RETURN(bval);
 END_IF ;
 IF  'LIST' IN types THEN  REPEAT i := 1 TO SIZEOF(val);
 mval := convert_to_maths_value(val [ i ]);
 IF NOT EXISTS(mval)THEN RETURN(?);
 END_IF ;
 INSERT(tval, mval, i - 1);
 END_REPEAT;
 RETURN(tval);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- convert_to_maths_value

FUNCTION convert_to_operand
	(val : maths_value) : generic_expression;
 LOCAL
 types : SET OF STRING := stripped_typeof(val);
 END_LOCAL
;
 IF  'GENERIC_EXPRESSION' IN  types THEN  RETURN(val);
 END_IF ;
 IF  'MATHS_ATOM' IN  types THEN  RETURN(convert_to_literal(val));
 END_IF ;
 IF  'ATOM_BASED_VALUE' IN  types THEN  RETURN(make_atom_based_literal(val));
 END_IF ;
 IF 'MATHS_TUPLE' IN types THEN RETURN(make_maths_tuple_literal(val));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- convert_to_operand

FUNCTION convert_to_operands
	(values : AGGREGATE OF maths_value) : LIST [0:?] OF generic_expression;
 LOCAL
 operands : LIST OF generic_expression := [ ];
 loc : INTEGER := 0;
 END_LOCAL
;
 IF NOT EXISTS(values)THEN RETURN(?);
 END_IF;
 REPEAT i := LOINDEX(values)TO HIINDEX(values);
 INSERT(operands, convert_to_operand(values [ i ]), loc);
 loc := loc + 1;
 END_REPEAT;
 RETURN(operands);
 END_FUNCTION; -- convert_to_operands

FUNCTION convert_to_operands_prcmfn
	(srcdom : maths_space_or_function; prepfun : LIST [0:?] OF maths_function; finfun : maths_function_select) : LIST [2:?] OF generic_expression;
 LOCAL
 operands : LIST OF generic_expression := [ ];
 END_LOCAL
;
 INSERT(operands, srcdom, 0);
 REPEAT i := 1 TO SIZEOF(prepfun);
 INSERT(operands, prepfun [ i ], i);
 END_REPEAT;
 INSERT(operands, convert_to_maths_function(finfun), SIZEOF(prepfun)+ 1);
 RETURN(operands);
 END_FUNCTION; -- convert_to_operands_prcmfn

FUNCTION ctmv
	(x : GENERIC:G) : maths_value;
 RETURN(convert_to_maths_value(x));
 END_FUNCTION; -- ctmv

FUNCTION definite_integral_check
	(domain : tuple_space; vrblint : input_selector; lowerinf : BOOLEAN; upperinf : BOOLEAN) : BOOLEAN;
 LOCAL
 domn : tuple_space := domain;
 fspc : maths_space;
 dim : nonnegative_integer;
 k : positive_integer;
 END_LOCAL
;
 IF(space_dimension(domain)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(domain)))THEN  domn := factor1(domain);
 END_IF ;
 dim := space_dimension(domn);
 k := vrblint;
 IF  k > dim THEN  RETURN(FALSE );
 END_IF ;
 fspc := factor_space(domn, k);
 IF  NOT((schema_prefix + 'REAL_INTERVAL')IN TYPEOF(fspc))THEN  RETURN(FALSE );
 END_IF ;
 IF  lowerinf AND  min_exists(fspc)THEN  RETURN(FALSE );
 END_IF ;
 IF upperinf AND max_exists(fspc)THEN RETURN(FALSE);
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- definite_integral_check

FUNCTION definite_integral_expr_check
	(operands : LIST [2:?] OF generic_expression; lowerinf : BOOLEAN; upperinf : BOOLEAN) : BOOLEAN;
 LOCAL
 nops : INTEGER := 2;
 vspc : maths_space;
 dim : nonnegative_integer;
 k : positive_integer;
 bspc : maths_space;
 END_LOCAL
;
 IF  NOT  lowerinf THEN  nops := nops + 1;
 END_IF ;
 IF  NOT  upperinf THEN  nops := nops + 1;
 END_IF ;
 IF  SIZEOF(operands)<> nops THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT('GENERIC_VARIABLE' IN  stripped_typeof(operands [ 2 ]))THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT  has_values_space(operands [ 2 ])THEN  RETURN(FALSE );
 END_IF ;
 vspc := values_space_of(operands [ 2 ]);
 IF  NOT('REAL_INTERVAL' IN stripped_typeof(vspc))THEN  RETURN(FALSE );
 END_IF ;
 IF  lowerinf THEN  IF  min_exists(vspc)THEN  RETURN(FALSE );
 END_IF ;
 k := 3;
 ELSE  IF  NOT  has_values_space(operands [ 3 ])THEN  RETURN(FALSE );
 END_IF ;
 bspc := values_space_of(operands [ 3 ]);
 IF  NOT  compatible_spaces(bspc, vspc)THEN  RETURN(FALSE );
 END_IF ;
 k := 4;
 END_IF ;
 IF  upperinf THEN  IF  max_exists(vspc)THEN  RETURN(FALSE );
 END_IF ;
 ELSE IF  NOT  has_values_space(operands [ k ])THEN  RETURN(FALSE );
 END_IF ;
 bspc := values_space_of(operands [ k ]);
 IF NOT compatible_spaces(bspc, vspc)THEN RETURN(FALSE);
 END_IF ;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- definite_integral_expr_check

FUNCTION derive_definite_integral_domain
	(igrl : definite_integral_function) : tuple_space;
 LOCAL
 idomn : tuple_space := igrl.integrand.domain;
 types : SET OF STRING := TYPEOF(idomn);
 idx : INTEGER  := igrl.variable_of_integration;
 tupled : BOOLEAN := bool(((space_dimension(idomn)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  types)));
 prefix : INTEGER := 0;
 espc : extended_tuple_space;
 vdomn : maths_space;
 END_LOCAL
;
 IF  tupled THEN  idomn := factor1(idomn);
 types := TYPEOF(idomn);
 END_IF ;
 IF  igrl.lower_limit_neg_infinity THEN  prefix := prefix + 1;
 END_IF ;
 IF  igrl.upper_limit_pos_infinity THEN  prefix := prefix + 1;
 END_IF ;
 vdomn := factor_space(idomn, idx);
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN types THEN  espc := idomn;
 idomn := make_extended_tuple_space(process_product_space(espc.base, idx, prefix, vdomn), espc.extender);
 ELSE  idomn := process_product_space(idomn, idx, prefix, vdomn);
 END_IF ;
 IF tupled THEN RETURN(one_tuples_of(idomn));
 ELSE RETURN(idomn);
 END_IF;
 END_FUNCTION; -- derive_definite_integral_domain

FUNCTION derive_elementary_function_domain
	(ef_val : elementary_function_enumerators) : tuple_space;
 IF NOT EXISTS(ef_val)THEN RETURN(?);
 END_IF;
 CASE ef_val OF ef_and : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
 ef_or : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_logicals));
 ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
 ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_add_i : RETURN(the_integer_tuples);
 ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_multiply_i : RETURN(the_integer_tuples);
 ef_divide_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_mod_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_eq_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_ne_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_gt_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_lt_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_ge_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_le_i : RETURN(make_uniform_product_space(the_integers, 2));
 ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_if_i : RETURN(make_listed_product_space([ the_logicals, the_integers, the_integers ]));
 ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_add_r : RETURN(the_real_tuples);
 ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_multiply_r : RETURN(the_real_tuples);
 ef_divide_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_mod_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_exponentiate_r : RETURN(make_listed_product_space([ the_nonnegative_reals, the_reals ]));
 ef_exponentiate_ri : RETURN(make_listed_product_space([ the_reals, the_integers ]));
 ef_eq_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_ne_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_gt_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_lt_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_ge_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_le_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_abs_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_acos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_asin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_atan2_r : RETURN(make_uniform_product_space(the_reals, 2));
 ef_cos_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_exp_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_ln_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_log2_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_log10_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_sin_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_if_r : RETURN(make_listed_product_space([ the_logicals, the_reals, the_reals ]));
 ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_add_c : RETURN(the_complex_tuples);
 ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_multiply_c : RETURN(the_complex_tuples);
 ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_exponentiate_ci : RETURN(make_listed_product_space([ the_complex_numbers, the_integers ]));
 ef_eq_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_ne_c : RETURN(make_uniform_product_space(the_complex_numbers, 2));
 ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_abs_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_arg_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_if_c : RETURN(make_listed_product_space([ the_logicals, the_complex_numbers, the_complex_numbers ]));
 ef_subscript_s : RETURN(make_listed_product_space([ the_strings, the_integers ]));
 ef_eq_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_ne_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_gt_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_lt_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_ge_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_le_s : RETURN(make_uniform_product_space(the_strings, 2));
 ef_subsequence_s : RETURN(make_listed_product_space([ the_strings, the_integers, the_integers ]));
 ef_concat_s : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_strings));
 ef_size_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_format : RETURN(make_listed_product_space([ the_numbers, the_strings ]));
 ef_value : RETURN(make_uniform_product_space(the_strings, 1));
 ef_like : RETURN(make_uniform_product_space(the_strings, 2));
 ef_if_s : RETURN(make_listed_product_space([ the_logicals, the_strings, the_strings ]));
 ef_subscript_b : RETURN(make_listed_product_space([ the_binarys, the_integers ]));
 ef_eq_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_ne_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_gt_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_lt_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_ge_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_le_b : RETURN(make_uniform_product_space(the_binarys, 2));
 ef_subsequence_b : RETURN(make_listed_product_space([ the_binarys, the_integers, the_integers ]));
 ef_concat_b : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_binarys));
 ef_size_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_if_b : RETURN(make_listed_product_space([ the_logicals, the_binarys, the_binarys ]));
 ef_subscript_t : RETURN(make_listed_product_space([ the_tuples, the_integers ]));
 ef_eq_t : RETURN(make_uniform_product_space(the_tuples, 2));
 ef_ne_t : RETURN(make_uniform_product_space(the_tuples, 2));
 ef_concat_t : RETURN(make_extended_tuple_space(the_zero_tuple_space, the_tuples));
 ef_size_t : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_entuple : RETURN(the_tuples);
 ef_detuple : RETURN(make_uniform_product_space(the_generics, 1));
 ef_insert : RETURN(make_listed_product_space([ the_tuples, the_generics, the_integers ]));
 ef_remove : RETURN(make_listed_product_space([ the_tuples, the_integers ]));
 ef_if_t : RETURN(make_listed_product_space([ the_logicals, the_tuples, the_tuples ]));
 ef_sum_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_product_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_add_it : RETURN(make_extended_tuple_space(the_integer_tuples, the_integer_tuples));
 ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
 ef_scalar_mult_it : RETURN(make_listed_product_space([ the_integers, the_integer_tuples ]));
 ef_dot_prod_it : RETURN(make_uniform_product_space(the_integer_tuples, 2));
 ef_sum_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_product_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_add_rt : RETURN(make_extended_tuple_space(the_real_tuples, the_real_tuples));
 ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
 ef_scalar_mult_rt : RETURN(make_listed_product_space([ the_reals, the_real_tuples ]));
 ef_dot_prod_rt : RETURN(make_uniform_product_space(the_real_tuples, 2));
 ef_norm_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_sum_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_product_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_add_ct : RETURN(make_extended_tuple_space(the_complex_tuples, the_complex_tuples));
 ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
 ef_scalar_mult_ct : RETURN(make_listed_product_space([ the_complex_numbers, the_complex_tuples ]));
 ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_tuples, 2));
 ef_norm_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_if : RETURN(make_listed_product_space([ the_logicals, the_generics, the_generics ]));
 ef_ensemble : RETURN(the_tuples);
 ef_member_of : RETURN(make_listed_product_space([ the_generics, the_maths_spaces ]));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- derive_elementary_function_domain

FUNCTION derive_elementary_function_range
	(ef_val : elementary_function_enumerators) : tuple_space;
 IF NOT EXISTS(ef_val)THEN RETURN(?);
 END_IF;
 CASE ef_val OF ef_and : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_or : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_not : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_xor : RETURN(make_uniform_product_space(the_logicals, 2));
 ef_negate_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_add_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_subtract_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_multiply_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_divide_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_mod_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_exponentiate_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_eq_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_i : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_abs_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_if_i : RETURN(make_uniform_product_space(the_integers, 1));
 ef_negate_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_reciprocal_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_add_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_subtract_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_multiply_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_divide_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_mod_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_exponentiate_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_exponentiate_ri : RETURN(make_uniform_product_space(the_reals, 1));
 ef_eq_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_r : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_abs_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_acos_r : RETURN(make_uniform_product_space(the_zero_pi_interval, 1));
 ef_asin_r : RETURN(make_uniform_product_space(the_neghalfpi_halfpi_interval, 1));
 ef_atan2_r : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
 ef_cos_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_exp_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_ln_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_log2_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_log10_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_sin_r : RETURN(make_uniform_product_space(the_neg1_one_interval, 1));
 ef_sqrt_r : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_tan_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_if_r : RETURN(make_uniform_product_space(the_reals, 1));
 ef_negate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_reciprocal_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_add_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_subtract_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_multiply_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_divide_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exponentiate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exponentiate_ci : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_eq_c : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_c : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_conjugate_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_abs_c : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_arg_c : RETURN(make_uniform_product_space(the_negpi_pi_interval, 1));
 ef_cos_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_exp_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_ln_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sin_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_sqrt_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_tan_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_if_c : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_subscript_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_eq_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_s : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_subsequence_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_concat_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_size_s : RETURN(make_uniform_product_space(the_integers, 1));
 ef_format : RETURN(make_uniform_product_space(the_strings, 1));
 ef_value : RETURN(make_uniform_product_space(the_reals, 1));
 ef_like : RETURN(make_uniform_product_space(the_booleans, 1));
 ef_if_s : RETURN(make_uniform_product_space(the_strings, 1));
 ef_subscript_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_eq_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_gt_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_lt_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ge_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_le_b : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_subsequence_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_concat_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_size_b : RETURN(make_uniform_product_space(the_integers, 1));
 ef_if_b : RETURN(make_uniform_product_space(the_binarys, 1));
 ef_subscript_t : RETURN(make_uniform_product_space(the_generics, 1));
 ef_eq_t : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_ne_t : RETURN(make_uniform_product_space(the_logicals, 1));
 ef_concat_t : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_size_t : RETURN(make_uniform_product_space(the_integers, 1));
 ef_entuple : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_detuple : RETURN(the_tuples);
 ef_insert : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_remove : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_if_t : RETURN(make_uniform_product_space(the_tuples, 1));
 ef_sum_it : RETURN(make_uniform_product_space(the_integers, 1));
 ef_product_it : RETURN(make_uniform_product_space(the_integers, 1));
 ef_add_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_subtract_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_scalar_mult_it : RETURN(make_uniform_product_space(the_integer_tuples, 1));
 ef_dot_prod_it : RETURN(make_uniform_product_space(the_integers, 1));
 ef_sum_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_product_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_add_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_subtract_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_scalar_mult_rt : RETURN(make_uniform_product_space(the_real_tuples, 1));
 ef_dot_prod_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_norm_rt : RETURN(make_uniform_product_space(the_reals, 1));
 ef_sum_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_product_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_add_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_subtract_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_scalar_mult_ct : RETURN(make_uniform_product_space(the_complex_tuples, 1));
 ef_dot_prod_ct : RETURN(make_uniform_product_space(the_complex_numbers, 1));
 ef_norm_ct : RETURN(make_uniform_product_space(the_nonnegative_reals, 1));
 ef_if : RETURN(make_uniform_product_space(the_generics, 1));
 ef_ensemble : RETURN(make_uniform_product_space(the_maths_spaces, 1));
 ef_member_of : RETURN(make_uniform_product_space(the_logicals, 1));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- derive_elementary_function_range

FUNCTION derive_finite_function_domain
	(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
 LOCAL
 result : SET OF maths_value := [ ];
 END_LOCAL
;
 result := result + list_selected_components(pairs, 1);
 RETURN(one_tuples_of(make_finite_space(result)));
 END_FUNCTION; -- derive_finite_function_domain

FUNCTION derive_finite_function_range
	(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : tuple_space;
 LOCAL
 result : SET OF maths_value := [ ];
 END_LOCAL
;
 result := result + list_selected_components(pairs, 2);
 RETURN(one_tuples_of(make_finite_space(result)));
 END_FUNCTION; -- derive_finite_function_range

FUNCTION derive_function_domain
	(func : maths_function) : tuple_space;
 LOCAL
 typenames : SET OF  STRING := stripped_typeof(func);
 tspace : tuple_space := make_listed_product_space([ ]);
 shape : LIST  OF  positive_integer;
 sidxs : LIST  OF  INTEGER := [ 0 ];
 itvl : finite_integer_interval;
 factors : LIST OF finite_integer_interval := [ ];
 is_uniform : BOOLEAN := TRUE;
 END_LOCAL
;
 IF  'FINITE_FUNCTION' IN  typenames THEN  RETURN(derive_finite_function_domain(func \ finite_function.pairs));
 END_IF ;
 IF  'CONSTANT_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ constant_function.source_of_domain));
 END_IF ;
 IF  'SELECTOR_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ selector_function.source_of_domain));
 END_IF ;
 IF  'ELEMENTARY_FUNCTION' IN  typenames THEN  RETURN(derive_elementary_function_domain(func \ elementary_function.func_id));
 END_IF ;
 IF  'RESTRICTION_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(func \ restriction_function.operand));
 END_IF ;
 IF  'REPACKAGING_FUNCTION' IN  typenames THEN  IF  func \ repackaging_function.input_repack = ro_nochange THEN  RETURN(func \ repackaging_function.operand.domain);
 END_IF ;
 IF  func \ repackaging_function.input_repack = ro_wrap_as_tuple THEN  RETURN(factor1(func \ repackaging_function.operand.domain));
 END_IF ;
 IF  func \ repackaging_function.input_repack = ro_unwrap_tuple THEN  RETURN(one_tuples_of(func \ repackaging_function.operand.domain));
 END_IF ;
 RETURN(?);
 END_IF ;
 IF  'REINDEXED_ARRAY_FUNCTION' IN  typenames THEN  shape := shape_of_array(func \ unary_generic_expression.operand);
 sidxs := func \ reindexed_array_function.starting_indices;
 REPEAT  i := 1 TO  SIZEOF(shape);
 itvl := make_finite_integer_interval(sidxs [ i ], sidxs [ i ] + shape [ i ] - 1);
 INSERT(factors, itvl, i - 1);
 IF  shape [ i ] <> shape [ 1 ] THEN  is_uniform := FALSE ;
 END_IF ;
 END_REPEAT ;
 IF  is_uniform THEN  RETURN(make_uniform_product_space(factors [ 1 ], SIZEOF(shape)));
 END_IF ;
 RETURN(make_listed_product_space(factors));
 END_IF ;
 IF  'SERIES_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(func \ series_composed_function.operands [ 1 ].domain);
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ parallel_composed_function.source_of_domain));
 END_IF ;
 IF  'EXPLICIT_TABLE_FUNCTION' IN  typenames THEN  shape := func \ explicit_table_function.shape;
 sidxs [ 1 ] := func \ explicit_table_function.index_base;
 REPEAT  i := 1 TO  SIZEOF(shape);
 itvl := make_finite_integer_interval(sidxs [ 1 ], sidxs [ 1 ] + shape [ i ] - 1);
 INSERT(factors, itvl, i - 1);
 IF  shape [ i ] <> shape [ 1 ] THEN  is_uniform := FALSE;
 END_IF ;
 END_REPEAT ;
 IF  is_uniform THEN  RETURN(make_uniform_product_space(factors [ 1 ], SIZEOF(shape)));
 END_IF ;
 RETURN(make_listed_product_space(factors));
 END_IF ;
 IF  'HOMOGENEOUS_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ homogeneous_linear_function.mat.range), func \ homogeneous_linear_function.mat \ explicit_table_function.shape [ func \ homogeneous_linear_function.sum_index ])));
 END_IF ;
 IF  'GENERAL_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ general_linear_function.mat.range), func \ general_linear_function.mat \ explicit_table_function.shape [ func \ general_linear_function.sum_index ] - 1)));
 END_IF ;
 IF  'B_SPLINE_BASIS' IN  typenames THEN  RETURN(one_tuples_of(make_finite_real_interval(func \ b_spline_basis.repeated_knots [ func \ b_spline_basis.order ], closed, func \ b_spline_basis.repeated_knots [ func \ b_spline_basis.num_basis + 1 ], closed)));
 END_IF ;
 IF  'B_SPLINE_FUNCTION' IN  typenames THEN  REPEAT  i := 1 TO  SIZEOF(func \ b_spline_function.basis);
 tspace := assoc_product_space(tspace, func \ b_spline_function.basis [ i ].domain);
 END_REPEAT ;
 RETURN(one_tuples_of(tspace));
 END_IF ;
 IF  'RATIONALIZE_FUNCTION' IN  typenames THEN  RETURN(func \ rationalize_function.fun.domain);
 END_IF ;
 IF  'PARTIAL_DERIVATIVE_FUNCTION' IN  typenames THEN  RETURN(func \ partial_derivative_function.derivand.domain);
 END_IF ;
 IF  'DEFINITE_INTEGRAL_FUNCTION' IN  typenames THEN  RETURN(derive_definite_integral_domain(func));
 END_IF ;
 IF  'ABSTRACTED_EXPRESSION_FUNCTION' IN  typenames THEN  REPEAT i := 1 TO SIZEOF(func \ abstracted_expression_function.variables);
 tspace := assoc_product_space(tspace, one_tuples_of(values_space_of(func \ abstracted_expression_function.variables [ i ])));
 END_REPEAT;
 RETURN(tspace);
 END_IF ;
 IF  'EXPRESSION_DENOTED_FUNCTION' IN  typenames THEN  RETURN(values_space_of(func \ expression_denoted_function.expr)\ function_space.domain_argument);
 END_IF ;
 IF  'IMPORTED_POINT_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_listed_product_space([ ])));
 END_IF ;
 IF  'IMPORTED_CURVE_FUNCTION' IN  typenames THEN  RETURN(func \ imported_curve_function.parametric_domain);
 END_IF ;
 IF  'IMPORTED_SURFACE_FUNCTION' IN  typenames THEN  RETURN(func \ imported_surface_function.parametric_domain);
 END_IF ;
 IF  'IMPORTED_VOLUME_FUNCTION' IN  typenames THEN  RETURN(func \ imported_volume_function.parametric_domain);
 END_IF ;
 IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN RETURN(func \ application_defined_function.explicit_domain);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- derive_function_domain

FUNCTION derive_function_range
	(func : maths_function) : tuple_space;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(func);
 tspace : tuple_space := make_listed_product_space([ ]);
 m, n : nonnegative_integer := 0;
 END_LOCAL
;
 IF  'FINITE_FUNCTION' IN  typenames THEN  RETURN(derive_finite_function_range(func \ finite_function.pairs));
 END_IF ;
 IF  'CONSTANT_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_finite_space([ func \ constant_function.sole_output ])));
 END_IF ;
 IF  'SELECTOR_FUNCTION' IN  typenames THEN  tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(tspace))THEN  tspace := factor1(tspace);
 END_IF ;
 RETURN(one_tuples_of(factor_space(tspace, func \ selector_function.selector)));
 END_IF ;
 IF  'ELEMENTARY_FUNCTION' IN  typenames THEN  RETURN(derive_elementary_function_range(func \ elementary_function.func_id));
 END_IF ;
 IF  'RESTRICTION_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(func \ restriction_function.operand));
 END_IF ;
 IF  'REPACKAGING_FUNCTION' IN  typenames THEN  tspace := func \ repackaging_function.operand.range;
 IF  func \ repackaging_function.output_repack = ro_wrap_as_tuple THEN  tspace := one_tuples_of(tspace);
 END_IF ;
 IF  func \ repackaging_function.output_repack = ro_unwrap_tuple THEN  tspace := factor1(tspace);
 END_IF ;
 IF  func \ repackaging_function.selected_output > 0 THEN  tspace := one_tuples_of(factor_space(tspace, func \ repackaging_function.selected_output));
 END_IF ;
 RETURN(tspace);
 END_IF ;
 IF  'REINDEXED_ARRAY_FUNCTION' IN  typenames THEN  RETURN(func \ unary_generic_expression.operand \ maths_function.range);
 END_IF ;
 IF  'SERIES_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(func \ series_composed_function.operands [ SIZEOF(func \ series_composed_function.operands)].range);
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  typenames THEN  RETURN(func \ parallel_composed_function.final_function.range);
 END_IF ;
 IF  'EXPLICIT_TABLE_FUNCTION' IN  typenames THEN  IF  'LISTED_REAL_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_reals));
 END_IF ;
 IF  'LISTED_INTEGER_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_integers));
 END_IF ;
 IF  'LISTED_LOGICAL_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_logicals));
 END_IF ;
 IF  'LISTED_STRING_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_strings));
 END_IF ;
 IF  'LISTED_COMPLEX_NUMBER_DATA' IN  typenames THEN  RETURN(one_tuples_of(the_complex_numbers));
 END_IF ;
 IF  'LISTED_DATA' IN  typenames THEN  RETURN(one_tuples_of(func \ listed_data.value_range));
 END_IF ;
 IF  'EXTERNALLY_LISTED_DATA' IN  typenames THEN  RETURN(one_tuples_of(func \ externally_listed_data.value_range));
 END_IF ;
 IF  'LINEARIZED_TABLE_FUNCTION' IN  typenames THEN  RETURN(func \ linearized_table_function.source.range);
 END_IF ;
 IF  'BASIC_SPARSE_MATRIX' IN  typenames THEN  RETURN(func \ basic_sparse_matrix.val.range);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF  'HOMOGENEOUS_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ homogeneous_linear_function.mat.range), func \ homogeneous_linear_function.mat \ explicit_table_function.shape [ 3 - func \ homogeneous_linear_function.sum_index ])));
 END_IF ;
 IF  'GENERAL_LINEAR_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(factor1(func \ general_linear_function.mat.range), func \ general_linear_function.mat \ explicit_table_function.shape [ 3 - func \ general_linear_function.sum_index ])));
 END_IF ;
 IF  'B_SPLINE_BASIS' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, func \ b_spline_basis.num_basis)));
 END_IF ;
 IF  'B_SPLINE_FUNCTION' IN  typenames THEN  tspace := factor1(func \ b_spline_function.coef.domain);
 m := SIZEOF(func \ b_spline_function.basis);
 n := space_dimension(tspace);
 IF  m = n THEN  RETURN(one_tuples_of(the_reals));
 END_IF ;
 IF  m = n - 1 THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, factor_space(tspace, n)\ finite_integer_interval.size)));
 END_IF ;
 tspace := extract_factors(tspace, m + 1, n);
 RETURN(one_tuples_of(make_function_space(sc_equal, tspace, sc_subspace, number_superspace_of(func \ b_spline_function.coef.range))));
 END_IF ;
 IF  'RATIONALIZE_FUNCTION' IN  typenames THEN  tspace := factor1(func \ rationalize_function.fun.range);
 n := space_dimension(tspace);
 RETURN(one_tuples_of(make_uniform_product_space(number_superspace_of(factor1(tspace)), n - 1)));
 END_IF ;
 IF  'PARTIAL_DERIVATIVE_FUNCTION' IN  typenames THEN  RETURN(drop_numeric_constraints(func \ partial_derivative_function.derivand.range));
 END_IF ;
 IF  'DEFINITE_INTEGRAL_FUNCTION' IN  typenames THEN  RETURN(drop_numeric_constraints(func \ definite_integral_function.integrand.range));
 END_IF ;
 IF  'ABSTRACTED_EXPRESSION_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(values_space_of(func \ abstracted_expression_function.expr)));
 END_IF ;
 IF  'EXPRESSION_DENOTED_FUNCTION' IN  typenames THEN  RETURN(values_space_of(func \ expression_denoted_function.expr)\ function_space.range_argument);
 END_IF ;
 IF  'IMPORTED_POINT_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_point_function.geometry))));
 END_IF ;
 IF  'IMPORTED_CURVE_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_curve_function.geometry))));
 END_IF ;
 IF  'IMPORTED_SURFACE_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_surface_function.geometry))));
 END_IF ;
 IF  'IMPORTED_VOLUME_FUNCTION' IN  typenames THEN  RETURN(one_tuples_of(make_uniform_product_space(the_reals, dimension_of(func \ imported_volume_function.geometry))));
 END_IF ;
 IF 'APPLICATION_DEFINED_FUNCTION' IN typenames THEN RETURN(func \ application_defined_function.explicit_range);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- derive_function_range

FUNCTION domain_from
	(ref : maths_space_or_function) : tuple_space;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(ref);
 func : maths_function;
 END_LOCAL
;
 IF  NOT EXISTS(ref)THEN  RETURN(?);
 END_IF ;
 IF  'TUPLE_SPACE' IN  typenames THEN  RETURN(ref);
 END_IF ;
 IF  'MATHS_SPACE' IN  typenames THEN  RETURN(one_tuples_of(ref));
 END_IF ;
 func := ref;
 IF  'CONSTANT_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ constant_function.source_of_domain));
 END_IF ;
 IF  'SELECTOR_FUNCTION' IN  typenames THEN  RETURN(domain_from(func \ selector_function.source_of_domain));
 END_IF ;
 IF 'PARALLEL_COMPOSED_FUNCTION' IN typenames THEN RETURN(domain_from(func \ parallel_composed_function.source_of_domain));
 END_IF;
 RETURN(func.domain);
 END_FUNCTION; -- domain_from

FUNCTION dot_count
	(str : STRING) : INTEGER;
 LOCAL
 n : INTEGER := 0;
 END_LOCAL
;
 REPEAT i := 1 TO LENGTH(str);
 IF str [ i ] = '.' THEN n := n + 1;
 END_IF;
 END_REPEAT;
 RETURN(n);
 END_FUNCTION; -- dot_count

FUNCTION dotted_identifiers_syntax
	(str : STRING) : BOOLEAN;
 LOCAL
 k : positive_integer;
 m : positive_integer;
 END_LOCAL
;
 IF  NOT EXISTS(str)THEN  RETURN(FALSE );
 END_IF ;
 k := parse_express_identifier(str, 1);
 IF  k = 1 THEN  RETURN(FALSE );
 END_IF ;
 REPEAT WHILE k <= LENGTH(str);
 IF(str [ k ] <> '.')OR(k = LENGTH(str))THEN  RETURN(FALSE );
 END_IF ;
 m := parse_express_identifier(str, k + 1);
 IF m = k + 1 THEN RETURN(FALSE);
 END_IF;
 k := m;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- dotted_identifiers_syntax

FUNCTION drop_numeric_constraints
	(spc : maths_space) : maths_space;
 LOCAL
 typenames : SET OF  STRING := stripped_typeof(spc);
 tspc : listed_product_space;
 factors : LIST OF maths_space := [ ];
 xspc : extended_tuple_space;
 END_LOCAL
;
 IF  'UNIFORM_PRODUCT_SPACE' IN  typenames THEN  RETURN(make_uniform_product_space(drop_numeric_constraints(spc \ uniform_product_space.base), spc \ uniform_product_space.exponent));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  typenames THEN  tspc := spc;
 REPEAT i := 1 TO SIZEOF(tspc.factors);
 INSERT(factors, drop_numeric_constraints(tspc.factors [ i ]), i - 1);
 END_REPEAT;
 RETURN(make_listed_product_space(factors));
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN typenames THEN  xspc := spc;
 RETURN(make_extended_tuple_space(drop_numeric_constraints(xspc.base), drop_numeric_constraints(xspc.extender)));
 END_IF ;
 IF subspace_of_es(spc, es_numbers)THEN RETURN(number_superspace_of(spc));
 END_IF;
 RETURN(spc);
 END_FUNCTION; -- drop_numeric_constraints

FUNCTION enclose_cregion_in_pregion
	(crgn : cartesian_complex_number_region; centre : complex_number_literal) : polar_complex_number_region;
 LOCAL
 xitv, yitv : real_interval;
 is_xmin, is_xmax, is_ymin, is_ymax : BOOLEAN ;
 xmin, xmax, ymin, ymax, xc, yc : REAL  := 0.0;
 xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN  := FALSE ;
 rmin, rmax : REAL  := - 1.0;
 amin : REAL  := 4.0;
 amax : REAL  := - 4.0;
 rmax_exists, outside : BOOLEAN  := TRUE;
 rmin_in, rmax_in, amin_in, amax_in : BOOLEAN  := FALSE ;
 ab, a, r : REAL := 0.0;
 incl : BOOLEAN;
 ritv : real_interval;
 aitv : finite_real_interval;
 minclo, maxclo : open_closed := open;
 END_LOCAL
;
 IF  NOT  EXISTS(crgn)OR NOT  EXISTS(centre)THEN  RETURN(?);
 END_IF ;
 xitv := crgn.real_constraint;
 yitv := crgn.imag_constraint;
 xc := centre.real_part;
 yc := centre.imag_part;
 is_xmin := min_exists(xitv);
 is_xmax := max_exists(xitv);
 is_ymin := min_exists(yitv);
 is_ymax := max_exists(yitv);
 IF  is_xmin THEN  xmin := real_min(xitv);
 xmin_in := min_included(xitv);
 END_IF ;
 IF  is_xmax THEN  xmax := real_max(xitv);
 xmax_in := max_included(xitv);
 END_IF ;
 IF  is_ymin THEN  ymin := real_min(yitv);
 ymin_in := min_included(yitv);
 END_IF ;
 IF  is_ymax THEN  ymax := real_max(yitv);
 ymax_in := max_included(yitv);
 END_IF ;
 rmax_exists := is_xmin AND  is_xmax AND  is_ymin AND  is_ymax;
 IF  is_xmin AND(xc <= xmin)THEN  ab := 0.0;
 ELSE  IF  is_ymin AND(yc <= ymin)THEN  ab := 0.5 * PI ;
 ELSE  IF  is_ymax AND(yc >= ymax)THEN  ab := - 0.5 * PI ;
 ELSE  IF  is_xmax AND(xc >= xmax)THEN  ab := PI ;
 ELSE  outside := FALSE ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 IF  NOT  outside AND  NOT  rmax_exists THEN  RETURN(?);
 END_IF ;
 IF  is_xmin AND(xc <= xmin)AND  strictly_in(yc, yitv)THEN  rmin := xmin - xc;
 rmin_in := xmin_in;
 ELSE  IF  is_ymin AND(yc <= ymin)AND  strictly_in(xc, xitv)THEN  rmin := ymin - yc;
 rmin_in := ymin_in;
 ELSE  IF  is_ymax AND(yc >= ymax)AND  strictly_in(xc, xitv)THEN  rmin := yc - ymax;
 rmin_in := ymax_in;
 ELSE  IF  is_xmax AND(xc >= xmax)AND  strictly_in(yc, yitv)THEN  rmin := xc - xmax;
 rmin_in := xmax_in;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 IF  is_xmin THEN  IF  is_ymin THEN  r := SQRT((xmin - xc)** 2 +(ymin - yc)** 2);
 incl := xmin_in AND  ymin_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymin - yc, xmin - xc)- ab);
 IF  xc = xmin THEN  incl := xmin_in;
 END_IF ;
 IF  yc = ymin THEN  incl := ymin_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmin_in AND  ymin_in;
 amin := angle(0.0 - ab);
 amin_in := ymin_in;
 amax := angle(0.5 * PI  - ab);
 amax_in := xmin_in;
 END_IF ;
 END_IF ;
 ELSE  IF  xc <= xmin THEN  angle_minmax(ab, - 0.5 * PI ,(xc = xmin)AND  xmin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT  is_ymax AND(xc <= xmin)THEN  angle_minmax(ab, 0.5 * PI ,(xc = xmin)AND  xmin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  is_ymin THEN  IF  is_xmax THEN  r := SQRT((xmax - xc)** 2 +(ymin - yc)** 2);
 incl := xmax_in AND  ymin_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymin - yc, xmax - xc)- ab);
 IF  xc = xmax THEN  incl := xmax_in;
 END_IF ;
 IF  yc = ymin THEN  incl := ymin_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmax_in AND  ymin_in;
 amin := angle(0.5 * PI  - ab);
 amin_in := ymin_in;
 amax := angle(PI  - ab);
 amax_in := xmax_in;
 END_IF ;
 END_IF ;
 ELSE  IF  yc <= ymin THEN  angle_minmax(ab, 0.0,(yc = ymin)AND  ymin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT  is_xmin AND(yc <= ymin)THEN  angle_minmax(ab, PI ,(yc = ymin)AND  ymin_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  is_xmax THEN  IF  is_ymax THEN  r := SQRT((xmax - xc)** 2 +(ymax - yc)** 2);
 incl := xmax_in AND  ymax_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymax - yc, xmax - xc)- ab);
 IF  xc = xmax THEN  incl := xmax_in;
 END_IF ;
 IF  yc = ymax THEN  incl := ymax_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmax_in AND  ymax_in;
 amin := angle(- PI  - ab);
 amin_in := ymax_in;
 amax := angle(- 0.5 * PI  - ab);
 amax_in := xmax_in;
 END_IF ;
 END_IF ;
 ELSE  IF  xc >= xmax THEN  angle_minmax(ab, 0.5 * PI ,(xc = xmax)AND  xmax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT  is_ymin AND(xc >= xmax)THEN  angle_minmax(ab, - 0.5 * PI ,(xc = xmax)AND  xmax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  is_ymax THEN  IF  is_xmin THEN  r := SQRT((xmin - xc)** 2 +(ymax - yc)** 2);
 incl := xmin_in AND  ymax_in;
 IF  rmax_exists THEN  range_max(r, incl, rmax, rmax_in);
 END_IF ;
 IF  outside THEN  IF  r > 0.0 THEN  range_min(r, incl, rmin, rmin_in);
 a := angle(atan2(ymax - yc, xmin - xc)- ab);
 IF  xc = xmin THEN  incl := xmin_in;
 END_IF ;
 IF  yc = ymax THEN  incl := ymax_in;
 END_IF ;
 angle_minmax(ab, a, incl, amin, amax, amin_in, amax_in);
 ELSE  rmin := 0.0;
 rmin_in := xmin_in AND  ymax_in;
 amin := angle(0.5 * PI  - ab);
 amin_in := ymax_in;
 amax := angle(PI  - ab);
 amax_in := xmin_in;
 END_IF ;
 END_IF ;
 ELSE  IF  yc >= ymax THEN  angle_minmax(ab, PI ,(yc = ymax)AND  ymax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  NOT is_xmax AND(yc >= ymax)THEN  angle_minmax(ab, 0.0,(yc = ymax)AND ymax_in, amin, amax, amin_in, amax_in);
 END_IF ;
 END_IF ;
 IF  outside THEN  amin := angle(amin + ab);
 IF  amin = PI  THEN  amin := - PI ;
 END_IF ;
 amax := angle(amax + ab);
 IF  amax <= amin THEN  amax := amax + 2.0 * PI ;
 END_IF ;
 ELSE  amin := - PI ;
 amin_in := FALSE ;
 amax := PI;
 amax_in := FALSE;
 END_IF ;
 IF  amin_in THEN  minclo := closed;
 END_IF ;
 IF  amax_in THEN  maxclo := closed;
 END_IF ;
 aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
 minclo := open;
 IF  rmin_in THEN  minclo := closed;
 END_IF ;
 IF  rmax_exists THEN  maxclo := open;
 IF rmax_in THEN maxclo := closed;
 END_IF ;
 ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
 ELSE ritv := make_real_interval_from_min(rmin, minclo);
 END_IF;
 RETURN(make_polar_complex_number_region(centre, ritv, aitv));
 END_FUNCTION; -- enclose_cregion_in_pregion

FUNCTION enclose_pregion_in_cregion
	(prgn : polar_complex_number_region) : cartesian_complex_number_region;
 LOCAL
 xc, yc, xmin, xmax, ymin, ymax : REAL  := 0.0;
 ritv, xitv, yitv : real_interval;
 aitv : finite_real_interval;
 xmin_exists, xmax_exists, ymin_exists, ymax_exists : BOOLEAN ;
 xmin_in, xmax_in, ymin_in, ymax_in : BOOLEAN  := FALSE ;
 a, r : REAL := 0.0;
 a_in : BOOLEAN := FALSE ;
 min_clo, max_clo : open_closed := open;
 END_LOCAL
;
 IF  NOT  EXISTS(prgn)THEN  RETURN(?);
 END_IF ;
 xc := prgn.centre.real_part;
 yc := prgn.centre.imag_part;
 ritv := prgn.distance_constraint;
 aitv := prgn.direction_constraint;
 nearest_good_direction(PI , aitv, a, a_in);
 IF  COS(a)>= 0.0 THEN  xmin_exists := TRUE ;
 xmin := xc + real_min(ritv)* COS(a);
 xmin_in := a_in AND(min_included(ritv)OR(COS(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  xmin_exists := TRUE ;
 xmin := xc + real_max(ritv)* COS(a);
 xmin_in := a_in AND  max_included(ritv);
 ELSE  xmin_exists := FALSE ;
 END_IF ;
 END_IF ;
 nearest_good_direction(0.0, aitv, a, a_in);
 IF  COS(a)<= 0.0 THEN  xmax_exists := TRUE ;
 xmax := xc + real_min(ritv)* COS(a);
 xmax_in := a_in AND(min_included(ritv)OR(COS(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  xmax_exists := TRUE ;
 xmax := xc + real_max(ritv)* COS(a);
 xmax_in := a_in AND  max_included(ritv);
 ELSE  xmax_exists := FALSE ;
 END_IF ;
 END_IF ;
 nearest_good_direction(- 0.5 * PI , aitv, a, a_in);
 IF  SIN(a)>= 0.0 THEN  ymin_exists := TRUE ;
 ymin := yc + real_min(ritv)* SIN(a);
 ymin_in := a_in AND(min_included(ritv)OR(SIN(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  ymin_exists := TRUE ;
 ymin := yc + real_max(ritv)* SIN(a);
 ymin_in := a_in AND  max_included(ritv);
 ELSE  ymin_exists := FALSE ;
 END_IF ;
 END_IF ;
 nearest_good_direction(0.5 * PI, aitv, a, a_in);
 IF  SIN(a)<= 0.0 THEN  ymax_exists := TRUE ;
 ymax := yc + real_min(ritv)* SIN(a);
 ymax_in := a_in AND(min_included(ritv)OR(SIN(a)= 0.0));
 ELSE  IF  max_exists(ritv)THEN  ymax_exists := TRUE;
 ymax := yc + real_max(ritv)* SIN(a);
 ymax_in := a_in AND max_included(ritv);
 ELSE  ymax_exists := FALSE;
 END_IF ;
 END_IF ;
 IF  NOT(xmin_exists OR  xmax_exists OR  ymin_exists OR ymax_exists)THEN  RETURN(?);
 END_IF ;
 IF  xmin_exists THEN  IF  xmin_in THEN  min_clo := closed;
 ELSE  min_clo := open;
 END_IF ;
 IF  xmax_exists THEN  IF  xmax_in THEN  max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 xitv := make_finite_real_interval(xmin, min_clo, xmax, max_clo);
 ELSE  xitv := make_real_interval_from_min(xmin, min_clo);
 END_IF ;
 ELSE  IF  xmax_exists THEN  IF  xmax_in THEN  max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 xitv := make_real_interval_to_max(xmax, max_clo);
 ELSE  xitv := the_reals;
 END_IF ;
 END_IF ;
 IF  ymin_exists THEN  IF  ymin_in THEN  min_clo := closed;
 ELSE  min_clo := open;
 END_IF ;
 IF  ymax_exists THEN  IF  ymax_in THEN  max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 yitv := make_finite_real_interval(ymin, min_clo, ymax, max_clo);
 ELSE  yitv := make_real_interval_from_min(ymin, min_clo);
 END_IF ;
 ELSE  IF  ymax_exists THEN  IF ymax_in THEN max_clo := closed;
 ELSE  max_clo := open;
 END_IF ;
 yitv := make_real_interval_to_max(ymax, max_clo);
 ELSE yitv := the_reals;
 END_IF ;
 END_IF;
 RETURN(make_cartesian_complex_number_region(xitv, yitv));
 END_FUNCTION; -- enclose_pregion_in_cregion

FUNCTION enclose_pregion_in_pregion
	(prgn : polar_complex_number_region; centre : complex_number_literal) : polar_complex_number_region;
 LOCAL
 ritp, ritv : real_interval;
 aitp, aitv : finite_real_interval;
 xp, yp, xc, yc, rmax, rmin, amin, amax, rc, acp, apc : REAL  := 0.0;
 rmax_in, rmin_in, amin_in, amax_in : BOOLEAN  := FALSE ;
 rmxp, rmnp, x, y, r, a, ab, r0, a0, r1, a1, r2, a2, r3, a3 : REAL := 0.0;
 in0, in1, in2, in3, inn : BOOLEAN := FALSE ;
 minclo, maxclo : open_closed := open;
 END_LOCAL
;
 IF  NOT  EXISTS(prgn)OR  NOT  EXISTS(centre)THEN  RETURN(?);
 END_IF ;
 xp := prgn.centre.real_part;
 yp := prgn.centre.imag_part;
 ritp := prgn.distance_constraint;
 aitp := prgn.direction_constraint;
 xc := centre.real_part;
 yc := centre.imag_part;
 IF(xc = xp)AND(yc = yp)THEN  RETURN(prgn);
 END_IF ;
 rc := SQRT((xp - xc)** 2 +(yp - yc)** 2);
 acp := atan2(yp - yc, xp - xc);
 apc := atan2(yc - yp, xc - xp);
 rmnp := real_min(ritp);
 IF  max_exists(ritp)THEN  rmxp := real_max(ritp);
 IF  aitp.max - aitp.min = 2.0 * PI  THEN  inn := NOT  max_included(aitp);
 a := angle2(aitp.min);
 rmax := rc + rmxp;
 rmax_in := max_included(ritp);
 IF  inn AND(acp = a)THEN  rmax_in := FALSE ;
 END_IF ;
 IF  rc > rmxp THEN  a0 := ASIN(rmxp / rc);
 amin := angle2(acp - a0);
 amin_in := max_included(ritp);
 IF  amin = PI  THEN  amin := - PI ;
 END_IF ;
 amax := angle2(acp + a0);
 amax_in := amin_in;
 IF  amax < amin THEN  amax := amax + 2.0 * PI ;
 END_IF ;
 rmin := rc - rmxp;
 rmin_in := amin_in;
 IF  inn THEN  IF  apc = a THEN  rmin_in := FALSE ;
 END_IF ;
 IF  angle2(amin + 0.5 * PI)= a THEN  amin_in := FALSE ;
 END_IF ;
 IF  angle2(amax - 0.5 * PI)= a THEN  amax_in := FALSE ;
 END_IF ;
 END_IF ;
 ELSE  IF  rc = rmxp THEN  amin := angle2(acp - 0.5 * PI );
 amin_in := FALSE ;
 IF  amin = PI  THEN  amin := - PI ;
 END_IF ;
 amax := angle2(acp + 0.5 * PI );
 amax_in := FALSE ;
 IF  amax < amin THEN  amax := amax + 2.0 * PI ;
 END_IF ;
 rmin := 0.0;
 rmin_in := max_included(ritp);
 IF  inn AND(apc = a)THEN  rmin_in := FALSE ;
 END_IF ;
 ELSE  IF  rc > rmnp THEN  IF  inn AND(apc = a)THEN  rmin := 0.0;
 rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  rmin := 0.0;
 rmin_in := TRUE ;
 amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 END_IF ;
 ELSE  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 IF  inn THEN  IF  apc = a THEN  rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  IF  acp = a THEN  amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 ELSE  x := xp + rmxp * COS(aitp.min)- xc;
 y := yp + rmxp * SIN(aitp.min)- yc;
 r0 := SQRT(x ** 2 + y ** 2);
 in0 := max_included(ritp)AND  min_included(aitp);
 IF  r0 <> 0.0 THEN  a0 := atan2(y, x);
 END_IF ;
 x := xp + rmxp * COS(aitp.max)- xc;
 y := yp + rmxp * SIN(aitp.max)- yc;
 r1 := SQRT(x ** 2 + y ** 2);
 in1 := max_included(ritp)AND  max_included(aitp);
 IF  r1 <> 0.0 THEN  a1 := atan2(y, x);
 END_IF ;
 x := xp + rmnp * COS(aitp.max)- xc;
 y := yp + rmnp * SIN(aitp.max)- yc;
 r2 := SQRT(x ** 2 + y ** 2);
 in2 := min_included(ritp)AND  max_included(aitp);
 IF  r2 <> 0.0 THEN  a2 := atan2(y, x);
 ELSE  a2 := a1;
 in2 := in1;
 END_IF ;
 IF  r1 = 0.0 THEN  a1 := a2;
 in1 := in2;
 END_IF ;
 x := xp + rmnp * COS(aitp.min)- xc;
 y := yp + rmnp * SIN(aitp.min)- yc;
 r3 := SQRT(x ** 2 + y ** 2);
 in3 := min_included(ritp)AND  min_included(aitp);
 IF  r3 <> 0.0 THEN  a3 := atan2(y, x);
 ELSE  a3 := a0;
 in3 := in0;
 END_IF ;
 IF  r0 = 0.0 THEN  a0 := a3;
 in0 := in3;
 END_IF ;
 IF  rmnp = 0.0 THEN  in2 := min_included(ritp);
 in3 := in2;
 END_IF ;
 IF(apc = angle2(aitp.min))OR(acp = angle2(aitp.min))THEN  in0 := min_included(aitp);
 in3 := in0;
 ELSE  IF(apc = angle2(aitp.max))OR(acp = angle2(aitp.max))THEN  in1 := max_included(aitp);
 in2 := in1;
 END_IF ;
 END_IF ;
 IF  strictly_in2(acp, aitp)THEN  rmax := rc + rmxp;
 rmax_in := max_included(ritp);
 ELSE  rmax := r0;
 rmax_in := in0;
 IF  rmax = r1 THEN  rmax_in := rmax_in OR  in1;
 END_IF ;
 IF  rmax < r1 THEN  rmax := r1;
 rmax_in := in1;
 END_IF ;
 IF  rmax = r2 THEN  rmax_in := rmax_in OR  in2;
 END_IF ;
 IF  rmax < r2 THEN  rmax := r2;
 rmax_in := in2;
 END_IF ;
 IF  rmax = r3 THEN  rmax_in := rmax_in OR  in3;
 END_IF ;
 IF  rmax < r3 THEN  rmax := r3;
 rmax_in := in3;
 END_IF ;
 END_IF ;
 IF  strictly_in2(apc, aitp)THEN  IF  rc >= rmxp THEN  rmin := rc - rmxp;
 rmin_in := max_included(ritp);
 ELSE  IF  rc <= rmnp THEN  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 ELSE  rmin := 0.0;
 rmin_in := TRUE ;
 END_IF ;
 END_IF ;
 ELSE  rmin := r0;
 rmin_in := in0;
 a := apc - aitp.min;
 r := rc * COS(a);
 IF  { rmnp < r < rmxp } THEN  rmin := rc * SIN(ABS(a));
 rmin_in := min_included(aitp);
 END_IF ;
 a := apc - aitp.max;
 r := rc * COS(a);
 IF  { rmnp < r < rmxp } THEN  r := rc * SIN(ABS(a));
 inn := max_included(aitp);
 IF  r = rmin THEN  rmin_in := rmin_in OR  inn;
 END_IF ;
 IF  r < rmin THEN  rmin := r;
 rmin_in := inn;
 END_IF ;
 END_IF ;
 IF  r1 = rmin THEN  rmin_in := rmin_in OR  in1;
 END_IF ;
 IF  r1 < rmin THEN  rmin := r1;
 rmin_in := in1;
 END_IF ;
 IF  r2 = rmin THEN  rmin_in := rmin_in OR  in2;
 END_IF ;
 IF  r2 < rmin THEN  rmin := r2;
 rmin_in := in2;
 END_IF ;
 IF  r3 = rmin THEN  rmin_in := rmin_in OR  in3;
 END_IF ;
 IF  r3 < rmin THEN  rmin := r3;
 rmin_in := in3;
 END_IF ;
 END_IF ;
 IF  rc >= rmxp THEN  ab := acp;
 find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
 a := ACOS(rmxp / rc);
 IF  strictly_in2(apc - a, aitp)THEN  amin := ab - ASIN(rmxp / rc);
 amin_in := max_included(ritp);
 END_IF ;
 IF  strictly_in2(apc + a, aitp)THEN  amax := ab + ASIN(rmxp / rc);
 amax_in := max_included(ritp);
 END_IF ;
 angle_range(amin, amax);
 ELSE  IF  rc > rmnp THEN  ab := angle2(0.5 *(aitp.min + aitp.max));
 find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
 ELSE  ab := angle2(0.5 *(aitp.min + aitp.max));
 a0 := angle2(a0 - ab);
 a1 := angle2(a1 - ab);
 a2 := angle2(a2 - ab);
 a3 := angle2(a3 - ab);
 IF  a3 > a2 THEN  a2 := a2 + 2.0 * PI ;
 END_IF ;
 IF  a0 > a1 THEN  a0 := a0 + 2.0 * PI ;
 END_IF ;
 IF  a3 < a0 THEN  amin := a3;
 amin_in := in3;
 ELSE  amin := a0;
 amin_in := in0;
 END_IF ;
 IF  a2 > a1 THEN  amax := a2;
 amax_in := in2;
 ELSE  amax := a1;
 amax_in := in1;
 END_IF ;
 IF(amax - amin > 2.0 * PI)OR((amax - amin = 2.0 * PI)AND(amin_in OR  amax_in))THEN  amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 ELSE  amin := amin + ab;
 amax := amax + ab;
 angle_range(amin, amax);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 IF  rmin_in THEN  minclo := closed;
 END_IF ;
 IF  rmax_in THEN  maxclo := closed;
 END_IF ;
 ritv := make_finite_real_interval(rmin, minclo, rmax, maxclo);
 ELSE  IF(rc > rmnp)AND  strictly_in2(apc, aitp)THEN  RETURN(?);
 END_IF ;
 IF  aitp.max - aitp.min = 2.0 * PI  THEN  a := angle2(aitp.min);
 IF  rc > rmnp THEN  IF  max_included(aitp)THEN  RETURN(?);
 END_IF ;
 rmin := 0.0;
 rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 amin := - PI ;
 amin_in := FALSE ;
 amax := PI ;
 amax_in := TRUE ;
 IF  NOT max_included(aitp)THEN  IF  apc = a THEN  rmin_in := FALSE ;
 amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 ELSE  IF  acp = a THEN  amin := aitp.min;
 amin_in := FALSE ;
 amax := aitp.max;
 amax_in := FALSE ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 ELSE  a0 := angle2(aitp.min);
 in0 := FALSE ;
 a1 := angle2(aitp.max);
 in1 := FALSE ;
 x := xp + rmnp * COS(aitp.max)- xc;
 y := yp + rmnp * SIN(aitp.max)- yc;
 r2 := SQRT(x ** 2 + y ** 2);
 in2 := min_included(ritp)AND  max_included(aitp);
 IF  r2 <> 0.0 THEN  a2 := atan2(y, x);
 ELSE  a2 := a1;
 in2 := in1;
 END_IF ;
 x := xp + rmnp * COS(aitp.min)- xc;
 y := yp + rmnp * SIN(aitp.min)- yc;
 r3 := SQRT(x ** 2 + y ** 2);
 in3 := min_included(ritp)AND  min_included(aitp);
 IF  r3 <> 0.0 THEN  a3 := atan2(y, x);
 ELSE  a3 := a0;
 in3 := in0;
 END_IF ;
 IF  rmnp = 0.0 THEN  in2 := min_included(ritp);
 in3 := in2;
 END_IF ;
 IF(apc = angle2(aitp.min))OR(acp = angle2(aitp.min))THEN  in0 := min_included(aitp);
 in3 := in0;
 ELSE  IF(apc = angle2(aitp.max))OR(acp = angle2(aitp.max))THEN  in1 := max_included(aitp);
 in2 := in1;
 END_IF ;
 END_IF ;
 IF  strictly_in2(apc, aitp)THEN  rmin := rmnp - rc;
 rmin_in := min_included(ritp);
 ELSE  rmin := r2;
 rmin_in := in2;
 a := apc - aitp.min;
 r := rc * COS(a);
 IF  rmnp < r THEN  rmin := rc * SIN(ABS(a));
 rmin_in := min_included(aitp);
 END_IF ;
 a := apc - aitp.max;
 r := rc * COS(a);
 IF  rmnp < r THEN  r := rc * SIN(ABS(a));
 inn := max_included(aitp);
 IF  r = rmin THEN  rmin_in := rmin_in OR  inn;
 END_IF ;
 IF  r < rmin THEN  rmin := r;
 rmin_in := inn;
 END_IF ;
 END_IF ;
 IF  r3 = rmin THEN  rmin_in := rmin_in OR  in3;
 END_IF ;
 IF  r3 < rmin THEN  rmin := r3;
 rmin_in := in3;
 END_IF ;
 END_IF ;
 ab := angle2(0.5 *(aitp.min + aitp.max));
 IF  rc > rmnp THEN  find_aminmax(ab, a0, a1, a2, a3, in0, in1, in2, in3, amin, amax, amin_in, amax_in);
 ELSE  a0 := angle2(a0 - ab);
 a1 := angle2(a1 - ab);
 a2 := angle2(a2 - ab);
 a3 := angle2(a3 - ab);
 IF  a3 > a2 THEN  a2 := a2 + 2.0 * PI ;
 END_IF ;
 IF  a0 > a1 THEN  a0 := a0 + 2.0 * PI ;
 END_IF ;
 IF  a3 < a0 THEN  amin := a3;
 amin_in := in3;
 ELSE  amin := a0;
 amin_in := in0;
 END_IF ;
 IF  a2 > a1 THEN  amax := a2;
 amax_in := in2;
 ELSE  amax := a1;
 amax_in := in1;
 END_IF ;
 IF(amax - amin > 2.0 * PI)OR((amax - amin = 2.0 * PI)AND(amin_in OR amax_in))THEN  amin := - PI ;
 amin_in := FALSE;
 amax := PI;
 amax_in := TRUE;
 IF(rmin = 0.0)AND rmin_in THEN  RETURN(?);
 END_IF ;
 ELSE amin := amin + ab;
 amax := amax + ab;
 angle_range(amin, amax);
 END_IF ;
 END_IF ;
 END_IF ;
 IF  rmin_in THEN  minclo := closed;
 END_IF ;
 ritv := make_real_interval_from_min(rmin, minclo);
 END_IF ;
 minclo := open;
 maxclo := open;
 IF  amin_in THEN  minclo := closed;
 END_IF ;
 IF amax_in THEN maxclo := closed;
 END_IF;
 aitv := make_finite_real_interval(amin, minclo, amax, maxclo);
 RETURN(make_polar_complex_number_region(centre, ritv, aitv));
 END_FUNCTION; -- enclose_pregion_in_pregion

FUNCTION equal_cregion_pregion
	(crgn : cartesian_complex_number_region; prgn : polar_complex_number_region) : LOGICAL;
 LOCAL
 arng, amin, xc, yc : REAL;
 aitv, xitv, yitv : real_interval;
 c_in : BOOLEAN;
 END_LOCAL
;
 IF  NOT  EXISTS(crgn)OR  NOT  EXISTS(prgn)THEN  RETURN(FALSE );
 END_IF ;
 IF  max_exists(prgn.distance_constraint)THEN  RETURN(FALSE );
 END_IF ;
 IF  real_min(prgn.distance_constraint)<> 0.0 THEN  RETURN(FALSE );
 END_IF ;
 c_in := min_included(prgn.distance_constraint);
 aitv := prgn.direction_constraint;
 amin := aitv.min;
 arng := aitv.max - amin;
 xc := prgn.centre.real_part;
 yc := prgn.centre.imag_part;
 xitv := crgn.real_constraint;
 yitv := crgn.imag_constraint;
 IF  arng = 0.5 * PI  THEN  IF  amin = 0.0 THEN  RETURN(NOT  max_exists(xitv)AND  NOT  max_exists(yitv)AND  min_exists(xitv)AND  min_exists(yitv)AND(real_min(xitv)= xc)AND(real_min(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  NOT  min_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  NOT  min_included(yitv))));
 END_IF ;
 IF  amin = 0.5 * PI  THEN  RETURN(max_exists(xitv)AND  NOT  max_exists(yitv)AND  NOT  min_exists(xitv)AND  min_exists(yitv)AND(real_max(xitv)= xc)AND(real_min(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  NOT  min_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  NOT  min_included(yitv))));
 END_IF ;
 IF  amin = - PI  THEN  RETURN(max_exists(xitv)AND  max_exists(yitv)AND  NOT  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_max(xitv)= xc)AND(real_max(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv)AND  NOT  max_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv)AND  NOT  max_included(yitv))));
 END_IF ;
 IF  amin = - 0.5 * PI  THEN  RETURN(NOT  max_exists(xitv)AND  max_exists(yitv)AND  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_min(xitv)= xc)AND(real_max(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv)AND  NOT  max_included(yitv))OR(NOT  c_in AND  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(xitv)AND  NOT  max_included(yitv))));
 END_IF ;
 END_IF ;
 IF  arng = PI  THEN  IF  amin = 0.0 THEN  RETURN(NOT  max_exists(xitv)AND  NOT  max_exists(yitv)AND  NOT  min_exists(xitv)AND  min_exists(yitv)AND(real_min(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  min_included(yitv))));
 END_IF ;
 IF  amin = 0.5 * PI  THEN  RETURN(max_exists(xitv)AND  NOT  max_exists(yitv)AND  NOT  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_max(xitv)= xc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(xitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(xitv))));
 END_IF ;
 IF  amin = - PI  THEN  RETURN(NOT  max_exists(xitv)AND  max_exists(yitv)AND  NOT  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_max(yitv)= yc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  max_included(yitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND  NOT  max_included(yitv))));
 END_IF ;
 IF amin = - 0.5 * PI THEN RETURN(NOT  max_exists(xitv)AND  NOT  max_exists(yitv)AND  min_exists(xitv)AND  NOT  min_exists(yitv)AND(real_min(xitv)= xc)AND((c_in AND  min_included(aitv)AND  max_included(aitv)AND  min_included(xitv))OR(NOT  c_in AND  NOT  min_included(aitv)AND  NOT  max_included(aitv)AND NOT min_included(xitv))));
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- equal_cregion_pregion

FUNCTION equal_maths_functions
	(fun1 : maths_function; fun2 : maths_function) : LOGICAL;
 LOCAL
 cum : LOGICAL;
 END_LOCAL
;
 IF  fun1 = fun2 THEN  RETURN(TRUE);
 END_IF ;
 cum := equal_maths_spaces(fun1.domain, fun2.domain);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 cum := cum AND equal_maths_spaces(fun1.range, fun2.range);
 IF cum = FALSE  THEN RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- equal_maths_functions

FUNCTION equal_maths_spaces
	(spc1 : maths_space; spc2 : maths_space) : LOGICAL;
 LOCAL
 spc1types : SET  OF  STRING  := stripped_typeof(spc1);
 spc2types : SET  OF  STRING := stripped_typeof(spc2);
 set1, set2 : SET OF  maths_value;
 cum : LOGICAL  := TRUE ;
 base : maths_space;
 expnt : INTEGER;
 factors : LIST  OF  maths_space;
 factors2 : LIST OF maths_space;
 fs1, fs2 : function_space;
 cum2 : LOGICAL;
 END_LOCAL
;
 IF  spc1 = spc2 THEN  RETURN(TRUE );
 END_IF ;
 IF  'FINITE_SPACE' IN  spc1types THEN  set1 := spc1 \ finite_space.members;
 IF  'FINITE_SPACE' IN  spc2types THEN  set2 := spc2 \ finite_space.members;
 REPEAT  i := 1 TO  SIZEOF(set1);
 cum := cum AND  member_of(set1 [ i ], spc2);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 IF  cum = TRUE THEN  REPEAT  i := 1 TO  SIZEOF(set2);
 cum := cum AND  member_of(set2 [ i ], spc1);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_IF ;
 RETURN(cum);
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN  spc2types THEN  set2 := [ ];
 REPEAT  i := spc2 \ finite_integer_interval.min TO  spc2 \ finite_integer_interval.max;
 set2 := set2 + [ i ];
 END_REPEAT ;
 RETURN(equal_maths_spaces(spc1, make_finite_space(set2)));
 END_IF ;
 END_IF ;
 IF('FINITE_INTEGER_INTERVAL' IN  spc1types)AND('FINITE_SPACE' IN  spc2types)THEN  set1 := [ ];
 REPEAT  i := spc1 \ finite_integer_interval.min TO  spc1 \ finite_integer_interval.max;
 set1 := set1 + [ i ];
 END_REPEAT ;
 RETURN(equal_maths_spaces(make_finite_space(set1), spc2));
 END_IF ;
 IF('CARTESIAN_COMPLEX_NUMBER_REGION' IN  spc1types)AND('POLAR_COMPLEX_NUMBER_REGION' IN  spc2types)THEN  RETURN(equal_cregion_pregion(spc1, spc2));
 END_IF ;
 IF('POLAR_COMPLEX_NUMBER_REGION' IN  spc1types)AND('CARTESIAN_COMPLEX_NUMBER_REGION' IN  spc2types)THEN  RETURN(equal_cregion_pregion(spc2, spc1));
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  spc1types THEN  base := spc1 \ uniform_product_space.base;
 expnt := spc1 \ uniform_product_space.exponent;
 IF  'UNIFORM_PRODUCT_SPACE' IN  spc2types THEN  IF  expnt <> spc2 \ uniform_product_space.exponent THEN  RETURN(FALSE );
 END_IF ;
 RETURN(equal_maths_spaces(base, spc2 \ uniform_product_space.base));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  spc2types THEN  factors := spc2 \ listed_product_space.factors;
 IF  expnt <> SIZEOF(factors)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(factors);
 cum := cum AND  equal_maths_spaces(base, factors [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  spc1types THEN  factors := spc1 \ listed_product_space.factors;
 IF  'UNIFORM_PRODUCT_SPACE' IN  spc2types THEN  IF  spc2 \ uniform_product_space.exponent <> SIZEOF(factors)THEN  RETURN(FALSE );
 END_IF ;
 base := spc2 \ uniform_product_space.base;
 REPEAT  i := 1 TO  SIZEOF(factors);
 cum := cum AND  equal_maths_spaces(base, factors [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  spc2types THEN  factors2 := spc2 \ listed_product_space.factors;
 IF  SIZEOF(factors)<> SIZEOF(factors2)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(factors);
 cum := cum AND  equal_maths_spaces(factors [ i ], factors2 [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 END_IF ;
 IF('EXTENDED_TUPLE_SPACE' IN  spc1types)AND('EXTENDED_TUPLE_SPACE' IN  spc2types)THEN  RETURN(equal_maths_spaces(spc1 \ extended_tuple_space.extender, spc2 \ extended_tuple_space.extender)AND  equal_maths_spaces(spc1 \ extended_tuple_space.base, spc2 \ extended_tuple_space.base));
 END_IF ;
 IF('FUNCTION_SPACE' IN  spc1types)AND('FUNCTION_SPACE' IN  spc2types)THEN  fs1 := spc1;
 fs2 := spc2;
 IF  fs1.domain_constraint <> fs2.domain_constraint THEN  IF(fs1.domain_constraint = sc_equal)OR(fs2.domain_constraint = sc_equal)THEN  RETURN(FALSE );
 END_IF ;
 IF(fs1.domain_constraint <> sc_subspace)THEN  fs1 := spc2;
 fs2 := spc1;
 END_IF ;
 IF(fs1.domain_constraint <> sc_subspace)OR(fs2.domain_constraint <> sc_member)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF  any_space_satisfies(fs1.domain_constraint, fs1.domain_argument)<> any_space_satisfies(fs2.domain_constraint, fs2.domain_argument)THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT('FINITE_SPACE' IN  stripped_typeof(fs2.domain_argument))THEN  RETURN(FALSE );
 END_IF ;
 IF  SIZEOF([ 'FINITE_SPACE', 'FINITE_INTEGER_INTERVAL' ] * stripped_typeof(fs1.domain_argument))= 0 THEN  RETURN(FALSE );
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 cum := equal_maths_spaces(fs1.domain_argument, fs2.domain_argument);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 IF  fs1.range_constraint <> fs2.range_constraint THEN  IF(fs1.range_constraint = sc_equal)OR(fs2.range_constraint = sc_equal)THEN  RETURN(FALSE );
 END_IF ;
 IF(fs1.range_constraint <> sc_subspace)THEN  fs1 := spc2;
 fs2 := spc1;
 END_IF ;
 IF(fs1.range_constraint <> sc_subspace)OR(fs2.range_constraint <> sc_member)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF  any_space_satisfies(fs1.range_constraint, fs1.range_argument)<> any_space_satisfies(fs2.range_constraint, fs2.range_argument)THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT('FINITE_SPACE' IN stripped_typeof(fs2.range_argument))THEN  RETURN(FALSE );
 END_IF ;
 IF SIZEOF([ 'FINITE_SPACE', 'FINITE_INTEGER_INTERVAL' ] * stripped_typeof(fs1.range_argument))= 0 THEN RETURN(FALSE );
 END_IF ;
 RETURN(UNKNOWN);
 END_IF ;
 cum := cum AND equal_maths_spaces(fs1.range_argument, fs2.range_argument);
 RETURN(cum);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- equal_maths_spaces

FUNCTION equal_maths_values
	(val1 : maths_value; val2 : maths_value) : LOGICAL;
 LOCAL
 types1, types2 : SET OF  STRING;
 list1, list2 : LIST OF maths_value;
 cum : LOGICAL := TRUE ;
 END_LOCAL
;
 IF  NOT  EXISTS(val1)OR  NOT  EXISTS(val2)THEN  RETURN(FALSE );
 END_IF ;
 IF  val1 = val2 THEN  RETURN(TRUE);
 END_IF ;
 types1 := stripped_typeof(val1);
 types2 := stripped_typeof(val2);
 IF('MATHS_ATOM' IN  types1)OR('COMPLEX_NUMBER_LITERAL' IN  types1)THEN  IF  'MATHS_ATOM' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'COMPLEX_NUMBER_LITERAL' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'LIST' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'MATHS_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF('MATHS_ATOM' IN  types2)OR('COMPLEX_NUMBER_LITERAL' IN  types2)THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF  'LIST' IN  types1 THEN  IF  'LIST' IN  types2 THEN  list1 := val1;
 list2 := val2;
 IF  SIZEOF(list1)<> SIZEOF(list2)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(list1);
 cum := cum AND  equal_maths_values(list1 [ i ], list2 [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 IF  'MATHS_SPACE' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'LIST' IN  types2 THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF  'MATHS_SPACE' IN  types1 THEN  IF  'MATHS_SPACE' IN  types2 THEN  RETURN(equal_maths_spaces(val1, val2));
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(FALSE );
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'MATHS_SPACE' IN  types2 THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types1 THEN  IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(equal_maths_functions(val1, val2));
 END_IF ;
 IF  'GENERIC_EXPRESSION' IN  types2 THEN  RETURN(mem_of_vs(val1, val2));
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'MATHS_FUNCTION' IN  types2 THEN  RETURN(equal_maths_values(val2, val1));
 END_IF ;
 IF('GENERIC_EXPRESSION' IN  types1)AND('GENERIC_EXPRESSION' IN types2)THEN  IF  NOT  has_values_space(val1)OR NOT  has_values_space(val2)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF NOT compatible_spaces(values_space_of(val1), values_space_of(val2))THEN RETURN(FALSE);
 END_IF ;
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- equal_maths_values

FUNCTION es_subspace_of_es
	(es1 : elementary_space_enumerators; es2 : elementary_space_enumerators) : BOOLEAN;
 IF  NOT  EXISTS(es1)OR  NOT EXISTS(es2)THEN  RETURN(FALSE );
 END_IF ;
 IF  es1 = es2 THEN  RETURN(TRUE );
 END_IF ;
 IF  es2 = es_generics THEN  RETURN(TRUE );
 END_IF ;
 IF(es1 = es_booleans)AND(es2 = es_logicals)THEN  RETURN(TRUE );
 END_IF ;
 IF(es2 = es_numbers)AND((es1 = es_complex_numbers)OR(es1 = es_reals)OR(es1 = es_integers))THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- es_subspace_of_es

FUNCTION expression_is_constant
	(expr : generic_expression) : BOOLEAN;
 RETURN(bool(SIZEOF(free_variables_of(expr))= 0));
 END_FUNCTION; -- expression_is_constant

FUNCTION extract_factors
	(tspace : tuple_space; m : INTEGER; n : INTEGER) : tuple_space;
 LOCAL
 tsp : tuple_space := the_zero_tuple_space;
 END_LOCAL
;
 REPEAT i := m TO n;
 tsp := assoc_product_space(tsp, factor_space(tspace, i));
 END_REPEAT;
 RETURN(tsp);
 END_FUNCTION; -- extract_factors

FUNCTION extremal_position_check
	(fun : linearized_table_function) : BOOLEAN;
 LOCAL
 source_domain : maths_space;
 source_interval : finite_integer_interval;
 index : INTEGER  := 1;
 base : INTEGER ;
 shape : LIST  OF  positive_integer;
 ndim : positive_integer;
 slo, shi : INTEGER ;
 sublo : LIST  OF  INTEGER  := [ ];
 subhi : LIST OF INTEGER := [ ];
 END_LOCAL
;
 IF  NOT  EXISTS(fun)THEN  RETURN(FALSE );
 END_IF ;
 source_domain := factor1(fun.source.domain);
 IF(schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(source_domain)THEN  source_domain := factor1(source_domain);
 END_IF ;
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  TYPEOF(source_domain))THEN  RETURN(FALSE );
 END_IF ;
 source_interval := source_domain;
 base := fun \ explicit_table_function.index_base;
 shape := fun \ explicit_table_function.shape;
 IF(schema_prefix + 'STANDARD_TABLE_FUNCTION')IN  TYPEOF(fun)THEN  REPEAT  j := 1 TO  SIZEOF(shape);
 index := index * shape [ j ];
 END_REPEAT ;
 index := fun.first + index - 1;
 RETURN(bool({ source_interval.min <= index <= source_interval.max }));
 END_IF ;
 IF(schema_prefix + 'REGULAR_TABLE_FUNCTION')IN TYPEOF(fun)THEN  ndim := SIZEOF(fun \ explicit_table_function.shape);
 REPEAT j := 1 TO ndim;
 slo := base;
 shi := base + shape [ j ] - 1;
 IF  fun \ regular_table_function.increments [ j ] >= 0 THEN  INSERT(sublo, slo, j - 1);
 INSERT(subhi, shi, j - 1);
 ELSE INSERT(sublo, shi, j - 1);
 INSERT(subhi, slo, j - 1);
 END_IF ;
 END_REPEAT;
 index := regular_indexing(sublo, base, shape, fun \ regular_table_function.increments, fun.first);
 IF  NOT({ source_interval.min <= index <= source_interval.max })THEN  RETURN(FALSE );
 END_IF ;
 index := regular_indexing(subhi, base, shape, fun \ regular_table_function.increments, fun.first);
 IF NOT({ source_interval.min <= index <= source_interval.max })THEN RETURN(FALSE );
 END_IF ;
 RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- extremal_position_check

FUNCTION factor1
	(tspace : tuple_space) : maths_space;
 LOCAL
 typenames : SET OF STRING := TYPEOF(tspace);
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  typenames THEN  RETURN(tspace \ uniform_product_space.base);
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  typenames THEN  RETURN(tspace \ listed_product_space.factors [ 1 ]);
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN typenames THEN RETURN(factor1(tspace \ extended_tuple_space.base));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- factor1

FUNCTION factor_space
	(tspace : tuple_space; idx : positive_integer) : maths_space;
 LOCAL
 typenames : SET OF STRING := TYPEOF(tspace);
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  typenames THEN  IF  idx <= tspace \ uniform_product_space.exponent THEN  RETURN(tspace \ uniform_product_space.base);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  typenames THEN  IF  idx <= SIZEOF(tspace \ listed_product_space.factors)THEN  RETURN(tspace \ listed_product_space.factors [ idx ]);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN typenames THEN  IF idx <= space_dimension(tspace \ extended_tuple_space.base)THEN RETURN(factor_space(tspace \ extended_tuple_space.base, idx));
 END_IF ;
 RETURN(tspace \ extended_tuple_space.extender);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- factor_space

FUNCTION fedex
	(val : AGGREGATE OF GENERIC; i : INTEGER) : GENERIC:X;
 RETURN(val [ i ]);
 END_FUNCTION; -- fedex

FUNCTION free_variables_of
	(expr : generic_expression) : SET [0:?] OF generic_variable;
 LOCAL
 typenames : SET  OF  STRING := stripped_typeof(expr);
 result : SET OF  generic_variable := [ ];
 exprs : LIST OF generic_expression := [ ];
 END_LOCAL
;
 IF  'GENERIC_LITERAL' IN  typenames THEN  RETURN(result);
 END_IF ;
 IF  'GENERIC_VARIABLE' IN  typenames THEN  result := result + expr;
 RETURN(result);
 END_IF ;
 IF  'QUANTIFIER_EXPRESSION' IN  typenames THEN  exprs := QUERY(ge <* expr \ multiple_arity_generic_expression.operands | NOT(ge IN  expr \ quantifier_expression.variables));
 REPEAT  i := 1 TO  SIZEOF(exprs);
 result := result + free_variables_of(exprs [ i ]);
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(expr \ quantifier_expression.variables);
 result := result - expr \ quantifier_expression.variables [ i ];
 END_REPEAT ;
 RETURN(result);
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  typenames THEN  RETURN(free_variables_of(expr \ unary_generic_expression.operand));
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  typenames THEN  result := free_variables_of(expr \ binary_generic_expression.operands [ 1 ]);
 RETURN(result + free_variables_of(expr \ binary_generic_expression.operands [ 2 ]));
 END_IF ;
 IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN typenames THEN REPEAT i := 1 TO SIZEOF(expr \ multiple_arity_generic_expression.operands);
 result := result + free_variables_of(expr \ multiple_arity_generic_expression.operands [ i ]);
 END_REPEAT;
 RETURN(result);
 END_IF;
 RETURN(result);
 END_FUNCTION; -- free_variables_of

FUNCTION function_applicability
	(func : maths_function_select; arguments : LIST [1:?] OF maths_value) : BOOLEAN;
 LOCAL
 domain : tuple_space := convert_to_maths_function(func).domain;
 domain_types : SET OF STRING := TYPEOF(domain);
 narg : positive_integer := SIZEOF(arguments);
 arg : generic_expression;
 END_LOCAL
;
 IF(schema_prefix + 'PRODUCT_SPACE')IN  domain_types THEN  IF  space_dimension(domain)<> narg THEN  RETURN(FALSE );
 END_IF ;
 ELSE  IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN domain_types THEN  IF  space_dimension(domain)> narg THEN  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE );
 END_IF ;
 END_IF ;
 REPEAT i := 1 TO narg;
 arg := convert_to_operand(arguments [ i ]);
 IF  NOT  has_values_space(arg)THEN  RETURN(FALSE );
 END_IF ;
 IF NOT compatible_spaces(factor_space(domain, i), values_space_of(arg))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- function_applicability

FUNCTION function_is_1d_array
	(func : maths_function) : BOOLEAN;
 LOCAL
 temp : maths_space;
 END_LOCAL
;
 IF  NOT EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 IF  space_dimension(func.domain)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(func.domain);
 IF(schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(temp)THEN  IF  space_dimension(temp)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(temp);
 END_IF ;
 IF(schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp)THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- function_is_1d_array

FUNCTION function_is_1d_table
	(func : maths_function) : BOOLEAN;
 LOCAL
 temp : maths_space;
 itvl : finite_integer_interval;
 END_LOCAL
;
 IF  NOT EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 IF  space_dimension(func.domain)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(func.domain);
 IF(schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(temp)THEN  IF  space_dimension(temp)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(temp);
 END_IF ;
 IF(schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp)THEN itvl := temp;
 RETURN(bool((itvl.min = 0)OR(itvl.min = 1)));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- function_is_1d_table

FUNCTION function_is_2d_table
	(func : maths_function) : BOOLEAN;
 LOCAL
 temp : maths_space;
 pspace : product_space;
 itvl1, itvl2 : finite_integer_interval;
 END_LOCAL
;
 IF  NOT  EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 IF  space_dimension(func.domain)<> 1 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(func.domain);
 IF  NOT('PRODUCT_SPACE' IN  stripped_typeof(temp))THEN  RETURN(FALSE );
 END_IF ;
 pspace := temp;
 IF  space_dimension(pspace)<> 2 THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(pspace);
 IF  NOT('FINITE_INTEGER_INTERVAL' IN  stripped_typeof(temp))THEN  RETURN(FALSE );
 END_IF ;
 itvl1 := temp;
 temp := factor_space(pspace, 2);
 IF NOT('FINITE_INTEGER_INTERVAL' IN stripped_typeof(temp))THEN RETURN(FALSE);
 END_IF;
 itvl2 := temp;
 RETURN(bool((itvl1.min = itvl2.min)AND((itvl1.min = 0)OR(itvl1.min = 1))));
 END_FUNCTION; -- function_is_2d_table

FUNCTION function_is_array
	(func : maths_function) : BOOLEAN;
 LOCAL
 tspace : tuple_space;
 temp : maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(tspace)))THEN  tspace := factor1(tspace);
 END_IF ;
 IF  NOT((schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(tspace))THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO space_dimension(tspace);
 temp := factor_space(tspace, i);
 IF NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- function_is_array

FUNCTION function_is_table
	(func : maths_function) : BOOLEAN;
 LOCAL
 tspace : tuple_space;
 temp : maths_space;
 base : INTEGER;
 END_LOCAL
;
 IF  NOT  EXISTS(func)THEN  RETURN(FALSE );
 END_IF ;
 tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(tspace)))THEN  tspace := factor1(tspace);
 END_IF ;
 IF  NOT((schema_prefix + 'PRODUCT_SPACE')IN  TYPEOF(tspace))THEN  RETURN(FALSE );
 END_IF ;
 temp := factor1(tspace);
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  TYPEOF(temp))THEN  RETURN(FALSE );
 END_IF ;
 base := temp \ finite_integer_interval.min;
 IF(base <> 0)AND(base <> 1)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 2 TO space_dimension(tspace);
 temp := factor_space(tspace, i);
 IF  NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN  RETURN(FALSE );
 END_IF ;
 IF temp \ finite_integer_interval.min <> base THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- function_is_table

FUNCTION good_t
	(v : maths_value; tn : STRING) : BOOLEAN;
 LOCAL
 tpl : LIST OF maths_value;
 END_LOCAL
;
 IF  'LIST' IN  TYPEOF(v)THEN  tpl := v;
 REPEAT i := 1 TO SIZEOF(tpl);
 IF NOT(tn IN TYPEOF(tpl [ i ]))THEN RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- good_t

FUNCTION has_values_space
	(expr : generic_expression) : BOOLEAN;
 LOCAL
 typenames : SET OF STRING := stripped_typeof(expr);
 END_LOCAL
;
 IF  'EXPRESSION' IN  typenames THEN  RETURN(bool(('NUMERIC_EXPRESSION' IN  typenames)OR('STRING_EXPRESSION' IN  typenames)OR('BOOLEAN_EXPRESSION' IN  typenames)));
 END_IF ;
 IF  'MATHS_FUNCTION' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'FUNCTION_APPLICATION' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_SPACE' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_VARIABLE' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'DEPENDENT_VARIABLE_DEFINITION' IN  typenames THEN  RETURN(has_values_space(expr \ unary_generic_expression.operand));
 END_IF ;
 IF  'COMPLEX_NUMBER_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'LOGICAL_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'BINARY_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_ENUM_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'REAL_TUPLE_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'INTEGER_TUPLE_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'ATOM_BASED_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'MATHS_TUPLE_LITERAL' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF  'PARTIAL_DERIVATIVE_EXPRESSION' IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 IF 'DEFINITE_INTEGRAL_EXPRESSION' IN typenames THEN RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- has_values_space

FUNCTION list_selected_components
	(aggr : AGGREGATE OF LIST [0:?] OF maths_value; k : positive_integer) : LIST [0:?] OF maths_value;
 LOCAL
 result : LIST OF maths_value := [ ];
 j : INTEGER := 0;
 END_LOCAL
;
 REPEAT i := LOINDEX(aggr)TO HIINDEX(aggr);
 IF k <= SIZEOF(aggr [ i ])THEN INSERT(result, aggr [ i ] [ k ], j);
 j := j + 1;
 END_IF;
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- list_selected_components

FUNCTION make_abstracted_expression_function
	(operands : LIST [2:?] OF generic_expression) : abstracted_expression_function;
 RETURN(abstracted_expression_function()|| maths_function()|| generic_expression()|| quantifier_expression(remove_first(operands))|| multiple_arity_generic_expression(operands));
 END_FUNCTION; -- make_abstracted_expression_function

FUNCTION make_atom_based_literal
	(lit_value : atom_based_value) : atom_based_literal;
 RETURN(atom_based_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_atom_based_literal

FUNCTION make_b_spline_basis
	(degree : nonnegative_integer; repeated_knots : LIST [2:?] OF REAL) : b_spline_basis;
 RETURN(b_spline_basis(degree, repeated_knots)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_b_spline_basis

FUNCTION make_b_spline_function
	(coef : maths_function; bases : LIST [1:?] OF b_spline_basis) : b_spline_function;
 RETURN(b_spline_function(bases)|| maths_function()|| generic_expression()|| unary_generic_expression(coef));
 END_FUNCTION; -- make_b_spline_function

FUNCTION make_banded_matrix
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; source : maths_function; first : INTEGER; default_entry : maths_value; below : INTEGER; above : INTEGER; order : ordering_type) : banded_matrix;
 RETURN(banded_matrix(default_entry, below, above, order)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(source));
 END_FUNCTION; -- make_banded_matrix

FUNCTION make_basic_sparse_matrix
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; operands : LIST [3:3] OF maths_function; default_entry : maths_value; order : ordering_type) : basic_sparse_matrix;
 RETURN(basic_sparse_matrix(default_entry, order)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| multiple_arity_generic_expression(operands));
 END_FUNCTION; -- make_basic_sparse_matrix

FUNCTION make_binary_literal
	(lit_value : BINARY) : binary_literal;
 RETURN(binary_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_binary_literal

FUNCTION make_boolean_literal
	(lit_value : BOOLEAN) : boolean_literal;
 RETURN(boolean_literal(lit_value)|| simple_boolean_expression()|| boolean_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_boolean_literal

FUNCTION make_cartesian_complex_number_region
	(real_constraint : real_interval; imag_constraint : real_interval) : cartesian_complex_number_region;
 RETURN(cartesian_complex_number_region(real_constraint, imag_constraint)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_cartesian_complex_number_region

FUNCTION make_complex_number_literal
	(rpart : REAL; ipart : REAL) : complex_number_literal;
 RETURN(complex_number_literal(rpart, ipart)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_complex_number_literal

FUNCTION make_constant_function
	(sole_value : maths_value; src_of_domn : maths_space_or_function) : constant_function;
 RETURN(constant_function(sole_value, src_of_domn)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_constant_function

FUNCTION make_cos_expression
	(operand : numeric_expression) : cos_function;
 RETURN(cos_expression()|| unary_numeric_call_expression()|| unary_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_cos_expression

FUNCTION make_definite_integral_expression
	(operands : LIST [2:4] OF generic_expression; loinf : BOOLEAN; upinf : BOOLEAN) : definite_integral_expression;
 RETURN(definite_integral_expression(loinf, upinf)|| quantifier_expression([ operands [ 2 ] ])|| multiple_arity_generic_expression(operands)|| generic_expression());
 END_FUNCTION; -- make_definite_integral_expression

FUNCTION make_definite_integral_function
	(integrand : maths_function; varintg : input_selector; loinf : BOOLEAN; upinf : BOOLEAN) : definite_integral_function;
 RETURN(definite_integral_function(varintg, loinf, upinf)|| maths_function()|| generic_expression()|| unary_generic_expression(integrand));
 END_FUNCTION; -- make_definite_integral_function

FUNCTION make_elementary_function
	(func_id : elementary_function_enumerators) : elementary_function;
 RETURN(elementary_function(func_id)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_elementary_function

FUNCTION make_elementary_space
	(space_id : elementary_space_enumerators) : elementary_space;
 RETURN(elementary_space(space_id)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_elementary_space

FUNCTION make_environment
	(varbl : generic_variable; sem : variable_semantics) : environment;
 RETURN(environment(varbl, sem));
 END_FUNCTION; -- make_environment

FUNCTION make_expression_denoted_function
	(expression : generic_expression) : expression_denoted_function;
 RETURN(expression_denoted_function()|| maths_function()|| generic_expression()|| unary_generic_expression(expression));
 END_FUNCTION; -- make_expression_denoted_function

FUNCTION make_extended_tuple_space
	(base : product_space; extender : maths_space) : extended_tuple_space;
 RETURN(extended_tuple_space(base, extender)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_extended_tuple_space

FUNCTION make_finite_function
	(pairs : SET [1:?] OF LIST [2:2] OF maths_value) : finite_function;
 RETURN(finite_function(pairs)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_function

FUNCTION make_finite_integer_interval
	(min : INTEGER; max : INTEGER) : finite_integer_interval;
 RETURN(finite_integer_interval(min, max)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_integer_interval

FUNCTION make_finite_real_interval
	(min : REAL; minclo : open_closed; max : REAL; maxclo : open_closed) : finite_real_interval;
 RETURN(finite_real_interval(min, minclo, max, maxclo)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_real_interval

FUNCTION make_finite_space
	(members : SET [0:?] OF maths_value) : finite_space;
 RETURN(finite_space(members)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_finite_space

FUNCTION make_function_application
	(afunction : maths_function_select; arguments : LIST [1:?] OF maths_value) : function_application;
 RETURN(function_application(afunction, arguments)|| multiple_arity_generic_expression(convert_to_maths_function(afunction)+ convert_to_operands(arguments))|| generic_expression());
 END_FUNCTION; -- make_function_application

FUNCTION make_function_space
	(domain_constraint : space_constraint_type; domain_argument : maths_space; range_constraint : space_constraint_type; range_argument : maths_space) : function_space;
 RETURN(function_space(domain_constraint, domain_argument, range_constraint, range_argument)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_function_space

FUNCTION make_general_linear_function
	(mat : maths_function; sum_index : one_or_two) : general_linear_function;
 RETURN(general_linear_function(sum_index)|| maths_function()|| generic_expression()|| unary_generic_expression(mat));
 END_FUNCTION; -- make_general_linear_function

FUNCTION make_int_literal
	(lit_value : INTEGER) : int_literal;
 RETURN(int_literal()|| literal_number(lit_value)|| simple_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_int_literal

FUNCTION make_integer_interval_from_min
	(min : INTEGER) : integer_interval_from_min;
 RETURN(integer_interval_from_min(min)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_integer_interval_from_min

FUNCTION make_listed_complex_number_data
	(index_base : zero_or_one; values : LIST [2:?] OF REAL) : listed_complex_number_data;
 RETURN(listed_complex_number_data(values)|| explicit_table_function(index_base, [ SIZEOF(values)/ 2 ])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_complex_number_data

FUNCTION make_listed_data
	(index_base : zero_or_one; values : LIST [2:?] OF maths_value; value_range : maths_space) : listed_data;
 RETURN(listed_data(values, value_range)|| explicit_table_function(index_base, [ SIZEOF(values)])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_data

FUNCTION make_listed_integer_data
	(index_base : zero_or_one; values : LIST [1:?] OF INTEGER) : listed_integer_data;
 RETURN(listed_integer_data(values)|| explicit_table_function(index_base, [ SIZEOF(values)])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_integer_data

FUNCTION make_listed_product_space
	(factors : LIST [0:?] OF maths_space) : listed_product_space;
 RETURN(listed_product_space(factors)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_product_space

FUNCTION make_listed_real_data
	(index_base : zero_or_one; values : LIST [1:?] OF REAL) : listed_real_data;
 RETURN(listed_real_data(values)|| explicit_table_function(index_base, [ SIZEOF(values)])|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_listed_real_data

FUNCTION make_logical_literal
	(lit_value : LOGICAL) : logical_literal;
 RETURN(logical_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_logical_literal

FUNCTION make_maths_enum_literal
	(lit_value : maths_enum_atom) : maths_enum_literal;
 RETURN(maths_enum_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_maths_enum_literal

FUNCTION make_maths_real_variable
	(values_space : maths_space; name : label) : maths_real_variable;
 RETURN(maths_real_variable()|| maths_variable(values_space, name)|| generic_variable()|| simple_generic_expression()|| generic_expression()|| real_numeric_variable()|| numeric_variable()|| variable());
 END_FUNCTION; -- make_maths_real_variable

FUNCTION make_maths_tuple_literal
	(lit_value : LIST [0:?] OF maths_value) : maths_tuple_literal;
 RETURN(maths_tuple_literal(lit_value)|| generic_literal()|| simple_generic_expression()|| generic_expression());
 END_FUNCTION; -- make_maths_tuple_literal

FUNCTION make_mult_expression
	(operands : LIST [2:?] OF generic_expression) : mult_expression;
 RETURN(mult_expression()|| multiple_arity_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| multiple_arity_generic_expression(operands));
 END_FUNCTION; -- make_mult_expression

FUNCTION make_number_literal
	(nmb : NUMBER) : generic_literal;
 IF 'INTEGER' IN TYPEOF(nmb)THEN RETURN(make_int_literal(nmb));
 END_IF;
 RETURN(make_real_literal(nmb));
 END_FUNCTION; -- make_number_literal

FUNCTION make_parallel_composed_function
	(srcdom : maths_space_or_function; prepfuncs : LIST [2:?] OF maths_function; finfunc : maths_function_select) : parallel_composed_function;
 RETURN(parallel_composed_function(srcdom, prepfuncs, finfunc)|| maths_function()|| generic_expression()|| multiple_arity_generic_expression(convert_to_operands_prcmfn(srcdom, prepfuncs, finfunc)));
 END_FUNCTION; -- make_parallel_composed_function

FUNCTION make_partial_derivative_expression
	(derivand : generic_expression; dvars : LIST [1:?] OF maths_variable; extend : extension_options) : partial_derivative_expression;
 RETURN(partial_derivative_expression(dvars, extend)|| unary_generic_expression(derivand)|| generic_expression());
 END_FUNCTION; -- make_partial_derivative_expression

FUNCTION make_partial_derivative_function
	(derivand : maths_function; dvars : LIST [1:?] OF input_selector; extend : extension_options) : partial_derivative_function;
 RETURN(partial_derivative_function(dvars, extend)|| maths_function()|| generic_expression()|| unary_generic_expression(derivand));
 END_FUNCTION; -- make_partial_derivative_function

FUNCTION make_polar_complex_number_region
	(centre : complex_number_literal; dis_constraint : real_interval; dir_constraint : finite_real_interval) : polar_complex_number_region;
 RETURN(polar_complex_number_region(centre, dis_constraint, dir_constraint)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_polar_complex_number_region

FUNCTION make_rationalize_function
	(fun : maths_function) : rationalize_function;
 RETURN(rationalize_function()|| maths_function()|| generic_expression()|| unary_generic_expression(fun));
 END_FUNCTION; -- make_rationalize_function

FUNCTION make_real_interval_from_min
	(min : REAL; minclo : open_closed) : real_interval_from_min;
 RETURN(real_interval_from_min(min, minclo)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_real_interval_from_min

FUNCTION make_real_interval_to_max
	(max : REAL; maxclo : open_closed) : real_interval_to_max;
 RETURN(real_interval_to_max(max, maxclo)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_real_interval_to_max

FUNCTION make_real_literal
	(lit_value : REAL) : real_literal;
 RETURN(real_literal()|| literal_number(lit_value)|| simple_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_real_literal

FUNCTION make_regular_table_function
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; operand : maths_function; first : INTEGER; increments : LIST [1:?] OF INTEGER) : regular_table_function;
 RETURN(regular_table_function(increments)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_regular_table_function

FUNCTION make_reindexed_array_function
	(func : maths_function; start_idxs : LIST [1:?] OF INTEGER) : reindexed_array_function;
 RETURN(reindexed_array_function(start_idxs)|| maths_function()|| generic_expression()|| unary_generic_expression(func));
 END_FUNCTION; -- make_reindexed_array_function

FUNCTION make_repackaging_function
	(operand : maths_function; input_repack : repackage_options; output_repack : repackage_options; selected_output : nonnegative_integer) : repackaging_function;
 RETURN(repackaging_function(input_repack, output_repack, selected_output)|| maths_function()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_repackaging_function

FUNCTION make_selector_function
	(selector : input_selector; src_of_domn : maths_space_or_function) : selector_function;
 RETURN(selector_function(selector, src_of_domn)|| maths_function()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_selector_function

FUNCTION make_series_composed_function
	(functions : LIST [2:?] OF maths_function) : series_composed_function;
 RETURN(series_composed_function()|| maths_function()|| generic_expression()|| multiple_arity_generic_expression(functions));
 END_FUNCTION; -- make_series_composed_function

FUNCTION make_sin_expression
	(operand : numeric_expression) : sin_function;
 RETURN(sin_expression()|| unary_numeric_call_expression()|| unary_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_sin_expression

FUNCTION make_standard_table_function
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; operand : maths_function; first : INTEGER; order : ordering_type) : standard_table_function;
 RETURN(standard_table_function(order)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_standard_table_function

FUNCTION make_strict_triangular_matrix
	(index_base : zero_or_one; shape : LIST [1:?] OF positive_integer; source : maths_function; first : INTEGER; default_entry : maths_value; lo_up : lower_upper; order : ordering_type; main_diagonal_value : maths_value) : strict_triangular_matrix;
 RETURN(strict_triangular_matrix(main_diagonal_value)|| triangular_matrix(default_entry, lo_up, order)|| linearized_table_function(first)|| explicit_table_function(index_base, shape)|| maths_function()|| generic_expression()|| unary_generic_expression(source));
 END_FUNCTION; -- make_strict_triangular_matrix

FUNCTION make_string_literal
	(lit_value : STRING) : string_literal;
 RETURN(string_literal(lit_value)|| simple_string_expression()|| string_expression()|| expression()|| generic_expression()|| simple_generic_expression()|| generic_literal());
 END_FUNCTION; -- make_string_literal

FUNCTION make_unary_minus_expression
	(operand : numeric_expression) : minus_function;
 RETURN(unary_minus_expression()|| unary_numeric_call_expression()|| unary_numeric_expression()|| numeric_expression()|| expression()|| generic_expression()|| unary_generic_expression(operand));
 END_FUNCTION; -- make_unary_minus_expression

FUNCTION make_uniform_product_space
	(base : maths_space; exponent : positive_integer) : uniform_product_space;
 RETURN(uniform_product_space(base, exponent)|| maths_space()|| generic_expression()|| generic_literal()|| simple_generic_expression());
 END_FUNCTION; -- make_uniform_product_space

FUNCTION makec
	(x : REAL; y : REAL) : complex_number_literal;
 RETURN(make_complex_number_literal(x, y));
 END_FUNCTION; -- makec

FUNCTION max_exists
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_TO_MAX')IN  types)OR((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)OR((schema_prefix + 'REAL_INTERVAL_TO_MAX')IN types)));
 END_FUNCTION; -- max_exists

FUNCTION max_included
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_TO_MAX')IN  types)THEN  RETURN(TRUE);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(bool(spc \ finite_real_interval.max_closure = closed));
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_TO_MAX')IN types)THEN RETURN(bool(spc \ real_interval_to_max.max_closure = closed));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- max_included

FUNCTION mem_of_vs
	(val1 : maths_value; val2 : maths_value) : LOGICAL;
 IF  NOT  has_values_space(val2)THEN  RETURN(UNKNOWN );
 END_IF ;
 IF NOT member_of(val1, values_space_of(val2))THEN RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- mem_of_vs

FUNCTION member_of
	(val : GENERIC:G; spc : maths_space) : LOGICAL;
 LOCAL
 v : maths_value := simplify_maths_value(convert_to_maths_value(val));
 vtypes : SET  OF  STRING  := stripped_typeof(v);
 s : maths_space := simplify_maths_space(spc);
 stypes : SET  OF  STRING := stripped_typeof(s);
 tmp_int : INTEGER;
 tmp_real : REAL;
 tmp_cmplx : complex_number_literal;
 lgcl, cum : LOGICAL;
 vspc, sspc : maths_space;
 smem : SET OF  maths_value;
 factors : LIST OF  maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(s)THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT  EXISTS(v)THEN  RETURN(s = the_generics);
 END_IF ;
 IF('GENERIC_EXPRESSION' IN  vtypes)AND  NOT('MATHS_SPACE' IN  vtypes)AND  NOT('MATHS_FUNCTION' IN  vtypes)AND  NOT('COMPLEX_NUMBER_LITERAL' IN  vtypes)THEN  IF  has_values_space(v)THEN  vspc := values_space_of(v);
 IF  subspace_of(vspc, s)THEN  RETURN(TRUE );
 END_IF ;
 IF  NOT  compatible_spaces(vspc, s)THEN  RETURN(FALSE );
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  stypes THEN  CASE  s \ elementary_space.space_id OF  es_numbers : RETURN(('NUMBER' IN  vtypes)OR('COMPLEX_NUMBER_LITERAL' IN  vtypes));
 es_complex_numbers : RETURN('COMPLEX_NUMBER_LITERAL' IN  vtypes);
 es_reals : RETURN(('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes));
 es_integers : RETURN('INTEGER' IN  vtypes);
 es_logicals : RETURN('LOGICAL' IN  vtypes);
 es_booleans : RETURN('BOOLEAN' IN  vtypes);
 es_strings : RETURN('STRING' IN  vtypes);
 es_binarys : RETURN('BINARY' IN  vtypes);
 es_maths_spaces : RETURN('MATHS_SPACE' IN  vtypes);
 es_maths_functions : RETURN('MATHS_FUNCTION' IN  vtypes);
 es_generics : RETURN(TRUE );
 END_CASE ;
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN  stypes THEN  IF  'INTEGER' IN  vtypes THEN  tmp_int := v;
 RETURN({ s \ finite_integer_interval.min <= tmp_int <= s \ finite_integer_interval.max });
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'INTEGER_INTERVAL_FROM_MIN' IN  stypes THEN  IF  'INTEGER' IN  vtypes THEN  tmp_int := v;
 RETURN(s \ integer_interval_from_min.min <= tmp_int);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'INTEGER_INTERVAL_TO_MAX' IN  stypes THEN  IF  'INTEGER' IN  vtypes THEN  tmp_int := v;
 RETURN(tmp_int <= s \ integer_interval_to_max.max);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_REAL_INTERVAL' IN  stypes THEN  IF('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes)THEN  tmp_real := v;
 IF  s \ finite_real_interval.min_closure = closed THEN  IF  s \ finite_real_interval.max_closure = closed THEN  RETURN({ s \ finite_real_interval.min <= tmp_real <= s \ finite_real_interval.max });
 ELSE  RETURN({ s \ finite_real_interval.min <= tmp_real < s \ finite_real_interval.max });
 END_IF ;
 ELSE  IF  s \ finite_real_interval.max_closure = closed THEN  RETURN({ s \ finite_real_interval.min < tmp_real <= s \ finite_real_interval.max });
 ELSE  RETURN({ s \ finite_real_interval.min < tmp_real < s \ finite_real_interval.max });
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_FROM_MIN' IN  stypes THEN  IF('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes)THEN  tmp_real := v;
 IF  s \ real_interval_from_min.min_closure = closed THEN  RETURN(s \ real_interval_from_min.min <= tmp_real);
 ELSE  RETURN(s \ real_interval_from_min.min < tmp_real);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_TO_MAX' IN  stypes THEN  IF('REAL' IN  vtypes)AND  NOT('INTEGER' IN  vtypes)THEN  tmp_real := v;
 IF  s \ real_interval_to_max.max_closure = closed THEN  RETURN(tmp_real <= s \ real_interval_to_max.max);
 ELSE RETURN(tmp_real < s \ real_interval_to_max.max);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  stypes THEN  IF  'COMPLEX_NUMBER_LITERAL' IN  vtypes THEN  RETURN(member_of(v \ complex_number_literal.real_part, s \ cartesian_complex_number_region.real_constraint)AND  member_of(v \ complex_number_literal.imag_part, s \ cartesian_complex_number_region.imag_constraint));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  stypes THEN  IF  'COMPLEX_NUMBER_LITERAL' IN  vtypes THEN  tmp_cmplx := v;
 tmp_cmplx.real_part := tmp_cmplx.real_part - s \ polar_complex_number_region.centre.real_part;
 tmp_cmplx.imag_part := tmp_cmplx.imag_part - s \ polar_complex_number_region.centre.imag_part;
 tmp_real := SQRT(tmp_cmplx.real_part ** 2 + tmp_cmplx.imag_part ** 2);
 IF  NOT member_of(tmp_real, s \ polar_complex_number_region.distance_constraint)THEN  RETURN(FALSE );
 END_IF ;
 IF  tmp_real = 0.0 THEN  RETURN(TRUE );
 END_IF ;
 tmp_real := atan2(tmp_cmplx.imag_part, tmp_cmplx.real_part);
 RETURN(member_of(tmp_real, s \ polar_complex_number_region.direction_constraint)OR  member_of(tmp_real + 2.0 * PI, s \ polar_complex_number_region.direction_constraint));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_SPACE' IN  stypes THEN  smem := s \ finite_space.members;
 cum := FALSE ;
 REPEAT  i := 1 TO  SIZEOF(smem);
 cum := cum OR equal_maths_values(v, smem [ i ]);
 IF  cum = TRUE  THEN  RETURN(TRUE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  stypes THEN  IF  'LIST' IN  vtypes THEN  IF  SIZEOF(v)= s \ uniform_product_space.exponent THEN  sspc := s \ uniform_product_space.base;
 cum := TRUE ;
 REPEAT  i := 1 TO  SIZEOF(v);
 cum := cum AND  member_of(v [ i ], sspc);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  stypes THEN  IF  'LIST' IN  vtypes THEN  factors := s \ listed_product_space.factors;
 IF  SIZEOF(v)= SIZEOF(factors)THEN  cum := TRUE ;
 REPEAT  i := 1 TO  SIZEOF(v);
 cum := cum AND  member_of(v [ i ], factors [ i ]);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  stypes THEN  IF  'LIST' IN  vtypes THEN  sspc := s \ extended_tuple_space.base;
 tmp_int := space_dimension(sspc);
 IF  SIZEOF(v)>= tmp_int THEN  cum := TRUE;
 REPEAT  i := 1 TO  tmp_int;
 cum := cum AND  member_of(v [ i ], factor_space(sspc, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 sspc := s \ extended_tuple_space.extender;
 REPEAT i := tmp_int + 1 TO SIZEOF(v);
 cum := cum AND  member_of(v [ i ], sspc);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  stypes THEN  IF  'MATHS_FUNCTION' IN vtypes THEN  vspc := v \ maths_function.domain;
 sspc := s \ function_space.domain_argument;
 CASE  s \ function_space.domain_constraint OF  sc_equal : cum := equal_maths_spaces(vspc, sspc);
 sc_subspace : cum := subspace_of(vspc, sspc);
 sc_member : cum := member_of(vspc, sspc);
 END_CASE ;
 IF cum = FALSE  THEN RETURN(FALSE );
 END_IF ;
 vspc := v \ maths_function.range;
 sspc := s \ function_space.range_argument;
 CASE s \ function_space.range_constraint OF sc_equal : cum := cum AND  equal_maths_spaces(vspc, sspc);
 sc_subspace : cum := cum AND  subspace_of(vspc, sspc);
 sc_member : cum := cum AND member_of(vspc, sspc);
 END_CASE;
 RETURN(cum);
 END_IF ;
 RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- member_of

FUNCTION min_exists
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 RETURN(bool(((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN')IN  types)OR((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)OR((schema_prefix + 'REAL_INTERVAL_FROM_MIN')IN types)));
 END_FUNCTION; -- min_exists

FUNCTION min_included
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)OR((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN')IN  types)THEN  RETURN(TRUE);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(bool(spc \ finite_real_interval.min_closure = closed));
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_FROM_MIN')IN types)THEN RETURN(bool(spc \ real_interval_from_min.min_closure = closed));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- min_included

FUNCTION no_cyclic_domain_reference
	(ref : maths_space_or_function; used : SET [0:?] OF maths_function) : BOOLEAN;
 LOCAL
 typenames : SET OF STRING := TYPEOF(ref);
 func : maths_function;
 END_LOCAL
;
 IF(NOT  EXISTS(ref))OR(NOT EXISTS(used))THEN  RETURN(FALSE );
 END_IF ;
 IF(schema_prefix + 'MATHS_SPACE')IN  typenames THEN  RETURN(TRUE );
 END_IF ;
 func := ref;
 IF  func IN  used THEN  RETURN(FALSE);
 END_IF ;
 IF(schema_prefix + 'CONSTANT_FUNCTION')IN  typenames THEN  RETURN(no_cyclic_domain_reference(func \ constant_function.source_of_domain, used + [ func ]));
 END_IF ;
 IF(schema_prefix + 'SELECTOR_FUNCTION')IN  typenames THEN  RETURN(no_cyclic_domain_reference(func \ selector_function.source_of_domain, used + [ func ]));
 END_IF ;
 IF(schema_prefix + 'PARALLEL_COMPOSED_FUNCTION')IN typenames THEN RETURN(no_cyclic_domain_reference(func \ parallel_composed_function.source_of_domain, used + [ func ]));
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- no_cyclic_domain_reference

FUNCTION no_cyclic_space_reference
	(spc : maths_space; refs : SET [0:?] OF maths_space) : BOOLEAN;
 LOCAL
 types : SET  OF  STRING;
 refs_plus : SET OF maths_space;
 END_LOCAL
;
 IF(spc IN  refs)THEN  RETURN(FALSE);
 END_IF ;
 types := TYPEOF(spc);
 refs_plus := refs + spc;
 IF(schema_prefix + 'FINITE_SPACE')IN  types THEN  RETURN(bool(SIZEOF(QUERY(sp <* QUERY(mem <* spc \ finite_space.members |(schema_prefix + 'MATHS_SPACE')IN  TYPEOF(mem))| NOT  no_cyclic_space_reference(sp, refs_plus)))= 0));
 END_IF ;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  types THEN  RETURN(no_cyclic_space_reference(spc \ uniform_product_space.base, refs_plus));
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  types THEN  RETURN(bool(SIZEOF(QUERY(fac <* spc \ listed_product_space.factors | NOT no_cyclic_space_reference(fac, refs_plus)))= 0));
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN types THEN RETURN(no_cyclic_space_reference(spc \ extended_tuple_space.base, refs_plus)AND no_cyclic_space_reference(spc \ extended_tuple_space.extender, refs_plus));
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- no_cyclic_space_reference

FUNCTION nondecreasing
	(lr : LIST [0:?] OF REAL) : BOOLEAN;
 IF  NOT EXISTS(lr)THEN  RETURN(FALSE );
 END_IF ;
 REPEAT j := 2 TO SIZEOF(lr);
 IF lr [ j ] < lr [ j - 1 ] THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- nondecreasing

FUNCTION number_superspace_of
	(spc : maths_space) : elementary_space;
 IF  subspace_of_es(spc, es_integers)THEN  RETURN(the_integers);
 END_IF ;
 IF  subspace_of_es(spc, es_reals)THEN  RETURN(the_reals);
 END_IF ;
 IF  subspace_of_es(spc, es_complex_numbers)THEN  RETURN(the_complex_numbers);
 END_IF ;
 IF subspace_of_es(spc, es_numbers)THEN RETURN(the_numbers);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- number_superspace_of

FUNCTION number_tuple_subspace_check
	(spc : maths_space) : LOGICAL;
 LOCAL
 types : SET OF  STRING := stripped_typeof(spc);
 factors : LIST OF maths_space;
 cum : LOGICAL := TRUE;
 END_LOCAL
;
 IF  'UNIFORM_PRODUCT_SPACE' IN  types THEN  RETURN(subspace_of_es(spc \ uniform_product_space.base, es_numbers));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  types THEN  factors := spc \ listed_product_space.factors;
 REPEAT i := 1 TO SIZEOF(factors);
 cum := cum AND  subspace_of_es(factors [ i ], es_numbers);
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 IF 'EXTENDED_TUPLE_SPACE' IN types THEN cum := subspace_of_es(spc \ extended_tuple_space.extender, es_numbers);
 cum := cum AND number_tuple_subspace_check(spc \ extended_tuple_space.base);
 RETURN(cum);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- number_tuple_subspace_check

FUNCTION one_tuples_of
	(spc : maths_space) : tuple_space;
 RETURN(make_uniform_product_space(spc, 1));
 END_FUNCTION; -- one_tuples_of

FUNCTION parallel_composed_function_composability_check
	(funcs : LIST [0:?] OF maths_function; final : maths_function_select) : BOOLEAN;
 LOCAL
 tplsp : tuple_space := the_zero_tuple_space;
 finfun : maths_function := convert_to_maths_function(final);
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(funcs);
 tplsp := assoc_product_space(tplsp, funcs [ i ].range);
 END_REPEAT;
 RETURN(compatible_spaces(tplsp, finfun.domain));
 END_FUNCTION; -- parallel_composed_function_composability_check

FUNCTION parallel_composed_function_domain_check
	(comdom : tuple_space; funcs : LIST [0:?] OF maths_function) : BOOLEAN;
 REPEAT i := 1 TO SIZEOF(funcs);
 IF NOT(compatible_spaces(comdom, funcs [ i ].domain))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- parallel_composed_function_domain_check

FUNCTION parse_express_identifier
	(s : STRING; i : positive_integer) : positive_integer;
 LOCAL
 k : positive_integer;
 END_LOCAL
;
 k := i;
 IF  i <= LENGTH(s)THEN  IF(s [ i ] LIKE  '@')THEN REPEAT UNTIL(k > LENGTH(s))OR((s [ k ] <> '_')AND  NOT(s [ k ] LIKE  '@')AND NOT(s [ k ] LIKE '#'));
 k := k + 1;
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(k);
 END_FUNCTION; -- parse_express_identifier

FUNCTION partial_derivative_check
	(domain : tuple_space; d_vars : LIST [1:?] OF input_selector) : BOOLEAN;
 LOCAL
 domn : tuple_space := domain;
 fspc : maths_space;
 dim : INTEGER ;
 k : INTEGER;
 END_LOCAL
;
 IF(space_dimension(domain)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN TYPEOF(factor1(domain)))THEN  domn := factor1(domain);
 END_IF ;
 dim := space_dimension(domn);
 REPEAT i := 1 TO SIZEOF(d_vars);
 k := d_vars [ i ];
 IF  k > dim THEN  RETURN(FALSE );
 END_IF ;
 fspc := factor_space(domn, k);
 IF(NOT  subspace_of_es(fspc, es_reals))AND(NOT subspace_of_es(fspc, es_complex_numbers))THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- partial_derivative_check

FUNCTION process_product_space
	(spc : product_space; idx : INTEGER; prefix : INTEGER; vdomn : maths_space) : product_space;
 LOCAL
 uspc : uniform_product_space;
 expnt : INTEGER;
 factors : LIST OF maths_space;
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN TYPEOF(spc)THEN  uspc := spc;
 expnt := uspc.exponent + prefix;
 IF  idx <= uspc.exponent THEN  expnt := expnt - 1;
 END_IF ;
 IF  expnt = 0 THEN  RETURN(make_listed_product_space([ ]));
 ELSE  RETURN(make_uniform_product_space(uspc.base, expnt));
 END_IF ;
 ELSE factors := spc \ listed_product_space.factors;
 IF  idx <= SIZEOF(factors)THEN  REMOVE(factors, idx);
 END_IF ;
 IF  prefix > 0 THEN  INSERT(factors, vdomn, 0);
 IF prefix > 1 THEN INSERT(factors, vdomn, 0);
 END_IF ;
 END_IF ;
 RETURN(make_listed_product_space(factors));
 END_IF;
 END_FUNCTION; -- process_product_space

FUNCTION real_max
	(spc : maths_space) : REAL;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)THEN  RETURN(spc \ finite_integer_interval.max);
 END_IF ;
 IF((schema_prefix + 'INTEGER_INTERVAL_TO_MAX')IN  types)THEN  RETURN(spc \ integer_interval_to_max.max);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(spc \ finite_real_interval.max);
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_TO_MAX')IN types)THEN RETURN(spc \ real_interval_to_max.max);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- real_max

FUNCTION real_min
	(spc : maths_space) : REAL;
 LOCAL
 types : SET OF STRING := TYPEOF(spc);
 END_LOCAL
;
 IF((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN  types)THEN  RETURN(spc \ finite_integer_interval.min);
 END_IF ;
 IF((schema_prefix + 'INTEGER_INTERVAL_FROM_MIN')IN  types)THEN  RETURN(spc \ integer_interval_from_min.min);
 END_IF ;
 IF((schema_prefix + 'FINITE_REAL_INTERVAL')IN  types)THEN  RETURN(spc \ finite_real_interval.min);
 END_IF ;
 IF((schema_prefix + 'REAL_INTERVAL_FROM_MIN')IN types)THEN RETURN(spc \ real_interval_from_min.min);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- real_min

FUNCTION regular_indexing
	(sub : LIST [0:?] OF INTEGER; base : zero_or_one; shape : LIST [1:?] OF positive_integer; inc : LIST [1:?] OF INTEGER; first : INTEGER) : INTEGER;
 LOCAL
 k : INTEGER ;
 index : INTEGER;
 END_LOCAL
;
 IF  NOT  EXISTS(sub)OR  NOT  EXISTS(base)OR  NOT  EXISTS(shape)OR  NOT  EXISTS(inc)OR  NOT  EXISTS(first)THEN  RETURN(?);
 END_IF ;
 IF(SIZEOF(sub)<> SIZEOF(inc))OR(SIZEOF(sub)<> SIZEOF(shape))THEN  RETURN(?);
 END_IF ;
 index := first;
 REPEAT j := 1 TO SIZEOF(sub);
 IF  NOT  EXISTS(sub [ j ])OR NOT  EXISTS(inc [ j ])THEN  RETURN(?);
 END_IF ;
 k := sub [ j ] - base;
 IF NOT({ 0 <= k < shape [ j ] })THEN RETURN(?);
 END_IF;
 index := index + k * inc [ j ];
 END_REPEAT;
 RETURN(index);
 END_FUNCTION; -- regular_indexing

FUNCTION remove_first
	(alist : LIST [0:?] OF GENERIC) : LIST [0:?] OF GENERIC;
 LOCAL
 blist : LIST OF GENERIC : GEN := alist;
 END_LOCAL
;
 IF SIZEOF(blist)> 0 THEN REMOVE(blist, 1);
 END_IF;
 RETURN(blist);
 END_FUNCTION; -- remove_first

FUNCTION repackage
	(tspace : tuple_space; repckg : repackage_options) : tuple_space;
 CASE repckg OF ro_nochange : RETURN(tspace);
 ro_wrap_as_tuple : RETURN(one_tuples_of(tspace));
 ro_unwrap_tuple : RETURN(factor1(tspace));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- repackage

FUNCTION restore_binary
	(expr : binary_generic_expression; opd1 : generic_expression; opd2 : generic_expression) : generic_expression;
 expr.operands [ 1 ] := opd1;
 expr.operands [ 2 ] := opd2;
 RETURN(expr);
 END_FUNCTION; -- restore_binary

FUNCTION restore_mulary
	(expr : multiple_arity_generic_expression; ops : LIST [0:?] OF generic_expression) : generic_expression;
 expr.operands := ops;
 RETURN(expr);
 END_FUNCTION; -- restore_mulary

FUNCTION restore_unary
	(expr : unary_generic_expression; opnd : generic_expression) : generic_expression;
 expr.operand := opnd;
 RETURN(expr);
 END_FUNCTION; -- restore_unary

FUNCTION shape_of_array
	(func : maths_function) : LIST [0:?] OF positive_integer;
 LOCAL
 tspace : tuple_space;
 temp : maths_space;
 result : LIST OF positive_integer := [ ];
 END_LOCAL
;
 IF(schema_prefix + 'EXPLICIT_TABLE_FUNCTION')IN  TYPEOF(func)THEN  RETURN(func \ explicit_table_function.shape);
 END_IF ;
 tspace := func.domain;
 IF(space_dimension(tspace)= 1)AND((schema_prefix + 'TUPLE_SPACE')IN  TYPEOF(factor1(tspace)))THEN  tspace := factor1(tspace);
 END_IF ;
 REPEAT i := 1 TO space_dimension(tspace);
 temp := factor_space(tspace, i);
 IF NOT((schema_prefix + 'FINITE_INTEGER_INTERVAL')IN TYPEOF(temp))THEN RETURN(?);
 END_IF;
 INSERT(result, temp \ finite_integer_interval.size, i - 1);
 END_REPEAT;
 RETURN(result);
 END_FUNCTION; -- shape_of_array

FUNCTION simplify_function_application
	(expr : function_application) : maths_value;
 LOCAL
 types : SET  OF  STRING  := stripped_typeof(expr.func);
 ef_val : elementary_function_enumerators;
 is_elementary : BOOLEAN  := FALSE ;
 v, v1, v2, v3 : maths_value;
 vlist : LIST  OF  maths_value := [ ];
 gexpr : generic_expression;
 pairs : SET  [ 1 : ? ] OF  LIST  [ 2 : 2 ] OF  maths_value;
 boo : BOOLEAN;
 lgc, cum : LOGICAL;
 j, k, n : INTEGER;
 p, q, r, s, t, u : REAL;
 str, st2 : STRING;
 bin, bi2 : BINARY;
 tpl, tp2 : LIST OF  maths_value;
 mem : SET OF  maths_value := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(expr.arguments);
 v := simplify_maths_value(expr.arguments [ i ]);
 INSERT(vlist, v, i - 1);
 END_REPEAT ;
 IF  SIZEOF(vlist)>= 1 THEN  v1 := vlist [ 1 ];
 END_IF ;
 IF  SIZEOF(vlist)>= 2 THEN  v2 := vlist [ 2 ];
 END_IF ;
 IF  SIZEOF(vlist)>= 3 THEN  v3 := vlist [ 3 ];
 END_IF ;
 IF  'ELEMENTARY_FUNCTION_ENUMERATORS' IN  types THEN  ef_val := expr.func;
 is_elementary := TRUE ;
 END_IF ;
 IF  'ELEMENTARY_FUNCTION' IN  types THEN  ef_val := expr.func \ elementary_function.func_id;
 is_elementary := TRUE ;
 END_IF ;
 IF  is_elementary THEN  CASE ef_val OF ef_and : BEGIN  cum := TRUE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'LOGICAL' IN  TYPEOF(vlist [ i ])THEN  lgc := vlist [ i ];
 cum := cum AND  lgc;
 IF  lgc = FALSE  THEN  RETURN(ctmv(FALSE));
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(cum));
 END_IF ;
 IF  cum <> TRUE  THEN  INSERT(vlist, ctmv(cum), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_or : BEGIN  cum := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'LOGICAL' IN  TYPEOF(vlist [ i ])THEN  lgc := vlist [ i ];
 cum := cum OR  lgc;
 IF  lgc = TRUE  THEN  RETURN(ctmv(TRUE));
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(cum));
 END_IF ;
 IF  cum <> FALSE  THEN  INSERT(vlist, ctmv(cum), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_not : IF  'LOGICAL' IN  TYPEOF(v1)THEN  lgc := v1;
 RETURN(ctmv(NOT  lgc));
 END_IF ;
 ef_xor : BEGIN  IF  'LOGICAL' IN  TYPEOF(v1)THEN  lgc := v1;
 IF  'LOGICAL' IN  TYPEOF(v2)THEN  cum := v2;
 RETURN(ctmv(lgc XOR cum));
 ELSE  IF  lgc = FALSE  THEN  RETURN(ctmv(v2));
 ELSE  IF  lgc = UNKNOWN  THEN  RETURN(ctmv(UNKNOWN));
 ELSE  RETURN(make_function_application(ef_not, [ v2 ]));
 END_IF ;
 END_IF ;
 END_IF ;
 ELSE  IF  'LOGICAL' IN  TYPEOF(v2)THEN  lgc := v2;
 IF  lgc = FALSE  THEN  RETURN(ctmv(v1));
 ELSE  IF  lgc = UNKNOWN  THEN  RETURN(ctmv(UNKNOWN));
 ELSE  RETURN(make_function_application(ef_not, [ v1 ]));
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END ;
 ef_negate_i : IF  'INTEGER' IN  TYPEOF(v1)THEN  j := v1;
 RETURN(ctmv(- j));
 END_IF ;
 ef_add_i : BEGIN  j := 0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  k := vlist [ i ];
 j := j + k;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  j <> 0 THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j - k));
 END_IF ;
 ef_multiply_i : BEGIN  j := 1;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  k := vlist [ i ];
 j := j * k;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  j <> 1 THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_divide_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j DIV  k));
 END_IF ;
 ef_mod_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j MOD k));
 END_IF ;
 ef_exponentiate_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 n := 1;
 REPEAT  i := 1 TO  ABS(k);
 n := n * j;
 END_REPEAT ;
 IF  k < 0 THEN  n := 1 DIV  n;
 END_IF ;
 RETURN(ctmv(n));
 END_IF ;
 ef_eq_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j = k));
 END_IF ;
 ef_ne_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j <> k));
 END_IF ;
 ef_gt_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j > k));
 END_IF ;
 ef_lt_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j < k));
 END_IF ;
 ef_ge_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j >= k));
 END_IF ;
 ef_le_i : IF('INTEGER' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  j := v1;
 k := v2;
 RETURN(ctmv(j <= k));
 END_IF ;
 ef_abs_i : IF  'INTEGER' IN  TYPEOF(v1)THEN  j := v1;
 RETURN(ctmv(ABS(j)));
 END_IF ;
 ef_max_i : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  k := vlist [ i ];
 IF  k > j THEN  j := k;
 END_IF ;
 ELSE  j := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_min_i : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'INTEGER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  k := vlist [ i ];
 IF  k < j THEN  j := k;
 END_IF ;
 ELSE  j := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(j));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(j), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_negate_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(- r));
 END_IF ;
 ef_reciprocal_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(1.0 / r));
 END_IF ;
 ef_add_r : BEGIN  r := 0.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  s := vlist [ i ];
 r := r + s;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  r <> 0.0 THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r - s));
 END_IF ;
 ef_multiply_r : BEGIN  r := 1.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  s := vlist [ i ];
 r := r * s;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  r <> 1.0 THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_divide_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r / s));
 END_IF ;
 ef_mod_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 t := r / s;
 j := t DIV 1;
 IF(t < 0.0)AND(j <> t)THEN  j := j - 1;
 END_IF ;
 RETURN(ctmv(r - j * s));
 END_IF ;
 ef_exponentiate_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r ** s));
 END_IF ;
 ef_exponentiate_ri : IF('REAL' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  r := v1;
 k := v2;
 t := 1.0;
 REPEAT  i := 1 TO  ABS(k);
 t := t * r;
 END_REPEAT ;
 IF  k < 0 THEN  t := 1.0 / t;
 END_IF ;
 RETURN(ctmv(t));
 END_IF ;
 ef_eq_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r = s));
 END_IF ;
 ef_ne_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r <> s));
 END_IF ;
 ef_gt_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r > s));
 END_IF ;
 ef_lt_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r < s));
 END_IF ;
 ef_ge_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r >= s));
 END_IF ;
 ef_le_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(r <= s));
 END_IF ;
 ef_abs_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(ABS(r)));
 END_IF ;
 ef_max_r : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  s := vlist [ i ];
 IF  s > r THEN  r := s;
 END_IF ;
 ELSE  r := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_min_r : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'REAL' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  s := vlist [ i ];
 IF  s < r THEN  r := s;
 END_IF ;
 ELSE  r := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(r));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(r), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_acos_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(ACOS(r)));
 END_IF ;
 ef_asin_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(ASIN(r)));
 END_IF ;
 ef_atan2_r : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(ctmv(atan2(r, s)));
 END_IF ;
 ef_cos_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(COS(r)));
 END_IF ;
 ef_exp_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(EXP(r)));
 END_IF ;
 ef_ln_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(LOG(r)));
 END_IF ;
 ef_log2_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(LOG2(r)));
 END_IF ;
 ef_log10_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(LOG10(r)));
 END_IF ;
 ef_sin_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(SIN(r)));
 END_IF ;
 ef_sqrt_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(SQRT(r)));
 END_IF ;
 ef_tan_r : IF  'REAL' IN  TYPEOF(v1)THEN  r := v1;
 RETURN(ctmv(TAN(r)));
 END_IF ;
 ef_form_c : IF('REAL' IN  TYPEOF(v1))AND('REAL' IN  TYPEOF(v2))THEN  r := v1;
 s := v2;
 RETURN(makec(r, s));
 END_IF ;
 ef_rpart_c : IF  cnlit IN  TYPEOF(v1)THEN  RETURN(ctmv(v1 \ complex_number_literal.real_part));
 END_IF ;
 ef_ipart_c : IF  cnlit IN  TYPEOF(v1)THEN  RETURN(ctmv(v1 \ complex_number_literal.imag_part));
 END_IF ;
 ef_negate_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(- p, - q));
 END_IF ;
 ef_reciprocal_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := p * p + q * q;
 RETURN(makec(p / t, - q / t));
 END_IF ;
 ef_add_c : BEGIN  p := 0.0;
 q := 0.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  cnlit IN  TYPEOF(vlist [ i ])THEN  parts(vlist [ i ], r, s);
 p := p + r;
 q := q + s;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(makec(p, q));
 END_IF ;
 IF  p * p + q * q <> 0.0 THEN  INSERT(vlist, makec(p, q), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 RETURN(makec(p - r, q - s));
 END_IF ;
 ef_multiply_c : BEGIN  p := 1.0;
 q := 0.0;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  cnlit IN  TYPEOF(vlist [ i ])THEN  parts(vlist [ i ], r, s);
 p := p * r - q * s;
 q := p * s + q * r;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(makec(p, q));
 END_IF ;
 IF(p <> 1.0)OR(q <> 0.0)THEN  INSERT(vlist, makec(p, q), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_divide_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 t := r * r + s * s;
 RETURN(makec((p * r + q * s)/ t,(q * r - p * s)/ t));
 END_IF ;
 ef_exponentiate_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 t := 0.5 * LOG(p * p + q * q);
 u := atan2(q, p);
 p := r * t - s * u;
 q := r * u + s * t;
 r := EXP(p);
 RETURN(makec(r * COS(q), r * SIN(q)));
 END_IF ;
 ef_exponentiate_ci : IF(cnlit IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  parts(v1, p, q);
 k := v2;
 r := 1.0;
 s := 0.0;
 REPEAT  i := 1 TO  ABS(k);
 r := p * r - q * s;
 s := p * s + q * r;
 END_REPEAT ;
 IF  k < 0 THEN  t := r * r + s * s;
 r := r / t;
 s := - s / t;
 END_IF ;
 RETURN(makec(r, s));
 END_IF ;
 ef_eq_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 RETURN(ctmv((p = r)AND(q = s)));
 END_IF ;
 ef_ne_c : IF(cnlit IN  TYPEOF(v1))AND(cnlit IN  TYPEOF(v2))THEN  parts(v1, p, q);
 parts(v2, r, s);
 RETURN(ctmv((p <> r)OR(q <> s)));
 END_IF ;
 ef_conjugate_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(p, - q));
 END_IF ;
 ef_abs_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(ctmv(SQRT(p * p + q * q)));
 END_IF ;
 ef_arg_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(ctmv(atan2(q, p)));
 END_IF ;
 ef_cos_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := 0.5 * EXP(- q);
 u := 0.5 * EXP(q);
 RETURN(makec((t + u)* COS(p),(t - u)* SIN(p)));
 END_IF ;
 ef_exp_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(EXP(p)* COS(q), EXP(p)* SIN(q)));
 END_IF ;
 ef_ln_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 RETURN(makec(0.5 * LOG(p * p + q * q), atan2(q, p)));
 END_IF ;
 ef_sin_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := 0.5 * EXP(- q);
 u := 0.5 * EXP(q);
 RETURN(makec((t + u)* SIN(p),(u - t)* COS(p)));
 END_IF ;
 ef_sqrt_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := SQRT(SQRT(p * p + q * q));
 u := 0.5 * atan2(q, p);
 RETURN(makec(t * COS(u), t * SIN(u)));
 END_IF ;
 ef_tan_c : IF  cnlit IN  TYPEOF(v1)THEN  parts(v1, p, q);
 t := EXP(2.0 * q)+ EXP(- 2.0 * q)+ 2.0 * COS(2.0 * p);
 RETURN(makec(2.0 * SIN(2.0 * p)/ t,(EXP(- 2.0 * q)- EXP(2.0 * q))/ t));
 END_IF ;
 ef_subscript_s : IF('STRING' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  str := v1;
 k := v2;
 RETURN(ctmv(str [ k ]));
 END_IF ;
 ef_eq_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str = st2));
 END_IF ;
 ef_ne_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str <> st2));
 END_IF ;
 ef_gt_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str > st2));
 END_IF ;
 ef_lt_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str < st2));
 END_IF ;
 ef_ge_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str >= st2));
 END_IF ;
 ef_le_s : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  str := v1;
 st2 := v2;
 RETURN(ctmv(str <= st2));
 END_IF ;
 ef_subsequence_s : IF('STRING' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))AND('INTEGER' IN  TYPEOF(v3))THEN  str := v1;
 j := v2;
 k := v3;
 RETURN(ctmv(str [ j : k ]));
 END_IF ;
 ef_concat_s : BEGIN  str := '';
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'STRING' IN  TYPEOF(vlist [ i ])THEN  st2 := vlist [ i ];
 str := str + st2;
 REMOVE(vlist, i);
 ELSE  IF  str <> '' THEN  INSERT(vlist, ctmv(str), i);
 str := '';
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(str));
 END_IF ;
 IF  str <> '' THEN  INSERT(vlist, ctmv(str), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_size_s : IF  'STRING' IN  TYPEOF(v1)THEN  str := v1;
 RETURN(ctmv(LENGTH(str)));
 END_IF ;
 ef_format : IF('NUMBER' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  RETURN(ctmv(FORMAT(v1, v2)));
 END_IF ;
 ef_value : IF  'STRING' IN  TYPEOF(v1)THEN  str := v1;
 RETURN(ctmv(VALUE(str)));
 END_IF ;
 ef_like : IF('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  RETURN(ctmv(v1 LIKE v2));
 END_IF ;
 ef_subscript_b : IF('BINARY' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  bin := v1;
 k := v2;
 RETURN(ctmv(bin [ k ]));
 END_IF ;
 ef_eq_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin = bi2));
 END_IF ;
 ef_ne_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin <> bi2));
 END_IF ;
 ef_gt_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin > bi2));
 END_IF ;
 ef_lt_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin < bi2));
 END_IF ;
 ef_ge_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin >= bi2));
 END_IF ;
 ef_le_b : IF('BINARY' IN  TYPEOF(v1))AND('BINARY' IN  TYPEOF(v2))THEN  bin := v1;
 bi2 := v2;
 RETURN(ctmv(bin <= bi2));
 END_IF ;
 ef_subsequence_b : IF('BINARY' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))AND('INTEGER' IN  TYPEOF(v3))THEN  bin := v1;
 j := v2;
 k := v3;
 RETURN(ctmv(bin [ j : k ]));
 END_IF ;
 ef_concat_b : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'BINARY' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  bi2 := vlist [ i ];
 bin := bin + bi2;
 ELSE  bin := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(vlist, i);
 ELSE  IF  boo THEN  INSERT(vlist, ctmv(bin), i);
 boo := FALSE ;
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(bin));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(bin), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_size_b : IF  'BINARY' IN  TYPEOF(v1)THEN  bin := v1;
 RETURN(ctmv(BLENGTH(bin)));
 END_IF ;
 ef_subscript_t : IF('LIST' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  tpl := v1;
 k := v2;
 RETURN(ctmv(tpl [ k ]));
 END_IF ;
 ef_eq_t : IF('LIST' IN  TYPEOF(v1))AND('LIST' IN  TYPEOF(v2))THEN  lgc := equal_maths_values(v1, v2);
 IF  lgc <> UNKNOWN  THEN  RETURN(ctmv(lgc));
 END_IF ;
 END_IF ;
 ef_ne_t : IF('LIST' IN  TYPEOF(v1))AND('LIST' IN  TYPEOF(v2))THEN  lgc := equal_maths_values(v1, v2);
 IF  lgc <> UNKNOWN  THEN  RETURN(ctmv(NOT  lgc));
 END_IF ;
 END_IF ;
 ef_concat_t : BEGIN  tpl := [ ];
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'STRING' IN  TYPEOF(vlist [ i ])THEN  tp2 := vlist [ i ];
 tpl := tpl + tp2;
 REMOVE(vlist, i);
 ELSE  IF  SIZEOF(tpl)<> 0 THEN  INSERT(vlist, ctmv(tpl), i);
 tpl := [ ];
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  SIZEOF(tpl)<> 0 THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_size_t : IF  'LIST' IN  TYPEOF(v1)THEN  tpl := v1;
 RETURN(ctmv(SIZEOF(tpl)));
 END_IF ;
 ef_entuple : RETURN(ctmv(vlist));
 ef_detuple : IF  'LIST' IN  TYPEOF(v1)THEN  tpl := v1;
 RETURN(ctmv(tpl [ 1 ]));
 END_IF ;
 ef_insert : IF('LIST' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v3))THEN  tpl := v1;
 k := v3;
 INSERT(tpl, v2, k);
 RETURN(ctmv(tpl));
 END_IF ;
 ef_remove : IF('LIST' IN  TYPEOF(v1))AND('INTEGER' IN  TYPEOF(v2))THEN  tpl := v1;
 k := v2;
 REMOVE(tpl, k);
 RETURN(ctmv(tpl));
 END_IF ;
 ef_sum_it : IF  good_t(v1, 'INTEGER')THEN  tpl := v1;
 j := 0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 j := j + tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(j));
 END_IF ;
 ef_product_it : IF  good_t(v1, 'INTEGER')THEN  tpl := v1;
 j := 1;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 j := j * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(j));
 END_IF ;
 ef_add_it : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  good_t(vlist [ i ], 'INTEGER')THEN  IF  NOT  boo THEN  tpl := vlist [ i ];
 boo := TRUE ;
 ELSE  tp2 := vlist [ i ];
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(tpl);
 tpl [ j ] := tpl [ j ] + tp2 [ j ];
 END_REPEAT ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_it : IF  good_t(v1, 'INTEGER')AND  good_t(v2, 'INTEGER')THEN  tpl := v1;
 tp2 := v2;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := tpl [ i ] - tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_scalar_mult_it : IF('INTEGER' IN  TYPEOF(v1))AND  good_t(v2, 'INTEGER')THEN  j := v1;
 tpl := v2;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := j * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_dot_prod_it : IF  good_t(v1, 'INTEGER')AND  good_t(v2, 'INTEGER')THEN  tpl := v1;
 tp2 := v2;
 j := 0;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 j := j + tpl [ i ] * tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(j));
 END_IF ;
 ef_sum_rt : IF  good_t(v1, 'REAL')THEN  tpl := v1;
 r := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r + tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(r));
 END_IF ;
 ef_product_rt : IF  good_t(v1, 'REAL')THEN  tpl := v1;
 r := 1.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(r));
 END_IF ;
 ef_add_rt : BEGIN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  good_t(vlist [ i ], 'REAL')THEN  IF  NOT  boo THEN  tpl := vlist [ i ];
 boo := TRUE ;
 ELSE  tp2 := vlist [ i ];
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(tpl);
 tpl [ j ] := tpl [ j ] + tp2 [ j ];
 END_REPEAT ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END ;
 ef_subtract_rt : IF  good_t(v1, 'REAL')AND  good_t(v2, 'REAL')THEN  tpl := v1;
 tp2 := v2;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := tpl [ i ] - tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_scalar_mult_rt : IF('REAL' IN  TYPEOF(v1))AND  good_t(v2, 'REAL')THEN  r := v1;
 tpl := v2;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 tpl [ i ] := r * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_dot_prod_rt : IF  good_t(v1, 'REAL')AND  good_t(v2, 'REAL')THEN  tpl := v1;
 tp2 := v2;
 r := 0;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r + tpl [ i ] * tp2 [ i ];
 END_REPEAT ;
 RETURN(ctmv(r));
 END_IF ;
 ef_norm_rt : IF  good_t(v1, 'REAL')THEN  tpl := v1;
 r := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 r := r + tpl [ i ] * tpl [ i ];
 END_REPEAT ;
 RETURN(ctmv(SQRT(r)));
 END_IF ;
 ef_sum_ct : IF  good_t(v1, cnlit)THEN  tpl := v1;
 p := 0.0;
 q := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], r, s);
 p := p + r;
 q := q + s;
 END_REPEAT ;
 RETURN(makec(p, q));
 END_IF ;
 ef_product_ct : IF  good_t(v1, cnlit)THEN  tpl := v1;
 p := 1.0;
 q := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], r, s);
 p := p * r - q * s;
 q := p * s + q * r;
 END_REPEAT ;
 RETURN(makec(p, q));
 END_IF ;
 ef_add_ct : BEGIN boo := FALSE;
 REPEAT  i := SIZEOF(vlist)TO  1 BY - 1;
 IF  good_t(vlist [ i ], cnlit)THEN  IF  NOT boo THEN  tpl := vlist [ i ];
 boo := TRUE;
 ELSE  tp2 := vlist [ i ];
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  l := 1 TO  SIZEOF(tpl);
 parts(tpl [ j ], p, q);
 parts(tp2 [ j ], r, s);
 tpl [ j ] := makec(p + r, q + s);
 END_REPEAT ;
 END_IF ;
 REMOVE(vlist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(vlist)= 0 THEN  RETURN(ctmv(tpl));
 END_IF ;
 IF  boo THEN  INSERT(vlist, ctmv(tpl), 0);
 END_IF ;
 IF  SIZEOF(vlist)= 1 THEN  RETURN(vlist [ 1 ]);
 END_IF ;
 END;
 ef_subtract_ct : IF  good_t(v1, cnlit)AND  good_t(v2, cnlit)THEN  tpl := v1;
 tp2 := v2;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], p, q);
 parts(tp2 [ i ], r, s);
 tpl [ i ] := makec(p - r, q - s);
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_scalar_mult_ct : IF(cnlit IN  TYPEOF(v1))AND  good_t(v2, cnlit)THEN  parts(v1, p, q);
 tpl := v2;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], r, s);
 tpl [ i ] := makec(p * r - q * s, p * s + q * r);
 END_REPEAT ;
 RETURN(ctmv(tpl));
 END_IF ;
 ef_dot_prod_ct : IF  good_t(v1, cnlit)AND good_t(v2, cnlit)THEN  tpl := v1;
 tp2 := v2;
 t := 0.0;
 u := 0.0;
 IF  SIZEOF(tpl)<> SIZEOF(tp2)THEN  RETURN(?);
 END_IF ;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], p, q);
 parts(tp2 [ i ], r, s);
 t := t + p * r + q * s;
 u := u + q * r - p * s;
 END_REPEAT ;
 RETURN(makec(t, u));
 END_IF ;
 ef_norm_ct : IF  good_t(v1, cnlit)THEN  tpl := v1;
 r := 0.0;
 REPEAT  i := 1 TO  SIZEOF(tpl);
 parts(tpl [ i ], p, q);
 r := r + p * p + q * q;
 END_REPEAT ;
 RETURN(ctmv(SQRT(r)));
 END_IF ;
 ef_if, ef_if_i, ef_if_r, ef_if_c, ef_if_s, ef_if_b, ef_if_t : IF  'LOGICAL' IN  TYPEOF(v1)THEN  lgc := v1;
 IF  lgc THEN  RETURN(v2);
 ELSE RETURN(v3);
 END_IF ;
 END_IF ;
 ef_ensemble : RETURN(make_finite_space(mem + vlist));
 ef_member_of : IF(schema_prefix + 'MATHS_SPACE')IN  TYPEOF(v2)THEN  lgc := member_of(v1, v2);
 IF  lgc <> UNKNOWN THEN  RETURN(ctmv(lgc));
 END_IF ;
 END_IF ;
 END_CASE;
 RETURN(make_function_application(expr.func, vlist));
 END_IF ;
 IF  'ABSTRACTED_EXPRESSION_FUNCTION' IN  types THEN  gexpr := substitute(expr.func \ abstracted_expression_function.expr, expr.func \ quantifier_expression.variables, vlist);
 RETURN(simplify_generic_expression(gexpr));
 END_IF ;
 IF  'FINITE_FUNCTION' IN types THEN  pairs := expr.func \ finite_function.pairs;
 REPEAT i := 1 TO SIZEOF(pairs);
 IF equal_maths_values(vlist [ 1 ], pairs [ i ] [ 1 ])THEN RETURN(simplify_maths_value(pairs [ i ] [ 2 ]));
 END_IF ;
 END_REPEAT;
 RETURN(make_function_application(expr.func, vlist));
 END_IF;
 RETURN(expr);
 END_FUNCTION; -- simplify_function_application

FUNCTION simplify_generic_expression
	(expr : generic_expression) : maths_value;
 LOCAL
 types : SET OF  STRING  := stripped_typeof(expr);
 v1, v2 : maths_value;
 vlist : LIST  OF  maths_value := [ ];
 op1, op2 : generic_expression;
 oplist : LIST  OF  generic_expression := [ ];
 opnds : LIST [ 2 : ? ] OF generic_expression;
 n, m : INTEGER;
 finfun : maths_function_select;
 boo : BOOLEAN;
 str : STRING;
 nmb : NUMBER;
 END_LOCAL
;
 IF  'INT_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ int_literal.the_value));
 END_IF ;
 IF  'REAL_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ real_literal.the_value));
 END_IF ;
 IF  'BOOLEAN_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ boolean_literal.the_value));
 END_IF ;
 IF  'STRING_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ string_literal.the_value));
 END_IF ;
 IF  'COMPLEX_NUMBER_LITERAL' IN  types THEN  RETURN(expr);
 END_IF ;
 IF  'LOGICAL_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ logical_literal.lit_value));
 END_IF ;
 IF  'BINARY_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ binary_literal.lit_value));
 END_IF ;
 IF  'MATHS_ENUM_LITERAL' IN  types THEN  RETURN(expr \ maths_enum_literal.lit_value);
 END_IF ;
 IF  'REAL_TUPLE_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ real_tuple_literal.lit_value));
 END_IF ;
 IF  'INTEGER_TUPLE_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ integer_tuple_literal.lit_value));
 END_IF ;
 IF  'ATOM_BASED_LITERAL' IN  types THEN  RETURN(expr \ atom_based_literal.lit_value);
 END_IF ;
 IF  'MATHS_TUPLE_LITERAL' IN  types THEN  RETURN(convert_to_maths_value(expr \ maths_tuple_literal.lit_value));
 END_IF ;
 IF  'MATHS_SPACE' IN  types THEN  RETURN(simplify_maths_space(expr));
 END_IF ;
 IF  'FUNCTION_APPLICATION' IN  types THEN  RETURN(simplify_function_application(expr));
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  types THEN  v1 := simplify_generic_expression(expr \ unary_generic_expression.operand);
 op1 := convert_to_operand(v1);
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  types THEN  v1 := simplify_generic_expression(expr \ binary_generic_expression.operands [ 1 ]);
 op1 := convert_to_operand(v1);
 v2 := simplify_generic_expression(expr \ binary_generic_expression.operands [ 2 ]);
 op2 := convert_to_operand(v2);
 END_IF ;
 IF  'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN  types THEN  opnds := expr \ multiple_arity_generic_expression.operands;
 REPEAT  i := 1 TO  SIZEOF(opnds);
 v1 := simplify_generic_expression(opnds [ i ]);
 INSERT(vlist, v1, i - 1);
 INSERT(oplist, convert_to_operand(v1), i - 1);
 END_REPEAT ;
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  types THEN  v1 := vlist [ 1 ];
 n := SIZEOF(vlist);
 finfun := vlist [ n ];
 REMOVE(vlist, n);
 REMOVE(vlist, 1);
 RETURN(make_parallel_composed_function(v1, vlist, finfun));
 END_IF ;
 IF('ABS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ABS(v1)));
 END_IF ;
 IF('ACOS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ACOS(v1)));
 END_IF ;
 IF  'AND_EXPRESSION' IN  types THEN  REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'BOOLEAN' IN  TYPEOF(vlist [ i ])THEN  boo := vlist [ i ];
 IF  NOT  boo THEN  RETURN(convert_to_maths_value(FALSE));
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(TRUE));
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('ASIN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ASIN(v1)));
 END_IF ;
 IF('ATAN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(ATAN(v1, v2)));
 END_IF ;
 IF('COMPARISON_EXPRESSION' IN  types)AND((('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2)))OR(('STRING' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2)))OR(('BOOLEAN' IN  TYPEOF(v1))AND('BOOLEAN' IN  TYPEOF(v2))))THEN  IF  'COMPARISON_EQUAL' IN  types THEN  boo := bool(v1 = v2);
 ELSE  IF  'COMPARISON_GREATER' IN  types THEN  boo := bool(v1 > v2);
 ELSE  IF  'COMPARISON_GREATER_EQUAL' IN  types THEN  boo := bool(v1 >= v2);
 ELSE  IF  'COMPARISON_LESS' IN  types THEN  boo := bool(v1 < v2);
 ELSE  IF  'COMPARISON_LESS_EQUAL' IN  types THEN  boo := bool(v1 <= v2);
 ELSE  IF  'COMPARISON_NOT_EQUAL' IN  types THEN  boo := bool(v1 <> v2);
 ELSE  IF  'LIKE_EXPRESSION' IN  types THEN  boo := bool(v1 LIKE v2);
 ELSE  RETURN(?);
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 END_IF ;
 RETURN(convert_to_maths_value(boo));
 END_IF ;
 IF  'CONCAT_EXPRESSION' IN  types THEN  str := '';
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'STRING' IN  TYPEOF(vlist [ i ])THEN  str := vlist [ i ] + str;
 REMOVE(oplist, i);
 ELSE  IF  LENGTH(str)> 0 THEN  INSERT(oplist, make_string_literal(str), i);
 str := '';
 END_IF ;
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(str));
 END_IF ;
 IF  LENGTH(str)> 0 THEN  INSERT(oplist, make_string_literal(str), 0);
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('COS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(COS(v1)));
 END_IF ;
 IF('DIV_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 DIV v2));
 END_IF ;
 IF  'EQUALS_EXPRESSION' IN  types THEN  opnds := expr \ binary_generic_expression.operands;
 RETURN(convert_to_maths_value(opnds [ 1 ] :=: opnds [ 2 ]));
 END_IF ;
 IF('EXP_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(EXP(v1)));
 END_IF ;
 IF('FORMAT_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('STRING' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(FORMAT(v1, v2)));
 END_IF ;
 IF('INDEX_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  str := v1;
 n := v2;
 RETURN(convert_to_maths_value(str [ n ]));
 END_IF ;
 IF('INT_VALUE_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(VALUE(v1)));
 END_IF ;
 IF  'INTERVAL_EXPRESSION' IN  types THEN  str := '';
 IF  'NUMBER' IN  TYPEOF(vlist [ 1 ])THEN  str := 'NUMBER';
 END_IF ;
 IF  'STRING' IN  TYPEOF(vlist [ 1 ])THEN  str := 'STRING';
 END_IF ;
 IF  'BOOLEAN' IN  TYPEOF(vlist [ 1 ])THEN  str := 'BOOLEAN';
 END_IF ;
 IF(LENGTH(str)> 0)AND(str IN  TYPEOF(vlist [ 2 ]))AND(str IN  TYPEOF(vlist [ 3 ]))THEN  RETURN(convert_to_maths_value({ vlist [ 1 ] <= vlist [ 2 ] <= vlist [ 3 ] }));
 END_IF ;
 END_IF ;
 IF('LENGTH_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LENGTH(v1)));
 END_IF ;
 IF('LOG_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LOG(v1)));
 END_IF ;
 IF('LOG10_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LOG10(v1)));
 END_IF ;
 IF('LOG2_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(LOG2(v1)));
 END_IF ;
 IF  'MAXIMUM_EXPRESSION' IN  types THEN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  IF  nmb < vlist [ i ] THEN  nmb := vlist [ i ];
 END_IF ;
 ELSE  nmb := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  boo THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 END_IF ;
 IF  'MINIMUM_EXPRESSION' IN  types THEN  boo := FALSE ;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  IF  boo THEN  IF  nmb > vlist [ i ] THEN  nmb := vlist [ i ];
 END_IF ;
 ELSE nmb := vlist [ i ];
 boo := TRUE ;
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  boo THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 END_IF ;
 IF('MINUS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 - v2));
 END_IF ;
 IF('MOD_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 MOD v2));
 END_IF ;
 IF  'MULT_EXPRESSION' IN  types THEN  nmb := 1;
 REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  nmb := nmb * vlist [ i ];
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  nmb <> 1 THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('NOT_EXPRESSION' IN  types)AND('BOOLEAN' IN  TYPEOF(v1))THEN  boo := v1;
 RETURN(convert_to_maths_value(NOT(boo)));
 END_IF ;
 IF('ODD_EXPRESSION' IN  types)AND('INTEGER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(ODD(v1)));
 END_IF ;
 IF  'OR_EXPRESSION' IN  types THEN  REPEAT  i := SIZEOF(vlist)TO  1 BY  - 1;
 IF  'BOOLEAN' IN  TYPEOF(vlist [ i ])THEN  boo := vlist [ i ];
 IF  boo THEN  RETURN(convert_to_maths_value(TRUE));
 END_IF ;
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT ;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(FALSE));
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF  'PLUS_EXPRESSION' IN  types THEN  nmb := 0;
 REPEAT i := SIZEOF(vlist)TO 1 BY - 1;
 IF  'NUMBER' IN  TYPEOF(vlist [ i ])THEN  nmb := nmb + vlist [ i ];
 REMOVE(oplist, i);
 END_IF ;
 END_REPEAT;
 IF  SIZEOF(oplist)= 0 THEN  RETURN(convert_to_maths_value(nmb));
 END_IF ;
 IF  nmb <> 0 THEN  INSERT(oplist, make_number_literal(nmb), 0);
 END_IF ;
 IF  SIZEOF(oplist)= 1 THEN  RETURN(oplist [ 1 ]);
 END_IF ;
 END_IF ;
 IF('POWER_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 ** v2));
 END_IF ;
 IF('SIN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(SIN(v1)));
 END_IF ;
 IF('SLASH_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))AND('NUMBER' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 / v2));
 END_IF ;
 IF('SQUARE_ROOT_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(SQRT(v1)));
 END_IF ;
 IF('SUBSTRING_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(vlist [ 1 ]))AND('NUMBER' IN  TYPEOF(vlist [ 2 ]))AND('NUMBER' IN  TYPEOF(vlist [ 3 ]))THEN  str := vlist [ 1 ];
 n := vlist [ 2 ];
 m := vlist [ 3 ];
 RETURN(convert_to_maths_value(str [ n : m ]));
 END_IF ;
 IF('TAN_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(TAN(v1)));
 END_IF ;
 IF('UNARY_MINUS_EXPRESSION' IN  types)AND('NUMBER' IN  TYPEOF(v1))THEN  nmb := v1;
 RETURN(convert_to_maths_value(- nmb));
 END_IF ;
 IF('VALUE_EXPRESSION' IN  types)AND('STRING' IN  TYPEOF(v1))THEN  RETURN(convert_to_maths_value(VALUE(v1)));
 END_IF ;
 IF('XOR_EXPRESSION' IN  types)AND('BOOLEAN' IN  TYPEOF(v1))AND('BOOLEAN' IN  TYPEOF(v2))THEN  RETURN(convert_to_maths_value(v1 XOR v2));
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  types THEN  RETURN(restore_unary(expr, op1));
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  types THEN  RETURN(restore_binary(expr, op1, op2));
 END_IF ;
 IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN RETURN(restore_mulary(expr, oplist));
 END_IF;
 RETURN(expr);
 END_FUNCTION; -- simplify_generic_expression

FUNCTION simplify_maths_space
	(spc : maths_space) : maths_space;
 LOCAL
 stypes : SET  OF  STRING := stripped_typeof(spc);
 sset : SET  OF  maths_value;
 zset : SET OF  maths_value := [ ];
 zval : maths_value;
 zspc : maths_space;
 zallint : BOOLEAN := TRUE;
 zint, zmin, zmax : INTEGER;
 factors : LIST  OF  maths_space;
 zfactors : LIST OF maths_space := [ ];
 rspc : maths_space;
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  stypes THEN  sset := spc \ finite_space.members;
 REPEAT  i := 1 TO  SIZEOF(sset);
 zval := simplify_maths_value(sset [ i ]);
 zset := zset + [ zval ];
 IF  zallint AND('INTEGER' IN  TYPEOF(zval))THEN  zint := zval;
 IF  i = 1 THEN  zmin := zint;
 zmax := zint;
 ELSE  IF  zint < zmin THEN  zmin := zint;
 END_IF ;
 IF  zint > zmax THEN  zmax := zint;
 END_IF ;
 END_IF ;
 ELSE zallint := FALSE;
 END_IF ;
 END_REPEAT ;
 IF  zallint AND(SIZEOF(zset)= zmax - zmin + 1)THEN  RETURN(make_finite_integer_interval(zmin, zmax));
 END_IF ;
 RETURN(make_finite_space(zset));
 END_IF ;
 IF  'UNIFORM_PRODUCT_SPACE' IN  stypes THEN  zspc := simplify_maths_space(spc \ uniform_product_space.base);
 RETURN(make_uniform_product_space(zspc, spc \ uniform_product_space.exponent));
 END_IF ;
 IF  'LISTED_PRODUCT_SPACE' IN  stypes THEN  factors := spc \ listed_product_space.factors;
 REPEAT i := 1 TO SIZEOF(factors);
 INSERT(zfactors, simplify_maths_space(factors [ i ]), i - 1);
 END_REPEAT;
 RETURN(make_listed_product_space(zfactors));
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  stypes THEN  zspc := simplify_maths_space(spc \ extended_tuple_space.base);
 rspc := simplify_maths_space(spc \ extended_tuple_space.extender);
 RETURN(make_extended_tuple_space(zspc, rspc));
 END_IF ;
 IF 'FUNCTION_SPACE' IN stypes THEN zspc := simplify_maths_space(spc \ function_space.domain_argument);
 rspc := simplify_maths_space(spc \ function_space.range_argument);
 RETURN(make_function_space(spc \ function_space.domain_constraint, zspc, spc \ function_space.range_constraint, rspc));
 END_IF;
 RETURN(spc);
 END_FUNCTION; -- simplify_maths_space

FUNCTION simplify_maths_value
	(val : maths_value) : maths_value;
 LOCAL
 vtypes : SET OF  STRING := stripped_typeof(val);
 vlist : LIST  OF  maths_value;
 nlist : LIST OF maths_value := [ ];
 END_LOCAL
;
 IF  'GENERIC_EXPRESSION' IN  vtypes THEN  RETURN(simplify_generic_expression(val));
 END_IF ;
 IF 'LIST' IN vtypes THEN vlist := val;
 REPEAT i := 1 TO SIZEOF(vlist);
 INSERT(nlist, simplify_maths_value(vlist [ i ]), i - 1);
 END_REPEAT;
 RETURN(convert_to_maths_value(nlist));
 END_IF;
 RETURN(val);
 END_FUNCTION; -- simplify_maths_value

FUNCTION singleton_member_of
	(spc : maths_space) : maths_value;
 LOCAL
 types : SET OF STRING := stripped_typeof(spc);
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  types THEN  IF  SIZEOF(spc \ finite_space.members)= 1 THEN  RETURN(spc \ finite_space.members [ 1 ]);
 END_IF ;
 RETURN(?);
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN types THEN  IF spc \ finite_integer_interval.size = 1 THEN RETURN(spc \ finite_integer_interval.min);
 END_IF ;
 RETURN(?);
 END_IF;
 RETURN(?);
 END_FUNCTION; -- singleton_member_of

FUNCTION space_dimension
	(tspace : tuple_space) : nonnegative_integer;
 LOCAL
 types : SET OF STRING := TYPEOF(tspace);
 END_LOCAL
;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  types THEN  RETURN(tspace \ uniform_product_space.exponent);
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN  types THEN  RETURN(SIZEOF(tspace \ listed_product_space.factors));
 END_IF ;
 IF(schema_prefix + 'EXTENDED_TUPLE_SPACE')IN types THEN RETURN(space_dimension(tspace \ extended_tuple_space.base));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- space_dimension

FUNCTION space_is_continuum
	(space : maths_space) : BOOLEAN;
 LOCAL
 typenames : SET OF  STRING := TYPEOF(space);
 factors : LIST OF maths_space;
 END_LOCAL
;
 IF  NOT  EXISTS(space)THEN  RETURN(FALSE );
 END_IF ;
 IF  subspace_of_es(space, es_reals)OR subspace_of_es(space, es_complex_numbers)THEN  RETURN(TRUE );
 END_IF ;
 IF(schema_prefix + 'UNIFORM_PRODUCT_SPACE')IN  typenames THEN  RETURN(space_is_continuum(space \ uniform_product_space.base));
 END_IF ;
 IF(schema_prefix + 'LISTED_PRODUCT_SPACE')IN typenames THEN  factors := space \ listed_product_space.factors;
 IF  SIZEOF(factors)= 0 THEN  RETURN(FALSE );
 END_IF ;
 REPEAT i := 1 TO SIZEOF(factors);
 IF NOT space_is_continuum(factors [ i ])THEN RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(TRUE);
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- space_is_continuum

FUNCTION space_is_singleton
	(spc : maths_space) : BOOLEAN;
 LOCAL
 types : SET OF STRING := stripped_typeof(spc);
 END_LOCAL
;
 IF  'FINITE_SPACE' IN  types THEN  RETURN(bool(SIZEOF(spc \ finite_space.members)= 1));
 END_IF ;
 IF 'FINITE_INTEGER_INTERVAL' IN types THEN RETURN(bool(spc \ finite_integer_interval.size = 1));
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- space_is_singleton

FUNCTION strictly_in
	(z : REAL; zitv : real_interval) : LOGICAL;
 RETURN((NOT  min_exists(zitv)OR(z > real_min(zitv)))AND(NOT max_exists(zitv)OR(z < real_max(zitv))));
 END_FUNCTION; -- strictly_in

FUNCTION strictly_in2
	(a : REAL; aitv : finite_real_interval) : LOGICAL;
 a := angle2(a);
 RETURN({ aitv.min < a < aitv.max } OR { aitv.min < a + 2.0 * PI < aitv.max });
 END_FUNCTION; -- strictly_in2

FUNCTION stripped_typeof
	(arg : GENERIC:G) : SET [0:?] OF STRING;
 LOCAL
 types : SET  OF  STRING  := TYPEOF(arg);
 stypes : SET OF STRING := [ ];
 n : INTEGER := LENGTH(schema_prefix);
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(types);
 IF types [ i ] [ 1 : n ] = schema_prefix THEN stypes := stypes + [ types [ i ] [ n + 1 : LENGTH(types [ i ])] ];
 ELSE stypes := stypes + [ types [ i ] ];
 END_IF;
 END_REPEAT;
 RETURN(stypes);
 END_FUNCTION; -- stripped_typeof

FUNCTION subspace_of
	(space1 : maths_space; space2 : maths_space) : LOGICAL;
 LOCAL
 spc1 : maths_space := simplify_maths_space(space1);
 spc2 : maths_space := simplify_maths_space(space2);
 types1 : SET  OF  STRING  := stripped_typeof(spc1);
 types2 : SET OF  STRING := stripped_typeof(spc2);
 lgcl, cum : LOGICAL;
 es_val : elementary_space_enumerators;
 bnd1, bnd2 : REAL;
 n : INTEGER;
 sp1, sp2 : maths_space;
 prgn1, prgn2 : polar_complex_number_region;
 aitv : finite_real_interval;
 END_LOCAL
;
 IF  NOT  EXISTS(spc1)OR  NOT  EXISTS(spc2)THEN  RETURN(FALSE );
 END_IF ;
 IF  spc2 = the_generics THEN  RETURN(TRUE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types1 THEN  IF  NOT('ELEMENTARY_SPACE' IN  types2)THEN  RETURN(FALSE );
 END_IF ;
 es_val := spc2 \ elementary_space.space_id;
 IF  spc1 \ elementary_space.space_id = es_val THEN  RETURN(TRUE );
 END_IF ;
 CASE  spc1 \ elementary_space.space_id OF  es_numbers : RETURN(FALSE );
 es_complex_numbers : RETURN(es_val = es_numbers);
 es_reals : RETURN(es_val = es_numbers);
 es_integers : RETURN(es_val = es_numbers);
 es_logicals : RETURN(FALSE );
 es_booleans : RETURN(es_val = es_logicals);
 es_strings : RETURN(FALSE );
 es_binarys : RETURN(FALSE );
 es_maths_spaces : RETURN(FALSE );
 es_maths_functions : RETURN(FALSE );
 es_generics : RETURN(FALSE );
 END_CASE ;
 RETURN(UNKNOWN );
 END_IF ;
 IF  'FINITE_INTEGER_INTERVAL' IN  types1 THEN  cum := TRUE ;
 REPEAT  i := spc1 \ finite_integer_interval.min TO  spc1 \ finite_integer_interval.max;
 cum := cum AND  member_of(i, spc2);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'INTEGER_INTERVAL_FROM_MIN' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_integers));
 END_IF ;
 IF  'INTEGER_INTERVAL_FROM_MIN' IN  types2 THEN  RETURN(spc1 \ integer_interval_from_min.min >= spc2 \ integer_interval_from_min.min);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'INTEGER_INTERVAL_TO_MAX' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_integers));
 END_IF ;
 IF  'INTEGER_INTERVAL_TO_MAX' IN  types2 THEN  RETURN(spc1 \ integer_interval_to_max.max <= spc2 \ integer_interval_to_max.max);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_REAL_INTERVAL' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_reals));
 END_IF ;
 IF('FINITE_REAL_INTERVAL' IN  types2)OR('REAL_INTERVAL_FROM_MIN' IN  types2)OR('REAL_INTERVAL_TO_MAX' IN  types2)THEN  IF  min_exists(spc2)THEN  bnd1 := spc1 \ finite_real_interval.min;
 bnd2 := real_min(spc2);
 IF(bnd1 < bnd2)OR((bnd1 = bnd2)AND  min_included(spc1)AND  NOT  min_included(spc2))THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  max_exists(spc2)THEN  bnd1 := spc1 \ finite_real_interval.max;
 bnd2 := real_max(spc2);
 IF(bnd1 > bnd2)OR((bnd1 = bnd2)AND  max_included(spc1)AND  NOT  max_included(spc2))THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 RETURN(TRUE );
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_FROM_MIN' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_reals));
 END_IF ;
 IF  'REAL_INTERVAL_FROM_MIN' IN  types2 THEN  bnd1 := spc1 \ real_interval_from_min.min;
 bnd2 := spc2 \ real_interval_from_min.min;
 RETURN((bnd2 < bnd1)OR((bnd2 = bnd1)AND(min_included(spc2)OR  NOT  min_included(spc1))));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'REAL_INTERVAL_TO_MAX' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_reals));
 END_IF ;
 IF  'REAL_INTERVAL_TO_MAX' IN  types2 THEN  bnd1 := spc1 \ real_interval_to_max.max;
 bnd2 := spc2 \ real_interval_to_max.max;
 RETURN((bnd2 > bnd1)OR((bnd2 = bnd1)AND(max_included(spc2)OR  NOT  max_included(spc1))));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_complex_numbers));
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  types2 THEN  RETURN(subspace_of(spc1 \ cartesian_complex_number_region.real_constraint, spc2 \ cartesian_complex_number_region.real_constraint)AND  subspace_of(spc1 \ cartesian_complex_number_region.imag_constraint, spc2 \ cartesian_complex_number_region.imag_constraint));
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  types2 THEN  RETURN(subspace_of(enclose_cregion_in_pregion(spc1, spc2 \ polar_complex_number_region.centre), spc2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  es_val := spc2 \ elementary_space.space_id;
 RETURN((es_val = es_numbers)OR(es_val = es_complex_numbers));
 END_IF ;
 IF  'CARTESIAN_COMPLEX_NUMBER_REGION' IN  types2 THEN  RETURN(subspace_of(enclose_pregion_in_cregion(spc1), spc2));
 END_IF ;
 IF  'POLAR_COMPLEX_NUMBER_REGION' IN  types2 THEN  prgn1 := spc1;
 prgn2 := spc2;
 IF  prgn1.centre = prgn2.centre THEN  IF  prgn2.direction_constraint.max > PI  THEN  aitv := make_finite_real_interval(- PI , open, prgn2.direction_constraint.max - 2.0 * PI, prgn2.direction_constraint.max_closure);
 RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint)AND(subspace_of(prgn1.direction_constraint, prgn2.direction_constraint)OR subspace_of(prgn1.direction_constraint, aitv)));
 ELSE RETURN(subspace_of(prgn1.distance_constraint, prgn2.distance_constraint)AND  subspace_of(prgn1.direction_constraint, prgn2.direction_constraint));
 END_IF ;
 END_IF ;
 RETURN(subspace_of(enclose_pregion_in_pregion(prgn1, prgn2.centre), prgn2));
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FINITE_SPACE' IN  types1 THEN  cum := TRUE ;
 REPEAT  i := 1 TO  SIZEOF(spc1 \ finite_space.members);
 cum := cum AND  member_of(spc1 \ finite_space.members [ i ], spc2);
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 IF  'PRODUCT_SPACE' IN  types1 THEN  IF  'PRODUCT_SPACE' IN  types2 THEN  IF  space_dimension(spc1)= space_dimension(spc2)THEN  cum := TRUE ;
 REPEAT  i := 1 TO  space_dimension(spc1);
 cum := cum AND  subspace_of(factor_space(spc1, i), factor_space(spc2, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  IF  space_dimension(spc1)>= space_dimension(spc2)THEN  cum := TRUE ;
 REPEAT  i := 1 TO  space_dimension(spc1);
 cum := cum AND  subspace_of(factor_space(spc1, i), factor_space(spc2, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 RETURN(cum);
 END_IF ;
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'EXTENDED_TUPLE_SPACE' IN  types1 THEN  IF  'EXTENDED_TUPLE_SPACE' IN  types2 THEN  n := space_dimension(spc1);
 IF  n < space_dimension(spc2)THEN  n := space_dimension(spc2);
 END_IF ;
 cum := TRUE ;
 REPEAT i := 1 TO n + 1;
 cum := cum AND  subspace_of(factor_space(spc1, i), factor_space(spc2, i));
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT;
 RETURN(cum);
 END_IF ;
 RETURN(FALSE );
 END_IF ;
 IF  'FUNCTION_SPACE' IN  types1 THEN  IF  'ELEMENTARY_SPACE' IN  types2 THEN  RETURN(spc2 \ elementary_space.space_id = es_maths_functions);
 END_IF ;
 IF  'FUNCTION_SPACE' IN types2 THEN  cum := TRUE;
 sp1 := spc1 \ function_space.domain_argument;
 sp2 := spc2 \ function_space.domain_argument;
 CASE  spc1 \ function_space.domain_constraint OF  sc_equal : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : cum := cum AND  equal_maths_spaces(sp1, sp2);
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : cum := cum AND  member_of(sp1, sp2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : RETURN(FALSE );
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : BEGIN  IF  NOT  member_of(sp1, sp2)THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 END_CASE ;
 END ;
 sc_member : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : cum := cum AND  space_is_singleton(sp1)AND  equal_maths_spaces(singleton_member_of(sp1), sp2);
 sc_subspace : BEGIN  IF  NOT  member_of(sp2, sp1)THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 sc_member : cum := cum AND(subspace_of(sp1, sp2));
 END_CASE ;
 END ;
 END_CASE ;
 IF  cum = FALSE  THEN  RETURN(FALSE );
 END_IF ;
 sp1 := spc1 \ function_space.range_argument;
 sp2 := spc2 \ function_space.range_argument;
 CASE  spc1 \ function_space.range_constraint OF  sc_equal : BEGIN  CASE  spc2 \ function_space.range_constraint OF  sc_equal : cum := cum AND  equal_maths_spaces(sp1, sp2);
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : cum := cum AND  member_of(sp1, sp2);
 END_CASE ;
 END ;
 sc_subspace : BEGIN  CASE  spc2 \ function_space.domain_constraint OF  sc_equal : RETURN(FALSE );
 sc_subspace : cum := cum AND  subspace_of(sp1, sp2);
 sc_member : BEGIN  IF  NOT  member_of(sp1, sp2)THEN  RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 END_CASE ;
 END ;
 sc_member : BEGIN  CASE spc2 \ function_space.domain_constraint OF sc_equal : cum := cum AND  space_is_singleton(sp1)AND  equal_maths_spaces(singleton_member_of(sp1), sp2);
 sc_subspace : BEGIN IF NOT member_of(sp2, sp1)THEN RETURN(FALSE );
 END_IF ;
 cum := UNKNOWN ;
 END ;
 sc_member : cum := cum AND subspace_of(sp1, sp2);
 END_CASE ;
 END;
 END_CASE;
 RETURN(cum);
 END_IF ;
 RETURN(FALSE);
 END_IF;
 RETURN(UNKNOWN);
 END_FUNCTION; -- subspace_of

FUNCTION subspace_of_es
	(spc : maths_space; es : elementary_space_enumerators) : LOGICAL;
 LOCAL
 types : SET OF  STRING := stripped_typeof(spc);
 END_LOCAL
;
 IF  NOT  EXISTS(spc)OR  NOT EXISTS(es)THEN  RETURN(FALSE );
 END_IF ;
 IF  'ELEMENTARY_SPACE' IN  types THEN  RETURN(es_subspace_of_es(spc \ elementary_space.space_id, es));
 END_IF ;
 IF 'FINITE_SPACE' IN  types THEN RETURN(all_members_of_es(spc \ finite_space.members, es));
 END_IF;
 CASE es OF es_numbers : RETURN(('FINITE_INTEGER_INTERVAL' IN  types)OR('INTEGER_INTERVAL_FROM_MIN' IN  types)OR('INTEGER_INTERVAL_TO_MAX' IN  types)OR('FINITE_REAL_INTERVAL' IN  types)OR('REAL_INTERVAL_FROM_MIN' IN  types)OR('REAL_INTERVAL_TO_MAX' IN  types)OR('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types));
 es_complex_numbers : RETURN(('CARTESIAN_COMPLEX_NUMBER_REGION' IN  types)OR('POLAR_COMPLEX_NUMBER_REGION' IN  types));
 es_reals : RETURN(('FINITE_REAL_INTERVAL' IN  types)OR('REAL_INTERVAL_FROM_MIN' IN  types)OR('REAL_INTERVAL_TO_MAX' IN  types));
 es_integers : RETURN(('FINITE_INTEGER_INTERVAL' IN  types)OR('INTEGER_INTERVAL_FROM_MIN' IN  types)OR('INTEGER_INTERVAL_TO_MAX' IN  types));
 es_logicals : RETURN(FALSE );
 es_booleans : RETURN(FALSE );
 es_strings : RETURN(FALSE );
 es_binarys : RETURN(FALSE );
 es_maths_spaces : RETURN(FALSE);
 es_maths_functions : RETURN('FUNCTION_SPACE' IN types);
 es_generics : RETURN(TRUE);
 END_CASE;
 RETURN(UNKNOWN);
 END_FUNCTION; -- subspace_of_es

FUNCTION substitute
	(expr : generic_expression; vars : LIST [1:?] OF generic_variable; vals : LIST [1:?] OF maths_value) : generic_expression;
 LOCAL
 types : SET OF  STRING := stripped_typeof(expr);
 opnds : LIST  OF  generic_expression;
 op1, op2 : generic_expression;
 qvars : LIST  OF  generic_variable;
 srcdom : maths_space_or_function;
 prpfun : LIST [ 1 : ? ] OF maths_function;
 finfun : maths_function_select;
 END_LOCAL
;
 IF  SIZEOF(vars)<> SIZEOF(vals)THEN  RETURN(?);
 END_IF ;
 IF  'GENERIC_LITERAL' IN  types THEN  RETURN(expr);
 END_IF ;
 IF  'GENERIC_VARIABLE' IN  types THEN  REPEAT  i := 1 TO  SIZEOF(vars);
 IF  expr :=: vars [ i ] THEN  RETURN(vals [ i ]);
 END_IF ;
 END_REPEAT ;
 RETURN(expr);
 END_IF ;
 IF  'QUANTIFIER_EXPRESSION' IN  types THEN  qvars := expr \ quantifier_expression.variables;
 REPEAT  i := SIZEOF(vars)TO  1 BY - 1;
 IF  vars [ i ] IN  qvars THEN  REMOVE(vars, i);
 REMOVE(vals, i);
 END_IF ;
 END_REPEAT ;
 opnds := expr \ multiple_arity_generic_expression.operands;
 REPEAT  i := 1 TO  SIZEOF(opnds);
 IF  NOT(opnds [ i ] IN  qvars)THEN  expr \ multiple_arity_generic_expression.operands [ i ] := substitute(opnds [ i ], vars, vals);
 END_IF ;
 END_REPEAT ;
 RETURN(expr);
 END_IF ;
 IF  'UNARY_GENERIC_EXPRESSION' IN  types THEN  op1 := expr \ unary_generic_expression.operand;
 expr \ unary_generic_expression.operand := substitute(op1, vars, vals);
 END_IF ;
 IF  'BINARY_GENERIC_EXPRESSION' IN  types THEN  op1 := expr \ binary_generic_expression.operands [ 1 ];
 expr \ binary_generic_expression.operands [ 1 ] := substitute(op1, vars, vals);
 op2 := expr \ binary_generic_expression.operands [ 2 ];
 expr \ binary_generic_expression.operands [ 2 ] := substitute(op2, vars, vals);
 END_IF ;
 IF  'PARALLEL_COMPOSED_FUNCTION' IN  types THEN  srcdom := expr \ parallel_composed_function.source_of_domain;
 prpfun := expr \ parallel_composed_function.prep_functions;
 finfun := expr \ parallel_composed_function.final_function;
 srcdom := substitute(srcdom, vars, vals);
 REPEAT  i := 1 TO  SIZEOF(prpfun);
 prpfun [ i ] := substitute(prpfun [ i ], vars, vals);
 END_REPEAT ;
 IF  'MATHS_FUNCTION' IN  stripped_typeof(finfun)THEN  finfun := substitute(finfun, vars, vals);
 END_IF ;
 RETURN(make_parallel_composed_function(srcdom, prpfun, finfun));
 END_IF ;
 IF 'MULTIPLE_ARITY_GENERIC_EXPRESSION' IN types THEN opnds := expr \ multiple_arity_generic_expression.operands;
 REPEAT i := 1 TO SIZEOF(opnds);
 expr \ multiple_arity_generic_expression.operands [ i ] := substitute(opnds [ i ], vars, vals);
 END_REPEAT;
 END_IF;
 RETURN(expr);
 END_FUNCTION; -- substitute

FUNCTION values_space_of
	(expr : generic_expression) : maths_space;
 LOCAL
 e_prefix : STRING  := 'ISO13584_EXPRESSIONS_SCHEMA.';
 typenames : SET OF STRING := TYPEOF(expr);
 END_LOCAL
;
 IF(schema_prefix + 'MATHS_VARIABLE')IN  typenames THEN  RETURN(expr \ maths_variable.values_space);
 END_IF ;
 IF(e_prefix + 'EXPRESSION')IN  typenames THEN  IF(e_prefix + 'NUMERIC_EXPRESSION')IN  typenames THEN  IF  expr \ numeric_expression.is_int THEN  IF(e_prefix + 'INT_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ int_literal.the_value ]));
 ELSE  RETURN(the_integers);
 END_IF ;
 ELSE  IF(e_prefix + 'REAL_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ real_literal.the_value ]));
 ELSE  RETURN(the_reals);
 END_IF ;
 END_IF ;
 END_IF ;
 IF(e_prefix + 'BOOLEAN_EXPRESSION')IN  typenames THEN  IF(e_prefix + 'BOOLEAN_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ boolean_literal.the_value ]));
 ELSE  RETURN(the_booleans);
 END_IF ;
 END_IF ;
 IF(e_prefix + 'STRING_EXPRESSION')IN  typenames THEN  IF(e_prefix + 'STRING_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ string_literal.the_value ]));
 ELSE  RETURN(the_strings);
 END_IF ;
 END_IF ;
 RETURN(?);
 END_IF ;
 IF(schema_prefix + 'MATHS_FUNCTION')IN  typenames THEN  IF  expression_is_constant(expr)THEN  RETURN(make_finite_space([ expr ]));
 ELSE  RETURN(make_function_space(sc_equal, expr \ maths_function.domain, sc_equal, expr \ maths_function.range));
 END_IF ;
 END_IF ;
 IF(schema_prefix + 'FUNCTION_APPLICATION')IN  typenames THEN  RETURN(expr \ function_application.func.range);
 END_IF ;
 IF(schema_prefix + 'MATHS_SPACE')IN  typenames THEN  IF  expression_is_constant(expr)THEN  RETURN(make_finite_space([ expr ]));
 ELSE RETURN(make_elementary_space(es_maths_spaces));
 END_IF ;
 END_IF ;
 IF(schema_prefix + 'DEPENDENT_VARIABLE_DEFINITION')IN  typenames THEN  RETURN(values_space_of(expr \ unary_generic_expression.operand));
 END_IF ;
 IF(schema_prefix + 'COMPLEX_NUMBER_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr ]));
 END_IF ;
 IF(schema_prefix + 'LOGICAL_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ logical_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'BINARY_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ binary_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'MATHS_ENUM_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ maths_enum_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'REAL_TUPLE_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ real_tuple_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'INTEGER_TUPLE_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ integer_tuple_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'ATOM_BASED_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ atom_based_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'MATHS_TUPLE_LITERAL')IN  typenames THEN  RETURN(make_finite_space([ expr \ maths_tuple_literal.lit_value ]));
 END_IF ;
 IF(schema_prefix + 'PARTIAL_DERIVATIVE_EXPRESSION')IN  typenames THEN  RETURN(drop_numeric_constraints(values_space_of(expr \ partial_derivative_expression.derivand)));
 END_IF ;
 IF(schema_prefix + 'DEFINITE_INTEGRAL_EXPRESSION')IN typenames THEN RETURN(drop_numeric_constraints(values_space_of(expr \ definite_integral_expression.integrand)));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- values_space_of

FUNCTION derive_dimensional_exponents
	(x : unit) : dimensional_exponents;
 LOCAL
 result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
 END_LOCAL
;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.DERIVED_UNIT' IN TYPEOF(x)THEN REPEAT i := LOINDEX(x.elements)TO HIINDEX(x.elements);
 result.length_exponent := result.length_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.length_exponent);
 result.mass_exponent := result.mass_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.mass_exponent);
 result.time_exponent := result.time_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.time_exponent);
 result.electric_current_exponent := result.electric_current_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.electric_current_exponent);
 result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.thermodynamic_temperature_exponent);
 result.amount_of_substance_exponent := result.amount_of_substance_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.amount_of_substance_exponent);
 result.luminous_intensity_exponent := result.luminous_intensity_exponent +(x.elements [ i ].exponent * x.elements [ i ].unit.dimensions.luminous_intensity_exponent);
 END_REPEAT;
 ELSE result := x.dimensions;
 END_IF;
 RETURN(result);
 END_FUNCTION; -- derive_dimensional_exponents

FUNCTION dimensions_for_si_unit
	(n : si_unit_name) : dimensional_exponents;
 CASE n OF metre : RETURN(dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 gram : RETURN(dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 second : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
 ampere : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
 kelvin : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
 mole : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
 candela : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
 radian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 steradian : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
 hertz : RETURN(dimensional_exponents(0.0, 0.0, - 1.0, 0.0, 0.0, 0.0, 0.0));
 newton : RETURN(dimensional_exponents(1.0, 1.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 pascal : RETURN(dimensional_exponents(- 1.0, 1.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 joule : RETURN(dimensional_exponents(2.0, 1.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 watt : RETURN(dimensional_exponents(2.0, 1.0, - 3.0, 0.0, 0.0, 0.0, 0.0));
 coulomb : RETURN(dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
 volt : RETURN(dimensional_exponents(2.0, 1.0, - 3.0, - 1.0, 0.0, 0.0, 0.0));
 farad : RETURN(dimensional_exponents(- 2.0, - 1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
 ohm : RETURN(dimensional_exponents(2.0, 1.0, - 3.0, - 2.0, 0.0, 0.0, 0.0));
 siemens : RETURN(dimensional_exponents(- 2.0, - 1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
 weber : RETURN(dimensional_exponents(2.0, 1.0, - 2.0, - 1.0, 0.0, 0.0, 0.0));
 tesla : RETURN(dimensional_exponents(0.0, 1.0, - 2.0, - 1.0, 0.0, 0.0, 0.0));
 henry : RETURN(dimensional_exponents(2.0, 1.0, - 2.0, - 2.0, 0.0, 0.0, 0.0));
 degree_Celsius : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
 lumen : RETURN(dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
 lux : RETURN(dimensional_exponents(- 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
 becquerel : RETURN(dimensional_exponents(0.0, 0.0, - 1.0, 0.0, 0.0, 0.0, 0.0));
 gray : RETURN(dimensional_exponents(2.0, 0.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 sievert : RETURN(dimensional_exponents(2.0, 0.0, - 2.0, 0.0, 0.0, 0.0, 0.0));
 OTHERWISE : RETURN(?);
 END_CASE;
 END_FUNCTION; -- dimensions_for_si_unit

FUNCTION valid_units
	(m : measure_with_unit) : BOOLEAN;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LENGTH_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MASS_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.TIME_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PLANE_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SOLID_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.AREA_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VOLUME_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.RATIO_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POSITIVE_LENGTH_MEASURE' IN  TYPEOF(m.value_component)THEN  IF  derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN  RETURN(FALSE );
 END_IF ;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN TYPEOF(m.value_component)THEN  IF derive_dimensional_exponents(m.unit_component)<> dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN RETURN(FALSE);
 END_IF ;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- valid_units

FUNCTION consistent_bus_structural_definition
	(input_rel : SET [1:?] OF product_definition_relationship) : BOOLEAN;
 LOCAL
 input : SET  OF  product_definition := [ ];
 vertex : SET OF product_definition := [ ];
 edge : INTEGER  := SIZEOF(input);
 vc : INTEGER  := 0;
 vertex_degree : INTEGER := 0;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(input_rel)BY  1;
 input := input + input_rel [ i ].related_product_definition;
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(input)BY  1;
 vertex := vertex + input [ i ] \ product_definition_relationship.relating_product_definition;
 vertex := vertex + input [ i ] \ product_definition_relationship.related_product_definition;
 END_REPEAT ;
 vc := SIZEOF(vertex);
 IF(vc <>(edge + 1))THEN  RETURN(FALSE );
 END_IF ;
 REPEAT  i := 1 TO  vc BY  1;
 vertex_degree := 0;
 REPEAT j := 1 TO SIZEOF(input)BY 1;
 IF  input [ j ] \ product_definition_relationship.relating_product_definition = vertex [ i ] THEN  vertex_degree := vertex_degree + 1;
 END_IF ;
 IF  input [ j ] \ product_definition_relationship.related_product_definition = vertex [ i ] THEN  vertex_degree := vertex_degree + 1;
 END_IF ;
 END_REPEAT ;
 IF(vertex_degree > 2)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- consistent_bus_structural_definition

FUNCTION valid_selected_instance_representation
	(pd : product_definition_or_assembly_relationship) : LOGICAL;
 LOCAL
 properties : SET  OF  property_definition := [ ];
 property_definition_representations : SET OF property_definition_representation := [ ];
 selected_representation : representation;
 END_LOCAL
;
 properties := QUERY(prd <* USEDIN(pd, 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION.DEFINITION')|(prd.name = 'occurrence selection'));
 IF(SIZEOF(properties)<> 1)THEN  RETURN(FALSE );
 END_IF ;
 property_definition_representations := QUERY(pdr <* USEDIN(properties [ 1 ], 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(pdr.used_representation.name = 'selection criteria'));
 IF(SIZEOF(property_definition_representations)<> 1)THEN  RETURN(FALSE );
 END_IF ;
 selected_representation := property_definition_representations [ 1 ].used_representation;
 IF(SIZEOF(selected_representation.items)< 1)OR(SIZEOF(selected_representation.items)> 2)THEN  RETURN(FALSE );
 END_IF ;
 IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |(SIZEOF([ 'PRODUCT_OCCURRENCE_MIM.MEASURE_REPRESENTATION_ITEM', 'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE' ] * TYPEOF(i))= 1)AND(i.name = 'selection quantity')))<> 1)THEN  RETURN(FALSE );
 END_IF ;
 IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |('PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(i))AND(i.name = 'selection control')))> 1)THEN  RETURN(FALSE );
 END_IF ;
 IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |('PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i))AND(i.name = 'selection control')))= 0)AND(SIZEOF(QUERY(i <* selected_representation.used_representation.items |(i.name = 'selection quantity')AND(SIZEOF([ 'PRODUCT_OCCURRENCE_MIM.QUALIFIED_REPRESENTATION_ITEM', 'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE' ] * TYPEOF(i))= 0)))> 0)THEN RETURN(FALSE);
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- valid_selected_instance_representation

FUNCTION acyclic_organization_relationship
	(relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF organization_relationship;
 END_LOCAL
;
 IF  relation.relating_organization IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION'))| specific_relation IN TYPEOF(org));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_organization_relationship(x [ i ], relatives + relation.relating_organization, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_organization_relationship

FUNCTION acyclic_organization_type_relationship
	(relation : organization_type_relationship; relatives : SET [0:?] OF organization_type; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF organization_type_relationship;
 END_LOCAL
;
 IF  relation.relating_organization_type IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE'))| specific_relation IN TYPEOF(orgtyp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_organization_type_relationship(x [ i ], relatives + relation.relating_organization_type, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_organization_type_relationship

FUNCTION acyclic_organizational_project_relationship
	(relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF organizational_project_relationship;
 END_LOCAL
;
 IF  relation.relating_organizational_project IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT'))| specific_relation IN TYPEOF(op));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_organizational_project_relationship(x [ i ], relatives + relation.relating_organizational_project, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_organizational_project_relationship

FUNCTION acyclic_person_type_definition_relationship
	(relation : person_type_definition_relationship; relatives : SET [0:?] OF person_type_definition; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF person_type_definition_relationship;
 END_LOCAL
;
 IF  relation.relating_person_type_definition IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION'))| specific_relation IN TYPEOF(ptdef));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_person_type_definition_relationship(x [ i ], relatives + relation.relating_person_type_definition, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_person_type_definition_relationship

FUNCTION acyclic_position_in_organization_relationship
	(relation : position_in_organization_relationship; relatives : SET [0:?] OF position_in_organization; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF position_in_organization_relationship;
 END_LOCAL
;
 IF  relation.relating_position_in_organization IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION'))| specific_relation IN TYPEOF(piorg));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_position_in_organization_relationship(x [ i ], relatives + relation.relating_position_in_organization, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_position_in_organization_relationship

FUNCTION component_definition_located_by_component_location
	(cl : component_2d_location) : component_definition;
 LOCAL
 pdr : BAG OF property_definition_representation := USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION');
 END_LOCAL
;
 REPEAT i := 1 TO HIINDEX(pdr)BY 1;
 IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdr [ i ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdr [ i ].definition.definition \ product_definition_relationship.related_product_definition)))THEN RETURN(pdr [ i ].definition.definition \ product_definition_relationship.related_product_definition);
 END_IF;
 END_REPEAT;
 RETURN(?);
 END_FUNCTION; -- component_definition_located_by_component_location

FUNCTION cto2d_determinant_test
	(cto2d : cartesian_transformation_operator_2d; expected_value : REAL; delta : REAL) : BOOLEAN;
 LOCAL
 det : REAL  := 0.0;
 DRs : LIST [ 4 : 4 ] OF REAL := [ ];
 END_LOCAL
;
 DRs [ 1 ] := cto2d.u [ 1 ].direction_ratios [ 1 ];
 DRs [ 2 ] := cto2d.u [ 1 ].direction_ratios [ 2 ];
 DRs [ 3 ] := cto2d.u [ 2 ].direction_ratios [ 1 ];
 DRs [ 4 ] := cto2d.u [ 2 ].direction_ratios [ 2 ];
 det :=(DRs [ 1 ] * DRs [ 4 ])-(DRs [ 2 ] * DRs [ 3 ]);
 IF(ABS(expected_value - det)< ABS(delta))THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- cto2d_determinant_test

FUNCTION is_bottom_footprint_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pds : SET  OF  property_definition := BAG_TO_SET(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'));
 fo : SET  OF  shape_aspect := [ ];
 sar : SET  OF  shape_aspect_relationship := [ ];
 dri : SET  OF  descriptive_representation_item := [ ];
 pdr : SET OF property_definition_representation := [ ];
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pds)BY  1;
 fo := fo + BAG_TO_SET(QUERY(sa <*(USEDIN(pds [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE'))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FOOTPRINT_OCCURRENCE' IN  TYPEOF(sa)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fo)BY  1;
 sar := sar + BAG_TO_SET(QUERY(sar <*(USEDIN(fo [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FOOTPRINT_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('usage definition' = sar \ shape_aspect_relationship.name)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 pdr := pdr + BAG_TO_SET(QUERY(pdr <*(USEDIN(sar [ i ].relating_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'product definition context description')));
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pdr)BY 1;
 dri := dri +(QUERY(dri <* pdr [ i ].used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'text')AND(dri.description = 'bottom')));
 END_REPEAT;
 IF(SIZEOF(dri)= 1)THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_bottom_footprint_occurrence

FUNCTION is_bottom_footprint_occurrence_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_bottom_footprint_occurrence(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_bottom_footprint_occurrence_location

FUNCTION is_bottom_padstack_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pds : SET  OF  property_definition := BAG_TO_SET(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'));
 fo : SET  OF  shape_aspect := [ ];
 sar : SET  OF  shape_aspect_relationship := [ ];
 dri : SET  OF  descriptive_representation_item := [ ];
 pdr : SET OF property_definition_representation := [ ];
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pds)BY  1;
 fo := fo + BAG_TO_SET(QUERY(sa <*(USEDIN(pds [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE'))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PADSTACK_OCCURRENCE' IN  TYPEOF(sa)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fo)BY  1;
 sar := sar + BAG_TO_SET(QUERY(sar <*(USEDIN(fo [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PADSTACK_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('usage definition' = sar \ shape_aspect_relationship.name)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 pdr := pdr + BAG_TO_SET(QUERY(pdr <*(USEDIN(sar [ i ].relating_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'product definition context description')));
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pdr)BY 1;
 dri := dri +(QUERY(dri <* pdr [ i ].used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'text')AND(dri.description = 'bottom')));
 END_REPEAT;
 IF(SIZEOF(dri)= 1)THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_bottom_padstack_occurrence

FUNCTION is_bottom_padstack_occurrence_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_bottom_padstack_occurrence(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_bottom_padstack_occurrence_location

FUNCTION is_interconnect_module_component_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_interconnect_module_occurrence(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_interconnect_module_component_location

FUNCTION is_laminate_component_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_laminate_component(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_laminate_component_location

FUNCTION is_symmetrical_footprint_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pds : SET  OF  property_definition := BAG_TO_SET(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'));
 fo : SET  OF  shape_aspect := [ ];
 sar : SET  OF  shape_aspect_relationship := [ ];
 dri : SET  OF  descriptive_representation_item := [ ];
 pdr : SET OF property_definition_representation := [ ];
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pds)BY  1;
 fo := fo + BAG_TO_SET(QUERY(sa <*(USEDIN(pds [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE'))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FOOTPRINT_OCCURRENCE' IN  TYPEOF(sa)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fo)BY  1;
 sar := sar + BAG_TO_SET(QUERY(sar <*(USEDIN(fo [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FOOTPRINT_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('usage definition' = sar \ shape_aspect_relationship.name)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 pdr := pdr + BAG_TO_SET(QUERY(pdr <*(USEDIN(sar [ i ].relating_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'product definition context description')));
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pdr)BY 1;
 dri := dri +(QUERY(dri <* pdr [ i ].used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'text')AND(dri.description = 'symmetrical')));
 END_REPEAT;
 IF(SIZEOF(dri)= 1)THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_symmetrical_footprint_occurrence

FUNCTION is_symmetrical_footprint_occurrence_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_symmetrical_footprint_occurrence(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_symmetrical_footprint_occurrence_location

FUNCTION is_symmetrical_padstack_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pds : SET  OF  property_definition := BAG_TO_SET(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'));
 fo : SET  OF  shape_aspect := [ ];
 sar : SET  OF  shape_aspect_relationship := [ ];
 dri : SET  OF  descriptive_representation_item := [ ];
 pdr : SET OF property_definition_representation := [ ];
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pds)BY  1;
 fo := fo + BAG_TO_SET(QUERY(sa <*(USEDIN(pds [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE'))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PADSTACK_OCCURRENCE' IN  TYPEOF(sa)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fo)BY  1;
 sar := sar + BAG_TO_SET(QUERY(sar <*(USEDIN(fo [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PADSTACK_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('usage definition' = sar \ shape_aspect_relationship.name)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 pdr := pdr + BAG_TO_SET(QUERY(pdr <*(USEDIN(sar [ i ].relating_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'product definition context description')));
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pdr)BY 1;
 dri := dri +(QUERY(dri <* pdr [ i ].used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'text')AND(dri.description = 'symmetrical')));
 END_REPEAT;
 IF(SIZEOF(dri)= 1)THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_symmetrical_padstack_occurrence

FUNCTION is_symmetrical_padstack_occurrence_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_symmetrical_padstack_occurrence(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_symmetrical_padstack_occurrence_location

FUNCTION is_top_footprint_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pds : SET  OF  property_definition := BAG_TO_SET(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'));
 fo : SET  OF  shape_aspect := [ ];
 sar : SET  OF  shape_aspect_relationship := [ ];
 dri : SET  OF  descriptive_representation_item := [ ];
 pdr : SET OF property_definition_representation := [ ];
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pds)BY  1;
 fo := fo + BAG_TO_SET(QUERY(sa <*(USEDIN(pds [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE'))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FOOTPRINT_OCCURRENCE' IN  TYPEOF(sa)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fo)BY  1;
 sar := sar + BAG_TO_SET(QUERY(sar <*(USEDIN(fo [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'FOOTPRINT_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('usage definition' = sar \ shape_aspect_relationship.name)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 pdr := pdr + BAG_TO_SET(QUERY(pdr <*(USEDIN(sar [ i ].relating_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'product definition context description')));
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pdr)BY 1;
 dri := dri +(QUERY(dri <* pdr [ i ].used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'text')AND(dri.description = 'top')));
 END_REPEAT;
 IF(SIZEOF(dri)= 1)THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_top_footprint_occurrence

FUNCTION is_top_footprint_occurrence_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_top_footprint_occurrence(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_top_footprint_occurrence_location

FUNCTION is_top_padstack_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pds : SET  OF  property_definition := BAG_TO_SET(USEDIN(pd, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION.DEFINITION'));
 fo : SET  OF  shape_aspect := [ ];
 sar : SET  OF  shape_aspect_relationship := [ ];
 dri : SET  OF  descriptive_representation_item := [ ];
 pdr : SET OF property_definition_representation := [ ];
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 REPEAT  i := 1 TO  SIZEOF(pds)BY  1;
 fo := fo + BAG_TO_SET(QUERY(sa <*(USEDIN(pds [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT.OF_SHAPE'))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PADSTACK_OCCURRENCE' IN  TYPEOF(sa)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(fo)BY  1;
 sar := sar + BAG_TO_SET(QUERY(sar <*(USEDIN(fo [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PADSTACK_DEFINITION' IN  TYPEOF(sar.relating_shape_aspect.of_shape.definition))AND('usage definition' = sar \ shape_aspect_relationship.name)));
 END_REPEAT ;
 REPEAT  i := 1 TO  SIZEOF(sar)BY  1;
 pdr := pdr + BAG_TO_SET(QUERY(pdr <*(USEDIN(sar [ i ].relating_shape_aspect.of_shape.definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'REPRESENTATION' IN  TYPEOF(pdr.used_representation))AND(pdr.used_representation \ representation.name = 'product definition context description')));
 END_REPEAT ;
 REPEAT i := 1 TO SIZEOF(pdr)BY 1;
 dri := dri +(QUERY(dri <* pdr [ i ].used_representation.items |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(dri))AND(dri \ representation_item.name = 'text')AND(dri.description = 'top')));
 END_REPEAT;
 IF(SIZEOF(dri)= 1)THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_top_padstack_occurrence

FUNCTION is_top_padstack_occurrence_location
	(cl : component_2d_location) : BOOLEAN;
 LOCAL
 pdrs : SET OF property_definition_representation := BAG_TO_SET(USEDIN(cl, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'));
 END_LOCAL
;
 IF  SIZEOF(pdrs)= 1 THEN  IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NEXT_ASSEMBLY_USAGE_OCCURRENCE' IN  TYPEOF(pdrs [ 1 ].definition.definition))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF(pdrs [ 1 ].definition.definition.related_product_definition))AND is_top_padstack_occurrence(pdrs [ 1 ].definition.definition.related_product_definition))THEN RETURN(TRUE);
 ELSE  RETURN(FALSE );
 END_IF ;
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_top_padstack_occurrence_location

FUNCTION is_assembly_module_macro_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'macro occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_macro_occurrence

FUNCTION is_assembly_module_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'physical occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_occurrence

FUNCTION is_interconnect_module_macro_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'macro occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_macro_occurrence

FUNCTION is_interconnect_module_occurrence
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'physical occurrence'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_occurrence

FUNCTION is_assembly_module_design
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_design

FUNCTION is_assembly_module_usage
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'assembly module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design usage'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_assembly_module_usage

FUNCTION is_ee_product_definition
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF(NOT(is_laminate_component(pd))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_DEFINITION' IN  TYPEOF(pd)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'STRATUM' IN  TYPEOF(pd)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION_PLACEMENT_LINK' IN  TYPEOF(pd)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'BUS_STRUCTURAL_DEFINITION' IN  TYPEOF(pd)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'COMPONENT_FUNCTIONAL_UNIT' IN  TYPEOF(pd)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'LINEAR_ARRAY_COMPONENT_DEFINITION_LINK' IN  TYPEOF(pd)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'NETWORK_NODE_DEFINITION' IN  TYPEOF(pd)))AND(NOT('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_PART_TEMPLATE_MATERIAL' IN TYPEOF(pd))))THEN RETURN(TRUE);
 ELSE RETURN(FALSE);
 END_IF;
 END_FUNCTION; -- is_ee_product_definition

FUNCTION is_interconnect_module_design
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_design

FUNCTION is_interconnect_module_usage
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE ;
 END_LOCAL
;
 IF  NOT(EXISTS(pd \ product_definition.name))THEN  RETURN(FALSE);
 END_IF ;
 IF((pd \ product_definition.name = 'interconnect module')AND(pd.frame_of_reference \ application_context_element.name = 'physical design usage'))THEN RETURN(TRUE);
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_interconnect_module_usage

FUNCTION is_laminate_component
	(pd : product_definition) : BOOLEAN;
 LOCAL
 pass : BOOLEAN := FALSE;
 END_LOCAL
;
 IF(pd \ product_definition.description = 'laminate component')THEN  RETURN(TRUE );
 ELSE IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRINTED_COMPONENT' IN TYPEOF(pd))THEN RETURN(TRUE);
 END_IF ;
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- is_laminate_component

FUNCTION acyclic_occlusion_precedence
	(relation : occlusion_precedence; set_of_lower : SET [0:?] OF hiding_or_blanking_select) : BOOLEAN;
 LOCAL
 x : SET  OF  occlusion_precedence;
 local_set_of_lower : SET OF hiding_or_blanking_select;
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(set_of_lower);
 IF  relation.higher_precedence :=: set_of_lower [ i ] THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 x := bag_to_set(USEDIN(relation.higher_precedence, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'OCCLUSION_PRECEDENCE.LOWER_PRECEDENCE'));
 local_set_of_lower := set_of_lower + relation.higher_precedence;
 IF  SIZEOF(x)> 0 THEN  REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_occlusion_precedence(x [ i ], local_set_of_lower)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_occlusion_precedence

FUNCTION acyclic_composite_text
	(start_composite : composite_text; child_text : SET [1:?] OF text_or_character) : LOGICAL;
 LOCAL
 i : INTEGER;
 local_composite_text : SET  [ 0 : ? ] OF  composite_text;
 local_annotation_text : SET  [ 0 : ? ] OF  annotation_text;
 local_children : SET [ 0 : ? ] OF text_or_character;
 END_LOCAL
;
 local_composite_text := QUERY(child <* child_text |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_TEXT' IN  TYPEOF(child)));
 IF(SIZEOF(local_composite_text)> 0)THEN  REPEAT  i := 1 TO  HIINDEX(local_composite_text);
 IF(start_composite :=: local_composite_text [ i ])THEN  RETURN(FALSE);
 END_IF ;
 END_REPEAT ;
 END_IF ;
 local_children := child_text;
 IF(SIZEOF(local_composite_text))> 0 THEN  REPEAT  i := 1 TO  HIINDEX(local_composite_text);
 local_children := local_children + local_composite_text [ i ].collected_text;
 END_REPEAT ;
 END_IF ;
 local_annotation_text := QUERY(child <* child_text |('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT' IN TYPEOF(child)));
 IF(SIZEOF(local_annotation_text)> 0)THEN  REPEAT i := 1 TO HIINDEX(local_annotation_text);
 local_children := local_children + QUERY(item <* local_annotation_text [ i ] \ mapped_item.mapping_source.mapped_representation.items | SIZEOF([ 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ANNOTATION_TEXT', 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.COMPOSITE_TEXT' ] * TYPEOF(item))> 0);
 END_REPEAT;
 END_IF ;
 IF(local_children :<>: child_text)THEN RETURN(acyclic_composite_text(start_composite, local_children));
 ELSE RETURN(TRUE);
 END_IF;
 END_FUNCTION; -- acyclic_composite_text

FUNCTION acyclic_symbol_representation_relationship
	(relation : symbol_representation_relationship; children : SET [0:?] OF symbol_representation) : BOOLEAN;
 LOCAL
 x : SET  OF  symbol_representation_relationship;
 local_children : SET OF symbol_representation;
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(children);
 IF  relation \ representation_relationship.rep_1 :=: children [ i ] THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 x := bag_to_set(USEDIN(relation \ representation_relationship.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2'));
 local_children := children + relation \ representation_relationship.rep_1;
 IF  SIZEOF(x)> 0 THEN  REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_symbol_representation_relationship(x [ i ], local_children)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_symbol_representation_relationship

FUNCTION field_in_table
	(field : table_record_field_representation; table : annotation_table_occurrence) : BOOLEAN;
 LOCAL
 table_rep : table_representation;
 symbol_rep_rel_set : SET  OF  symbol_representation_relationship;
 mapped_item_set : SET  OF  mapped_item;
 table_record_rep_set : SET OF table_record_representation := [ ];
 END_LOCAL
;
 table_rep := table \ styled_item.item \ mapped_item.mapping_source.mapped_representation;
 mapped_item_set := QUERY(item <* table_rep.items |('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN  TYPEOF(item))AND('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'TABLE_RECORD_REPRESENTATION' IN  TYPEOF(item \ mapped_item.mapping_source.mapped_representation)));
 REPEAT  i := 1 TO  HIINDEX(mapped_item_set);
 table_record_rep_set := table_record_rep_set + mapped_item_set [ i ].mapping_source.mapped_representation;
 END_REPEAT ;
 symbol_rep_rel_set := bag_to_set(USEDIN(table_rep, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1'));
 REPEAT i := 1 TO HIINDEX(symbol_rep_rel_set);
 table_record_rep_set := table_record_rep_set + symbol_rep_rel_set [ i ] \ representation_relationship.rep_2;
 END_REPEAT;
 IF SIZEOF(QUERY(table_record_rep <* table_record_rep_set |(SIZEOF(QUERY(rep_rel <* USEDIN(table_record_rep, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SYMBOL_REPRESENTATION_RELATIONSHIP' IN  TYPEOF(rep_rel))AND(rep_rel.rep_2 :=: field)))> 0)OR(SIZEOF(QUERY(item <* table_record_rep.items |('REPRESENTATION_SCHEMA.MAPPED_ITEM' IN TYPEOF(item))AND(field :=: item \ mapped_item.mapping_source.mapped_representation)))> 0)))= 0 THEN RETURN(FALSE);
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- field_in_table

FUNCTION acyclic_presentation_representation_relationship
	(relation : presentation_representation_relationship; children : SET [0:?] OF presentation_representation) : BOOLEAN;
 LOCAL
 x : SET  OF  presentation_representation_relationship;
 local_children : SET OF presentation_representation;
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(children);
 IF  relation \ representation_relationship.rep_1 :=: children [ i ] THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 x := bag_to_set(USEDIN(relation \ representation_relationship.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2'));
 local_children := children + relation \ representation_relationship.rep_1;
 IF  SIZEOF(x)> 0 THEN  REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_presentation_representation_relationship(x [ i ], local_children)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_presentation_representation_relationship

FUNCTION aspect_ratio
	(p : planar_box) : positive_ratio_measure;
 IF(p.size_in_x > 0.)AND(p.size_in_y > 0.)THEN RETURN(p.size_in_x / p.size_in_y);
 ELSE RETURN(?);
 END_IF;
 END_FUNCTION; -- aspect_ratio

FUNCTION printed_part_template_access_mechanisms
	(input : SET [0:?] OF printed_part_template_link) : SET [0:?] OF printed_part_template_terminal;
 LOCAL
 pptt : SET OF printed_part_template_terminal := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(input)BY 1;
 pptt := input [ i ].precedent_printed_part_template.raw_access_mechanisms + pptt;
 pptt := input [ i ].subsequent_printed_part_template.raw_access_mechanisms + pptt;
 END_REPEAT;
 RETURN(pptt);
 END_FUNCTION; -- printed_part_template_access_mechanisms

FUNCTION acyclic_product_category_relationship
	(relation : product_category_relationship; children : SET [0:?] OF product_category) : BOOLEAN;
 LOCAL
 x : SET  OF  product_category_relationship;
 local_children : SET OF product_category;
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(children);
 IF  relation.category :=: children [ i ] THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 x := bag_to_set(USEDIN(relation.category, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
 local_children := children + relation.category;
 IF  SIZEOF(x)> 0 THEN  REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_category_relationship(x [ i ], local_children)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_category_relationship

FUNCTION acyclic_product_definition_formation_relationship
	(relation : product_definition_formation_relationship; relatives : SET [1:?] OF product_definition_formation; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF product_definition_formation_relationship;
 END_LOCAL
;
 IF  relation.relating_product_definition_formation IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION'))| specific_relation IN TYPEOF(pdf));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_definition_formation_relationship(x [ i ], relatives + relation.relating_product_definition_formation, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_definition_formation_relationship

FUNCTION acyclic_product_definition_relationship
	(relation : product_definition_relationship; relatives : SET [1:?] OF product_definition; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF product_definition_relationship;
 END_LOCAL
;
 IF  relation.relating_product_definition IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))| specific_relation IN TYPEOF(pd));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_definition_relationship(x [ i ], relatives + relation.relating_product_definition, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_definition_relationship

FUNCTION acyclic_product_relationship
	(relation : product_relationship; relatives : SET [1:?] OF product; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF product_relationship;
 END_LOCAL
;
 IF  relation.relating_product IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT'))| specific_relation IN TYPEOF(prod));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_product_relationship(x [ i ], relatives + relation.relating_product, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_product_relationship

FUNCTION get_product_definitions
	(c_def_instance : product) : SET [0:?] OF product_definition;
 LOCAL
 pd_set : SET  OF  product_definition_formation := [ ];
 pdr_set : SET OF product_definition := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(USEDIN(c_def_instance, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set + bag_to_set(USEDIN(pd_set [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT_DEFINITION.FORMATION'));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_product_definitions

FUNCTION acyclic_characterized_object_relationship
	(relation : characterized_object_relationship; relatives : SET [1:?] OF characterized_object; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF characterized_object_relationship;
 END_LOCAL
;
 IF  relation.relating_object IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT'))| specific_relation IN TYPEOF(ca));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_characterized_object_relationship(x [ i ], relatives + relation.relating_object, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_characterized_object_relationship

FUNCTION acyclic_general_property_relationship
	(relation : general_property_relationship; relatives : SET [1:?] OF general_property; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF general_property_relationship;
 END_LOCAL
;
 IF  relation.relating_property IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY'))| specific_relation IN TYPEOF(genp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_general_property_relationship(x [ i ], relatives + relation.relating_property, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_general_property_relationship

FUNCTION acyclic_shape_aspect_relationship
	(relation : shape_aspect_relationship; relatives : SET [1:?] OF shape_aspect; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF shape_aspect_relationship;
 END_LOCAL
;
 IF  relation.relating_shape_aspect IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT'))| specific_relation IN TYPEOF(sa));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_shape_aspect_relationship(x [ i ], relatives + relation.relating_shape_aspect, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_shape_aspect_relationship

FUNCTION get_shape_aspects
	(c_def_instance : characterized_definition) : SET [0:?] OF shape_aspect;
 LOCAL
 pd_set : SET  OF  product_definition_shape := [ ];
 pdr_set : SET OF shape_aspect := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PROPERTY_DEFINITION.DEFINITION')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set + bag_to_set(USEDIN(pd_set [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_shape_aspects

FUNCTION get_property_definition_representations
	(c_def_instance : characterized_definition) : SET [0:?] OF property_definition_representation;
 LOCAL
 pd_set : SET  OF  property_definition := [ ];
 pdr_set : SET OF property_definition_representation := [ ];
 END_LOCAL
;
 pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
 IF(SIZEOF(pd_set)< 1)THEN RETURN(pdr_set);
 END_IF;
 REPEAT i := 1 TO HIINDEX(pd_set);
 pdr_set := pdr_set + bag_to_set(USEDIN(pd_set [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
 END_REPEAT;
 RETURN(pdr_set);
 END_FUNCTION; -- get_property_definition_representations

FUNCTION relatives_of_product_definitions
	(definition_set : SET [0:?] OF product_definition; relation_subtype : STRING) : SET [0:?] OF product_definition;
 FUNCTION local_relatives_of_product_definitions(definition_set : SET  OF  product_definition;
 total_definitions : SET  OF  product_definition;
 relation_subtype : STRING): SET  OF  product_definition;
 LOCAL
 local_def : SET  OF  product_definition := [ ];
 local_pdr : SET  OF  product_definition_relationship := [ ];
 local_total : SET OF product_definition := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(definition_set);
 local_pdr := local_pdr + bag_to_set(USEDIN(definition_set [ i ], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
 END_REPEAT ;
 REPEAT i := 1 TO HIINDEX(local_pdr);
 local_def := local_def + local_pdr [ i ].related_product_definition;
 END_REPEAT;
 IF(SIZEOF(local_def)- SIZEOF(total_definitions))= 0 THEN RETURN(local_def);
 ELSE local_total := total_definitions + local_def;
 RETURN(local_def +(local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
 END_IF;
 END_FUNCTION;
 RETURN(local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));
 END_FUNCTION; -- relatives_of_product_definitions

FUNCTION relatives_of_shape_representations
	(shape_representation_set : SET [0:?] OF shape_representation) : SET [0:?] OF shape_representation;
 FUNCTION local_relatives_of_shape_representations(shape_representation_set : SET  OF  shape_representation;
 total_reps : SET  OF  shape_representation): SET  OF  shape_representation;
 LOCAL
 local_shape_rep : SET  OF  shape_representation := [ ];
 local_srr : SET  OF  shape_representation_relationship := [ ];
 local_total : SET OF shape_representation := [ ];
 END_LOCAL
;
 REPEAT  i := 1 TO  HIINDEX(shape_representation_set);
 local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set [ i ], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1'))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP' IN  TYPEOF(rr));
 END_REPEAT ;
 REPEAT i := 1 TO HIINDEX(local_srr);
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr [ i ])THEN  local_shape_rep := local_shape_rep + local_srr [ i ].rep_2;
 END_IF ;
 END_REPEAT;
 IF SIZEOF(local_shape_rep - total_reps)= 0 THEN RETURN(shape_representation_set);
 ELSE local_total := total_reps + local_shape_rep;
 RETURN(local_shape_rep +(local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
 END_IF;
 END_FUNCTION;
 RETURN(local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));
 END_FUNCTION; -- relatives_of_shape_representations

FUNCTION acyclic_qualification_relationship
	(relation : qualification_relationship; relatives : SET [0:?] OF qualification; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF qualification_relationship;
 END_LOCAL
;
 IF  relation.relating_qualification IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION'))| specific_relation IN TYPEOF(qual));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_qualification_relationship(x [ i ], relatives + relation.relating_qualification, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_qualification_relationship

FUNCTION acyclic_qualification_type_relationship
	(relation : qualification_type_relationship; relatives : SET [0:?] OF qualification_type; specific_relation : STRING) : BOOLEAN;
 LOCAL
 x : SET OF qualification_type_relationship;
 END_LOCAL
;
 IF  relation.relating_qualification_type IN  relatives THEN  RETURN(FALSE );
 END_IF ;
 x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE'))| specific_relation IN TYPEOF(qultyp));
 REPEAT i := 1 TO HIINDEX(x);
 IF NOT acyclic_qualification_type_relationship(x [ i ], relatives + relation.relating_qualification_type, specific_relation)THEN RETURN(FALSE);
 END_IF;
 END_REPEAT;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_qualification_type_relationship

FUNCTION acyclic_mapped_representation
	(parent_set : SET [0:?] OF representation; children_set : SET [0:?] OF representation_item) : BOOLEAN;
 LOCAL
 x, y : SET OF representation_item;
 END_LOCAL
;
 x := QUERY(z <* children_set | 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.MAPPED_ITEM' IN  TYPEOF(z));
 IF  SIZEOF(x)> 0 THEN  REPEAT  i := 1 TO  HIINDEX(x);
 IF  x [ i ] \ mapped_item.mapping_source.mapped_representation IN  parent_set THEN  RETURN(FALSE );
 END_IF ;
 IF  NOT  acyclic_mapped_representation(parent_set + x [ i ] \ mapped_item.mapping_source.mapped_representation, x [ i ] \ mapped_item.mapping_source.mapped_representation.items)THEN  RETURN(FALSE );
 END_IF ;
 END_REPEAT ;
 END_IF ;
 x := children_set - x;
 IF  SIZEOF(x)> 0 THEN  REPEAT i := 1 TO HIINDEX(x);
 y := QUERY(z <* bag_to_set(USEDIN(x [ i ], ''))| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
 IF NOT acyclic_mapped_representation(parent_set, y)THEN RETURN(FALSE);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(TRUE);
 END_FUNCTION; -- acyclic_mapped_representation

FUNCTION item_in_context
	(item : representation_item; cntxt : representation_context) : BOOLEAN;
 LOCAL
 y : BAG OF representation_item;
 END_LOCAL
;
 IF  SIZEOF(USEDIN(item, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REPRESENTATION.ITEMS')* cntxt.representations_in_context)> 0 THEN  RETURN(TRUE );
 ELSE y := QUERY(z <* USEDIN(item, '')| 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));
 IF  SIZEOF(y)> 0 THEN  REPEAT i := 1 TO HIINDEX(y);
 IF item_in_context(y [ i ], cntxt)THEN RETURN(TRUE);
 END_IF ;
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(FALSE);
 END_FUNCTION; -- item_in_context

FUNCTION using_items
	(item : founded_item_select; checked_items : SET [0:?] OF founded_item_select) : SET [0:?] OF founded_item_select;
 LOCAL
 new_check_items : SET  OF  founded_item_select;
 result_items : SET  OF  founded_item_select;
 next_items : SET OF founded_item_select;
 END_LOCAL
;
 result_items := [ ];
 new_check_items := checked_items + item;
 next_items := QUERY(z <* bag_to_set(USEDIN(item, ''))|('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REPRESENTATION_ITEM' IN  TYPEOF(z))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FOUNDED_ITEM' IN  TYPEOF(z)));
 IF  SIZEOF(next_items)> 0 THEN  REPEAT i := 1 TO HIINDEX(next_items);
 IF NOT(next_items [ i ] IN new_check_items)THEN result_items := result_items + next_items [ i ] + using_items(next_items [ i ], new_check_items);
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(result_items);
 END_FUNCTION; -- using_items

FUNCTION using_representations
	(item : founded_item_select) : SET [0:?] OF representation;
 LOCAL
 results : SET  OF  representation;
 result_bag : BAG OF  representation;
 intermediate_items : SET OF founded_item_select;
 END_LOCAL
;
 results := [ ];
 result_bag := USEDIN(item, 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REPRESENTATION.ITEMS');
 IF  SIZEOF(result_bag)> 0 THEN  REPEAT  i := 1 TO  HIINDEX(result_bag);
 results := results + result_bag [ i ];
 END_REPEAT ;
 END_IF ;
 intermediate_items := using_items(item, [ ]);
 IF  SIZEOF(intermediate_items)> 0 THEN  REPEAT  i := 1 TO  HIINDEX(intermediate_items);
 result_bag := USEDIN(intermediate_items [ i ], 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.REPRESENTATION.ITEMS');
 IF SIZEOF(result_bag)> 0 THEN REPEAT j := 1 TO HIINDEX(result_bag);
 results := results + result_bag [ j ];
 END_REPEAT ;
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(results);
 END_FUNCTION; -- using_representations

FUNCTION valid_measure_value
	(m : measure_value) : BOOLEAN;
 IF('REAL' IN  TYPEOF(m))THEN  RETURN(m > 0.0);
 ELSE  IF('INTEGER' IN TYPEOF(m))THEN RETURN(m > 0);
 ELSE RETURN(TRUE);
 END_IF ;
 END_IF;
 END_FUNCTION; -- valid_measure_value

FUNCTION instance_unique
	(the_bag : BAG [0:?] OF GENERIC) : BOOLEAN;
 LOCAL
 the_set : SET OF GENERIC : intype := [ ];
 i : INTEGER;
 pass : BOOLEAN := TRUE;
 END_LOCAL
;
 IF  SIZEOF(the_bag)> 0 THEN  the_set := bag_to_set(the_bag);
 END_IF ;
 IF NOT(SIZEOF(the_set)= SIZEOF(the_bag))THEN pass := FALSE;
 END_IF;
 RETURN(pass);
 END_FUNCTION; -- instance_unique

FUNCTION categories_of_product
	(obj : product) : SET [0:?] OF STRING;
 LOCAL
 category_assignments : BAG OF  product_category;
 categories : SET OF STRING := [ ];
 i : INTEGER;
 END_LOCAL
;
 category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
 REPEAT i := LOINDEX(category_assignments)TO HIINDEX(category_assignments)BY 1;
 categories := categories + category_assignments [ i ].name;
 END_REPEAT;
 RETURN(categories);
 END_FUNCTION; -- categories_of_product

FUNCTION bag_to_set
	(the_bag : BAG [0:?] OF GENERIC) : SET [0:?] OF GENERIC;
 LOCAL
 the_set : SET OF GENERIC : intype := [ ];
 END_LOCAL
;
 IF SIZEOF(the_bag)> 0 THEN REPEAT i := 1 TO HIINDEX(the_bag);
 the_set := the_set + the_bag [ i ];
 END_REPEAT;
 END_IF;
 RETURN(the_set);
 END_FUNCTION; -- bag_to_set

FUNCTION type_check_function
	(the_type : GENERIC; sub_names : SET [0:?] OF STRING; criterion : INTEGER) : LOGICAL;
 IF((NOT  EXISTS(the_type))OR(NOT({ 0 <= criterion <= 3 }))OR(SIZEOF(sub_names)= 0))THEN RETURN(UNKNOWN);
 ELSE CASE criterion OF 0 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))> 0);
 1 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))= 0);
 2 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))= 1);
 3 : RETURN(SIZEOF(sub_names * TYPEOF(the_type))<= 1);
 END_CASE;
 END_IF;
 END_FUNCTION; -- type_check_function

FUNCTION boolean_choose
	(b : BOOLEAN; choice1 : GENERIC:item; choice2 : GENERIC:item) : GENERIC:item;
 IF b THEN RETURN(choice1);
 ELSE RETURN(choice2);
 END_IF;
 END_FUNCTION; -- boolean_choose

FUNCTION closed_shell_reversed
	(a_shell : closed_shell) : oriented_closed_shell;
 LOCAL
 the_reverse : oriented_closed_shell;
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell))THEN the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| closed_shell()|| oriented_closed_shell(a_shell \ oriented_closed_shell.closed_shell_element, NOT(a_shell \ oriented_closed_shell.orientation));
 ELSE the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| closed_shell()|| oriented_closed_shell(a_shell, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- closed_shell_reversed

FUNCTION conditional_reverse
	(p : BOOLEAN; an_item : reversible_topology) : reversible_topology;
 IF p THEN RETURN(an_item);
 ELSE RETURN(topology_reversed(an_item));
 END_IF;
 END_FUNCTION; -- conditional_reverse

FUNCTION edge_curve_pcurves
	(an_edge : edge_curve; the_surface_curves : SET [0:?] OF surface_curve) : SET [0:?] OF pcurve;
 LOCAL
 a_curve : curve;
 result : SET OF  pcurve;
 the_geometry : LIST [ 1 : 2 ] OF pcurve_or_surface;
 END_LOCAL
;
 a_curve := an_edge.edge_geometry;
 result := [ ];
 IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF(a_curve)THEN  result := result + a_curve;
 ELSE  IF  'GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(a_curve)THEN  the_geometry := a_curve \ surface_curve.associated_geometry;
 REPEAT  k := 1 TO  SIZEOF(the_geometry);
 IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF(the_geometry [ k ])THEN  result := result + the_geometry [ k ];
 END_IF ;
 END_REPEAT ;
 ELSE REPEAT  j := 1 TO  SIZEOF(the_surface_curves);
 the_geometry := the_surface_curves [ j ].associated_geometry;
 IF  the_surface_curves [ j ].curve_3d :=: a_curve THEN  REPEAT k := 1 TO SIZEOF(the_geometry);
 IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(the_geometry [ k ])THEN result := result + the_geometry [ k ];
 END_IF ;
 END_REPEAT ;
 END_IF ;
 END_REPEAT;
 END_IF ;
 END_IF;
 RETURN(RESULT);
 END_FUNCTION; -- edge_curve_pcurves

FUNCTION edge_reversed
	(an_edge : edge) : oriented_edge;
 LOCAL
 the_reverse : oriented_edge;
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_EDGE' IN TYPEOF(an_edge))THEN the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start)|| oriented_edge(an_edge \ oriented_edge.edge_element, NOT(an_edge \ oriented_edge.orientation));
 ELSE the_reverse := dummy_tri || edge(an_edge.edge_end, an_edge.edge_start)|| oriented_edge(an_edge, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- edge_reversed

FUNCTION face_bound_reversed
	(a_face_bound : face_bound) : face_bound;
 LOCAL
 the_reverse : face_bound;
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound))THEN the_reverse := dummy_tri || face_bound(a_face_bound \ face_bound.bound, NOT(a_face_bound \ face_bound.orientation))|| face_outer_bound();
 ELSE the_reverse := dummy_tri || face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- face_bound_reversed

FUNCTION face_reversed
	(a_face : face) : oriented_face;
 LOCAL
 the_reverse : oriented_face;
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_FACE' IN TYPEOF(a_face))THEN the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds))|| oriented_face(a_face \ oriented_face.face_element, NOT(a_face \ oriented_face.orientation));
 ELSE the_reverse := dummy_tri || face(set_of_topology_reversed(a_face.bounds))|| oriented_face(a_face, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- face_reversed

FUNCTION list_face_loops
	(f : face) : LIST [0:?] OF loop;
 LOCAL
 loops : LIST [ 0 : ? ] OF loop := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(f.bounds);
 loops := loops +(f.bounds [ i ].bound);
 END_REPEAT;
 RETURN(loops);
 END_FUNCTION; -- list_face_loops

FUNCTION list_loop_edges
	(l : loop) : LIST [0:?] OF edge;
 LOCAL
 edges : LIST [ 0 : ? ] OF edge := [ ];
 END_LOCAL
;
 IF 'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE_LOOP' IN TYPEOF(l)THEN REPEAT i := 1 TO SIZEOF(l \ path.edge_list);
 edges := edges +(l \ path.edge_list [ i ].edge_element);
 END_REPEAT;
 END_IF;
 RETURN(edges);
 END_FUNCTION; -- list_loop_edges

FUNCTION list_of_topology_reversed
	(a_list : list_of_reversible_topology_item) : list_of_reversible_topology_item;
 LOCAL
 the_reverse : list_of_reversible_topology_item;
 END_LOCAL
;
 the_reverse := [ ];
 REPEAT i := 1 TO SIZEOF(a_list);
 the_reverse := topology_reversed(a_list [ i ])+ the_reverse;
 END_REPEAT;
 RETURN(the_reverse);
 END_FUNCTION; -- list_of_topology_reversed

FUNCTION list_shell_edges
	(s : shell) : LIST [0:?] OF edge;
 LOCAL
 edges : LIST [ 0 : ? ] OF edge := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
 edges := edges + list_loop_edges(list_shell_loops(s)[ i ]);
 END_REPEAT;
 RETURN(edges);
 END_FUNCTION; -- list_shell_edges

FUNCTION list_shell_faces
	(s : shell) : LIST [0:?] OF face;
 LOCAL
 faces : LIST [ 0 : ? ] OF face := [ ];
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CLOSED_SHELL' IN  TYPEOF(s))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OPEN_SHELL' IN TYPEOF(s))THEN REPEAT i := 1 TO SIZEOF(s \ connected_face_set.cfs_faces);
 faces := faces + s \ connected_face_set.cfs_faces [ i ];
 END_REPEAT;
 END_IF;
 RETURN(faces);
 END_FUNCTION; -- list_shell_faces

FUNCTION list_shell_loops
	(s : shell) : LIST [0:?] OF loop;
 LOCAL
 loops : LIST [ 0 : ? ] OF loop := [ ];
 END_LOCAL
;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.VERTEX_SHELL' IN  TYPEOF(s)THEN  loops := loops + s.vertex_shell_extent;
 END_IF ;
 IF  'AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.WIRE_SHELL' IN  TYPEOF(s)THEN  REPEAT  i := 1 TO  SIZEOF(s.wire_shell_extent);
 loops := loops + s.wire_shell_extent [ i ];
 END_REPEAT ;
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OPEN_SHELL' IN  TYPEOF(s))OR('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CLOSED_SHELL' IN TYPEOF(s))THEN REPEAT i := 1 TO SIZEOF(s.cfs_faces);
 loops := loops + list_face_loops(s.cfs_faces [ i ]);
 END_REPEAT;
 END_IF;
 RETURN(loops);
 END_FUNCTION; -- list_shell_loops

FUNCTION list_to_set
	(l : LIST [0:?] OF GENERIC) : SET [0:?] OF GENERIC;
 LOCAL
 s : SET OF GENERIC : T := [ ];
 END_LOCAL
;
 REPEAT i := 1 TO SIZEOF(l);
 s := s + l [ i ];
 END_REPEAT;
 RETURN(s);
 END_FUNCTION; -- list_to_set

FUNCTION mixed_loop_type_set
	(l : SET [0:?] OF loop) : LOGICAL;
 LOCAL
 poly_loop_type : LOGICAL;
 END_LOCAL
;
 IF(SIZEOF(l)<= 1)THEN  RETURN(FALSE );
 END_IF ;
 poly_loop_type :=('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLY_LOOP' IN  TYPEOF(l [ 1 ]));
 REPEAT i := 2 TO SIZEOF(l);
 IF(('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.POLY_LOOP' IN TYPEOF(l [ i ]))<> poly_loop_type)THEN RETURN(TRUE);
 END_IF;
 END_REPEAT;
 RETURN(FALSE);
 END_FUNCTION; -- mixed_loop_type_set

FUNCTION open_shell_reversed
	(a_shell : open_shell) : oriented_open_shell;
 LOCAL
 the_reverse : oriented_open_shell;
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell))THEN the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| open_shell()|| oriented_open_shell(a_shell \ oriented_open_shell.open_shell_element,(NOT(a_shell \ oriented_open_shell.orientation)));
 ELSE the_reverse := dummy_tri || connected_face_set(a_shell \ connected_face_set.cfs_faces)|| open_shell()|| oriented_open_shell(a_shell, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- open_shell_reversed

FUNCTION path_head_to_tail
	(a_path : path) : LOGICAL;
 LOCAL
 n : INTEGER;
 p : LOGICAL := TRUE;
 END_LOCAL
;
 n := SIZEOF(a_path.edge_list);
 REPEAT i := 2 TO n;
 p := p AND(a_path.edge_list [ i - 1 ].edge_end :=: a_path.edge_list [ i ].edge_start);
 END_REPEAT;
 RETURN(p);
 END_FUNCTION; -- path_head_to_tail

FUNCTION path_reversed
	(a_path : path) : oriented_path;
 LOCAL
 the_reverse : oriented_path;
 END_LOCAL
;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.ORIENTED_PATH' IN TYPEOF(a_path))THEN the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list))|| oriented_path(a_path \ oriented_path.path_element, NOT(a_path \ oriented_path.orientation));
 ELSE the_reverse := dummy_tri || path(list_of_topology_reversed(a_path.edge_list))|| oriented_path(a_path, FALSE);
 END_IF;
 RETURN(the_reverse);
 END_FUNCTION; -- path_reversed

FUNCTION set_of_topology_reversed
	(a_set : set_of_reversible_topology_item) : set_of_reversible_topology_item;
 LOCAL
 the_reverse : set_of_reversible_topology_item;
 END_LOCAL
;
 the_reverse := [ ];
 REPEAT i := 1 TO SIZEOF(a_set);
 the_reverse := the_reverse + topology_reversed(a_set [ i ]);
 END_REPEAT;
 RETURN(the_reverse);
 END_FUNCTION; -- set_of_topology_reversed

FUNCTION shell_reversed
	(a_shell : shell) : shell;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.OPEN_SHELL' IN  TYPEOF(a_shell))THEN  RETURN(open_shell_reversed(a_shell));
 ELSE  IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.CLOSED_SHELL' IN TYPEOF(a_shell))THEN RETURN(closed_shell_reversed(a_shell));
 ELSE RETURN(?);
 END_IF ;
 END_IF;
 END_FUNCTION; -- shell_reversed

FUNCTION topology_reversed
	(an_item : reversible_topology) : reversible_topology;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.EDGE' IN  TYPEOF(an_item))THEN  RETURN(edge_reversed(an_item));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.PATH' IN  TYPEOF(an_item))THEN  RETURN(path_reversed(an_item));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FACE_BOUND' IN  TYPEOF(an_item))THEN  RETURN(face_bound_reversed(an_item));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.FACE' IN  TYPEOF(an_item))THEN  RETURN(face_reversed(an_item));
 END_IF ;
 IF('AP210_ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN_MIM_LF.SHELL' IN  TYPEOF(an_item))THEN  RETURN(shell_reversed(an_item));
 END_IF ;
 IF('SET' IN  TYPEOF(an_item))THEN  RETURN(set_of_topology_reversed(an_item));
 END_IF ;
 IF('LIST' IN TYPEOF(an_item))THEN RETURN(list_of_topology_reversed(an_item));
 END_IF;
 RETURN(?);
 END_FUNCTION; -- topology_reversed

FUNCTION vertex_point_pcurves
	(a_vertex : vertex_point; the_degenerates : SET [0:?] OF evaluated_degenerate_pcurve) : SET [0:?] OF degenerate_pcurve;
 LOCAL
 a_point : point;
 result : SET OF degenerate_pcurve;
 END_LOCAL
;
 a_point := a_vertex.vertex_geometry;
 result := [ ];
 IF  'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point)THEN  result := result + a_point;
 ELSE REPEAT j := 1 TO SIZEOF(the_degenerates);
 IF(the_degenerates [ j ].equivalent_point :=: a_point)THEN result := result + the_degenerates [ j ];
 END_IF ;
 END_REPEAT;
 END_IF;
 RETURN(RESULT);
 END_FUNCTION; -- vertex_point_pcurves

PROCEDURE angle_minmax
	(ab : REAL; a : REAL; a_in : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN; VAR amax_in : BOOLEAN);

END_PROCEDURE; -- angle_minmax

PROCEDURE angle_range
	(VAR amin : REAL; VAR amax : REAL);

END_PROCEDURE; -- angle_range

PROCEDURE find_aminmax
	(ab : REAL; a0 : REAL; a1 : REAL; a2 : REAL; a3 : REAL; in0 : BOOLEAN; in1 : BOOLEAN; in2 : BOOLEAN; in3 : BOOLEAN; VAR amin : REAL; VAR amax : REAL; VAR amin_in : BOOLEAN; VAR amax_in : BOOLEAN);

END_PROCEDURE; -- find_aminmax

PROCEDURE nearest_good_direction
	(acart : REAL; aitv : finite_real_interval; VAR a : REAL; VAR a_in : BOOLEAN);

END_PROCEDURE; -- nearest_good_direction

PROCEDURE parts
	(c : complex_number_literal; VAR x : REAL; VAR y : REAL);

END_PROCEDURE; -- parts

PROCEDURE range_max
	(r : REAL; incl : BOOLEAN; VAR rmax : REAL; VAR rmax_in : BOOLEAN);

END_PROCEDURE; -- range_max

PROCEDURE range_min
	(r : REAL; incl : BOOLEAN; VAR rmin : REAL; VAR rmin_in : BOOLEAN);

END_PROCEDURE; -- range_min

END_SCHEMA; --ap210_electronic_assembly_interconnect_and_packaging_design_mim_lf

