(*
 $Id: mim_lf.exp,v 1.16 2005/03/09 01:07:43 thendrix Exp $
 ISO TC184/SC4/WG3 N2013 - ISO/TS 10303-1616 AP210 functional specification - EXPRESS MIM Long form
 Supersedes ISO TC184/SC4/WG3 N1713
*)

SCHEMA ap210_functional_specification_mim_lf;

CONSTANT
	dummy_gri : geometric_representation_item := representation_item('')||
                                   geometric_representation_item();


	dummy_tri : topological_representation_item := representation_item('')||
                   topological_representation_item();



END_CONSTANT;

TYPE supported_item = SELECT (
	action,
	action_directive,
	action_method);
END_TYPE; -- supported_item

TYPE action_method_items = EXTENSIBLE SELECT ;
END_TYPE; -- action_method_items

TYPE action_items = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- action_items

TYPE aliasable_item = EXTENSIBLE SELECT ;
END_TYPE; -- aliasable_item

TYPE am_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	analytical_model_definition);
END_TYPE; -- am_document_reference_item

TYPE am_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH (
	digital_analytical_model_vector_port);
END_TYPE; -- am_external_identification_item

TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- approval_item

TYPE date_and_time_item_approval = SELECT BASED_ON date_and_time_item WITH (
	approval_person_organization);
END_TYPE; -- date_and_time_item_approval

TYPE date_item_approval = SELECT BASED_ON date_item WITH (
	approval_person_organization);
END_TYPE; -- date_item_approval

TYPE attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- attribute_classification_item

TYPE description_attribute_select = SELECT (
	action_request_solution,
	application_context,
	approval_role,
	configuration_design,
	context_dependent_shape_representation,
	date_role,
	date_time_role,
	effectivity,
	external_source,
	organization_role,
	person_and_organization,
	person_and_organization_role,
	person_role,
	property_definition_representation,
	representation,
	time_role);
END_TYPE; -- description_attribute_select

TYPE id_attribute_select = SELECT (
	action,
	address,
	application_context,
	group,
	organizational_project,
	product_category,
	property_definition,
	representation,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- id_attribute_select

TYPE name_attribute_select = SELECT (
	action_request_solution,
	address,
	configuration_design,
	context_dependent_shape_representation,
	derived_unit,
	effectivity,
	person_and_organization,
	product_definition,
	product_definition_substitute,
	property_definition_representation);
END_TYPE; -- name_attribute_select

TYPE role_select = SELECT (
	action_assignment,
	action_request_assignment,
	approval_assignment,
	approval_date_time,
	certification_assignment,
	contract_assignment,
	document_reference,
	effectivity_assignment,
	external_referent_assignment,
	group_assignment,
	name_assignment,
	security_classification_assignment);
END_TYPE; -- role_select

TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- certification_item

TYPE c_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	representation);
END_TYPE; -- c_document_reference_item

TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- classification_item

TYPE classification_select = EXTENSIBLE SELECT ;
END_TYPE; -- classification_select

TYPE complete_membership_select = EXTENSIBLE SELECT ;
END_TYPE; -- complete_membership_select

TYPE class_system_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	characterized_class);
END_TYPE; -- class_system_item

TYPE classification_classification_item = EXTENSIBLE SELECT BASED_ON classification_item WITH (
	class);
END_TYPE; -- classification_classification_item

TYPE classification_identification_item = EXTENSIBLE SELECT BASED_ON identification_item WITH (
	class);
END_TYPE; -- classification_identification_item

TYPE classification_item_extended = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	characterized_class,
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- classification_item_extended

TYPE classified_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- classified_item

TYPE cwa_identification_item = SELECT BASED_ON identification_item WITH (
	characterized_class);
END_TYPE; -- cwa_identification_item

TYPE cwa_versionable_item = SELECT BASED_ON versionable_item WITH (
	characterized_class);
END_TYPE; -- cwa_versionable_item

TYPE configuration_design_item = SELECT (
	product_definition,
	product_definition_formation);
END_TYPE; -- configuration_design_item

TYPE contract_item = EXTENSIBLE SELECT ;
END_TYPE; -- contract_item

TYPE date_and_time_item = EXTENSIBLE SELECT ;
END_TYPE; -- date_and_time_item

TYPE date_item = EXTENSIBLE SELECT ;
END_TYPE; -- date_item

TYPE ahead_or_behind = ENUMERATION OF (
	ahead,
	exact,
	behind );
END_TYPE; -- ahead_or_behind

TYPE date_time_or_event_occurrence = SELECT (
	date_time_select,
	event_occurrence);
END_TYPE; -- date_time_or_event_occurrence

TYPE date_time_select = SELECT (
	date,
	date_and_time,
	local_time);
END_TYPE; -- date_time_select

TYPE day_in_month_number = INTEGER;
WHERE
	WR1 : {1 <= SELF <= 31};
END_TYPE; -- day_in_month_number

TYPE day_in_week_number = INTEGER;
WHERE
	WR1 : { 1 <= SELF <= 7 };
END_TYPE; -- day_in_week_number

TYPE day_in_year_number = INTEGER;
WHERE
	WR1 : {1 <= SELF <= 366};
END_TYPE; -- day_in_year_number

TYPE hour_in_day = INTEGER;
WHERE
	WR1 : { 0 <= SELF < 24 };
END_TYPE; -- hour_in_day

TYPE minute_in_hour = INTEGER;
WHERE
	WR1 : { 0 <= SELF <= 59 };
END_TYPE; -- minute_in_hour

TYPE month_in_year_number = INTEGER;
WHERE
	WR1 : { 1 <= SELF <= 12 };
END_TYPE; -- month_in_year_number

TYPE second_in_minute = REAL;
WHERE
	WR1 : { 0 <= SELF <= 60.0 };
END_TYPE; -- second_in_minute

TYPE week_in_year_number = INTEGER;
WHERE
	WR1 : { 1 <= SELF <= 53 };
END_TYPE; -- week_in_year_number

TYPE year_number = INTEGER;
END_TYPE; -- year_number

TYPE design_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH (
	product,
	product_definition_formation);
END_TYPE; -- design_action_method_items

TYPE design_pdm_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_action_request_item WITH (
	versioned_action_request);
END_TYPE; -- design_pdm_action_request_item

TYPE design_pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_approval_item WITH (
	action_directive,
	certification,
	configuration_item,
	contract,
	date,
	directed_action,
	document,
	effectivity,
	executed_action,
	general_property_relationship,
	product,
	product_definition,
	product_definition_formation_relationship,
	product_definition_relationship,
	product_definition_formation,
	representation,
	requirement_assignment,
	security_classification,
	shape_aspect_relationship);
END_TYPE; -- design_pdm_approval_item

TYPE design_pdm_attribute_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_classification_item WITH (
	action_directive,
	action_method,
	action_property,
	action_property_representation,
	action_relationship,
	action_request_solution,
	action_request_status,
	alternate_product_relationship,
	applied_action_assignment,
	applied_action_request_assignment,
	applied_approval_assignment,
	applied_certification_assignment,
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_effectivity_assignment,
	applied_event_occurrence_assignment,
	applied_external_identification_assignment,
	applied_identification_assignment,
	applied_person_and_organization_assignment,
	applied_organization_assignment,
	applied_organizational_project_assignment,
	approval,
	approval_person_organization,
	approval_relationship,
	approval_status,
	certification,
	context_dependent_unit,
	contract,
	date_and_time_assignment,
	date_assignment,
	derived_unit,
	descriptive_representation_item,
	document_file,
	document_relationship,
	effectivity,
	event_occurrence_relationship,
	executed_action,
	general_property,
	general_property_relationship,
	language,
	measure_representation_item,
	measure_with_unit,
	named_unit,
	organizational_address,
	organizational_project_relationship,
	organization_relationship,
	person_and_organization,
	person_and_organization_address,
	product,
	product_category,
	product_concept,
	product_concept_context,
	product_definition,
	product_definition_context,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	property_definition_representation,
	product_definition_relationship,
	representation,
	representation_context,
	representation_item,
	security_classification,
	time_interval_relationship,
	uncertainty_measure_with_unit,
	versioned_action_request);
END_TYPE; -- design_pdm_attribute_classification_item

TYPE design_pdm_certification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_certification_item WITH (
	alternate_product_relationship,
	product_definition_formation,
	make_from_usage_option);
END_TYPE; -- design_pdm_certification_item

TYPE design_pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_classification_item WITH (
	material_designation);
END_TYPE; -- design_pdm_classification_item

TYPE design_pdm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH (
	action_directive,
	alternate_product_relationship,
	directed_action,
	organization,
	person_and_organization,
	product,
	product_definition_formation);
END_TYPE; -- design_pdm_contract_item

TYPE design_pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_date_and_time_item WITH (
	action_directive,
	approval_person_organization,
	certification,
	contract,
	directed_action,
	document,
	product_definition,
	security_classification);
END_TYPE; -- design_pdm_date_and_time_item

TYPE design_pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_date_item WITH (
	action_directive,
	product_definition,
	directed_action,
	approval_person_organization,
	contract,
	document,
	executed_action,
	security_classification,
	certification);
END_TYPE; -- design_pdm_date_item

TYPE design_pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_document_reference_item WITH (
	applied_external_identification_assignment,
	assembly_component_usage,
	characterized_object,
	configuration_item,
	descriptive_representation_item,
	externally_defined_item,
	material_designation,
	measure_representation_item,
	product,
	product_category,
	product_definition,
	product_definition_formation,
	property_definition,
	representation,
	representation_item);
END_TYPE; -- design_pdm_document_reference_item

TYPE design_pdm_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	product_definition,
	product_definition_formation,
	property_definition_representation,
	representation,
	representation_item,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- design_pdm_groupable_item

TYPE design_pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_identification_item WITH (
	characterized_class,
	configuration_item,
	material_designation,
	person_and_organization,
	product,
	product_category,
	product_concept,
	product_definition_formation,
	organization);
END_TYPE; -- design_pdm_identification_item

TYPE design_pdm_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH (
	external_class_library,
	product,
	product_definition);
END_TYPE; -- design_pdm_name_item

TYPE design_pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_organization_item WITH (
	action_directive,
	applied_identification_assignment,
	certification,
	directed_action,
	document,
	product,
	product_definition,
	product_definition_formation,
	product_definition_formation_relationship,
	representation);
END_TYPE; -- design_pdm_organization_item

TYPE design_pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_person_and_organization_item WITH (
	action_directive,
	applied_identification_assignment,
	certification,
	document,
	product,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition,
	directed_action);
END_TYPE; -- design_pdm_person_and_organization_item

TYPE design_pdm_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH (
	descriptive_representation_item,
	configuration_item,
	product_definition,
	product_definition_formation,
	product,
	shape_aspect,
	representation);
END_TYPE; -- design_pdm_requirement_assigned_item

TYPE design_pdm_requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_source_item WITH (
	product_definition,
	product_definition_formation,
	product,
	shape_aspect,
	characterized_object,
	product_definition_relationship);
END_TYPE; -- design_pdm_requirement_source_item

TYPE design_pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON pdm_security_classification_item WITH (
	document,
	make_from_usage_option,
	product_definition_formation,
	product_definition);
END_TYPE; -- design_pdm_security_classification_item

TYPE promissory_usage_in_product_model_assigned_item = SELECT (
	product_concept,
	product_definition);
END_TYPE; -- promissory_usage_in_product_model_assigned_item

TYPE document_reference_item = EXTENSIBLE SELECT ;
END_TYPE; -- document_reference_item

TYPE document_location_select = SELECT BASED_ON external_identification_item WITH (
	product_definition);
END_TYPE; -- document_location_select

TYPE dm_aliasable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON aliasable_item WITH (
	document_file,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- dm_aliasable_item

TYPE dm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_approval_item WITH (
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- dm_approval_item

TYPE dm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_attribute_language_item WITH (
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_external_identification_assignment,
	document_relationship,
	document_usage_role,
	external_source,
	object_role,
	product,
	product_category,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- dm_attribute_language_item

TYPE dm_contract_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON contract_item WITH (
	product_definition_formation);
END_TYPE; -- dm_contract_item

TYPE dm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_and_time_item WITH (
	document_file,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- dm_date_and_time_item

TYPE dm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_date_item WITH (
	document_file,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- dm_date_item

TYPE dm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH (
	document_file,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- dm_identification_item

TYPE dm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_multi_language_attribute_item WITH (
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_external_identification_assignment,
	document_relationship,
	document_usage_role,
	external_source,
	object_role,
	product,
	product_category,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- dm_multi_language_attribute_item

TYPE dm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_organization_item WITH (
	document_file,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- dm_organization_item

TYPE dm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_person_and_organization_item WITH (
	document_file,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- dm_person_and_organization_item

TYPE dm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH (
	document_file,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- dm_security_classification_item

TYPE product_or_formation_or_definition = SELECT (
	product,
	product_definition_formation,
	product_definition);
END_TYPE; -- product_or_formation_or_definition

TYPE effectivity_item = EXTENSIBLE SELECT ;
END_TYPE; -- effectivity_item

TYPE representation_identification_item = SELECT BASED_ON identification_item WITH (
	shape_representation);
END_TYPE; -- representation_identification_item

TYPE representation_version_item = SELECT BASED_ON versionable_item WITH (
	shape_representation);
END_TYPE; -- representation_version_item

TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- event_occurrence_item

TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	event_occurrence);
END_TYPE; -- event_occurrence_date_and_time_item

TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	event_occurrence);
END_TYPE; -- event_occurrence_date_item

TYPE external_class_name_item = SELECT BASED_ON name_item WITH (
	external_class_library);
END_TYPE; -- external_class_name_item

TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- external_identification_item

TYPE message = STRING;
END_TYPE; -- message

TYPE source_item = SELECT (
	identifier,
	message);
END_TYPE; -- source_item

TYPE file_identification_item = SELECT BASED_ON identification_item WITH (
	document_file);
END_TYPE; -- file_identification_item

TYPE file_location_select = SELECT BASED_ON external_identification_item WITH (
	document_file);
END_TYPE; -- file_location_select

TYPE file_version_item = SELECT BASED_ON versionable_item WITH (
	document_file);
END_TYPE; -- file_version_item

TYPE fs_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	representation);
END_TYPE; -- fs_document_reference_item

TYPE fs_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH (
	functional_specification);
END_TYPE; -- fs_external_identification_item

TYPE nfuv_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	shape_aspect);
END_TYPE; -- nfuv_groupable_item

TYPE boolean_operand = SELECT (
	solid_model,
	half_space_solid,
	csg_primitive,
	boolean_result,
	half_space_2d);
END_TYPE; -- boolean_operand

TYPE boolean_operator = ENUMERATION OF (
	union,
	intersection,
	difference );
END_TYPE; -- boolean_operator

TYPE csg_primitive = SELECT (
	sphere,
	ellipsoid,
	block,
	right_angular_wedge,
	faceted_primitive,
	rectangular_pyramid,
	torus,
	right_circular_cone,
	eccentric_cone,
	right_circular_cylinder,
	cyclide_segment_solid,
	primitive_2d);
END_TYPE; -- csg_primitive

TYPE csg_select = SELECT (
	boolean_result,
	csg_primitive);
END_TYPE; -- csg_select

TYPE geometric_set_select = SELECT (
	point,
	curve,
	surface);
END_TYPE; -- geometric_set_select

TYPE surface_model = SELECT (
	shell_based_surface_model,
	face_based_surface_model);
END_TYPE; -- surface_model

TYPE wireframe_model = SELECT (
	shell_based_wireframe_model,
	edge_based_wireframe_model);
END_TYPE; -- wireframe_model

TYPE axis2_placement = SELECT (
	axis2_placement_2d,
	axis2_placement_3d);
END_TYPE; -- axis2_placement

TYPE b_spline_curve_form = ENUMERATION OF (
	polyline_form,
	circular_arc,
	elliptic_arc,
	parabolic_arc,
	hyperbolic_arc,
	unspecified );
END_TYPE; -- b_spline_curve_form

TYPE b_spline_surface_form = ENUMERATION OF (
	plane_surf,
	cylindrical_surf,
	conical_surf,
	spherical_surf,
	toroidal_surf,
	surf_of_revolution,
	ruled_surf,
	generalised_cone,
	quadric_surf,
	surf_of_linear_extrusion,
	unspecified );
END_TYPE; -- b_spline_surface_form

TYPE curve_on_surface = SELECT (
	pcurve,
	surface_curve,
	composite_curve_on_surface);
END_TYPE; -- curve_on_surface

TYPE dimension_count = INTEGER;
WHERE
	WR1 : SELF > 0;
END_TYPE; -- dimension_count

TYPE extent_enumeration = ENUMERATION OF (
	invalid,
	zero,
	finite_non_zero,
	infinite );
END_TYPE; -- extent_enumeration

TYPE knot_type = ENUMERATION OF (
	uniform_knots,
	quasi_uniform_knots,
	piecewise_bezier_knots,
	unspecified );
END_TYPE; -- knot_type

TYPE pcurve_or_surface = SELECT (
	pcurve,
	surface);
END_TYPE; -- pcurve_or_surface

TYPE preferred_surface_curve_representation = ENUMERATION OF (
	curve_3d,
	pcurve_s1,
	pcurve_s2 );
END_TYPE; -- preferred_surface_curve_representation

TYPE surface_boundary = SELECT (
	boundary_curve,
	degenerate_pcurve);
END_TYPE; -- surface_boundary

TYPE transition_code = ENUMERATION OF (
	discontinuous,
	continuous,
	cont_same_gradient,
	cont_same_gradient_same_curvature );
END_TYPE; -- transition_code

TYPE trimming_preference = ENUMERATION OF (
	cartesian,
	parameter,
	unspecified );
END_TYPE; -- trimming_preference

TYPE trimming_select = SELECT (
	cartesian_point,
	parameter_value);
END_TYPE; -- trimming_select

TYPE vector_or_direction = SELECT (
	vector,
	direction);
END_TYPE; -- vector_or_direction

TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE; -- groupable_item

TYPE identification_item = EXTENSIBLE SELECT ;
END_TYPE; -- identification_item

TYPE versionable_item = EXTENSIBLE SELECT ;
END_TYPE; -- versionable_item

TYPE idrm_marked_item = EXTENSIBLE SELECT BASED_ON classification_item WITH (
	product_definition,
	document_file);
END_TYPE; -- idrm_marked_item

TYPE mri_aliasable_item = EXTENSIBLE SELECT BASED_ON aliasable_item WITH (
	approval_status,
	contract,
	organization,
	security_classification_level);
END_TYPE; -- mri_aliasable_item

TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH (
	certification,
	contract);
END_TYPE; -- mri_approval_item

TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH (
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	identification_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization);
END_TYPE; -- mri_attribute_language_item

TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	certification,
	contract,
	security_classification);
END_TYPE; -- mri_date_and_time_item

TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	certification,
	contract,
	security_classification);
END_TYPE; -- mri_date_item

TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
	approval_status,
	contract,
	organization,
	security_classification_level);
END_TYPE; -- mri_identification_item

TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH (
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	identification_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization);
END_TYPE; -- mri_multi_language_attribute_item

TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH (
	applied_identification_assignment,
	applied_security_classification_assignment,
	contract);
END_TYPE; -- mri_organization_item

TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH (
	applied_identification_assignment,
	applied_security_classification_assignment,
	contract);
END_TYPE; -- mri_person_and_organization_item

TYPE attribute_type = SELECT (
	label,
	text);
END_TYPE; -- attribute_type

TYPE characterized_material_property = SELECT (
	material_property_representation,
	product_material_composition_relationship);
END_TYPE; -- characterized_material_property

TYPE amount_of_substance_measure = REAL;
END_TYPE; -- amount_of_substance_measure

TYPE area_measure = REAL;
END_TYPE; -- area_measure

TYPE celsius_temperature_measure = REAL;
END_TYPE; -- celsius_temperature_measure

TYPE context_dependent_measure = REAL;
END_TYPE; -- context_dependent_measure

TYPE count_measure = NUMBER;
END_TYPE; -- count_measure

TYPE descriptive_measure = STRING;
END_TYPE; -- descriptive_measure

TYPE electric_current_measure = REAL;
END_TYPE; -- electric_current_measure

TYPE length_measure = REAL;
END_TYPE; -- length_measure

TYPE luminous_intensity_measure = REAL;
END_TYPE; -- luminous_intensity_measure

TYPE mass_measure = REAL;
END_TYPE; -- mass_measure

TYPE measure_value = SELECT (
	amount_of_substance_measure,
	area_measure,
	celsius_temperature_measure,
	context_dependent_measure,
	count_measure,
	descriptive_measure,
	electric_current_measure,
	length_measure,
	luminous_intensity_measure,
	mass_measure,
	numeric_measure,
	parameter_value,
	plane_angle_measure,
	positive_length_measure,
	positive_plane_angle_measure,
	positive_ratio_measure,
	ratio_measure,
	solid_angle_measure,
	thermodynamic_temperature_measure,
	time_measure,
	volume_measure);
END_TYPE; -- measure_value

TYPE numeric_measure = NUMBER;
END_TYPE; -- numeric_measure

TYPE parameter_value = REAL;
END_TYPE; -- parameter_value

TYPE plane_angle_measure = REAL;
END_TYPE; -- plane_angle_measure

TYPE positive_length_measure = length_measure;
WHERE
	WR1 : SELF > 0.0;
END_TYPE; -- positive_length_measure

TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
	WR1 : SELF > 0.0;
END_TYPE; -- positive_plane_angle_measure

TYPE positive_ratio_measure = ratio_measure;
WHERE
	WR1 : SELF > 0.0;
END_TYPE; -- positive_ratio_measure

TYPE ratio_measure = REAL;
END_TYPE; -- ratio_measure

TYPE si_prefix = ENUMERATION OF (
	exa,
	peta,
	tera,
	giga,
	mega,
	kilo,
	hecto,
	deca,
	deci,
	centi,
	milli,
	micro,
	nano,
	pico,
	femto,
	atto );
END_TYPE; -- si_prefix

TYPE si_unit_name = ENUMERATION OF (
	metre,
	gram,
	second,
	ampere,
	kelvin,
	mole,
	candela,
	radian,
	steradian,
	hertz,
	newton,
	pascal,
	joule,
	watt,
	coulomb,
	volt,
	farad,
	ohm,
	siemens,
	weber,
	tesla,
	henry,
	degree_Celsius,
	lumen,
	lux,
	becquerel,
	gray,
	sievert );
END_TYPE; -- si_unit_name

TYPE solid_angle_measure = REAL;
END_TYPE; -- solid_angle_measure

TYPE thermodynamic_temperature_measure = REAL;
END_TYPE; -- thermodynamic_temperature_measure

TYPE time_measure = REAL;
END_TYPE; -- time_measure

TYPE unit = SELECT (
	derived_unit,
	named_unit);
END_TYPE; -- unit

TYPE volume_measure = REAL;
END_TYPE; -- volume_measure

TYPE model_parameter_assigned_item = SELECT (
	unit);
END_TYPE; -- model_parameter_assigned_item

TYPE mp_action_method_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_method_items WITH (
	test_method_based_parameter_assignment);
END_TYPE; -- mp_action_method_items

TYPE mp_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	model_parameter);
END_TYPE; -- mp_document_reference_item

TYPE mp_groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON groupable_item WITH (
	group_relationship);
END_TYPE; -- mp_groupable_item

TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT (
	multi_language_attribute_assignment,
	attribute_value_assignment);
END_TYPE; -- attribute_language_item

TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- multi_language_attribute_item

TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- name_item

TYPE nfdv_requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON requirement_assigned_item WITH (
	component_functional_unit);
END_TYPE; -- nfdv_requirement_assigned_item

TYPE product_definition_or_assembly_relationship = SELECT (
	assembly_component_usage,
	product_definition);
END_TYPE; -- product_definition_or_assembly_relationship

TYPE organization_item = EXTENSIBLE SELECT ;
END_TYPE; -- organization_item

TYPE person_and_organization_item = EXTENSIBLE SELECT ;
END_TYPE; -- person_and_organization_item

TYPE person_organization_select = SELECT (
	organization,
	person,
	person_and_organization);
END_TYPE; -- person_organization_select

TYPE plib_class_identification_item = SELECT BASED_ON external_identification_item WITH (
	externally_defined_class);
END_TYPE; -- plib_class_identification_item

TYPE plib_class_organization_item = SELECT BASED_ON organization_item WITH (
	class);
END_TYPE; -- plib_class_organization_item

TYPE pdpdms_external_identification_item = EXTENSIBLE SELECT BASED_ON external_identification_item WITH (
	action_relationship,
	action_request_status,
	applied_organization_assignment,
	applied_person_and_organization_assignment,
	approval,
	approval_status,
	date_assignment,
	date_and_time_assignment,
	organizational_address,
	security_classification,
	versioned_action_request);
END_TYPE; -- pdpdms_external_identification_item

TYPE pdpdms_person_and_organization_item = EXTENSIBLE SELECT BASED_ON person_and_organization_item WITH (
	person_and_organization);
END_TYPE; -- pdpdms_person_and_organization_item

TYPE characterized_action_definition = SELECT (
	action,
	action_method,
	action_method_relationship,
	action_relationship);
END_TYPE; -- characterized_action_definition

TYPE characterized_resource_definition = SELECT (
	action_resource,
	action_resource_relationship,
	action_resource_requirement,
	action_resource_requirement_relationship);
END_TYPE; -- characterized_resource_definition

TYPE property_or_shape_select = SELECT (
	property_definition,
	shape_definition);
END_TYPE; -- property_or_shape_select

TYPE category_usage_item = SELECT (
	product_class);
END_TYPE; -- category_usage_item

TYPE id_for_class = SELECT BASED_ON identification_item WITH (
	product_class,
	product_concept_feature);
END_TYPE; -- id_for_class

TYPE specification_for_category = SELECT BASED_ON groupable_item WITH (
	package_product_concept_feature,
	product_concept_feature);
END_TYPE; -- specification_for_category

TYPE version_for_class = SELECT BASED_ON versionable_item WITH (
	product_class,
	product_concept_feature);
END_TYPE; -- version_for_class

TYPE pdm_action_items = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_items WITH (
	configuration_effectivity,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- pdm_action_items

TYPE pdm_action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON action_request_item WITH (
	product_definition,
	product_definition_formation,
	product_definition_relationship,
	property_definition);
END_TYPE; -- pdm_action_request_item

TYPE pdm_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON approval_item WITH (
	action,
	applied_action_assignment,
	configuration_effectivity,
	versioned_action_request);
END_TYPE; -- pdm_approval_item

TYPE pdm_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON attribute_language_item WITH (
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_external_identification_assignment,
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	document_relationship,
	document_usage_role,
	external_source,
	identification_role,
	object_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization,
	product,
	product_category,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- pdm_attribute_language_item

TYPE pdm_certification_item = EXTENSIBLE SELECT BASED_ON certification_item WITH (
	product_definition_formation_relationship);
END_TYPE; -- pdm_certification_item

TYPE pdm_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON classification_item WITH (
	action,
	action_directive,
	action_method,
	action_property,
	action_relationship,
	action_request_solution,
	action_request_status,
	address,
	alternate_product_relationship,
	applied_action_assignment,
	applied_action_request_assignment,
	applied_approval_assignment,
	applied_certification_assignment,
	applied_contract_assignment,
	applied_date_and_time_assignment,
	applied_date_assignment,
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_effectivity_assignment,
	applied_event_occurrence_assignment,
	applied_external_identification_assignment,
	applied_identification_assignment,
	applied_organization_assignment,
	applied_organizational_project_assignment,
	applied_person_and_organization_assignment,
	applied_security_classification_assignment,
	approval,
	approval_person_organization,
	approval_relationship,
	approval_status,
	assembly_component_usage_substitute,
	calendar_date,
	certification,
	class,
	configuration_item,
	context_dependent_unit,
	contract,
	conversion_based_unit,
	date_and_time,
	date_and_time_assignment,
	date_assignment,
	derived_unit,
	descriptive_representation_item,
	directed_action,
	document_file,
	document_relationship,
	effectivity,
	event_occurrence,
	executed_action,
	general_property,
	general_property_relationship,
	group,
	identification_assignment,
	language,
	measure_representation_item,
	measure_with_unit,
	multi_language_attribute_assignment,
	named_unit,
	organization,
	organization_relationship,
	organizational_address,
	organizational_project,
	organizational_project_relationship,
	person,
	person_and_organization_address,
	product,
	product_category,
	product_concept,
	product_definition,
	product_definition_context,
	product_definition_formation,
	product_definition_formation_relationship,
	product_definition_relationship,
	property_definition,
	property_definition_representation,
	representation,
	representation_context,
	representation_item,
	security_classification,
	uncertainty_measure_with_unit,
	versioned_action_request);
END_TYPE; -- pdm_classification_item

TYPE pdm_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_and_time_item WITH (
	action,
	applied_action_assignment,
	executed_action,
	versioned_action_request);
END_TYPE; -- pdm_date_and_time_item

TYPE pdm_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON date_item WITH (
	action,
	applied_action_assignment,
	versioned_action_request);
END_TYPE; -- pdm_date_item

TYPE pdm_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	action_method,
	executed_action,
	product_definition_formation_relationship,
	shape_aspect,
	shape_aspect_relationship,
	versioned_action_request);
END_TYPE; -- pdm_document_reference_item

TYPE pdm_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON effectivity_item WITH (
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- pdm_effectivity_item

TYPE pdm_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH (
	organizational_project);
END_TYPE; -- pdm_event_occurrence_item

TYPE pdm_external_class_name_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON name_item WITH (
	assembly_component_usage,
	external_class_library);
END_TYPE; -- pdm_external_class_name_item

TYPE pdm_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON identification_item WITH (
	shape_aspect_relationship);
END_TYPE; -- pdm_identification_item

TYPE pdm_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON multi_language_attribute_item WITH (
	applied_document_reference,
	applied_document_usage_constraint_assignment,
	applied_external_identification_assignment,
	applied_organizational_project_assignment,
	approval,
	approval_relationship,
	approval_status,
	certification,
	certification_type,
	contract,
	date_role,
	date_time_role,
	document_relationship,
	document_usage_role,
	external_source,
	identification_role,
	object_role,
	organization_relationship,
	organizational_project,
	organizational_project_relationship,
	organizational_project_role,
	person_and_organization,
	product,
	product_category,
	product_definition,
	product_definition_formation,
	product_definition_relationship);
END_TYPE; -- pdm_multi_language_attribute_item

TYPE pdm_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON organization_item WITH (
	action,
	applied_action_assignment,
	approval,
	configuration_item,
	contract,
	executed_action,
	security_classification,
	versioned_action_request);
END_TYPE; -- pdm_organization_item

TYPE pdm_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON person_and_organization_item WITH (
	action,
	applied_action_assignment,
	approval,
	configuration_item,
	contract,
	executed_action,
	security_classification,
	versioned_action_request);
END_TYPE; -- pdm_person_and_organization_item

TYPE pdm_project_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON project_item WITH (
	executed_action,
	product_concept);
END_TYPE; -- pdm_project_item

TYPE pdm_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH (
	assembly_component_usage);
END_TYPE; -- pdm_security_classification_item

TYPE pdm_time_interval_item = EXTENSIBLE SELECT BASED_ON time_interval_item WITH (
	action);
END_TYPE; -- pdm_time_interval_item

TYPE source = ENUMERATION OF (
	made,
	bought,
	not_known );
END_TYPE; -- source

TYPE characterized_definition = SELECT (
	characterized_object,
	characterized_product_definition,
	shape_definition);
END_TYPE; -- characterized_definition

TYPE characterized_product_definition = SELECT (
	product_definition,
	product_definition_relationship);
END_TYPE; -- characterized_product_definition

TYPE derived_property_select = SELECT (
	action_property,
	property_definition,
	resource_property);
END_TYPE; -- derived_property_select

TYPE shape_definition = SELECT (
	product_definition_shape,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- shape_definition

TYPE represented_definition = SELECT (
	general_property,
	property_definition,
	property_definition_relationship,
	shape_aspect,
	shape_aspect_relationship);
END_TYPE; -- represented_definition

TYPE project_as_date_and_time_item = SELECT BASED_ON date_and_time_item WITH (
	organizational_project);
END_TYPE; -- project_as_date_and_time_item

TYPE project_as_date_item = SELECT BASED_ON date_item WITH (
	organizational_project);
END_TYPE; -- project_as_date_item

TYPE project_event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON event_occurrence_item WITH (
	organizational_project);
END_TYPE; -- project_event_occurrence_item

TYPE project_item = EXTENSIBLE SELECT ;
END_TYPE; -- project_item

TYPE puipc_security_classification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON security_classification_item WITH (
	promissory_usage_in_product_concept_relationship);
END_TYPE; -- puipc_security_classification_item

TYPE value_qualifier = SELECT (
	precision_qualifier,
	type_qualifier,
	uncertainty_qualifier);
END_TYPE; -- value_qualifier

TYPE compound_item_definition = SELECT (
	list_representation_item,
	set_representation_item);
END_TYPE; -- compound_item_definition

TYPE founded_item_select = SELECT (
	founded_item,
	representation_item);
END_TYPE; -- founded_item_select

TYPE list_representation_item = LIST [1:?] OF representation_item;
END_TYPE; -- list_representation_item

TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE; -- set_representation_item

TYPE transformation = SELECT (
	item_defined_transformation,
	functionally_defined_transformation);
END_TYPE; -- transformation

TYPE requirement_assigned_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- requirement_assigned_item

TYPE requirement_source_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- requirement_source_item

TYPE requirement_identification_and_version_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON mri_identification_item WITH (
	product,
	product_definition_formation);
END_TYPE; -- requirement_identification_and_version_mri_identification_item

TYPE security_classification_item = EXTENSIBLE SELECT ;
END_TYPE; -- security_classification_item

TYPE s_external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON external_identification_item WITH (
	composite_signal_property_relationship,
	property_definition,
	signal);
END_TYPE; -- s_external_identification_item

TYPE spr_document_reference_item = SELECT BASED_ON document_reference_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_document_reference_item

TYPE spr_organization_item = EXTENSIBLE SELECT BASED_ON organization_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_organization_item

TYPE spr_person_and_organization_item = EXTENSIBLE SELECT BASED_ON person_and_organization_item WITH (
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- spr_person_and_organization_item

TYPE document_identifier_assigned_item = SELECT (
	document);
END_TYPE; -- document_identifier_assigned_item

TYPE sd_document_reference_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON document_reference_item WITH (
	configuration_item,
	product,
	product_definition,
	product_definition_formation);
END_TYPE; -- sd_document_reference_item

TYPE id_for_product_identification = SELECT BASED_ON identification_item WITH (
	product_identification);
END_TYPE; -- id_for_product_identification

TYPE version_for_product_identification = SELECT BASED_ON versionable_item WITH (
	product_identification);
END_TYPE; -- version_for_product_identification

TYPE identifier = STRING;
END_TYPE; -- identifier

TYPE label = STRING;
END_TYPE; -- label

TYPE text = STRING;
END_TYPE; -- text

TYPE string_representation_item_select = SELECT (
	descriptive_representation_item,
	included_text_block,
	structured_text_composition);
END_TYPE; -- string_representation_item_select

TYPE time_interval_item = EXTENSIBLE SELECT ;
END_TYPE; -- time_interval_item

TYPE list_of_reversible_topology_item = LIST [0:?] OF reversible_topology_item;
END_TYPE; -- list_of_reversible_topology_item

TYPE reversible_topology = SELECT (
	reversible_topology_item,
	list_of_reversible_topology_item,
	set_of_reversible_topology_item);
END_TYPE; -- reversible_topology

TYPE reversible_topology_item = SELECT (
	edge,
	path,
	face,
	face_bound,
	closed_shell,
	open_shell);
END_TYPE; -- reversible_topology_item

TYPE set_of_reversible_topology_item = SET [0:?] OF reversible_topology_item;
END_TYPE; -- set_of_reversible_topology_item

TYPE shell = SELECT (
	vertex_shell,
	wire_shell,
	open_shell,
	closed_shell);
END_TYPE; -- shell

TYPE action_request_item = EXTENSIBLE GENERIC_ENTITY SELECT ;
END_TYPE; -- action_request_item

ENTITY action;
	name : label;
	description : OPTIONAL text;
	chosen_method : action_method;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- action


ENTITY action_directive;
	name : label;
	description : OPTIONAL text;
	analysis : text;
	comment : text;
	requests : SET [1:?] OF versioned_action_request;
END_ENTITY; -- action_directive


ENTITY action_method;
	name : label;
	description : OPTIONAL text;
	consequence : text;
	purpose : text;
END_ENTITY; -- action_method


ENTITY action_method_relationship;
	name : label;
	description : OPTIONAL text;
	relating_method : action_method;
	related_method : action_method;
END_ENTITY; -- action_method_relationship


ENTITY action_relationship;
	name : label;
	description : OPTIONAL text;
	relating_action : action;
	related_action : action;
END_ENTITY; -- action_relationship


ENTITY action_request_solution;
	method : action_method;
	request : versioned_action_request;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
END_ENTITY; -- action_request_solution


ENTITY action_request_status;
	status : label;
	assigned_request : versioned_action_request;
END_ENTITY; -- action_request_status


ENTITY action_resource;
	name : label;
	description : OPTIONAL text;
	usage : SET [1:?] OF supported_item;
	kind : action_resource_type;
END_ENTITY; -- action_resource


ENTITY action_resource_relationship;
	name : label;
	description : OPTIONAL text;
	relating_resource : action_resource;
	related_resource : action_resource;
END_ENTITY; -- action_resource_relationship


ENTITY action_resource_type;
	name : label;
END_ENTITY; -- action_resource_type


ENTITY action_status;
	status : label;
	assigned_action : executed_action;
END_ENTITY; -- action_status


ENTITY directed_action
	SUBTYPE OF (executed_action);
	directive : action_directive;
END_ENTITY; -- directed_action


ENTITY executed_action
	SUBTYPE OF (action);
END_ENTITY; -- executed_action


ENTITY versioned_action_request;
	id : identifier;
	version : label;
	purpose : text;
	description : OPTIONAL text;
END_ENTITY; -- versioned_action_request


ENTITY versioned_action_request_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_versioned_action_request : versioned_action_request;
	related_versioned_action_request : versioned_action_request;
END_ENTITY; -- versioned_action_request_relationship


ENTITY applied_action_method_assignment
	SUBTYPE OF (action_method_assignment);
	items : SET [1:?] OF action_method_items;
END_ENTITY; -- applied_action_method_assignment


ENTITY applied_action_assignment
	SUBTYPE OF (action_assignment);
	items : SET [1:?] OF action_items;
END_ENTITY; -- applied_action_assignment


ENTITY across_port_variable
	SUBTYPE OF (port_variable);
END_ENTITY; -- across_port_variable


ENTITY analog_analytical_model_port
	SUBTYPE OF (analytical_model_port);
END_ENTITY; -- analog_analytical_model_port


ENTITY analog_port_variable
	SUBTYPE OF (representation, representation_item);
END_ENTITY; -- analog_port_variable


ENTITY analytical_model
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
END_ENTITY; -- analytical_model


ENTITY analytical_model_definition
	SUBTYPE OF (product_definition);
END_ENTITY; -- analytical_model_definition


ENTITY analytical_model_make_from_relationship
	SUBTYPE OF (product_definition_relationship);
	SELF\product_definition_relationship.related_product_definition : analytical_model_definition;
	SELF\product_definition_relationship.relating_product_definition : analytical_model_definition;
UNIQUE
	UR1 : relating_product_definition, related_product_definition;
END_ENTITY; -- analytical_model_make_from_relationship


ENTITY analytical_model_parameter
	SUBTYPE OF (model_parameter);
END_ENTITY; -- analytical_model_parameter


ENTITY analytical_model_port
	SUPERTYPE OF ((analytical_model_vector_port ANDOR ONEOF (analog_analytical_model_port, digital_analytical_model_port)))
	SUBTYPE OF (representation);
END_ENTITY; -- analytical_model_port


ENTITY analytical_model_port_assignment
	SUBTYPE OF (property_definition_representation, representation_relationship);
END_ENTITY; -- analytical_model_port_assignment


ENTITY analytical_model_scalar_port
	SUBTYPE OF (analytical_model_vector_port);
END_ENTITY; -- analytical_model_scalar_port


ENTITY analytical_model_vector_port
	SUBTYPE OF (analytical_model_port, compound_representation_item);
END_ENTITY; -- analytical_model_vector_port


ENTITY analytical_representation
	SUBTYPE OF (representation);
UNIQUE
	UR1 : name;
END_ENTITY; -- analytical_representation


ENTITY digital_analytical_model_port
	SUBTYPE OF (analytical_model_port);
END_ENTITY; -- digital_analytical_model_port


ENTITY digital_analytical_model_scalar_port
	SUBTYPE OF (digital_analytical_model_vector_port, analytical_model_scalar_port);
END_ENTITY; -- digital_analytical_model_scalar_port


ENTITY digital_analytical_model_vector_port
	SUBTYPE OF (analytical_model_vector_port);
END_ENTITY; -- digital_analytical_model_vector_port


ENTITY make_from_model_port_relationship
	SUBTYPE OF (representation, representation_relationship);
	SELF\representation_relationship.rep_1 : analytical_model_port;
	SELF\representation_relationship.rep_2 : analytical_model_port;
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 : rep_1 :<>: rep_2;
END_ENTITY; -- make_from_model_port_relationship


ENTITY port_variable
	SUPERTYPE OF (ONEOF (across_port_variable, through_port_variable, transform_port_variable))
	SUBTYPE OF (representation, representation_item);
END_ENTITY; -- port_variable


ENTITY through_port_variable
	SUBTYPE OF (port_variable);
END_ENTITY; -- through_port_variable


ENTITY transform_port_variable
	SUBTYPE OF (port_variable);
END_ENTITY; -- transform_port_variable


ENTITY application_context;
	application : label;
DERIVE
	description : text := get_description_value(SELF);
	id : identifier := get_id_value(SELF);
INVERSE
	context_elements: SET [1:?] OF application_context_element FOR frame_of_reference;
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- application_context


ENTITY application_context_element
	SUPERTYPE OF (ONEOF (library_context, product_concept_context, product_context, product_definition_context));
	name : label;
	frame_of_reference : application_context;
END_ENTITY; -- application_context_element


ENTITY application_context_relationship;
	name : label;
	description : OPTIONAL text;
	relating_context : application_context;
	related_context : application_context;
END_ENTITY; -- application_context_relationship


ENTITY application_protocol_definition;
	status : label;
	application_interpreted_model_schema_name : label;
	application_protocol_year : year_number;
	application : application_context;
END_ENTITY; -- application_protocol_definition


ENTITY library_context
	SUBTYPE OF (application_context_element);
	library_reference : label;
END_ENTITY; -- library_context


ENTITY product_concept_context
	SUBTYPE OF (application_context_element);
	market_segment_type : label;
END_ENTITY; -- product_concept_context


ENTITY product_context
	SUBTYPE OF (application_context_element);
	discipline_type : label;
END_ENTITY; -- product_context


ENTITY product_definition_context
	SUBTYPE OF (application_context_element);
	life_cycle_stage : label;
END_ENTITY; -- product_definition_context


ENTITY applied_approval_assignment
	SUBTYPE OF (approval_assignment);
	items : SET [1:?] OF approval_item;
END_ENTITY; -- applied_approval_assignment


ENTITY approval;
	status : approval_status;
	level : label;
END_ENTITY; -- approval


ENTITY approval_date_time;
	date_time : date_time_select;
	dated_approval : approval;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- approval_date_time


ENTITY approval_person_organization;
	person_organization : person_organization_select;
	authorized_approval : approval;
	role : approval_role;
END_ENTITY; -- approval_person_organization


ENTITY approval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_approval : approval;
	related_approval : approval;
END_ENTITY; -- approval_relationship


ENTITY approval_role;
	role : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- approval_role


ENTITY approval_status;
	name : label;
END_ENTITY; -- approval_status


ENTITY applied_attribute_classification_assignment
	SUBTYPE OF (attribute_classification_assignment);
	items : SET [1:?] OF attribute_classification_item;
	SELF\attribute_classification_assignment.assigned_class : class;
END_ENTITY; -- applied_attribute_classification_assignment


ENTITY description_attribute;
	attribute_value : text;
	described_item : description_attribute_select;
END_ENTITY; -- description_attribute


ENTITY id_attribute;
	attribute_value : identifier;
	identified_item : id_attribute_select;
END_ENTITY; -- id_attribute


ENTITY name_attribute;
	attribute_value : label;
	named_item : name_attribute_select;
END_ENTITY; -- name_attribute


ENTITY object_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- object_role


ENTITY role_association;
	role : object_role;
	item_with_role : role_select;
END_ENTITY; -- role_association


ENTITY applied_certification_assignment
	SUBTYPE OF (certification_assignment);
	items : SET [1:?] OF certification_item;
END_ENTITY; -- applied_certification_assignment


ENTITY certification;
	name : label;
	purpose : text;
	kind : certification_type;
END_ENTITY; -- certification


ENTITY certification_type;
	description : label;
END_ENTITY; -- certification_type


ENTITY characteristic_type
	SUBTYPE OF (group);
END_ENTITY; -- characteristic_type


ENTITY range_characteristic
	SUBTYPE OF (representation, descriptive_representation_item);
END_ENTITY; -- range_characteristic


ENTITY row_representation_item
	SUBTYPE OF (compound_representation_item);
WHERE
	WR1 : SIZEOF(QUERY(itet <* SELF\compound_representation_item.item_element |
       NOT('REPRESENTATION_SCHEMA.LIST_REPRESENTATION_ITEM' IN TYPEOF(itet))
           ))= 0;
END_ENTITY; -- row_representation_item


ENTITY table_representation_item
	SUBTYPE OF (compound_representation_item, characterized_object);
WHERE
	WR1 : SIZEOF(QUERY(itet <* SELF\compound_representation_item.item_element |
       NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ROW_REPRESENTATION_ITEM' IN TYPEOF(itet))
           ))= 0;
END_ENTITY; -- table_representation_item


ENTITY applied_classification_assignment
	SUBTYPE OF (classification_assignment);
	items : SET [1:?] OF classification_item;
END_ENTITY; -- applied_classification_assignment


ENTITY class
	SUBTYPE OF (group);
END_ENTITY; -- class


ENTITY class_by_extension
	SUBTYPE OF (class);
END_ENTITY; -- class_by_extension


ENTITY class_by_intension
	SUBTYPE OF (class);
END_ENTITY; -- class_by_intension


ENTITY classification
	SUBTYPE OF (classification_assignment);
	classified : classification_select;
DERIVE
	classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY; -- classification


ENTITY complete_membership
	SUBTYPE OF (classification_assignment);
DERIVE
	containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY; -- complete_membership


ENTITY complete_membership_of_empty_set
	SUBTYPE OF (complete_membership);
END_ENTITY; -- complete_membership_of_empty_set


ENTITY complete_membership_of_non_empty_set
	SUBTYPE OF (complete_membership);
	members : SET [1:?] OF complete_membership_select;
END_ENTITY; -- complete_membership_of_non_empty_set


ENTITY characterized_class
	SUBTYPE OF (characterized_object, class);
END_ENTITY; -- characterized_class


ENTITY class_system
	SUBTYPE OF (group);
END_ENTITY; -- class_system


ENTITY configurable_item
	SUBTYPE OF (configuration_item);
	item_concept_feature : SET [1:?] OF product_concept_feature_association;
END_ENTITY; -- configurable_item


ENTITY configuration_design;
	configuration : configuration_item;
	design : configuration_design_item;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
UNIQUE
	UR1 : configuration, design;
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- configuration_design


ENTITY configuration_effectivity
	SUBTYPE OF (product_definition_effectivity);
	configuration : configuration_design;
UNIQUE
	UR1 : configuration, usage, id;
WHERE
	WR1 : 'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN
        TYPEOF(SELF\product_definition_effectivity.usage);
END_ENTITY; -- configuration_effectivity


ENTITY configuration_item;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	item_concept : product_concept;
	purpose : OPTIONAL label;
END_ENTITY; -- configuration_item


ENTITY configuration_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_configuration_item : configuration_item;
	related_configuration_item : configuration_item;
END_ENTITY; -- configuration_item_relationship


ENTITY applied_contract_assignment
	SUBTYPE OF (contract_assignment);
	items : SET [1:?] OF contract_item;
END_ENTITY; -- applied_contract_assignment


ENTITY contract;
	name : label;
	purpose : text;
	kind : contract_type;
END_ENTITY; -- contract


ENTITY contract_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_contract : contract;
	related_contract : contract;
END_ENTITY; -- contract_relationship


ENTITY contract_type;
	description : label;
END_ENTITY; -- contract_type


ENTITY applied_date_and_time_assignment
	SUBTYPE OF (date_and_time_assignment);
	items : SET [1:?] OF date_and_time_item;
END_ENTITY; -- applied_date_and_time_assignment


ENTITY applied_date_assignment
	SUBTYPE OF (date_assignment);
	items : SET [1:?] OF date_item;
END_ENTITY; -- applied_date_assignment


ENTITY calendar_date
	SUBTYPE OF (date);
	day_component : day_in_month_number;
	month_component : month_in_year_number;
WHERE
	WR1 : valid_calendar_date(SELF);
END_ENTITY; -- calendar_date


ENTITY coordinated_universal_time_offset;
	hour_offset : INTEGER;
	minute_offset : OPTIONAL INTEGER;
	sense : ahead_or_behind;
DERIVE
	actual_minute_offset : INTEGER := NVL(minute_offset,0);
WHERE
	WR1 : { 0 <= hour_offset < 24 };
	WR2 : { 0 <= actual_minute_offset <= 59 };
	WR3 : NOT(((hour_offset <> 0)OR(actual_minute_offset <>0))AND(sense = exact));
END_ENTITY; -- coordinated_universal_time_offset


ENTITY date
	SUPERTYPE OF (ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date));
	year_component : year_number;
END_ENTITY; -- date


ENTITY date_and_time;
	date_component : date;
	time_component : local_time;
END_ENTITY; -- date_and_time


ENTITY date_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- date_role


ENTITY date_time_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- date_time_role


ENTITY event_occurrence;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence


ENTITY event_occurrence_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence_context_role


ENTITY event_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	relating_event : event_occurrence;
	related_event : event_occurrence;
END_ENTITY; -- event_occurrence_relationship


ENTITY event_occurrence_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- event_occurrence_role


ENTITY local_time;
	hour_component : hour_in_day;
	minute_component : OPTIONAL minute_in_hour;
	second_component : OPTIONAL second_in_minute;
	zone : coordinated_universal_time_offset;
WHERE
	WR1 : valid_time(SELF);
END_ENTITY; -- local_time


ENTITY ordinal_date
	SUBTYPE OF (date);
	day_component : day_in_year_number;
WHERE
	WR1 : (NOT leap_year(SELF.year_component)AND  { 1 <= day_component <= 365 })OR(leap_year(SELF.year_component)AND { 1 <= day_component <= 366 });
END_ENTITY; -- ordinal_date


ENTITY relative_event_occurrence
	SUBTYPE OF (event_occurrence);
	base_event : event_occurrence;
	offset : time_measure_with_unit;
END_ENTITY; -- relative_event_occurrence


ENTITY time_interval;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- time_interval


ENTITY time_interval_relationship;
	name : label;
	description : OPTIONAL text;
	relating_time_interval : time_interval;
	related_time_interval : time_interval;
END_ENTITY; -- time_interval_relationship


ENTITY time_interval_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- time_interval_role


ENTITY time_interval_with_bounds
	SUBTYPE OF (time_interval);
	primary_bound : OPTIONAL date_time_or_event_occurrence;
	secondary_bound : OPTIONAL date_time_or_event_occurrence;
	duration : OPTIONAL time_measure_with_unit;
WHERE
	WR1 : NOT(EXISTS(secondary_bound)AND EXISTS(duration));
	WR2 : EXISTS(primary_bound)OR EXISTS(secondary_bound);
END_ENTITY; -- time_interval_with_bounds


ENTITY time_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- time_role


ENTITY week_of_year_and_day_date
	SUBTYPE OF (date);
	week_component : week_in_year_number;
	day_component : OPTIONAL day_in_week_number;
END_ENTITY; -- week_of_year_and_day_date


ENTITY applied_document_reference
	SUBTYPE OF (document_reference);
	items : SET [1:?] OF document_reference_item;
END_ENTITY; -- applied_document_reference


ENTITY applied_document_usage_constraint_assignment
	SUBTYPE OF (document_usage_constraint_assignment);
	items : SET [1:?] OF document_reference_item;
END_ENTITY; -- applied_document_usage_constraint_assignment


ENTITY document_product_equivalence
	SUBTYPE OF (document_product_association);
WHERE
	WR1 : SELF\document_product_association.name = 'equivalence';
	WR2 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product))OR((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product,'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
	WR3 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product))OR((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
	WR4 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product))OR((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition')AND(SIZEOF(QUERY(prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1));
END_ENTITY; -- document_product_equivalence


ENTITY document;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	kind : document_type;
INVERSE
	representation_types: SET [0:?] OF document_representation_type FOR represented_document;
END_ENTITY; -- document


ENTITY document_product_association;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_product : product_or_formation_or_definition;
END_ENTITY; -- document_product_association


ENTITY document_relationship;
	name : label;
	description : OPTIONAL text;
	relating_document : document;
	related_document : document;
END_ENTITY; -- document_relationship


ENTITY document_representation_type;
	name : label;
	represented_document : document;
END_ENTITY; -- document_representation_type


ENTITY document_type;
	product_data_type : label;
END_ENTITY; -- document_type


ENTITY document_usage_constraint;
	source : document;
	subject_element : label;
	subject_element_value : text;
END_ENTITY; -- document_usage_constraint


ENTITY document_with_class
	SUBTYPE OF (document);
	class : identifier;
END_ENTITY; -- document_with_class


ENTITY applied_effectivity_assignment
	SUBTYPE OF (effectivity_assignment);
	items : SET [1:?] OF effectivity_item;
END_ENTITY; -- applied_effectivity_assignment


ENTITY dated_effectivity
	SUBTYPE OF (effectivity);
	effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
	effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY; -- dated_effectivity


ENTITY effectivity
	SUPERTYPE OF (ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity));
	id : identifier;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- effectivity


ENTITY effectivity_relationship;
	name : label;
	description : OPTIONAL text;
	related_effectivity : effectivity;
	relating_effectivity : effectivity;
END_ENTITY; -- effectivity_relationship


ENTITY lot_effectivity
	SUBTYPE OF (effectivity);
	effectivity_lot_id : identifier;
	effectivity_lot_size : measure_with_unit;
END_ENTITY; -- lot_effectivity


ENTITY serial_numbered_effectivity
	SUBTYPE OF (effectivity);
	effectivity_start_id : identifier;
	effectivity_end_id : OPTIONAL identifier;
END_ENTITY; -- serial_numbered_effectivity


ENTITY time_interval_based_effectivity
	SUBTYPE OF (effectivity);
	effectivity_period : time_interval;
END_ENTITY; -- time_interval_based_effectivity


ENTITY applied_event_occurrence_assignment
	SUBTYPE OF (event_occurrence_assignment);
	items : SET [1:?] OF event_occurrence_item;
END_ENTITY; -- applied_event_occurrence_assignment


ENTITY experience;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience


ENTITY experience_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_experience : experience;
	related_experience : experience;
END_ENTITY; -- experience_relationship


ENTITY experience_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_type


ENTITY experience_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_experience_type : experience_type;
	related_experience_type : experience_type;
END_ENTITY; -- experience_type_relationship


ENTITY definitional_representation_relationship
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 : acyclic_representation_relationship(SELF,
       [SELF\representation_relationship.rep_2],
       'REPRESENTATION_SCHEMA.'+
       'REPRESENTATION');
END_ENTITY; -- definitional_representation_relationship


ENTITY geometric_model_element_relationship
	SUBTYPE OF (geometric_representation_item, representation_item_relationship);
UNIQUE
	UR1 : relating_representation_item, related_representation_item;
WHERE
	WR1 : SELF\representation_item_relationship.relating_representation_item :<>: 
       SELF\representation_item_relationship.related_representation_item;
END_ENTITY; -- geometric_model_element_relationship


ENTITY value_range
	SUBTYPE OF (compound_representation_item);
WHERE
	WR1 : ('value_with_unit_mim.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF(item_element))AND value_range_wr1(item_element);
	WR2 : value_range_wr2(item_element);
	WR3 : value_range_wr3(item_element);
END_ENTITY; -- value_range


ENTITY external_class_library
	SUBTYPE OF (external_source);
END_ENTITY; -- external_class_library


ENTITY externally_defined_class
	SUBTYPE OF (class, externally_defined_item);
END_ENTITY; -- externally_defined_class


ENTITY applied_external_identification_assignment
	SUBTYPE OF (external_identification_assignment);
	items : SET [1:?] OF external_identification_item;
END_ENTITY; -- applied_external_identification_assignment


ENTITY external_source;
	source_id : source_item;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- external_source


ENTITY external_source_relationship;
	name : label;
	description : OPTIONAL text;
	relating_source : external_source;
	related_source : external_source;
END_ENTITY; -- external_source_relationship


ENTITY externally_defined_item;
	item_id : source_item;
	source : external_source;
END_ENTITY; -- externally_defined_item


ENTITY externally_defined_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_item : externally_defined_item;
	related_item : externally_defined_item;
END_ENTITY; -- externally_defined_item_relationship


ENTITY pre_defined_item;
	name : label;
END_ENTITY; -- pre_defined_item


ENTITY document_file
	SUBTYPE OF (document, characterized_object);
WHERE
	WR1 : SELF\characterized_object.name = '';
	WR2 : NOT EXISTS(SELF\characterized_object.description);
	WR3 : SIZEOF(QUERY(drt <* SELF\document.representation_types |
               drt.name IN ['digital','physical']))= 1;
END_ENTITY; -- document_file


ENTITY functional_specification
	SUBTYPE OF (representation);
END_ENTITY; -- functional_specification


ENTITY functional_specification_definition
	SUBTYPE OF (functional_unit);
END_ENTITY; -- functional_specification_definition


ENTITY functional_terminal_group
	SUBTYPE OF (group);
UNIQUE
	UR1 : name;
END_ENTITY; -- functional_terminal_group


ENTITY functional_unit
	SUBTYPE OF (product_definition);
END_ENTITY; -- functional_unit


ENTITY functional_unit_terminal_definition
	SUBTYPE OF (shape_aspect);
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'FUNCTIONAL_UNIT' IN
       TYPEOF(SELF.of_shape.definition));
END_ENTITY; -- functional_unit_terminal_definition


ENTITY make_from_functional_unit_terminal_definition_relationship
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
UNIQUE
	UR1 : relating_shape_aspect, related_shape_aspect;
WHERE
	WR1 : relating_shape_aspect.of_shape :<>: 
       related_shape_aspect.of_shape;
	WR2 : SELF\shape_aspect.product_definitional = FALSE;
END_ENTITY; -- make_from_functional_unit_terminal_definition_relationship


ENTITY scalar_terminal_definition_link
	SUBTYPE OF (shape_aspect, shape_aspect_relationship);
	SELF\shape_aspect_relationship.relating_shape_aspect : functional_unit_terminal_definition;
UNIQUE
	UR1 : related_shape_aspect, relating_shape_aspect;
WHERE
	WR1 : SELF\shape_aspect_relationship.related_shape_aspect :<>:
       SELF\shape_aspect_relationship.relating_shape_aspect;
END_ENTITY; -- scalar_terminal_definition_link


ENTITY general_material_property
	SUBTYPE OF (general_property);
WHERE
	WR1 : SIZEOF(QUERY(gpa <* USEDIN(SELF,'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION')| 
  NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition))))= 0;
END_ENTITY; -- general_material_property


ENTITY block
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
END_ENTITY; -- block


ENTITY boolean_result
	SUBTYPE OF (geometric_representation_item);
	operator : boolean_operator;
	first_operand : boolean_operand;
	second_operand : boolean_operand;
END_ENTITY; -- boolean_result


ENTITY box_domain
	SUBTYPE OF (founded_item);
	corner : cartesian_point;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	zlength : positive_length_measure;
WHERE
	WR1 : SIZEOF(QUERY(item <* USEDIN(SELF,'')|
             NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BOXED_HALF_SPACE'
                    IN TYPEOF(item))))= 0;
END_ENTITY; -- box_domain


ENTITY boxed_half_space
	SUBTYPE OF (half_space_solid);
	enclosure : box_domain;
END_ENTITY; -- boxed_half_space


ENTITY brep_2d
	SUBTYPE OF (solid_model);
	extent : face;
WHERE
	WR1 : SIZEOF(['TOPOLOGY_SCHEMA.FACE_SURFACE',
          'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] *
              TYPEOF(SELF.extent))= 0;
	WR2 : SIZEOF(QUERY(bnds <* extent.bounds |
         NOT('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))))= 0;
	WR3 : SIZEOF(QUERY(bnds <* extent.bounds |
         'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))= 1;
	WR4 : SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* extent.bounds |
         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN  TYPEOF(bnds.bound))|
          NOT(SIZEOF(QUERY(oe <* elp_fbnds.bound\path.edge_list | NOT
         (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element))AND
        (oe.edge_element\geometric_representation_item.dim = 2))))=
                0)))= 0;
END_ENTITY; -- brep_2d


ENTITY brep_with_voids
	SUBTYPE OF (manifold_solid_brep);
	voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY; -- brep_with_voids


ENTITY circular_area
	SUBTYPE OF (primitive_2d);
	centre : cartesian_point;
	radius : positive_length_measure;
END_ENTITY; -- circular_area


ENTITY convex_hexahedron
	SUBTYPE OF (faceted_primitive);
WHERE
	WR1 : SIZEOF(points)= 8;
	WR2 : above_plane(points[1], points[2], points[3], points[4])= 0.0;
	WR3 : above_plane(points[5], points[8], points[7], points[6])= 0.0;
	WR4 : above_plane(points[1], points[4], points[8], points[5])= 0.0;
	WR5 : above_plane(points[4], points[3], points[7], points[8])= 0.0;
	WR6 : above_plane(points[3], points[2], points[6], points[7])= 0.0;
	WR7 : above_plane(points[1], points[5], points[6], points[2])= 0.0;
	WR8 : same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
	WR9 : same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
	WR10 : same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
	WR11 : same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
	WR12 : same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
	WR13 : same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
END_ENTITY; -- convex_hexahedron


ENTITY csg_solid
	SUBTYPE OF (solid_model);
	tree_root_expression : csg_select;
END_ENTITY; -- csg_solid


ENTITY cyclide_segment_solid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	radius1 : positive_length_measure;
	radius2 : positive_length_measure;
	cone_angle1 : plane_angle_measure;
	cone_angle2 : plane_angle_measure;
	turn_angle : plane_angle_measure;
END_ENTITY; -- cyclide_segment_solid


ENTITY eccentric_cone
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	height : positive_length_measure;
	x_offset : length_measure;
	y_offset : length_measure;
	ratio : REAL;
WHERE
	WR1 : ratio >= 0.0;
END_ENTITY; -- eccentric_cone


ENTITY edge_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	ebwm_boundary : SET [1:?] OF connected_edge_set;
END_ENTITY; -- edge_based_wireframe_model


ENTITY ellipsoid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	semi_axis_3 : positive_length_measure;
END_ENTITY; -- ellipsoid


ENTITY elliptic_area
	SUBTYPE OF (primitive_2d);
	position : axis2_placement_2d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
END_ENTITY; -- elliptic_area


ENTITY extruded_area_solid
	SUBTYPE OF (swept_area_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 : dot_product(
       (SELF\swept_area_solid.swept_area.basis_surface\
        elementary_surface.position.p[3]), extruded_direction)<> 0.0;
END_ENTITY; -- extruded_area_solid


ENTITY extruded_face_solid
	SUBTYPE OF (swept_face_solid);
	extruded_direction : direction;
	depth : positive_length_measure;
WHERE
	WR1 : dot_product(
       (SELF\swept_face_solid.swept_face.face_geometry\
        elementary_surface.position.p[3]), extruded_direction)<> 0.0;
END_ENTITY; -- extruded_face_solid


ENTITY face_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	fbsm_faces : SET [1:?] OF connected_face_set;
END_ENTITY; -- face_based_surface_model


ENTITY faceted_brep
	SUBTYPE OF (manifold_solid_brep);
END_ENTITY; -- faceted_brep


ENTITY faceted_primitive
	SUPERTYPE OF (ONEOF (tetrahedron, convex_hexahedron))
	SUBTYPE OF (geometric_representation_item);
	points : LIST [4:?] OF  UNIQUE cartesian_point;
WHERE
	WR1 : points[1].dim = 3;
END_ENTITY; -- faceted_primitive


ENTITY geometric_curve_set
	SUBTYPE OF (geometric_set);
WHERE
	WR1 : SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
                            'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp)))= 0;
END_ENTITY; -- geometric_curve_set


ENTITY geometric_set
	SUPERTYPE OF (ONEOF (geometric_curve_set, geometric_set_replica))
	SUBTYPE OF (geometric_representation_item);
	elements : SET [1:?] OF geometric_set_select;
END_ENTITY; -- geometric_set


ENTITY geometric_set_replica
	SUBTYPE OF (geometric_set);
	parent_set : geometric_set;
	transformation : cartesian_transformation_operator;
DERIVE
	SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := build_transformed_set(transformation, parent_set);
WHERE
	WR1 : acyclic_set_replica(SELF, parent_set);
END_ENTITY; -- geometric_set_replica


ENTITY half_space_2d
	SUBTYPE OF (geometric_representation_item);
	base_curve : curve;
	agreement_flag : BOOLEAN;
END_ENTITY; -- half_space_2d


ENTITY half_space_solid
	SUBTYPE OF (geometric_representation_item);
	base_surface : surface;
	agreement_flag : BOOLEAN;
END_ENTITY; -- half_space_solid


ENTITY manifold_solid_brep
	SUBTYPE OF (solid_model);
	outer : closed_shell;
END_ENTITY; -- manifold_solid_brep


ENTITY polygonal_area
	SUBTYPE OF (primitive_2d);
	bounds : LIST [3:?] OF  UNIQUE cartesian_point;
END_ENTITY; -- polygonal_area


ENTITY primitive_2d
	SUPERTYPE OF (ONEOF (circular_area, elliptic_area, rectangular_area, polygonal_area))
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY; -- primitive_2d


ENTITY rectangle_domain
	SUBTYPE OF (founded_item);
	corner : cartesian_point;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
WHERE
	WR1 : SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT
  ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.RECTANGLED_HALF_SPACE' IN TYPEOF(item))))= 0;
END_ENTITY; -- rectangle_domain


ENTITY rectangled_half_space
	SUBTYPE OF (half_space_2d);
	enclosure : rectangle_domain;
END_ENTITY; -- rectangled_half_space


ENTITY rectangular_area
	SUBTYPE OF (primitive_2d);
	position : axis2_placement_2d;
	x : positive_length_measure;
	y : positive_length_measure;
END_ENTITY; -- rectangular_area


ENTITY rectangular_pyramid
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- rectangular_pyramid


ENTITY revolved_area_solid
	SUBTYPE OF (swept_area_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
END_ENTITY; -- revolved_area_solid


ENTITY revolved_face_solid
	SUBTYPE OF (swept_face_solid);
	axis : axis1_placement;
	angle : plane_angle_measure;
DERIVE
	axis_line : line := representation_item('')||
                    geometric_representation_item()|| curve()||
                    line(axis.location, representation_item('')||
                    geometric_representation_item()||
                    vector(axis.z, 1.0));
END_ENTITY; -- revolved_face_solid


ENTITY right_angular_wedge
	SUBTYPE OF (geometric_representation_item);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
	ltx : length_measure;
WHERE
	WR1 : ((0.0 <= ltx)AND(ltx < x));
END_ENTITY; -- right_angular_wedge


ENTITY right_circular_cone
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 : radius >= 0.0;
END_ENTITY; -- right_circular_cone


ENTITY right_circular_cylinder
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	height : positive_length_measure;
	radius : positive_length_measure;
END_ENTITY; -- right_circular_cylinder


ENTITY sectioned_spine
	SUBTYPE OF (geometric_curve_set);
	cross_sections : LIST [2:?] OF curve;
	spine_points : LIST [2:?] OF point;
WHERE
	WR1 : SIZEOF(SELF\geometric_set.elements)= 1;
	WR2 : 'GEOMETRY_SCHEMA.CURVE' IN
                     TYPEOF(SELF\geometric_set.elements[1]);
	WR3 : SIZEOF(cross_sections)= SIZEOF(spine_points);
	WR4 : SELF\geometric_representation_item.dim = 3;
END_ENTITY; -- sectioned_spine


ENTITY shell_based_surface_model
	SUBTYPE OF (geometric_representation_item);
	sbsm_boundary : SET [1:?] OF shell;
WHERE
	WR1 : constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY; -- shell_based_surface_model


ENTITY shell_based_wireframe_model
	SUBTYPE OF (geometric_representation_item);
	sbwm_boundary : SET [1:?] OF shell;
WHERE
	WR1 : constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY; -- shell_based_wireframe_model


ENTITY solid_model
	SUPERTYPE OF (ONEOF (csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid, solid_replica, brep_2d, trimmed_volume))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- solid_model


ENTITY solid_replica
	SUBTYPE OF (solid_model);
	parent_solid : solid_model;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 : acyclic_solid_replica(SELF, parent_solid);
	WR2 : parent_solid\geometric_representation_item.dim = 3;
END_ENTITY; -- solid_replica


ENTITY sphere
	SUBTYPE OF (geometric_representation_item);
	radius : positive_length_measure;
	centre : point;
END_ENTITY; -- sphere


ENTITY surface_curve_swept_area_solid
	SUBTYPE OF (swept_area_solid);
	directrix : curve;
	start_param : REAL;
	end_param : REAL;
	reference_surface : surface;
WHERE
	WR1 : (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR
         (reference_surface IN(directrix\surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_area_solid


ENTITY surface_curve_swept_face_solid
	SUBTYPE OF (swept_face_solid);
	directrix : curve;
	start_param : REAL;
	end_param : REAL;
	reference_surface : surface;
WHERE
	WR1 : (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR
         (reference_surface IN(directrix\surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_face_solid


ENTITY swept_area_solid
	SUPERTYPE OF (ONEOF (revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid))
	SUBTYPE OF (solid_model);
	swept_area : curve_bounded_surface;
WHERE
	WR1 : 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
END_ENTITY; -- swept_area_solid


ENTITY swept_disk_solid
	SUBTYPE OF (solid_model);
	directrix : curve;
	radius : positive_length_measure;
	inner_radius : OPTIONAL positive_length_measure;
	start_param : REAL;
	end_param : REAL;
WHERE
	WR1 : directrix.dim = 3;
	WR2 : (NOT EXISTS(inner_radius))OR(radius > inner_radius);
END_ENTITY; -- swept_disk_solid


ENTITY swept_face_solid
	SUPERTYPE OF (ONEOF (extruded_face_solid, revolved_face_solid, surface_curve_swept_face_solid))
	SUBTYPE OF (solid_model);
	swept_face : face_surface;
WHERE
	WR1 : 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
END_ENTITY; -- swept_face_solid


ENTITY tetrahedron
	SUBTYPE OF (faceted_primitive);
WHERE
	WR1 : SIZEOF(points)= 4;
	WR2 : above_plane(points[1], points[2], points[3], points[4])<> 0.0;
END_ENTITY; -- tetrahedron


ENTITY torus
	SUBTYPE OF (geometric_representation_item);
	position : axis1_placement;
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
WHERE
	WR1 : major_radius > minor_radius;
END_ENTITY; -- torus


ENTITY trimmed_volume
	SUBTYPE OF (solid_model);
	basis_volume : volume;
	u1 : parameter_value;
	u2 : parameter_value;
	v1 : parameter_value;
	v2 : parameter_value;
	w1 : parameter_value;
	w2 : parameter_value;
WHERE
	WR1 : u1 <> u2;
	WR2 : v1 <> v2;
	WR3 : w1 <> w2;
END_ENTITY; -- trimmed_volume


ENTITY axis1_placement
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
DERIVE
	z : direction := NVL(normalise(axis), dummy_gri ||
                                 direction([0.0,0.0,1.0]));
WHERE
	WR1 : SELF\geometric_representation_item.dim  = 3;
END_ENTITY; -- axis1_placement


ENTITY axis2_placement_2d
	SUBTYPE OF (placement);
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [2:2] OF direction := build_2axes(ref_direction);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY; -- axis2_placement_2d


ENTITY axis2_placement_3d
	SUBTYPE OF (placement);
	axis : OPTIONAL direction;
	ref_direction : OPTIONAL direction;
DERIVE
	p : LIST [3:3] OF direction := build_axes(axis,ref_direction);
WHERE
	WR1 : SELF\placement.location.dim = 3;
	WR2 : (NOT(EXISTS(axis)))OR(axis.dim = 3);
	WR3 : (NOT(EXISTS(ref_direction)))OR(ref_direction.dim = 3);
	WR4 : (NOT(EXISTS(axis)))OR(NOT(EXISTS(ref_direction)))OR
         (cross_product(axis,ref_direction).magnitude > 0.0);
END_ENTITY; -- axis2_placement_3d


ENTITY b_spline_curve
	SUPERTYPE OF ((ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve))
	SUBTYPE OF (bounded_curve);
	degree : INTEGER;
	control_points_list : LIST [2:?] OF cartesian_point;
	curve_form : b_spline_curve_form;
	closed_curve : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:upper_index_on_control_points] OF cartesian_point := list_to_array(control_points_list,0,
                                             upper_index_on_control_points);
	upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list)- 1);
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.UNIFORM_CURVE' IN  TYPEOF(self))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.QUASI_UNIFORM_CURVE' IN  TYPEOF(self))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BEZIER_CURVE' IN  TYPEOF(self))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
END_ENTITY; -- b_spline_curve


ENTITY b_spline_curve_with_knots
	SUBTYPE OF (b_spline_curve);
	knot_multiplicities : LIST [2:?] OF INTEGER;
	knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
	WR1 : constraints_param_b_spline(degree, upper_index_on_knots,
                               upper_index_on_control_points,
                               knot_multiplicities, knots);
	WR2 : SIZEOF(knot_multiplicities)= upper_index_on_knots;
END_ENTITY; -- b_spline_curve_with_knots


ENTITY b_spline_surface
	SUPERTYPE OF ((ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface))
	SUBTYPE OF (bounded_surface);
	u_degree : INTEGER;
	v_degree : INTEGER;
	control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
	surface_form : b_spline_surface_form;
	u_closed : LOGICAL;
	v_closed : LOGICAL;
	self_intersect : LOGICAL;
DERIVE
	control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF cartesian_point := make_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper);
	u_upper : INTEGER := SIZEOF(control_points_list)- 1;
	v_upper : INTEGER := SIZEOF(control_points_list[1])- 1;
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.UNIFORM_SURFACE' IN  TYPEOF(SELF))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.QUASI_UNIFORM_SURFACE' IN  TYPEOF(SELF))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BEZIER_SURFACE' IN  TYPEOF(SELF))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_surface


ENTITY b_spline_surface_with_knots
	SUBTYPE OF (b_spline_surface);
	u_multiplicities : LIST [2:?] OF INTEGER;
	v_multiplicities : LIST [2:?] OF INTEGER;
	u_knots : LIST [2:?] OF parameter_value;
	v_knots : LIST [2:?] OF parameter_value;
	knot_spec : knot_type;
DERIVE
	knot_u_upper : INTEGER := SIZEOF(u_knots);
	knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
	WR1 : constraints_param_b_spline(SELF\b_spline_surface.u_degree,
                   knot_u_upper, SELF\b_spline_surface.u_upper,
                               u_multiplicities, u_knots);
	WR2 : constraints_param_b_spline(SELF\b_spline_surface.v_degree,
                   knot_v_upper, SELF\b_spline_surface.v_upper,
                               v_multiplicities, v_knots);
	WR3 : SIZEOF(u_multiplicities)= knot_u_upper;
	WR4 : SIZEOF(v_multiplicities)= knot_v_upper;
END_ENTITY; -- b_spline_surface_with_knots


ENTITY b_spline_volume
	SUPERTYPE OF ((ONEOF (b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume, bezier_volume) ANDOR rational_b_spline_volume))
	SUBTYPE OF (volume);
	u_degree : INTEGER;
	v_degree : INTEGER;
	w_degree : INTEGER;
	control_points_list : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF cartesian_point;
DERIVE
	control_points : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF ARRAY [0:w_upper] OF cartesian_point := make_array_of_array_of_array(control_points_list,
                                              0,u_upper,0,v_upper,
                                              0,w_upper);
	u_upper : INTEGER := SIZEOF(control_points_list)- 1;
	v_upper : INTEGER := SIZEOF(control_points_list[1])- 1;
	w_upper : INTEGER := SIZEOF(control_points_list[1][1])- 1;
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BEZIER_VOLUME' IN  TYPEOF(SELF))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.UNIFORM_VOLUME' IN  TYPEOF(SELF))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.QUASI_UNIFORM_VOLUME' IN  TYPEOF(SELF))OR
       ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF));
END_ENTITY; -- b_spline_volume


ENTITY b_spline_volume_with_knots
	SUBTYPE OF (b_spline_volume);
	u_multiplicities : LIST [2:?] OF INTEGER;
	v_multiplicities : LIST [2:?] OF INTEGER;
	w_multiplicities : LIST [2:?] OF INTEGER;
	u_knots : LIST [2:?] OF parameter_value;
	v_knots : LIST [2:?] OF parameter_value;
	w_knots : LIST [2:?] OF parameter_value;
DERIVE
	knot_u_upper : INTEGER := SIZEOF(u_knots);
	knot_v_upper : INTEGER := SIZEOF(v_knots);
	knot_w_upper : INTEGER := SIZEOF(w_knots);
WHERE
	WR1 : constraints_param_b_spline(SELF\b_spline_volume.u_degree,
                   knot_u_upper, SELF\b_spline_volume.u_upper,
                               u_multiplicities, u_knots);
	WR2 : constraints_param_b_spline(SELF\b_spline_volume.v_degree,
                   knot_v_upper, SELF\b_spline_volume.v_upper,
                               v_multiplicities, v_knots);
	WR3 : constraints_param_b_spline(SELF\b_spline_volume.w_degree,
                   knot_w_upper, SELF\b_spline_volume.w_upper,
                               w_multiplicities, w_knots);
	WR4 : SIZEOF(u_multiplicities)= knot_u_upper;
	WR5 : SIZEOF(v_multiplicities)= knot_v_upper;
	WR6 : SIZEOF(w_multiplicities)= knot_w_upper;
END_ENTITY; -- b_spline_volume_with_knots


ENTITY bezier_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- bezier_curve


ENTITY bezier_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- bezier_surface


ENTITY bezier_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- bezier_volume


ENTITY block_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
END_ENTITY; -- block_volume


ENTITY boundary_curve
	SUBTYPE OF (composite_curve_on_surface);
WHERE
	WR1 : SELF\composite_curve.closed_curve;
END_ENTITY; -- boundary_curve


ENTITY bounded_curve
	SUPERTYPE OF (ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve))
	SUBTYPE OF (curve);
END_ENTITY; -- bounded_curve


ENTITY bounded_pcurve
	SUBTYPE OF (pcurve, bounded_curve);
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BOUNDED_CURVE' IN
                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
END_ENTITY; -- bounded_pcurve


ENTITY bounded_surface
	SUPERTYPE OF (ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface))
	SUBTYPE OF (surface);
END_ENTITY; -- bounded_surface


ENTITY bounded_surface_curve
	SUBTYPE OF (surface_curve, bounded_curve);
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BOUNDED_CURVE' IN
             TYPEOF(SELF\surface_curve.curve_3d));
END_ENTITY; -- bounded_surface_curve


ENTITY cartesian_point
	SUPERTYPE OF (ONEOF (cylindrical_point, polar_point, spherical_point))
	SUBTYPE OF (point);
	coordinates : LIST [1:3] OF length_measure;
END_ENTITY; -- cartesian_point


ENTITY cartesian_transformation_operator
	SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d))
	SUBTYPE OF (geometric_representation_item, functionally_defined_transformation);
	axis1 : OPTIONAL direction;
	axis2 : OPTIONAL direction;
	local_origin : cartesian_point;
	scale : OPTIONAL REAL;
DERIVE
	scl : REAL := NVL(scale, 1.0);
WHERE
	WR1 : scl > 0.0;
END_ENTITY; -- cartesian_transformation_operator


ENTITY cartesian_transformation_operator_2d
	SUBTYPE OF (cartesian_transformation_operator);
DERIVE
	u : LIST [2:2] OF direction := base_axis(2,SELF\cartesian_transformation_operator.axis1,
                   SELF\cartesian_transformation_operator.axis2,?);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY; -- cartesian_transformation_operator_2d


ENTITY cartesian_transformation_operator_3d
	SUBTYPE OF (cartesian_transformation_operator);
	axis3 : OPTIONAL direction;
DERIVE
	u : LIST [3:3] OF direction := base_axis(3,SELF\cartesian_transformation_operator.axis1,
                        SELF\cartesian_transformation_operator.axis2,axis3);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY; -- cartesian_transformation_operator_3d


ENTITY circle
	SUBTYPE OF (conic);
	radius : positive_length_measure;
END_ENTITY; -- circle


ENTITY circular_involute
	SUBTYPE OF (curve);
	position : axis2_placement;
	base_radius : positive_length_measure;
END_ENTITY; -- circular_involute


ENTITY clothoid
	SUBTYPE OF (curve);
	position : axis2_placement;
	clothoid_constant : length_measure;
END_ENTITY; -- clothoid


ENTITY composite_curve
	SUBTYPE OF (bounded_curve);
	segments : LIST [1:?] OF composite_curve_segment;
	self_intersect : LOGICAL;
DERIVE
	closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
	n_segments : INTEGER := SIZEOF(segments);
WHERE
	WR1 : ((NOT closed_curve)AND (SIZEOF(QUERY(temp <* segments |
                temp.transition = discontinuous))= 1))OR
           ((closed_curve)AND(SIZEOF(QUERY(temp <* segments | 
                temp.transition = discontinuous))= 0));
END_ENTITY; -- composite_curve


ENTITY composite_curve_on_surface
	SUPERTYPE OF (boundary_curve)
	SUBTYPE OF (composite_curve);
DERIVE
	basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
WHERE
	WR1 : SIZEOF(basis_surface)> 0;
	WR2 : constraints_composite_curve_on_surface(SELF);
END_ENTITY; -- composite_curve_on_surface


ENTITY composite_curve_segment
	SUBTYPE OF (founded_item);
	transition : transition_code;
	same_sense : BOOLEAN;
	parent_curve : curve;
INVERSE
	using_curves: BAG [1:?] OF composite_curve FOR segments;
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve));
END_ENTITY; -- composite_curve_segment


ENTITY conic
	SUPERTYPE OF (ONEOF (circle, ellipse, hyperbola, parabola))
	SUBTYPE OF (curve);
	position : axis2_placement;
END_ENTITY; -- conic


ENTITY conical_surface
	SUBTYPE OF (elementary_surface);
	radius : length_measure;
	semi_angle : plane_angle_measure;
WHERE
	WR1 : radius >= 0.0;
END_ENTITY; -- conical_surface


ENTITY curve
	SUPERTYPE OF (ONEOF (line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- curve


ENTITY curve_bounded_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	boundaries : SET [1:?] OF boundary_curve;
	implicit_outer : BOOLEAN;
WHERE
	WR1 : (NOT implicit_outer)OR
        (SIZEOF(QUERY(temp <* boundaries |
           'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))= 0);
	WR2 : (NOT(implicit_outer))OR
               ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
	WR3 : SIZEOF(QUERY(temp <* boundaries |
                  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.OUTER_BOUNDARY_CURVE' IN
                                         TYPEOF(temp)))<= 1;
	WR4 : SIZEOF(QUERY(temp <* boundaries |
           (temp\composite_curve_on_surface.basis_surface [1] <>
                                         SELF.basis_surface)))= 0;
END_ENTITY; -- curve_bounded_surface


ENTITY curve_replica
	SUBTYPE OF (curve);
	parent_curve : curve;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 : transformation.dim = parent_curve.dim;
	WR2 : acyclic_curve_replica(SELF, parent_curve);
END_ENTITY; -- curve_replica


ENTITY cylindrical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	z : length_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [r*cos(theta), r*sin(theta), z];
WHERE
	WR1 : r >= 0.0;
END_ENTITY; -- cylindrical_point


ENTITY cylindrical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY; -- cylindrical_surface


ENTITY cylindrical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	radius : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- cylindrical_volume


ENTITY degenerate_pcurve
	SUBTYPE OF (point);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 : SIZEOF(reference_to_curve\representation.items)= 1;
	WR2 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CURVE' IN TYPEOF
                   (reference_to_curve\representation.items[1]);
	WR3 : reference_to_curve\representation.
                   items[1]\geometric_representation_item.dim =2;
END_ENTITY; -- degenerate_pcurve


ENTITY degenerate_toroidal_surface
	SUBTYPE OF (toroidal_surface);
	select_outer : BOOLEAN;
WHERE
	WR1 : major_radius <   minor_radius;
END_ENTITY; -- degenerate_toroidal_surface


ENTITY direction
	SUBTYPE OF (geometric_representation_item);
	direction_ratios : LIST [2:3] OF REAL;
WHERE
	WR1 : SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0))> 0;
END_ENTITY; -- direction


ENTITY dupin_cyclide_surface
	SUBTYPE OF (elementary_surface);
	generalised_major_radius : positive_length_measure;
	generalised_minor_radius : positive_length_measure;
	skewness : length_measure;
WHERE
	WR1 : skewness >= 0.0;
END_ENTITY; -- dupin_cyclide_surface


ENTITY eccentric_conical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	height : positive_length_measure;
	x_offset : length_measure;
	y_offset : length_measure;
	ratio : REAL;
WHERE
	WR1 : ratio >= 0.0;
END_ENTITY; -- eccentric_conical_volume


ENTITY elementary_surface
	SUPERTYPE OF (ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface))
	SUBTYPE OF (surface);
	position : axis2_placement_3d;
END_ENTITY; -- elementary_surface


ENTITY ellipse
	SUBTYPE OF (conic);
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
END_ENTITY; -- ellipse


ENTITY ellipsoid_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	semi_axis_1 : positive_length_measure;
	semi_axis_2 : positive_length_measure;
	semi_axis_3 : positive_length_measure;
END_ENTITY; -- ellipsoid_volume


ENTITY evaluated_degenerate_pcurve
	SUBTYPE OF (degenerate_pcurve);
	equivalent_point : cartesian_point;
END_ENTITY; -- evaluated_degenerate_pcurve


ENTITY fixed_reference_swept_surface
	SUBTYPE OF (swept_surface);
	directrix : curve;
	fixed_reference : direction;
END_ENTITY; -- fixed_reference_swept_surface


ENTITY geometric_representation_context
	SUBTYPE OF (representation_context);
	coordinate_space_dimension : dimension_count;
END_ENTITY; -- geometric_representation_context


ENTITY geometric_representation_item
	SUPERTYPE OF (ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge, ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid, half_space_2d, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set))
	SUBTYPE OF (representation_item);
DERIVE
	dim : dimension_count := dimension_of(SELF);
WHERE
	WR1 : SIZEOF(QUERY(using_rep <* using_representations(SELF)|
      NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN
      TYPEOF(using_rep.context_of_items))))= 0;
END_ENTITY; -- geometric_representation_item


ENTITY hexahedron_volume
	SUBTYPE OF (volume);
	points : LIST [8:8] OF cartesian_point;
WHERE
	WR1 : above_plane(points[1], points[2], points[3], points[4])= 0.0;
	WR2 : above_plane(points[5], points[8], points[7], points[6])= 0.0;
	WR3 : above_plane(points[1], points[4], points[8], points[5])= 0.0;
	WR4 : above_plane(points[4], points[3], points[7], points[8])= 0.0;
	WR5 : above_plane(points[3], points[2], points[6], points[7])= 0.0;
	WR6 : above_plane(points[1], points[5], points[6], points[2])= 0.0;
	WR7 : same_side([points[1], points[2], points[3]],
                     [points[5], points[6], points[7], points[8]]);
	WR8 : same_side([points[1], points[4], points[8]],
                     [points[3], points[7], points[6], points[2]]);
	WR9 : same_side([points[1], points[2], points[5]],
                      [points[3], points[7], points[8], points[4]]);
	WR10 : same_side([points[5], points[6], points[7]],
                     [points[1], points[2], points[3], points[4]]);
	WR11 : same_side([points[3], points[7], points[6]],
                     [points[1], points[4], points[8], points[5]]);
	WR12 : same_side([points[3], points[7], points[8]],
                      [points[1], points[5], points[6], points[2]]);
	WR13 : points[1].dim = 3;
END_ENTITY; -- hexahedron_volume


ENTITY hyperbola
	SUBTYPE OF (conic);
	semi_axis : positive_length_measure;
	semi_imag_axis : positive_length_measure;
END_ENTITY; -- hyperbola


ENTITY intersection_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 : SIZEOF(SELF\surface_curve.associated_geometry)= 2;
	WR2 : associated_surface(SELF\surface_curve.associated_geometry[1])<>
             associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY; -- intersection_curve


ENTITY line
	SUBTYPE OF (curve);
	pnt : cartesian_point;
	dir : vector;
WHERE
	WR1 : dir.dim  = pnt.dim;
END_ENTITY; -- line


ENTITY offset_curve_2d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
WHERE
	WR1 : basis_curve.dim = 2;
END_ENTITY; -- offset_curve_2d


ENTITY offset_curve_3d
	SUBTYPE OF (curve);
	basis_curve : curve;
	distance : length_measure;
	self_intersect : LOGICAL;
	ref_direction : direction;
WHERE
	WR1 : (basis_curve.dim = 3)AND(ref_direction.dim = 3);
END_ENTITY; -- offset_curve_3d


ENTITY offset_surface
	SUBTYPE OF (surface);
	basis_surface : surface;
	distance : length_measure;
	self_intersect : LOGICAL;
END_ENTITY; -- offset_surface


ENTITY oriented_surface
	SUBTYPE OF (surface);
	orientation : BOOLEAN;
END_ENTITY; -- oriented_surface


ENTITY outer_boundary_curve
	SUBTYPE OF (boundary_curve);
END_ENTITY; -- outer_boundary_curve


ENTITY parabola
	SUBTYPE OF (conic);
	focal_dist : length_measure;
WHERE
	WR1 : focal_dist <> 0.0;
END_ENTITY; -- parabola


ENTITY pcurve
	SUBTYPE OF (curve);
	basis_surface : surface;
	reference_to_curve : definitional_representation;
WHERE
	WR1 : SIZEOF(reference_to_curve\representation.items)= 1;
	WR2 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CURVE' IN TYPEOF
                   (reference_to_curve\representation.items[1]);
	WR3 : reference_to_curve\representation.items[1]\
                               geometric_representation_item.dim =2;
END_ENTITY; -- pcurve


ENTITY placement
	SUPERTYPE OF (ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d))
	SUBTYPE OF (geometric_representation_item);
	location : cartesian_point;
END_ENTITY; -- placement


ENTITY plane
	SUBTYPE OF (elementary_surface);
END_ENTITY; -- plane


ENTITY point
	SUPERTYPE OF (ONEOF (cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica, degenerate_pcurve))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- point


ENTITY point_in_volume
	SUBTYPE OF (point);
	basis_volume : volume;
	point_parameter_u : parameter_value;
	point_parameter_v : parameter_value;
	point_parameter_w : parameter_value;
END_ENTITY; -- point_in_volume


ENTITY point_on_curve
	SUBTYPE OF (point);
	basis_curve : curve;
	point_parameter : parameter_value;
END_ENTITY; -- point_on_curve


ENTITY point_on_surface
	SUBTYPE OF (point);
	basis_surface : surface;
	point_parameter_u : parameter_value;
	point_parameter_v : parameter_value;
END_ENTITY; -- point_on_surface


ENTITY point_replica
	SUBTYPE OF (point);
	parent_pt : point;
	transformation : cartesian_transformation_operator;
WHERE
	WR1 : transformation.dim = parent_pt.dim;
	WR2 : acyclic_point_replica(SELF,parent_pt);
END_ENTITY; -- point_replica


ENTITY polar_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [r*cos(theta), r*sin(theta)];
WHERE
	WR1 : r >= 0.0;
END_ENTITY; -- polar_point


ENTITY polyline
	SUBTYPE OF (bounded_curve);
	points : LIST [2:?] OF cartesian_point;
END_ENTITY; -- polyline


ENTITY pyramid_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	xlength : positive_length_measure;
	ylength : positive_length_measure;
	height : positive_length_measure;
END_ENTITY; -- pyramid_volume


ENTITY quasi_uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- quasi_uniform_curve


ENTITY quasi_uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- quasi_uniform_surface


ENTITY quasi_uniform_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- quasi_uniform_volume


ENTITY rational_b_spline_curve
	SUBTYPE OF (b_spline_curve);
	weights_data : LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:upper_index_on_control_points] OF REAL := list_to_array(weights_data,0,
                                      upper_index_on_control_points);
WHERE
	WR1 : SIZEOF(weights_data)= SIZEOF(SELF\b_spline_curve.
                                           control_points_list);
	WR2 : curve_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_curve


ENTITY rational_b_spline_surface
	SUBTYPE OF (b_spline_surface);
	weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL := make_array_of_array(weights_data,0,u_upper,0,v_upper);
WHERE
	WR1 : (SIZEOF(weights_data)=
                     SIZEOF(SELF\b_spline_surface.control_points_list))
           AND(SIZEOF(weights_data[1])=
                  SIZEOF(SELF\b_spline_surface.control_points_list[1]));
	WR2 : surface_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_surface


ENTITY rational_b_spline_volume
	SUBTYPE OF (b_spline_volume);
	weights_data : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF REAL;
DERIVE
	weights : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF ARRAY [0:w_upper] OF REAL := make_array_of_array_of_array
                            (weights_data,0,u_upper,0,v_upper,0,w_upper);
WHERE
	WR1 : (SIZEOF(weights_data)=
                         SIZEOF(SELF\b_spline_volume.control_points_list))
           AND (SIZEOF(weights_data[1])=
                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))
            AND(SIZEOF(weights_data[1][1])=
                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
	WR2 : volume_weights_positive(SELF);
END_ENTITY; -- rational_b_spline_volume


ENTITY rectangular_composite_surface
	SUBTYPE OF (bounded_surface);
	segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
DERIVE
	n_u : INTEGER := SIZEOF(segments);
	n_v : INTEGER := SIZEOF(segments[1]);
WHERE
	WR1 : SIZEOF(QUERY(s <* segments | n_v <> SIZEOF(s)))= 0;
	WR2 : constraints_rectangular_composite_surface(SELF);
END_ENTITY; -- rectangular_composite_surface


ENTITY rectangular_trimmed_surface
	SUBTYPE OF (bounded_surface);
	basis_surface : surface;
	u1 : parameter_value;
	u2 : parameter_value;
	v1 : parameter_value;
	v2 : parameter_value;
	usense : BOOLEAN;
	vsense : BOOLEAN;
WHERE
	WR1 : u1 <> u2;
	WR2 : v1 <> v2;
	WR3 : (('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ELEMENTARY_SURFACE' IN  TYPEOF(basis_surface))
       AND (NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PLANE' IN  TYPEOF(basis_surface))))OR
     ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))
          OR(usense =(u2 > u1));
	WR4 : (('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SPHERICAL_SURFACE' IN  TYPEOF(basis_surface))
          OR
        ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))
          OR(vsense =(v2 > v1));
END_ENTITY; -- rectangular_trimmed_surface


ENTITY reparametrised_composite_curve_segment
	SUBTYPE OF (composite_curve_segment);
	param_length : parameter_value;
WHERE
	WR1 : param_length > 0.0;
END_ENTITY; -- reparametrised_composite_curve_segment


ENTITY seam_curve
	SUBTYPE OF (surface_curve);
WHERE
	WR1 : SIZEOF(SELF\surface_curve.associated_geometry)= 2;
	WR2 : associated_surface(SELF\surface_curve.associated_geometry[1])=
           associated_surface(SELF\surface_curve.associated_geometry[2]);
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN
           TYPEOF(SELF\surface_curve.associated_geometry[1]);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[2]);
END_ENTITY; -- seam_curve


ENTITY spherical_point
	SUBTYPE OF (cartesian_point);
	r : length_measure;
	theta : plane_angle_measure;
	phi : plane_angle_measure;
DERIVE
	SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
WHERE
	WR1 : r >= 0.0;
END_ENTITY; -- spherical_point


ENTITY spherical_surface
	SUBTYPE OF (elementary_surface);
	radius : positive_length_measure;
END_ENTITY; -- spherical_surface


ENTITY spherical_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	radius : positive_length_measure;
END_ENTITY; -- spherical_volume


ENTITY surface
	SUPERTYPE OF (ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica))
	SUBTYPE OF (geometric_representation_item);
END_ENTITY; -- surface


ENTITY surface_curve
	SUPERTYPE OF ((ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve))
	SUBTYPE OF (curve);
	curve_3d : curve;
	associated_geometry : LIST [1:2] OF pcurve_or_surface;
	master_representation : preferred_surface_curve_representation;
DERIVE
	basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
WHERE
	WR1 : curve_3d.dim = 3;
	WR2 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1]))OR
                       (master_representation <> pcurve_s1);
	WR3 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2]))OR
                       (master_representation <> pcurve_s2);
	WR4 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN TYPEOF(curve_3d));
END_ENTITY; -- surface_curve


ENTITY surface_curve_swept_surface
	SUBTYPE OF (swept_surface);
	directrix : curve;
	reference_surface : surface;
WHERE
	WR1 : (NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SURFACE_CURVE' IN  TYPEOF(directrix)))OR
         (reference_surface IN(directrix\surface_curve.basis_surface));
END_ENTITY; -- surface_curve_swept_surface


ENTITY surface_of_linear_extrusion
	SUBTYPE OF (swept_surface);
	extrusion_axis : vector;
END_ENTITY; -- surface_of_linear_extrusion


ENTITY surface_of_revolution
	SUBTYPE OF (swept_surface);
	axis_position : axis1_placement;
DERIVE
	axis_line : line := representation_item('')||
                     geometric_representation_item()|| curve()||
                     line(axis_position.location, representation_item('')||
                     geometric_representation_item()||
                     vector(axis_position.z, 1.0));
END_ENTITY; -- surface_of_revolution


ENTITY surface_patch
	SUBTYPE OF (founded_item);
	parent_surface : bounded_surface;
	u_transition : transition_code;
	v_transition : transition_code;
	u_sense : BOOLEAN;
	v_sense : BOOLEAN;
INVERSE
	using_surfaces: BAG [1:?] OF rectangular_composite_surface FOR segments;
WHERE
	WR1 : (NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CURVE_BOUNDED_SURFACE' 
                 IN TYPEOF(parent_surface)));
END_ENTITY; -- surface_patch


ENTITY surface_replica
	SUBTYPE OF (surface);
	parent_surface : surface;
	transformation : cartesian_transformation_operator_3d;
WHERE
	WR1 : acyclic_surface_replica(SELF, parent_surface);
END_ENTITY; -- surface_replica


ENTITY swept_surface
	SUPERTYPE OF (ONEOF (surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface, fixed_reference_swept_surface))
	SUBTYPE OF (surface);
	swept_curve : curve;
END_ENTITY; -- swept_surface


ENTITY tetrahedron_volume
	SUBTYPE OF (volume);
	point_1 : cartesian_point;
	point_2 : cartesian_point;
	point_3 : cartesian_point;
	point_4 : cartesian_point;
WHERE
	WR1 : point_1.dim = 3;
	WR2 : above_plane(point_1, point_2, point_3, point_4)<> 0.0;
END_ENTITY; -- tetrahedron_volume


ENTITY toroidal_surface
	SUBTYPE OF (elementary_surface);
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
END_ENTITY; -- toroidal_surface


ENTITY toroidal_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	major_radius : positive_length_measure;
	minor_radius : positive_length_measure;
WHERE
	WR1 : minor_radius < major_radius;
END_ENTITY; -- toroidal_volume


ENTITY trimmed_curve
	SUBTYPE OF (bounded_curve);
	basis_curve : curve;
	trim_1 : SET [1:2] OF trimming_select;
	trim_2 : SET [1:2] OF trimming_select;
	sense_agreement : BOOLEAN;
	master_representation : trimming_preference;
WHERE
	WR1 : (HIINDEX(trim_1)= 1)OR(TYPEOF(trim_1[1])<> TYPEOF(trim_1[2]));
	WR2 : (HIINDEX(trim_2)= 1)OR(TYPEOF(trim_2[1])<> TYPEOF(trim_2[2]));
END_ENTITY; -- trimmed_curve


ENTITY uniform_curve
	SUBTYPE OF (b_spline_curve);
END_ENTITY; -- uniform_curve


ENTITY uniform_surface
	SUBTYPE OF (b_spline_surface);
END_ENTITY; -- uniform_surface


ENTITY uniform_volume
	SUBTYPE OF (b_spline_volume);
END_ENTITY; -- uniform_volume


ENTITY vector
	SUBTYPE OF (geometric_representation_item);
	orientation : direction;
	magnitude : length_measure;
WHERE
	WR1 : magnitude >= 0.0;
END_ENTITY; -- vector


ENTITY volume
	SUPERTYPE OF (ONEOF (block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume))
	SUBTYPE OF (geometric_representation_item);
WHERE
	WR1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY; -- volume


ENTITY wedge_volume
	SUBTYPE OF (volume);
	position : axis2_placement_3d;
	x : positive_length_measure;
	y : positive_length_measure;
	z : positive_length_measure;
	ltx : length_measure;
WHERE
	WR1 : ((0.0 <= ltx)AND(ltx < x));
END_ENTITY; -- wedge_volume


ENTITY applied_group_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF groupable_item;
END_ENTITY; -- applied_group_assignment


ENTITY group;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- group


ENTITY group_relationship;
	name : label;
	description : OPTIONAL text;
	relating_group : group;
	related_group : group;
END_ENTITY; -- group_relationship


ENTITY applied_identification_assignment
	SUBTYPE OF (identification_assignment);
	items : SET [1:?] OF identification_item;
END_ENTITY; -- applied_identification_assignment


ENTITY binary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:2] OF generic_expression;
END_ENTITY; -- binary_generic_expression


ENTITY environment;
	syntactic_representation : generic_variable;
	semantics : variable_semantics;
END_ENTITY; -- environment


ENTITY generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression));
WHERE
	WR1 : is_acyclic(SELF);
END_ENTITY; -- generic_expression


ENTITY generic_literal
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
END_ENTITY; -- generic_literal


ENTITY generic_variable
	ABSTRACT SUPERTYPE
	SUBTYPE OF (simple_generic_expression);
INVERSE
	interpretation: environment FOR syntactic_representation;
END_ENTITY; -- generic_variable


ENTITY multiple_arity_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operands : LIST [2:?] OF generic_expression;
END_ENTITY; -- multiple_arity_generic_expression


ENTITY simple_generic_expression
	ABSTRACT SUPERTYPE OF (ONEOF (generic_literal, generic_variable))
	SUBTYPE OF (generic_expression);
END_ENTITY; -- simple_generic_expression


ENTITY unary_generic_expression
	ABSTRACT SUPERTYPE
	SUBTYPE OF (generic_expression);
	operand : generic_expression;
END_ENTITY; -- unary_generic_expression


ENTITY variable_semantics
	ABSTRACT SUPERTYPE;
END_ENTITY; -- variable_semantics


ENTITY location;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location


ENTITY location_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_location : location;
	related_location : location;
END_ENTITY; -- location_relationship


ENTITY action_assignment
	ABSTRACT SUPERTYPE;
	assigned_action : action;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- action_assignment


ENTITY action_method_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_method : action_method;
	role : action_method_role;
END_ENTITY; -- action_method_assignment


ENTITY action_method_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- action_method_role


ENTITY action_request_assignment
	ABSTRACT SUPERTYPE;
	assigned_action_request : versioned_action_request;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- action_request_assignment


ENTITY approval_assignment
	ABSTRACT SUPERTYPE;
	assigned_approval : approval;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- approval_assignment


ENTITY attribute_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	attribute_name : label;
	role : classification_role;
END_ENTITY; -- attribute_classification_assignment


ENTITY attribute_value_assignment
	ABSTRACT SUPERTYPE;
	attribute_name : label;
	attribute_value : attribute_type;
	role : attribute_value_role;
END_ENTITY; -- attribute_value_assignment


ENTITY attribute_value_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- attribute_value_role


ENTITY certification_assignment
	ABSTRACT SUPERTYPE;
	assigned_certification : certification;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- certification_assignment


ENTITY classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_class : group;
	role : classification_role;
END_ENTITY; -- classification_assignment


ENTITY classification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- classification_role


ENTITY contract_assignment
	ABSTRACT SUPERTYPE;
	assigned_contract : contract;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- contract_assignment


ENTITY date_and_time_assignment
	ABSTRACT SUPERTYPE;
	assigned_date_and_time : date_and_time;
	role : date_time_role;
END_ENTITY; -- date_and_time_assignment


ENTITY date_assignment
	ABSTRACT SUPERTYPE;
	assigned_date : date;
	role : date_role;
END_ENTITY; -- date_assignment


ENTITY document_reference
	ABSTRACT SUPERTYPE;
	assigned_document : document;
	source : label;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- document_reference


ENTITY document_usage_constraint_assignment
	ABSTRACT SUPERTYPE;
	assigned_document_usage : document_usage_constraint;
	role : document_usage_role;
END_ENTITY; -- document_usage_constraint_assignment


ENTITY document_usage_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- document_usage_role


ENTITY effectivity_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity : effectivity;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- effectivity_assignment


ENTITY effectivity_context_assignment
	ABSTRACT SUPERTYPE;
	assigned_effectivity_assignment : effectivity_assignment;
	role : effectivity_context_role;
END_ENTITY; -- effectivity_context_assignment


ENTITY effectivity_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- effectivity_context_role


ENTITY event_occurrence_assignment
	ABSTRACT SUPERTYPE;
	assigned_event_occurrence : event_occurrence;
	role : event_occurrence_role;
END_ENTITY; -- event_occurrence_assignment


ENTITY event_occurrence_context_assignment
	ABSTRACT SUPERTYPE;
	assigned_event_occurrence_assignment : event_occurrence_assignment;
	role : event_occurrence_context_role;
END_ENTITY; -- event_occurrence_context_assignment


ENTITY experience_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_experience : experience;
	role : experience_role;
END_ENTITY; -- experience_assignment


ENTITY experience_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_role


ENTITY experience_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_experience_type : experience_type;
	role : experience_type_role;
END_ENTITY; -- experience_type_assignment


ENTITY experience_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- experience_type_role


ENTITY external_identification_assignment
	ABSTRACT SUPERTYPE
	SUBTYPE OF (identification_assignment);
	source : external_source;
END_ENTITY; -- external_identification_assignment


ENTITY external_referent_assignment
	ABSTRACT SUPERTYPE;
	assigned_name : label;
DERIVE
	role : object_role := get_role(SELF);
UNIQUE
	UR1 : assigned_name;
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- external_referent_assignment


ENTITY group_assignment
	ABSTRACT SUPERTYPE;
	assigned_group : group;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- group_assignment


ENTITY identification_assignment
	ABSTRACT SUPERTYPE;
	assigned_id : identifier;
	role : identification_role;
END_ENTITY; -- identification_assignment


ENTITY identification_assignment_relationship;
	name : label;
	description : OPTIONAL text;
	relating_identification_assignment : identification_assignment;
	related_identification_assignment : identification_assignment;
END_ENTITY; -- identification_assignment_relationship


ENTITY identification_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- identification_role


ENTITY library_assignment
	ABSTRACT SUPERTYPE
	SUBTYPE OF (external_referent_assignment);
	frame_of_reference : library_context;
UNIQUE
	UR1 : frame_of_reference;
END_ENTITY; -- library_assignment


ENTITY location_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_location : location;
	role : location_role;
END_ENTITY; -- location_assignment


ENTITY location_representation_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	represented_location : location;
	role : location_representation_role;
END_ENTITY; -- location_representation_assignment


ENTITY location_representation_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location_representation_role


ENTITY location_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- location_role


ENTITY name_assignment
	ABSTRACT SUPERTYPE;
	assigned_name : label;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- name_assignment


ENTITY organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_organization : organization;
	role : organization_role;
END_ENTITY; -- organization_assignment


ENTITY organization_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_organization_type : organization_type;
	role : organization_type_role;
END_ENTITY; -- organization_type_assignment


ENTITY organization_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization_type_role


ENTITY organizational_project_assignment
	ABSTRACT SUPERTYPE;
	assigned_organizational_project : organizational_project;
	role : organizational_project_role;
END_ENTITY; -- organizational_project_assignment


ENTITY organizational_project_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organizational_project_role


ENTITY person_and_organization_assignment
	ABSTRACT SUPERTYPE;
	assigned_person_and_organization : person_and_organization;
	role : person_and_organization_role;
END_ENTITY; -- person_and_organization_assignment


ENTITY person_assignment
	ABSTRACT SUPERTYPE;
	assigned_person : person;
	role : person_role;
END_ENTITY; -- person_assignment


ENTITY person_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_person_type : person_type;
	role : person_type_role;
END_ENTITY; -- person_type_assignment


ENTITY person_type_definition_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_person_type_definition : person_type_definition;
	role : person_type_definition_role;
END_ENTITY; -- person_type_definition_assignment


ENTITY person_type_definition_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type_definition_role


ENTITY person_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type_role


ENTITY position_in_organization_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_position_in_organization : position_in_organization;
	role : position_in_organization_role;
END_ENTITY; -- position_in_organization_assignment


ENTITY position_in_organization_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_role


ENTITY position_in_organization_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_position_in_organization_type : position_in_organization_type;
	role : position_in_organization_type_role;
END_ENTITY; -- position_in_organization_type_assignment


ENTITY position_in_organization_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_type_role


ENTITY qualification_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_qualification : qualification;
	role : qualification_role;
END_ENTITY; -- qualification_assignment


ENTITY qualification_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_role


ENTITY qualification_type_assignment
	ABSTRACT SUPERTYPE;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	assigned_qualification_type : qualification_type;
	role : qualification_type_role;
END_ENTITY; -- qualification_type_assignment


ENTITY qualification_type_role;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_type_role


ENTITY security_classification_assignment
	ABSTRACT SUPERTYPE;
	assigned_security_classification : security_classification;
DERIVE
	role : object_role := get_role(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))<= 1;
END_ENTITY; -- security_classification_assignment


ENTITY time_assignment
	ABSTRACT SUPERTYPE;
	assigned_time : local_time;
	role : time_role;
END_ENTITY; -- time_assignment


ENTITY time_interval_assignment
	ABSTRACT SUPERTYPE;
	assigned_time_interval : time_interval;
	role : time_interval_role;
END_ENTITY; -- time_interval_assignment


ENTITY material_designation;
	name : label;
	definitions : SET [1:?] OF characterized_definition;
END_ENTITY; -- material_designation


ENTITY material_designation_characterization;
	name : label;
	description : text;
	designation : material_designation;
	property : characterized_material_property;
END_ENTITY; -- material_designation_characterization


ENTITY material_property
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : name, definition;
WHERE
	WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
          TYPEOF(SELF\property_definition.definition))OR
      (SIZEOF(bag_to_set(USEDIN(SELF ,
                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))-
              QUERY(temp <* bag_to_set(USEDIN(SELF ,
                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|
                      ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
                      'MATERIAL_PROPERTY_REPRESENTATION' IN
                      TYPEOF(temp))))= 0);
END_ENTITY; -- material_property


ENTITY product_material_composition_relationship
	SUBTYPE OF (product_definition_relationship);
	class : label;
	constituent_amount : SET [1:?] OF measure_with_unit;
	composition_basis : label;
	determination_method : text;
END_ENTITY; -- product_material_composition_relationship


ENTITY property_definition_relationship;
	name : label;
	description : text;
	relating_property_definition : property_definition;
	related_property_definition : property_definition;
END_ENTITY; -- property_definition_relationship


ENTITY data_environment;
	name : label;
	description : text;
	elements : SET [1:?] OF property_definition_representation;
END_ENTITY; -- data_environment


ENTITY data_environment_relationship;
	name : label;
	description : text;
	relating_data_environment : data_environment;
	related_data_environment : data_environment;
END_ENTITY; -- data_environment_relationship


ENTITY material_property_representation
	SUBTYPE OF (property_definition_representation);
	dependent_environment : data_environment;
END_ENTITY; -- material_property_representation


ENTITY amount_of_substance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- amount_of_substance_measure_with_unit


ENTITY amount_of_substance_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- amount_of_substance_unit


ENTITY area_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- area_measure_with_unit


ENTITY area_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 2.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- area_unit


ENTITY celsius_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- celsius_temperature_measure_with_unit


ENTITY context_dependent_unit
	SUBTYPE OF (named_unit);
	name : label;
END_ENTITY; -- context_dependent_unit


ENTITY conversion_based_unit
	SUBTYPE OF (named_unit);
	name : label;
	conversion_factor : measure_with_unit;
END_ENTITY; -- conversion_based_unit


ENTITY derived_unit;
	elements : SET [1:?] OF derived_unit_element;
DERIVE
	name : label := get_name_value(SELF);
WHERE
	WR1 : (SIZEOF(elements)> 1)OR((SIZEOF(elements)= 1)AND(elements[1].exponent <> 1.0));
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
END_ENTITY; -- derived_unit


ENTITY derived_unit_element;
	unit : named_unit;
	exponent : REAL;
END_ENTITY; -- derived_unit_element


ENTITY dimensional_exponents;
	length_exponent : REAL;
	mass_exponent : REAL;
	time_exponent : REAL;
	electric_current_exponent : REAL;
	thermodynamic_temperature_exponent : REAL;
	amount_of_substance_exponent : REAL;
	luminous_intensity_exponent : REAL;
END_ENTITY; -- dimensional_exponents


ENTITY electric_current_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- electric_current_measure_with_unit


ENTITY electric_current_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- electric_current_unit


ENTITY global_unit_assigned_context
	SUBTYPE OF (representation_context);
	units : SET [1:?] OF unit;
END_ENTITY; -- global_unit_assigned_context


ENTITY length_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- length_measure_with_unit


ENTITY length_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 1.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- length_unit


ENTITY luminous_intensity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- luminous_intensity_measure_with_unit


ENTITY luminous_intensity_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
END_ENTITY; -- luminous_intensity_unit


ENTITY mass_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- mass_measure_with_unit


ENTITY mass_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 1.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- mass_unit


ENTITY measure_with_unit
	SUPERTYPE OF (ONEOF (length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit));
	value_component : measure_value;
	unit_component : unit;
WHERE
	WR1 : valid_units(SELF);
END_ENTITY; -- measure_with_unit


ENTITY named_unit
	SUPERTYPE OF ((ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit, ratio_unit)));
	dimensions : dimensional_exponents;
END_ENTITY; -- named_unit


ENTITY plane_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- plane_angle_measure_with_unit


ENTITY plane_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- plane_angle_unit


ENTITY ratio_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- ratio_measure_with_unit


ENTITY ratio_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- ratio_unit


ENTITY si_unit
	SUBTYPE OF (named_unit);
	prefix : OPTIONAL si_prefix;
	name : si_unit_name;
DERIVE
	SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(name);
END_ENTITY; -- si_unit


ENTITY solid_angle_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- solid_angle_measure_with_unit


ENTITY solid_angle_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- solid_angle_unit


ENTITY thermodynamic_temperature_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- thermodynamic_temperature_measure_with_unit


ENTITY thermodynamic_temperature_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- thermodynamic_temperature_unit


ENTITY time_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- time_measure_with_unit


ENTITY time_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 1.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
END_ENTITY; -- time_unit


ENTITY volume_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY; -- volume_measure_with_unit


ENTITY volume_unit
	SUBTYPE OF (named_unit);
WHERE
	WR1 : (SELF\named_unit.dimensions.length_exponent = 3.000000)AND (SELF\named_unit.dimensions.mass_exponent = 0.000000)AND (SELF\named_unit.dimensions.time_exponent = 0.000000)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
END_ENTITY; -- volume_unit


ENTITY category_model_parameter
	SUBTYPE OF (model_parameter);
END_ENTITY; -- category_model_parameter


ENTITY model_parameter
	SUBTYPE OF (descriptive_representation_item, group_assignment, general_property);
	items : OPTIONAL SET [1:1] OF model_parameter_assigned_item;
END_ENTITY; -- model_parameter


ENTITY parameter_assignment
	SUBTYPE OF (parameter_assignment_representation, property_definition_representation);
END_ENTITY; -- parameter_assignment


ENTITY parameter_assignment_override
	SUBTYPE OF (representation, representation_relationship);
	SELF\representation_relationship.rep_1 : parameter_assignment_representation;
	SELF\representation_relationship.rep_2 : parameter_assignment_representation;
UNIQUE
	UR1 : rep_1, rep_2;
WHERE
	WR1 : SELF\representation_relationship.rep_1 <> 
       SELF\representation_relationship.rep_2;
END_ENTITY; -- parameter_assignment_override


ENTITY parameter_assignment_representation
	SUBTYPE OF (representation);
END_ENTITY; -- parameter_assignment_representation


ENTITY product_specific_parameter_value_assignment
	SUBTYPE OF (characterized_object, product_related_product_category);
END_ENTITY; -- product_specific_parameter_value_assignment


ENTITY schema_based_model_parameter
	SUBTYPE OF (model_parameter);
END_ENTITY; -- schema_based_model_parameter


ENTITY test_method_based_parameter_assignment
	SUBTYPE OF (parameter_assignment);
END_ENTITY; -- test_method_based_parameter_assignment


ENTITY attribute_language_assignment
	SUBTYPE OF (attribute_classification_assignment);
	items : SET [1:?] OF attribute_language_item;
	SELF\attribute_classification_assignment.assigned_class : language;
WHERE
	WR1 : SELF\attribute_classification_assignment.role.name IN ['primary', 'translated'];
	WR2 : SELF\attribute_classification_assignment.attribute_name<> '';
END_ENTITY; -- attribute_language_assignment


ENTITY language
	SUBTYPE OF (group);
WHERE
	WR1 : SELF\group.name <> '';
END_ENTITY; -- language


ENTITY multi_language_attribute_assignment
	SUBTYPE OF (attribute_value_assignment);
	items : SET [1:?] OF multi_language_attribute_item;
DERIVE
	translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;
INVERSE
	language_indication: SET [1:1] OF attribute_language_assignment FOR items;
WHERE
	WR1 : (SELF\attribute_value_assignment.role.name = 'alternate language');
	WR2 : SIZEOF(QUERY(ala <* language_indication |  
  (ala\attribute_classification_assignment.attribute_name = 'attribute_value')AND 
  (ala\attribute_classification_assignment.role.name='translated')))= 1;
	WR3 : SELF\attribute_value_assignment.attribute_name <> '';
	WR4 : SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')|
(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name)AND 
(ata.translation_language :=: translation_language)))>1))=0;
	WR5 : SIZEOF(QUERY(ci <* items |
SIZEOF(QUERY(ata <* USEDIN(ci, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')|
(ata\attribute_classification_assignment.role.name='primary')AND
(ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name)AND 
(ata\attribute_classification_assignment.assigned_class :=: translation_language)))>0))=0;
END_ENTITY; -- multi_language_attribute_assignment


ENTITY applied_name_assignment
	SUBTYPE OF (name_assignment);
	item : name_item;
END_ENTITY; -- applied_name_assignment


ENTITY bus_element_link
	SUBTYPE OF (product_definition, product_definition_relationship);
UNIQUE
	UR1 : related_product_definition, relating_product_definition;
WHERE
	WR1 : SELF\product_definition_relationship.related_product_definition :<>:
       SELF\product_definition_relationship.relating_product_definition;
END_ENTITY; -- bus_element_link


ENTITY bus_structural_definition
	SUBTYPE OF (product_definition);
END_ENTITY; -- bus_structural_definition


ENTITY component_functional_terminal
	SUBTYPE OF (shape_aspect);
END_ENTITY; -- component_functional_terminal


ENTITY component_functional_unit
	SUBTYPE OF (product_definition);
END_ENTITY; -- component_functional_unit


ENTITY network_node_definition
	SUBTYPE OF (product_definition);
END_ENTITY; -- network_node_definition


ENTITY applied_organization_assignment
	SUBTYPE OF (organization_assignment);
	items : SET [1:?] OF organization_item;
END_ENTITY; -- applied_organization_assignment


ENTITY applied_person_and_organization_assignment
	SUBTYPE OF (person_and_organization_assignment);
	items : SET [1:?] OF person_and_organization_item;
END_ENTITY; -- applied_person_and_organization_assignment


ENTITY person_and_organization_address
	SUBTYPE OF (organizational_address, personal_address);
	SELF\organizational_address.organizations : SET [1:1] OF organization;
	SELF\personal_address.people : SET [1:1] OF person;
WHERE
	WR1 : SIZEOF(QUERY(pao <* USEDIN(SELF\personal_address.people[1], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON')| pao.the_organization :=: SELF\organizational_address.organizations[1]))= 1;
END_ENTITY; -- person_and_organization_address


ENTITY address;
	internal_location : OPTIONAL label;
	street_number : OPTIONAL label;
	street : OPTIONAL label;
	postal_box : OPTIONAL label;
	town : OPTIONAL label;
	region : OPTIONAL label;
	postal_code : OPTIONAL label;
	country : OPTIONAL label;
	facsimile_number : OPTIONAL label;
	telephone_number : OPTIONAL label;
	electronic_mail_address : OPTIONAL label;
	telex_number : OPTIONAL label;
DERIVE
	name : label := get_name_value(SELF);
	url : identifier := get_id_value(SELF);
WHERE
	WR1 : EXISTS(internal_location)OR  EXISTS(street_number)OR  EXISTS(street)OR  EXISTS(postal_box)OR  EXISTS(town)OR  EXISTS(region)OR  EXISTS(postal_code)OR  EXISTS(country)OR  EXISTS(facsimile_number)OR  EXISTS(telephone_number)OR  EXISTS(electronic_mail_address)OR EXISTS(telex_number);
END_ENTITY; -- address


ENTITY organization;
	id : OPTIONAL identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization


ENTITY organization_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organization : organization;
	related_organization : organization;
END_ENTITY; -- organization_relationship


ENTITY organization_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- organization_role


ENTITY organization_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- organization_type


ENTITY organization_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_organization_type : organization_type;
	related_organization_type : organization_type;
END_ENTITY; -- organization_type_relationship


ENTITY organizational_address
	SUBTYPE OF (address);
	organizations : SET [1:?] OF organization;
	description : OPTIONAL text;
END_ENTITY; -- organizational_address


ENTITY organizational_project;
	name : label;
	description : OPTIONAL text;
	responsible_organizations : SET [1:?] OF organization;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- organizational_project


ENTITY organizational_project_relationship;
	name : label;
	description : OPTIONAL text;
	relating_organizational_project : organizational_project;
	related_organizational_project : organizational_project;
END_ENTITY; -- organizational_project_relationship


ENTITY person;
	id : identifier;
	last_name : OPTIONAL label;
	first_name : OPTIONAL label;
	middle_names : OPTIONAL LIST [1:?] OF label;
	prefix_titles : OPTIONAL LIST [1:?] OF label;
	suffix_titles : OPTIONAL LIST [1:?] OF label;
WHERE
	WR1 : EXISTS(last_name)OR EXISTS(first_name);
END_ENTITY; -- person


ENTITY person_and_organization;
	the_person : person;
	the_organization : organization;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- person_and_organization


ENTITY person_and_organization_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- person_and_organization_role


ENTITY person_role;
	name : label;
DERIVE
	description : text := get_description_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
END_ENTITY; -- person_role


ENTITY person_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- person_type


ENTITY person_type_definition;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	formation : person_type_definition_formation;
END_ENTITY; -- person_type_definition


ENTITY person_type_definition_formation;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	of_person_type : person_type;
END_ENTITY; -- person_type_definition_formation


ENTITY person_type_definition_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_person_type_definition : person_type_definition;
	related_person_type_definition : person_type_definition;
END_ENTITY; -- person_type_definition_relationship


ENTITY personal_address
	SUBTYPE OF (address);
	people : SET [1:?] OF person;
	description : OPTIONAL text;
END_ENTITY; -- personal_address


ENTITY position_in_organization;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization


ENTITY position_in_organization_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_position_in_organization : position_in_organization;
	related_position_in_organization : position_in_organization;
END_ENTITY; -- position_in_organization_relationship


ENTITY position_in_organization_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- position_in_organization_type


ENTITY known_source
	SUBTYPE OF (external_source, pre_defined_item);
END_ENTITY; -- known_source


ENTITY action_property_representation;
	name : label;
	description : text;
	property : action_property;
	representation : representation;
END_ENTITY; -- action_property_representation


ENTITY resource_property_representation;
	name : label;
	description : text;
	property : resource_property;
	representation : representation;
END_ENTITY; -- resource_property_representation


ENTITY action_property;
	name : label;
	description : text;
	definition : characterized_action_definition;
END_ENTITY; -- action_property


ENTITY action_property_relationship;
	name : label;
	description : text;
	relating_action_property : action_property;
	related_action_property : action_property;
WHERE
	WR1 : relating_action_property :<>: related_action_property;
END_ENTITY; -- action_property_relationship


ENTITY action_resource_requirement;
	name : label;
	description : text;
	kind : resource_requirement_type;
	operations : SET [1:?] OF characterized_action_definition;
END_ENTITY; -- action_resource_requirement


ENTITY action_resource_requirement_relationship;
	name : label;
	description : text;
	relating_action_resource_requirement : action_resource_requirement;
	related_action_resource_requirement : action_resource_requirement;
WHERE
	WR1 : relating_action_resource_requirement :<>: 
       related_action_resource_requirement;
END_ENTITY; -- action_resource_requirement_relationship


ENTITY process_product_association;
	name : label;
	description : text;
	defined_product : characterized_product_definition;
	process : product_definition_process;
END_ENTITY; -- process_product_association


ENTITY process_property_association;
	name : label;
	description : text;
	process : property_process;
	property_or_shape : property_or_shape_select;
END_ENTITY; -- process_property_association


ENTITY product_definition_process
	SUBTYPE OF (action);
	identification : identifier;
INVERSE
	product_definitions: SET [1:?] OF process_product_association FOR process;
END_ENTITY; -- product_definition_process


ENTITY property_process
	SUBTYPE OF (action);
	identification : identifier;
INVERSE
	properties: SET [1:?] OF process_property_association FOR process;
END_ENTITY; -- property_process


ENTITY replacement_relationship
	SUBTYPE OF (action_relationship);
WHERE
	WR1 : acyclic_action_relationship(SELF,
       [SELF\action_relationship.related_action],
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.REPLACEMENT_RELATIONSHIP');
END_ENTITY; -- replacement_relationship


ENTITY requirement_for_action_resource
	SUBTYPE OF (action_resource_requirement);
	resources : SET [1:?] OF action_resource;
END_ENTITY; -- requirement_for_action_resource


ENTITY resource_property;
	name : label;
	description : text;
	resource : characterized_resource_definition;
END_ENTITY; -- resource_property


ENTITY resource_property_relationship;
	name : label;
	description : text;
	relating_resource_property : resource_property;
	related_resource_property : resource_property;
WHERE
	WR1 : relating_resource_property :<>: related_resource_property;
END_ENTITY; -- resource_property_relationship


ENTITY resource_requirement_type;
	name : label;
	description : text;
END_ENTITY; -- resource_requirement_type


ENTITY resource_requirement_type_relationship;
	name : label;
	description : text;
	relating_requirement_type : resource_requirement_type;
	related_requirement_type : resource_requirement_type;
WHERE
	WR1 : relating_requirement_type :<>: related_requirement_type;
END_ENTITY; -- resource_requirement_type_relationship


ENTITY exclusive_product_concept_feature_category
	SUBTYPE OF (product_concept_feature_category);
END_ENTITY; -- exclusive_product_concept_feature_category


ENTITY inclusion_product_concept_feature
	SUBTYPE OF (conditional_concept_feature);
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(SELF));
	WR2 : SIZEOF(QUERY(cfr <* USEDIN(SELF  ,'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE')| 
	'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN  TYPEOF(cfr)))+ 
SIZEOF(QUERY(cfr <* USEDIN(SELF, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE')| 
	'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)))= 0;
	WR3 : SELF.condition.conditional_operator.name = 'implication';
END_ENTITY; -- inclusion_product_concept_feature


ENTITY package_product_concept_feature
	SUBTYPE OF (product_concept_feature);
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF(SELF));
	WR2 : SIZEOF(QUERY(cfr <* USEDIN(SELF ,
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE')| 
('AUTOMOTIVE_DESIGN.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN  TYPEOF (cfr))AND 
(SIZEOF(QUERY(ipcf <* USEDIN(cfr, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.' +
'CONDITION')| 
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(ipcf)))= 1)))>0;
END_ENTITY; -- package_product_concept_feature


ENTITY product_class
	SUBTYPE OF (product_concept, characterized_object);
END_ENTITY; -- product_class


ENTITY product_concept_feature_category
	SUBTYPE OF (group);
WHERE
	WR1 : SIZEOF(QUERY(aga <* USEDIN(SELF, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')|
    ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'APPLIED_GROUP_ASSIGNMENT' IN  TYPEOF(aga))AND
   ((aga.role.name <> 'specification category member')OR 
  (SIZEOF(QUERY(i <* aga.items |('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'PRODUCT_CONCEPT_FEATURE' IN  TYPEOF(i))AND 
    NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF(i))))<> SIZEOF(aga.items)))
     ))=0;
END_ENTITY; -- product_concept_feature_category


ENTITY product_concept_feature_category_usage
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF category_usage_item;
	SELF\group_assignment.assigned_group : product_concept_feature_category;
WHERE
	WR1 : SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ];
END_ENTITY; -- product_concept_feature_category_usage


ENTITY concept_feature_operator;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- concept_feature_operator


ENTITY concept_feature_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept_feature : product_concept_feature;
	related_product_concept_feature : product_concept_feature;
END_ENTITY; -- concept_feature_relationship


ENTITY concept_feature_relationship_with_condition
	SUBTYPE OF (concept_feature_relationship);
	conditional_operator : concept_feature_operator;
END_ENTITY; -- concept_feature_relationship_with_condition


ENTITY conditional_concept_feature
	SUBTYPE OF (product_concept_feature);
	condition : concept_feature_relationship_with_condition;
END_ENTITY; -- conditional_concept_feature


ENTITY product_concept;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	market_context : product_concept_context;
UNIQUE
	UR1 : id;
END_ENTITY; -- product_concept


ENTITY product_concept_feature;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- product_concept_feature


ENTITY product_concept_feature_association;
	name : label;
	description : OPTIONAL text;
	concept : product_concept;
	feature : product_concept_feature;
END_ENTITY; -- product_concept_feature_association


ENTITY product_concept_relationship;
	name : label;
	description : OPTIONAL text;
	relating_product_concept : product_concept;
	related_product_concept : product_concept;
END_ENTITY; -- product_concept_relationship


ENTITY product;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	frame_of_reference : SET [1:?] OF product_context;
END_ENTITY; -- product


ENTITY product_category;
	name : label;
	description : OPTIONAL text;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- product_category


ENTITY product_category_relationship;
	name : label;
	description : OPTIONAL text;
	category : product_category;
	sub_category : product_category;
WHERE
	WR1 : acyclic_product_category_relationship(SELF, [SELF.sub_category]);
END_ENTITY; -- product_category_relationship


ENTITY product_definition;
	id : identifier;
	description : OPTIONAL text;
	formation : product_definition_formation;
	frame_of_reference : product_definition_context;
DERIVE
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
END_ENTITY; -- product_definition


ENTITY product_definition_context_association;
	definition : product_definition;
	frame_of_reference : product_definition_context;
	role : product_definition_context_role;
END_ENTITY; -- product_definition_context_association


ENTITY product_definition_context_role;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- product_definition_context_role


ENTITY product_definition_effectivity
	SUBTYPE OF (effectivity);
	usage : product_definition_relationship;
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'))= 0;
END_ENTITY; -- product_definition_effectivity


ENTITY product_definition_formation;
	id : identifier;
	description : OPTIONAL text;
	of_product : product;
UNIQUE
	UR1 : id, of_product;
END_ENTITY; -- product_definition_formation


ENTITY product_definition_formation_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition_formation : product_definition_formation;
	related_product_definition_formation : product_definition_formation;
END_ENTITY; -- product_definition_formation_relationship


ENTITY product_definition_formation_with_specified_source
	SUBTYPE OF (product_definition_formation);
	make_or_buy : source;
END_ENTITY; -- product_definition_formation_with_specified_source


ENTITY product_definition_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product_definition : product_definition;
	related_product_definition : product_definition;
END_ENTITY; -- product_definition_relationship


ENTITY product_definition_substitute;
	description : OPTIONAL text;
	context_relationship : product_definition_relationship;
	substitute_definition : product_definition;
DERIVE
	name : label := get_name_value(SELF);
WHERE
	WR1 : context_relationship.related_product_definition :<>: substitute_definition;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
END_ENTITY; -- product_definition_substitute


ENTITY product_definition_with_associated_documents
	SUBTYPE OF (product_definition);
	documentation_ids : SET [1:?] OF document;
END_ENTITY; -- product_definition_with_associated_documents


ENTITY product_related_product_category
	SUBTYPE OF (product_category);
	products : SET [1:?] OF product;
END_ENTITY; -- product_related_product_category


ENTITY product_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_product : product;
	related_product : product;
END_ENTITY; -- product_relationship


ENTITY characterized_object;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- characterized_object


ENTITY characterized_object_relationship;
	name : label;
	description : OPTIONAL text;
	relating_object : characterized_object;
	related_object : characterized_object;
END_ENTITY; -- characterized_object_relationship


ENTITY general_property;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- general_property


ENTITY general_property_association;
	name : label;
	description : OPTIONAL text;
	base_definition : general_property;
	derived_definition : derived_property_select;
WHERE
	WR1 : SIZEOF(USEDIN(derived_definition, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION'))= 1;
	WR2 : derived_definition.name = base_definition.name;
END_ENTITY; -- general_property_association


ENTITY general_property_relationship;
	name : label;
	description : OPTIONAL text;
	relating_property : general_property;
	related_property : general_property;
END_ENTITY; -- general_property_relationship


ENTITY product_definition_shape
	SUBTYPE OF (property_definition);
UNIQUE
	UR1 : definition;
WHERE
	WR1 : SIZEOF(['AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition))> 0;
END_ENTITY; -- product_definition_shape


ENTITY property_definition;
	name : label;
	description : OPTIONAL text;
	definition : characterized_definition;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- property_definition


ENTITY shape_aspect;
	name : label;
	description : OPTIONAL text;
	of_shape : product_definition_shape;
	product_definitional : LOGICAL;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- shape_aspect


ENTITY shape_aspect_relationship;
	name : label;
	description : OPTIONAL text;
	relating_shape_aspect : shape_aspect;
	related_shape_aspect : shape_aspect;
DERIVE
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))<= 1;
END_ENTITY; -- shape_aspect_relationship


ENTITY context_dependent_shape_representation;
	representation_relation : shape_representation_relationship;
	represented_product_relation : product_definition_shape;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP'
         IN TYPEOF(SELF.represented_product_relation.definition);
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
	WR3 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
END_ENTITY; -- context_dependent_shape_representation


ENTITY item_identified_representation_usage;
	name : label;
	description : OPTIONAL text;
	definition : represented_definition;
	used_representation : representation;
	identified_item : representation_item;
WHERE
	WR1 : SELF.used_representation IN 
       using_representations(SELF.identified_item);
END_ENTITY; -- item_identified_representation_usage


ENTITY property_definition_representation;
	definition : represented_definition;
	used_representation : representation;
DERIVE
	description : text := get_description_value(SELF);
	name : label := get_name_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))<= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                       'NAME_ATTRIBUTE.NAMED_ITEM'))<= 1;
END_ENTITY; -- property_definition_representation


ENTITY shape_definition_representation
	SUBTYPE OF (property_definition_representation);
WHERE
	WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN
       TYPEOF (SELF.definition))
       OR
      ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN
       TYPEOF(SELF.definition.definition));
	WR2 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SHAPE_REPRESENTATION' IN
       TYPEOF(SELF.used_representation);
END_ENTITY; -- shape_definition_representation


ENTITY shape_representation
	SUBTYPE OF (representation);
END_ENTITY; -- shape_representation


ENTITY shape_representation_relationship
	SUBTYPE OF (representation_relationship);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SHAPE_REPRESENTATION' IN
      (TYPEOF(SELF\representation_relationship.rep_1)+
        TYPEOF(SELF\representation_relationship.rep_2));
END_ENTITY; -- shape_representation_relationship


ENTITY alternate_product_relationship;
	name : label;
	definition : OPTIONAL text;
	alternate : product;
	base : product;
	basis : text;
UNIQUE
	UR1 : alternate, base;
WHERE
	WR1 : alternate :<>: base;
END_ENTITY; -- alternate_product_relationship


ENTITY assembly_component_usage
	SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence))
	SUBTYPE OF (product_definition_usage);
	reference_designator : OPTIONAL identifier;
END_ENTITY; -- assembly_component_usage


ENTITY assembly_component_usage_substitute;
	name : label;
	definition : OPTIONAL text;
	base : assembly_component_usage;
	substitute : assembly_component_usage;
UNIQUE
	UR1 : base, substitute;
WHERE
	WR1 : base.relating_product_definition :=:
       substitute.relating_product_definition;
	WR2 : base :<>: substitute;
END_ENTITY; -- assembly_component_usage_substitute


ENTITY assembly_component_usage_substitute_with_ranking
	SUBTYPE OF (assembly_component_usage_substitute);
	ranking : INTEGER;
	ranking_rationale : text;
END_ENTITY; -- assembly_component_usage_substitute_with_ranking


ENTITY make_from_usage_option
	SUBTYPE OF (product_definition_usage);
	ranking : INTEGER;
	ranking_rationale : text;
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT('NUMBER' IN TYPEOF(quantity.value_component)))
       OR(quantity.value_component > 0);
END_ENTITY; -- make_from_usage_option


ENTITY make_from_usage_option_group;
	members : SET [2:?] OF make_from_usage_option;
WHERE
	WR1 : SIZEOF(QUERY(example <* members |
       example.related_product_definition
       :=: members[1].related_product_definition))=SIZEOF(members);
END_ENTITY; -- make_from_usage_option_group


ENTITY next_assembly_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- next_assembly_usage_occurrence


ENTITY product_definition_occurrence_relationship;
	name : label;
	description : OPTIONAL text;
	occurrence : product_definition;
	occurrence_usage : assembly_component_usage;
WHERE
	WR1 : occurrence_usage.relating_product_definition :<>: 
       occurrence;
	WR2 : occurrence_usage.related_product_definition :<>: 
       occurrence;
	WR3 : occurrence.formation :=:
       occurrence_usage.related_product_definition.formation;
END_ENTITY; -- product_definition_occurrence_relationship


ENTITY product_definition_usage
	SUPERTYPE OF (ONEOF (make_from_usage_option, assembly_component_usage))
	SUBTYPE OF (product_definition_relationship);
UNIQUE
	UR1 : id, relating_product_definition, related_product_definition;
WHERE
	WR1 : acyclic_product_definition_relationship
        (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY; -- product_definition_usage


ENTITY promissory_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
END_ENTITY; -- promissory_usage_occurrence


ENTITY quantified_assembly_component_usage
	SUBTYPE OF (assembly_component_usage);
	quantity : measure_with_unit;
WHERE
	WR1 : (NOT('NUMBER' IN TYPEOF(quantity.value_component)))
       OR(quantity.value_component > 0);
END_ENTITY; -- quantified_assembly_component_usage


ENTITY specified_higher_usage_occurrence
	SUBTYPE OF (assembly_component_usage);
	upper_usage : assembly_component_usage;
	next_usage : next_assembly_usage_occurrence;
UNIQUE
	UR1 : upper_usage, next_usage;
WHERE
	WR1 : SELF :<>: upper_usage;
	WR2 : SELF\product_definition_relationship.relating_product_definition
       :=: upper_usage.relating_product_definition;
	WR3 : SELF\product_definition_relationship.related_product_definition
       :=: next_usage.related_product_definition;
	WR4 : (upper_usage.related_product_definition :=:
       next_usage.relating_product_definition)OR
      (SIZEOF(QUERY(pdr <* USEDIN(upper_usage.related_product_definition,
       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
       'RELATED_PRODUCT_DEFINITION')|
        pdr.relating_product_definition :=: 
        next_usage.relating_product_definition))= 1);
	WR5 : SIZEOF(['AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
       * TYPEOF(upper_usage))= 1;
END_ENTITY; -- specified_higher_usage_occurrence


ENTITY applied_organizational_project_assignment
	SUBTYPE OF (organizational_project_assignment);
	items : SET [1:?] OF project_item;
END_ENTITY; -- applied_organizational_project_assignment


ENTITY promissory_usage_in_product_concept_relationship
	SUBTYPE OF (configuration_item);
END_ENTITY; -- promissory_usage_in_product_concept_relationship


ENTITY qualification;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification


ENTITY qualification_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_qualification : qualification;
	related_qualification : qualification;
END_ENTITY; -- qualification_relationship


ENTITY qualification_type;
	id : identifier;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- qualification_type


ENTITY qualification_type_relationship;
	id : identifier;
	name : label;
	description : OPTIONAL text;
	relating_qualification_type : qualification_type;
	related_qualification_type : qualification_type;
END_ENTITY; -- qualification_type_relationship


ENTITY descriptive_representation_item
	SUBTYPE OF (representation_item);
	description : text;
END_ENTITY; -- descriptive_representation_item


ENTITY expanded_uncertainty
	SUBTYPE OF (standard_uncertainty);
	coverage_factor : REAL;
END_ENTITY; -- expanded_uncertainty


ENTITY measure_qualification;
	name : label;
	description : text;
	qualified_measure : measure_with_unit;
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 : SIZEOF(QUERY(temp <* qualifiers |
             'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp)))< 2;
END_ENTITY; -- measure_qualification


ENTITY measure_representation_item
	SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY; -- measure_representation_item


ENTITY precision_qualifier;
	precision_value : INTEGER;
END_ENTITY; -- precision_qualifier


ENTITY qualified_representation_item
	SUBTYPE OF (representation_item);
	qualifiers : SET [1:?] OF value_qualifier;
WHERE
	WR1 : SIZEOF(QUERY(temp <* qualifiers |
             'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRECISION_QUALIFIER'
             IN TYPEOF(temp)))< 2;
END_ENTITY; -- qualified_representation_item


ENTITY qualitative_uncertainty
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : text;
END_ENTITY; -- qualitative_uncertainty


ENTITY standard_uncertainty
	SUPERTYPE OF (expanded_uncertainty)
	SUBTYPE OF (uncertainty_qualifier);
	uncertainty_value : REAL;
END_ENTITY; -- standard_uncertainty


ENTITY type_qualifier;
	name : label;
END_ENTITY; -- type_qualifier


ENTITY uncertainty_qualifier
	SUPERTYPE OF (ONEOF (standard_uncertainty, qualitative_uncertainty));
	measure_name : label;
	description : text;
END_ENTITY; -- uncertainty_qualifier


ENTITY compound_representation_item
	SUBTYPE OF (representation_item);
	item_element : compound_item_definition;
END_ENTITY; -- compound_representation_item


ENTITY definitional_representation
	SUBTYPE OF (representation);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN
        TYPEOF(SELF\representation.context_of_items);
END_ENTITY; -- definitional_representation


ENTITY founded_item;
END_ENTITY; -- founded_item


ENTITY functionally_defined_transformation;
	name : label;
	description : OPTIONAL text;
END_ENTITY; -- functionally_defined_transformation


ENTITY global_uncertainty_assigned_context
	SUBTYPE OF (representation_context);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- global_uncertainty_assigned_context


ENTITY item_defined_transformation;
	name : label;
	description : OPTIONAL text;
	transform_item_1 : representation_item;
	transform_item_2 : representation_item;
END_ENTITY; -- item_defined_transformation


ENTITY mapped_item
	SUBTYPE OF (representation_item);
	mapping_source : representation_map;
	mapping_target : representation_item;
WHERE
	WR1 : acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY; -- mapped_item


ENTITY parametric_representation_context
	SUBTYPE OF (representation_context);
END_ENTITY; -- parametric_representation_context


ENTITY representation;
	name : label;
	items : SET [1:?] OF representation_item;
	context_of_items : representation_context;
DERIVE
	description : text := get_description_value(SELF);
	id : identifier := get_id_value(SELF);
WHERE
	WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
       <= 1;
	WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
       <= 1;
END_ENTITY; -- representation


ENTITY representation_context;
	context_identifier : identifier;
	context_type : text;
INVERSE
	representations_in_context: SET [1:?] OF representation FOR context_of_items;
END_ENTITY; -- representation_context


ENTITY representation_item;
	name : label;
WHERE
	WR1 : SIZEOF(using_representations(SELF))> 0;
END_ENTITY; -- representation_item


ENTITY representation_item_relationship;
	name : label;
	description : OPTIONAL text;
	relating_representation_item : representation_item;
	related_representation_item : representation_item;
END_ENTITY; -- representation_item_relationship


ENTITY representation_map;
	mapping_origin : representation_item;
	mapped_representation : representation;
INVERSE
	map_usage: SET [1:?] OF mapped_item FOR mapping_source;
WHERE
	WR1 : item_in_context(SELF.mapping_origin,
       SELF.mapped_representation.context_of_items);
END_ENTITY; -- representation_map


ENTITY representation_relationship;
	name : label;
	description : OPTIONAL text;
	rep_1 : representation;
	rep_2 : representation;
END_ENTITY; -- representation_relationship


ENTITY representation_relationship_with_transformation
	SUBTYPE OF (representation_relationship);
	transformation_operator : transformation;
WHERE
	WR1 : SELF\representation_relationship.rep_1.context_of_items
   :<>: SELF\representation_relationship.rep_2.context_of_items;
END_ENTITY; -- representation_relationship_with_transformation


ENTITY uncertainty_assigned_representation
	SUBTYPE OF (representation);
	uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY; -- uncertainty_assigned_representation


ENTITY uncertainty_measure_with_unit
	SUBTYPE OF (measure_with_unit);
	name : label;
	description : OPTIONAL text;
WHERE
	WR1 : valid_measure_value(SELF\measure_with_unit.value_component);
END_ENTITY; -- uncertainty_measure_with_unit


ENTITY value_representation_item
	SUBTYPE OF (representation_item);
	value_component : measure_value;
WHERE
	WR1 : SIZEOF(QUERY(rep <* using_representations(SELF)|
       NOT('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
       IN TYPEOF(rep.context_of_items)
      )))= 0;
END_ENTITY; -- value_representation_item


ENTITY assigned_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY; -- assigned_requirement


ENTITY requirement_assigned_object
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_assigned_item;
	SELF\group_assignment.assigned_group : requirement_assignment;
END_ENTITY; -- requirement_assigned_object


ENTITY requirement_assignment
	SUBTYPE OF (characterized_object, group);
END_ENTITY; -- requirement_assignment


ENTITY requirement_source
	SUBTYPE OF (group);
END_ENTITY; -- requirement_source


ENTITY source_for_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF requirement_source_item;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY; -- source_for_requirement


ENTITY sourced_requirement
	SUBTYPE OF (group_assignment);
	items : SET [1:1] OF product_definition;
	SELF\group_assignment.assigned_group : requirement_source;
END_ENTITY; -- sourced_requirement


ENTITY applied_security_classification_assignment
	SUBTYPE OF (security_classification_assignment);
	items : SET [1:?] OF security_classification_item;
END_ENTITY; -- applied_security_classification_assignment


ENTITY security_classification;
	name : label;
	purpose : text;
	security_level : security_classification_level;
END_ENTITY; -- security_classification


ENTITY security_classification_level;
	name : label;
END_ENTITY; -- security_classification_level


ENTITY composite_signal_property_relationship
	SUBTYPE OF (property_definition, property_definition_relationship);
WHERE
	WR1 : SELF\property_definition_relationship.related_property_definition.definition :<>:
       SELF\property_definition_relationship.relating_property_definition.definition;
END_ENTITY; -- composite_signal_property_relationship


ENTITY signal
	SUBTYPE OF (characterized_object);
END_ENTITY; -- signal


ENTITY signal_category
	SUBTYPE OF (group);
END_ENTITY; -- signal_category


ENTITY document_identifier
	SUBTYPE OF (group);
UNIQUE
	UR1 : name, description;
END_ENTITY; -- document_identifier


ENTITY document_identifier_assignment
	SUBTYPE OF (group_assignment);
	items : SET [1:?] OF document_identifier_assigned_item;
	SELF\group_assignment.assigned_group : document_identifier;
END_ENTITY; -- document_identifier_assignment


ENTITY partial_document_with_structured_text_representation_assignment
	SUBTYPE OF (applied_document_usage_constraint_assignment, characterized_object);
END_ENTITY; -- partial_document_with_structured_text_representation_assignment


ENTITY specification_definition
	SUBTYPE OF (product_definition);
END_ENTITY; -- specification_definition


ENTITY product_identification
	SUBTYPE OF (configuration_item, characterized_object);
	SELF\configuration_item.item_concept : product_class;
WHERE
	WR1 : SIZEOF(QUERY(cd <* USEDIN(SELF ,'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION')|
   ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'PRODUCT_DEFINITION_FORMATION' IN  TYPEOF(cd.design))AND 
  (SIZEOF(QUERY(prpc <* USEDIN(cd.design\product_definition_formation.of_product ,
     'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| 
         prpc.name IN ['part', 'raw material', 'tool']))>0
   )))<=1;
	WR2 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'CONFIGURABLE_ITEM' IN  TYPEOF(SELF))XOR 
  ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF(SELF));
END_ENTITY; -- product_identification


ENTITY product_specification
	SUBTYPE OF (product_identification, configurable_item);
END_ENTITY; -- product_specification


ENTITY included_text_block
	SUBTYPE OF (mapped_item);
WHERE
	WR1 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.STRUCTURED_TEXT_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation);
END_ENTITY; -- included_text_block


ENTITY structured_text_composition
	SUBTYPE OF (compound_representation_item);
END_ENTITY; -- structured_text_composition


ENTITY structured_text_representation
	SUBTYPE OF (representation);
	SELF\representation.items : SET [1:?] OF string_representation_item_select;
END_ENTITY; -- structured_text_representation


ENTITY tagged_text_format
	SUBTYPE OF (class, representation_context);
END_ENTITY; -- tagged_text_format


ENTITY tagged_text_item
	SUBTYPE OF (descriptive_representation_item);
END_ENTITY; -- tagged_text_item


ENTITY uniform_resource_indicator
	SUBTYPE OF (descriptive_representation_item);
END_ENTITY; -- uniform_resource_indicator


ENTITY applied_time_interval_assignment
	SUBTYPE OF (time_interval_assignment);
	items : SET [0:?] OF time_interval_item;
END_ENTITY; -- applied_time_interval_assignment


ENTITY closed_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY; -- closed_shell


ENTITY connected_edge_set
	SUBTYPE OF (topological_representation_item);
	ces_edges : SET [1:?] OF edge;
END_ENTITY; -- connected_edge_set


ENTITY connected_face_set
	SUPERTYPE OF (ONEOF (closed_shell, open_shell))
	SUBTYPE OF (topological_representation_item);
	cfs_faces : SET [1:?] OF face;
END_ENTITY; -- connected_face_set


ENTITY connected_face_sub_set
	SUBTYPE OF (connected_face_set);
	parent_face_set : connected_face_set;
END_ENTITY; -- connected_face_sub_set


ENTITY edge
	SUPERTYPE OF (ONEOF (edge_curve, oriented_edge, subedge))
	SUBTYPE OF (topological_representation_item);
	edge_start : vertex;
	edge_end : vertex;
END_ENTITY; -- edge


ENTITY edge_curve
	SUBTYPE OF (edge, geometric_representation_item);
	edge_geometry : curve;
	same_sense : BOOLEAN;
END_ENTITY; -- edge_curve


ENTITY edge_loop
	SUBTYPE OF (loop, path);
DERIVE
	ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
	WR1 : (SELF\path.edge_list[1].edge_start):=:
       (SELF\path.edge_list[ne].edge_end);
END_ENTITY; -- edge_loop


ENTITY face
	SUPERTYPE OF (ONEOF (face_surface, subface, oriented_face))
	SUBTYPE OF (topological_representation_item);
	bounds : SET [1:?] OF face_bound;
WHERE
	WR1 : NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
	WR2 : SIZEOF(QUERY(temp <* bounds | 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.FACE_OUTER_BOUND' IN
                                               TYPEOF(temp)))<= 1;
END_ENTITY; -- face


ENTITY face_bound
	SUBTYPE OF (topological_representation_item);
	bound : loop;
	orientation : BOOLEAN;
END_ENTITY; -- face_bound


ENTITY face_outer_bound
	SUBTYPE OF (face_bound);
END_ENTITY; -- face_outer_bound


ENTITY face_surface
	SUBTYPE OF (face, geometric_representation_item);
	face_geometry : surface;
	same_sense : BOOLEAN;
WHERE
	WR1 : NOT('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
END_ENTITY; -- face_surface


ENTITY loop
	SUPERTYPE OF (ONEOF (vertex_loop, edge_loop, poly_loop))
	SUBTYPE OF (topological_representation_item);
END_ENTITY; -- loop


ENTITY open_path
	SUBTYPE OF (path);
DERIVE
	ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
	WR1 : (SELF\path.edge_list[1].edge_element.edge_start):<>:
                      (SELF\path.edge_list[ne].edge_element.edge_end);
END_ENTITY; -- open_path


ENTITY open_shell
	SUBTYPE OF (connected_face_set);
END_ENTITY; -- open_shell


ENTITY oriented_closed_shell
	SUBTYPE OF (closed_shell);
	closed_shell_element : closed_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                   SELF.closed_shell_element.cfs_faces);
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_CLOSED_SHELL' 
                IN TYPEOF(SELF.closed_shell_element));
END_ENTITY; -- oriented_closed_shell


ENTITY oriented_edge
	SUBTYPE OF (edge);
	edge_element : edge;
	orientation : BOOLEAN;
DERIVE
	SELF\edge.edge_end : vertex := boolean_choose(SELF.orientation,
                                            SELF.edge_element.edge_end,
                                            SELF.edge_element.edge_start);
	SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation,
                                            SELF.edge_element.edge_start,
                                            SELF.edge_element.edge_end);
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element));
END_ENTITY; -- oriented_edge


ENTITY oriented_face
	SUBTYPE OF (face);
	face_element : face;
	orientation : BOOLEAN;
DERIVE
	SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_FACE' IN TYPEOF(SELF.face_element));
END_ENTITY; -- oriented_face


ENTITY oriented_open_shell
	SUBTYPE OF (open_shell);
	open_shell_element : open_shell;
	orientation : BOOLEAN;
DERIVE
	SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                      SELF.open_shell_element.cfs_faces);
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_OPEN_SHELL' 
                IN TYPEOF(SELF.open_shell_element));
END_ENTITY; -- oriented_open_shell


ENTITY oriented_path
	SUBTYPE OF (path);
	path_element : path;
	orientation : BOOLEAN;
DERIVE
	SELF\path.edge_list : LIST [1:?] OF  UNIQUE oriented_edge := conditional_reverse(SELF.orientation,
                                         SELF.path_element.edge_list);
WHERE
	WR1 : NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_PATH' IN TYPEOF(SELF.path_element));
END_ENTITY; -- oriented_path


ENTITY path
	SUPERTYPE OF (ONEOF (open_path, edge_loop, oriented_path))
	SUBTYPE OF (topological_representation_item);
	edge_list : LIST [1:?] OF  UNIQUE oriented_edge;
WHERE
	WR1 : path_head_to_tail(SELF);
END_ENTITY; -- path


ENTITY poly_loop
	SUBTYPE OF (loop, geometric_representation_item);
	polygon : LIST [3:?] OF  UNIQUE cartesian_point;
END_ENTITY; -- poly_loop


ENTITY seam_edge
	SUBTYPE OF (oriented_edge);
	pcurve_reference : pcurve;
WHERE
	WR1 : ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.EDGE_CURVE' IN  TYPEOF(edge_element))AND
               ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SEAM_CURVE' IN TYPEOF
                      (edge_element\edge_curve.edge_geometry));
	WR2 : pcurve_reference IN edge_element\edge_curve.edge_geometry\
                                 surface_curve.associated_geometry;
END_ENTITY; -- seam_edge


ENTITY subedge
	SUBTYPE OF (edge);
	parent_edge : edge;
END_ENTITY; -- subedge


ENTITY subface
	SUBTYPE OF (face);
	parent_face : face;
WHERE
	WR1 : NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))+
              list_to_set(list_face_loops(parent_face))));
END_ENTITY; -- subface


ENTITY topological_representation_item
	SUPERTYPE OF (ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set, (loop ANDOR path)))
	SUBTYPE OF (representation_item);
END_ENTITY; -- topological_representation_item


ENTITY vertex
	SUBTYPE OF (topological_representation_item);
END_ENTITY; -- vertex


ENTITY vertex_loop
	SUBTYPE OF (loop);
	loop_vertex : vertex;
END_ENTITY; -- vertex_loop


ENTITY vertex_point
	SUBTYPE OF (vertex, geometric_representation_item);
	vertex_geometry : point;
END_ENTITY; -- vertex_point


ENTITY vertex_shell
	SUBTYPE OF (topological_representation_item);
	vertex_shell_extent : vertex_loop;
END_ENTITY; -- vertex_shell


ENTITY wire_shell
	SUBTYPE OF (topological_representation_item);
	wire_shell_extent : SET [1:?] OF loop;
WHERE
	WR1 : NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY; -- wire_shell


ENTITY absorbed_dose_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\absorbed_dose_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = gray;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- absorbed_dose_measure_with_unit


ENTITY activity_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\activity_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = becquerel;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- activity_measure_with_unit


ENTITY capacitance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\capacitance_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = farad;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- capacitance_measure_with_unit


ENTITY conductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\conductance_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = siemens;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- conductance_measure_with_unit


ENTITY dose_equivalent_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\dose_equivalent_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = sievert;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- dose_equivalent_measure_with_unit


ENTITY electric_charge_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\electric_charge_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = coulomb;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- electric_charge_measure_with_unit


ENTITY electromotive_force_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\electromotive_force_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = volt;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- electromotive_force_measure_with_unit


ENTITY energy_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\energy_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = joule;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- energy_measure_with_unit


ENTITY expression_conversion_based_unit
	SUBTYPE OF (context_dependent_unit, variable_semantics);
INVERSE
	associated_variable_environment: environment FOR semantics;
END_ENTITY; -- expression_conversion_based_unit


ENTITY force_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\force_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = newton;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- force_measure_with_unit


ENTITY frequency_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\frequency_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = hertz;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- frequency_measure_with_unit


ENTITY illuminance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\illuminance_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = lux;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- illuminance_measure_with_unit


ENTITY inductance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\inductance_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = henry;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- inductance_measure_with_unit


ENTITY luminous_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\luminous_flux_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = lumen;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- luminous_flux_measure_with_unit


ENTITY magnetic_flux_density_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\magnetic_flux_density_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = tesla;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- magnetic_flux_density_measure_with_unit


ENTITY magnetic_flux_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\magnetic_flux_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = weber;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- magnetic_flux_measure_with_unit


ENTITY polar_complex_number_literal
	SUBTYPE OF (generic_literal);
	radius : REAL;
	angle : REAL;
WHERE
	WR1 : radius >= 0;
	WR2 : { 0 <= angle < 2*PI };
END_ENTITY; -- polar_complex_number_literal


ENTITY power_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\power_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = watt;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- power_measure_with_unit


ENTITY pressure_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\pressure_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = pascal;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- pressure_measure_with_unit


ENTITY resistance_measure_with_unit
	SUBTYPE OF (measure_with_unit);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||
       SELF\resistance_measure_with_unit)))= 0;
	WR2 : SELF\measure_with_unit.unit_component\si_unit.name = ohm;
	WR3 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SI_UNIT' IN 
       TYPEOF(SELF\measure_with_unit.unit_component);
	WR4 : 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.NUMERIC_MEASURE' IN 
       TYPEOF(SELF\measure_with_unit.value_component);
END_ENTITY; -- resistance_measure_with_unit


ENTITY scattering_parameter
	SUBTYPE OF (polar_complex_number_literal);
WHERE
	WR1 : SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\polar_complex_number_literal ||
       SELF\scattering_parameter)))= 0;
END_ENTITY; -- scattering_parameter


ENTITY applied_action_request_assignment
	SUBTYPE OF (action_request_assignment);
	items : SET [1:?] OF action_request_item;
END_ENTITY; -- applied_action_request_assignment


SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
	ONEOF (classification, complete_membership);
END_SUBTYPE_CONSTRAINT; -- classification_or_complete_membership

RULE restrict_classification_assignments FOR (applied_classification_assignment);
WHERE
	WR1 : SIZEOF(QUERY(aia <* applied_classification_assignment | 
		NOT class_assignment_is_valid(aia)))=0;
END_RULE; -- restrict_classification_assignments

RULE restrict_group_relationship_for_classification_hierarchy FOR (group_relationship);
WHERE
	WR1 : SIZEOF(QUERY(gr <* group_relationship | 
 (gr.name = 'class hierarchy')AND 
 (NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CLASS' IN  TYPEOF(gr.related_group))OR 
  NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CLASS' IN TYPEOF(gr.relating_group)))))= 0;
END_RULE; -- restrict_group_relationship_for_classification_hierarchy

RULE subtype_exclusiveness_representation_item FOR (representation_item);
WHERE
	WR1 : SIZEOF(QUERY(cri <* representation_item | NOT(type_check_function(cri,['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM','REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM','REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM'], 3))))= 0;
END_RULE; -- subtype_exclusiveness_representation_item

RULE compatible_dimension FOR (cartesian_point, direction, representation_context, geometric_representation_context);
WHERE
	WR1 : SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
      (y <* geometric_representation_context | item_in_context(x,y)AND
      (HIINDEX(x.coordinates)<> y.coordinate_space_dimension)))> 0))=0;
	WR2 : SIZEOF(QUERY(x <* direction | SIZEOF(QUERY
      (y <* geometric_representation_context | item_in_context(x,y)AND
      (HIINDEX(x.direction_ratios)<> y.coordinate_space_dimension)))
       > 0))= 0;
END_RULE; -- compatible_dimension

RULE restrict_language_assignment_per_attribute FOR (attribute_language_assignment);
WHERE
	WR1 : SIZEOF(QUERY(ala1 <* attribute_language_assignment |
	SIZEOF(QUERY(it <* ala1.items |
	   SIZEOF(QUERY(ala2 <* USEDIN(it ,'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')| 
		(ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name)AND 
		(ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class)
		))>1 
	  ))>0 
	))=0;
END_RULE; -- restrict_language_assignment_per_attribute

RULE restrict_part_occurrence FOR (product_definition);LOCAL

  part_occurrences: SET OF product_definition := [];

END_LOCAL
;

  part_occurrences := QUERY(pd <* product_definition | 
	(pd.frame_of_reference.name = 'part occurrence'));

WHERE
	WR1 : SIZEOF(QUERY(pd <* part_occurrences | 
	(NOT(pd.name IN 
['single instance', 'selected instance' ,'quantified instance', 'specified instance' ]))))= 0;
	WR2 : SIZEOF(QUERY(pd <* part_occurrences | 
 	(SIZEOF(QUERY(pdr <* USEDIN(pd ,
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| 
	pdr.name = 'definition usage'))<>1)AND  
	(SIZEOF(QUERY(cd <* USEDIN(pd, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN')| 
	(cd.name = 'occurrence usage definition')AND 
	(NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF(cd.configuration)))))<>1)))= 0;
	WR3 : SIZEOF(QUERY(pd <* part_occurrences |  
	(SIZEOF(QUERY(cd <* USEDIN(pd, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|
 	('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF(cd))))= 0)AND
 	(SIZEOF(USEDIN(pd, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE'))= 0)))= 0;
	WR4 : SIZEOF(QUERY(pd <* part_occurrences | 
	(pd.name = 'selected instance')AND 
	NOT valid_selected_instance_representation(pd)))=0;
	WR5 : SIZEOF(QUERY(pd <* part_occurrences | 
 	(pd.name = 'quantified instance')AND  
	(SIZEOF(QUERY (ppd <* USEDIN(pd, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +'PROPERTY_DEFINITION.DEFINITION')|
 	(ppd.name ='occurrence quantity')AND  
	(SIZEOF(QUERY(pdr <*USEDIN(ppd, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(
	pdr.used_representation.name = 'quantity')AND  
	(SIZEOF(pdr.used_representation.items)= 1)AND 
 	(SIZEOF(QUERY(i <* pdr.used_representation.items | 
	('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i))AND
	(i.name = 'quantity measure')))= 1)))= 1)))= 0)))= 0;
	WR6 : SIZEOF(QUERY(pd <* part_occurrences | 
	(pd.name = 'specified instance')AND 
	(SIZEOF(QUERY(
pdor <* USEDIN(pd, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE')| 
  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdor.occurrence_usage)))= 0)))= 0;
END_RULE; -- restrict_part_occurrence

RULE restrict_part_occurrence_category FOR (product_definition);LOCAL

  part_occurrences: SET OF product_definition := [];

END_LOCAL
;

  part_occurrences :=  QUERY(pd <* product_definition |(
		pd.frame_of_reference.name = 'part occurrence'));

WHERE
	WR1 : SIZEOF(QUERY(pd <* part_occurrences | 
(SIZEOF(QUERY(prpc <* USEDIN(pd.formation.of_product, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| 
  prpc.name IN ['part','raw material','tool']))= 0)))= 0;
END_RULE; -- restrict_part_occurrence_category

RULE restrict_product_definitions_for_definition_usage FOR (product_definition_relationship);
WHERE
	WR1 : SIZEOF(QUERY(pdr <* product_definition_relationship |
   (pdr.name = 'definition usage')AND 
	((pdr.relating_product_definition.frame_of_reference.name<> 'part definition')OR 
	(pdr.related_product_definition.frame_of_reference.name<>'part occurrence'))))=0;
END_RULE; -- restrict_product_definitions_for_definition_usage

RULE selected_instance_usage_requires_representation FOR (assembly_component_usage);LOCAL

  selected_instance_usages: SET OF assembly_component_usage := [];

END_LOCAL
;

  selected_instance_usages:=  QUERY(acr <* assembly_component_usage|
		(acr.name = 'selected instance usage'));

WHERE
	WR1 : SIZEOF(QUERY(acr <* selected_instance_usages | 
	NOT valid_selected_instance_representation(acr)))=0;
END_RULE; -- selected_instance_usage_requires_representation

RULE product_concept_feature_requires_category FOR (product_concept_feature);
WHERE
	WR1 : SIZEOF(QUERY(pcf <* product_concept_feature |
(SIZEOF(['AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf))= 0)AND  
(SIZEOF(QUERY(aga <* USEDIN(pcf, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS')| 
(aga.role.name = 'specification category member')AND 
('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(aga.assigned_group))))<>1)))= 0;
END_RULE; -- product_concept_feature_requires_category

RULE restrict_concept_feature_operator FOR (concept_feature_operator);
WHERE
	WR1 : SIZEOF(QUERY(cfo <* concept_feature_operator | NOT
	(cfo.name IN ['and', 'or', 'oneof', 'not', 'implication'])))= 0;
	WR2 : SIZEOF(QUERY(cfo <* concept_feature_operator |(cfo.name = 'implication')AND
(SIZEOF(QUERY (cfrwc <* USEDIN(cfo, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +
'CONDITIONAL_OPERATOR')| 
	SIZEOF(QUERY(ccf <* USEDIN(cfrwc, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION')| 
	NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(ccf))))>0))>0)))= 0;
	WR3 : SIZEOF(QUERY(cfo <* concept_feature_operator |(cfo.name = 'not')
AND(SIZEOF(QUERY(cfrwc <* USEDIN(cfo, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR')| 
	cfrwc.related_product_concept_feature :<>: cfrwc.relating_product_concept_feature))>0)))= 0;
END_RULE; -- restrict_concept_feature_operator

RULE restrict_group_relationship_for_specification_category FOR (group_relationship);
WHERE
	WR1 : SIZEOF(QUERY(gr <* group_relationship | 
 (gr.name = 'specification category hierarchy')AND 
 (NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN  TYPEOF(gr.related_group))
  OR NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group)))))= 0;
END_RULE; -- restrict_group_relationship_for_specification_category

RULE subtype_exclusive_measure_with_unit FOR (measure_with_unit);
WHERE
	WR1 : SIZEOF(QUERY(mwu <* measure_with_unit |
       NOT(SIZEOF([
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'ABSORBED_DOSE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'ACTIVITY_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'AREA_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'CAPACITANCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'CONDUCTANCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'DOSE_EQUIVALENT_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'ELECTRIC_CHARGE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'ELECTRIC_CURRENT_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'ELECTROMOTIVE_FORCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'ENERGY_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'FORCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'FREQUENCY_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'ILLUMINANCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'INDUCTANCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'LENGTH_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'LUMINOUS_FLUX_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'LUMINOUS_INTENSITY_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'MAGNETIC_FLUX_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'MASS_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'PLANE_ANGLE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'POWER_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'PRESSURE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'RATIO_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'RESISTANCE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'SOLID_ANGLE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'TIME_MEASURE_WITH_UNIT',
       'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
       'VOLUME_MEASURE_WITH_UNIT'] *
       TYPEOF(mwu))<= 1)))= 0;
END_RULE; -- subtype_exclusive_measure_with_unit

FUNCTION acyclic_action_method_relationship
	(relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF action_method_relationship;

    END_LOCAL
;


    IF  relation.relating_method IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD'))| specific_relation IN TYPEOF(am));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_action_method_relationship

FUNCTION acyclic_action_relationship
	(relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF action_relationship;

    END_LOCAL
;


    IF  relation.relating_action IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION'))| specific_relation IN TYPEOF(actn));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_action_relationship

FUNCTION acyclic_action_resource_relationship
	(relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF action_resource_relationship;

    END_LOCAL
;


    IF  relation.relating_resource IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE'))| specific_relation IN TYPEOF(ar));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_action_resource_relationship

FUNCTION acyclic_versioned_action_request_relationship
	(relation : versioned_action_request_relationship; relatives : SET [0:?] OF versioned_action_request; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF versioned_action_request_relationship;

    END_LOCAL
;


    IF  relation.relating_versioned_action_request IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST'))| specific_relation IN TYPEOF(varr));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_versioned_action_request_relationship

FUNCTION acyclic_approval_relationship
	(relation : approval_relationship; relatives : SET [1:?] OF approval; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF approval_relationship;

    END_LOCAL
;


    IF  relation.relating_approval IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL'))| specific_relation IN TYPEOF(app));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_approval_relationship

FUNCTION get_description_value
	(obj : description_attribute_select) : text;
LOCAL

    description_bag : BAG OF description_attribute :=(USEDIN(obj, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));

  END_LOCAL
;


  IF SIZEOF(description_bag)= 1 THEN
    RETURN (description_bag[1].attribute_value);

  ELSE
    RETURN(?);

  END_IF;
END_FUNCTION; -- get_description_value

FUNCTION get_id_value
	(obj : id_attribute_select) : identifier;
LOCAL

      id_bag : BAG OF id_attribute :=(USEDIN(obj, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));

END_LOCAL
;

IF SIZEOF(id_bag)= 1 THEN
      RETURN (id_bag[1].attribute_value);

ELSE
      RETURN(?);

END_IF;
END_FUNCTION; -- get_id_value

FUNCTION get_name_value
	(obj : name_attribute_select) : label;
LOCAL

    name_bag : BAG OF name_attribute :=(USEDIN(obj, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));

  END_LOCAL
;


  IF SIZEOF(name_bag)= 1 THEN
    RETURN (name_bag[1].attribute_value);

  ELSE
    RETURN(?);

  END_IF;
END_FUNCTION; -- get_name_value

FUNCTION get_role
	(obj : role_select) : object_role;
LOCAL

    role_bag : BAG OF role_association :=(USEDIN(obj, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));

  END_LOCAL
;


  IF SIZEOF(role_bag)= 1 THEN
    RETURN (role_bag[1].role);

  ELSE
    RETURN(?);

  END_IF;
END_FUNCTION; -- get_role

FUNCTION class_assignment_is_valid
	(aia : applied_classification_assignment) : BOOLEAN;
LOCAL

  item: classification_item;

  role: classification_role;

END_LOCAL
;


role:= aia.role;

IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +'CLASS_SYSTEM' IN  TYPEOF(aia.assigned_class))THEN
  IF(role.name <> 'class system membership')THEN
    RETURN(FALSE);

  END_IF;

  REPEAT  i:=LOINDEX(aia.items)TO  HIINDEX(aia.items);

    item:= aia.items[i];


    IF (SIZEOF(['AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0)THEN
-- item invalid IF  item does NOT  belong TO  the types that may have a class_system
	RETURN(FALSE);

    END_IF;

  END_REPEAT;

END_IF;


IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +'CHARACTERIZED_CLASS' IN  TYPEOF(aia.assigned_class))THEN
  IF	NOT(role.name IN ['definitional','non-definitional',''])THEN
    RETURN(FALSE);
 
  END_IF;


  REPEAT i:=LOINDEX(aia.items)TO  HIINDEX(aia.items);

    item:= aia.items[i];


    IF (SIZEOF(['AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0)THEN
-- item invalid IF item does NOT belong TO the types that may have a characterized_class
	RETURN(FALSE);

    END_IF;

  END_REPEAT;

END_IF;

RETURN(TRUE);
END_FUNCTION; -- class_assignment_is_valid

FUNCTION acyclic_contract_relationship
	(relation : contract_relationship; relatives : SET [1:?] OF contract; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF contract_relationship;

    END_LOCAL
;


    IF  relation.relating_contract IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT'))| specific_relation IN TYPEOF(cont));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_contract_relationship

FUNCTION acyclic_event_occurrence_relationship
	(relation : event_occurrence_relationship; relatives : SET [1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF event_occurrence_relationship;

    END_LOCAL
;


    IF  relation.relating_event IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT'))| specific_relation IN TYPEOF(evnt));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_event_occurrence_relationship

FUNCTION acyclic_time_interval_relationship
	(relation : time_interval_relationship; relatives : SET [1:?] OF time_interval; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF time_interval_relationship;

    END_LOCAL
;


    IF  relation.relating_time_interval IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL'))| specific_relation IN TYPEOF(ti));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_time_interval_relationship

FUNCTION leap_year
	(year : year_number) : BOOLEAN;
IF((((year MOD  4)= 0)AND((year MOD  100)<> 0))OR((year MOD 400)= 0))THEN
    RETURN (TRUE);

  ELSE
    RETURN(FALSE);

  END_IF;
END_FUNCTION; -- leap_year

FUNCTION valid_calendar_date
	(date : calendar_date) : LOGICAL;
CASE date.month_component OF
    1  : RETURN({ 1 <= date.day_component <= 31 });

    2  : BEGIN
           IF(leap_year(date.year_component))THEN
             RETURN({ 1 <= date.day_component <= 29 });

           ELSE
             RETURN({ 1 <= date.day_component <= 28 });

           END_IF;

         END;

    3  : RETURN({ 1 <= date.day_component <= 31 });

    4  : RETURN({ 1 <= date.day_component <= 30 });

    5  : RETURN({ 1 <= date.day_component <= 31 });

    6  : RETURN({ 1 <= date.day_component <= 30 });

    7  : RETURN({ 1 <= date.day_component <= 31 });

    8  : RETURN({ 1 <= date.day_component <= 31 });

    9  : RETURN({ 1 <= date.day_component <= 30 });

    10 : RETURN({ 1 <= date.day_component <= 31 });

    11 : RETURN({ 1 <= date.day_component <= 30 });

    12 : RETURN({ 1 <= date.day_component <= 31 });

  END_CASE;

  RETURN(FALSE);
END_FUNCTION; -- valid_calendar_date

FUNCTION valid_time
	(time : local_time) : BOOLEAN;
IF EXISTS(time.second_component)THEN
    RETURN (EXISTS(time.minute_component));

  ELSE
    RETURN(TRUE);

  END_IF;
END_FUNCTION; -- valid_time

FUNCTION acyclic_document_relationship
	(relation : document_relationship; relatives : SET [1:?] OF document; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF document_relationship;

    END_LOCAL
;


    IF  relation.relating_document IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT'))| specific_relation IN TYPEOF(doc));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_document_relationship

FUNCTION acyclic_effectivity_relationship
	(relation : effectivity_relationship; relatives : SET [1:?] OF effectivity; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF effectivity_relationship;

    END_LOCAL
;


    IF  relation.relating_effectivity IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY'))| specific_relation IN TYPEOF(eff));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_effectivity_relationship

FUNCTION acyclic_experience_relationship
	(relation : experience_relationship; relatives : SET [0:?] OF experience; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF experience_relationship;

    END_LOCAL
;


    IF  relation.relating_experience IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE'))| specific_relation IN TYPEOF(expr));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_experience_relationship

FUNCTION acyclic_experience_type_relationship
	(relation : experience_type_relationship; relatives : SET [0:?] OF experience_type; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF experience_type_relationship;

    END_LOCAL
;


    IF  relation.relating_experience_type IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE'))| specific_relation IN TYPEOF(exptyp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_experience_type_relationship

FUNCTION acyclic_representation_relationship
	(relation : representation_relationship; relatives : SET [1:?] OF representation; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF representation_relationship;

    END_LOCAL
;


    IF  relation.rep_1 IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(r <* bag_to_set(USEDIN(relation.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2'))| specific_relation IN TYPEOF(r));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_representation_relationship

FUNCTION value_range_wr1
	(agg : compound_item_definition) : BOOLEAN;
BEGIN
IF(SIZEOF(agg)= 2)AND((SIZEOF(QUERY(i1 <* agg |(
'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF
(i1))))= 2)OR
(SIZEOF(QUERY(i2 <* agg |(
'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF
(i2))))= 2))THEN
RETURN(TRUE);

ELSE
RETURN(FALSE);

END_IF;

END;
END_FUNCTION; -- value_range_wr1

FUNCTION value_range_wr2
	(agg : compound_item_definition) : BOOLEAN;
BEGIN
IF(SIZEOF(QUERY(i <* agg |(i.name = 'upper limit')))= 1)
AND(SIZEOF(QUERY(i <* agg |(i.name = 'lower limit')))= 1)
THEN
RETURN(TRUE);

ELSE
RETURN(FALSE);

END_IF;

END;
END_FUNCTION; -- value_range_wr2

FUNCTION value_range_wr3
	(agg : compound_item_definition) : BOOLEAN;
BEGIN
IF(SIZEOF(QUERY(i1 <* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF (i1))AND
(SIZEOF(QUERY(i2 <* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i2))AND
(i1 :<>: i2)AND(i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component)))= 1)))= 2)
THEN
RETURN(TRUE);

ELSE
RETURN(FALSE);

END_IF;

END;
END_FUNCTION; -- value_range_wr3

FUNCTION acyclic_external_source_relationship
	(relation : external_source_relationship; relatives : SET [1:?] OF external_source; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF external_source_relationship;

    END_LOCAL
;


    IF  relation.relating_source IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE'))| specific_relation IN TYPEOF(es));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_external_source_relationship

FUNCTION acyclic_externally_defined_item_relationship
	(relation : externally_defined_item_relationship; relatives : SET [1:?] OF externally_defined_item; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF externally_defined_item_relationship;

    END_LOCAL
;


    IF  relation.relating_item IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM'))| specific_relation IN TYPEOF(edi));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_externally_defined_item_relationship

FUNCTION acyclic_set_replica
	(rep : geometric_set_replica; parent : geometric_set) : BOOLEAN;
IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA')IN TYPEOF(parent))
        THEN  RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE geometric_set_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same geometric_set_replica,
     otherwise, call FUNCTION again WITH the parents own parent_set. *)
    ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));

    END_IF;
END_FUNCTION; -- acyclic_set_replica

FUNCTION acyclic_solid_replica
	(rep : solid_replica; parent : solid_model) : BOOLEAN;
IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE solid_replica.*)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same solid_replica, otherwise,
   call FUNCTION again WITH the parents own parent_solid.    *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));

    END_IF;
END_FUNCTION; -- acyclic_solid_replica

FUNCTION build_transformed_set
	(tr : cartesian_transformation_operator; gset : geometric_set) : SET [0:?] OF geometric_set_select;
LOCAL

   s          : SET  [1:?] OF  geometric_set_select := gset.elements;

   trset      : SET [0:?] OF geometric_set_select := [];

  END_LOCAL
;

  REPEAT j := 1 TO SIZEOF(s);

    IF ('GEOMETRY_SCHEMA.CURVE' IN  TYPEOF(s[j]))THEN
     trset := trset + dummy_gri || curve()||curve_replica(s[j],tr);
 ELSE
     IF ('GEOMETRY_SCHEMA.POINT' IN  TYPEOF(s[j]))THEN
       trset := trset + dummy_gri || point()|| point_replica(s[j],tr);

       ELSE
       IF('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j]))THEN
         trset := trset + dummy_gri || surface() || surface_replica(s[j],
           tr || cartesian_transformation_operator_3d(?));

       END_IF;

     END_IF;

    END_IF;

  END_REPEAT;

  RETURN(trset);
END_FUNCTION; -- build_transformed_set

FUNCTION constraints_geometry_shell_based_surface_model
	(m : shell_based_surface_model) : BOOLEAN;
LOCAL

     result : BOOLEAN := TRUE;

   END_LOCAL
;

   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);

     IF(NOT('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j]))AND
       (NOT('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;

       RETURN(result);

      (* A surface model is composed OF OPEN_ AND CLOSED_SHELLs.*)
     END_IF;

   END_REPEAT;

   RETURN(result);
END_FUNCTION; -- constraints_geometry_shell_based_surface_model

FUNCTION constraints_geometry_shell_based_wireframe_model
	(m : shell_based_wireframe_model) : BOOLEAN;
LOCAL

     result : BOOLEAN := TRUE;

   END_LOCAL
;


   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);

     IF(NOT('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j]))AND
       (NOT('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;

       RETURN(result);

      (* A wireframe model is composed OF WIRE_ AND VERTEX_SHELLs *)
     END_IF;

   END_REPEAT;

   RETURN(result);
END_FUNCTION; -- constraints_geometry_shell_based_wireframe_model

FUNCTION msb_shells
	(brep : manifold_solid_brep) : SET [1:?] OF closed_shell;
IF SIZEOF(QUERY(msbtype <* TYPEOF(brep)|
       msbtype LIKE '*BREP_WITH_VOIDS'))>= 1 THEN
       RETURN(brep\brep_with_voids.voids + brep.outer);

     ELSE
       RETURN([brep.outer]);

     END_IF;
END_FUNCTION; -- msb_shells

FUNCTION above_plane
	(p1 : cartesian_point; p2 : cartesian_point; p3 : cartesian_point; p4 : cartesian_point) : REAL;
LOCAL

     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);

     val, mag         : REAL;

   END_LOCAL
;


   IF(p1.dim <> 3)THEN
     RETURN(?);

   END_IF;

   REPEAT i := 1 TO 3;

     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];

     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];

     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];

     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];

  END_REPEAT;

  mag := sqrt(mag);

  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);

  RETURN(val);
END_FUNCTION; -- above_plane

FUNCTION acyclic_curve_replica
	(rep : curve_replica; parent : curve) : BOOLEAN;
IF NOT (('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CURVE_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE curve_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same curve_replica, otherwise,
   call FUNCTION again WITH the parents own parent_curve.    *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));

    END_IF;
END_FUNCTION; -- acyclic_curve_replica

FUNCTION acyclic_point_replica
	(rep : point_replica; parent : point) : BOOLEAN;
IF NOT (('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.POINT_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE point_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same point_replica, otherwise,
   call FUNCTION again WITH the parents own parent_pt.    *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));

    END_IF;
END_FUNCTION; -- acyclic_point_replica

FUNCTION acyclic_surface_replica
	(rep : surface_replica; parent : surface) : BOOLEAN;
IF NOT (('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SURFACE_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE surface_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same surface_replica, otherwise,
   call FUNCTION again WITH the parents own parent_surface.    *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));

    END_IF;
END_FUNCTION; -- acyclic_surface_replica

FUNCTION associated_surface
	(arg : pcurve_or_surface) : surface;
LOCAL

     surf : surface;

   END_LOCAL
;

   
   IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN TYPEOF(arg)THEN
     surf := arg.basis_surface;

   ELSE
     surf := arg;

   END_IF;

   RETURN(surf);
END_FUNCTION; -- associated_surface

FUNCTION base_axis
	(dim : INTEGER; axis1 : direction; axis2 : direction; axis3 : direction) : LIST [2:3] OF direction;
LOCAL

    u      : LIST [2:3] OF direction;

    factor : REAL;

    d1, d2 : direction;

  END_LOCAL
;

  
  IF (dim = 3)THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));

    d2 := first_proj_axis(d1,axis1);

    u := [d2, second_proj_axis(d1,d2,axis2), d1];

  ELSE
     IF  EXISTS(axis1)THEN
      d1 := normalise(axis1);

      u := [d1, orthogonal_complement(d1)];

      IF  EXISTS(axis2)THEN
        factor := dot_product(axis2,u[2]);

        IF (factor < 0.0)THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];

          u[2].direction_ratios[2] := -u[2].direction_ratios[2];

        END_IF;

      END_IF;

    ELSE
      IF EXISTS(axis2)THEN
        d1 := normalise(axis2);

        u := [orthogonal_complement(d1), d1];
 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];

        u[1].direction_ratios[2] := -u[1].direction_ratios[2];

      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];

      END_IF;

    END_IF;

  END_IF;

  RETURN(u);
END_FUNCTION; -- base_axis

FUNCTION build_2axes
	(ref_direction : direction) : LIST [2:2] OF direction;
LOCAL

     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));

   END_LOCAL
;


   RETURN([d, orthogonal_complement(d)]);
END_FUNCTION; -- build_2axes

FUNCTION build_axes
	(axis : direction; ref_direction : direction) : LIST [3:3] OF direction;
LOCAL

     d1, d2 : direction;

   END_LOCAL
;

  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));

  d2 := first_proj_axis(d1, ref_direction);

  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);
END_FUNCTION; -- build_axes

FUNCTION constraints_composite_curve_on_surface
	(c : composite_curve_on_surface) : BOOLEAN;
LOCAL

     n_segments : INTEGER := SIZEOF(c.segments);

   END_LOCAL
;

        
   REPEAT k := 1 TO n_segments;

     IF(NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN  
           TYPEOF(c\composite_curve.segments[k].parent_curve)))AND
       (NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve)))AND
       (NOT('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
       RETURN(FALSE);

     END_IF;

   END_REPEAT;

   RETURN(TRUE);
END_FUNCTION; -- constraints_composite_curve_on_surface

FUNCTION constraints_param_b_spline
	(degree : INTEGER; up_knots : INTEGER; up_cp : INTEGER; knot_mult : LIST [0:?] OF INTEGER; knots : LIST [0:?] OF parameter_value) : BOOLEAN;
LOCAL

     result  : BOOLEAN := TRUE;

     k, sum  : INTEGER;

   END_LOCAL
;

   
  (* Find sum OF knot multiplicities.*)
   sum := knot_mult[1];

   
   REPEAT  i := 2 TO  up_knots;

     sum := sum + knot_mult[i];

   END_REPEAT;

   
  (* Check limits holding FOR all B-spline parametrisations *)
   IF (degree < 1)OR (up_knots < 2)OR (up_cp < degree)OR
        (sum <>(degree + up_cp + 2))THEN
     result := FALSE;

     RETURN(result);

   END_IF;

   
   k := knot_mult[1];

   
   IF (k < 1)OR (k > degree + 1)THEN
     result := FALSE;

     RETURN(result);

   END_IF;

      
   REPEAT i := 2 TO up_knots;

     IF (knot_mult[i] < 1)OR(knots[i] <= knots[i-1])THEN
       result := FALSE;

       RETURN(result);

     END_IF;

        
     k := knot_mult[i];

     
     IF (i < up_knots)AND (k > degree)THEN
       result := FALSE;

       RETURN(result);

     END_IF;

        
     IF(i = up_knots)AND(k > degree + 1)THEN
       result := FALSE;

       RETURN(result);

     END_IF;

   END_REPEAT;

   RETURN(result);
END_FUNCTION; -- constraints_param_b_spline

FUNCTION constraints_rectangular_composite_surface
	(s : rectangular_composite_surface) : BOOLEAN;
REPEAT i := 1 TO  s.n_u;

       REPEAT  j := 1 TO  s.n_v;

         IF  NOT(('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.B_SPLINE_SURFACE' IN  TYPEOF
                   (s.segments[i][j].parent_surface))OR
                ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                   (s.segments[i][j].parent_surface)))THEN
           RETURN(FALSE);

       END_IF;

     END_REPEAT;

   END_REPEAT;


  (* Check the transition codes, omitting the last row OR column *)
   REPEAT  i := 1 TO  s.n_u-1;

     REPEAT  j := 1 TO  s.n_v;

       IF  s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);

       END_IF;

     END_REPEAT;

   END_REPEAT;

   
   REPEAT  i := 1 TO  s.n_u;

     REPEAT j := 1 TO s.n_v-1;

       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);

       END_IF;

     END_REPEAT;

   END_REPEAT;

   RETURN(TRUE);
END_FUNCTION; -- constraints_rectangular_composite_surface

FUNCTION cross_product
	(arg1 : direction; arg2 : direction) : vector;
LOCAL

    mag    : REAL;

    res    : direction;

    v1,v2  : LIST[3:3] OF REAL;

    result : vector;

  END_LOCAL
;

  
  IF(NOT  EXISTS (arg1)OR (arg1.dim = 2))OR
   (NOT EXISTS(arg2)OR(arg2.dim = 2))THEN
    RETURN(?);

  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;

      v2  := normalise(arg2).direction_ratios;

      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
           (v1[3]*v2[1] - v1[1]*v2[3]),(v1[1]*v2[2] - v1[2]*v2[1])]);

      mag := 0.0;

      REPEAT i := 1 TO 3;

        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];

      END_REPEAT;

      IF(mag > 0.0)THEN
        result := dummy_gri || vector(res, SQRT(mag));

      ELSE
        result := dummy_gri || vector(arg1, 0.0);

      END_IF;

      RETURN(result);

    END;

  END_IF;
END_FUNCTION; -- cross_product

FUNCTION curve_weights_positive
	(b : rational_b_spline_curve) : BOOLEAN;
LOCAL

     result : BOOLEAN := TRUE;

   END_LOCAL
;


   REPEAT i := 0 TO b.upper_index_on_control_points;

     IF b.weights[i] <= 0.0  THEN
       result := FALSE;

       RETURN(result);

     END_IF;

   END_REPEAT;

   RETURN(result);
END_FUNCTION; -- curve_weights_positive

FUNCTION default_b_spline_curve_weights
	(up_cp : INTEGER) : ARRAY [0:up_cp] OF REAL;
RETURN([1:up_cp + 1]);
END_FUNCTION; -- default_b_spline_curve_weights

FUNCTION default_b_spline_knot_mult
	(degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST [2:?] OF INTEGER;
LOCAL

     knot_mult : LIST [1:up_knots] OF INTEGER;

   END_LOCAL
;

        
   IF  uniform = uniform_knots THEN
     knot_mult := [1:up_knots];

   ELSE
     IF  uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];

       knot_mult[1] := degree + 1;

       knot_mult[up_knots] := degree + 1;

     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];

         knot_mult[1] := degree + 1;

         knot_mult[up_knots] := degree + 1;

       ELSE
         knot_mult := [0:up_knots];

       END_IF;

     END_IF;

   END_IF;

   RETURN(knot_mult);
END_FUNCTION; -- default_b_spline_knot_mult

FUNCTION default_b_spline_knots
	(degree : INTEGER; up_knots : INTEGER; uniform : knot_type) : LIST [2:?] OF parameter_value;
LOCAL

    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];

    ishift : INTEGER := 1;

  END_LOCAL
;


  IF (uniform = uniform_knots)THEN
     ishift := degree + 1;

  END_if;

  IF(uniform = uniform_knots)OR 
    (uniform = quasi_uniform_knots)OR
    (uniform = piecewise_bezier_knots)THEN
    
    REPEAT i := 1 TO up_knots;

      knots[i] := i - ishift;

    END_REPEAT;

  END_IF;

  RETURN(knots);
END_FUNCTION; -- default_b_spline_knots

FUNCTION default_b_spline_surface_weights
	(u_upper : INTEGER; v_upper : INTEGER) : ARRAY [0:u_upper] OF ARRAY [0:v_upper] OF REAL;
RETURN([[1:v_upper + 1]:u_upper +1]);
END_FUNCTION; -- default_b_spline_surface_weights

FUNCTION dimension_of
	(item : geometric_representation_item) : dimension_count;
LOCAL

    x   : SET  OF  representation;

    y   : representation_context;

    dim : dimension_count;

  END_LOCAL
;

  -- FOR  cartesian_point, direction, OR vector dimension is determined by
  -- counting components.
    IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(item)THEN
       dim := SIZEOF(item\cartesian_point.coordinates);

       RETURN(dim);

    END_IF;

    IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.DIRECTION' IN  TYPEOF(item)THEN
       dim := SIZEOF(item\direction.direction_ratios);

       RETURN(dim);

    END_IF;

    IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN  TYPEOF(item)THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);

       RETURN(dim);

    END_IF;

  -- FOR  all other types OF  geometric_representation_item dim is obtained
  -- via context.
  -- Find the SET  OF  representation IN which the item is used.

  x := using_representations(item);


  -- Determines the dimension_count OF  the 
  -- geometric_representation_context.Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is OF  TYPE geometric_representation_context AND has
  -- the same dimension_count FOR all values OF x.
  -- The SET x is non-empty since this is required BY WR1 of
  -- representation_item.
    y := x[1].context_of_items;

    dim := y\geometric_representation_context.coordinate_space_dimension;

    RETURN(dim);
END_FUNCTION; -- dimension_of

FUNCTION dot_product
	(arg1 : direction; arg2 : direction) : REAL;
LOCAL

     scalar : REAL;

     vec1, vec2: direction;

     ndim : INTEGER;

   END_LOCAL
;

   
   IF  NOT  EXISTS (arg1)OR NOT EXISTS(arg2)THEN
     scalar := ?;

    (* When FUNCTION  is called WITH  invalid data an indeterminate result
     is RETURNed *)
   ELSE
     IF(arg1.dim <> arg2.dim)THEN
       scalar := ?;

    (* When FUNCTION is called WITH invalid data an indeterminate result
     is RETURNed *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);

         vec2   := normalise(arg2);

         ndim   := arg1.dim;

         scalar := 0.0;

         REPEAT  i := 1 TO ndim;

           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];

         END_REPEAT;

       END;

     END_IF;

   END_IF;

   RETURN(scalar);
END_FUNCTION; -- dot_product

FUNCTION first_proj_axis
	(z_axis : direction; arg : direction) : direction;
LOCAL

    x_axis : direction;

    v      : direction;

    z      : direction;

    x_vec  : vector;

  END_LOCAL
;

  
  IF (NOT EXISTS(z_axis))THEN
    RETURN (?);

  ELSE
    z := normalise(z_axis);

    IF  NOT EXISTS(arg)THEN
      IF ((z.direction_ratios <> [1.0,0.0,0.0])AND
         (z.direction_ratios <> [-1.0,0.0,0.0])) THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);

      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);

      END_IF;

    ELSE
      IF  (arg.dim <> 3)THEN
        RETURN (?);

      END_IF;

      IF((cross_product(arg,z).magnitude)= 0.0)THEN
        RETURN(?);

      ELSE
        v := normalise(arg);

      END_IF;

    END_IF;

    x_vec := scalar_times_vector(dot_product(v, z), z);

    x_axis := vector_difference(v, x_vec).orientation;

    x_axis := normalise(x_axis);

  END_IF;

  RETURN(x_axis);
END_FUNCTION; -- first_proj_axis

FUNCTION get_basis_surface
	(c : curve_on_surface) : SET [0:2] OF surface;
LOCAL

    surfs  : SET[0:2] OF  surface;

    n      : INTEGER;

  END_LOCAL
;

  surfs := [];

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PCURVE' IN  TYPEOF (c)THEN
    surfs := [c\pcurve.basis_surface];

  ELSE
    IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SURFACE_CURVE' IN  TYPEOF (c)THEN
      n := SIZEOF(c\surface_curve.associated_geometry);

      REPEAT  i := 1 TO  n;

      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);

      END_REPEAT;

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)THEN
  (* FOR a composite_curve_on_surface the basis_surface is the intersection
    OF  the basis_surfaces OF all the segments.*)
     n := SIZEOF(c\composite_curve.segments);

     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);

     IF n > 1 THEN
       REPEAT i := 2 TO n;

         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);

       END_REPEAT;

     END_IF;


  END_IF;

  RETURN(surfs);
END_FUNCTION; -- get_basis_surface

FUNCTION list_to_array
	(lis : LIST [0:?] OF GENERIC; low : INTEGER; u : INTEGER) : ARRAY [low:u] OF GENERIC;
LOCAL

     n   : INTEGER;

     res : ARRAY [low:u] OF GENERIC : T;

   END_LOCAL
;

      
   n := SIZEOF(lis);

   IF(n <>(u-low +1))THEN
     RETURN(?);

   ELSE
     res := [lis[1] : n];

     REPEAT i := 2 TO n;

       res[low+i-1] := lis[i];

     END_REPEAT;

     RETURN(res);

   END_IF;
END_FUNCTION; -- list_to_array

FUNCTION make_array_of_array
	(lis : LIST [1:?] OF LIST [1:?] OF GENERIC; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER) : ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC;
LOCAL

     res   : ARRAY[low1:u1] OF  ARRAY [low2:u2] OF GENERIC : T;

   END_LOCAL
;


(* Check input dimensions FOR consistency *)
   IF (u1-low1+1)<> SIZEOF(lis)THEN
     RETURN (?);

   END_IF;

   IF (u2 - low2 + 1)<> SIZEOF(lis[1])THEN
     RETURN (?);

   END_IF;

(* Initialise res WITH values FROM lis[1] *)
   res := [list_to_array(lis[1], low2, u2):(u1-low1 + 1)];

   REPEAT i := 2 TO HIINDEX(lis);

     IF(u2-low2+1)<> SIZEOF(lis[i])THEN
       RETURN (?);

     END_IF;
     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);

   END_REPEAT;
 
   
   RETURN(res);
END_FUNCTION; -- make_array_of_array

FUNCTION make_array_of_array_of_array
	(lis : LIST [1:?] OF LIST [1:?] OF LIST [1:?] OF GENERIC; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER; low3 : INTEGER; u3 : INTEGER) : ARRAY [low1:u1] OF ARRAY [low2:u2] OF ARRAY [low3:u3] OF GENERIC;
LOCAL
 
   res   : ARRAY[low1:u1] OF  ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;

 END_LOCAL
;
                

(* Check input dimensions FOR consistency *)
   IF (u1-low1+1)<> SIZEOF(lis)THEN
     RETURN (?);

   END_IF;

   IF (u2-low2+1)<> SIZEOF(lis[1])THEN
     RETURN (?);

   END_IF;

(* Initialise res WITH values FROM lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3):(u1-low1 + 1)];

   REPEAT i := 2 TO HIINDEX(lis);

     IF(u2-low2+1)<> SIZEOF(lis[i])THEN
       RETURN (?);

     END_IF;
  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);

   END_REPEAT;
 
   RETURN(res);
END_FUNCTION; -- make_array_of_array_of_array

FUNCTION normalise
	(arg : vector_or_direction) : vector_or_direction;
LOCAL

     ndim   : INTEGER;

     v      : direction;

     result : vector_or_direction;

     vec    : vector;

     mag    : REAL;

   END_LOCAL
;

   
   IF  NOT EXISTS(arg)THEN
     result := ?;

(* When FUNCTION is called WITH invalid data a NULL result is RETURNed *)
   ELSE
     ndim := arg.dim;

     IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN  TYPEOF(arg)THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);

         IF  arg.magnitude = 0.0 THEN
           RETURN(?);

         ELSE
          vec := dummy_gri || vector(v, 1.0);

         END_IF;

       END;

     ELSE
       v := dummy_gri || direction(arg.direction_ratios);

     END_IF;

     mag := 0.0;

     REPEAT   i := 1 TO  ndim;

       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];

     END_REPEAT;

     IF  mag > 0.0 THEN
       mag := SQRT(mag);

       REPEAT  i := 1 TO ndim;

         v.direction_ratios[i] := v.direction_ratios[i]/mag;

       END_REPEAT;

       IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN TYPEOF(arg)THEN
         vec.orientation := v;

         result := vec;

       ELSE
         result := v;

       END_IF;

     ELSE
       RETURN(?);

     END_IF;

   END_IF;

   RETURN(result);
END_FUNCTION; -- normalise

FUNCTION orthogonal_complement
	(vec : direction) : direction;
LOCAL

     result :  direction ;

   END_LOCAL
;


   IF(vec.dim <> 2)OR NOT EXISTS(vec)THEN
     RETURN(?);

   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);

     RETURN(result);

   END_IF;
END_FUNCTION; -- orthogonal_complement

FUNCTION same_side
	(plane_pts : LIST [3:3] OF cartesian_point; test_points : LIST [2:?] OF cartesian_point) : BOOLEAN;
LOCAL

     val1, val2 : REAL;

     n          : INTEGER;

   END_LOCAL
;


   IF (plane_pts[1].dim = 2)OR(test_points[1].dim = 2)THEN
     RETURN(?);

   END_IF;

   n := SIZEOF(test_points);

   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1]);

   REPEAT i := 2 TO n;

     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i]);

     IF(val1*val2 <= 0.0)THEN
       RETURN(FALSE);

     END_IF;

   END_REPEAT;

   RETURN(TRUE);
END_FUNCTION; -- same_side

FUNCTION scalar_times_vector
	(scalar : REAL; vec : vector_or_direction) : vector;
LOCAL

     v      : direction;

     mag    : REAL;

     result : vector;

   END_LOCAL
;


   IF  NOT  EXISTS (scalar)OR NOT EXISTS(vec)THEN
     RETURN (?);

    ELSE
     IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN TYPEOF(vec)THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);

       mag := scalar * vec.magnitude;

     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);

       mag := scalar;

     END_IF;

     IF(mag < 0.0)THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);

         v.direction_ratios[i] := -v.direction_ratios[i];

       END_REPEAT;

       mag := -mag;

     END_IF;

     result := dummy_gri || vector(normalise(v), mag);

   END_IF;

   RETURN(result);
END_FUNCTION; -- scalar_times_vector

FUNCTION second_proj_axis
	(z_axis : direction; x_axis : direction; arg : direction) : direction;
LOCAL

     y_axis : vector;

     v      : direction;

     temp   : vector;

   END_LOCAL
;

   
   IF NOT EXISTS(arg)THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);

   ELSE
     v := arg;

   END_IF;

   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);

   y_axis := vector_difference(v, temp);

   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);

   y_axis := vector_difference(y_axis, temp);

   y_axis := normalise(y_axis);

   RETURN(y_axis.orientation);
END_FUNCTION; -- second_proj_axis

FUNCTION surface_weights_positive
	(b : rational_b_spline_surface) : BOOLEAN;
LOCAL

     result        : BOOLEAN := TRUE;

   END_LOCAL
;

   
   REPEAT  i := 0 TO  b.u_upper;

     REPEAT j := 0 TO b.v_upper;

       IF(b.weights[i][j] <= 0.0) THEN
         result := FALSE;

         RETURN(result);

       END_IF;

     END_REPEAT;

   END_REPEAT;

   RETURN(result);
END_FUNCTION; -- surface_weights_positive

FUNCTION vector_difference
	(arg1 : vector_or_direction; arg2 : vector_or_direction) : vector;
LOCAL

     result          : vector;

     res, vec1, vec2 : direction;

     mag, mag1, mag2 : REAL;

     ndim            : INTEGER;

   END_LOCAL
;


   IF ((NOT EXISTS (arg1))OR (NOT EXISTS(arg2)))OR(arg1.dim <> arg2.dim)
       THEN
     RETURN (?);

    ELSE
     BEGIN
       IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN
         mag1 := arg1.magnitude;

         vec1 := arg1.orientation;

       ELSE
         mag1 := 1.0;

         vec1 := arg1;

       END_IF;

       IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN
         mag2 := arg2.magnitude;

         vec2 := arg2.orientation;

       ELSE
         mag2 := 1.0;

         vec2 := arg2;

       END_IF;

       vec1 := normalise(vec1);

       vec2 := normalise(vec2);

       ndim := SIZEOF(vec1.direction_ratios);

       mag := 0.0;

       res := dummy_gri || direction(vec1.direction_ratios);

       REPEAT i := 1 TO ndim;

         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];

         mag := mag +(res.direction_ratios[i]*res.direction_ratios[i]);

       END_REPEAT;

       IF(mag > 0.0)THEN
       result := dummy_gri || vector(res, SQRT(mag));

       ELSE
         result := dummy_gri || vector(vec1,  0.0);

       END_IF;

     END;

   END_IF;

   RETURN(result);
END_FUNCTION; -- vector_difference

FUNCTION vector_sum
	(arg1 : vector_or_direction; arg2 : vector_or_direction) : vector;
LOCAL

     result          : vector;

     res, vec1, vec2 : direction;

     mag, mag1, mag2 : REAL;

     ndim            : INTEGER;

   END_LOCAL
;


   IF ((NOT EXISTS (arg1))OR (NOT EXISTS(arg2)))OR(arg1.dim <> arg2.dim)
       THEN
     RETURN (?);


   ELSE
     BEGIN
       IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN
         mag1 := arg1.magnitude;

         vec1 := arg1.orientation;

       ELSE
         mag1 := 1.0;

         vec1 := arg1;

       END_IF;

       IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN
         mag2 := arg2.magnitude;

         vec2 := arg2.orientation;

       ELSE
         mag2 := 1.0;

         vec2 := arg2;

       END_IF;

       vec1 := normalise(vec1);

       vec2 := normalise(vec2);

       ndim := SIZEOF(vec1.direction_ratios);

       mag := 0.0;

       res := dummy_gri || direction(vec1.direction_ratios);

       REPEAT i := 1 TO ndim;

         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];

         mag := mag +(res.direction_ratios[i]*res.direction_ratios[i]);

       END_REPEAT;

       IF(mag > 0.0)THEN
       result := dummy_gri || vector(res, SQRT(mag));

       ELSE
         result := dummy_gri || vector(vec1,  0.0);

       END_IF;

     END;

   END_IF;

   RETURN(result);
END_FUNCTION; -- vector_sum

FUNCTION volume_weights_positive
	(b : rational_b_spline_volume) : BOOLEAN;
LOCAL

       result   : BOOLEAN := TRUE;

     END_LOCAL
;


     REPEAT  i := 0 TO  b.u_upper;

       REPEAT  j := 0 TO  b.v_upper;

         REPEAT k := 0 TO b.w_upper;

           IF(b.weights[i][j][k] <= 0.0) THEN
             result := FALSE;

             RETURN(result);

           END_IF;

         END_REPEAT;

       END_REPEAT;

     END_REPEAT;

     RETURN(result);
END_FUNCTION; -- volume_weights_positive

FUNCTION acyclic_group_relationship
	(relation : group_relationship; relatives : SET [1:?] OF group; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF group_relationship;

    END_LOCAL
;


    IF  relation.relating_group IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP'))| specific_relation IN TYPEOF(grp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_group_relationship

FUNCTION acyclic
	(arg1 : generic_expression; arg2 : SET [0:?] OF generic_expression) : BOOLEAN;
LOCAL

	result: BOOLEAN;

END_LOCAL
;


IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1))
THEN
	RETURN(TRUE);

END_IF;


IF arg1 IN arg2 
THEN 
	RETURN(FALSE);

END_IF;


IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1)
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));

END_IF;


IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1)
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));

END_IF;


IF 
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF(arg1)
THEN 
	result := TRUE;

	REPEAT i := 1 TO 
			SIZEOF(arg1\multiple_arity_generic_expression.operands);

		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);

	END_REPEAT;


	RETURN(result);

END_IF;
END_FUNCTION; -- acyclic

FUNCTION is_acyclic
	(arg : generic_expression) : BOOLEAN;
RETURN(acyclic(arg, []));
END_FUNCTION; -- is_acyclic

FUNCTION used_variables
	(arg : generic_expression) : SET [0:?] OF generic_variable;
LOCAL

	result : SET OF generic_variable := [];

END_LOCAL
;


IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.GENERIC_VARIABLE' 
	IN TYPEOF (arg)
THEN 
	RETURN([arg]);

END_IF;


IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\unary_generic_expression.operand));

END_IF;


IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables(arg\binary_generic_expression.operands[2]));

END_IF;


IF
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF(arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);

		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);

	END_REPEAT;

	
	RETURN(result);

END_IF;

RETURN([ ]);
END_FUNCTION; -- used_variables

FUNCTION acyclic_location_relationship
	(relation : location_relationship; relatives : SET [0:?] OF location; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF location_relationship;

    END_LOCAL
;


    IF  relation.relating_location IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION'))| specific_relation IN TYPEOF(lctn));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_location_relationship

FUNCTION acyclic_identification_assignment_relationship
	(relation : identification_assignment_relationship; relatives : SET [1:?] OF identification_assignment; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF identification_assignment_relationship;

    END_LOCAL
;


    IF  relation.relating_identification_assignment IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT'))| specific_relation IN TYPEOF(ia));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_identification_assignment_relationship

FUNCTION acyclic_property_definition_relationship
	(relation : property_definition_relationship; relatives : SET [1:?] OF property_definition; specific_relation : STRING) : LOGICAL;
LOCAL

    x                : SET OF property_definition_relationship;

  END_LOCAL
;


  IF  relation.relating_property_definition IN  
            relatives THEN
    RETURN(FALSE);

  END_IF;
             -- IN  is based IN  instance equality

  x := QUERY(pd <* bag_to_set(USEDIN
      (relation.relating_property_definition,
        'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION'))|
         specific_relation IN TYPEOF(pd));


  REPEAT I := 1 TO HIINDEX(x);
             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
     (x[i],
       relatives + relation.relating_property_definition,
       specific_relation)THEN
      RETURN(FALSE);

    END_IF;

  END_REPEAT;


  RETURN(TRUE);
END_FUNCTION; -- acyclic_property_definition_relationship

FUNCTION derive_dimensional_exponents
	(x : unit) : dimensional_exponents;
LOCAL

    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

  END_LOCAL
;


  IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.DERIVED_UNIT' IN TYPEOF(x)THEN
    REPEAT i := LOINDEX(x.elements)TO HIINDEX(x.elements);

      result.length_exponent := result.length_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);

      result.mass_exponent := result.mass_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);

      result.time_exponent := result.time_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);

      result.electric_current_exponent := result.electric_current_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);

      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);

      result.amount_of_substance_exponent := result.amount_of_substance_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);

      result.luminous_intensity_exponent := result.luminous_intensity_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);

    END_REPEAT;

  ELSE
    result := x.dimensions;

  END_IF;

  RETURN(result);
END_FUNCTION; -- derive_dimensional_exponents

FUNCTION dimensions_for_si_unit
	(n : si_unit_name) : dimensional_exponents;
CASE n OF
    metre          : RETURN (dimensional_exponents
                         (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    gram           : RETURN (dimensional_exponents
                        (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    second         : RETURN (dimensional_exponents
                        (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));

    ampere         : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));

    kelvin         : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));

    mole           : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));

    candela        : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));

    radian         : RETURN (dimensional_exponents
                          (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    steradian      : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    hertz          : RETURN (dimensional_exponents
                        (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));

    newton         : RETURN (dimensional_exponents
                        (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    pascal         : RETURN (dimensional_exponents
                        (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    joule          : RETURN (dimensional_exponents
                        (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    watt           : RETURN (dimensional_exponents
                        (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));

    coulomb        : RETURN (dimensional_exponents
                        (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));

    volt           : RETURN (dimensional_exponents
                        (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));

    farad          : RETURN (dimensional_exponents
                        (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));

    ohm            : RETURN (dimensional_exponents
                        (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));

    siemens        : RETURN (dimensional_exponents
                        (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));

    weber          : RETURN (dimensional_exponents
                        (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));

    tesla          : RETURN (dimensional_exponents
                        (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));

    henry          : RETURN (dimensional_exponents
                        (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));

    degree_Celsius : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));

    lumen          : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));

    lux            : RETURN (dimensional_exponents
                        (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));

    becquerel      : RETURN (dimensional_exponents
                        (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));

    gray           : RETURN (dimensional_exponents
                        (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    sievert        : RETURN (dimensional_exponents
                        (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    OTHERWISE      : RETURN(?);

  END_CASE;
END_FUNCTION; -- dimensions_for_si_unit

FUNCTION valid_units
	(m : measure_with_unit) : BOOLEAN;
IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.LENGTH_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MASS_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.TIME_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PLANE_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SOLID_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.AREA_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VOLUME_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.RATIO_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF(m.value_component)THEN
    IF derive_dimensional_exponents(m.unit_component)<>
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  RETURN(TRUE);
END_FUNCTION; -- valid_units

FUNCTION valid_selected_instance_representation
	(pd : product_definition_or_assembly_relationship) : LOGICAL;
LOCAL

  properties: SET  OF  property_definition :=[];

  property_definition_representations: SET OF property_definition_representation :=[];

  selected_representation: representation;

END_LOCAL
;


properties :=QUERY(prd<* USEDIN(pd ,'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION')| 
(prd.name = 'occurrence selection'));

IF(SIZEOF(properties)<>1)THEN
	RETURN(FALSE);

END_IF;


property_definition_representations := QUERY(pdr <* USEDIN(properties[1], 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 
	(pdr.used_representation.name = 'selection criteria'));

IF(SIZEOF(property_definition_representations)<>1)THEN
	RETURN(FALSE);

END_IF;


selected_representation := property_definition_representations[1].used_representation;


IF(SIZEOF(selected_representation.items)<1)OR (SIZEOF(selected_representation.items)>2)THEN
	RETURN(FALSE);

END_IF;


IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |
	(SIZEOF(['AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MEASURE_REPRESENTATION_ITEM' ,
			'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VALUE_RANGE']* TYPEOF(i))= 1)AND
 	(i.name = 'selection quantity')))<> 1)THEN
	RETURN(FALSE);

END_IF;


IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |
	('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(i))AND
 	(i.name = 'selection control')))> 1)THEN
	RETURN(FALSE);

END_IF;
 --the selection control is NOT specified THEN the quantity shall be a qualified_representation_item OR a value_range
IF(SIZEOF(QUERY(i <* selected_representation.used_representation.items |
	('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i))AND
 	(i.name = 'selection control')))= 0)AND  
  (SIZEOF(QUERY(i <* selected_representation.used_representation.items |
    (i.name = 'selection quantity')AND  
    (SIZEOF(['AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.QUALIFIED_REPRESENTATION_ITEM' ,
		'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VALUE_RANGE']* TYPEOF(i))=0)))> 0)THEN
	RETURN(FALSE);

END_IF;

	
RETURN(TRUE);
END_FUNCTION; -- valid_selected_instance_representation

FUNCTION acyclic_organization_relationship
	(relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF organization_relationship;

    END_LOCAL
;


    IF  relation.relating_organization IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION'))| specific_relation IN TYPEOF(org));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_organization_relationship

FUNCTION acyclic_organization_type_relationship
	(relation : organization_type_relationship; relatives : SET [0:?] OF organization_type; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF organization_type_relationship;

    END_LOCAL
;


    IF  relation.relating_organization_type IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE'))| specific_relation IN TYPEOF(orgtyp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_organization_type_relationship

FUNCTION acyclic_organizational_project_relationship
	(relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF organizational_project_relationship;

    END_LOCAL
;


    IF  relation.relating_organizational_project IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT'))| specific_relation IN TYPEOF(op));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_organizational_project_relationship

FUNCTION acyclic_person_type_definition_relationship
	(relation : person_type_definition_relationship; relatives : SET [0:?] OF person_type_definition; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF person_type_definition_relationship;

    END_LOCAL
;


    IF  relation.relating_person_type_definition IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION'))| specific_relation IN TYPEOF(ptdef));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_person_type_definition_relationship

FUNCTION acyclic_position_in_organization_relationship
	(relation : position_in_organization_relationship; relatives : SET [0:?] OF position_in_organization; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF position_in_organization_relationship;

    END_LOCAL
;


    IF  relation.relating_position_in_organization IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION'))| specific_relation IN TYPEOF(piorg));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_position_in_organization_relationship

FUNCTION acyclic_product_category_relationship
	(relation : product_category_relationship; children : SET [0:?] OF product_category) : BOOLEAN;
LOCAL

      x : SET  OF  product_category_relationship;

      local_children : SET OF product_category;

    END_LOCAL
;


    REPEAT  i := 1 TO  HIINDEX(children);

      IF  relation.category :=: children[i] THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    x := bag_to_set(USEDIN(relation.category, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));

    local_children := children + relation.category;

    IF  SIZEOF(x)> 0 THEN
      REPEAT i := 1 TO HIINDEX(x);

        IF NOT acyclic_product_category_relationship(x[i], local_children)THEN
          RETURN (FALSE);

        END_IF;

      END_REPEAT;

    END_IF;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_product_category_relationship

FUNCTION acyclic_product_definition_formation_relationship
	(relation : product_definition_formation_relationship; relatives : SET [1:?] OF product_definition_formation; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF product_definition_formation_relationship;

    END_LOCAL
;


    IF  relation.relating_product_definition_formation IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION'))| specific_relation IN TYPEOF(pdf));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_product_definition_formation_relationship

FUNCTION acyclic_product_definition_relationship
	(relation : product_definition_relationship; relatives : SET [1:?] OF product_definition; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF product_definition_relationship;

    END_LOCAL
;


    IF  relation.relating_product_definition IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))| specific_relation IN TYPEOF(pd));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation)THEN
        RETURN(FALSE);

      END_IF;

    END_REPEAT;

RETURN(TRUE);
END_FUNCTION; -- acyclic_product_definition_relationship

FUNCTION acyclic_product_relationship
	(relation : product_relationship; relatives : SET [1:?] OF product; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF product_relationship;

    END_LOCAL
;


    IF  relation.relating_product IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT'))| specific_relation IN TYPEOF(prod));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_product_relationship

FUNCTION get_product_definitions
	(c_def_instance : product) : SET [0:?] OF product_definition;
LOCAL

      pd_set : SET  OF  product_definition_formation := [];

      pdr_set : SET OF product_definition := [];

    END_LOCAL
;


    pd_set := bag_to_set(USEDIN(c_def_instance, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));

    IF(SIZEOF(pd_set)< 1)THEN
      RETURN (pdr_set);

    END_IF;

    REPEAT i := 1 TO HIINDEX(pd_set);

      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_DEFINITION.FORMATION'));

    END_REPEAT;

    RETURN(pdr_set);
END_FUNCTION; -- get_product_definitions

FUNCTION acyclic_characterized_object_relationship
	(relation : characterized_object_relationship; relatives : SET [1:?] OF characterized_object; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF characterized_object_relationship;

    END_LOCAL
;


    IF  relation.relating_object IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT'))| specific_relation IN TYPEOF(ca));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation)THEN
        RETURN(FALSE);

      END_IF;

    END_REPEAT;

RETURN(TRUE);
END_FUNCTION; -- acyclic_characterized_object_relationship

FUNCTION acyclic_general_property_relationship
	(relation : general_property_relationship; relatives : SET [1:?] OF general_property; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF general_property_relationship;

    END_LOCAL
;


    IF  relation.relating_property IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY'))| specific_relation IN TYPEOF(genp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_general_property_relationship

FUNCTION acyclic_shape_aspect_relationship
	(relation : shape_aspect_relationship; relatives : SET [1:?] OF shape_aspect; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF shape_aspect_relationship;

    END_LOCAL
;


    IF  relation.relating_shape_aspect IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT'))| specific_relation IN TYPEOF(sa));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_shape_aspect_relationship

FUNCTION get_shape_aspects
	(c_def_instance : characterized_definition) : SET [0:?] OF shape_aspect;
LOCAL

      pd_set : SET  OF  product_definition_shape := [];

      pdr_set : SET OF shape_aspect := [];

    END_LOCAL
;


    pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PROPERTY_DEFINITION.DEFINITION')| 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));

    IF(SIZEOF(pd_set)< 1)THEN
      RETURN (pdr_set);

    END_IF;

    REPEAT i := 1 TO HIINDEX(pd_set);

      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));

    END_REPEAT;

    RETURN(pdr_set);
END_FUNCTION; -- get_shape_aspects

FUNCTION get_property_definition_representations
	(c_def_instance : characterized_definition) : SET [0:?] OF property_definition_representation;
LOCAL

      pd_set : SET  OF  property_definition := [];

      pdr_set : SET OF property_definition_representation := [];

      END_LOCAL
;

      
 pd_set := bag_to_set(USEDIN(c_def_instance,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));

 IF(SIZEOF(pd_set)< 1)THEN RETURN (pdr_set);

 END_IF;


 REPEAT i:= 1 TO HIINDEX(pd_set);

    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i],
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));

 END_REPEAT;

 RETURN(pdr_set);
END_FUNCTION; -- get_property_definition_representations

FUNCTION local_relatives_of_product_definitions
	(definition_set : SET [0:?] OF product_definition; total_definitions : SET [0:?] OF product_definition; relation_subtype : STRING) : SET [0:?] OF product_definition;
LOCAL

    local_def   : SET  OF  product_definition := [];

    local_pdr   : SET  OF  product_definition_relationship := [];

    local_total : SET OF product_definition := [];

  END_LOCAL
;

  REPEAT  i := 1 TO  HIINDEX(definition_set);

    local_pdr := local_pdr +
                 bag_to_set(USEDIN
                  (definition_set[i],
                    relation_subtype + '.RELATING_PRODUCT_DEFINITION'));

  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(local_pdr);

    local_def := local_def + local_pdr[i].related_product_definition;

  END_REPEAT;

  IF(SIZEOF(local_def)- SIZEOF(total_definitions))= 0 THEN
    RETURN(local_def);

  ELSE
    local_total := total_definitions + local_def;

    RETURN(local_def +
         (local_relatives_of_product_definitions
         (local_def - total_definitions, local_total, relation_subtype)));

  END_IF;
END_FUNCTION; -- local_relatives_of_product_definitions

FUNCTION local_relatives_of_shape_representations
	(shape_representation_set : SET [0:?] OF shape_representation; total_reps : SET [0:?] OF shape_representation) : SET [0:?] OF shape_representation;
LOCAL

      local_shape_rep : SET  OF  shape_representation := [];

      local_srr       : SET  OF  shape_representation_relationship := [];

      local_total     : SET OF shape_representation := [];

    END_LOCAL
;

    REPEAT  i := 1 TO  HIINDEX(shape_representation_set);

      local_srr := local_srr + QUERY(rr <* bag_to_set
     (USEDIN(shape_representation_set[i],
       'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1'))|
'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP'
      IN  TYPEOF(rr));

    END_REPEAT;

    REPEAT i := 1 TO HIINDEX(local_srr);

      IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.'+
                  'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i])
      THEN
         local_shape_rep := local_shape_rep + local_srr[i].rep_2;

      END_IF;

    END_REPEAT;

    IF SIZEOF(local_shape_rep - total_reps)= 0 THEN
      RETURN(shape_representation_set);

    ELSE
      local_total := total_reps + local_shape_rep;

      RETURN(local_shape_rep +(local_relatives_of_shape_representations
                              (local_shape_rep - total_reps, local_total)));

    END_IF;
END_FUNCTION; -- local_relatives_of_shape_representations

FUNCTION relatives_of_product_definitions
	(definition_set : SET [0:?] OF product_definition; relation_subtype : STRING) : SET [0:?] OF product_definition;
RETURN(local_relatives_of_product_definitions
      (definition_set, definition_set, relation_subtype));
END_FUNCTION; -- relatives_of_product_definitions

FUNCTION relatives_of_shape_representations
	(shape_representation_set : SET [0:?] OF shape_representation) : SET [0:?] OF shape_representation;
RETURN(local_relatives_of_shape_representations
         (shape_representation_set, shape_representation_set));
END_FUNCTION; -- relatives_of_shape_representations

FUNCTION acyclic_qualification_relationship
	(relation : qualification_relationship; relatives : SET [0:?] OF qualification; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF qualification_relationship;

    END_LOCAL
;


    IF  relation.relating_qualification IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION'))| specific_relation IN TYPEOF(qual));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_qualification_relationship

FUNCTION acyclic_qualification_type_relationship
	(relation : qualification_type_relationship; relatives : SET [0:?] OF qualification_type; specific_relation : STRING) : BOOLEAN;
LOCAL

      x : SET OF qualification_type_relationship;

    END_LOCAL
;


    IF  relation.relating_qualification_type IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE'))| specific_relation IN TYPEOF(qultyp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);
END_FUNCTION; -- acyclic_qualification_type_relationship

FUNCTION acyclic_mapped_representation
	(parent_set : SET [0:?] OF representation; children_set : SET [0:?] OF representation_item) : BOOLEAN;
LOCAL

    x,y : SET  OF  representation_item;

  END_LOCAL
;

  -- Determine the subset OF  children_set that are mapped_items
  x := QUERY(z <* children_set | 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.MAPPED_ITEM'
       IN  TYPEOF(z));

  -- Determine that the subset has elements
  IF  SIZEOF(x)> 0 THEN
    -- Check each element OF  the set
    REPEAT  i := 1 TO  HIINDEX(x);

      -- IF  the selected element maps a representation IN  the
      -- parent_set, THEN RETURN  false
      IF  x[i]\mapped_item.mapping_source.mapped_representation
        IN  parent_set THEN
        RETURN (FALSE);

      END_IF;

      -- Recursive check OF  the items OF  mapped_representation
      IF  NOT  acyclic_mapped_representation
       (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

  END_IF;

  -- Determine the subset OF  children_set that are not
  -- mapped_items
  x := children_set - x;

  -- Determine that the subset has elements
  IF  SIZEOF(x)> 0 THEN
    -- FOR  each element OF  the set:
    REPEAT i := 1 TO HIINDEX(x);

      -- Determine the SET OF representation_items referenced
      y := QUERY(z <* bag_to_set(USEDIN(x[i], ''))|
           'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));

      -- Recursively check FOR  an offending mapped_item
      -- RETURN  FALSE FOR any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

  END_IF;

  -- RETURN  TRUE when all elements are checked and
  -- no error conditions found
  RETURN(TRUE);
END_FUNCTION; -- acyclic_mapped_representation

FUNCTION item_in_context
	(item : representation_item; cntxt : representation_context) : BOOLEAN;
LOCAL

    y : BAG  OF  representation_item;

  END_LOCAL
;

  -- IF  there is one OR more representation using both the item
  -- AND cntxt RETURN  true.
  IF  SIZEOF(USEDIN(item,'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context)> 0 THEN
    RETURN (TRUE);

    -- Determine the BAG  OF representation_items that reference
    -- item
    ELSE y := QUERY(z <* USEDIN(item, '')|
           'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.REPRESENTATION_ITEM' IN  TYPEOF(z));

      -- Ensure that the BAG is NOT empty
      IF  SIZEOF(y)> 0 THEN
      -- FOR each element IN  the bag
      REPEAT i := 1 TO  HIINDEX(y);

        -- Check TO see it is an item IN the input cntxt.
        IF item_in_context(y[i], cntxt)THEN
          RETURN (TRUE);

        END_IF;

      END_REPEAT;

    END_IF;

  END_IF;

  -- RETURN  FALSE when all possible branches have been checked
  -- WITH no success.
  RETURN(FALSE);
END_FUNCTION; -- item_in_context

FUNCTION using_items
	(item : founded_item_select; checked_items : SET [0:?] OF founded_item_select) : SET [0:?] OF founded_item_select;
LOCAL

    new_check_items    : SET  OF  founded_item_select;

    result_items       : SET  OF  founded_item_select;

    next_items         : SET  OF  founded_item_select;

  END_LOCAL
;

  result_items := [];

  new_check_items := checked_items + item;

  -- Find the SET  OF  representation_items OR  founded_items
  -- IN  which item is used directly.
  next_items := QUERY(z <* bag_to_set(USEDIN(item, ''))|
   ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.REPRESENTATION_ITEM' IN  TYPEOF(z))OR
   ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.FOUNDED_ITEM'        IN  TYPEOF(z)));

  -- IF  the SET  OF  next_items is NOT empty;

  IF  SIZEOF(next_items)> 0 THEN
    -- FOR  each element IN  the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);

      -- Check FOR loop IN  data model, i.e.one OF  the next_items
      -- occurred earlier IN  the SET  OF  check_items;

      IF NOT(next_items[i] IN  new_check_items)THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);

      END_IF;

    END_REPEAT;

  END_IF;

  -- RETURN  the SET OF representation_items OR founded_items
  -- IN which the input item is used directly AND indirectly.
  RETURN(result_items);
END_FUNCTION; -- using_items

FUNCTION using_representations
	(item : founded_item_select) : SET [0:?] OF representation;
LOCAL

    results            : SET  OF  representation;

    result_bag         : BAG OF  representation;

    intermediate_items : SET  OF  founded_item_select;

  END_LOCAL
;

  -- Find the representations IN  which the item is used AND  add TO  the
  -- results set.
  results := [];

  result_bag :=
USEDIN(item,'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.REPRESENTATION.ITEMS');

  IF  SIZEOF(result_bag)> 0 THEN
    REPEAT  i := 1 TO  HIINDEX(result_bag);

      results := results + result_bag[i];

    END_REPEAT;

  END_IF;

  -- Find all representation_items OR  founded_items
  -- BY which item is referenced directly OR  indirectly.
  intermediate_items := using_items(item,[]);

  -- IF  the SET  OF  intermediate items is NOT empty;

  IF  SIZEOF(intermediate_items)> 0 THEN
    -- FOR each element IN  the set, add the
    -- representations OF  that element.
    REPEAT  i := 1 TO  HIINDEX(intermediate_items);

      result_bag := USEDIN(intermediate_items[i],
                    'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.REPRESENTATION.ITEMS');

      IF SIZEOF(result_bag)> 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);

          results := results + result_bag[j];

        END_REPEAT;

      END_IF;

    END_REPEAT;

  END_IF;

  -- RETURN  the SET OF representation IN which the input item is
  -- used directly AND indirectly(through intervening
  -- representation_items OR founded items).
  RETURN(results);
END_FUNCTION; -- using_representations

FUNCTION valid_measure_value
	(m : measure_value) : BOOLEAN;
IF('REAL' IN  TYPEOF (m))THEN
  RETURN (m > 0.0);

  ELSE
    IF('INTEGER' IN TYPEOF(m))THEN
    RETURN (m > 0);

    ELSE
      RETURN(TRUE);

    END_IF;

  END_IF;
END_FUNCTION; -- valid_measure_value

FUNCTION categories_of_product
	(obj : product) : SET [0:?] OF STRING;
LOCAL

category_assignments: BAG OF  product_category;

categories: SET OF STRING:=[];

i: INTEGER;

END_LOCAL
;

category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');

REPEAT i := LOINDEX(category_assignments)TO HIINDEX(category_assignments)BY 1;

categories := categories + category_assignments[i].name;

END_REPEAT;

RETURN(categories);
END_FUNCTION; -- categories_of_product

FUNCTION bag_to_set
	(the_bag : BAG [0:?] OF GENERIC) : SET [0:?] OF GENERIC;
LOCAL

      the_set : SET OF GENERIC:intype := [];

    END_LOCAL
;


    IF SIZEOF(the_bag)> 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);

        the_set := the_set + the_bag[i];

      END_REPEAT;

    END_IF;

    RETURN(the_set);
END_FUNCTION; -- bag_to_set

FUNCTION type_check_function
	(the_type : GENERIC; sub_names : SET [0:?] OF STRING; criterion : INTEGER) : LOGICAL;
IF((NOT EXISTS(the_type))OR(NOT({0<= criterion <=3}))OR
(SIZEOF(sub_names)= 0))THEN RETURN (UNKNOWN);

ELSE
  CASE criterion OF
       0: RETURN (SIZEOF(sub_names * TYPEOF (the_type))> 0);

       1: RETURN (SIZEOF(sub_names * TYPEOF (the_type))= 0);

       2: RETURN (SIZEOF(sub_names * TYPEOF (the_type))= 1);

       3: RETURN(SIZEOF(sub_names * TYPEOF(the_type))<= 1);

  END_CASE;

END_IF;
END_FUNCTION; -- type_check_function

FUNCTION boolean_choose
	(b : BOOLEAN; choice1 : GENERIC:item; choice2 : GENERIC:item) : GENERIC:item;
IF b THEN
       RETURN (choice1);

     ELSE
       RETURN(choice2);

     END_IF;
END_FUNCTION; -- boolean_choose

FUNCTION closed_shell_reversed
	(a_shell : closed_shell) : oriented_closed_shell;
LOCAL

    the_reverse : oriented_closed_shell;

  END_LOCAL
;

   IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell))THEN
      the_reverse := dummy_tri ||
                    connected_face_set(
                       a_shell\connected_face_set.cfs_faces)||
                    closed_shell()|| oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));

   ELSE
      the_reverse := dummy_tri ||
               connected_face_set(
                 a_shell\connected_face_set.cfs_faces)||
               closed_shell()|| oriented_closed_shell(a_shell, FALSE);

   END_IF;

   RETURN(the_reverse);
END_FUNCTION; -- closed_shell_reversed

FUNCTION conditional_reverse
	(p : BOOLEAN; an_item : reversible_topology) : reversible_topology;
IF p THEN
     RETURN (an_item);

   ELSE
     RETURN(topology_reversed(an_item));

   END_IF;
END_FUNCTION; -- conditional_reverse

FUNCTION edge_curve_pcurves
	(an_edge : edge_curve; the_surface_curves : SET [0:?] OF surface_curve) : SET [0:?] OF pcurve;
LOCAL

  a_curve      : curve;

  result       : SET OF  pcurve;

  the_geometry : LIST[1:2] OF pcurve_or_surface;

END_LOCAL
;

  a_curve := an_edge.edge_geometry;

  result := [];

  IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF(a_curve)THEN
    result := result + a_curve;

  ELSE
    IF  'GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(a_curve)THEN
      the_geometry := a_curve\surface_curve.associated_geometry;

      REPEAT  k := 1 TO  SIZEOF(the_geometry);

         IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];

         END_IF;

      END_REPEAT;

    ELSE
      REPEAT  j := 1 TO  SIZEOF(the_surface_curves);

        the_geometry := the_surface_curves[j].associated_geometry;

        IF  the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);

            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(the_geometry[k])
            THEN
              result := result + the_geometry[k];

            END_IF;

          END_REPEAT;

        END_IF;

      END_REPEAT;

    END_IF;

  END_IF;


  RETURN(RESULT);
END_FUNCTION; -- edge_curve_pcurves

FUNCTION edge_reversed
	(an_edge : edge) : oriented_edge;
LOCAL

     the_reverse : oriented_edge;

   END_LOCAL
;


   IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_EDGE' IN TYPEOF(an_edge))THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start)||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT(an_edge\oriented_edge.orientation));

   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start)||
             oriented_edge(an_edge, FALSE);

   END_IF;

   RETURN(the_reverse);
END_FUNCTION; -- edge_reversed

FUNCTION face_bound_reversed
	(a_face_bound : face_bound) : face_bound;
LOCAL

     the_reverse : face_bound ;

   END_LOCAL
;

   IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound))THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT(a_face_bound\face_bound.orientation))
                            || face_outer_bound();

   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));

   END_IF;

  RETURN(the_reverse);
END_FUNCTION; -- face_bound_reversed

FUNCTION face_reversed
	(a_face : face) : oriented_face;
LOCAL

     the_reverse : oriented_face ;

   END_LOCAL
;

   IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_FACE' IN TYPEOF(a_face))THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds))||
          oriented_face(a_face\oriented_face.face_element,
                           NOT(a_face\oriented_face.orientation));

   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds))||
                               oriented_face(a_face, FALSE);

   END_IF;

      RETURN(the_reverse);
END_FUNCTION; -- face_reversed

FUNCTION list_face_loops
	(f : face) : LIST [0:?] OF loop;
LOCAL

     loops : LIST[0:?] OF loop := [];

   END_LOCAL
;

   
   REPEAT i := 1 TO SIZEOF(f.bounds);

     loops := loops +(f.bounds[i].bound);

   END_REPEAT;

      
   RETURN(loops);
END_FUNCTION; -- list_face_loops

FUNCTION list_loop_edges
	(l : loop) : LIST [0:?] OF edge;
LOCAL

     edges : LIST[0:?] OF edge := [];

   END_LOCAL
;

      
   IF 'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.EDGE_LOOP' IN TYPEOF(l)THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);

       edges := edges +(l\path.edge_list[i].edge_element);

     END_REPEAT;

   END_IF;


   RETURN(edges);
END_FUNCTION; -- list_loop_edges

FUNCTION list_of_topology_reversed
	(a_list : list_of_reversible_topology_item) : list_of_reversible_topology_item;
LOCAL

     the_reverse : list_of_reversible_topology_item;

   END_LOCAL
;

    
   the_reverse := [];

   REPEAT i := 1 TO SIZEOF(a_list);

     the_reverse := topology_reversed(a_list [i])+ the_reverse;

   END_REPEAT;

  
   RETURN(the_reverse);
END_FUNCTION; -- list_of_topology_reversed

FUNCTION list_shell_edges
	(s : shell) : LIST [0:?] OF edge;
LOCAL

     edges : LIST[0:?] OF edge := [];

   END_LOCAL
;

      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));

     edges := edges + list_loop_edges(list_shell_loops(s)[i]);

   END_REPEAT;

   
   RETURN(edges);
END_FUNCTION; -- list_shell_edges

FUNCTION list_shell_faces
	(s : shell) : LIST [0:?] OF face;
LOCAL

     faces : LIST[0:?] OF face := [];

   END_LOCAL
;

   
   IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CLOSED_SHELL' IN  TYPEOF(s))OR 
     ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.OPEN_SHELL' IN TYPEOF(s))THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);

       faces := faces + s\connected_face_set.cfs_faces[i];

     END_REPEAT;

   END_IF;

      
   RETURN(faces);
END_FUNCTION; -- list_shell_faces

FUNCTION list_shell_loops
	(s : shell) : LIST [0:?] OF loop;
LOCAL

     loops : LIST[0:?] OF loop := [];

   END_LOCAL
;

      
   IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.VERTEX_SHELL' IN  TYPEOF(s)THEN
     loops := loops + s.vertex_shell_extent;

   END_IF;

      
   IF  'AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.WIRE_SHELL' IN  TYPEOF(s)THEN
     REPEAT  i := 1 TO  SIZEOF(s.wire_shell_extent);

       loops := loops + s.wire_shell_extent[i];

     END_REPEAT;

   END_IF;

      
   IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.OPEN_SHELL' IN  TYPEOF(s))OR 
     ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CLOSED_SHELL' IN TYPEOF(s))THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);

       loops := loops + list_face_loops(s.cfs_faces[i]);

     END_REPEAT;

   END_IF;

      
   RETURN(loops);
END_FUNCTION; -- list_shell_loops

FUNCTION list_to_set
	(l : LIST [0:?] OF GENERIC) : SET [0:?] OF GENERIC;
LOCAL

     s : SET OF GENERIC:T := [];

   END_LOCAL
;

      
   REPEAT i := 1 TO SIZEOF(l);

     s := s + l[i];

   END_REPEAT;

   
   RETURN(s);
END_FUNCTION; -- list_to_set

FUNCTION mixed_loop_type_set
	(l : SET [0:?] OF loop) : LOGICAL;
LOCAL

      poly_loop_type: LOGICAL;

    END_LOCAL
;

    IF(SIZEOF(l)<= 1)THEN
      RETURN(FALSE);

    END_IF;

    poly_loop_type :=('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.POLY_LOOP' IN  TYPEOF(l[1]));

    REPEAT i := 2 TO SIZEOF(l);

      IF(('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.POLY_LOOP' IN TYPEOF(l[i]))<> poly_loop_type)
          THEN
          RETURN(TRUE);

       END_IF;

    END_REPEAT;

    RETURN(FALSE);
END_FUNCTION; -- mixed_loop_type_set

FUNCTION open_shell_reversed
	(a_shell : open_shell) : oriented_open_shell;
LOCAL

     the_reverse : oriented_open_shell;

   END_LOCAL
;

   IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell))THEN
     the_reverse := dummy_tri ||
                  connected_face_set(
                      a_shell\connected_face_set.cfs_faces)||
                  open_shell()|| oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                     (NOT(a_shell\oriented_open_shell.orientation)));

   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set(
                     a_shell\connected_face_set.cfs_faces)||
                 open_shell()||  oriented_open_shell(a_shell, FALSE);

   END_IF;

   RETURN(the_reverse);
END_FUNCTION; -- open_shell_reversed

FUNCTION path_head_to_tail
	(a_path : path) : LOGICAL;
LOCAL

     n : INTEGER;

     p : LOGICAL := TRUE;

   END_LOCAL
;

     
     n := SIZEOF(a_path.edge_list);

     REPEAT i := 2 TO n;

       p := p AND(a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);

     END_REPEAT;

     
     RETURN(p);
END_FUNCTION; -- path_head_to_tail

FUNCTION path_reversed
	(a_path : path) : oriented_path;
LOCAL

    the_reverse : oriented_path ;

  END_LOCAL
;

  IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.ORIENTED_PATH' IN TYPEOF(a_path))THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed(a_path.edge_list))||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation));

  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed(a_path.edge_list))||
                       oriented_path(a_path, FALSE);

  END_IF;


  RETURN(the_reverse);
END_FUNCTION; -- path_reversed

FUNCTION set_of_topology_reversed
	(a_set : set_of_reversible_topology_item) : set_of_reversible_topology_item;
LOCAL

     the_reverse : set_of_reversible_topology_item;

   END_LOCAL
;

   
   the_reverse := [];

   REPEAT i := 1 TO SIZEOF(a_set);

     the_reverse := the_reverse + topology_reversed(a_set [i]);

   END_REPEAT;

   
   RETURN(the_reverse);
END_FUNCTION; -- set_of_topology_reversed

FUNCTION shell_reversed
	(a_shell : shell) : shell;
IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.OPEN_SHELL' IN  TYPEOF (a_shell))THEN
     RETURN (open_shell_reversed(a_shell));

   ELSE
     IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.CLOSED_SHELL' IN TYPEOF(a_shell))THEN
       RETURN (closed_shell_reversed(a_shell));

     ELSE
       RETURN(?);

     END_IF;

   END_IF;
END_FUNCTION; -- shell_reversed

FUNCTION topology_reversed
	(an_item : reversible_topology) : reversible_topology;
IF('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.EDGE' IN  TYPEOF (an_item))THEN
     RETURN (edge_reversed(an_item));

   END_IF;


   IF ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.PATH' IN  TYPEOF (an_item))THEN
     RETURN (path_reversed(an_item));

   END_IF;


   IF ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.FACE_BOUND' IN  TYPEOF (an_item))THEN
     RETURN (face_bound_reversed(an_item));

   END_IF;

  
   IF ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.FACE' IN  TYPEOF (an_item))THEN
     RETURN (face_reversed(an_item));

   END_IF;


   IF ('AP210_FUNCTIONAL_SPECIFICATION_MIM_LF.SHELL' IN  TYPEOF (an_item))THEN
     RETURN (shell_reversed(an_item));

   END_IF;


   IF ('SET' IN  TYPEOF (an_item))THEN
     RETURN (set_of_topology_reversed(an_item));

   END_IF;


   IF('LIST' IN TYPEOF(an_item))THEN
     RETURN (list_of_topology_reversed(an_item));

   END_IF;


   RETURN(?);
END_FUNCTION; -- topology_reversed

FUNCTION vertex_point_pcurves
	(a_vertex : vertex_point; the_degenerates : SET [0:?] OF evaluated_degenerate_pcurve) : SET [0:?] OF degenerate_pcurve;
LOCAL

  a_point : point;

  result  : SET OF degenerate_pcurve;

END_LOCAL
;

  a_point := a_vertex.vertex_geometry;

  result := [];

  IF  'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point)THEN
    result := result + a_point;

  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);

         IF(the_degenerates[j].equivalent_point :=: a_point) THEN
            result := result + the_degenerates[j];

         END_IF;

      END_REPEAT;

  END_IF;


  RETURN(RESULT);
END_FUNCTION; -- vertex_point_pcurves

END_SCHEMA; --ap210_functional_specification_mim_lf

