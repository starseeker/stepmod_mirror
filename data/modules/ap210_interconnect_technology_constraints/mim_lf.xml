<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="$Date$" rcs.revision="$Revision$" description.file="arm_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="ap210_interconnect_technology_constraints_mim_lf schema_instance"/>
   <schema name="ap210_interconnect_technology_constraints_mim_lf">
      <constant name="dummy_gri" expression="representation_item('')||&#10;                                   geometric_representation_item()">
         <typename name="geometric_representation_item"/>
      </constant>
      <constant name="dummy_tri" expression="representation_item('')||&#10;                   topological_representation_item()">
         <typename name="topological_representation_item"/>
      </constant>
      <type name="action_items">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="action_method_items">
         <select extensible="YES"/>
      </type>
      <type name="action_request_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="ahead_or_behind">
         <enumeration items="ahead exact behind"/>
      </type>
      <type name="aliasable_item">
         <select extensible="YES"/>
      </type>
      <type name="am_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="analytical_model_definition"/>
      </type>
      <type name="am_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="digital_analytical_model_vector_port"/>
      </type>
      <type name="amount_of_substance_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="angle_relator">
         <enumeration items="equal large small"/>
      </type>
      <type name="approval_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="area_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="attribute_classification_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="attribute_language_item">
         <select extensible="YES" genericentity="YES" selectitems="multi_language_attribute_assignment attribute_value_assignment"/>
      </type>
      <type name="attribute_type">
         <select selectitems="label text"/>
      </type>
      <type name="axis2_placement">
         <select selectitems="axis2_placement_2d axis2_placement_3d"/>
      </type>
      <type name="b_spline_curve_form">
         <enumeration items="polyline_form circular_arc elliptic_arc parabolic_arc hyperbolic_arc unspecified"/>
      </type>
      <type name="b_spline_surface_form">
         <enumeration items="plane_surf cylindrical_surf conical_surf spherical_surf toroidal_surf surf_of_revolution ruled_surf generalised_cone quadric_surf surf_of_linear_extrusion unspecified"/>
      </type>
      <type name="bc_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="trimmed_curve"/>
      </type>
      <type name="boolean_operand">
         <select selectitems="solid_model half_space_solid csg_primitive boolean_result half_space_2d"/>
      </type>
      <type name="boolean_operator">
         <enumeration items="union intersection difference"/>
      </type>
      <type name="c_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="representation"/>
      </type>
      <type name="category_usage_item">
         <select selectitems="product_class"/>
      </type>
      <type name="celsius_temperature_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="certification_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="characterized_action_definition">
         <select selectitems="action action_method action_method_relationship action_relationship"/>
      </type>
      <type name="characterized_definition">
         <select selectitems="characterized_object characterized_product_definition shape_definition"/>
      </type>
      <type name="characterized_material_property">
         <select selectitems="material_property_representation product_material_composition_relationship"/>
      </type>
      <type name="characterized_product_definition">
         <select selectitems="product_definition product_definition_relationship"/>
      </type>
      <type name="characterized_resource_definition">
         <select selectitems="action_resource action_resource_relationship action_resource_requirement action_resource_requirement_relationship"/>
      </type>
      <type name="class_system_item">
         <select extensible="YES" genericentity="YES" selectitems="characterized_class"/>
      </type>
      <type name="classification_classification_item">
         <select extensible="YES" basedon="classification_item" selectitems="class"/>
      </type>
      <type name="classification_identification_item">
         <select extensible="YES" basedon="identification_item" selectitems="class"/>
      </type>
      <type name="classification_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="classification_item_extended">
         <select extensible="YES" genericentity="YES" basedon="classification_item" selectitems="characterized_class product product_definition_formation product_definition"/>
      </type>
      <type name="classification_select">
         <select extensible="YES"/>
      </type>
      <type name="classified_item">
         <select extensible="YES" genericentity="YES" selectitems="product product_definition_formation product_definition"/>
      </type>
      <type name="cma_classification_item">
         <select extensible="YES" genericentity="YES" basedon="classification_item" selectitems="material_designation"/>
      </type>
      <type name="complete_membership_select">
         <select extensible="YES"/>
      </type>
      <type name="compound_item_definition">
         <select selectitems="list_representation_item set_representation_item"/>
      </type>
      <type name="configuration_design_item">
         <select selectitems="product_definition product_definition_formation"/>
      </type>
      <type name="context_dependent_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="contract_item">
         <select extensible="YES"/>
      </type>
      <type name="count_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="csg_primitive">
         <select selectitems="sphere ellipsoid block right_angular_wedge faceted_primitive rectangular_pyramid torus right_circular_cone eccentric_cone right_circular_cylinder cyclide_segment_solid primitive_2d"/>
      </type>
      <type name="csg_select">
         <select selectitems="boolean_result csg_primitive"/>
      </type>
      <type name="curve_on_surface">
         <select selectitems="pcurve surface_curve composite_curve_on_surface"/>
      </type>
      <type name="cwa_identification_item">
         <select basedon="identification_item" selectitems="characterized_class"/>
      </type>
      <type name="cwa_versionable_item">
         <select basedon="versionable_item" selectitems="characterized_class"/>
      </type>
      <type name="date_and_time_item">
         <select extensible="YES"/>
      </type>
      <type name="date_and_time_item_approval">
         <select basedon="date_and_time_item" selectitems="approval_person_organization"/>
      </type>
      <type name="date_item">
         <select extensible="YES"/>
      </type>
      <type name="date_item_approval">
         <select basedon="date_item" selectitems="approval_person_organization"/>
      </type>
      <type name="date_time_or_event_occurrence">
         <select selectitems="date_time_select event_occurrence"/>
      </type>
      <type name="date_time_select">
         <select selectitems="date date_and_time local_time"/>
      </type>
      <type name="day_in_month_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{1 &lt;= SELF &lt;= 31}"/>
      </type>
      <type name="day_in_week_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 1 &lt;= SELF &lt;= 7 }"/>
      </type>
      <type name="day_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{1 &lt;= SELF &lt;= 366}"/>
      </type>
      <type name="derived_property_select">
         <select selectitems="action_property property_definition resource_property"/>
      </type>
      <type name="description_attribute_select">
         <select selectitems="action_request_solution application_context approval_role configuration_design context_dependent_shape_representation date_role date_time_role effectivity external_source organization_role person_and_organization person_and_organization_role person_role property_definition_representation representation time_role"/>
      </type>
      <type name="descriptive_measure">
         <builtintype type="STRING"/>
      </type>
      <type name="design_action_method_items">
         <select extensible="YES" genericentity="YES" basedon="action_method_items" selectitems="product product_definition_formation"/>
      </type>
      <type name="design_pdm_action_request_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_action_request_item" selectitems="versioned_action_request"/>
      </type>
      <type name="design_pdm_approval_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_approval_item" selectitems="action_directive certification configuration_item contract date directed_action document effectivity executed_action general_property_relationship product product_definition product_definition_formation_relationship product_definition_relationship product_definition_formation representation requirement_assignment security_classification shape_aspect_relationship"/>
      </type>
      <type name="design_pdm_attribute_classification_item">
         <select extensible="YES" genericentity="YES" basedon="attribute_classification_item" selectitems="action_directive action_method action_property action_property_representation action_relationship action_request_solution action_request_status alternate_product_relationship applied_action_assignment applied_action_request_assignment applied_approval_assignment applied_certification_assignment applied_document_reference applied_document_usage_constraint_assignment applied_effectivity_assignment applied_event_occurrence_assignment applied_external_identification_assignment applied_identification_assignment applied_person_and_organization_assignment applied_organization_assignment applied_organizational_project_assignment approval approval_person_organization approval_relationship approval_status certification context_dependent_unit contract date_and_time_assignment date_assignment derived_unit descriptive_representation_item document_file document_relationship effectivity event_occurrence_relationship executed_action general_property general_property_relationship language measure_representation_item measure_with_unit named_unit organizational_address organizational_project_relationship organization_relationship person_and_organization person_and_organization_address product product_category product_concept product_concept_context product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition property_definition_representation product_definition_relationship representation representation_context representation_item security_classification time_interval_relationship uncertainty_measure_with_unit versioned_action_request"/>
      </type>
      <type name="design_pdm_certification_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_certification_item" selectitems="alternate_product_relationship product_definition_formation make_from_usage_option"/>
      </type>
      <type name="design_pdm_classification_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_classification_item" selectitems="material_designation"/>
      </type>
      <type name="design_pdm_contract_item">
         <select extensible="YES" genericentity="YES" basedon="contract_item" selectitems="action_directive alternate_product_relationship directed_action organization person_and_organization product product_definition_formation"/>
      </type>
      <type name="design_pdm_date_and_time_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_date_and_time_item" selectitems="action_directive approval_person_organization certification contract directed_action document product_definition security_classification"/>
      </type>
      <type name="design_pdm_date_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_date_item" selectitems="action_directive product_definition directed_action approval_person_organization contract document executed_action security_classification certification"/>
      </type>
      <type name="design_pdm_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_document_reference_item" selectitems="applied_external_identification_assignment assembly_component_usage characterized_object configuration_item descriptive_representation_item externally_defined_item material_designation measure_representation_item product product_category product_definition product_definition_formation property_definition representation representation_item"/>
      </type>
      <type name="design_pdm_groupable_item">
         <select extensible="YES" genericentity="YES" basedon="groupable_item" selectitems="product_definition product_definition_formation property_definition_representation representation representation_item shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="design_pdm_identification_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_identification_item" selectitems="characterized_class configuration_item material_designation person_and_organization product product_category product_concept product_definition_formation organization"/>
      </type>
      <type name="design_pdm_name_item">
         <select extensible="YES" genericentity="YES" basedon="name_item" selectitems="external_class_library product product_definition"/>
      </type>
      <type name="design_pdm_organization_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_organization_item" selectitems="action_directive applied_identification_assignment certification directed_action document product product_definition product_definition_formation product_definition_formation_relationship representation"/>
      </type>
      <type name="design_pdm_person_and_organization_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_person_and_organization_item" selectitems="action_directive applied_identification_assignment certification document product product_definition_formation product_definition_formation_relationship product_definition directed_action"/>
      </type>
      <type name="design_pdm_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assigned_item" selectitems="descriptive_representation_item configuration_item product_definition product_definition_formation product shape_aspect representation"/>
      </type>
      <type name="design_pdm_requirement_source_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_source_item" selectitems="product_definition product_definition_formation product shape_aspect characterized_object product_definition_relationship"/>
      </type>
      <type name="design_pdm_security_classification_item">
         <select extensible="YES" genericentity="YES" basedon="pdm_security_classification_item" selectitems="document make_from_usage_option product_definition_formation product_definition"/>
      </type>
      <type name="dimension_count">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="SELF &gt; 0"/>
      </type>
      <type name="dimension_identification_item">
         <select basedon="identification_item" selectitems="dimensional_size"/>
      </type>
      <type name="dimension_tolerance_document_reference_item">
         <select basedon="document_reference_item" selectitems="dimensional_size externally_defined_dimension_definition"/>
      </type>
      <type name="dimensional_characteristic">
         <select selectitems="dimensional_location dimensional_size"/>
      </type>
      <type name="dm_aliasable_item">
         <select extensible="YES" genericentity="YES" basedon="aliasable_item" selectitems="document_file product product_definition product_definition_formation"/>
      </type>
      <type name="dm_approval_item">
         <select extensible="YES" genericentity="YES" basedon="mri_approval_item" selectitems="product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="dm_attribute_language_item">
         <select extensible="YES" genericentity="YES" basedon="mri_attribute_language_item" selectitems="applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment document_relationship document_usage_role external_source object_role product product_category product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="dm_contract_item">
         <select extensible="YES" genericentity="YES" basedon="contract_item" selectitems="product_definition_formation"/>
      </type>
      <type name="dm_date_and_time_item">
         <select extensible="YES" genericentity="YES" basedon="mri_date_and_time_item" selectitems="document_file product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="dm_date_item">
         <select extensible="YES" genericentity="YES" basedon="mri_date_item" selectitems="document_file product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="dm_identification_item">
         <select extensible="YES" genericentity="YES" basedon="mri_identification_item" selectitems="document_file product product_definition product_definition_formation"/>
      </type>
      <type name="dm_multi_language_attribute_item">
         <select extensible="YES" genericentity="YES" basedon="mri_multi_language_attribute_item" selectitems="applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment document_relationship document_usage_role external_source object_role product product_category product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="dm_organization_item">
         <select extensible="YES" genericentity="YES" basedon="mri_organization_item" selectitems="document_file product product_definition product_definition_formation"/>
      </type>
      <type name="dm_person_and_organization_item">
         <select extensible="YES" genericentity="YES" basedon="mri_person_and_organization_item" selectitems="document_file product product_definition product_definition_formation"/>
      </type>
      <type name="dm_security_classification_item">
         <select extensible="YES" genericentity="YES" basedon="security_classification_item" selectitems="document_file product product_definition product_definition_formation"/>
      </type>
      <type name="document_identifier_assigned_item">
         <select selectitems="document"/>
      </type>
      <type name="document_location_select">
         <select basedon="external_identification_item" selectitems="product_definition"/>
      </type>
      <type name="document_reference_item">
         <select extensible="YES"/>
      </type>
      <type name="effectivity_item">
         <select extensible="YES"/>
      </type>
      <type name="effectivity_item_for_replacement">
         <select basedon="effectivity_item" selectitems="product_definition_relationship"/>
      </type>
      <type name="egt_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="representation"/>
      </type>
      <type name="egt_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="shape_dimension_representation"/>
      </type>
      <type name="egt_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assigned_item" selectitems="statistical_geometric_tolerance statistical_dimensional_size statistical_dimensional_location property_definition"/>
      </type>
      <type name="electric_current_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="event_occurrence_date_and_time_item">
         <select extensible="YES" genericentity="YES" basedon="date_and_time_item" selectitems="event_occurrence"/>
      </type>
      <type name="event_occurrence_date_item">
         <select extensible="YES" genericentity="YES" basedon="date_item" selectitems="event_occurrence"/>
      </type>
      <type name="event_occurrence_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="extent_enumeration">
         <enumeration items="invalid zero finite_non_zero infinite"/>
      </type>
      <type name="external_class_name_item">
         <select basedon="name_item" selectitems="external_class_library"/>
      </type>
      <type name="external_identification_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="file_identification_item">
         <select basedon="identification_item" selectitems="document_file"/>
      </type>
      <type name="file_location_select">
         <select basedon="external_identification_item" selectitems="document_file"/>
      </type>
      <type name="file_version_item">
         <select basedon="versionable_item" selectitems="document_file"/>
      </type>
      <type name="founded_item_select">
         <select selectitems="founded_item representation_item"/>
      </type>
      <type name="fs_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="representation"/>
      </type>
      <type name="fs_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="functional_specification"/>
      </type>
      <type name="ft_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="passage_technology stratum_technology"/>
      </type>
      <type name="ft_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="land_physical_template stratum_technology"/>
      </type>
      <type name="geometric_set_select">
         <select selectitems="point curve surface"/>
      </type>
      <type name="groupable_item">
         <select extensible="YES" genericentity="YES"/>
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.GROUP' IN TYPEOF(SELF))"/>
      </type>
      <type name="hour_in_day">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 0 &lt;= SELF &lt; 24 }"/>
      </type>
      <type name="id_attribute_select">
         <select selectitems="action address application_context group organizational_project product_category property_definition representation shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="id_for_class">
         <select basedon="identification_item" selectitems="product_class product_concept_feature"/>
      </type>
      <type name="id_for_product_identification">
         <select basedon="identification_item" selectitems="product_identification"/>
      </type>
      <type name="identification_item">
         <select extensible="YES"/>
      </type>
      <type name="identifier">
         <builtintype type="STRING"/>
      </type>
      <type name="idrm_marked_item">
         <select extensible="YES" basedon="classification_item" selectitems="product_definition document_file"/>
      </type>
      <type name="knot_type">
         <enumeration items="uniform_knots quasi_uniform_knots piecewise_bezier_knots unspecified"/>
      </type>
      <type name="label">
         <builtintype type="STRING"/>
      </type>
      <type name="length_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="limit_condition">
         <enumeration items="maximum_material_condition least_material_condition regardless_of_feature_size"/>
      </type>
      <type name="list_of_reversible_topology_item">
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="list_representation_item">
         <aggregate type="LIST" lower="1" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="luminous_intensity_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="mass_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="measure_value">
         <select selectitems="amount_of_substance_measure area_measure celsius_temperature_measure context_dependent_measure count_measure descriptive_measure electric_current_measure length_measure luminous_intensity_measure mass_measure numeric_measure parameter_value plane_angle_measure positive_length_measure positive_plane_angle_measure positive_ratio_measure ratio_measure solid_angle_measure thermodynamic_temperature_measure time_measure volume_measure"/>
      </type>
      <type name="message">
         <builtintype type="STRING"/>
      </type>
      <type name="minute_in_hour">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 0 &lt;= SELF &lt;= 59 }"/>
      </type>
      <type name="model_parameter_assigned_item">
         <select selectitems="unit"/>
      </type>
      <type name="month_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 1 &lt;= SELF &lt;= 12 }"/>
      </type>
      <type name="mp_action_method_items">
         <select extensible="YES" genericentity="YES" basedon="action_method_items" selectitems="test_method_based_parameter_assignment"/>
      </type>
      <type name="mp_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="model_parameter"/>
      </type>
      <type name="mp_groupable_item">
         <select extensible="YES" genericentity="YES" basedon="groupable_item" selectitems="group_relationship"/>
      </type>
      <type name="mri_aliasable_item">
         <select extensible="YES" basedon="aliasable_item" selectitems="approval_status contract organization security_classification_level"/>
      </type>
      <type name="mri_approval_item">
         <select extensible="YES" genericentity="YES" basedon="approval_item" selectitems="certification contract"/>
      </type>
      <type name="mri_attribute_language_item">
         <select extensible="YES" genericentity="YES" basedon="attribute_language_item" selectitems="applied_organizational_project_assignment approval approval_relationship approval_status certification certification_type contract date_role date_time_role identification_role organization_relationship organizational_project organizational_project_relationship organizational_project_role person_and_organization"/>
      </type>
      <type name="mri_date_and_time_item">
         <select extensible="YES" genericentity="YES" basedon="date_and_time_item" selectitems="applied_organization_assignment applied_person_and_organization_assignment applied_security_classification_assignment certification contract security_classification"/>
      </type>
      <type name="mri_date_item">
         <select extensible="YES" genericentity="YES" basedon="date_item" selectitems="applied_organization_assignment applied_person_and_organization_assignment applied_security_classification_assignment certification contract security_classification"/>
      </type>
      <type name="mri_identification_item">
         <select extensible="YES" genericentity="YES" basedon="identification_item" selectitems="approval_status contract organization security_classification_level"/>
      </type>
      <type name="mri_multi_language_attribute_item">
         <select extensible="YES" genericentity="YES" basedon="multi_language_attribute_item" selectitems="applied_organizational_project_assignment approval approval_relationship approval_status certification certification_type contract date_role date_time_role identification_role organization_relationship organizational_project organizational_project_relationship organizational_project_role person_and_organization"/>
      </type>
      <type name="mri_organization_item">
         <select extensible="YES" genericentity="YES" basedon="organization_item" selectitems="applied_identification_assignment applied_security_classification_assignment contract"/>
      </type>
      <type name="mri_person_and_organization_item">
         <select extensible="YES" genericentity="YES" basedon="person_and_organization_item" selectitems="applied_identification_assignment applied_security_classification_assignment contract"/>
      </type>
      <type name="multi_language_attribute_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="name_attribute_select">
         <select selectitems="action_request_solution address configuration_design context_dependent_shape_representation derived_unit effectivity person_and_organization product_definition product_definition_substitute property_definition_representation"/>
      </type>
      <type name="name_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="nfdv_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assigned_item" selectitems="component_functional_unit"/>
      </type>
      <type name="nfuv_groupable_item">
         <select extensible="YES" genericentity="YES" basedon="groupable_item" selectitems="shape_aspect"/>
      </type>
      <type name="numeric_measure">
         <builtintype type="NUMBER"/>
      </type>
      <type name="organization_item">
         <select extensible="YES"/>
      </type>
      <type name="parameter_value">
         <builtintype type="REAL"/>
      </type>
      <type name="pcurve_or_surface">
         <select selectitems="pcurve surface"/>
      </type>
      <type name="pdm_action_items">
         <select extensible="YES" genericentity="YES" basedon="action_items" selectitems="configuration_effectivity product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="pdm_action_request_item">
         <select extensible="YES" genericentity="YES" basedon="action_request_item" selectitems="product_definition product_definition_formation product_definition_relationship property_definition"/>
      </type>
      <type name="pdm_approval_item">
         <select extensible="YES" genericentity="YES" basedon="approval_item" selectitems="action applied_action_assignment configuration_effectivity versioned_action_request"/>
      </type>
      <type name="pdm_attribute_language_item">
         <select extensible="YES" genericentity="YES" basedon="attribute_language_item" selectitems="applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment applied_organizational_project_assignment approval approval_relationship approval_status certification certification_type contract date_role date_time_role document_relationship document_usage_role external_source identification_role object_role organization_relationship organizational_project organizational_project_relationship organizational_project_role person_and_organization product product_category product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="pdm_certification_item">
         <select extensible="YES" basedon="certification_item" selectitems="product_definition_formation_relationship"/>
      </type>
      <type name="pdm_classification_item">
         <select extensible="YES" genericentity="YES" basedon="classification_item" selectitems="action action_directive action_method action_property action_relationship action_request_solution action_request_status address alternate_product_relationship applied_action_assignment applied_action_request_assignment applied_approval_assignment applied_certification_assignment applied_contract_assignment applied_date_and_time_assignment applied_date_assignment applied_document_reference applied_document_usage_constraint_assignment applied_effectivity_assignment applied_event_occurrence_assignment applied_external_identification_assignment applied_identification_assignment applied_organization_assignment applied_organizational_project_assignment applied_person_and_organization_assignment applied_security_classification_assignment approval approval_person_organization approval_relationship approval_status assembly_component_usage_substitute calendar_date certification class configuration_item context_dependent_unit contract conversion_based_unit date_and_time date_and_time_assignment date_assignment derived_unit descriptive_representation_item directed_action document_file document_relationship effectivity event_occurrence executed_action general_property general_property_relationship group identification_assignment language measure_representation_item measure_with_unit multi_language_attribute_assignment named_unit organization organization_relationship organizational_address organizational_project organizational_project_relationship person person_and_organization_address product product_category product_concept product_definition product_definition_context product_definition_formation product_definition_formation_relationship product_definition_relationship property_definition property_definition_representation representation representation_context representation_item security_classification uncertainty_measure_with_unit versioned_action_request"/>
      </type>
      <type name="pdm_date_and_time_item">
         <select extensible="YES" genericentity="YES" basedon="date_and_time_item" selectitems="action applied_action_assignment executed_action versioned_action_request"/>
      </type>
      <type name="pdm_date_item">
         <select extensible="YES" genericentity="YES" basedon="date_item" selectitems="action applied_action_assignment versioned_action_request"/>
      </type>
      <type name="pdm_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="action_method executed_action product_definition_formation_relationship shape_aspect shape_aspect_relationship versioned_action_request"/>
      </type>
      <type name="pdm_effectivity_item">
         <select extensible="YES" genericentity="YES" basedon="effectivity_item" selectitems="product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="pdm_event_occurrence_item">
         <select extensible="YES" genericentity="YES" basedon="event_occurrence_item" selectitems="organizational_project"/>
      </type>
      <type name="pdm_external_class_name_item">
         <select extensible="YES" genericentity="YES" basedon="name_item" selectitems="assembly_component_usage external_class_library"/>
      </type>
      <type name="pdm_identification_item">
         <select extensible="YES" genericentity="YES" basedon="identification_item" selectitems="shape_aspect_relationship"/>
      </type>
      <type name="pdm_multi_language_attribute_item">
         <select extensible="YES" genericentity="YES" basedon="multi_language_attribute_item" selectitems="applied_document_reference applied_document_usage_constraint_assignment applied_external_identification_assignment applied_organizational_project_assignment approval approval_relationship approval_status certification certification_type contract date_role date_time_role document_relationship document_usage_role external_source identification_role object_role organization_relationship organizational_project organizational_project_relationship organizational_project_role person_and_organization product product_category product_definition product_definition_formation product_definition_relationship"/>
      </type>
      <type name="pdm_organization_item">
         <select extensible="YES" genericentity="YES" basedon="organization_item" selectitems="action applied_action_assignment approval configuration_item contract executed_action security_classification versioned_action_request"/>
      </type>
      <type name="pdm_person_and_organization_item">
         <select extensible="YES" genericentity="YES" basedon="person_and_organization_item" selectitems="action applied_action_assignment approval configuration_item contract executed_action security_classification versioned_action_request"/>
      </type>
      <type name="pdm_project_item">
         <select extensible="YES" genericentity="YES" basedon="project_item" selectitems="executed_action product_concept"/>
      </type>
      <type name="pdm_security_classification_item">
         <select extensible="YES" genericentity="YES" basedon="security_classification_item" selectitems="assembly_component_usage"/>
      </type>
      <type name="pdm_time_interval_item">
         <select extensible="YES" basedon="time_interval_item" selectitems="action"/>
      </type>
      <type name="pdpdms_external_identification_item">
         <select extensible="YES" basedon="external_identification_item" selectitems="action_relationship action_request_status applied_organization_assignment applied_person_and_organization_assignment approval approval_status date_assignment date_and_time_assignment organizational_address security_classification versioned_action_request"/>
      </type>
      <type name="pdpdms_person_and_organization_item">
         <select extensible="YES" basedon="person_and_organization_item" selectitems="person_and_organization"/>
      </type>
      <type name="person_and_organization_item">
         <select extensible="YES"/>
      </type>
      <type name="person_organization_select">
         <select selectitems="organization person person_and_organization"/>
      </type>
      <type name="plane_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="plib_class_identification_item">
         <select basedon="external_identification_item" selectitems="externally_defined_class"/>
      </type>
      <type name="plib_class_organization_item">
         <select basedon="organization_item" selectitems="class"/>
      </type>
      <type name="plt_groupable_item">
         <select basedon="groupable_item" selectitems="representation_item"/>
      </type>
      <type name="positive_length_measure">
         <typename name="length_measure"/>
         <where label="WR1" expression="SELF &gt; 0.0"/>
      </type>
      <type name="positive_plane_angle_measure">
         <typename name="plane_angle_measure"/>
         <where label="WR1" expression="SELF &gt; 0.0"/>
      </type>
      <type name="positive_ratio_measure">
         <typename name="ratio_measure"/>
         <where label="WR1" expression="SELF &gt; 0.0"/>
      </type>
      <type name="pr_action_items">
         <select extensible="YES" genericentity="YES" basedon="action_items" selectitems="product_definition_formation"/>
      </type>
      <type name="pr_date_and_time_item">
         <select extensible="YES" genericentity="YES" basedon="date_and_time_item" selectitems="rule_action"/>
      </type>
      <type name="pr_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="rule_set"/>
      </type>
      <type name="pr_identification_item">
         <select extensible="YES" genericentity="YES" basedon="identification_item" selectitems="rule_set"/>
      </type>
      <type name="preferred_surface_curve_representation">
         <enumeration items="curve_3d pcurve_s1 pcurve_s2"/>
      </type>
      <type name="product_definition_or_assembly_relationship">
         <select selectitems="assembly_component_usage product_definition"/>
      </type>
      <type name="product_or_formation_or_definition">
         <select selectitems="product product_definition_formation product_definition"/>
      </type>
      <type name="project_as_date_and_time_item">
         <select basedon="date_and_time_item" selectitems="organizational_project"/>
      </type>
      <type name="project_as_date_item">
         <select basedon="date_item" selectitems="organizational_project"/>
      </type>
      <type name="project_event_occurrence_item">
         <select extensible="YES" genericentity="YES" basedon="event_occurrence_item" selectitems="organizational_project"/>
      </type>
      <type name="project_item">
         <select extensible="YES"/>
      </type>
      <type name="promissory_usage_in_product_model_assigned_item">
         <select selectitems="product_concept product_definition"/>
      </type>
      <type name="property_or_shape_select">
         <select selectitems="property_definition shape_definition"/>
      </type>
      <type name="ptswp_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="shape_representation"/>
      </type>
      <type name="ptswp_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assigned_item" selectitems="shape_representation"/>
      </type>
      <type name="puipc_security_classification_item">
         <select extensible="YES" genericentity="YES" basedon="security_classification_item" selectitems="promissory_usage_in_product_concept_relationship"/>
      </type>
      <type name="puswp_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="shape_representation"/>
      </type>
      <type name="puswp_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assigned_item" selectitems="shape_representation"/>
      </type>
      <type name="puuv_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="shape_aspect"/>
      </type>
      <type name="puuv_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="requirement_assigned_item" selectitems="shape_aspect"/>
      </type>
      <type name="ratio_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="rd_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="predefined_requirement_view_definition"/>
      </type>
      <type name="rd_groupable_item">
         <select extensible="YES" genericentity="YES" basedon="groupable_item" selectitems="predefined_requirement_view_definition"/>
      </type>
      <type name="representation_identification_item">
         <select basedon="identification_item" selectitems="shape_representation"/>
      </type>
      <type name="representation_version_item">
         <select basedon="versionable_item" selectitems="shape_representation"/>
      </type>
      <type name="represented_definition">
         <select selectitems="general_property property_definition property_definition_relationship shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="requirement_assigned_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="requirement_identification_and_version_mri_identification_item">
         <select extensible="YES" genericentity="YES" basedon="mri_identification_item" selectitems="product product_definition_formation"/>
      </type>
      <type name="requirement_source_item">
         <select extensible="YES" genericentity="YES"/>
      </type>
      <type name="reversible_topology">
         <select selectitems="reversible_topology_item list_of_reversible_topology_item set_of_reversible_topology_item"/>
      </type>
      <type name="reversible_topology_item">
         <select selectitems="edge path face face_bound closed_shell open_shell"/>
      </type>
      <type name="role_select">
         <select selectitems="action_assignment action_request_assignment approval_assignment approval_date_time certification_assignment contract_assignment document_reference effectivity_assignment external_referent_assignment group_assignment name_assignment security_classification_assignment"/>
      </type>
      <type name="rule_superseded_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <type name="s_external_identification_item">
         <select extensible="YES" genericentity="YES" basedon="external_identification_item" selectitems="composite_signal_property_relationship property_definition signal"/>
      </type>
      <type name="sd_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="document_reference_item" selectitems="configuration_item product product_definition product_definition_formation"/>
      </type>
      <type name="second_in_minute">
         <builtintype type="REAL"/>
         <where label="WR1" expression="{ 0 &lt;= SELF &lt;= 60.0 }"/>
      </type>
      <type name="security_classification_item">
         <select extensible="YES"/>
      </type>
      <type name="set_of_reversible_topology_item">
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="reversible_topology_item"/>
      </type>
      <type name="set_representation_item">
         <aggregate type="SET" lower="1" upper="?"/>
         <typename name="representation_item"/>
      </type>
      <type name="shape_definition">
         <select selectitems="product_definition_shape shape_aspect shape_aspect_relationship"/>
      </type>
      <type name="shape_tolerance_select">
         <select selectitems="geometric_tolerance plus_minus_tolerance"/>
      </type>
      <type name="shell">
         <select selectitems="vertex_shell wire_shell open_shell closed_shell"/>
      </type>
      <type name="si_prefix">
         <enumeration items="exa peta tera giga mega kilo hecto deca deci centi milli micro nano pico femto atto"/>
      </type>
      <type name="si_unit_name">
         <enumeration items="metre gram second ampere kelvin mole candela radian steradian hertz newton pascal joule watt coulomb volt farad ohm siemens weber tesla henry degree_Celsius lumen lux becquerel gray sievert"/>
      </type>
      <type name="solid_angle_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="source">
         <enumeration items="made bought not_known"/>
      </type>
      <type name="source_item">
         <select selectitems="identifier message"/>
      </type>
      <type name="specification_for_category">
         <select basedon="groupable_item" selectitems="package_product_concept_feature product_concept_feature"/>
      </type>
      <type name="spr_document_reference_item">
         <select basedon="document_reference_item" selectitems="product product_definition product_definition_formation"/>
      </type>
      <type name="spr_organization_item">
         <select extensible="YES" basedon="organization_item" selectitems="product product_definition product_definition_formation"/>
      </type>
      <type name="spr_person_and_organization_item">
         <select extensible="YES" basedon="person_and_organization_item" selectitems="product product_definition product_definition_formation"/>
      </type>
      <type name="string_representation_item_select">
         <select selectitems="descriptive_representation_item included_text_block structured_text_composition"/>
      </type>
      <type name="supported_item">
         <select selectitems="action action_directive action_method"/>
      </type>
      <type name="surface_boundary">
         <select selectitems="boundary_curve degenerate_pcurve"/>
      </type>
      <type name="surface_model">
         <select selectitems="shell_based_surface_model face_based_surface_model"/>
      </type>
      <type name="text">
         <builtintype type="STRING"/>
      </type>
      <type name="thermodynamic_temperature_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="time_interval_item">
         <select extensible="YES"/>
      </type>
      <type name="time_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="tolerance_method_definition">
         <select selectitems="tolerance_value limits_and_fits"/>
      </type>
      <type name="transformation">
         <select selectitems="item_defined_transformation functionally_defined_transformation"/>
      </type>
      <type name="transition_code">
         <enumeration items="discontinuous continuous cont_same_gradient cont_same_gradient_same_curvature"/>
      </type>
      <type name="trimming_preference">
         <enumeration items="cartesian parameter unspecified"/>
      </type>
      <type name="trimming_select">
         <select selectitems="cartesian_point parameter_value"/>
      </type>
      <type name="unit">
         <select selectitems="derived_unit named_unit"/>
      </type>
      <type name="value_qualifier">
         <select selectitems="precision_qualifier type_qualifier uncertainty_qualifier"/>
      </type>
      <type name="vector_or_direction">
         <select selectitems="vector direction"/>
      </type>
      <type name="version_for_class">
         <select basedon="versionable_item" selectitems="product_class product_concept_feature"/>
      </type>
      <type name="version_for_product_identification">
         <select basedon="versionable_item" selectitems="product_identification"/>
      </type>
      <type name="versionable_item">
         <select extensible="YES"/>
      </type>
      <type name="volume_measure">
         <builtintype type="REAL"/>
      </type>
      <type name="week_in_year_number">
         <builtintype type="INTEGER"/>
         <where label="WR1" expression="{ 1 &lt;= SELF &lt;= 53 }"/>
      </type>
      <type name="wireframe_model">
         <select selectitems="shell_based_wireframe_model edge_based_wireframe_model"/>
      </type>
      <type name="year_number">
         <builtintype type="INTEGER"/>
      </type>
      <entity name="absorbed_dose_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\absorbed_dose_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = gray"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="abstract_variable" supertypes="property_definition property_definition_representation representation representation_item"/>
      <entity name="across_port_variable" supertypes="port_variable"/>
      <entity name="action">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="chosen_method">
            <typename name="action_method"/>
         </explicit>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="action_assignment" abstract.supertype="YES">
         <explicit name="assigned_action">
            <typename name="action"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="action_directive">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="analysis">
            <typename name="text"/>
         </explicit>
         <explicit name="comment">
            <typename name="text"/>
         </explicit>
         <explicit name="requests">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_method">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="consequence">
            <typename name="text"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="action_method_assignment" abstract.supertype="YES">
         <explicit name="assigned_action_method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="role">
            <typename name="action_method_role"/>
         </explicit>
      </entity>
      <entity name="action_method_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="related_method">
            <typename name="action_method"/>
         </explicit>
      </entity>
      <entity name="action_method_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="action_property">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_action_definition"/>
         </explicit>
      </entity>
      <entity name="action_property_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_action_property">
            <typename name="action_property"/>
         </explicit>
         <explicit name="related_action_property">
            <typename name="action_property"/>
         </explicit>
         <where label="WR1" expression="relating_action_property :&lt;&gt;: related_action_property"/>
      </entity>
      <entity name="action_property_representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="property">
            <typename name="action_property"/>
         </explicit>
         <explicit name="representation">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="action_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_action">
            <typename name="action"/>
         </explicit>
         <explicit name="related_action">
            <typename name="action"/>
         </explicit>
      </entity>
      <entity name="action_request_assignment" abstract.supertype="YES">
         <explicit name="assigned_action_request">
            <typename name="versioned_action_request"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="action_request_solution">
         <explicit name="method">
            <typename name="action_method"/>
         </explicit>
         <explicit name="request">
            <typename name="versioned_action_request"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="action_request_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="action_resource">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="usage">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="supported_item"/>
         </explicit>
         <explicit name="kind">
            <typename name="action_resource_type"/>
         </explicit>
      </entity>
      <entity name="action_resource_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_resource">
            <typename name="action_resource"/>
         </explicit>
         <explicit name="related_resource">
            <typename name="action_resource"/>
         </explicit>
      </entity>
      <entity name="action_resource_requirement">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="resource_requirement_type"/>
         </explicit>
         <explicit name="operations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="characterized_action_definition"/>
         </explicit>
      </entity>
      <entity name="action_resource_requirement_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_action_resource_requirement">
            <typename name="action_resource_requirement"/>
         </explicit>
         <explicit name="related_action_resource_requirement">
            <typename name="action_resource_requirement"/>
         </explicit>
         <where label="WR1" expression="relating_action_resource_requirement :&lt;&gt;: &#10;       related_action_resource_requirement"/>
      </entity>
      <entity name="action_resource_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="action_status">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="assigned_action">
            <typename name="executed_action"/>
         </explicit>
      </entity>
      <entity name="activity_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\activity_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = becquerel"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="address">
         <explicit name="internal_location" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="street" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_box" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="town" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="region" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="postal_code" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="country" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="facsimile_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telephone_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="electronic_mail_address" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="telex_number" optional="YES">
            <typename name="label"/>
         </explicit>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <derived name="url" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="EXISTS(internal_location)OR  EXISTS(street_number)OR  EXISTS(street)OR  EXISTS(postal_box)OR  EXISTS(town)OR  EXISTS(region)OR  EXISTS(postal_code)OR  EXISTS(country)OR  EXISTS(facsimile_number)OR  EXISTS(telephone_number)OR  EXISTS(electronic_mail_address)OR EXISTS(telex_number)"/>
      </entity>
      <entity name="alternate_product_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="alternate">
            <typename name="product"/>
         </explicit>
         <explicit name="base">
            <typename name="product"/>
         </explicit>
         <explicit name="basis">
            <typename name="text"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="alternate"/>
            <unique.attribute attribute="base"/>
         </unique>
         <where label="WR1" expression="alternate :&lt;&gt;: base"/>
      </entity>
      <entity name="amount_of_substance_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="amount_of_substance_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="analog_analytical_model_port" supertypes="analytical_model_port"/>
      <entity name="analog_port_variable" supertypes="representation representation_item"/>
      <entity name="analytical_model" supertypes="representation">
         <unique label="UR1">
            <unique.attribute entity-ref="representation" attribute="name"/>
         </unique>
      </entity>
      <entity name="analytical_model_definition" supertypes="product_definition"/>
      <entity name="analytical_model_make_from_relationship" supertypes="product_definition_relationship">
         <explicit name="related_product_definition">
            <typename name="analytical_model_definition"/>
            <redeclaration entity-ref="product_definition_relationship"/>
         </explicit>
         <explicit name="relating_product_definition">
            <typename name="analytical_model_definition"/>
            <redeclaration entity-ref="product_definition_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="relating_product_definition"/>
            <unique.attribute attribute="related_product_definition"/>
         </unique>
      </entity>
      <entity name="analytical_model_parameter" supertypes="model_parameter"/>
      <entity name="analytical_model_port" supertypes="representation" super.expression="analytical_model_vector_port ANDOR ONEOF (analog_analytical_model_port, digital_analytical_model_port)"/>
      <entity name="analytical_model_port_assignment" supertypes="property_definition_representation representation_relationship"/>
      <entity name="analytical_model_scalar_port" supertypes="analytical_model_vector_port"/>
      <entity name="analytical_model_vector_port" supertypes="analytical_model_port compound_representation_item"/>
      <entity name="analytical_representation" supertypes="representation">
         <unique label="UR1">
            <unique.attribute entity-ref="representation" attribute="name"/>
         </unique>
      </entity>
      <entity name="angular_location" supertypes="dimensional_location">
         <explicit name="angle_selection">
            <typename name="angle_relator"/>
         </explicit>
      </entity>
      <entity name="angular_size" supertypes="dimensional_size">
         <explicit name="angle_selection">
            <typename name="angle_relator"/>
         </explicit>
      </entity>
      <entity name="angularity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt; 3"/>
      </entity>
      <entity name="apex" supertypes="derived_shape_aspect"/>
      <entity name="application_context">
         <explicit name="application">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <inverse name="context_elements" entity="application_context_element" attribute="frame_of_reference">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="application_context_element" super.expression="ONEOF (library_context, product_concept_context, product_context, product_definition_context)">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="application_context_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_context">
            <typename name="application_context"/>
         </explicit>
         <explicit name="related_context">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="application_protocol_definition">
         <explicit name="status">
            <typename name="label"/>
         </explicit>
         <explicit name="application_interpreted_model_schema_name">
            <typename name="label"/>
         </explicit>
         <explicit name="application_protocol_year">
            <typename name="year_number"/>
         </explicit>
         <explicit name="application">
            <typename name="application_context"/>
         </explicit>
      </entity>
      <entity name="applied_action_assignment" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_items"/>
         </explicit>
      </entity>
      <entity name="applied_action_method_assignment" supertypes="action_method_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_method_items"/>
         </explicit>
      </entity>
      <entity name="applied_action_request_assignment" supertypes="action_request_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_request_item"/>
         </explicit>
      </entity>
      <entity name="applied_approval_assignment" supertypes="approval_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="approval_item"/>
         </explicit>
      </entity>
      <entity name="applied_attribute_classification_assignment" supertypes="attribute_classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="attribute_classification_item"/>
         </explicit>
         <explicit name="assigned_class">
            <typename name="class"/>
            <redeclaration entity-ref="attribute_classification_assignment"/>
         </explicit>
      </entity>
      <entity name="applied_certification_assignment" supertypes="certification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="certification_item"/>
         </explicit>
      </entity>
      <entity name="applied_classification_assignment" supertypes="classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_contract_assignment" supertypes="contract_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="contract_item"/>
         </explicit>
      </entity>
      <entity name="applied_date_and_time_assignment" supertypes="date_and_time_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="date_and_time_item"/>
         </explicit>
      </entity>
      <entity name="applied_date_assignment" supertypes="date_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="date_item"/>
         </explicit>
      </entity>
      <entity name="applied_document_reference" supertypes="document_reference">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document_reference_item"/>
         </explicit>
      </entity>
      <entity name="applied_document_usage_constraint_assignment" supertypes="document_usage_constraint_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document_reference_item"/>
         </explicit>
      </entity>
      <entity name="applied_effectivity_assignment" supertypes="effectivity_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="effectivity_item"/>
         </explicit>
      </entity>
      <entity name="applied_event_occurrence_assignment" supertypes="event_occurrence_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="event_occurrence_item"/>
         </explicit>
      </entity>
      <entity name="applied_external_identification_assignment" supertypes="external_identification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="external_identification_item"/>
         </explicit>
      </entity>
      <entity name="applied_group_assignment" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="groupable_item"/>
         </explicit>
      </entity>
      <entity name="applied_identification_assignment" supertypes="identification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="identification_item"/>
         </explicit>
      </entity>
      <entity name="applied_name_assignment" supertypes="name_assignment">
         <explicit name="item">
            <typename name="name_item"/>
         </explicit>
      </entity>
      <entity name="applied_organization_assignment" supertypes="organization_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization_item"/>
         </explicit>
      </entity>
      <entity name="applied_organizational_project_assignment" supertypes="organizational_project_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="project_item"/>
         </explicit>
      </entity>
      <entity name="applied_person_and_organization_assignment" supertypes="person_and_organization_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person_and_organization_item"/>
         </explicit>
      </entity>
      <entity name="applied_security_classification_assignment" supertypes="security_classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="security_classification_item"/>
         </explicit>
      </entity>
      <entity name="applied_time_interval_assignment" supertypes="time_interval_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="time_interval_item"/>
         </explicit>
      </entity>
      <entity name="approval">
         <explicit name="status">
            <typename name="approval_status"/>
         </explicit>
         <explicit name="level">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="approval_assignment" abstract.supertype="YES">
         <explicit name="assigned_approval">
            <typename name="approval"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="approval_date_time">
         <explicit name="date_time">
            <typename name="date_time_select"/>
         </explicit>
         <explicit name="dated_approval">
            <typename name="approval"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="approval_person_organization">
         <explicit name="person_organization">
            <typename name="person_organization_select"/>
         </explicit>
         <explicit name="authorized_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="role">
            <typename name="approval_role"/>
         </explicit>
      </entity>
      <entity name="approval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_approval">
            <typename name="approval"/>
         </explicit>
         <explicit name="related_approval">
            <typename name="approval"/>
         </explicit>
      </entity>
      <entity name="approval_role">
         <explicit name="role">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="approval_status">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="area_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="area_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 2.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="assembly_component_usage" supertypes="product_definition_usage" super.expression="ONEOF (next_assembly_usage_occurrence, specified_higher_usage_occurrence, promissory_usage_occurrence)">
         <explicit name="reference_designator" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="assembly_component_usage_substitute">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definition" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="base">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="substitute">
            <typename name="assembly_component_usage"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="base"/>
            <unique.attribute attribute="substitute"/>
         </unique>
         <where label="WR1" expression="base.relating_product_definition :=:&#10;       substitute.relating_product_definition"/>
         <where label="WR2" expression="base :&lt;&gt;: substitute"/>
      </entity>
      <entity name="assembly_component_usage_substitute_with_ranking" supertypes="assembly_component_usage_substitute">
         <explicit name="ranking">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="ranking_rationale">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="assigned_requirement" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="product_definition"/>
         </explicit>
         <explicit name="assigned_group">
            <typename name="requirement_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
      </entity>
      <entity name="atomic_formula" supertypes="compound_representation_item"/>
      <entity name="attribute_assertion" supertypes="fact_type property_definition_representation representation"/>
      <entity name="attribute_classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_class">
            <typename name="group"/>
         </explicit>
         <explicit name="attribute_name">
            <typename name="label"/>
         </explicit>
         <explicit name="role">
            <typename name="classification_role"/>
         </explicit>
      </entity>
      <entity name="attribute_language_assignment" supertypes="attribute_classification_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="attribute_language_item"/>
         </explicit>
         <explicit name="assigned_class">
            <typename name="language"/>
            <redeclaration entity-ref="attribute_classification_assignment"/>
         </explicit>
         <where label="WR1" expression="SELF\attribute_classification_assignment.role.name IN ['primary', 'translated']"/>
         <where label="WR2" expression="SELF\attribute_classification_assignment.attribute_name&lt;&gt; ''"/>
      </entity>
      <entity name="attribute_value_assignment" abstract.supertype="YES">
         <explicit name="attribute_name">
            <typename name="label"/>
         </explicit>
         <explicit name="attribute_value">
            <typename name="attribute_type"/>
         </explicit>
         <explicit name="role">
            <typename name="attribute_value_role"/>
         </explicit>
      </entity>
      <entity name="attribute_value_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="auxiliary_characteristic_dimension_representation" supertypes="dimensional_characteristic_representation"/>
      <entity name="axis1_placement" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="z" expression="NVL(normalise(axis), dummy_gri ||&#10;                                 direction([0.0,0.0,1.0]))">
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim  = 3"/>
      </entity>
      <entity name="axis2_placement_2d" supertypes="placement">
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_2axes(ref_direction)">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="axis2_placement_3d" supertypes="placement">
         <explicit name="axis" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="ref_direction" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="p" expression="build_axes(axis,ref_direction)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\placement.location.dim = 3"/>
         <where label="WR2" expression="(NOT(EXISTS(axis)))OR(axis.dim = 3)"/>
         <where label="WR3" expression="(NOT(EXISTS(ref_direction)))OR(ref_direction.dim = 3)"/>
         <where label="WR4" expression="(NOT(EXISTS(axis)))OR(NOT(EXISTS(ref_direction)))OR&#10;         (cross_product(axis,ref_direction).magnitude &gt; 0.0)"/>
      </entity>
      <entity name="b_spline_curve" supertypes="bounded_curve" super.expression="ONEOF (uniform_curve, b_spline_curve_with_knots, quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve">
         <explicit name="degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="curve_form">
            <typename name="b_spline_curve_form"/>
         </explicit>
         <explicit name="closed_curve">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="control_points" expression="list_to_array(control_points_list,0,&#10;                                             upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <derived name="upper_index_on_control_points" expression="(SIZEOF(control_points_list)- 1)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.UNIFORM_CURVE' IN  TYPEOF(self))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.QUASI_UNIFORM_CURVE' IN  TYPEOF(self))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BEZIER_CURVE' IN  TYPEOF(self))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self))"/>
      </entity>
      <entity name="b_spline_curve_with_knots" supertypes="b_spline_curve">
         <explicit name="knot_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="upper_index_on_knots" expression="SIZEOF(knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="constraints_param_b_spline(degree, upper_index_on_knots,&#10;                               upper_index_on_control_points,&#10;                               knot_multiplicities, knots)"/>
         <where label="WR2" expression="SIZEOF(knot_multiplicities)= upper_index_on_knots"/>
      </entity>
      <entity name="b_spline_surface" supertypes="bounded_surface" super.expression="ONEOF (b_spline_surface_with_knots, uniform_surface, quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface">
         <explicit name="u_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="surface_form">
            <typename name="b_spline_surface_form"/>
         </explicit>
         <explicit name="u_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="v_closed">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="control_points" expression="make_array_of_array(control_points_list,&#10;                                              0,u_upper,0,v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <derived name="u_upper" expression="SIZEOF(control_points_list)- 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="v_upper" expression="SIZEOF(control_points_list[1])- 1">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.UNIFORM_SURFACE' IN  TYPEOF(SELF))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.QUASI_UNIFORM_SURFACE' IN  TYPEOF(SELF))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BEZIER_SURFACE' IN  TYPEOF(SELF))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="b_spline_surface_with_knots" supertypes="b_spline_surface">
         <explicit name="u_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="u_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="knot_spec">
            <typename name="knot_type"/>
         </explicit>
         <derived name="knot_u_upper" expression="SIZEOF(u_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="knot_v_upper" expression="SIZEOF(v_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="constraints_param_b_spline(SELF\b_spline_surface.u_degree,&#10;                   knot_u_upper, SELF\b_spline_surface.u_upper,&#10;                               u_multiplicities, u_knots)"/>
         <where label="WR2" expression="constraints_param_b_spline(SELF\b_spline_surface.v_degree,&#10;                   knot_v_upper, SELF\b_spline_surface.v_upper,&#10;                               v_multiplicities, v_knots)"/>
         <where label="WR3" expression="SIZEOF(u_multiplicities)= knot_u_upper"/>
         <where label="WR4" expression="SIZEOF(v_multiplicities)= knot_v_upper"/>
      </entity>
      <entity name="b_spline_volume" supertypes="volume" super.expression="ONEOF (b_spline_volume_with_knots, uniform_volume, quasi_uniform_volume, bezier_volume) ANDOR rational_b_spline_volume">
         <explicit name="u_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="w_degree">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="control_points_list">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <derived name="control_points" expression="make_array_of_array_of_array(control_points_list,&#10;                                              0,u_upper,0,v_upper,&#10;                                              0,w_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <typename name="cartesian_point"/>
         </derived>
         <derived name="u_upper" expression="SIZEOF(control_points_list)- 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="v_upper" expression="SIZEOF(control_points_list[1])- 1">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="w_upper" expression="SIZEOF(control_points_list[1][1])- 1">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BEZIER_VOLUME' IN  TYPEOF(SELF))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.UNIFORM_VOLUME' IN  TYPEOF(SELF))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.QUASI_UNIFORM_VOLUME' IN  TYPEOF(SELF))OR&#10;       ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="b_spline_volume_with_knots" supertypes="b_spline_volume">
         <explicit name="u_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="v_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="w_multiplicities">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="u_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="w_knots">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="parameter_value"/>
         </explicit>
         <derived name="knot_u_upper" expression="SIZEOF(u_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="knot_v_upper" expression="SIZEOF(v_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="knot_w_upper" expression="SIZEOF(w_knots)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="constraints_param_b_spline(SELF\b_spline_volume.u_degree,&#10;                   knot_u_upper, SELF\b_spline_volume.u_upper,&#10;                               u_multiplicities, u_knots)"/>
         <where label="WR2" expression="constraints_param_b_spline(SELF\b_spline_volume.v_degree,&#10;                   knot_v_upper, SELF\b_spline_volume.v_upper,&#10;                               v_multiplicities, v_knots)"/>
         <where label="WR3" expression="constraints_param_b_spline(SELF\b_spline_volume.w_degree,&#10;                   knot_w_upper, SELF\b_spline_volume.w_upper,&#10;                               w_multiplicities, w_knots)"/>
         <where label="WR4" expression="SIZEOF(u_multiplicities)= knot_u_upper"/>
         <where label="WR5" expression="SIZEOF(v_multiplicities)= knot_v_upper"/>
         <where label="WR6" expression="SIZEOF(w_multiplicities)= knot_w_upper"/>
      </entity>
      <entity name="back_chaining_rule" supertypes="rule_definition"/>
      <entity name="back_chaining_rule_body" supertypes="property_definition property_definition_representation representation"/>
      <entity name="bezier_curve" supertypes="b_spline_curve"/>
      <entity name="bezier_surface" supertypes="b_spline_surface"/>
      <entity name="bezier_volume" supertypes="b_spline_volume"/>
      <entity name="binary_generic_expression" abstract.supertype="YES" supertypes="generic_expression">
         <explicit name="operands">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity name="blind_passage_template" supertypes="unsupported_passage_template"/>
      <entity name="block" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="x">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="y">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="block_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="x">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="y">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="boolean_result" supertypes="geometric_representation_item">
         <explicit name="operator">
            <typename name="boolean_operator"/>
         </explicit>
         <explicit name="first_operand">
            <typename name="boolean_operand"/>
         </explicit>
         <explicit name="second_operand">
            <typename name="boolean_operand"/>
         </explicit>
      </entity>
      <entity name="boundary_curve" supertypes="composite_curve_on_surface">
         <where label="WR1" expression="SELF\composite_curve.closed_curve"/>
      </entity>
      <entity name="bounded_curve" supertypes="curve" super.expression="ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, bounded_surface_curve, composite_curve)"/>
      <entity name="bounded_pcurve" supertypes="pcurve bounded_curve">
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BOUNDED_CURVE' IN&#10;                   TYPEOF(SELF\pcurve.reference_to_curve.items[1]))"/>
      </entity>
      <entity name="bounded_surface" supertypes="surface" super.expression="ONEOF (b_spline_surface, rectangular_trimmed_surface, curve_bounded_surface, rectangular_composite_surface)"/>
      <entity name="bounded_surface_curve" supertypes="surface_curve bounded_curve">
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BOUNDED_CURVE' IN&#10;             TYPEOF(SELF\surface_curve.curve_3d))"/>
      </entity>
      <entity name="box_domain" supertypes="founded_item">
         <explicit name="corner">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="xlength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ylength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="zlength">
            <typename name="positive_length_measure"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(item &lt;* USEDIN(SELF,'')|&#10;             NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BOXED_HALF_SPACE'&#10;                    IN TYPEOF(item))))= 0"/>
      </entity>
      <entity name="boxed_half_space" supertypes="half_space_solid">
         <explicit name="enclosure">
            <typename name="box_domain"/>
         </explicit>
      </entity>
      <entity name="brep_2d" supertypes="solid_model">
         <explicit name="extent">
            <typename name="face"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(['TOPOLOGY_SCHEMA.FACE_SURFACE',&#10;          'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] *&#10;              TYPEOF(SELF.extent))= 0"/>
         <where label="WR2" expression="SIZEOF(QUERY(bnds &lt;* extent.bounds |&#10;         NOT('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))))= 0"/>
         <where label="WR3" expression="SIZEOF(QUERY(bnds &lt;* extent.bounds |&#10;         'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds)))= 1"/>
         <where label="WR4" expression="SIZEOF(QUERY(elp_fbnds &lt;* QUERY(bnds &lt;* extent.bounds |&#10;         'TOPOLOGY_SCHEMA.EDGE_LOOP' IN  TYPEOF(bnds.bound))|&#10;          NOT(SIZEOF(QUERY(oe &lt;* elp_fbnds.bound\path.edge_list | NOT&#10;         (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element))AND&#10;        (oe.edge_element\geometric_representation_item.dim = 2))))=&#10;                0)))= 0"/>
      </entity>
      <entity name="brep_with_voids" supertypes="manifold_solid_brep">
         <explicit name="voids">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="oriented_closed_shell"/>
         </explicit>
      </entity>
      <entity name="bus_element_link" supertypes="product_definition product_definition_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_relationship" attribute="related_product_definition"/>
            <unique.attribute entity-ref="product_definition_relationship" attribute="relating_product_definition"/>
         </unique>
         <where label="WR1" expression="SELF\product_definition_relationship.related_product_definition :&lt;&gt;:&#10;       SELF\product_definition_relationship.relating_product_definition"/>
      </entity>
      <entity name="bus_structural_definition" supertypes="product_definition"/>
      <entity name="calendar_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_month_number"/>
         </explicit>
         <explicit name="month_component">
            <typename name="month_in_year_number"/>
         </explicit>
         <where label="WR1" expression="valid_calendar_date(SELF)"/>
      </entity>
      <entity name="capacitance_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\capacitance_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = farad"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="cartesian_point" supertypes="point" super.expression="ONEOF (cylindrical_point, polar_point, spherical_point)">
         <explicit name="coordinates">
            <aggregate type="LIST" lower="1" upper="3"/>
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="cartesian_transformation_operator" supertypes="geometric_representation_item functionally_defined_transformation" super.expression="ONEOF (cartesian_transformation_operator_2d, cartesian_transformation_operator_3d)">
         <explicit name="axis1" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="axis2" optional="YES">
            <typename name="direction"/>
         </explicit>
         <explicit name="local_origin">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="scale" optional="YES">
            <builtintype type="REAL"/>
         </explicit>
         <derived name="scl" expression="NVL(scale, 1.0)">
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="scl &gt; 0.0"/>
      </entity>
      <entity name="cartesian_transformation_operator_2d" supertypes="cartesian_transformation_operator">
         <derived name="u" expression="base_axis(2,SELF\cartesian_transformation_operator.axis1,&#10;                   SELF\cartesian_transformation_operator.axis2,?)">
            <aggregate type="LIST" lower="2" upper="2"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="cartesian_transformation_operator_3d" supertypes="cartesian_transformation_operator">
         <explicit name="axis3" optional="YES">
            <typename name="direction"/>
         </explicit>
         <derived name="u" expression="base_axis(3,SELF\cartesian_transformation_operator.axis1,&#10;                        SELF\cartesian_transformation_operator.axis2,axis3)">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="direction"/>
         </derived>
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 3"/>
      </entity>
      <entity name="category_model_parameter" supertypes="model_parameter"/>
      <entity name="celsius_temperature_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="centre_of_symmetry" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF&#10;       (QUERY(sadr&lt;*SELF\derived_shape_aspect.deriving_relationships|&#10;    NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SYMMETRIC_SHAPE_ASPECT'&#10;     IN TYPEOF&#10;    (sadr\shape_aspect_relationship.related_shape_aspect))))=0"/>
      </entity>
      <entity name="certification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="certification_type"/>
         </explicit>
      </entity>
      <entity name="certification_assignment" abstract.supertype="YES">
         <explicit name="assigned_certification">
            <typename name="certification"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="certification_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="characteristic_type" supertypes="group"/>
      <entity name="characterized_class" supertypes="characterized_object class"/>
      <entity name="characterized_object">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="characterized_object_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_object">
            <typename name="characterized_object"/>
         </explicit>
         <explicit name="related_object">
            <typename name="characterized_object"/>
         </explicit>
      </entity>
      <entity name="circle" supertypes="conic">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="circular_area" supertypes="primitive_2d">
         <explicit name="centre">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="circular_involute" supertypes="curve">
         <explicit name="position">
            <typename name="axis2_placement"/>
         </explicit>
         <explicit name="base_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="circular_runout_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 2"/>
      </entity>
      <entity name="class" supertypes="group"/>
      <entity name="class_by_extension" supertypes="class"/>
      <entity name="class_by_intension" supertypes="class"/>
      <entity name="class_system" supertypes="group"/>
      <entity name="classification" supertypes="classification_assignment">
         <explicit name="classified">
            <typename name="classification_select"/>
         </explicit>
         <derived name="classifier" expression="SELF\classification_assignment.assigned_class">
            <typename name="class"/>
         </derived>
      </entity>
      <entity name="classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_class">
            <typename name="group"/>
         </explicit>
         <explicit name="role">
            <typename name="classification_role"/>
         </explicit>
      </entity>
      <entity name="classification_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="closed_shell" supertypes="connected_face_set"/>
      <entity name="clothoid" supertypes="curve">
         <explicit name="position">
            <typename name="axis2_placement"/>
         </explicit>
         <explicit name="clothoid_constant">
            <typename name="length_measure"/>
         </explicit>
      </entity>
      <entity name="coaxiality_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 2"/>
      </entity>
      <entity name="common_datum" supertypes="composite_shape_aspect datum">
         <where label="WR1" expression="SIZEOF(SELF.component_relationships)= 2"/>
         <where label="WR2" expression="SIZEOF(&#10;QUERY(sar &lt;* SELF.component_relationships| NOT (('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DATUM' IN  TYPEOF (sar.related_shape_aspect))AND NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.COMMON_DATUM' IN TYPEOF(sar.related_shape_aspect)))))= 0"/>
      </entity>
      <entity name="complete_membership" supertypes="classification_assignment">
         <derived name="containing_set" expression="SELF\classification_assignment.assigned_class">
            <typename name="class"/>
         </derived>
      </entity>
      <entity name="complete_membership_of_empty_set" supertypes="complete_membership"/>
      <entity name="complete_membership_of_non_empty_set" supertypes="complete_membership">
         <explicit name="members">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="complete_membership_select"/>
         </explicit>
      </entity>
      <entity name="complex_clause" supertypes="compound_representation_item"/>
      <entity name="complex_conjunctive_clause" supertypes="complex_clause"/>
      <entity name="complex_disjunctive_clause" supertypes="complex_clause"/>
      <entity name="component_functional_terminal" supertypes="shape_aspect"/>
      <entity name="component_functional_unit" supertypes="product_definition"/>
      <entity name="component_termination_passage_template" supertypes="inter_stratum_feature_template"/>
      <entity name="composite_curve" supertypes="bounded_curve">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="composite_curve_segment"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="closed_curve" expression="segments[n_segments].transition &lt;&gt; discontinuous">
            <builtintype type="LOGICAL"/>
         </derived>
         <derived name="n_segments" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="((NOT closed_curve)AND (SIZEOF(QUERY(temp &lt;* segments |&#10;                temp.transition = discontinuous))= 1))OR&#10;           ((closed_curve)AND(SIZEOF(QUERY(temp &lt;* segments | &#10;                temp.transition = discontinuous))= 0))"/>
      </entity>
      <entity name="composite_curve_on_surface" supertypes="composite_curve" super.expression="boundary_curve">
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="0" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="WR1" expression="SIZEOF(basis_surface)&gt; 0"/>
         <where label="WR2" expression="constraints_composite_curve_on_surface(SELF)"/>
      </entity>
      <entity name="composite_curve_segment" supertypes="founded_item">
         <explicit name="transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <inverse name="using_curves" entity="composite_curve" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BOUNDED_CURVE' IN TYPEOF(parent_curve))"/>
      </entity>
      <entity name="composite_group_shape_aspect" supertypes="composite_shape_aspect"/>
      <entity name="composite_shape_aspect" supertypes="shape_aspect">
         <inverse name="component_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
            <inverse.aggregate type="SET" lower="2" upper="?"/>
         </inverse>
      </entity>
      <entity name="composite_signal_property_relationship" supertypes="property_definition property_definition_relationship">
         <where label="WR1" expression="SELF\property_definition_relationship.related_property_definition.definition :&lt;&gt;:&#10;       SELF\property_definition_relationship.relating_property_definition.definition"/>
      </entity>
      <entity name="composite_unit_shape_aspect" supertypes="composite_shape_aspect"/>
      <entity name="compound_representation_item" supertypes="representation_item">
         <explicit name="item_element">
            <typename name="compound_item_definition"/>
         </explicit>
      </entity>
      <entity name="concentricity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)= 1"/>
      </entity>
      <entity name="concept_feature_operator">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="concept_feature_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_concept_feature">
            <typename name="product_concept_feature"/>
         </explicit>
         <explicit name="related_product_concept_feature">
            <typename name="product_concept_feature"/>
         </explicit>
      </entity>
      <entity name="concept_feature_relationship_with_condition" supertypes="concept_feature_relationship">
         <explicit name="conditional_operator">
            <typename name="concept_feature_operator"/>
         </explicit>
      </entity>
      <entity name="conditional_concept_feature" supertypes="product_concept_feature">
         <explicit name="condition">
            <typename name="concept_feature_relationship_with_condition"/>
         </explicit>
      </entity>
      <entity name="conductance_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\conductance_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = siemens"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="configurable_item" supertypes="configuration_item">
         <explicit name="item_concept_feature">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_concept_feature_association"/>
         </explicit>
      </entity>
      <entity name="configuration_design">
         <explicit name="configuration">
            <typename name="configuration_item"/>
         </explicit>
         <explicit name="design">
            <typename name="configuration_design_item"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <unique label="UR1">
            <unique.attribute attribute="configuration"/>
            <unique.attribute attribute="design"/>
         </unique>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                             'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="configuration_effectivity" supertypes="product_definition_effectivity">
         <explicit name="configuration">
            <typename name="configuration_design"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="configuration"/>
            <unique.attribute entity-ref="product_definition_effectivity" attribute="usage"/>
            <unique.attribute entity-ref="effectivity" attribute="id"/>
         </unique>
         <where label="WR1" expression="'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN&#10;        TYPEOF(SELF\product_definition_effectivity.usage)"/>
      </entity>
      <entity name="configuration_item">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="item_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="purpose" optional="YES">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="configuration_item_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_configuration_item">
            <typename name="configuration_item"/>
         </explicit>
         <explicit name="related_configuration_item">
            <typename name="configuration_item"/>
         </explicit>
      </entity>
      <entity name="conic" supertypes="curve" super.expression="ONEOF (circle, ellipse, hyperbola, parabola)">
         <explicit name="position">
            <typename name="axis2_placement"/>
         </explicit>
      </entity>
      <entity name="conical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="semi_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where label="WR1" expression="radius &gt;= 0.0"/>
      </entity>
      <entity name="connected_edge_set" supertypes="topological_representation_item">
         <explicit name="ces_edges">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="edge"/>
         </explicit>
      </entity>
      <entity name="connected_face_set" supertypes="topological_representation_item" super.expression="ONEOF (closed_shell, open_shell)">
         <explicit name="cfs_faces">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
         </explicit>
      </entity>
      <entity name="connected_face_sub_set" supertypes="connected_face_set">
         <explicit name="parent_face_set">
            <typename name="connected_face_set"/>
         </explicit>
      </entity>
      <entity name="connection_zone_interface_plane_relationship" supertypes="shape_aspect shape_aspect_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect" attribute="name"/>
         </unique>
      </entity>
      <entity name="connection_zone_map_identification" supertypes="shape_aspect representation_relationship">
         <explicit name="rep_1">
            <typename name="usage_view_connection_zone_terminal_shape_relationship"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="usage_view_connection_zone_terminal_shape_relationship"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <where label="WR1" expression="SELF\representation_relationship.rep_2 :&lt;&gt;:&#10;       SELF\representation_relationship.rep_1"/>
      </entity>
      <entity name="context_dependent_shape_representation">
         <explicit name="representation_relation">
            <typename name="shape_representation_relationship"/>
         </explicit>
         <explicit name="represented_product_relation">
            <typename name="product_definition_shape"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP'&#10;         IN TYPEOF(SELF.represented_product_relation.definition)"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
         <where label="WR3" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                       'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="context_dependent_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="continuous_template" abstract.supertype="YES" supertypes="geometric_template" super.expression="ONEOF (inter_stratum_feature_template, single_stratum_continuous_template)"/>
      <entity name="contract">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="contract_type"/>
         </explicit>
      </entity>
      <entity name="contract_assignment" abstract.supertype="YES">
         <explicit name="assigned_contract">
            <typename name="contract"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="contract_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_contract">
            <typename name="contract"/>
         </explicit>
         <explicit name="related_contract">
            <typename name="contract"/>
         </explicit>
      </entity>
      <entity name="contract_type">
         <explicit name="description">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="conversion_based_unit" supertypes="named_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="conversion_factor">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="convex_hexahedron" supertypes="faceted_primitive">
         <where label="WR1" expression="SIZEOF(points)= 8"/>
         <where label="WR2" expression="above_plane(points[1], points[2], points[3], points[4])= 0.0"/>
         <where label="WR3" expression="above_plane(points[5], points[8], points[7], points[6])= 0.0"/>
         <where label="WR4" expression="above_plane(points[1], points[4], points[8], points[5])= 0.0"/>
         <where label="WR5" expression="above_plane(points[4], points[3], points[7], points[8])= 0.0"/>
         <where label="WR6" expression="above_plane(points[3], points[2], points[6], points[7])= 0.0"/>
         <where label="WR7" expression="above_plane(points[1], points[5], points[6], points[2])= 0.0"/>
         <where label="WR8" expression="same_side([points[1], points[2], points[3]],&#10;                     [points[5], points[6], points[7], points[8]])"/>
         <where label="WR9" expression="same_side([points[1], points[4], points[8]],&#10;                     [points[3], points[7], points[6], points[2]])"/>
         <where label="WR10" expression="same_side([points[1], points[2], points[5]],&#10;                      [points[3], points[7], points[8], points[4]])"/>
         <where label="WR11" expression="same_side([points[5], points[6], points[7]],&#10;                     [points[1], points[2], points[3], points[4]])"/>
         <where label="WR12" expression="same_side([points[3], points[7], points[6]],&#10;                     [points[1], points[4], points[8], points[5]])"/>
         <where label="WR13" expression="same_side([points[3], points[7], points[8]],&#10;                      [points[1], points[5], points[6], points[2]])"/>
      </entity>
      <entity name="coordinated_universal_time_offset">
         <explicit name="hour_offset">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="minute_offset" optional="YES">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="sense">
            <typename name="ahead_or_behind"/>
         </explicit>
         <derived name="actual_minute_offset" expression="NVL(minute_offset,0)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="{ 0 &lt;= hour_offset &lt; 24 }"/>
         <where label="WR2" expression="{ 0 &lt;= actual_minute_offset &lt;= 59 }"/>
         <where label="WR3" expression="NOT(((hour_offset &lt;&gt; 0)OR(actual_minute_offset &lt;&gt;0))AND(sense = exact))"/>
      </entity>
      <entity name="counterbore_passage_template" supertypes="unsupported_passage_template"/>
      <entity name="countersunk_passage_template" supertypes="unsupported_passage_template"/>
      <entity name="csg_2d_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SELF.context_of_items\&#10;  geometric_representation_context.coordinate_space_dimension = 2"/>
         <where label="WR2" expression="SIZEOF(QUERY(it &lt;* SELF.items| NOT&#10;    (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CSG_SOLID', &#10;     'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MAPPED_ITEM', &#10;     'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.AXIS2_PLACEMENT_2D'] &#10;     * TYPEOF(it))= 1)))= 0"/>
         <where label="WR3" expression="SIZEOF(QUERY(it &lt;* SELF.items | &#10;   (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CSG_SOLID']&#10;	* TYPEOF(it))= 1)&#10;	OR &#10;	(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MAPPED_ITEM' &#10;	IN TYPEOF(it))AND&#10;	('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;	'CSG_2D_SHAPE_REPRESENTATION' &#10;	  IN TYPEOF(it\mapped_item.mapping_source.mapped_representation)))&#10;      ))&gt;= 1"/>
         <where label="WR4" expression="SIZEOF(QUERY(it &lt;* SELF.items | &#10;    (('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MAPPED_ITEM' &#10;     IN  TYPEOF(it))AND(NOT((&#10;      'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;      'CSG_2D_SHAPE_REPRESENTATION')&#10;      IN TYPEOF(it\mapped_item.mapping_source.mapped_representation))))))= 0"/>
         <where label="WR5" expression="SIZEOF(TYPEOF(SELF)- TYPEOF(SELF\shape_representation ||&#10;      SELF\csg_2d_shape_representation || SELF\representation))= 0"/>
      </entity>
      <entity name="csg_solid" supertypes="solid_model">
         <explicit name="tree_root_expression">
            <typename name="csg_select"/>
         </explicit>
      </entity>
      <entity name="curve" supertypes="geometric_representation_item" super.expression="ONEOF (line, conic, clothoid, circular_involute, pcurve, surface_curve, offset_curve_2d, offset_curve_3d, curve_replica)"/>
      <entity name="curve_bounded_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="boundary_curve"/>
         </explicit>
         <explicit name="implicit_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="(NOT implicit_outer)OR&#10;        (SIZEOF(QUERY(temp &lt;* boundaries |&#10;           'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp)))= 0)"/>
         <where label="WR2" expression="(NOT(implicit_outer))OR&#10;               ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(basis_surface))"/>
         <where label="WR3" expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;                  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.OUTER_BOUNDARY_CURVE' IN&#10;                                         TYPEOF(temp)))&lt;= 1"/>
         <where label="WR4" expression="SIZEOF(QUERY(temp &lt;* boundaries |&#10;           (temp\composite_curve_on_surface.basis_surface [1] &lt;&gt;&#10;                                         SELF.basis_surface)))= 0"/>
      </entity>
      <entity name="curve_replica" supertypes="curve">
         <explicit name="parent_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="WR1" expression="transformation.dim = parent_curve.dim"/>
         <where label="WR2" expression="acyclic_curve_replica(SELF, parent_curve)"/>
      </entity>
      <entity name="cyclide_segment_solid" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="radius1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="radius2">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="cone_angle1">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="cone_angle2">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="turn_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
      </entity>
      <entity name="cylindrical_point" supertypes="cartesian_point">
         <explicit name="r">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="theta">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="length_measure"/>
         </explicit>
         <derived name="coordinates" expression="[r*cos(theta), r*sin(theta), z]">
            <aggregate type="LIST" lower="1" upper="3"/>
            <typename name="length_measure"/>
            <redeclaration entity-ref="cartesian_point"/>
         </derived>
         <where label="WR1" expression="r &gt;= 0.0"/>
      </entity>
      <entity name="cylindrical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="cylindrical_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="cylindricity_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="data_environment">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="elements">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="property_definition_representation"/>
         </explicit>
      </entity>
      <entity name="data_environment_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_data_environment">
            <typename name="data_environment"/>
         </explicit>
         <explicit name="related_data_environment">
            <typename name="data_environment"/>
         </explicit>
      </entity>
      <entity name="date" super.expression="ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date)">
         <explicit name="year_component">
            <typename name="year_number"/>
         </explicit>
      </entity>
      <entity name="date_and_time">
         <explicit name="date_component">
            <typename name="date"/>
         </explicit>
         <explicit name="time_component">
            <typename name="local_time"/>
         </explicit>
      </entity>
      <entity name="date_and_time_assignment" abstract.supertype="YES">
         <explicit name="assigned_date_and_time">
            <typename name="date_and_time"/>
         </explicit>
         <explicit name="role">
            <typename name="date_time_role"/>
         </explicit>
      </entity>
      <entity name="date_assignment" abstract.supertype="YES">
         <explicit name="assigned_date">
            <typename name="date"/>
         </explicit>
         <explicit name="role">
            <typename name="date_role"/>
         </explicit>
      </entity>
      <entity name="date_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="date_time_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="dated_effectivity" supertypes="effectivity">
         <explicit name="effectivity_end_date" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="effectivity_start_date">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
      </entity>
      <entity name="datum" supertypes="shape_aspect">
         <explicit name="identification">
            <typename name="identifier"/>
         </explicit>
         <inverse name="established_by_relationships" entity="shape_aspect_relationship" attribute="related_shape_aspect">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF(QUERY(x&lt;*SELF\datum.established_by_relationships |&#10;       SIZEOF(TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)* &#10;       ['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DATUM_FEATURE', &#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DATUM_TARGET'])&lt;&gt; 1))=0"/>
      </entity>
      <entity name="datum_difference" supertypes="shape_aspect shape_aspect_relationship">
         <where label="WR1" expression="SELF\shape_aspect_relationship.relating_shape_aspect :&lt;&gt;:&#10;       SELF\shape_aspect_relationship.related_shape_aspect"/>
      </entity>
      <entity name="datum_difference_based_characteristic" supertypes="representation_item"/>
      <entity name="datum_feature" supertypes="shape_aspect">
         <inverse name="feature_basis_relationship" entity="shape_aspect_relationship" attribute="relating_shape_aspect"/>
         <where label="WR1" expression="SIZEOF(QUERY(sar&lt;* bag_to_set(USEDIN(SELF,&#10;     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.'+&#10;       'RELATING_SHAPE_ASPECT'))&#10;       | NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DATUM' IN TYPEOF&#10;      (sar\shape_aspect_relationship.related_shape_aspect))))=0"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = TRUE"/>
      </entity>
      <entity name="datum_reference">
         <explicit name="precedence">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="referenced_datum">
            <typename name="datum"/>
         </explicit>
         <where label="WR1" expression="precedence &gt; 0"/>
      </entity>
      <entity name="datum_target" supertypes="shape_aspect">
         <explicit name="target_id">
            <typename name="identifier"/>
         </explicit>
         <inverse name="target_basis_relationship" entity="shape_aspect_relationship" attribute="relating_shape_aspect"/>
         <where label="WR1" expression="SIZEOF(QUERY(sar&lt;* bag_to_set(USEDIN(SELF,&#10;     'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' +&#10;       'RELATING_SHAPE_ASPECT'))&#10;      | NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DATUM' IN TYPEOF &#10;     (sar\shape_aspect_relationship.related_shape_aspect))))=0"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = TRUE"/>
      </entity>
      <entity name="default_attachment_size_based_land_physical_template" supertypes="land_physical_template shape_aspect"/>
      <entity name="default_passage_based_land_physical_template" abstract.supertype="YES" supertypes="land_physical_template" super.expression="ONEOF (default_plated_passage_based_land_physical_template, default_unsupported_passage_based_land_physical_template)"/>
      <entity name="default_plated_passage_based_land_physical_template" supertypes="default_passage_based_land_physical_template"/>
      <entity name="default_tolerance_table" supertypes="representation">
         <where label="WR1" expression="SIZEOF(QUERY(i &lt;* SELF.items | NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DEFAULT_TOLERANCE_TABLE_CELL' IN TYPEOF(i))))= 0"/>
         <where label="WR2" expression="(SIZEOF(QUERY(rr &lt;* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1')| rr.name &lt; 'general tolerance definition'))= 0)AND (SIZEOF(QUERY(rr &lt;* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_1')|(rr.name = 'general tolerance definition')AND (rr.rep_2.name &lt; 'default tolerance')))= 0)AND(SIZEOF(USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2'))= 0)"/>
      </entity>
      <entity name="default_tolerance_table_cell" supertypes="compound_representation_item">
         <where label="WR1" expression="SIZEOF(QUERY(x &lt;* USEDIN(SELF,'REPRESENTATION_SCHEMA.' + 'REPRESENTATION.ITEMS')| 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'DEFAULT_TOLERANCE_TABLE' IN TYPEOF(x)))=1"/>
         <where label="WR2" expression="default_tolerance_table_cell_wr2(SELF\compound_representation_item.item_element)"/>
         <where label="WR3" expression="default_tolerance_table_cell_wr3(SELF\compound_representation_item.item_element)"/>
         <where label="WR4" expression="default_tolerance_table_cell_wr4(SELF\compound_representation_item.item_element)"/>
         <where label="WR5" expression="default_tolerance_table_cell_wr5(SELF\compound_representation_item.item_element)"/>
      </entity>
      <entity name="default_unsupported_passage_based_land_physical_template" supertypes="default_passage_based_land_physical_template"/>
      <entity name="definitional_representation" supertypes="representation">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT' IN&#10;        TYPEOF(SELF\representation.context_of_items)"/>
      </entity>
      <entity name="definitional_representation_relationship" supertypes="representation_relationship">
         <where label="WR1" expression="acyclic_representation_relationship(SELF,&#10;       [SELF\representation_relationship.rep_2],&#10;       'REPRESENTATION_SCHEMA.'+&#10;       'REPRESENTATION')"/>
      </entity>
      <entity name="degenerate_pcurve" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(reference_to_curve\representation.items)= 1"/>
         <where label="WR2" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CURVE' IN TYPEOF&#10;                   (reference_to_curve\representation.items[1])"/>
         <where label="WR3" expression="reference_to_curve\representation.&#10;                   items[1]\geometric_representation_item.dim =2"/>
      </entity>
      <entity name="degenerate_toroidal_surface" supertypes="toroidal_surface">
         <explicit name="select_outer">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="major_radius &lt;   minor_radius"/>
      </entity>
      <entity name="dependent_template" abstract.supertype="YES" supertypes="part_template_definition"/>
      <entity name="derived_shape_aspect" supertypes="shape_aspect" super.expression="ONEOF (apex, centre_of_symmetry, geometric_alignment, geometric_intersection, parallel_offset, perpendicular_to, extension, tangent)">
         <inverse name="deriving_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF(QUERY(dr &lt;*&#10;          SELF\derived_shape_aspect.deriving_relationships |&#10;          NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;               'SHAPE_ASPECT_DERIVING_RELATIONSHIP'&#10;          IN TYPEOF(dr))))= 0"/>
      </entity>
      <entity name="derived_unit">
         <explicit name="elements">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="derived_unit_element"/>
         </explicit>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="(SIZEOF(elements)&gt; 1)OR((SIZEOF(elements)= 1)AND(elements[1].exponent &lt;&gt; 1.0))"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="derived_unit_element">
         <explicit name="unit">
            <typename name="named_unit"/>
         </explicit>
         <explicit name="exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="description_attribute">
         <explicit name="attribute_value">
            <typename name="text"/>
         </explicit>
         <explicit name="described_item">
            <typename name="description_attribute_select"/>
         </explicit>
      </entity>
      <entity name="descriptive_representation_item" supertypes="representation_item">
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="digital_analytical_model_port" supertypes="analytical_model_port"/>
      <entity name="digital_analytical_model_scalar_port" supertypes="digital_analytical_model_vector_port analytical_model_scalar_port"/>
      <entity name="digital_analytical_model_vector_port" supertypes="analytical_model_vector_port"/>
      <entity name="dimension_related_tolerance_zone_element">
         <explicit name="related_dimension">
            <typename name="dimensional_location"/>
         </explicit>
         <explicit name="related_element">
            <typename name="tolerance_zone_definition"/>
         </explicit>
      </entity>
      <entity name="dimensional_characteristic_representation">
         <explicit name="dimension">
            <typename name="dimensional_characteristic"/>
         </explicit>
         <explicit name="representation">
            <typename name="shape_dimension_representation"/>
         </explicit>
      </entity>
      <entity name="dimensional_exponents">
         <explicit name="length_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="mass_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="time_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="electric_current_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="thermodynamic_temperature_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="amount_of_substance_exponent">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="luminous_intensity_exponent">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="dimensional_location" supertypes="shape_aspect_relationship" super.expression="ONEOF (angular_location, dimensional_location_with_path)"/>
      <entity name="dimensional_location_with_path" supertypes="dimensional_location">
         <explicit name="path">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="dimensional_size" super.expression="ONEOF (angular_size, dimensional_size_with_path)">
         <explicit name="applies_to">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="applies_to.product_definitional = TRUE"/>
      </entity>
      <entity name="dimensional_size_property" supertypes="dimensional_size property_definition"/>
      <entity name="dimensional_size_with_path" supertypes="dimensional_size">
         <explicit name="path">
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="directed_action" supertypes="executed_action">
         <explicit name="directive">
            <typename name="action_directive"/>
         </explicit>
      </entity>
      <entity name="directed_dimensional_location" supertypes="dimensional_location"/>
      <entity name="direction" supertypes="geometric_representation_item">
         <explicit name="direction_ratios">
            <aggregate type="LIST" lower="2" upper="3"/>
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(tmp &lt;* direction_ratios | tmp &lt;&gt; 0.0))&gt; 0"/>
      </entity>
      <entity name="document">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="kind">
            <typename name="document_type"/>
         </explicit>
         <inverse name="representation_types" entity="document_representation_type" attribute="represented_document">
            <inverse.aggregate type="SET" lower="0" upper="?"/>
         </inverse>
      </entity>
      <entity name="document_file" supertypes="document characterized_object">
         <where label="WR1" expression="SELF\characterized_object.name = ''"/>
         <where label="WR2" expression="NOT EXISTS(SELF\characterized_object.description)"/>
         <where label="WR3" expression="SIZEOF(QUERY(drt &lt;* SELF\document.representation_types |&#10;               drt.name IN ['digital','physical']))= 1"/>
      </entity>
      <entity name="document_identifier" supertypes="group">
         <unique label="UR1">
            <unique.attribute entity-ref="group" attribute="name"/>
            <unique.attribute entity-ref="group" attribute="description"/>
         </unique>
      </entity>
      <entity name="document_identifier_assignment" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document_identifier_assigned_item"/>
         </explicit>
         <explicit name="assigned_group">
            <typename name="document_identifier"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
      </entity>
      <entity name="document_product_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_product">
            <typename name="product_or_formation_or_definition"/>
         </explicit>
      </entity>
      <entity name="document_product_equivalence" supertypes="document_product_association">
         <where label="WR1" expression="SELF\document_product_association.name = 'equivalence'"/>
         <where label="WR2" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product))OR((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document')AND(SIZEOF(QUERY(prpc &lt;* USEDIN(SELF\document_product_association.related_product,'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1))"/>
         <where label="WR3" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product))OR((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version')AND(SIZEOF(QUERY(prpc &lt;* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1))"/>
         <where label="WR4" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product))OR((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition')AND(SIZEOF(QUERY(prpc &lt;* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| prpc.name = 'document'))= 1))"/>
      </entity>
      <entity name="document_reference" abstract.supertype="YES">
         <explicit name="assigned_document">
            <typename name="document"/>
         </explicit>
         <explicit name="source">
            <typename name="label"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="document_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_document">
            <typename name="document"/>
         </explicit>
         <explicit name="related_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_representation_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="represented_document">
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="document_type">
         <explicit name="product_data_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="document_usage_constraint">
         <explicit name="source">
            <typename name="document"/>
         </explicit>
         <explicit name="subject_element">
            <typename name="label"/>
         </explicit>
         <explicit name="subject_element_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="document_usage_constraint_assignment" abstract.supertype="YES">
         <explicit name="assigned_document_usage">
            <typename name="document_usage_constraint"/>
         </explicit>
         <explicit name="role">
            <typename name="document_usage_role"/>
         </explicit>
      </entity>
      <entity name="document_usage_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="document_with_class" supertypes="document">
         <explicit name="class">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="dose_equivalent_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\dose_equivalent_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = sievert"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="dupin_cyclide_surface" supertypes="elementary_surface">
         <explicit name="generalised_major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="generalised_minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="skewness">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="skewness &gt;= 0.0"/>
      </entity>
      <entity name="eccentric_cone" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="x_offset">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="y_offset">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="ratio">
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="ratio &gt;= 0.0"/>
      </entity>
      <entity name="eccentric_conical_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="x_offset">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="y_offset">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="ratio">
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="ratio &gt;= 0.0"/>
      </entity>
      <entity name="edge" supertypes="topological_representation_item" super.expression="ONEOF (edge_curve, oriented_edge, subedge)">
         <explicit name="edge_start">
            <typename name="vertex"/>
         </explicit>
         <explicit name="edge_end">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="edge_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="ebwm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="connected_edge_set"/>
         </explicit>
      </entity>
      <entity name="edge_curve" supertypes="edge geometric_representation_item">
         <explicit name="edge_geometry">
            <typename name="curve"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="edge_loop" supertypes="loop path">
         <derived name="ne" expression="SIZEOF(SELF\path.edge_list)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="(SELF\path.edge_list[1].edge_start):=:&#10;       (SELF\path.edge_list[ne].edge_end)"/>
      </entity>
      <entity name="edge_segment_vertex" supertypes="physical_unit_datum"/>
      <entity name="effectivity" super.expression="ONEOF (serial_numbered_effectivity, dated_effectivity, lot_effectivity, time_interval_based_effectivity)">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="effectivity_assignment" abstract.supertype="YES">
         <explicit name="assigned_effectivity">
            <typename name="effectivity"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="effectivity_context_assignment" abstract.supertype="YES">
         <explicit name="assigned_effectivity_assignment">
            <typename name="effectivity_assignment"/>
         </explicit>
         <explicit name="role">
            <typename name="effectivity_context_role"/>
         </explicit>
      </entity>
      <entity name="effectivity_context_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="effectivity_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="related_effectivity">
            <typename name="effectivity"/>
         </explicit>
         <explicit name="relating_effectivity">
            <typename name="effectivity"/>
         </explicit>
      </entity>
      <entity name="electric_charge_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\electric_charge_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = coulomb"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="electric_current_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ELECTRIC_CURRENT_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="electric_current_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="electromotive_force_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\electromotive_force_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = volt"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="elementary_surface" supertypes="surface" super.expression="ONEOF (plane, cylindrical_surface, conical_surface, spherical_surface, toroidal_surface)">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
      </entity>
      <entity name="ellipse" supertypes="conic">
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="ellipsoid" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_3">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="ellipsoid_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_3">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="elliptic_area" supertypes="primitive_2d">
         <explicit name="position">
            <typename name="axis2_placement_2d"/>
         </explicit>
         <explicit name="semi_axis_1">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_axis_2">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="energy_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\energy_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = joule"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="entity_assertion" supertypes="fact_type"/>
      <entity name="enum_reference_prefix" supertypes="descriptive_representation_item"/>
      <entity name="environment">
         <explicit name="syntactic_representation">
            <typename name="generic_variable"/>
         </explicit>
         <explicit name="semantics">
            <typename name="variable_semantics"/>
         </explicit>
      </entity>
      <entity name="evaluated_degenerate_pcurve" supertypes="degenerate_pcurve">
         <explicit name="equivalent_point">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="event_occurrence">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_assignment" abstract.supertype="YES">
         <explicit name="assigned_event_occurrence">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="role">
            <typename name="event_occurrence_role"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_context_assignment" abstract.supertype="YES">
         <explicit name="assigned_event_occurrence_assignment">
            <typename name="event_occurrence_assignment"/>
         </explicit>
         <explicit name="role">
            <typename name="event_occurrence_context_role"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_context_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_event">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="related_event">
            <typename name="event_occurrence"/>
         </explicit>
      </entity>
      <entity name="event_occurrence_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="exclusive_product_concept_feature_category" supertypes="product_concept_feature_category"/>
      <entity name="executed_action" supertypes="action"/>
      <entity name="expanded_uncertainty" supertypes="standard_uncertainty">
         <explicit name="coverage_factor">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="experience">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="experience_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_experience">
            <typename name="experience"/>
         </explicit>
         <explicit name="role">
            <typename name="experience_role"/>
         </explicit>
      </entity>
      <entity name="experience_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_experience">
            <typename name="experience"/>
         </explicit>
         <explicit name="related_experience">
            <typename name="experience"/>
         </explicit>
      </entity>
      <entity name="experience_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="experience_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="experience_type_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_experience_type">
            <typename name="experience_type"/>
         </explicit>
         <explicit name="role">
            <typename name="experience_type_role"/>
         </explicit>
      </entity>
      <entity name="experience_type_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_experience_type">
            <typename name="experience_type"/>
         </explicit>
         <explicit name="related_experience_type">
            <typename name="experience_type"/>
         </explicit>
      </entity>
      <entity name="experience_type_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="expression_conversion_based_unit" supertypes="context_dependent_unit variable_semantics">
         <inverse name="associated_variable_environment" entity="environment" attribute="semantics"/>
      </entity>
      <entity name="extension" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF(SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="extent" supertypes="characterized_object"/>
      <entity name="external_class_library" supertypes="external_source"/>
      <entity name="external_identification_assignment" abstract.supertype="YES" supertypes="identification_assignment">
         <explicit name="source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="external_referent_assignment" abstract.supertype="YES">
         <explicit name="assigned_name">
            <typename name="label"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <unique label="UR1">
            <unique.attribute attribute="assigned_name"/>
         </unique>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="external_source">
         <explicit name="source_id">
            <typename name="source_item"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="external_source_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_source">
            <typename name="external_source"/>
         </explicit>
         <explicit name="related_source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="externally_defined_class" supertypes="class externally_defined_item"/>
      <entity name="externally_defined_dimension_definition" supertypes="dimensional_size externally_defined_item">
         <where label="WR1" expression="(SELF\externally_defined_item.item_id = 'external size dimension')AND(SELF\externally_defined_item.source.source_id = 'external size dimension specification')"/>
         <where label="WR2" expression="1 &gt;= SIZEOF(QUERY(adr &lt;* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')|(adr.assigned_document.description = 'external size dimension specification')))"/>
      </entity>
      <entity name="externally_defined_item">
         <explicit name="item_id">
            <typename name="source_item"/>
         </explicit>
         <explicit name="source">
            <typename name="external_source"/>
         </explicit>
      </entity>
      <entity name="externally_defined_item_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_item">
            <typename name="externally_defined_item"/>
         </explicit>
         <explicit name="related_item">
            <typename name="externally_defined_item"/>
         </explicit>
      </entity>
      <entity name="extruded_area_solid" supertypes="swept_area_solid">
         <explicit name="extruded_direction">
            <typename name="direction"/>
         </explicit>
         <explicit name="depth">
            <typename name="positive_length_measure"/>
         </explicit>
         <where label="WR1" expression="dot_product(&#10;       (SELF\swept_area_solid.swept_area.basis_surface\&#10;        elementary_surface.position.p[3]), extruded_direction)&lt;&gt; 0.0"/>
      </entity>
      <entity name="extruded_face_solid" supertypes="swept_face_solid">
         <explicit name="extruded_direction">
            <typename name="direction"/>
         </explicit>
         <explicit name="depth">
            <typename name="positive_length_measure"/>
         </explicit>
         <where label="WR1" expression="dot_product(&#10;       (SELF\swept_face_solid.swept_face.face_geometry\&#10;        elementary_surface.position.p[3]), extruded_direction)&lt;&gt; 0.0"/>
      </entity>
      <entity name="face" supertypes="topological_representation_item" super.expression="ONEOF (face_surface, subface, oriented_face)">
         <explicit name="bounds">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face_bound"/>
         </explicit>
         <where label="WR1" expression="NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))))"/>
         <where label="WR2" expression="SIZEOF(QUERY(temp &lt;* bounds | 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.FACE_OUTER_BOUND' IN&#10;                                               TYPEOF(temp)))&lt;= 1"/>
      </entity>
      <entity name="face_based_surface_model" supertypes="geometric_representation_item">
         <explicit name="fbsm_faces">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="connected_face_set"/>
         </explicit>
      </entity>
      <entity name="face_bound" supertypes="topological_representation_item">
         <explicit name="bound">
            <typename name="loop"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="face_outer_bound" supertypes="face_bound"/>
      <entity name="face_surface" supertypes="face geometric_representation_item">
         <explicit name="face_geometry">
            <typename name="surface"/>
         </explicit>
         <explicit name="same_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="NOT('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry))"/>
      </entity>
      <entity name="faceted_brep" supertypes="manifold_solid_brep"/>
      <entity name="faceted_primitive" supertypes="geometric_representation_item" super.expression="ONEOF (tetrahedron, convex_hexahedron)">
         <explicit name="points">
            <aggregate type="LIST" unique="YES" lower="4" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
         <where label="WR1" expression="points[1].dim = 3"/>
      </entity>
      <entity name="fact_type" supertypes="property_definition"/>
      <entity name="feature_definition" supertypes="characterized_object"/>
      <entity name="filled_via_template" supertypes="via_template"/>
      <entity name="fixed_reference_swept_surface" supertypes="swept_surface">
         <explicit name="directrix">
            <typename name="curve"/>
         </explicit>
         <explicit name="fixed_reference">
            <typename name="direction"/>
         </explicit>
      </entity>
      <entity name="flatness_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="force_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\force_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = newton"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="forward_chaining_rule" supertypes="rule_definition"/>
      <entity name="forward_chaining_rule_premise" supertypes="property_definition property_definition_representation representation"/>
      <entity name="founded_item"/>
      <entity name="frequency_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\frequency_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = hertz"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="func" supertypes="compound_representation_item"/>
      <entity name="functional_specification" supertypes="representation"/>
      <entity name="functional_specification_definition" supertypes="functional_unit"/>
      <entity name="functional_terminal_group" supertypes="group">
         <unique label="UR1">
            <unique.attribute entity-ref="group" attribute="name"/>
         </unique>
      </entity>
      <entity name="functional_unit" supertypes="product_definition"/>
      <entity name="functional_unit_terminal_definition" supertypes="shape_aspect">
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'FUNCTIONAL_UNIT' IN&#10;       TYPEOF(SELF.of_shape.definition))"/>
      </entity>
      <entity name="functionally_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="general_material_property" supertypes="general_property">
         <where label="WR1" expression="SIZEOF(QUERY(gpa &lt;* USEDIN(SELF,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION')| &#10;  NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition))))= 0"/>
      </entity>
      <entity name="general_property">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="general_property_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="base_definition">
            <typename name="general_property"/>
         </explicit>
         <explicit name="derived_definition">
            <typename name="derived_property_select"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(USEDIN(derived_definition, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION'))= 1"/>
         <where label="WR2" expression="derived_definition.name = base_definition.name"/>
      </entity>
      <entity name="general_property_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_property">
            <typename name="general_property"/>
         </explicit>
         <explicit name="related_property">
            <typename name="general_property"/>
         </explicit>
      </entity>
      <entity name="generic_expression" abstract.supertype="YES" super.expression="ONEOF (simple_generic_expression, unary_generic_expression, binary_generic_expression, multiple_arity_generic_expression)">
         <where label="WR1" expression="is_acyclic(SELF)"/>
      </entity>
      <entity name="generic_literal" abstract.supertype="YES" supertypes="simple_generic_expression"/>
      <entity name="generic_variable" abstract.supertype="YES" supertypes="simple_generic_expression">
         <inverse name="interpretation" entity="environment" attribute="syntactic_representation"/>
      </entity>
      <entity name="geometric_alignment" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF(SELF\derived_shape_aspect.deriving_relationships)&gt; 1"/>
      </entity>
      <entity name="geometric_curve_set" supertypes="geometric_set">
         <where label="WR1" expression="SIZEOF(QUERY(temp &lt;* SELF\geometric_set.elements |&#10;                            'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp)))= 0"/>
      </entity>
      <entity name="geometric_intersection" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF(SELF\derived_shape_aspect.deriving_relationships)&gt; 1"/>
      </entity>
      <entity name="geometric_model_element_relationship" supertypes="geometric_representation_item representation_item_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="representation_item_relationship" attribute="relating_representation_item"/>
            <unique.attribute entity-ref="representation_item_relationship" attribute="related_representation_item"/>
         </unique>
         <where label="WR1" expression="SELF\representation_item_relationship.relating_representation_item :&lt;&gt;: &#10;       SELF\representation_item_relationship.related_representation_item"/>
      </entity>
      <entity name="geometric_representation_context" supertypes="representation_context">
         <explicit name="coordinate_space_dimension">
            <typename name="dimension_count"/>
         </explicit>
      </entity>
      <entity name="geometric_representation_item" supertypes="representation_item" super.expression="ONEOF (point, direction, vector, placement, cartesian_transformation_operator, curve, surface, edge_curve, face_surface, poly_loop, vertex_point, solid_model, boolean_result, sphere, right_circular_cone, right_circular_cylinder, torus, block, primitive_2d, right_angular_wedge, ellipsoid, faceted_primitive, rectangular_pyramid, cyclide_segment_solid, volume, half_space_solid, half_space_2d, shell_based_surface_model, face_based_surface_model, shell_based_wireframe_model, edge_based_wireframe_model, geometric_set)">
         <derived name="dim" expression="dimension_of(SELF)">
            <typename name="dimension_count"/>
         </derived>
         <where label="WR1" expression="SIZEOF(QUERY(using_rep &lt;* using_representations(SELF)|&#10;      NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' IN&#10;      TYPEOF(using_rep.context_of_items))))= 0"/>
      </entity>
      <entity name="geometric_set" supertypes="geometric_representation_item" super.expression="ONEOF (geometric_curve_set, geometric_set_replica)">
         <explicit name="elements">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="geometric_set_select"/>
         </explicit>
      </entity>
      <entity name="geometric_set_replica" supertypes="geometric_set">
         <explicit name="parent_set">
            <typename name="geometric_set"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <derived name="elements" expression="build_transformed_set(transformation, parent_set)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="geometric_set_select"/>
            <redeclaration entity-ref="geometric_set"/>
         </derived>
         <where label="WR1" expression="acyclic_set_replica(SELF, parent_set)"/>
      </entity>
      <entity name="geometric_template" abstract.supertype="YES" supertypes="part_template_definition"/>
      <entity name="geometric_tolerance">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="toleranced_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <where label="WR1" expression="('NUMBER' IN TYPEOF&#10;      (magnitude\measure_with_unit.value_component))AND&#10;      (magnitude\measure_with_unit.value_component &gt;= 0.0)"/>
      </entity>
      <entity name="geometric_tolerance_group" supertypes="property_definition"/>
      <entity name="geometric_tolerance_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_geometric_tolerance">
            <typename name="geometric_tolerance"/>
         </explicit>
         <explicit name="related_geometric_tolerance">
            <typename name="geometric_tolerance"/>
         </explicit>
      </entity>
      <entity name="geometric_tolerance_with_datum_reference" supertypes="geometric_tolerance">
         <explicit name="datum_system">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="datum_reference"/>
         </explicit>
      </entity>
      <entity name="geometric_tolerance_with_defined_unit" supertypes="geometric_tolerance">
         <explicit name="unit_size">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="('NUMBER' IN TYPEOF&#10;      (unit_size\measure_with_unit.value_component))AND&#10;      (unit_size\measure_with_unit.value_component &gt; 0.0)"/>
      </entity>
      <entity name="global_assignment" supertypes="representation_item_relationship"/>
      <entity name="global_uncertainty_assigned_context" supertypes="representation_context">
         <explicit name="uncertainty">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="global_unit_assigned_context" supertypes="representation_context">
         <explicit name="units">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="unit"/>
         </explicit>
      </entity>
      <entity name="ground_fact" supertypes="atomic_formula"/>
      <entity name="group">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="group_assignment" abstract.supertype="YES">
         <explicit name="assigned_group">
            <typename name="group"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="group_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_group">
            <typename name="group"/>
         </explicit>
         <explicit name="related_group">
            <typename name="group"/>
         </explicit>
      </entity>
      <entity name="group_shape_aspect" supertypes="shape_aspect"/>
      <entity name="grouped_predefined_requirement_view_definition" supertypes="group predefined_requirement_view_definition"/>
      <entity name="half_space_2d" supertypes="geometric_representation_item">
         <explicit name="base_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="agreement_flag">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="half_space_solid" supertypes="geometric_representation_item">
         <explicit name="base_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="agreement_flag">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="hexahedron_volume" supertypes="volume">
         <explicit name="points">
            <aggregate type="LIST" lower="8" upper="8"/>
            <typename name="cartesian_point"/>
         </explicit>
         <where label="WR1" expression="above_plane(points[1], points[2], points[3], points[4])= 0.0"/>
         <where label="WR2" expression="above_plane(points[5], points[8], points[7], points[6])= 0.0"/>
         <where label="WR3" expression="above_plane(points[1], points[4], points[8], points[5])= 0.0"/>
         <where label="WR4" expression="above_plane(points[4], points[3], points[7], points[8])= 0.0"/>
         <where label="WR5" expression="above_plane(points[3], points[2], points[6], points[7])= 0.0"/>
         <where label="WR6" expression="above_plane(points[1], points[5], points[6], points[2])= 0.0"/>
         <where label="WR7" expression="same_side([points[1], points[2], points[3]],&#10;                     [points[5], points[6], points[7], points[8]])"/>
         <where label="WR8" expression="same_side([points[1], points[4], points[8]],&#10;                     [points[3], points[7], points[6], points[2]])"/>
         <where label="WR9" expression="same_side([points[1], points[2], points[5]],&#10;                      [points[3], points[7], points[8], points[4]])"/>
         <where label="WR10" expression="same_side([points[5], points[6], points[7]],&#10;                     [points[1], points[2], points[3], points[4]])"/>
         <where label="WR11" expression="same_side([points[3], points[7], points[6]],&#10;                     [points[1], points[4], points[8], points[5]])"/>
         <where label="WR12" expression="same_side([points[3], points[7], points[8]],&#10;                      [points[1], points[5], points[6], points[2]])"/>
         <where label="WR13" expression="points[1].dim = 3"/>
      </entity>
      <entity name="hyperbola" supertypes="conic">
         <explicit name="semi_axis">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="semi_imag_axis">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="id_attribute">
         <explicit name="attribute_value">
            <typename name="identifier"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="id_attribute_select"/>
         </explicit>
      </entity>
      <entity name="identification_assignment" abstract.supertype="YES">
         <explicit name="assigned_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="role">
            <typename name="identification_role"/>
         </explicit>
      </entity>
      <entity name="identification_assignment_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_identification_assignment">
            <typename name="identification_assignment"/>
         </explicit>
         <explicit name="related_identification_assignment">
            <typename name="identification_assignment"/>
         </explicit>
      </entity>
      <entity name="identification_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="illuminance_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\illuminance_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = lux"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="included_text_block" supertypes="mapped_item">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.STRUCTURED_TEXT_REPRESENTATION' IN TYPEOF(SELF\mapped_item.mapping_source.mapped_representation)"/>
      </entity>
      <entity name="inclusion_product_concept_feature" supertypes="conditional_concept_feature">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(SELF))"/>
         <where label="WR2" expression="SIZEOF(QUERY(cfr &lt;* USEDIN(SELF  ,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE')| &#10;	'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN  TYPEOF(cfr)))+ &#10;SIZEOF(QUERY(cfr &lt;* USEDIN(SELF, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE')| &#10;	'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)))= 0"/>
         <where label="WR3" expression="SELF.condition.conditional_operator.name = 'implication'"/>
      </entity>
      <entity name="inductance_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\inductance_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = henry"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="instanced_feature" supertypes="shape_aspect feature_definition">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_DEFINITION' IN&#10;         TYPEOF(SELF\shape_aspect.of_shape.definition)"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional"/>
      </entity>
      <entity name="inter_stratum_feature_template" supertypes="continuous_template" super.expression="ONEOF (component_termination_passage_template, unsupported_passage_template, via_template)"/>
      <entity name="interface_plane" supertypes="shape_aspect"/>
      <entity name="intersection_curve" supertypes="surface_curve">
         <where label="WR1" expression="SIZEOF(SELF\surface_curve.associated_geometry)= 2"/>
         <where label="WR2" expression="associated_surface(SELF\surface_curve.associated_geometry[1])&lt;&gt;&#10;             associated_surface(SELF\surface_curve.associated_geometry[2])"/>
      </entity>
      <entity name="item_defined_transformation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="transform_item_1">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="transform_item_2">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="item_identified_representation_usage">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="represented_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
         <explicit name="identified_item">
            <typename name="representation_item"/>
         </explicit>
         <where label="WR1" expression="SELF.used_representation IN &#10;       using_representations(SELF.identified_item)"/>
      </entity>
      <entity name="keepout_design_object_category" supertypes="characterized_object"/>
      <entity name="known_source" supertypes="external_source pre_defined_item"/>
      <entity name="land_physical_template" supertypes="stratum_feature_template" super.expression="ONEOF (default_passage_based_land_physical_template, default_attachment_size_based_land_physical_template)"/>
      <entity name="land_template_terminal" supertypes="shape_aspect"/>
      <entity name="language" supertypes="group">
         <where label="WR1" expression="SELF\group.name &lt;&gt; ''"/>
      </entity>
      <entity name="length_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="length_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 1.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="library_assignment" abstract.supertype="YES" supertypes="external_referent_assignment">
         <explicit name="frame_of_reference">
            <typename name="library_context"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="frame_of_reference"/>
         </unique>
      </entity>
      <entity name="library_context" supertypes="application_context_element">
         <explicit name="library_reference">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="limits_and_fits">
         <explicit name="form_variance">
            <typename name="label"/>
         </explicit>
         <explicit name="zone_variance">
            <typename name="label"/>
         </explicit>
         <explicit name="grade">
            <typename name="label"/>
         </explicit>
         <explicit name="source">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="line" supertypes="curve">
         <explicit name="pnt">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="dir">
            <typename name="vector"/>
         </explicit>
         <where label="WR1" expression="dir.dim  = pnt.dim"/>
      </entity>
      <entity name="line_profile_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 3)"/>
         <where label="WR2" expression="SIZEOF(&#10;QUERY(sar &lt;* USEDIN(SELF\geometric_tolerance.toleranced_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT')|(sar.name IN [ 'affected plane association', 'resulting intersection curve association' ])))= 1"/>
      </entity>
      <entity name="linear_profile_tolerance" supertypes="physical_unit_geometric_tolerance"/>
      <entity name="literal_conjunction" supertypes="simple_clause"/>
      <entity name="literal_disjunction" supertypes="simple_clause"/>
      <entity name="local_time">
         <explicit name="hour_component">
            <typename name="hour_in_day"/>
         </explicit>
         <explicit name="minute_component" optional="YES">
            <typename name="minute_in_hour"/>
         </explicit>
         <explicit name="second_component" optional="YES">
            <typename name="second_in_minute"/>
         </explicit>
         <explicit name="zone">
            <typename name="coordinated_universal_time_offset"/>
         </explicit>
         <where label="WR1" expression="valid_time(SELF)"/>
      </entity>
      <entity name="location">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="location_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_location">
            <typename name="location"/>
         </explicit>
         <explicit name="role">
            <typename name="location_role"/>
         </explicit>
      </entity>
      <entity name="location_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_location">
            <typename name="location"/>
         </explicit>
         <explicit name="related_location">
            <typename name="location"/>
         </explicit>
      </entity>
      <entity name="location_representation_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="represented_location">
            <typename name="location"/>
         </explicit>
         <explicit name="role">
            <typename name="location_representation_role"/>
         </explicit>
      </entity>
      <entity name="location_representation_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="location_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="location_shape_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF(SELF.items)= 1"/>
         <where label="WR2" expression="SIZEOF(QUERY(i &lt;* SELF.items | 'GEOMETRY_SCHEMA.' + 'POINT' IN TYPEOF(i)))= 1"/>
      </entity>
      <entity name="loop" supertypes="topological_representation_item" super.expression="ONEOF (vertex_loop, edge_loop, poly_loop)"/>
      <entity name="lot_effectivity" supertypes="effectivity">
         <explicit name="effectivity_lot_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_lot_size">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="luminous_flux_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\luminous_flux_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = lumen"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="luminous_intensity_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="luminous_intensity_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0)"/>
      </entity>
      <entity name="magnetic_flux_density_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\magnetic_flux_density_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = tesla"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="magnetic_flux_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\magnetic_flux_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = weber"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="make_from_functional_unit_terminal_definition_relationship" supertypes="shape_aspect shape_aspect_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="relating_shape_aspect"/>
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="related_shape_aspect"/>
         </unique>
         <where label="WR1" expression="relating_shape_aspect.of_shape :&lt;&gt;: &#10;       related_shape_aspect.of_shape"/>
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = FALSE"/>
      </entity>
      <entity name="make_from_model_port_relationship" supertypes="representation representation_relationship">
         <explicit name="rep_1">
            <typename name="analytical_model_port"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="analytical_model_port"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="rep_1"/>
            <unique.attribute attribute="rep_2"/>
         </unique>
         <where label="WR1" expression="rep_1 :&lt;&gt;: rep_2"/>
      </entity>
      <entity name="make_from_part_feature_relationship" supertypes="shape_aspect shape_aspect_relationship">
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="relating_shape_aspect"/>
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="related_shape_aspect"/>
         </unique>
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = FALSE"/>
      </entity>
      <entity name="make_from_usage_option" supertypes="product_definition_usage">
         <explicit name="ranking">
            <builtintype type="INTEGER"/>
         </explicit>
         <explicit name="ranking_rationale">
            <typename name="text"/>
         </explicit>
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="(NOT('NUMBER' IN TYPEOF(quantity.value_component)))&#10;       OR(quantity.value_component &gt; 0)"/>
      </entity>
      <entity name="make_from_usage_option_group">
         <explicit name="members">
            <aggregate type="SET" lower="2" upper="?"/>
            <typename name="make_from_usage_option"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(example &lt;* members |&#10;       example.related_product_definition&#10;       :=: members[1].related_product_definition))=SIZEOF(members)"/>
      </entity>
      <entity name="manifold_solid_brep" supertypes="solid_model">
         <explicit name="outer">
            <typename name="closed_shell"/>
         </explicit>
      </entity>
      <entity name="mapped_item" supertypes="representation_item">
         <explicit name="mapping_source">
            <typename name="representation_map"/>
         </explicit>
         <explicit name="mapping_target">
            <typename name="representation_item"/>
         </explicit>
         <where label="WR1" expression="acyclic_mapped_representation(using_representations(SELF), [SELF])"/>
      </entity>
      <entity name="mass_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="mass_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 1.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="material_addition_feature_template" supertypes="stratum_feature_template"/>
      <entity name="material_designation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="definitions">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="characterized_definition"/>
         </explicit>
      </entity>
      <entity name="material_designation_characterization">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="designation">
            <typename name="material_designation"/>
         </explicit>
         <explicit name="property">
            <typename name="characterized_material_property"/>
         </explicit>
      </entity>
      <entity name="material_designation_with_conductivity_classification" supertypes="material_designation"/>
      <entity name="material_electrical_conductivity_category" supertypes="group"/>
      <entity name="material_property" supertypes="property_definition">
         <unique label="UR1">
            <unique.attribute entity-ref="property_definition" attribute="name"/>
            <unique.attribute entity-ref="property_definition" attribute="definition"/>
         </unique>
         <where label="WR1" expression="('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN&#10;          TYPEOF(SELF\property_definition.definition))OR&#10;      (SIZEOF(bag_to_set(USEDIN(SELF ,&#10;                     'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +&#10;                     'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))-&#10;              QUERY(temp &lt;* bag_to_set(USEDIN(SELF ,&#10;                       'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +&#10;                       'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'))|&#10;                      ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +&#10;                      'MATERIAL_PROPERTY_REPRESENTATION' IN&#10;                      TYPEOF(temp))))= 0)"/>
      </entity>
      <entity name="material_property_representation" supertypes="property_definition_representation">
         <explicit name="dependent_environment">
            <typename name="data_environment"/>
         </explicit>
      </entity>
      <entity name="material_removal_feature_template" supertypes="single_stratum_continuous_template"/>
      <entity name="measure_qualification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="qualified_measure">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="qualifiers">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="value_qualifier"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(temp &lt;* qualifiers |&#10;             'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRECISION_QUALIFIER'&#10;             IN TYPEOF(temp)))&lt; 2"/>
      </entity>
      <entity name="measure_representation_item" supertypes="representation_item measure_with_unit"/>
      <entity name="measure_with_unit" super.expression="ONEOF (length_measure_with_unit, mass_measure_with_unit, time_measure_with_unit, electric_current_measure_with_unit, thermodynamic_temperature_measure_with_unit, celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit, ratio_measure_with_unit)">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <explicit name="unit_component">
            <typename name="unit"/>
         </explicit>
         <where label="WR1" expression="valid_units(SELF)"/>
      </entity>
      <entity name="model_parameter" supertypes="descriptive_representation_item group_assignment general_property">
         <explicit name="items" optional="YES">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="model_parameter_assigned_item"/>
         </explicit>
      </entity>
      <entity name="modified_geometric_tolerance" supertypes="geometric_tolerance">
         <explicit name="modifier">
            <typename name="limit_condition"/>
         </explicit>
      </entity>
      <entity name="multi_language_attribute_assignment" supertypes="attribute_value_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="multi_language_attribute_item"/>
         </explicit>
         <derived name="translation_language" expression="language_indication[1]\attribute_classification_assignment.assigned_class">
            <typename name="language"/>
         </derived>
         <inverse name="language_indication" entity="attribute_language_assignment" attribute="items">
            <inverse.aggregate type="SET" lower="1" upper="1"/>
         </inverse>
         <where label="WR1" expression="(SELF\attribute_value_assignment.role.name = 'alternate language')"/>
         <where label="WR2" expression="SIZEOF(QUERY(ala &lt;* language_indication |  &#10;  (ala\attribute_classification_assignment.attribute_name = 'attribute_value')AND &#10;  (ala\attribute_classification_assignment.role.name='translated')))= 1"/>
         <where label="WR3" expression="SELF\attribute_value_assignment.attribute_name &lt;&gt; ''"/>
         <where label="WR4" expression="SIZEOF(QUERY(ci &lt;* items |&#10;SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS')|&#10;(ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name)AND &#10;(ata.translation_language :=: translation_language)))&gt;1))=0"/>
         <where label="WR5" expression="SIZEOF(QUERY(ci &lt;* items |&#10;SIZEOF(QUERY(ata &lt;* USEDIN(ci, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')|&#10;(ata\attribute_classification_assignment.role.name='primary')AND&#10;(ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name)AND &#10;(ata\attribute_classification_assignment.assigned_class :=: translation_language)))&gt;0))=0"/>
      </entity>
      <entity name="multiple_arity_generic_expression" abstract.supertype="YES" supertypes="generic_expression">
         <explicit name="operands">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity name="name_assignment" abstract.supertype="YES">
         <explicit name="assigned_name">
            <typename name="label"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="name_attribute">
         <explicit name="attribute_value">
            <typename name="label"/>
         </explicit>
         <explicit name="named_item">
            <typename name="name_attribute_select"/>
         </explicit>
      </entity>
      <entity name="named_unit" super.expression="ONEOF (si_unit, conversion_based_unit, context_dependent_unit) ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, thermodynamic_temperature_unit, amount_of_substance_unit, luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, volume_unit, ratio_unit)">
         <explicit name="dimensions">
            <typename name="dimensional_exponents"/>
         </explicit>
      </entity>
      <entity name="network_node_definition" supertypes="product_definition"/>
      <entity name="next_assembly_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="object_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="offset_curve_2d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <where label="WR1" expression="basis_curve.dim = 2"/>
      </entity>
      <entity name="offset_curve_3d" supertypes="curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
         <explicit name="ref_direction">
            <typename name="direction"/>
         </explicit>
         <where label="WR1" expression="(basis_curve.dim = 3)AND(ref_direction.dim = 3)"/>
      </entity>
      <entity name="offset_surface" supertypes="surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="distance">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="self_intersect">
            <builtintype type="LOGICAL"/>
         </explicit>
      </entity>
      <entity name="open_path" supertypes="path">
         <derived name="ne" expression="SIZEOF(SELF\path.edge_list)">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="(SELF\path.edge_list[1].edge_element.edge_start):&lt;&gt;:&#10;                      (SELF\path.edge_list[ne].edge_element.edge_end)"/>
      </entity>
      <entity name="open_shell" supertypes="connected_face_set"/>
      <entity name="operational_requirement_occurrence_relationship" supertypes="property_definition product_definition_relationship"/>
      <entity name="opposing_boundary_dimensional_size" supertypes="dimensional_size"/>
      <entity name="ordinal_date" supertypes="date">
         <explicit name="day_component">
            <typename name="day_in_year_number"/>
         </explicit>
         <where label="WR1" expression="(NOT leap_year(SELF.year_component)AND  { 1 &lt;= day_component &lt;= 365 })OR(leap_year(SELF.year_component)AND { 1 &lt;= day_component &lt;= 366 })"/>
      </entity>
      <entity name="organization">
         <explicit name="id" optional="YES">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organization_assignment" abstract.supertype="YES">
         <explicit name="assigned_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="role">
            <typename name="organization_role"/>
         </explicit>
      </entity>
      <entity name="organization_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organization">
            <typename name="organization"/>
         </explicit>
         <explicit name="related_organization">
            <typename name="organization"/>
         </explicit>
      </entity>
      <entity name="organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="organization_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organization_type_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_organization_type">
            <typename name="organization_type"/>
         </explicit>
         <explicit name="role">
            <typename name="organization_type_role"/>
         </explicit>
      </entity>
      <entity name="organization_type_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organization_type">
            <typename name="organization_type"/>
         </explicit>
         <explicit name="related_organization_type">
            <typename name="organization_type"/>
         </explicit>
      </entity>
      <entity name="organization_type_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organizational_address" supertypes="address">
         <explicit name="organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="organizational_project">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="responsible_organizations">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </explicit>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="organizational_project_assignment" abstract.supertype="YES">
         <explicit name="assigned_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
         <explicit name="role">
            <typename name="organizational_project_role"/>
         </explicit>
      </entity>
      <entity name="organizational_project_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
         <explicit name="related_organizational_project">
            <typename name="organizational_project"/>
         </explicit>
      </entity>
      <entity name="organizational_project_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="oriented_closed_shell" supertypes="closed_shell">
         <explicit name="closed_shell_element">
            <typename name="closed_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="cfs_faces" expression="conditional_reverse(SELF.orientation,&#10;                                   SELF.closed_shell_element.cfs_faces)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_CLOSED_SHELL' &#10;                IN TYPEOF(SELF.closed_shell_element))"/>
      </entity>
      <entity name="oriented_edge" supertypes="edge">
         <explicit name="edge_element">
            <typename name="edge"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="edge_end" expression="boolean_choose(SELF.orientation,&#10;                                            SELF.edge_element.edge_end,&#10;                                            SELF.edge_element.edge_start)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <derived name="edge_start" expression="boolean_choose(SELF.orientation,&#10;                                            SELF.edge_element.edge_start,&#10;                                            SELF.edge_element.edge_end)">
            <typename name="vertex"/>
            <redeclaration entity-ref="edge"/>
         </derived>
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_EDGE' IN TYPEOF(SELF.edge_element))"/>
      </entity>
      <entity name="oriented_face" supertypes="face">
         <explicit name="face_element">
            <typename name="face"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="bounds" expression="conditional_reverse(SELF.orientation,SELF.face_element.bounds)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face_bound"/>
            <redeclaration entity-ref="face"/>
         </derived>
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_FACE' IN TYPEOF(SELF.face_element))"/>
      </entity>
      <entity name="oriented_open_shell" supertypes="open_shell">
         <explicit name="open_shell_element">
            <typename name="open_shell"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="cfs_faces" expression="conditional_reverse(SELF.orientation,&#10;                                      SELF.open_shell_element.cfs_faces)">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="face"/>
            <redeclaration entity-ref="connected_face_set"/>
         </derived>
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_OPEN_SHELL' &#10;                IN TYPEOF(SELF.open_shell_element))"/>
      </entity>
      <entity name="oriented_path" supertypes="path">
         <explicit name="path_element">
            <typename name="path"/>
         </explicit>
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <derived name="edge_list" expression="conditional_reverse(SELF.orientation,&#10;                                         SELF.path_element.edge_list)">
            <aggregate type="LIST" unique="YES" lower="1" upper="?"/>
            <typename name="oriented_edge"/>
            <redeclaration entity-ref="path"/>
         </derived>
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_PATH' IN TYPEOF(SELF.path_element))"/>
      </entity>
      <entity name="oriented_surface" supertypes="surface">
         <explicit name="orientation">
            <builtintype type="BOOLEAN"/>
         </explicit>
      </entity>
      <entity name="outer_boundary_curve" supertypes="boundary_curve"/>
      <entity name="package_product_concept_feature" supertypes="product_concept_feature">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF(SELF))"/>
         <where label="WR2" expression="SIZEOF(QUERY(cfr &lt;* USEDIN(SELF ,&#10;'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE')| &#10;('AUTOMOTIVE_DESIGN.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN  TYPEOF (cfr))AND &#10;(SIZEOF(QUERY(ipcf &lt;* USEDIN(cfr, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.' +&#10;'CONDITION')| &#10;'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(ipcf)))= 1)))&gt;0"/>
      </entity>
      <entity name="parabola" supertypes="conic">
         <explicit name="focal_dist">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="focal_dist &lt;&gt; 0.0"/>
      </entity>
      <entity name="parallel_offset" supertypes="derived_shape_aspect">
         <explicit name="offset">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="parallelism_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt; 3"/>
      </entity>
      <entity name="parameter_assignment" supertypes="parameter_assignment_representation property_definition_representation"/>
      <entity name="parameter_assignment_override" supertypes="representation representation_relationship">
         <explicit name="rep_1">
            <typename name="parameter_assignment_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="parameter_assignment_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="rep_1"/>
            <unique.attribute attribute="rep_2"/>
         </unique>
         <where label="WR1" expression="SELF\representation_relationship.rep_1 &lt;&gt; &#10;       SELF\representation_relationship.rep_2"/>
      </entity>
      <entity name="parameter_assignment_representation" supertypes="representation"/>
      <entity name="parametric_representation_context" supertypes="representation_context"/>
      <entity name="part_feature_template_definition" supertypes="feature_definition group">
         <where label="WR1" expression="SELF\group.name = SELF\characterized_object.name"/>
         <where label="WR2" expression="SELF\group.description = SELF\characterized_object.description"/>
      </entity>
      <entity name="part_template_definition" supertypes="product_definition product_definition_shape"/>
      <entity name="partial_document_with_structured_text_representation_assignment" supertypes="applied_document_usage_constraint_assignment characterized_object"/>
      <entity name="passage_technology" supertypes="characterized_object">
         <unique label="UR1">
            <unique.attribute entity-ref="characterized_object" attribute="name"/>
         </unique>
      </entity>
      <entity name="path" supertypes="topological_representation_item" super.expression="ONEOF (open_path, edge_loop, oriented_path)">
         <explicit name="edge_list">
            <aggregate type="LIST" unique="YES" lower="1" upper="?"/>
            <typename name="oriented_edge"/>
         </explicit>
         <where label="WR1" expression="path_head_to_tail(SELF)"/>
      </entity>
      <entity name="pcurve" supertypes="curve">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="reference_to_curve">
            <typename name="definitional_representation"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(reference_to_curve\representation.items)= 1"/>
         <where label="WR2" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CURVE' IN TYPEOF&#10;                   (reference_to_curve\representation.items[1])"/>
         <where label="WR3" expression="reference_to_curve\representation.items[1]\&#10;                               geometric_representation_item.dim =2"/>
      </entity>
      <entity name="perpendicular_to" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF(SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="perpendicularity_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 3"/>
      </entity>
      <entity name="person">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="last_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="first_name" optional="YES">
            <typename name="label"/>
         </explicit>
         <explicit name="middle_names" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="prefix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <explicit name="suffix_titles" optional="YES">
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="EXISTS(last_name)OR EXISTS(first_name)"/>
      </entity>
      <entity name="person_and_organization">
         <explicit name="the_person">
            <typename name="person"/>
         </explicit>
         <explicit name="the_organization">
            <typename name="organization"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="person_and_organization_address" supertypes="organizational_address personal_address">
         <explicit name="organizations">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="organization"/>
            <redeclaration entity-ref="organizational_address"/>
         </explicit>
         <explicit name="people">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="person"/>
            <redeclaration entity-ref="personal_address"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(pao &lt;* USEDIN(SELF\personal_address.people[1], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON')| pao.the_organization :=: SELF\organizational_address.organizations[1]))= 1"/>
      </entity>
      <entity name="person_and_organization_assignment" abstract.supertype="YES">
         <explicit name="assigned_person_and_organization">
            <typename name="person_and_organization"/>
         </explicit>
         <explicit name="role">
            <typename name="person_and_organization_role"/>
         </explicit>
      </entity>
      <entity name="person_and_organization_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="person_assignment" abstract.supertype="YES">
         <explicit name="assigned_person">
            <typename name="person"/>
         </explicit>
         <explicit name="role">
            <typename name="person_role"/>
         </explicit>
      </entity>
      <entity name="person_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="person_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="person_type_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_person_type">
            <typename name="person_type"/>
         </explicit>
         <explicit name="role">
            <typename name="person_type_role"/>
         </explicit>
      </entity>
      <entity name="person_type_definition">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="formation">
            <typename name="person_type_definition_formation"/>
         </explicit>
      </entity>
      <entity name="person_type_definition_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_person_type_definition">
            <typename name="person_type_definition"/>
         </explicit>
         <explicit name="role">
            <typename name="person_type_definition_role"/>
         </explicit>
      </entity>
      <entity name="person_type_definition_formation">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_person_type">
            <typename name="person_type"/>
         </explicit>
      </entity>
      <entity name="person_type_definition_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_person_type_definition">
            <typename name="person_type_definition"/>
         </explicit>
         <explicit name="related_person_type_definition">
            <typename name="person_type_definition"/>
         </explicit>
      </entity>
      <entity name="person_type_definition_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="person_type_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="personal_address" supertypes="address">
         <explicit name="people">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="person"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="physical_unit" supertypes="product_definition product_definition_shape"/>
      <entity name="physical_unit_datum" supertypes="shape_aspect" super.expression="edge_segment_vertex">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="physical_unit_datum_feature" supertypes="shape_aspect"/>
      <entity name="physical_unit_datum_target_set" supertypes="physical_unit_datum_feature"/>
      <entity name="physical_unit_geometric_tolerance" supertypes="geometric_tolerance property_definition"/>
      <entity name="placed_datum_target_feature" supertypes="datum_target">
         <derived name="representation_associations" expression="get_shape_aspect_property_definition_representations(SELF)">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="property_definition_representation"/>
         </derived>
         <where label="WR1" expression="SELF.description IN ['point','line','rectangle','circle', 'circular line']"/>
         <where label="WR2" expression="SIZEOF(QUERY(pdr &lt;* representation_associations | 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN TYPEOF(pdr.used_representation)))= 1"/>
         <where label="WR3" expression="valid_datum_target_parameters(SELF)"/>
      </entity>
      <entity name="placed_feature" supertypes="shape_aspect"/>
      <entity name="placement" supertypes="geometric_representation_item" super.expression="ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d)">
         <explicit name="location">
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="plane" supertypes="elementary_surface"/>
      <entity name="plane_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="plane_angle_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="plus_minus_tolerance">
         <explicit name="range">
            <typename name="tolerance_method_definition"/>
         </explicit>
         <explicit name="toleranced_dimension">
            <typename name="dimensional_characteristic"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="toleranced_dimension"/>
         </unique>
      </entity>
      <entity name="point" supertypes="geometric_representation_item" super.expression="ONEOF (cartesian_point, point_on_curve, point_on_surface, point_in_volume, point_replica, degenerate_pcurve)"/>
      <entity name="point_in_volume" supertypes="point">
         <explicit name="basis_volume">
            <typename name="volume"/>
         </explicit>
         <explicit name="point_parameter_u">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="point_parameter_v">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="point_parameter_w">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_on_curve" supertypes="point">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="point_parameter">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_on_surface" supertypes="point">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="point_parameter_u">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="point_parameter_v">
            <typename name="parameter_value"/>
         </explicit>
      </entity>
      <entity name="point_replica" supertypes="point">
         <explicit name="parent_pt">
            <typename name="point"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator"/>
         </explicit>
         <where label="WR1" expression="transformation.dim = parent_pt.dim"/>
         <where label="WR2" expression="acyclic_point_replica(SELF,parent_pt)"/>
      </entity>
      <entity name="polar_complex_number_literal" supertypes="generic_literal">
         <explicit name="radius">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="angle">
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="radius &gt;= 0"/>
         <where label="WR2" expression="{ 0 &lt;= angle &lt; 2*PI }"/>
      </entity>
      <entity name="polar_point" supertypes="cartesian_point">
         <explicit name="r">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="theta">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived name="coordinates" expression="[r*cos(theta), r*sin(theta)]">
            <aggregate type="LIST" lower="1" upper="3"/>
            <typename name="length_measure"/>
            <redeclaration entity-ref="cartesian_point"/>
         </derived>
         <where label="WR1" expression="r &gt;= 0.0"/>
      </entity>
      <entity name="poly_loop" supertypes="loop geometric_representation_item">
         <explicit name="polygon">
            <aggregate type="LIST" unique="YES" lower="3" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="polygonal_area" supertypes="primitive_2d">
         <explicit name="bounds">
            <aggregate type="LIST" unique="YES" lower="3" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="polyline" supertypes="bounded_curve">
         <explicit name="points">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </explicit>
      </entity>
      <entity name="port_variable" supertypes="representation representation_item" super.expression="ONEOF (across_port_variable, through_port_variable, transform_port_variable)"/>
      <entity name="position_in_organization">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="position_in_organization_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_position_in_organization">
            <typename name="position_in_organization"/>
         </explicit>
         <explicit name="role">
            <typename name="position_in_organization_role"/>
         </explicit>
      </entity>
      <entity name="position_in_organization_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_position_in_organization">
            <typename name="position_in_organization"/>
         </explicit>
         <explicit name="related_position_in_organization">
            <typename name="position_in_organization"/>
         </explicit>
      </entity>
      <entity name="position_in_organization_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="position_in_organization_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="position_in_organization_type_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_position_in_organization_type">
            <typename name="position_in_organization_type"/>
         </explicit>
         <explicit name="role">
            <typename name="position_in_organization_type_role"/>
         </explicit>
      </entity>
      <entity name="position_in_organization_type_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="position_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 3)"/>
      </entity>
      <entity name="positional_boundary" supertypes="shape_aspect">
         <where label="WR2" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="positional_boundary_member" supertypes="shape_aspect">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="power_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\power_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = watt"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="pre_defined_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="precision_qualifier">
         <explicit name="precision_value">
            <builtintype type="INTEGER"/>
         </explicit>
      </entity>
      <entity name="predefined_requirement_view_definition" supertypes="product_definition"/>
      <entity name="pressure_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\pressure_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = pascal"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="primitive_2d" supertypes="geometric_representation_item" super.expression="ONEOF (circular_area, elliptic_area, rectangular_area, polygonal_area)">
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 2"/>
      </entity>
      <entity name="process_product_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="defined_product">
            <typename name="characterized_product_definition"/>
         </explicit>
         <explicit name="process">
            <typename name="product_definition_process"/>
         </explicit>
      </entity>
      <entity name="process_property_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="process">
            <typename name="property_process"/>
         </explicit>
         <explicit name="property_or_shape">
            <typename name="property_or_shape_select"/>
         </explicit>
      </entity>
      <entity name="product">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="frame_of_reference">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_context"/>
         </explicit>
      </entity>
      <entity name="product_category">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="product_category_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="category">
            <typename name="product_category"/>
         </explicit>
         <explicit name="sub_category">
            <typename name="product_category"/>
         </explicit>
         <where label="WR1" expression="acyclic_product_category_relationship(SELF, [SELF.sub_category])"/>
      </entity>
      <entity name="product_class" supertypes="product_concept characterized_object"/>
      <entity name="product_concept">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="market_context">
            <typename name="product_concept_context"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="id"/>
         </unique>
      </entity>
      <entity name="product_concept_context" supertypes="application_context_element">
         <explicit name="market_segment_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature_association">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="feature">
            <typename name="product_concept_feature"/>
         </explicit>
      </entity>
      <entity name="product_concept_feature_category" supertypes="group">
         <where label="WR1" expression="SIZEOF(QUERY(aga &lt;* USEDIN(SELF, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP')|&#10;    ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'APPLIED_GROUP_ASSIGNMENT' IN  TYPEOF(aga))AND&#10;   ((aga.role.name &lt;&gt; 'specification category member')OR &#10;  (SIZEOF(QUERY(i &lt;* aga.items |('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'PRODUCT_CONCEPT_FEATURE' IN  TYPEOF(i))AND &#10;    NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF(i))))&lt;&gt; SIZEOF(aga.items)))&#10;     ))=0"/>
      </entity>
      <entity name="product_concept_feature_category_usage" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="category_usage_item"/>
         </explicit>
         <explicit name="assigned_group">
            <typename name="product_concept_feature_category"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
         <where label="WR1" expression="SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ]"/>
      </entity>
      <entity name="product_concept_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_concept">
            <typename name="product_concept"/>
         </explicit>
         <explicit name="related_product_concept">
            <typename name="product_concept"/>
         </explicit>
      </entity>
      <entity name="product_context" supertypes="application_context_element">
         <explicit name="discipline_type">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="product_definition_context" supertypes="application_context_element">
         <explicit name="life_cycle_stage">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="product_definition_context_association">
         <explicit name="definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="frame_of_reference">
            <typename name="product_definition_context"/>
         </explicit>
         <explicit name="role">
            <typename name="product_definition_context_role"/>
         </explicit>
      </entity>
      <entity name="product_definition_context_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_definition_effectivity" supertypes="effectivity">
         <explicit name="usage">
            <typename name="product_definition_relationship"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'))= 0"/>
      </entity>
      <entity name="product_definition_formation">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_product">
            <typename name="product"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="id"/>
            <unique.attribute attribute="of_product"/>
         </unique>
      </entity>
      <entity name="product_definition_formation_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition_formation">
            <typename name="product_definition_formation"/>
         </explicit>
         <explicit name="related_product_definition_formation">
            <typename name="product_definition_formation"/>
         </explicit>
      </entity>
      <entity name="product_definition_formation_with_specified_source" supertypes="product_definition_formation">
         <explicit name="make_or_buy">
            <typename name="source"/>
         </explicit>
      </entity>
      <entity name="product_definition_occurrence_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="occurrence">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="occurrence_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <where label="WR1" expression="occurrence_usage.relating_product_definition :&lt;&gt;: &#10;       occurrence"/>
         <where label="WR2" expression="occurrence_usage.related_product_definition :&lt;&gt;: &#10;       occurrence"/>
         <where label="WR3" expression="occurrence.formation :=:&#10;       occurrence_usage.related_product_definition.formation"/>
      </entity>
      <entity name="product_definition_process" supertypes="action">
         <explicit name="identification">
            <typename name="identifier"/>
         </explicit>
         <inverse name="product_definitions" entity="process_product_association" attribute="process">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="product_definition_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product_definition">
            <typename name="product_definition"/>
         </explicit>
         <explicit name="related_product_definition">
            <typename name="product_definition"/>
         </explicit>
      </entity>
      <entity name="product_definition_shape" supertypes="property_definition">
         <unique label="UR1">
            <unique.attribute entity-ref="property_definition" attribute="definition"/>
         </unique>
         <where label="WR1" expression="SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition))&gt; 0"/>
      </entity>
      <entity name="product_definition_substitute">
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="context_relationship">
            <typename name="product_definition_relationship"/>
         </explicit>
         <explicit name="substitute_definition">
            <typename name="product_definition"/>
         </explicit>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="context_relationship.related_product_definition :&lt;&gt;: substitute_definition"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="product_definition_usage" supertypes="product_definition_relationship" super.expression="ONEOF (make_from_usage_option, assembly_component_usage)">
         <unique label="UR1">
            <unique.attribute entity-ref="product_definition_relationship" attribute="id"/>
            <unique.attribute entity-ref="product_definition_relationship" attribute="relating_product_definition"/>
            <unique.attribute entity-ref="product_definition_relationship" attribute="related_product_definition"/>
         </unique>
         <where label="WR1" expression="acyclic_product_definition_relationship&#10;        (SELF,&#10;         [SELF\product_definition_relationship.related_product_definition],&#10;         'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_DEFINITION_USAGE')"/>
      </entity>
      <entity name="product_definition_with_associated_documents" supertypes="product_definition">
         <explicit name="documentation_ids">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document"/>
         </explicit>
      </entity>
      <entity name="product_identification" supertypes="configuration_item characterized_object">
         <explicit name="item_concept">
            <typename name="product_class"/>
            <redeclaration entity-ref="configuration_item"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(cd &lt;* USEDIN(SELF ,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CONFIGURATION_DESIGN.CONFIGURATION')|&#10;   ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'PRODUCT_DEFINITION_FORMATION' IN  TYPEOF(cd.design))AND &#10;  (SIZEOF(QUERY(prpc &lt;* USEDIN(cd.design\product_definition_formation.of_product ,&#10;     'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| &#10;         prpc.name IN ['part', 'raw material', 'tool']))&gt;0&#10;   )))&lt;=1"/>
         <where label="WR2" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'CONFIGURABLE_ITEM' IN  TYPEOF(SELF))XOR &#10;  ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="product_material_composition_relationship" supertypes="product_definition_relationship">
         <explicit name="class">
            <typename name="label"/>
         </explicit>
         <explicit name="constituent_amount">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="composition_basis">
            <typename name="label"/>
         </explicit>
         <explicit name="determination_method">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="product_related_product_category" supertypes="product_category">
         <explicit name="products">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product"/>
         </explicit>
      </entity>
      <entity name="product_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_product">
            <typename name="product"/>
         </explicit>
         <explicit name="related_product">
            <typename name="product"/>
         </explicit>
      </entity>
      <entity name="product_specific_parameter_value_assignment" supertypes="characterized_object product_related_product_category"/>
      <entity name="product_specification" supertypes="product_identification configurable_item"/>
      <entity name="projected_zone_definition" supertypes="tolerance_zone_definition">
         <explicit name="projection_end">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="projected_length">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="('NUMBER' IN TYPEOF&#10;      (projected_length\measure_with_unit.value_component))AND&#10;      (projected_length\measure_with_unit.value_component &gt; 0.0)"/>
         <where label="WR2" expression="(derive_dimensional_exponents&#10;      (projected_length\measure_with_unit.unit_component)=&#10;        dimensional_exponents(1,0,0,0,0,0,0))"/>
      </entity>
      <entity name="promissory_usage_in_product_concept_relationship" supertypes="configuration_item"/>
      <entity name="promissory_usage_occurrence" supertypes="assembly_component_usage"/>
      <entity name="property_definition">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="definition">
            <typename name="characterized_definition"/>
         </explicit>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="property_definition_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_property_definition">
            <typename name="property_definition"/>
         </explicit>
         <explicit name="related_property_definition">
            <typename name="property_definition"/>
         </explicit>
      </entity>
      <entity name="property_definition_representation">
         <explicit name="definition">
            <typename name="represented_definition"/>
         </explicit>
         <explicit name="used_representation">
            <typename name="representation"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="name" expression="get_name_value(SELF)">
            <typename name="label"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                       'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                       'NAME_ATTRIBUTE.NAMED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="property_process" supertypes="action">
         <explicit name="identification">
            <typename name="identifier"/>
         </explicit>
         <inverse name="properties" entity="process_property_association" attribute="process">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="pyramid_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="xlength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ylength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="qualification">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="qualification_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_qualification">
            <typename name="qualification"/>
         </explicit>
         <explicit name="role">
            <typename name="qualification_role"/>
         </explicit>
      </entity>
      <entity name="qualification_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_qualification">
            <typename name="qualification"/>
         </explicit>
         <explicit name="related_qualification">
            <typename name="qualification"/>
         </explicit>
      </entity>
      <entity name="qualification_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="qualification_type">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="qualification_type_assignment" abstract.supertype="YES">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="assigned_qualification_type">
            <typename name="qualification_type"/>
         </explicit>
         <explicit name="role">
            <typename name="qualification_type_role"/>
         </explicit>
      </entity>
      <entity name="qualification_type_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_qualification_type">
            <typename name="qualification_type"/>
         </explicit>
         <explicit name="related_qualification_type">
            <typename name="qualification_type"/>
         </explicit>
      </entity>
      <entity name="qualification_type_role">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="qualified_representation_item" supertypes="representation_item">
         <explicit name="qualifiers">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="value_qualifier"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(temp &lt;* qualifiers |&#10;             'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRECISION_QUALIFIER'&#10;             IN TYPEOF(temp)))&lt; 2"/>
      </entity>
      <entity name="qualitative_uncertainty" supertypes="uncertainty_qualifier">
         <explicit name="uncertainty_value">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="quantified_assembly_component_usage" supertypes="assembly_component_usage">
         <explicit name="quantity">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="(NOT('NUMBER' IN TYPEOF(quantity.value_component)))&#10;       OR(quantity.value_component &gt; 0)"/>
      </entity>
      <entity name="quasi_uniform_curve" supertypes="b_spline_curve"/>
      <entity name="quasi_uniform_surface" supertypes="b_spline_surface"/>
      <entity name="quasi_uniform_volume" supertypes="b_spline_volume"/>
      <entity name="range_characteristic" supertypes="representation descriptive_representation_item"/>
      <entity name="ratio_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="ratio_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="rational_b_spline_curve" supertypes="b_spline_curve">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="list_to_array(weights_data,0,&#10;                                      upper_index_on_control_points)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="SIZEOF(weights_data)= SIZEOF(SELF\b_spline_curve.&#10;                                           control_points_list)"/>
         <where label="WR2" expression="curve_weights_positive(SELF)"/>
      </entity>
      <entity name="rational_b_spline_surface" supertypes="b_spline_surface">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="make_array_of_array(weights_data,0,u_upper,0,v_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="(SIZEOF(weights_data)=&#10;                     SIZEOF(SELF\b_spline_surface.control_points_list))&#10;           AND(SIZEOF(weights_data[1])=&#10;                  SIZEOF(SELF\b_spline_surface.control_points_list[1]))"/>
         <where label="WR2" expression="surface_weights_positive(SELF)"/>
      </entity>
      <entity name="rational_b_spline_volume" supertypes="b_spline_volume">
         <explicit name="weights_data">
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <aggregate type="LIST" lower="2" upper="?"/>
            <builtintype type="REAL"/>
         </explicit>
         <derived name="weights" expression="make_array_of_array_of_array&#10;                            (weights_data,0,u_upper,0,v_upper,0,w_upper)">
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <aggregate type="ARRAY" lower="0" upper="0"/>
            <builtintype type="REAL"/>
         </derived>
         <where label="WR1" expression="(SIZEOF(weights_data)=&#10;                         SIZEOF(SELF\b_spline_volume.control_points_list))&#10;           AND (SIZEOF(weights_data[1])=&#10;                     SIZEOF(SELF\b_spline_volume.control_points_list[1]))&#10;            AND(SIZEOF(weights_data[1][1])=&#10;                 SIZEOF(SELF\b_spline_volume.control_points_list[1][1]))"/>
         <where label="WR2" expression="volume_weights_positive(SELF)"/>
      </entity>
      <entity name="rectangle_domain" supertypes="founded_item">
         <explicit name="corner">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="xlength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ylength">
            <typename name="positive_length_measure"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(item &lt;* USEDIN(SELF, '')| NOT&#10;  ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.RECTANGLED_HALF_SPACE' IN TYPEOF(item))))= 0"/>
      </entity>
      <entity name="rectangled_half_space" supertypes="half_space_2d">
         <explicit name="enclosure">
            <typename name="rectangle_domain"/>
         </explicit>
      </entity>
      <entity name="rectangular_area" supertypes="primitive_2d">
         <explicit name="position">
            <typename name="axis2_placement_2d"/>
         </explicit>
         <explicit name="x">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="y">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="rectangular_composite_surface" supertypes="bounded_surface">
         <explicit name="segments">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <typename name="surface_patch"/>
         </explicit>
         <derived name="n_u" expression="SIZEOF(segments)">
            <builtintype type="INTEGER"/>
         </derived>
         <derived name="n_v" expression="SIZEOF(segments[1])">
            <builtintype type="INTEGER"/>
         </derived>
         <where label="WR1" expression="SIZEOF(QUERY(s &lt;* segments | n_v &lt;&gt; SIZEOF(s)))= 0"/>
         <where label="WR2" expression="constraints_rectangular_composite_surface(SELF)"/>
      </entity>
      <entity name="rectangular_pyramid" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="xlength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ylength">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="rectangular_trimmed_surface" supertypes="bounded_surface">
         <explicit name="basis_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="u1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="u2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="usense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="vsense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <where label="WR1" expression="u1 &lt;&gt; u2"/>
         <where label="WR2" expression="v1 &lt;&gt; v2"/>
         <where label="WR3" expression="(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ELEMENTARY_SURFACE' IN  TYPEOF(basis_surface))&#10;       AND (NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PLANE' IN  TYPEOF(basis_surface))))OR&#10;     ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))&#10;          OR(usense =(u2 &gt; u1))"/>
         <where label="WR4" expression="(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SPHERICAL_SURFACE' IN  TYPEOF(basis_surface))&#10;          OR&#10;        ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))&#10;          OR(vsense =(v2 &gt; v1))"/>
      </entity>
      <entity name="reference_graphic_registration_mark" supertypes="shape_aspect">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = false"/>
      </entity>
      <entity name="referenced_modified_datum" supertypes="datum_reference">
         <explicit name="modifier">
            <typename name="limit_condition"/>
         </explicit>
      </entity>
      <entity name="relative_event_occurrence" supertypes="event_occurrence">
         <explicit name="base_event">
            <typename name="event_occurrence"/>
         </explicit>
         <explicit name="offset">
            <typename name="time_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="reparametrised_composite_curve_segment" supertypes="composite_curve_segment">
         <explicit name="param_length">
            <typename name="parameter_value"/>
         </explicit>
         <where label="WR1" expression="param_length &gt; 0.0"/>
      </entity>
      <entity name="replacement_relationship" supertypes="action_relationship">
         <where label="WR1" expression="acyclic_action_relationship(SELF,&#10;       [SELF\action_relationship.related_action],&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.REPLACEMENT_RELATIONSHIP')"/>
      </entity>
      <entity name="representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="representation_item"/>
         </explicit>
         <explicit name="context_of_items">
            <typename name="representation_context"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                             'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&#10;       &lt;= 1"/>
         <where label="WR2" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +&#10;                             'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&#10;       &lt;= 1"/>
      </entity>
      <entity name="representation_context">
         <explicit name="context_identifier">
            <typename name="identifier"/>
         </explicit>
         <explicit name="context_type">
            <typename name="text"/>
         </explicit>
         <inverse name="representations_in_context" entity="representation" attribute="context_of_items">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
      </entity>
      <entity name="representation_item">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(using_representations(SELF))&gt; 0"/>
      </entity>
      <entity name="representation_item_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_representation_item">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="related_representation_item">
            <typename name="representation_item"/>
         </explicit>
      </entity>
      <entity name="representation_map">
         <explicit name="mapping_origin">
            <typename name="representation_item"/>
         </explicit>
         <explicit name="mapped_representation">
            <typename name="representation"/>
         </explicit>
         <inverse name="map_usage" entity="mapped_item" attribute="mapping_source">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="item_in_context(SELF.mapping_origin,&#10;       SELF.mapped_representation.context_of_items)"/>
      </entity>
      <entity name="representation_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="rep_1">
            <typename name="representation"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="representation_relationship_with_transformation" supertypes="representation_relationship">
         <explicit name="transformation_operator">
            <typename name="transformation"/>
         </explicit>
         <where label="WR1" expression="SELF\representation_relationship.rep_1.context_of_items&#10;   :&lt;&gt;: SELF\representation_relationship.rep_2.context_of_items"/>
      </entity>
      <entity name="requirement_assigned_object" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="requirement_assigned_item"/>
         </explicit>
         <explicit name="assigned_group">
            <typename name="requirement_assignment"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
      </entity>
      <entity name="requirement_assignment" supertypes="characterized_object group"/>
      <entity name="requirement_definition" supertypes="product_definition"/>
      <entity name="requirement_for_action_resource" supertypes="action_resource_requirement">
         <explicit name="resources">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_resource"/>
         </explicit>
      </entity>
      <entity name="requirement_source" supertypes="group"/>
      <entity name="requirement_view_definition_relationship" supertypes="product_definition_relationship"/>
      <entity name="resistance_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\measure_with_unit ||&#10;       SELF\resistance_measure_with_unit)))= 0"/>
         <where label="WR2" expression="SELF\measure_with_unit.unit_component\si_unit.name = ohm"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SI_UNIT' IN &#10;       TYPEOF(SELF\measure_with_unit.unit_component)"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NUMERIC_MEASURE' IN &#10;       TYPEOF(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="resource_property">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="resource">
            <typename name="characterized_resource_definition"/>
         </explicit>
      </entity>
      <entity name="resource_property_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_resource_property">
            <typename name="resource_property"/>
         </explicit>
         <explicit name="related_resource_property">
            <typename name="resource_property"/>
         </explicit>
         <where label="WR1" expression="relating_resource_property :&lt;&gt;: related_resource_property"/>
      </entity>
      <entity name="resource_property_representation">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="property">
            <typename name="resource_property"/>
         </explicit>
         <explicit name="representation">
            <typename name="representation"/>
         </explicit>
      </entity>
      <entity name="resource_requirement_type">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="resource_requirement_type_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_requirement_type">
            <typename name="resource_requirement_type"/>
         </explicit>
         <explicit name="related_requirement_type">
            <typename name="resource_requirement_type"/>
         </explicit>
         <where label="WR1" expression="relating_requirement_type :&lt;&gt;: related_requirement_type"/>
      </entity>
      <entity name="revolved_area_solid" supertypes="swept_area_solid">
         <explicit name="axis">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived name="axis_line" expression="representation_item('')||&#10;                    geometric_representation_item()|| curve()||&#10;                    line(axis.location, representation_item('')||&#10;                    geometric_representation_item()||&#10;                    vector(axis.z, 1.0))">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="revolved_face_solid" supertypes="swept_face_solid">
         <explicit name="axis">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived name="axis_line" expression="representation_item('')||&#10;                    geometric_representation_item()|| curve()||&#10;                    line(axis.location, representation_item('')||&#10;                    geometric_representation_item()||&#10;                    vector(axis.z, 1.0))">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="right_angular_wedge" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="x">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="y">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ltx">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="((0.0 &lt;= ltx)AND(ltx &lt; x))"/>
      </entity>
      <entity name="right_circular_cone" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="radius">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="semi_angle">
            <typename name="plane_angle_measure"/>
         </explicit>
         <where label="WR1" expression="radius &gt;= 0.0"/>
      </entity>
      <entity name="right_circular_cylinder" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="height">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="role_association">
         <explicit name="role">
            <typename name="object_role"/>
         </explicit>
         <explicit name="item_with_role">
            <typename name="role_select"/>
         </explicit>
      </entity>
      <entity name="roundness_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="row_representation_item" supertypes="compound_representation_item">
         <where label="WR1" expression="SIZEOF(QUERY(itet &lt;* SELF\compound_representation_item.item_element |&#10;       NOT('REPRESENTATION_SCHEMA.LIST_REPRESENTATION_ITEM' IN TYPEOF(itet))&#10;           ))= 0"/>
      </entity>
      <entity name="row_value" supertypes="compound_representation_item"/>
      <entity name="row_variable" supertypes="abstract_variable"/>
      <entity name="rule_action" supertypes="action"/>
      <entity name="rule_condition" supertypes="atomic_formula"/>
      <entity name="rule_definition" supertypes="rule_software_definition"/>
      <entity name="rule_set" supertypes="rule_software_definition"/>
      <entity name="rule_set_group" supertypes="rule_software_definition"/>
      <entity name="rule_software_definition" supertypes="product_definition"/>
      <entity name="rule_superseded_assignment" supertypes="action_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="rule_superseded_item"/>
         </explicit>
      </entity>
      <entity name="rule_supersedence" supertypes="rule_action"/>
      <entity name="runout_zone_definition" supertypes="tolerance_zone_definition">
         <explicit name="orientation">
            <typename name="runout_zone_orientation"/>
         </explicit>
      </entity>
      <entity name="runout_zone_orientation">
         <explicit name="angle">
            <typename name="measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="runout_zone_orientation_reference_direction" supertypes="runout_zone_orientation">
         <explicit name="orientation_defining_relationship">
            <typename name="shape_aspect_relationship"/>
         </explicit>
      </entity>
      <entity name="scalar_terminal_definition_link" supertypes="shape_aspect shape_aspect_relationship">
         <explicit name="relating_shape_aspect">
            <typename name="functional_unit_terminal_definition"/>
            <redeclaration entity-ref="shape_aspect_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute entity-ref="shape_aspect_relationship" attribute="related_shape_aspect"/>
            <unique.attribute attribute="relating_shape_aspect"/>
         </unique>
         <where label="WR1" expression="SELF\shape_aspect_relationship.related_shape_aspect :&lt;&gt;:&#10;       SELF\shape_aspect_relationship.relating_shape_aspect"/>
      </entity>
      <entity name="scalar_variable" supertypes="abstract_variable"/>
      <entity name="scattering_parameter" supertypes="polar_complex_number_literal">
         <where label="WR1" expression="SIZEOF(TYPEOF(SELF)-(TYPEOF(SELF\polar_complex_number_literal ||&#10;       SELF\scattering_parameter)))= 0"/>
      </entity>
      <entity name="schema_based_model_parameter" supertypes="model_parameter"/>
      <entity name="seam_curve" supertypes="surface_curve">
         <where label="WR1" expression="SIZEOF(SELF\surface_curve.associated_geometry)= 2"/>
         <where label="WR2" expression="associated_surface(SELF\surface_curve.associated_geometry[1])=&#10;           associated_surface(SELF\surface_curve.associated_geometry[2])"/>
         <where label="WR3" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN&#10;           TYPEOF(SELF\surface_curve.associated_geometry[1])"/>
         <where label="WR4" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN&#10;            TYPEOF(SELF\surface_curve.associated_geometry[2])"/>
      </entity>
      <entity name="seam_edge" supertypes="oriented_edge">
         <explicit name="pcurve_reference">
            <typename name="pcurve"/>
         </explicit>
         <where label="WR1" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.EDGE_CURVE' IN  TYPEOF(edge_element))AND&#10;               ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SEAM_CURVE' IN TYPEOF&#10;                      (edge_element\edge_curve.edge_geometry))"/>
         <where label="WR2" expression="pcurve_reference IN edge_element\edge_curve.edge_geometry\&#10;                                 surface_curve.associated_geometry"/>
      </entity>
      <entity name="seating_plane" supertypes="shape_aspect"/>
      <entity name="sectioned_spine" supertypes="geometric_curve_set">
         <explicit name="cross_sections">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="curve"/>
         </explicit>
         <explicit name="spine_points">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="point"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(SELF\geometric_set.elements)= 1"/>
         <where label="WR2" expression="'GEOMETRY_SCHEMA.CURVE' IN&#10;                     TYPEOF(SELF\geometric_set.elements[1])"/>
         <where label="WR3" expression="SIZEOF(cross_sections)= SIZEOF(spine_points)"/>
         <where label="WR4" expression="SELF\geometric_representation_item.dim = 3"/>
      </entity>
      <entity name="security_classification">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="security_level">
            <typename name="security_classification_level"/>
         </explicit>
      </entity>
      <entity name="security_classification_assignment" abstract.supertype="YES">
         <explicit name="assigned_security_classification">
            <typename name="security_classification"/>
         </explicit>
         <derived name="role" expression="get_role(SELF)">
            <typename name="object_role"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE'))&lt;= 1"/>
      </entity>
      <entity name="security_classification_level">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="serial_numbered_effectivity" supertypes="effectivity">
         <explicit name="effectivity_start_id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="effectivity_end_id" optional="YES">
            <typename name="identifier"/>
         </explicit>
      </entity>
      <entity name="shape_aspect">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="of_shape">
            <typename name="product_definition_shape"/>
         </explicit>
         <explicit name="product_definitional">
            <builtintype type="LOGICAL"/>
         </explicit>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="shape_aspect_deriving_relationship" supertypes="shape_aspect_relationship">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DERIVED_SHAPE_ASPECT' IN&#10;TYPEOF&#10;           (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT)"/>
      </entity>
      <entity name="shape_aspect_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <explicit name="related_shape_aspect">
            <typename name="shape_aspect"/>
         </explicit>
         <derived name="id" expression="get_id_value(SELF)">
            <typename name="identifier"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="shape_definition_representation" supertypes="property_definition_representation">
         <where label="WR1" expression="('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN&#10;       TYPEOF (SELF.definition))&#10;       OR&#10;      ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN&#10;       TYPEOF(SELF.definition.definition))"/>
         <where label="WR2" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SHAPE_REPRESENTATION' IN&#10;       TYPEOF(SELF.used_representation)"/>
      </entity>
      <entity name="shape_dimension_representation" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF(QUERY(temp &lt;* SELF\representation.items | &#10;    NOT('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' &#10;        IN TYPEOF(temp))))= 0"/>
         <where label="WR2" expression="SIZEOF(SELF\representation.items)&lt;= 3"/>
         <where label="WR3" expression="SIZEOF(QUERY(pos_mri &lt;* QUERY(real_mri &lt;*&#10;        SELF\representation.items | 'REAL' IN TYPEOF&#10;       (real_mri\measure_with_unit.value_component))|        &#10;     NOT (pos_mri\measure_with_unit.value_component &gt; 0.0)))= 0"/>
      </entity>
      <entity name="shape_representation" supertypes="representation"/>
      <entity name="shape_representation_relationship" supertypes="representation_relationship">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SHAPE_REPRESENTATION' IN&#10;      (TYPEOF(SELF\representation_relationship.rep_1)+&#10;        TYPEOF(SELF\representation_relationship.rep_2))"/>
      </entity>
      <entity name="shape_representation_with_parameters" supertypes="shape_representation">
         <where label="WR1" expression="SIZEOF(QUERY(i &lt;* SELF.items | SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PLACEMENT', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM'] * TYPEOF(i))= 1))= SIZEOF(SELF.items)"/>
      </entity>
      <entity name="shell_based_surface_model" supertypes="geometric_representation_item">
         <explicit name="sbsm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where label="WR1" expression="constraints_geometry_shell_based_surface_model(SELF)"/>
      </entity>
      <entity name="shell_based_wireframe_model" supertypes="geometric_representation_item">
         <explicit name="sbwm_boundary">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shell"/>
         </explicit>
         <where label="WR1" expression="constraints_geometry_shell_based_wireframe_model(SELF)"/>
      </entity>
      <entity name="si_unit" supertypes="named_unit">
         <explicit name="prefix" optional="YES">
            <typename name="si_prefix"/>
         </explicit>
         <explicit name="name">
            <typename name="si_unit_name"/>
         </explicit>
         <derived name="dimensions" expression="dimensions_for_si_unit(name)">
            <typename name="dimensional_exponents"/>
            <redeclaration entity-ref="named_unit"/>
         </derived>
      </entity>
      <entity name="signal" supertypes="characterized_object"/>
      <entity name="signal_category" supertypes="group"/>
      <entity name="simple_clause" supertypes="compound_representation_item"/>
      <entity name="simple_generic_expression" abstract.supertype="YES" supertypes="generic_expression" super.expression="ONEOF (generic_literal, generic_variable)"/>
      <entity name="single_area_csg_2d_shape_representation" supertypes="csg_2d_shape_representation">
         <where label="WR1" expression="SIZEOF(QUERY(it &lt;* SELF.items| &#10;    ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MAPPED_ITEM' &#10;     IN TYPEOF(it))))= 0"/>
         <where label="WR2" expression="SIZEOF(QUERY(it &lt;* SELF.items| &#10;    ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CSG_SOLID' &#10;     IN TYPEOF(it))))= 1"/>
      </entity>
      <entity name="single_boundary_csg_2d_shape_representation" supertypes="single_area_csg_2d_shape_representation"/>
      <entity name="single_stratum_continuous_template" abstract.supertype="YES" supertypes="continuous_template single_stratum_template" super.expression="ONEOF (stratum_feature_template, material_removal_feature_template)"/>
      <entity name="single_stratum_template" abstract.supertype="YES" supertypes="geometric_template" super.expression="ONEOF (stratum_feature_template, material_removal_feature_template)"/>
      <entity name="solid_angle_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="solid_angle_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="solid_model" supertypes="geometric_representation_item" super.expression="ONEOF (csg_solid, manifold_solid_brep, swept_face_solid, swept_area_solid, swept_disk_solid, solid_replica, brep_2d, trimmed_volume)"/>
      <entity name="solid_replica" supertypes="solid_model">
         <explicit name="parent_solid">
            <typename name="solid_model"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator_3d"/>
         </explicit>
         <where label="WR1" expression="acyclic_solid_replica(SELF, parent_solid)"/>
         <where label="WR2" expression="parent_solid\geometric_representation_item.dim = 3"/>
      </entity>
      <entity name="source_for_requirement" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="requirement_source_item"/>
         </explicit>
         <explicit name="assigned_group">
            <typename name="requirement_source"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
      </entity>
      <entity name="sourced_requirement" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="1"/>
            <typename name="product_definition"/>
         </explicit>
         <explicit name="assigned_group">
            <typename name="requirement_source"/>
            <redeclaration entity-ref="group_assignment"/>
         </explicit>
      </entity>
      <entity name="specification_definition" supertypes="product_definition"/>
      <entity name="specified_higher_usage_occurrence" supertypes="assembly_component_usage">
         <explicit name="upper_usage">
            <typename name="assembly_component_usage"/>
         </explicit>
         <explicit name="next_usage">
            <typename name="next_assembly_usage_occurrence"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="upper_usage"/>
            <unique.attribute attribute="next_usage"/>
         </unique>
         <where label="WR1" expression="SELF :&lt;&gt;: upper_usage"/>
         <where label="WR2" expression="SELF\product_definition_relationship.relating_product_definition&#10;       :=: upper_usage.relating_product_definition"/>
         <where label="WR3" expression="SELF\product_definition_relationship.related_product_definition&#10;       :=: next_usage.related_product_definition"/>
         <where label="WR4" expression="(upper_usage.related_product_definition :=:&#10;       next_usage.relating_product_definition)OR&#10;      (SIZEOF(QUERY(pdr &lt;* USEDIN(upper_usage.related_product_definition,&#10;       'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +&#10;       'RELATED_PRODUCT_DEFINITION')|&#10;        pdr.relating_product_definition :=: &#10;        next_usage.relating_product_definition))= 1)"/>
         <where label="WR5" expression="SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE']&#10;       * TYPEOF(upper_usage))= 1"/>
      </entity>
      <entity name="sphere" supertypes="geometric_representation_item">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="centre">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="spherical_point" supertypes="cartesian_point">
         <explicit name="r">
            <typename name="length_measure"/>
         </explicit>
         <explicit name="theta">
            <typename name="plane_angle_measure"/>
         </explicit>
         <explicit name="phi">
            <typename name="plane_angle_measure"/>
         </explicit>
         <derived name="coordinates" expression="[r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)]">
            <aggregate type="LIST" lower="1" upper="3"/>
            <typename name="length_measure"/>
            <redeclaration entity-ref="cartesian_point"/>
         </derived>
         <where label="WR1" expression="r &gt;= 0.0"/>
      </entity>
      <entity name="spherical_surface" supertypes="elementary_surface">
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="spherical_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="standard_uncertainty" supertypes="uncertainty_qualifier" super.expression="expanded_uncertainty">
         <explicit name="uncertainty_value">
            <builtintype type="REAL"/>
         </explicit>
      </entity>
      <entity name="statistical_dimensional_location" supertypes="dimensional_location"/>
      <entity name="statistical_dimensional_size" supertypes="dimensional_size_property"/>
      <entity name="statistical_distribution_for_tolerance" supertypes="representation">
         <where label="WR1" expression="SIZEOF(QUERY(item &lt;* SELF\representation.items |&#10;       NOT('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' &#10;       IN TYPEOF(item))))= 0"/>
      </entity>
      <entity name="statistical_geometric_tolerance" supertypes="physical_unit_geometric_tolerance"/>
      <entity name="straightness_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))"/>
      </entity>
      <entity name="stratum_feature_template" supertypes="single_stratum_continuous_template"/>
      <entity name="stratum_stack_model" abstract.supertype="YES" supertypes="part_template_definition"/>
      <entity name="stratum_technology" supertypes="characterized_object">
         <unique label="UR1">
            <unique.attribute entity-ref="characterized_object" attribute="name"/>
         </unique>
      </entity>
      <entity name="stratum_technology_occurrence" supertypes="property_definition"/>
      <entity name="stratum_technology_occurrence_link" supertypes="property_definition property_definition_relationship"/>
      <entity name="stratum_technology_occurrence_swap_relationship" supertypes="property_definition property_definition_relationship"/>
      <entity name="stratum_technology_swap_relationship" supertypes="property_definition_relationship"/>
      <entity name="structured_text_composition" supertypes="compound_representation_item"/>
      <entity name="structured_text_representation" supertypes="representation">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="string_representation_item_select"/>
            <redeclaration entity-ref="representation"/>
         </explicit>
      </entity>
      <entity name="subedge" supertypes="edge">
         <explicit name="parent_edge">
            <typename name="edge"/>
         </explicit>
      </entity>
      <entity name="subface" supertypes="face">
         <explicit name="parent_face">
            <typename name="face"/>
         </explicit>
         <where label="WR1" expression="NOT(mixed_loop_type_set(list_to_set(list_face_loops(SELF))+&#10;              list_to_set(list_face_loops(parent_face))))"/>
      </entity>
      <entity name="surface" supertypes="geometric_representation_item" super.expression="ONEOF (elementary_surface, swept_surface, bounded_surface, offset_surface, surface_replica)"/>
      <entity name="surface_curve" supertypes="curve" super.expression="ONEOF (intersection_curve, seam_curve) ANDOR bounded_surface_curve">
         <explicit name="curve_3d">
            <typename name="curve"/>
         </explicit>
         <explicit name="associated_geometry">
            <aggregate type="LIST" lower="1" upper="2"/>
            <typename name="pcurve_or_surface"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="preferred_surface_curve_representation"/>
         </explicit>
         <derived name="basis_surface" expression="get_basis_surface(SELF)">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="surface"/>
         </derived>
         <where label="WR1" expression="curve_3d.dim = 3"/>
         <where label="WR2" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[1]))OR&#10;                       (master_representation &lt;&gt; pcurve_s1)"/>
         <where label="WR3" expression="('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN TYPEOF(associated_geometry[2]))OR&#10;                       (master_representation &lt;&gt; pcurve_s2)"/>
         <where label="WR4" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN TYPEOF(curve_3d))"/>
      </entity>
      <entity name="surface_curve_swept_area_solid" supertypes="swept_area_solid">
         <explicit name="directrix">
            <typename name="curve"/>
         </explicit>
         <explicit name="start_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="end_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="reference_surface">
            <typename name="surface"/>
         </explicit>
         <where label="WR1" expression="(NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR&#10;         (reference_surface IN(directrix\surface_curve.basis_surface))"/>
      </entity>
      <entity name="surface_curve_swept_face_solid" supertypes="swept_face_solid">
         <explicit name="directrix">
            <typename name="curve"/>
         </explicit>
         <explicit name="start_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="end_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="reference_surface">
            <typename name="surface"/>
         </explicit>
         <where label="WR1" expression="(NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(directrix)))OR&#10;         (reference_surface IN(directrix\surface_curve.basis_surface))"/>
      </entity>
      <entity name="surface_curve_swept_surface" supertypes="swept_surface">
         <explicit name="directrix">
            <typename name="curve"/>
         </explicit>
         <explicit name="reference_surface">
            <typename name="surface"/>
         </explicit>
         <where label="WR1" expression="(NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF(directrix)))OR&#10;         (reference_surface IN(directrix\surface_curve.basis_surface))"/>
      </entity>
      <entity name="surface_of_linear_extrusion" supertypes="swept_surface">
         <explicit name="extrusion_axis">
            <typename name="vector"/>
         </explicit>
      </entity>
      <entity name="surface_of_revolution" supertypes="swept_surface">
         <explicit name="axis_position">
            <typename name="axis1_placement"/>
         </explicit>
         <derived name="axis_line" expression="representation_item('')||&#10;                     geometric_representation_item()|| curve()||&#10;                     line(axis_position.location, representation_item('')||&#10;                     geometric_representation_item()||&#10;                     vector(axis_position.z, 1.0))">
            <typename name="line"/>
         </derived>
      </entity>
      <entity name="surface_patch" supertypes="founded_item">
         <explicit name="parent_surface">
            <typename name="bounded_surface"/>
         </explicit>
         <explicit name="u_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="v_transition">
            <typename name="transition_code"/>
         </explicit>
         <explicit name="u_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="v_sense">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <inverse name="using_surfaces" entity="rectangular_composite_surface" attribute="segments">
            <inverse.aggregate type="BAG" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="(NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CURVE_BOUNDED_SURFACE' &#10;                 IN TYPEOF(parent_surface)))"/>
      </entity>
      <entity name="surface_profile_tolerance" supertypes="geometric_tolerance">
         <where label="WR1" expression="NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GEOMETRIC_TOLERANCE_WITH_DATUM_REFERENCE' IN TYPEOF(SELF))OR(SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 3)"/>
      </entity>
      <entity name="surface_replica" supertypes="surface">
         <explicit name="parent_surface">
            <typename name="surface"/>
         </explicit>
         <explicit name="transformation">
            <typename name="cartesian_transformation_operator_3d"/>
         </explicit>
         <where label="WR1" expression="acyclic_surface_replica(SELF, parent_surface)"/>
      </entity>
      <entity name="swept_area_solid" supertypes="solid_model" super.expression="ONEOF (revolved_area_solid, extruded_area_solid, surface_curve_swept_area_solid)">
         <explicit name="swept_area">
            <typename name="curve_bounded_surface"/>
         </explicit>
         <where label="WR1" expression="'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface)"/>
      </entity>
      <entity name="swept_disk_solid" supertypes="solid_model">
         <explicit name="directrix">
            <typename name="curve"/>
         </explicit>
         <explicit name="radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="inner_radius" optional="YES">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="start_param">
            <builtintype type="REAL"/>
         </explicit>
         <explicit name="end_param">
            <builtintype type="REAL"/>
         </explicit>
         <where label="WR1" expression="directrix.dim = 3"/>
         <where label="WR2" expression="(NOT EXISTS(inner_radius))OR(radius &gt; inner_radius)"/>
      </entity>
      <entity name="swept_face_solid" supertypes="solid_model" super.expression="ONEOF (extruded_face_solid, revolved_face_solid, surface_curve_swept_face_solid)">
         <explicit name="swept_face">
            <typename name="face_surface"/>
         </explicit>
         <where label="WR1" expression="'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry)"/>
      </entity>
      <entity name="swept_surface" supertypes="surface" super.expression="ONEOF (surface_of_linear_extrusion, surface_of_revolution, surface_curve_swept_surface, fixed_reference_swept_surface)">
         <explicit name="swept_curve">
            <typename name="curve"/>
         </explicit>
      </entity>
      <entity name="symbol" supertypes="representation_item"/>
      <entity name="symmetric_shape_aspect" supertypes="shape_aspect">
         <inverse name="basis_relationships" entity="shape_aspect_relationship" attribute="relating_shape_aspect">
            <inverse.aggregate type="SET" lower="1" upper="?"/>
         </inverse>
         <where label="WR1" expression="SIZEOF(QUERY(x&lt;*SELF\symmetric_shape_aspect.basis_relationships |&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CENTRE_OF_SYMMETRY' IN TYPEOF &#10;      (x\shape_aspect_relationship.related_shape_aspect)))&gt;=1"/>
      </entity>
      <entity name="symmetry_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 3"/>
      </entity>
      <entity name="table_representation_item" supertypes="compound_representation_item characterized_object">
         <where label="WR1" expression="SIZEOF(QUERY(itet &lt;* SELF\compound_representation_item.item_element |&#10;       NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ROW_REPRESENTATION_ITEM' IN TYPEOF(itet))&#10;           ))= 0"/>
      </entity>
      <entity name="tagged_text_format" supertypes="class representation_context"/>
      <entity name="tagged_text_item" supertypes="descriptive_representation_item"/>
      <entity name="tangent" supertypes="derived_shape_aspect">
         <where label="WR1" expression="SIZEOF(SELF\derived_shape_aspect.deriving_relationships)= 1"/>
      </entity>
      <entity name="test_method_based_parameter_assignment" supertypes="parameter_assignment"/>
      <entity name="tetrahedron" supertypes="faceted_primitive">
         <where label="WR1" expression="SIZEOF(points)= 4"/>
         <where label="WR2" expression="above_plane(points[1], points[2], points[3], points[4])&lt;&gt; 0.0"/>
      </entity>
      <entity name="tetrahedron_volume" supertypes="volume">
         <explicit name="point_1">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="point_2">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="point_3">
            <typename name="cartesian_point"/>
         </explicit>
         <explicit name="point_4">
            <typename name="cartesian_point"/>
         </explicit>
         <where label="WR1" expression="point_1.dim = 3"/>
         <where label="WR2" expression="above_plane(point_1, point_2, point_3, point_4)&lt;&gt; 0.0"/>
      </entity>
      <entity name="thermodynamic_temperature_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="thermodynamic_temperature_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 0.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="through_port_variable" supertypes="port_variable"/>
      <entity name="time_assignment" abstract.supertype="YES">
         <explicit name="assigned_time">
            <typename name="local_time"/>
         </explicit>
         <explicit name="role">
            <typename name="time_role"/>
         </explicit>
      </entity>
      <entity name="time_interval">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="time_interval_assignment" abstract.supertype="YES">
         <explicit name="assigned_time_interval">
            <typename name="time_interval"/>
         </explicit>
         <explicit name="role">
            <typename name="time_interval_role"/>
         </explicit>
      </entity>
      <entity name="time_interval_based_effectivity" supertypes="effectivity">
         <explicit name="effectivity_period">
            <typename name="time_interval"/>
         </explicit>
      </entity>
      <entity name="time_interval_relationship">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_time_interval">
            <typename name="time_interval"/>
         </explicit>
         <explicit name="related_time_interval">
            <typename name="time_interval"/>
         </explicit>
      </entity>
      <entity name="time_interval_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="time_interval_with_bounds" supertypes="time_interval">
         <explicit name="primary_bound" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="secondary_bound" optional="YES">
            <typename name="date_time_or_event_occurrence"/>
         </explicit>
         <explicit name="duration" optional="YES">
            <typename name="time_measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="NOT(EXISTS(secondary_bound)AND EXISTS(duration))"/>
         <where label="WR2" expression="EXISTS(primary_bound)OR EXISTS(secondary_bound)"/>
      </entity>
      <entity name="time_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="time_role">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <derived name="description" expression="get_description_value(SELF)">
            <typename name="text"/>
         </derived>
         <where label="WR1" expression="SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))&lt;= 1"/>
      </entity>
      <entity name="time_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 0.0)AND (SELF\named_unit.dimensions.mass_exponent = 0.0)AND (SELF\named_unit.dimensions.time_exponent = 1.0)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0)"/>
      </entity>
      <entity name="tolerance_value">
         <explicit name="lower_bound">
            <typename name="measure_with_unit"/>
         </explicit>
         <explicit name="upper_bound">
            <typename name="measure_with_unit"/>
         </explicit>
         <where label="WR1" expression="upper_bound\measure_with_unit.value_component &gt;&#10;        lower_bound\measure_with_unit.value_component"/>
         <where label="WR2" expression="upper_bound\measure_with_unit.unit_component =&#10;        lower_bound\measure_with_unit.unit_component"/>
      </entity>
      <entity name="tolerance_with_statistical_distribution">
         <explicit name="associated_tolerance">
            <typename name="shape_tolerance_select"/>
         </explicit>
         <explicit name="tolerance_allocation">
            <typename name="statistical_distribution_for_tolerance"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone" supertypes="shape_aspect">
         <explicit name="defining_tolerance">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="geometric_tolerance"/>
         </explicit>
         <explicit name="form">
            <typename name="tolerance_zone_form"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_boundary" supertypes="shape_aspect">
         <where label="WR1" expression="SELF\shape_aspect.product_definitional = False"/>
      </entity>
      <entity name="tolerance_zone_definition" super.expression="ONEOF (projected_zone_definition, runout_zone_definition)">
         <explicit name="zone">
            <typename name="tolerance_zone"/>
         </explicit>
         <explicit name="boundaries">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shape_aspect"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_explicit_opposing_boundary_set" supertypes="tolerance_zone_boundary"/>
      <entity name="tolerance_zone_form">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="tolerance_zone_implicit_opposing_boundary_set" supertypes="tolerance_zone_boundary"/>
      <entity name="topological_representation_item" supertypes="representation_item" super.expression="ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, connected_edge_set, connected_face_set, (loop ANDOR path))"/>
      <entity name="toroidal_surface" supertypes="elementary_surface">
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
      </entity>
      <entity name="toroidal_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <where label="WR1" expression="minor_radius &lt; major_radius"/>
      </entity>
      <entity name="torus" supertypes="geometric_representation_item">
         <explicit name="position">
            <typename name="axis1_placement"/>
         </explicit>
         <explicit name="major_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="minor_radius">
            <typename name="positive_length_measure"/>
         </explicit>
         <where label="WR1" expression="major_radius &gt; minor_radius"/>
      </entity>
      <entity name="total_runout_tolerance" supertypes="geometric_tolerance_with_datum_reference">
         <where label="WR1" expression="SIZEOF(SELF\geometric_tolerance_with_datum_reference.datum_system)&lt;= 2"/>
      </entity>
      <entity name="transform_port_variable" supertypes="port_variable"/>
      <entity name="trimmed_curve" supertypes="bounded_curve">
         <explicit name="basis_curve">
            <typename name="curve"/>
         </explicit>
         <explicit name="trim_1">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="trim_2">
            <aggregate type="SET" lower="1" upper="2"/>
            <typename name="trimming_select"/>
         </explicit>
         <explicit name="sense_agreement">
            <builtintype type="BOOLEAN"/>
         </explicit>
         <explicit name="master_representation">
            <typename name="trimming_preference"/>
         </explicit>
         <where label="WR1" expression="(HIINDEX(trim_1)= 1)OR(TYPEOF(trim_1[1])&lt;&gt; TYPEOF(trim_1[2]))"/>
         <where label="WR2" expression="(HIINDEX(trim_2)= 1)OR(TYPEOF(trim_2[1])&lt;&gt; TYPEOF(trim_2[2]))"/>
      </entity>
      <entity name="trimmed_volume" supertypes="solid_model">
         <explicit name="basis_volume">
            <typename name="volume"/>
         </explicit>
         <explicit name="u1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="u2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="v2">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="w1">
            <typename name="parameter_value"/>
         </explicit>
         <explicit name="w2">
            <typename name="parameter_value"/>
         </explicit>
         <where label="WR1" expression="u1 &lt;&gt; u2"/>
         <where label="WR2" expression="v1 &lt;&gt; v2"/>
         <where label="WR3" expression="w1 &lt;&gt; w2"/>
      </entity>
      <entity name="type_qualifier">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
      </entity>
      <entity name="unary_generic_expression" abstract.supertype="YES" supertypes="generic_expression">
         <explicit name="operand">
            <typename name="generic_expression"/>
         </explicit>
      </entity>
      <entity name="uncertainty_assigned_representation" supertypes="representation">
         <explicit name="uncertainty">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="uncertainty_measure_with_unit"/>
         </explicit>
      </entity>
      <entity name="uncertainty_measure_with_unit" supertypes="measure_with_unit">
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <where label="WR1" expression="valid_measure_value(SELF\measure_with_unit.value_component)"/>
      </entity>
      <entity name="uncertainty_qualifier" super.expression="ONEOF (standard_uncertainty, qualitative_uncertainty)">
         <explicit name="measure_name">
            <typename name="label"/>
         </explicit>
         <explicit name="description">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="uniform_curve" supertypes="b_spline_curve"/>
      <entity name="uniform_resource_indicator" supertypes="descriptive_representation_item"/>
      <entity name="uniform_surface" supertypes="b_spline_surface"/>
      <entity name="uniform_volume" supertypes="b_spline_volume"/>
      <entity name="unsupported_passage_template" supertypes="inter_stratum_feature_template" super.expression="ONEOF (counterbore_passage_template, countersunk_passage_template, blind_passage_template)"/>
      <entity name="usage_view_connection_zone_terminal_shape_relationship" supertypes="representation representation_relationship_with_transformation">
         <explicit name="rep_1">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <explicit name="rep_2">
            <typename name="shape_representation"/>
            <redeclaration entity-ref="representation_relationship"/>
         </explicit>
         <unique label="UR1">
            <unique.attribute attribute="rep_1"/>
            <unique.attribute attribute="rep_2"/>
         </unique>
         <where label="WR1" expression="SELF\representation_relationship.rep_1 &lt;&gt; &#10;       SELF\representation_relationship.rep_2"/>
      </entity>
      <entity name="value_range" supertypes="compound_representation_item">
         <where label="WR1" expression="('value_with_unit_mim.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF(item_element))AND value_range_wr1(item_element)"/>
         <where label="WR2" expression="value_range_wr2(item_element)"/>
         <where label="WR3" expression="value_range_wr3(item_element)"/>
      </entity>
      <entity name="value_representation_item" supertypes="representation_item">
         <explicit name="value_component">
            <typename name="measure_value"/>
         </explicit>
         <where label="WR1" expression="SIZEOF(QUERY(rep &lt;* using_representations(SELF)|&#10;       NOT('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'&#10;       IN TYPEOF(rep.context_of_items)&#10;      )))= 0"/>
      </entity>
      <entity name="variable_semantics" abstract.supertype="YES"/>
      <entity name="vector" supertypes="geometric_representation_item">
         <explicit name="orientation">
            <typename name="direction"/>
         </explicit>
         <explicit name="magnitude">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="magnitude &gt;= 0.0"/>
      </entity>
      <entity name="versioned_action_request">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="version">
            <typename name="label"/>
         </explicit>
         <explicit name="purpose">
            <typename name="text"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
      </entity>
      <entity name="versioned_action_request_relationship">
         <explicit name="id">
            <typename name="identifier"/>
         </explicit>
         <explicit name="name">
            <typename name="label"/>
         </explicit>
         <explicit name="description" optional="YES">
            <typename name="text"/>
         </explicit>
         <explicit name="relating_versioned_action_request">
            <typename name="versioned_action_request"/>
         </explicit>
         <explicit name="related_versioned_action_request">
            <typename name="versioned_action_request"/>
         </explicit>
      </entity>
      <entity name="vertex" supertypes="topological_representation_item"/>
      <entity name="vertex_loop" supertypes="loop">
         <explicit name="loop_vertex">
            <typename name="vertex"/>
         </explicit>
      </entity>
      <entity name="vertex_point" supertypes="vertex geometric_representation_item">
         <explicit name="vertex_geometry">
            <typename name="point"/>
         </explicit>
      </entity>
      <entity name="vertex_shell" supertypes="topological_representation_item">
         <explicit name="vertex_shell_extent">
            <typename name="vertex_loop"/>
         </explicit>
      </entity>
      <entity name="via_template" supertypes="inter_stratum_feature_template"/>
      <entity name="viewing_plane" supertypes="shape_aspect"/>
      <entity name="volume" supertypes="geometric_representation_item" super.expression="ONEOF (block_volume, wedge_volume, spherical_volume, cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume)">
         <where label="WR1" expression="SELF\geometric_representation_item.dim = 3"/>
      </entity>
      <entity name="volume_measure_with_unit" supertypes="measure_with_unit">
         <where label="WR1" expression="'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component)"/>
      </entity>
      <entity name="volume_unit" supertypes="named_unit">
         <where label="WR1" expression="(SELF\named_unit.dimensions.length_exponent = 3.000000)AND (SELF\named_unit.dimensions.mass_exponent = 0.000000)AND (SELF\named_unit.dimensions.time_exponent = 0.000000)AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000)AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000)AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000)AND(SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000)"/>
      </entity>
      <entity name="wedge_volume" supertypes="volume">
         <explicit name="position">
            <typename name="axis2_placement_3d"/>
         </explicit>
         <explicit name="x">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="y">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="z">
            <typename name="positive_length_measure"/>
         </explicit>
         <explicit name="ltx">
            <typename name="length_measure"/>
         </explicit>
         <where label="WR1" expression="((0.0 &lt;= ltx)AND(ltx &lt; x))"/>
      </entity>
      <entity name="week_of_year_and_day_date" supertypes="date">
         <explicit name="week_component">
            <typename name="week_in_year_number"/>
         </explicit>
         <explicit name="day_component" optional="YES">
            <typename name="day_in_week_number"/>
         </explicit>
      </entity>
      <entity name="wire_shell" supertypes="topological_representation_item">
         <explicit name="wire_shell_extent">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="loop"/>
         </explicit>
         <where label="WR1" expression="NOT mixed_loop_type_set(wire_shell_extent)"/>
      </entity>
      <subtype.constraint name="classification_or_complete_membership" entity="classification_assignment" super.expression="ONEOF (classification, complete_membership)"/>
      <subtype.constraint name="egt_non_feature_shape_element_subtypes" entity="shape_aspect" super.expression="ONEOF (derived_shape_aspect, positional_boundary, positional_boundary_member, tolerance_zone_boundary, viewing_plane, seating_plane, reference_graphic_registration_mark)"/>
      <subtype.constraint name="ft_part_template_definition_subtypes" entity="part_template_definition" super.expression="ONEOF (geometric_template, stratum_stack_model)"/>
      <subtype.constraint name="ft_property_definition_relationship_subtypes" entity="property_definition_relationship" super.expression="ONEOF (stratum_technology_occurrence_swap_relationship, stratum_technology_swap_relationship, stratum_technology_occurrence_link)"/>
      <subtype.constraint name="ft_property_definition_subtypes" entity="property_definition" super.expression="ONEOF (stratum_technology_occurrence_link, stratum_technology_occurrence)"/>
      <subtype.constraint name="rd_model_parameter_subtypes" entity="model_parameter" super.expression="ONEOF (analytical_model_parameter, category_model_parameter)"/>
      <rule name="compatible_dimension" appliesto="cartesian_point direction representation_context geometric_representation_context">
         <where label="WR1" expression="SIZEOF(QUERY(x &lt;* cartesian_point| SIZEOF(QUERY&#10;      (y &lt;* geometric_representation_context | item_in_context(x,y)AND&#10;      (HIINDEX(x.coordinates)&lt;&gt; y.coordinate_space_dimension)))&gt; 0))=0"/>
         <where label="WR2" expression="SIZEOF(QUERY(x &lt;* direction | SIZEOF(QUERY&#10;      (y &lt;* geometric_representation_context | item_in_context(x,y)AND&#10;      (HIINDEX(x.direction_ratios)&lt;&gt; y.coordinate_space_dimension)))&#10;       &gt; 0))= 0"/>
      </rule>
      <rule name="product_concept_feature_requires_category" appliesto="product_concept_feature">
         <where label="WR1" expression="SIZEOF(QUERY(pcf &lt;* product_concept_feature |&#10;(SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE',&#10;'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE'] * TYPEOF(pcf))= 0)AND  &#10;(SIZEOF(QUERY(aga &lt;* USEDIN(pcf, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'APPLIED_GROUP_ASSIGNMENT.' + 'ITEMS')| &#10;(aga.role.name = 'specification category member')AND &#10;('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(aga.assigned_group))))&lt;&gt;1)))= 0"/>
      </rule>
      <rule name="product_definition_replacement_requires_effectivity_assignment" appliesto="product_definition_relationship">
         <where label="WR1" expression="SIZEOF(QUERY(pdr &lt;* product_definition_relationship | &#10;	(pdr.name = 'definition replacement')AND &#10;	(SIZEOF(USEDIN(pdr,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.APPLIED_EFFECTIVITY_ASSIGNMENT.ITEMS'))= 0)))&#10;	 = 0"/>
      </rule>
      <rule name="restrict_assembly_category" appliesto="product_definition">
         <algorithm>LOCAL

  assembly_definitions: SET OF product_definition := [];

END_LOCAL
;

  assembly_definitions :=  QUERY(pd &lt;* product_definition | 
    SIZEOF(QUERY(pdca &lt;* USEDIN(pd, 'ITEM_DEFINITION_STRUCTURE_MIM.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION')|
    pdca.frame_of_reference.name= 'assembly definition'))&gt; 0);</algorithm>
         <where label="WR1" expression="SIZEOF(QUERY(pd &lt;* assembly_definitions | &#10;   NOT('assembly' IN categories_of_product(pd.formation.of_product))))= 0"/>
      </rule>
      <rule name="restrict_classification_assignments" appliesto="applied_classification_assignment">
         <where label="WR1" expression="SIZEOF(QUERY(aia &lt;* applied_classification_assignment | &#10;		NOT class_assignment_is_valid(aia)))=0"/>
      </rule>
      <rule name="restrict_concept_feature_operator" appliesto="concept_feature_operator">
         <where label="WR1" expression="SIZEOF(QUERY(cfo &lt;* concept_feature_operator | NOT&#10;	(cfo.name IN ['and', 'or', 'oneof', 'not', 'implication'])))= 0"/>
         <where label="WR2" expression="SIZEOF(QUERY(cfo &lt;* concept_feature_operator |(cfo.name = 'implication')AND&#10;(SIZEOF(QUERY (cfrwc &lt;* USEDIN(cfo, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.' +&#10;'CONDITIONAL_OPERATOR')| &#10;	SIZEOF(QUERY(ccf &lt;* USEDIN(cfrwc, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONDITIONAL_CONCEPT_FEATURE.CONDITION')| &#10;	NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF(ccf))))&gt;0))&gt;0)))= 0"/>
         <where label="WR3" expression="SIZEOF(QUERY(cfo &lt;* concept_feature_operator |(cfo.name = 'not')&#10;AND(SIZEOF(QUERY(cfrwc &lt;* USEDIN(cfo, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION.CONDITIONAL_OPERATOR')| &#10;	cfrwc.related_product_concept_feature :&lt;&gt;: cfrwc.relating_product_concept_feature))&gt;0)))= 0"/>
      </rule>
      <rule name="restrict_group_relationship_for_classification_hierarchy" appliesto="group_relationship">
         <where label="WR1" expression="SIZEOF(QUERY(gr &lt;* group_relationship | &#10; (gr.name = 'class hierarchy')AND &#10; (NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CLASS' IN  TYPEOF(gr.related_group))OR &#10;  NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CLASS' IN TYPEOF(gr.relating_group)))))= 0"/>
      </rule>
      <rule name="restrict_group_relationship_for_specification_category" appliesto="group_relationship">
         <where label="WR1" expression="SIZEOF(QUERY(gr &lt;* group_relationship | &#10; (gr.name = 'specification category hierarchy')AND &#10; (NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN  TYPEOF(gr.related_group))&#10;  OR NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_CONCEPT_FEATURE_CATEGORY' IN TYPEOF(gr.relating_group)))))= 0"/>
      </rule>
      <rule name="restrict_language_assignment_per_attribute" appliesto="attribute_language_assignment">
         <where label="WR1" expression="SIZEOF(QUERY(ala1 &lt;* attribute_language_assignment |&#10;	SIZEOF(QUERY(it &lt;* ala1.items |&#10;	   SIZEOF(QUERY(ala2 &lt;* USEDIN(it ,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS')| &#10;		(ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name)AND &#10;		(ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class)&#10;		))&gt;1 &#10;	  ))&gt;0 &#10;	))=0"/>
      </rule>
      <rule name="restrict_part_occurrence" appliesto="product_definition">
         <algorithm>LOCAL

  part_occurrences: SET OF product_definition := [];

END_LOCAL
;

  part_occurrences := QUERY(pd &lt;* product_definition | 
	(pd.frame_of_reference.name = 'part occurrence'));</algorithm>
         <where label="WR1" expression="SIZEOF(QUERY(pd &lt;* part_occurrences | &#10;	(NOT(pd.name IN &#10;['single instance', 'selected instance' ,'quantified instance', 'specified instance' ]))))= 0"/>
         <where label="WR2" expression="SIZEOF(QUERY(pd &lt;* part_occurrences | &#10; 	(SIZEOF(QUERY(pdr &lt;* USEDIN(pd ,&#10;'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')| &#10;	pdr.name = 'definition usage'))&lt;&gt;1)AND  &#10;	(SIZEOF(QUERY(cd &lt;* USEDIN(pd, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONFIGURATION_DESIGN.DESIGN')| &#10;	(cd.name = 'occurrence usage definition')AND &#10;	(NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_IDENTIFICATION' IN TYPEOF(cd.configuration)))))&lt;&gt;1)))= 0"/>
         <where label="WR3" expression="SIZEOF(QUERY(pd &lt;* part_occurrences |  &#10;	(SIZEOF(QUERY(cd &lt;* USEDIN(pd, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+ 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION')|&#10; 	('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +'PRODUCT_DEFINITION_USAGE' IN TYPEOF(cd))))= 0)AND&#10; 	(SIZEOF(USEDIN(pd, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE'))= 0)))= 0"/>
         <where label="WR4" expression="SIZEOF(QUERY(pd &lt;* part_occurrences | &#10;	(pd.name = 'selected instance')AND &#10;	NOT valid_selected_instance_representation(pd)))=0"/>
         <where label="WR5" expression="SIZEOF(QUERY(pd &lt;* part_occurrences | &#10; 	(pd.name = 'quantified instance')AND  &#10;	(SIZEOF(QUERY (ppd &lt;* USEDIN(pd, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +'PROPERTY_DEFINITION.DEFINITION')|&#10; 	(ppd.name ='occurrence quantity')AND  &#10;	(SIZEOF(QUERY(pdr &lt;*USEDIN(ppd, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')|(&#10;	pdr.used_representation.name = 'quantity')AND  &#10;	(SIZEOF(pdr.used_representation.items)= 1)AND &#10; 	(SIZEOF(QUERY(i &lt;* pdr.used_representation.items | &#10;	('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i))AND&#10;	(i.name = 'quantity measure')))= 1)))= 1)))= 0)))= 0"/>
         <where label="WR6" expression="SIZEOF(QUERY(pd &lt;* part_occurrences | &#10;	(pd.name = 'specified instance')AND &#10;	(SIZEOF(QUERY(&#10;pdor &lt;* USEDIN(pd, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +'PRODUCT_DEFINITION_OCCURRENCE_RELATIONSHIP.OCCURRENCE')| &#10;  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +'SPECIFIED_HIGHER_USAGE_OCCURRENCE' IN TYPEOF(pdor.occurrence_usage)))= 0)))= 0"/>
      </rule>
      <rule name="restrict_part_occurrence_category" appliesto="product_definition">
         <algorithm>LOCAL

  part_occurrences: SET OF product_definition := [];

END_LOCAL
;

  part_occurrences :=  QUERY(pd &lt;* product_definition |(
		pd.frame_of_reference.name = 'part occurrence'));</algorithm>
         <where label="WR1" expression="SIZEOF(QUERY(pd &lt;* part_occurrences | &#10;(SIZEOF(QUERY(prpc &lt;* USEDIN(pd.formation.of_product, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS')| &#10;  prpc.name IN ['part','raw material','tool']))= 0)))= 0"/>
      </rule>
      <rule name="restrict_product_definitions_for_definition_usage" appliesto="product_definition_relationship">
         <where label="WR1" expression="SIZEOF(QUERY(pdr &lt;* product_definition_relationship |&#10;   (pdr.name = 'definition usage')AND &#10;	((pdr.relating_product_definition.frame_of_reference.name&lt;&gt; 'part definition')OR &#10;	(pdr.related_product_definition.frame_of_reference.name&lt;&gt;'part occurrence'))))=0"/>
      </rule>
      <rule name="restrict_product_definitions_for_part_definition_relationship" appliesto="product_definition_relationship">
         <where label="WR1" expression="SIZEOF(QUERY(pdr &lt;* product_definition_relationship |&#10;   (pdr.name IN [ 'geometrical relationship', 'definition replacement' ])AND &#10;	((pdr.relating_product_definition.frame_of_reference.name &lt;&gt;'part definition')OR &#10;	(pdr.related_product_definition.frame_of_reference.name &lt;&gt;'part definition'))))=0"/>
      </rule>
      <rule name="selected_instance_usage_requires_representation" appliesto="assembly_component_usage">
         <algorithm>LOCAL

  selected_instance_usages: SET OF assembly_component_usage := [];

END_LOCAL
;

  selected_instance_usages:=  QUERY(acr &lt;* assembly_component_usage|
		(acr.name = 'selected instance usage'));</algorithm>
         <where label="WR1" expression="SIZEOF(QUERY(acr &lt;* selected_instance_usages | &#10;	NOT valid_selected_instance_representation(acr)))=0"/>
      </rule>
      <rule name="subtype_exclusive_measure_with_unit" appliesto="measure_with_unit">
         <where label="WR1" expression="SIZEOF(QUERY(mwu &lt;* measure_with_unit |&#10;       NOT(SIZEOF([&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'ABSORBED_DOSE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'ACTIVITY_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'AREA_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'CAPACITANCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'CONDUCTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'DOSE_EQUIVALENT_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'ELECTRIC_CHARGE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'ELECTRIC_CURRENT_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'ELECTROMOTIVE_FORCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'ENERGY_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'FORCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'FREQUENCY_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'ILLUMINANCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'INDUCTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'LENGTH_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'LUMINOUS_FLUX_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'LUMINOUS_INTENSITY_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'MAGNETIC_FLUX_DENSITY_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'MAGNETIC_FLUX_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'MASS_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'PLANE_ANGLE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'POWER_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'PRESSURE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'RATIO_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'RESISTANCE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'SOLID_ANGLE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'TIME_MEASURE_WITH_UNIT',&#10;       'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +&#10;       'VOLUME_MEASURE_WITH_UNIT'] *&#10;       TYPEOF(mwu))&lt;= 1)))= 0"/>
      </rule>
      <rule name="subtype_exclusiveness_geometric_tolerance" appliesto="geometric_tolerance">
         <where label="WR1" expression="SIZEOF(QUERY(gt &lt;* geometric_tolerance | NOT(type_check_function(gt, ['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.FLATNESS_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.POSITION_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.TOTAL_RUNOUT_TOLERANCE'], 3))))= 0"/>
      </rule>
      <rule name="subtype_exclusiveness_representation_item" appliesto="representation_item">
         <where label="WR1" expression="SIZEOF(QUERY(cri &lt;* representation_item | NOT(type_check_function(cri,['QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM','REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM','REPRESENTATION_SCHEMA.COMPOUND_REPRESENTATION_ITEM'], 3))))= 0"/>
      </rule>
      <rule name="subtype_mandatory_geometric_tolerance" appliesto="geometric_tolerance">
         <where label="WR1" expression="SIZEOF(QUERY(gt &lt;* geometric_tolerance | NOT(type_check_function(gt, ['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ANGULARITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CIRCULAR_RUNOUT_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.COAXIALITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CONCENTRICITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CYLINDRICITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.FLATNESS_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LINE_PROFILE_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PARALLELISM_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PERPENDICULARITY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.POSITION_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ROUNDNESS_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.STRAIGHTNESS_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SURFACE_PROFILE_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SYMMETRY_TOLERANCE', 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.TOTAL_RUNOUT_TOLERANCE'], 0))))= 0"/>
      </rule>
      <function name="above_plane">
         <parameter name="p1">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p2">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p3">
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="p4">
            <typename name="cartesian_point"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL

     dir2, dir3, dir4 : direction :=
                 dummy_gri || direction([1.0, 0.0, 0.0]);

     val, mag         : REAL;

   END_LOCAL
;


   IF(p1.dim &lt;&gt; 3)THEN
     RETURN(?);

   END_IF;

   REPEAT i := 1 TO 3;

     dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];

     dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];

     dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];

     mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];

  END_REPEAT;

  mag := sqrt(mag);

  val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);

  RETURN(val);</algorithm>
      </function>
      <function name="acyclic">
         <parameter name="arg1">
            <typename name="generic_expression"/>
         </parameter>
         <parameter name="arg2">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

	result: BOOLEAN;

END_LOCAL
;


IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SIMPLE_GENERIC_EXPRESSION'
	IN TYPEOF (arg1))
THEN
	RETURN(TRUE);

END_IF;


IF arg1 IN arg2 
THEN 
	RETURN(FALSE);

END_IF;


IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1)
THEN 
	RETURN 
	(acyclic(arg1\unary_generic_expression.operand,arg2+[arg1]));

END_IF;


IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BINARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg1)
THEN 
	RETURN 
	(acyclic(arg1\binary_generic_expression.operands[1],arg2+[arg1])
	AND
	acyclic(arg1\binary_generic_expression.operands[2],arg2+[arg1]));

END_IF;


IF 
'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF(arg1)
THEN 
	result := TRUE;

	REPEAT i := 1 TO 
			SIZEOF(arg1\multiple_arity_generic_expression.operands);

		result := result AND
		acyclic(arg1\multiple_arity_generic_expression.operands[i], arg2+[arg1]);

	END_REPEAT;


	RETURN(result);

END_IF;</algorithm>
      </function>
      <function name="acyclic_action_method_relationship">
         <parameter name="relation">
            <typename name="action_method_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_method"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF action_method_relationship;

    END_LOCAL
;


    IF  relation.relating_method IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(am &lt;* bag_to_set(USEDIN(relation.relating_method, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD'))| specific_relation IN TYPEOF(am));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_action_relationship">
         <parameter name="relation">
            <typename name="action_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF action_relationship;

    END_LOCAL
;


    IF  relation.relating_action IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(actn &lt;* bag_to_set(USEDIN(relation.relating_action, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION'))| specific_relation IN TYPEOF(actn));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_action_resource_relationship">
         <parameter name="relation">
            <typename name="action_resource_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="action_resource"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF action_resource_relationship;

    END_LOCAL
;


    IF  relation.relating_resource IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ar &lt;* bag_to_set(USEDIN(relation.relating_resource, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE'))| specific_relation IN TYPEOF(ar));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_approval_relationship">
         <parameter name="relation">
            <typename name="approval_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="approval"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF approval_relationship;

    END_LOCAL
;


    IF  relation.relating_approval IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(app &lt;* bag_to_set(USEDIN(relation.relating_approval, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL'))| specific_relation IN TYPEOF(app));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_characterized_object_relationship">
         <parameter name="relation">
            <typename name="characterized_object_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="characterized_object"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF characterized_object_relationship;

    END_LOCAL
;


    IF  relation.relating_object IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ca &lt;* bag_to_set(USEDIN(relation.relating_object, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT'))| specific_relation IN TYPEOF(ca));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation)THEN
        RETURN(FALSE);

      END_IF;

    END_REPEAT;

RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_contract_relationship">
         <parameter name="relation">
            <typename name="contract_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="contract"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF contract_relationship;

    END_LOCAL
;


    IF  relation.relating_contract IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(cont &lt;* bag_to_set(USEDIN(relation.relating_contract, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT'))| specific_relation IN TYPEOF(cont));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_curve_replica">
         <parameter name="rep">
            <typename name="curve_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CURVE_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE curve_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same curve_replica, otherwise,
   call FUNCTION again WITH the parents own parent_curve.    *)
    ELSE
    RETURN(acyclic_curve_replica(rep,
               parent\curve_replica.parent_curve));

    END_IF;</algorithm>
      </function>
      <function name="acyclic_document_relationship">
         <parameter name="relation">
            <typename name="document_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="document"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF document_relationship;

    END_LOCAL
;


    IF  relation.relating_document IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(doc &lt;* bag_to_set(USEDIN(relation.relating_document, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT'))| specific_relation IN TYPEOF(doc));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_effectivity_relationship">
         <parameter name="relation">
            <typename name="effectivity_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="effectivity"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF effectivity_relationship;

    END_LOCAL
;


    IF  relation.relating_effectivity IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(eff &lt;* bag_to_set(USEDIN(relation.relating_effectivity, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY'))| specific_relation IN TYPEOF(eff));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_event_occurrence_relationship">
         <parameter name="relation">
            <typename name="event_occurrence_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="event_occurrence"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF event_occurrence_relationship;

    END_LOCAL
;


    IF  relation.relating_event IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(evnt &lt;* bag_to_set(USEDIN(relation.relating_event, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT'))| specific_relation IN TYPEOF(evnt));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_experience_relationship">
         <parameter name="relation">
            <typename name="experience_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="experience"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF experience_relationship;

    END_LOCAL
;


    IF  relation.relating_experience IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(expr &lt;* bag_to_set(USEDIN(relation.relating_experience, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE'))| specific_relation IN TYPEOF(expr));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_experience_type_relationship">
         <parameter name="relation">
            <typename name="experience_type_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="experience_type"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF experience_type_relationship;

    END_LOCAL
;


    IF  relation.relating_experience_type IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(exptyp &lt;* bag_to_set(USEDIN(relation.relating_experience_type, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE'))| specific_relation IN TYPEOF(exptyp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_external_source_relationship">
         <parameter name="relation">
            <typename name="external_source_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="external_source"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF external_source_relationship;

    END_LOCAL
;


    IF  relation.relating_source IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(es &lt;* bag_to_set(USEDIN(relation.relating_source, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE'))| specific_relation IN TYPEOF(es));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_externally_defined_item_relationship">
         <parameter name="relation">
            <typename name="externally_defined_item_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="externally_defined_item"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF externally_defined_item_relationship;

    END_LOCAL
;


    IF  relation.relating_item IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(edi &lt;* bag_to_set(USEDIN(relation.relating_item, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM'))| specific_relation IN TYPEOF(edi));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_general_property_relationship">
         <parameter name="relation">
            <typename name="general_property_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="general_property"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF general_property_relationship;

    END_LOCAL
;


    IF  relation.relating_property IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(genp &lt;* bag_to_set(USEDIN(relation.relating_property, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY'))| specific_relation IN TYPEOF(genp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_group_relationship">
         <parameter name="relation">
            <typename name="group_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="group"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF group_relationship;

    END_LOCAL
;


    IF  relation.relating_group IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(grp &lt;* bag_to_set(USEDIN(relation.relating_group, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP'))| specific_relation IN TYPEOF(grp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_identification_assignment_relationship">
         <parameter name="relation">
            <typename name="identification_assignment_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="identification_assignment"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF identification_assignment_relationship;

    END_LOCAL
;


    IF  relation.relating_identification_assignment IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ia &lt;* bag_to_set(USEDIN(relation.relating_identification_assignment, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT'))| specific_relation IN TYPEOF(ia));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_location_relationship">
         <parameter name="relation">
            <typename name="location_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="location"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF location_relationship;

    END_LOCAL
;


    IF  relation.relating_location IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(lctn &lt;* bag_to_set(USEDIN(relation.relating_location, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION'))| specific_relation IN TYPEOF(lctn));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_mapped_representation">
         <parameter name="parent_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="children_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="representation_item"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

    x,y : SET  OF  representation_item;

  END_LOCAL
;

  -- Determine the subset OF  children_set that are mapped_items
  x := QUERY(z &lt;* children_set | 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MAPPED_ITEM'
       IN  TYPEOF(z));

  -- Determine that the subset has elements
  IF  SIZEOF(x)&gt; 0 THEN
    -- Check each element OF  the set
    REPEAT  i := 1 TO  HIINDEX(x);

      -- IF  the selected element maps a representation IN  the
      -- parent_set, THEN RETURN  false
      IF  x[i]\mapped_item.mapping_source.mapped_representation
        IN  parent_set THEN
        RETURN (FALSE);

      END_IF;

      -- Recursive check OF  the items OF  mapped_representation
      IF  NOT  acyclic_mapped_representation
       (parent_set +
        x[i]\mapped_item.mapping_source.mapped_representation,
        x[i]\mapped_item.mapping_source.mapped_representation.items)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

  END_IF;

  -- Determine the subset OF  children_set that are not
  -- mapped_items
  x := children_set - x;

  -- Determine that the subset has elements
  IF  SIZEOF(x)&gt; 0 THEN
    -- FOR  each element OF  the set:
    REPEAT i := 1 TO HIINDEX(x);

      -- Determine the SET OF representation_items referenced
      y := QUERY(z &lt;* bag_to_set(USEDIN(x[i], ''))|
           'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z));

      -- Recursively check FOR  an offending mapped_item
      -- RETURN  FALSE FOR any errors encountered
      IF NOT acyclic_mapped_representation(parent_set, y)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

  END_IF;

  -- RETURN  TRUE when all elements are checked and
  -- no error conditions found
  RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_organization_relationship">
         <parameter name="relation">
            <typename name="organization_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organization"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF organization_relationship;

    END_LOCAL
;


    IF  relation.relating_organization IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(org &lt;* bag_to_set(USEDIN(relation.relating_organization, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION'))| specific_relation IN TYPEOF(org));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_organization_type_relationship">
         <parameter name="relation">
            <typename name="organization_type_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="organization_type"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF organization_type_relationship;

    END_LOCAL
;


    IF  relation.relating_organization_type IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(orgtyp &lt;* bag_to_set(USEDIN(relation.relating_organization_type, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE'))| specific_relation IN TYPEOF(orgtyp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_organizational_project_relationship">
         <parameter name="relation">
            <typename name="organizational_project_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="organizational_project"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF organizational_project_relationship;

    END_LOCAL
;


    IF  relation.relating_organizational_project IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(op &lt;* bag_to_set(USEDIN(relation.relating_organizational_project, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT'))| specific_relation IN TYPEOF(op));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_person_type_definition_relationship">
         <parameter name="relation">
            <typename name="person_type_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="person_type_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF person_type_definition_relationship;

    END_LOCAL
;


    IF  relation.relating_person_type_definition IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ptdef &lt;* bag_to_set(USEDIN(relation.relating_person_type_definition, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION'))| specific_relation IN TYPEOF(ptdef));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_point_replica">
         <parameter name="rep">
            <typename name="point_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.POINT_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE point_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same point_replica, otherwise,
   call FUNCTION again WITH the parents own parent_pt.    *)
    ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));

    END_IF;</algorithm>
      </function>
      <function name="acyclic_position_in_organization_relationship">
         <parameter name="relation">
            <typename name="position_in_organization_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="position_in_organization"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF position_in_organization_relationship;

    END_LOCAL
;


    IF  relation.relating_position_in_organization IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(piorg &lt;* bag_to_set(USEDIN(relation.relating_position_in_organization, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION'))| specific_relation IN TYPEOF(piorg));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_product_category_relationship">
         <parameter name="relation">
            <typename name="product_category_relationship"/>
         </parameter>
         <parameter name="children">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_category"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET  OF  product_category_relationship;

      local_children : SET OF product_category;

    END_LOCAL
;


    REPEAT  i := 1 TO  HIINDEX(children);

      IF  relation.category :=: children[i] THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    x := bag_to_set(USEDIN(relation.category, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));

    local_children := children + relation.category;

    IF  SIZEOF(x)&gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(x);

        IF NOT acyclic_product_category_relationship(x[i], local_children)THEN
          RETURN (FALSE);

        END_IF;

      END_REPEAT;

    END_IF;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_product_definition_formation_relationship">
         <parameter name="relation">
            <typename name="product_definition_formation_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_definition_formation"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF product_definition_formation_relationship;

    END_LOCAL
;


    IF  relation.relating_product_definition_formation IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(pdf &lt;* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION'))| specific_relation IN TYPEOF(pdf));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_product_definition_relationship">
         <parameter name="relation">
            <typename name="product_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF product_definition_relationship;

    END_LOCAL
;


    IF  relation.relating_product_definition IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(pd &lt;* bag_to_set(USEDIN(relation.relating_product_definition, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION'))| specific_relation IN TYPEOF(pd));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation)THEN
        RETURN(FALSE);

      END_IF;

    END_REPEAT;

RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_product_relationship">
         <parameter name="relation">
            <typename name="product_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="product"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF product_relationship;

    END_LOCAL
;


    IF  relation.relating_product IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(prod &lt;* bag_to_set(USEDIN(relation.relating_product, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT'))| specific_relation IN TYPEOF(prod));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_property_definition_relationship">
         <parameter name="relation">
            <typename name="property_definition_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="property_definition"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL

    x                : SET OF property_definition_relationship;

  END_LOCAL
;


  IF  relation.relating_property_definition IN  
            relatives THEN
    RETURN(FALSE);

  END_IF;
             -- IN  is based IN  instance equality

  x := QUERY(pd &lt;* bag_to_set(USEDIN
      (relation.relating_property_definition,
        'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +
        'PROPERTY_DEFINITION_RELATIONSHIP.' +
        'RELATED_PROPERTY_DEFINITION'))|
         specific_relation IN TYPEOF(pd));


  REPEAT I := 1 TO HIINDEX(x);
             -- pre-checked loop
    IF NOT acyclic_property_definition_relationship
     (x[i],
       relatives + relation.relating_property_definition,
       specific_relation)THEN
      RETURN(FALSE);

    END_IF;

  END_REPEAT;


  RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_qualification_relationship">
         <parameter name="relation">
            <typename name="qualification_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="qualification"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF qualification_relationship;

    END_LOCAL
;


    IF  relation.relating_qualification IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(qual &lt;* bag_to_set(USEDIN(relation.relating_qualification, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION'))| specific_relation IN TYPEOF(qual));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_qualification_type_relationship">
         <parameter name="relation">
            <typename name="qualification_type_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="qualification_type"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF qualification_type_relationship;

    END_LOCAL
;


    IF  relation.relating_qualification_type IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(qultyp &lt;* bag_to_set(USEDIN(relation.relating_qualification_type, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE'))| specific_relation IN TYPEOF(qultyp));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_representation_relationship">
         <parameter name="relation">
            <typename name="representation_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="representation"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF representation_relationship;

    END_LOCAL
;


    IF  relation.rep_1 IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(r &lt;* bag_to_set(USEDIN(relation.rep_1, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.' + 'REP_2'))| specific_relation IN TYPEOF(r));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_representation_relationship(x[i], relatives + relation.rep_1, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_set_replica">
         <parameter name="rep">
            <typename name="geometric_set_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="geometric_set"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA')IN TYPEOF(parent))
        THEN  RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE geometric_set_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same geometric_set_replica,
     otherwise, call FUNCTION again WITH the parents own parent_set. *)
    ELSE RETURN(acyclic_set_replica(rep,
                          parent\geometric_set_replica.parent_set));

    END_IF;</algorithm>
      </function>
      <function name="acyclic_shape_aspect_relationship">
         <parameter name="relation">
            <typename name="shape_aspect_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="shape_aspect"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF shape_aspect_relationship;

    END_LOCAL
;


    IF  relation.relating_shape_aspect IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(sa &lt;* bag_to_set(USEDIN(relation.relating_shape_aspect, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT'))| specific_relation IN TYPEOF(sa));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_solid_replica">
         <parameter name="rep">
            <typename name="solid_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="solid_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE solid_replica.*)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same solid_replica, otherwise,
   call FUNCTION again WITH the parents own parent_solid.    *)
    ELSE RETURN(acyclic_solid_replica(rep,
                      parent\solid_replica.parent_solid));

    END_IF;</algorithm>
      </function>
      <function name="acyclic_surface_replica">
         <parameter name="rep">
            <typename name="surface_replica"/>
         </parameter>
         <parameter name="parent">
            <typename name="surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF NOT (('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SURFACE_REPLICA')IN TYPEOF(parent))THEN
      RETURN (TRUE);

   END_IF;

(* RETURN  TRUE IF  the parent is NOT OF TYPE surface_replica *)
   IF (parent :=: rep)THEN
      RETURN (FALSE);

 (* RETURN FALSE IF the parent is the same surface_replica, otherwise,
   call FUNCTION again WITH the parents own parent_surface.    *)
    ELSE RETURN(acyclic_surface_replica(rep,
                   parent\surface_replica.parent_surface));

    END_IF;</algorithm>
      </function>
      <function name="acyclic_time_interval_relationship">
         <parameter name="relation">
            <typename name="time_interval_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="time_interval"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF time_interval_relationship;

    END_LOCAL
;


    IF  relation.relating_time_interval IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(ti &lt;* bag_to_set(USEDIN(relation.relating_time_interval, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL'))| specific_relation IN TYPEOF(ti));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="acyclic_versioned_action_request_relationship">
         <parameter name="relation">
            <typename name="versioned_action_request_relationship"/>
         </parameter>
         <parameter name="relatives">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="versioned_action_request"/>
         </parameter>
         <parameter name="specific_relation">
            <builtintype type="STRING"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

      x : SET OF versioned_action_request_relationship;

    END_LOCAL
;


    IF  relation.relating_versioned_action_request IN  relatives THEN
      RETURN (FALSE);

    END_IF;

    x := QUERY(varr &lt;* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST'))| specific_relation IN TYPEOF(varr));

    REPEAT i := 1 TO HIINDEX(x);

      IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation)THEN
        RETURN (FALSE);

      END_IF;

    END_REPEAT;

    RETURN(TRUE);</algorithm>
      </function>
      <function name="associated_surface">
         <parameter name="arg">
            <typename name="pcurve_or_surface"/>
         </parameter>
         <typename name="surface"/>
         <algorithm>LOCAL

     surf : surface;

   END_LOCAL
;

   
   IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN TYPEOF(arg)THEN
     surf := arg.basis_surface;

   ELSE
     surf := arg;

   END_IF;

   RETURN(surf);</algorithm>
      </function>
      <function name="bag_to_set">
         <parameter name="the_bag">
            <aggregate type="BAG" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL

      the_set : SET OF GENERIC:intype := [];

    END_LOCAL
;


    IF SIZEOF(the_bag)&gt; 0 THEN
      REPEAT i := 1 TO HIINDEX(the_bag);

        the_set := the_set + the_bag[i];

      END_REPEAT;

    END_IF;

    RETURN(the_set);</algorithm>
      </function>
      <function name="base_axis">
         <parameter name="dim">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="axis1">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis2">
            <typename name="direction"/>
         </parameter>
         <parameter name="axis3">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL

    u      : LIST [2:3] OF direction;

    factor : REAL;

    d1, d2 : direction;

  END_LOCAL
;

  
  IF (dim = 3)THEN
    d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));

    d2 := first_proj_axis(d1,axis1);

    u := [d2, second_proj_axis(d1,d2,axis2), d1];

  ELSE
     IF  EXISTS(axis1)THEN
      d1 := normalise(axis1);

      u := [d1, orthogonal_complement(d1)];

      IF  EXISTS(axis2)THEN
        factor := dot_product(axis2,u[2]);

        IF (factor &lt; 0.0)THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];

          u[2].direction_ratios[2] := -u[2].direction_ratios[2];

        END_IF;

      END_IF;

    ELSE
      IF EXISTS(axis2)THEN
        d1 := normalise(axis2);

        u := [orthogonal_complement(d1), d1];
 
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];

        u[1].direction_ratios[2] := -u[1].direction_ratios[2];

      ELSE
        u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                direction([0.0, 1.0])];

      END_IF;

    END_IF;

  END_IF;

  RETURN(u);</algorithm>
      </function>
      <function name="boolean_choose">
         <parameter name="b">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="choice1">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <parameter name="choice2">
            <builtintype type="GENERIC" typelabel="item"/>
         </parameter>
         <builtintype type="GENERIC" typelabel="item"/>
         <algorithm>IF b THEN
       RETURN (choice1);

     ELSE
       RETURN(choice2);

     END_IF;</algorithm>
      </function>
      <function name="build_2axes">
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="2"/>
         <typename name="direction"/>
         <algorithm>LOCAL

     d : direction := NVL(normalise(ref_direction),
                          dummy_gri || direction([1.0,0.0]));

   END_LOCAL
;


   RETURN([d, orthogonal_complement(d)]);</algorithm>
      </function>
      <function name="build_axes">
         <parameter name="axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="ref_direction">
            <typename name="direction"/>
         </parameter>
         <aggregate type="LIST" lower="3" upper="3"/>
         <typename name="direction"/>
         <algorithm>LOCAL

     d1, d2 : direction;

   END_LOCAL
;

  d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));

  d2 := first_proj_axis(d1, ref_direction);

  RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);</algorithm>
      </function>
      <function name="build_transformed_set">
         <parameter name="tr">
            <typename name="cartesian_transformation_operator"/>
         </parameter>
         <parameter name="gset">
            <typename name="geometric_set"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="geometric_set_select"/>
         <algorithm>LOCAL

   s          : SET  [1:?] OF  geometric_set_select := gset.elements;

   trset      : SET [0:?] OF geometric_set_select := [];

  END_LOCAL
;

  REPEAT j := 1 TO SIZEOF(s);

    IF ('GEOMETRY_SCHEMA.CURVE' IN  TYPEOF(s[j]))THEN
     trset := trset + dummy_gri || curve()||curve_replica(s[j],tr);
 ELSE
     IF ('GEOMETRY_SCHEMA.POINT' IN  TYPEOF(s[j]))THEN
       trset := trset + dummy_gri || point()|| point_replica(s[j],tr);

       ELSE
       IF('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j]))THEN
         trset := trset + dummy_gri || surface() || surface_replica(s[j],
           tr || cartesian_transformation_operator_3d(?));

       END_IF;

     END_IF;

    END_IF;

  END_REPEAT;

  RETURN(trset);</algorithm>
      </function>
      <function name="categories_of_product">
         <parameter name="obj">
            <typename name="product"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="STRING"/>
         <algorithm>LOCAL

category_assignments: BAG OF  product_category;

categories: SET OF STRING:=[];

i: INTEGER;

END_LOCAL
;

category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');

REPEAT i := LOINDEX(category_assignments)TO HIINDEX(category_assignments)BY 1;

categories := categories + category_assignments[i].name;

END_REPEAT;

RETURN(categories);</algorithm>
      </function>
      <function name="class_assignment_is_valid">
         <parameter name="aia">
            <typename name="applied_classification_assignment"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

  item: classification_item;

  role: classification_role;

END_LOCAL
;


role:= aia.role;

IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +'CLASS_SYSTEM' IN  TYPEOF(aia.assigned_class))THEN
  IF(role.name &lt;&gt; 'class system membership')THEN
    RETURN(FALSE);

  END_IF;

  REPEAT  i:=LOINDEX(aia.items)TO  HIINDEX(aia.items);

    item:= aia.items[i];


    IF (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0)THEN
-- item invalid IF  item does NOT  belong TO  the types that may have a class_system
	RETURN(FALSE);

    END_IF;

  END_REPEAT;

END_IF;


IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' +'CHARACTERIZED_CLASS' IN  TYPEOF(aia.assigned_class))THEN
  IF	NOT(role.name IN ['definitional','non-definitional',''])THEN
    RETURN(FALSE);
 
  END_IF;


  REPEAT i:=LOINDEX(aia.items)TO  HIINDEX(aia.items);

    item:= aia.items[i];


    IF (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0)THEN
-- item invalid IF item does NOT belong TO the types that may have a characterized_class
	RETURN(FALSE);

    END_IF;

  END_REPEAT;

END_IF;

RETURN(TRUE);</algorithm>
      </function>
      <function name="closed_shell_reversed">
         <parameter name="a_shell">
            <typename name="closed_shell"/>
         </parameter>
         <typename name="oriented_closed_shell"/>
         <algorithm>LOCAL

    the_reverse : oriented_closed_shell;

  END_LOCAL
;

   IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(a_shell))THEN
      the_reverse := dummy_tri ||
                    connected_face_set(
                       a_shell\connected_face_set.cfs_faces)||
                    closed_shell()|| oriented_closed_shell(
                     a_shell\oriented_closed_shell.closed_shell_element,
                       NOT(a_shell\oriented_closed_shell.orientation));

   ELSE
      the_reverse := dummy_tri ||
               connected_face_set(
                 a_shell\connected_face_set.cfs_faces)||
               closed_shell()|| oriented_closed_shell(a_shell, FALSE);

   END_IF;

   RETURN(the_reverse);</algorithm>
      </function>
      <function name="conditional_reverse">
         <parameter name="p">
            <builtintype type="BOOLEAN"/>
         </parameter>
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF p THEN
     RETURN (an_item);

   ELSE
     RETURN(topology_reversed(an_item));

   END_IF;</algorithm>
      </function>
      <function name="constraints_composite_curve_on_surface">
         <parameter name="c">
            <typename name="composite_curve_on_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

     n_segments : INTEGER := SIZEOF(c.segments);

   END_LOCAL
;

        
   REPEAT k := 1 TO n_segments;

     IF(NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN  
           TYPEOF(c\composite_curve.segments[k].parent_curve)))AND
       (NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SURFACE_CURVE' IN 
           TYPEOF(c\composite_curve.segments[k].parent_curve)))AND
       (NOT('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN
           TYPEOF(c\composite_curve.segments[k].parent_curve))) THEN
       RETURN(FALSE);

     END_IF;

   END_REPEAT;

   RETURN(TRUE);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_surface_model">
         <parameter name="m">
            <typename name="shell_based_surface_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

     result : BOOLEAN := TRUE;

   END_LOCAL
;

   
   REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);

     IF(NOT('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                     TYPEOF(m.sbsm_boundary[j]))AND
       (NOT('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
           TYPEOF(m.sbsm_boundary[j]))))
     THEN
       result := FALSE;

       RETURN(result);

      (* A surface model is composed OF OPEN_ AND CLOSED_SHELLs.*)
     END_IF;

   END_REPEAT;

   RETURN(result);</algorithm>
      </function>
      <function name="constraints_geometry_shell_based_wireframe_model">
         <parameter name="m">
            <typename name="shell_based_wireframe_model"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

     result : BOOLEAN := TRUE;

   END_LOCAL
;


   REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);

     IF(NOT('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                    TYPEOF(m.sbwm_boundary[j]))AND
       (NOT('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j]))))
     THEN
       result := FALSE;

       RETURN(result);

      (* A wireframe model is composed OF WIRE_ AND VERTEX_SHELLs *)
     END_IF;

   END_REPEAT;

   RETURN(result);</algorithm>
      </function>
      <function name="constraints_param_b_spline">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knot_mult">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="knots">
            <aggregate type="LIST" lower="0" upper="?"/>
            <typename name="parameter_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

     result  : BOOLEAN := TRUE;

     k, sum  : INTEGER;

   END_LOCAL
;

   
  (* Find sum OF knot multiplicities.*)
   sum := knot_mult[1];

   
   REPEAT  i := 2 TO  up_knots;

     sum := sum + knot_mult[i];

   END_REPEAT;

   
  (* Check limits holding FOR all B-spline parametrisations *)
   IF (degree &lt; 1)OR (up_knots &lt; 2)OR (up_cp &lt; degree)OR
        (sum &lt;&gt;(degree + up_cp + 2))THEN
     result := FALSE;

     RETURN(result);

   END_IF;

   
   k := knot_mult[1];

   
   IF (k &lt; 1)OR (k &gt; degree + 1)THEN
     result := FALSE;

     RETURN(result);

   END_IF;

      
   REPEAT i := 2 TO up_knots;

     IF (knot_mult[i] &lt; 1)OR(knots[i] &lt;= knots[i-1])THEN
       result := FALSE;

       RETURN(result);

     END_IF;

        
     k := knot_mult[i];

     
     IF (i &lt; up_knots)AND (k &gt; degree)THEN
       result := FALSE;

       RETURN(result);

     END_IF;

        
     IF(i = up_knots)AND(k &gt; degree + 1)THEN
       result := FALSE;

       RETURN(result);

     END_IF;

   END_REPEAT;

   RETURN(result);</algorithm>
      </function>
      <function name="constraints_rectangular_composite_surface">
         <parameter name="s">
            <typename name="rectangular_composite_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>REPEAT i := 1 TO  s.n_u;

       REPEAT  j := 1 TO  s.n_v;

         IF  NOT(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.B_SPLINE_SURFACE' IN  TYPEOF
                   (s.segments[i][j].parent_surface))OR
                ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                   (s.segments[i][j].parent_surface)))THEN
           RETURN(FALSE);

       END_IF;

     END_REPEAT;

   END_REPEAT;


  (* Check the transition codes, omitting the last row OR column *)
   REPEAT  i := 1 TO  s.n_u-1;

     REPEAT  j := 1 TO  s.n_v;

       IF  s.segments[i][j].u_transition = discontinuous THEN
         RETURN(FALSE);

       END_IF;

     END_REPEAT;

   END_REPEAT;

   
   REPEAT  i := 1 TO  s.n_u;

     REPEAT j := 1 TO s.n_v-1;

       IF s.segments[i][j].v_transition = discontinuous THEN
         RETURN(FALSE);

       END_IF;

     END_REPEAT;

   END_REPEAT;

   RETURN(TRUE);</algorithm>
      </function>
      <function name="cross_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL

    mag    : REAL;

    res    : direction;

    v1,v2  : LIST[3:3] OF REAL;

    result : vector;

  END_LOCAL
;

  
  IF(NOT  EXISTS (arg1)OR (arg1.dim = 2))OR
   (NOT EXISTS(arg2)OR(arg2.dim = 2))THEN
    RETURN(?);

  ELSE
    BEGIN
      v1  := normalise(arg1).direction_ratios;

      v2  := normalise(arg2).direction_ratios;

      res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
           (v1[3]*v2[1] - v1[1]*v2[3]),(v1[1]*v2[2] - v1[2]*v2[1])]);

      mag := 0.0;

      REPEAT i := 1 TO 3;

        mag := mag + res.direction_ratios[i]*res.direction_ratios[i];

      END_REPEAT;

      IF(mag &gt; 0.0)THEN
        result := dummy_gri || vector(res, SQRT(mag));

      ELSE
        result := dummy_gri || vector(arg1, 0.0);

      END_IF;

      RETURN(result);

    END;

  END_IF;</algorithm>
      </function>
      <function name="curve_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_curve"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

     result : BOOLEAN := TRUE;

   END_LOCAL
;


   REPEAT i := 0 TO b.upper_index_on_control_points;

     IF b.weights[i] &lt;= 0.0  THEN
       result := FALSE;

       RETURN(result);

     END_IF;

   END_REPEAT;

   RETURN(result);</algorithm>
      </function>
      <function name="default_b_spline_curve_weights">
         <parameter name="up_cp">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="REAL"/>
         <algorithm>RETURN([1:up_cp + 1]);</algorithm>
      </function>
      <function name="default_b_spline_knot_mult">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="uniform">
            <typename name="knot_type"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="?"/>
         <builtintype type="INTEGER"/>
         <algorithm>LOCAL

     knot_mult : LIST [1:up_knots] OF INTEGER;

   END_LOCAL
;

        
   IF  uniform = uniform_knots THEN
     knot_mult := [1:up_knots];

   ELSE
     IF  uniform = quasi_uniform_knots THEN
       knot_mult := [1:up_knots];

       knot_mult[1] := degree + 1;

       knot_mult[up_knots] := degree + 1;

     ELSE
       IF uniform = piecewise_bezier_knots THEN
         knot_mult := [degree:up_knots];

         knot_mult[1] := degree + 1;

         knot_mult[up_knots] := degree + 1;

       ELSE
         knot_mult := [0:up_knots];

       END_IF;

     END_IF;

   END_IF;

   RETURN(knot_mult);</algorithm>
      </function>
      <function name="default_b_spline_knots">
         <parameter name="degree">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="up_knots">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="uniform">
            <typename name="knot_type"/>
         </parameter>
         <aggregate type="LIST" lower="2" upper="?"/>
         <typename name="parameter_value"/>
         <algorithm>LOCAL

    knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];

    ishift : INTEGER := 1;

  END_LOCAL
;


  IF (uniform = uniform_knots)THEN
     ishift := degree + 1;

  END_if;

  IF(uniform = uniform_knots)OR 
    (uniform = quasi_uniform_knots)OR
    (uniform = piecewise_bezier_knots)THEN
    
    REPEAT i := 1 TO up_knots;

      knots[i] := i - ishift;

    END_REPEAT;

  END_IF;

  RETURN(knots);</algorithm>
      </function>
      <function name="default_b_spline_surface_weights">
         <parameter name="u_upper">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="v_upper">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="REAL"/>
         <algorithm>RETURN([[1:v_upper + 1]:u_upper +1]);</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr2">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF SIZEOF(agg)&lt;= 5 THEN 
  RETURN(TRUE);
 
ELSE 
  RETURN(FALSE);
 
END_IF;
 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr3">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF(SIZEOF(QUERY(i &lt;* agg |(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i))
  AND (i\representation_item.name = 'significant number of digits'))))= 1)OR 
((SIZEOF(QUERY(i &lt;* agg |(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i))AND  
 (i\representation_item.name = 'lower limit'))))= 1)AND  
(SIZEOF(QUERY(i &lt;* agg |(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i))AND 
 (i\representation_item.name = 'upper limit'))))= 1))THEN 
  RETURN(TRUE);
 
ELSE 
  RETURN(FALSE);
 
END_IF;
 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr4">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF(SIZEOF(QUERY(i &lt;* agg |(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i))AND  
 (i\representation_item.name = 'plus minus tolerance value'))))= 1)OR 
((SIZEOF(QUERY(i &lt;* agg |(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF(i))AND (
  i\representation_item.name = 'lower tolerance value'))))= 1)AND  
(SIZEOF(QUERY(i &lt;* agg |(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i))AND(
  i\representation_item.name = 'upper tolerance value'))))= 1))THEN 
  RETURN(TRUE);
 
ELSE 
  RETURN(FALSE);
 
END_IF;
 
END;</algorithm>
      </function>
      <function name="default_tolerance_table_cell_wr5">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN 
IF(SIZEOF(QUERY(i &lt;* agg |('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(i))))&lt;= 1)AND  
(SIZEOF(QUERY(i &lt;* agg |('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(i))))= 
  SIZEOF(QUERY(i &lt;* agg |(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i))AND 
 (i\representation_item.name = 'cell description')))))
THEN 
  RETURN(TRUE);
 
ELSE 
  RETURN(FALSE);
 
END_IF;
 
END;</algorithm>
      </function>
      <function name="derive_dimensional_exponents">
         <parameter name="x">
            <typename name="unit"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>LOCAL

    result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);

  END_LOCAL
;


  IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DERIVED_UNIT' IN TYPEOF(x)THEN
    REPEAT i := LOINDEX(x.elements)TO HIINDEX(x.elements);

      result.length_exponent := result.length_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);

      result.mass_exponent := result.mass_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);

      result.time_exponent := result.time_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);

      result.electric_current_exponent := result.electric_current_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);

      result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);

      result.amount_of_substance_exponent := result.amount_of_substance_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);

      result.luminous_intensity_exponent := result.luminous_intensity_exponent +(x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);

    END_REPEAT;

  ELSE
    result := x.dimensions;

  END_IF;

  RETURN(result);</algorithm>
      </function>
      <function name="dimension_of">
         <parameter name="item">
            <typename name="geometric_representation_item"/>
         </parameter>
         <typename name="dimension_count"/>
         <algorithm>LOCAL

    x   : SET  OF  representation;

    y   : representation_context;

    dim : dimension_count;

  END_LOCAL
;

  -- FOR  cartesian_point, direction, OR vector dimension is determined by
  -- counting components.
    IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CARTESIAN_POINT' IN  TYPEOF(item)THEN
       dim := SIZEOF(item\cartesian_point.coordinates);

       RETURN(dim);

    END_IF;

    IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DIRECTION' IN  TYPEOF(item)THEN
       dim := SIZEOF(item\direction.direction_ratios);

       RETURN(dim);

    END_IF;

    IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN  TYPEOF(item)THEN
       dim := SIZEOF(item\vector.orientation\direction.direction_ratios);

       RETURN(dim);

    END_IF;

  -- FOR  all other types OF  geometric_representation_item dim is obtained
  -- via context.
  -- Find the SET  OF  representation IN which the item is used.

  x := using_representations(item);


  -- Determines the dimension_count OF  the 
  -- geometric_representation_context.Note that the 
  -- RULE compatible_dimension ensures that the context_of_items
  -- is OF  TYPE geometric_representation_context AND has
  -- the same dimension_count FOR all values OF x.
  -- The SET x is non-empty since this is required BY WR1 of
  -- representation_item.
    y := x[1].context_of_items;

    dim := y\geometric_representation_context.coordinate_space_dimension;

    RETURN(dim);</algorithm>
      </function>
      <function name="dimensions_for_si_unit">
         <parameter name="n">
            <typename name="si_unit_name"/>
         </parameter>
         <typename name="dimensional_exponents"/>
         <algorithm>CASE n OF
    metre          : RETURN (dimensional_exponents
                         (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    gram           : RETURN (dimensional_exponents
                        (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    second         : RETURN (dimensional_exponents
                        (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));

    ampere         : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));

    kelvin         : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));

    mole           : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));

    candela        : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));

    radian         : RETURN (dimensional_exponents
                          (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    steradian      : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));

    hertz          : RETURN (dimensional_exponents
                        (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));

    newton         : RETURN (dimensional_exponents
                        (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    pascal         : RETURN (dimensional_exponents
                        (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    joule          : RETURN (dimensional_exponents
                        (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    watt           : RETURN (dimensional_exponents
                        (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));

    coulomb        : RETURN (dimensional_exponents
                        (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));

    volt           : RETURN (dimensional_exponents
                        (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));

    farad          : RETURN (dimensional_exponents
                        (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));

    ohm            : RETURN (dimensional_exponents
                        (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));

    siemens        : RETURN (dimensional_exponents
                        (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));

    weber          : RETURN (dimensional_exponents
                        (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));

    tesla          : RETURN (dimensional_exponents
                        (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));

    henry          : RETURN (dimensional_exponents
                        (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));

    degree_Celsius : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));

    lumen          : RETURN (dimensional_exponents
                        (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));

    lux            : RETURN (dimensional_exponents
                        (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));

    becquerel      : RETURN (dimensional_exponents
                        (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));

    gray           : RETURN (dimensional_exponents
                        (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    sievert        : RETURN (dimensional_exponents
                        (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));

    OTHERWISE      : RETURN(?);

  END_CASE;</algorithm>
      </function>
      <function name="dot_product">
         <parameter name="arg1">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="direction"/>
         </parameter>
         <builtintype type="REAL"/>
         <algorithm>LOCAL

     scalar : REAL;

     vec1, vec2: direction;

     ndim : INTEGER;

   END_LOCAL
;

   
   IF  NOT  EXISTS (arg1)OR NOT EXISTS(arg2)THEN
     scalar := ?;

    (* When FUNCTION  is called WITH  invalid data an indeterminate result
     is RETURNed *)
   ELSE
     IF(arg1.dim &lt;&gt; arg2.dim)THEN
       scalar := ?;

    (* When FUNCTION is called WITH invalid data an indeterminate result
     is RETURNed *)
     ELSE
       BEGIN
         vec1   := normalise(arg1);

         vec2   := normalise(arg2);

         ndim   := arg1.dim;

         scalar := 0.0;

         REPEAT  i := 1 TO ndim;

           scalar := scalar +
                       vec1.direction_ratios[i]*vec2.direction_ratios[i];

         END_REPEAT;

       END;

     END_IF;

   END_IF;

   RETURN(scalar);</algorithm>
      </function>
      <function name="edge_curve_pcurves">
         <parameter name="an_edge">
            <typename name="edge_curve"/>
         </parameter>
         <parameter name="the_surface_curves">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="surface_curve"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="pcurve"/>
         <algorithm>LOCAL

  a_curve      : curve;

  result       : SET OF  pcurve;

  the_geometry : LIST[1:2] OF pcurve_or_surface;

END_LOCAL
;

  a_curve := an_edge.edge_geometry;

  result := [];

  IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF(a_curve)THEN
    result := result + a_curve;

  ELSE
    IF  'GEOMETRY_SCHEMA.SURFACE_CURVE' IN  TYPEOF(a_curve)THEN
      the_geometry := a_curve\surface_curve.associated_geometry;

      REPEAT  k := 1 TO  SIZEOF(the_geometry);

         IF  'GEOMETRY_SCHEMA.PCURVE' IN  TYPEOF (the_geometry[k])
         THEN
            result := result + the_geometry[k];

         END_IF;

      END_REPEAT;

    ELSE
      REPEAT  j := 1 TO  SIZEOF(the_surface_curves);

        the_geometry := the_surface_curves[j].associated_geometry;

        IF  the_surface_curves[j].curve_3d :=: a_curve
        THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);

            IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(the_geometry[k])
            THEN
              result := result + the_geometry[k];

            END_IF;

          END_REPEAT;

        END_IF;

      END_REPEAT;

    END_IF;

  END_IF;


  RETURN(RESULT);</algorithm>
      </function>
      <function name="edge_reversed">
         <parameter name="an_edge">
            <typename name="edge"/>
         </parameter>
         <typename name="oriented_edge"/>
         <algorithm>LOCAL

     the_reverse : oriented_edge;

   END_LOCAL
;


   IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_EDGE' IN TYPEOF(an_edge))THEN
     the_reverse  := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start)||
             oriented_edge(an_edge\oriented_edge.edge_element,
                        NOT(an_edge\oriented_edge.orientation));

   ELSE
     the_reverse := dummy_tri ||
             edge(an_edge.edge_end, an_edge.edge_start)||
             oriented_edge(an_edge, FALSE);

   END_IF;

   RETURN(the_reverse);</algorithm>
      </function>
      <function name="face_bound_reversed">
         <parameter name="a_face_bound">
            <typename name="face_bound"/>
         </parameter>
         <typename name="face_bound"/>
         <algorithm>LOCAL

     the_reverse : face_bound ;

   END_LOCAL
;

   IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(a_face_bound))THEN
     the_reverse := dummy_tri ||
                      face_bound(a_face_bound\face_bound.bound,
                           NOT(a_face_bound\face_bound.orientation))
                            || face_outer_bound();

   ELSE
     the_reverse := dummy_tri ||
         face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));

   END_IF;

  RETURN(the_reverse);</algorithm>
      </function>
      <function name="face_reversed">
         <parameter name="a_face">
            <typename name="face"/>
         </parameter>
         <typename name="oriented_face"/>
         <algorithm>LOCAL

     the_reverse : oriented_face ;

   END_LOCAL
;

   IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_FACE' IN TYPEOF(a_face))THEN
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds))||
          oriented_face(a_face\oriented_face.face_element,
                           NOT(a_face\oriented_face.orientation));

   ELSE
     the_reverse := dummy_tri ||
       face(set_of_topology_reversed(a_face.bounds))||
                               oriented_face(a_face, FALSE);

   END_IF;

      RETURN(the_reverse);</algorithm>
      </function>
      <function name="first_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL

    x_axis : direction;

    v      : direction;

    z      : direction;

    x_vec  : vector;

  END_LOCAL
;

  
  IF (NOT EXISTS(z_axis))THEN
    RETURN (?);

  ELSE
    z := normalise(z_axis);

    IF  NOT EXISTS(arg)THEN
      IF ((z.direction_ratios &lt;&gt; [1.0,0.0,0.0])AND
         (z.direction_ratios &lt;&gt; [-1.0,0.0,0.0])) THEN
        v :=  dummy_gri || direction([1.0,0.0,0.0]);

      ELSE
        v := dummy_gri || direction([0.0,1.0,0.0]);

      END_IF;

    ELSE
      IF  (arg.dim &lt;&gt; 3)THEN
        RETURN (?);

      END_IF;

      IF((cross_product(arg,z).magnitude)= 0.0)THEN
        RETURN(?);

      ELSE
        v := normalise(arg);

      END_IF;

    END_IF;

    x_vec := scalar_times_vector(dot_product(v, z), z);

    x_axis := vector_difference(v, x_vec).orientation;

    x_axis := normalise(x_axis);

  END_IF;

  RETURN(x_axis);</algorithm>
      </function>
      <function name="get_basis_surface">
         <parameter name="c">
            <typename name="curve_on_surface"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="2"/>
         <typename name="surface"/>
         <algorithm>LOCAL

    surfs  : SET[0:2] OF  surface;

    n      : INTEGER;

  END_LOCAL
;

  surfs := [];

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PCURVE' IN  TYPEOF (c)THEN
    surfs := [c\pcurve.basis_surface];

  ELSE
    IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SURFACE_CURVE' IN  TYPEOF (c)THEN
      n := SIZEOF(c\surface_curve.associated_geometry);

      REPEAT  i := 1 TO  n;

      surfs := surfs +
                associated_surface(c\surface_curve.associated_geometry[i]);

      END_REPEAT;

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF(c)THEN
  (* FOR a composite_curve_on_surface the basis_surface is the intersection
    OF  the basis_surfaces OF all the segments.*)
     n := SIZEOF(c\composite_curve.segments);

     surfs := get_basis_surface(
                     c\composite_curve.segments[1].parent_curve);

     IF n &gt; 1 THEN
       REPEAT i := 2 TO n;

         surfs := surfs * get_basis_surface(
                  c\composite_curve.segments[i].parent_curve);

       END_REPEAT;

     END_IF;


  END_IF;

  RETURN(surfs);</algorithm>
      </function>
      <function name="get_description_value">
         <parameter name="obj">
            <typename name="description_attribute_select"/>
         </parameter>
         <typename name="text"/>
         <algorithm>LOCAL

    description_bag : BAG OF description_attribute :=(USEDIN(obj, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));

  END_LOCAL
;


  IF SIZEOF(description_bag)= 1 THEN
    RETURN (description_bag[1].attribute_value);

  ELSE
    RETURN(?);

  END_IF;</algorithm>
      </function>
      <function name="get_id_value">
         <parameter name="obj">
            <typename name="id_attribute_select"/>
         </parameter>
         <typename name="identifier"/>
         <algorithm>LOCAL

      id_bag : BAG OF id_attribute :=(USEDIN(obj, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));

END_LOCAL
;

IF SIZEOF(id_bag)= 1 THEN
      RETURN (id_bag[1].attribute_value);

ELSE
      RETURN(?);

END_IF;</algorithm>
      </function>
      <function name="get_name_value">
         <parameter name="obj">
            <typename name="name_attribute_select"/>
         </parameter>
         <typename name="label"/>
         <algorithm>LOCAL

    name_bag : BAG OF name_attribute :=(USEDIN(obj, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));

  END_LOCAL
;


  IF SIZEOF(name_bag)= 1 THEN
    RETURN (name_bag[1].attribute_value);

  ELSE
    RETURN(?);

  END_IF;</algorithm>
      </function>
      <function name="get_product_definitions">
         <parameter name="c_def_instance">
            <typename name="product"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="product_definition"/>
         <algorithm>LOCAL

      pd_set : SET  OF  product_definition_formation := [];

      pdr_set : SET OF product_definition := [];

    END_LOCAL
;


    pd_set := bag_to_set(USEDIN(c_def_instance, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));

    IF(SIZEOF(pd_set)&lt; 1)THEN
      RETURN (pdr_set);

    END_IF;

    REPEAT i := 1 TO HIINDEX(pd_set);

      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_DEFINITION.FORMATION'));

    END_REPEAT;

    RETURN(pdr_set);</algorithm>
      </function>
      <function name="get_property_definition_representations">
         <parameter name="c_def_instance">
            <typename name="characterized_definition"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="property_definition_representation"/>
         <algorithm>LOCAL

      pd_set : SET  OF  property_definition := [];

      pdr_set : SET OF property_definition_representation := [];

      END_LOCAL
;

      
 pd_set := bag_to_set(USEDIN(c_def_instance,
      'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));

 IF(SIZEOF(pd_set)&lt; 1)THEN RETURN (pdr_set);

 END_IF;


 REPEAT i:= 1 TO HIINDEX(pd_set);

    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i],
'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));

 END_REPEAT;

 RETURN(pdr_set);</algorithm>
      </function>
      <function name="get_role">
         <parameter name="obj">
            <typename name="role_select"/>
         </parameter>
         <typename name="object_role"/>
         <algorithm>LOCAL

    role_bag : BAG OF role_association :=(USEDIN(obj, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));

  END_LOCAL
;


  IF SIZEOF(role_bag)= 1 THEN
    RETURN (role_bag[1].role);

  ELSE
    RETURN(?);

  END_IF;</algorithm>
      </function>
      <function name="get_shape_aspect_property_definition_representations">
         <parameter name="s_a_instance">
            <typename name="shape_aspect"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="property_definition_representation"/>
         <algorithm>LOCAL

pd_set : SET  OF  property_definition := [];

pdr_set : SET OF property_definition_representation := [] ;

END_LOCAL
;

pd_set := bag_to_set(USEDIN(s_a_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));

IF(SIZEOF(pd_set)&lt; 1)THEN
RETURN(pdr_set);

END_IF;

REPEAT i := 1 TO HIINDEX(pd_set);

pdr_set := pdr_set +(QUERY(pdr &lt;* USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'PROPERTY_DEFINITION_REPRESENTATION.' + 'DEFINITION')|
'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr)));

END_REPEAT;

RETURN(pdr_set);</algorithm>
      </function>
      <function name="get_shape_aspects">
         <parameter name="c_def_instance">
            <typename name="characterized_definition"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="shape_aspect"/>
         <algorithm>LOCAL

      pd_set : SET  OF  product_definition_shape := [];

      pdr_set : SET OF shape_aspect := [];

    END_LOCAL
;


    pd_set := bag_to_set(QUERY(pd &lt;* USEDIN(c_def_instance, 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PROPERTY_DEFINITION.DEFINITION')| 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));

    IF(SIZEOF(pd_set)&lt; 1)THEN
      RETURN (pdr_set);

    END_IF;

    REPEAT i := 1 TO HIINDEX(pd_set);

      pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));

    END_REPEAT;

    RETURN(pdr_set);</algorithm>
      </function>
      <function name="is_acyclic">
         <parameter name="arg">
            <typename name="generic_expression"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>RETURN(acyclic(arg, []));</algorithm>
      </function>
      <function name="item_in_context">
         <parameter name="item">
            <typename name="representation_item"/>
         </parameter>
         <parameter name="cntxt">
            <typename name="representation_context"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

    y : BAG  OF  representation_item;

  END_LOCAL
;

  -- IF  there is one OR more representation using both the item
  -- AND cntxt RETURN  true.
  IF  SIZEOF(USEDIN(item,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.REPRESENTATION.ITEMS')
    * cntxt.representations_in_context)&gt; 0 THEN
    RETURN (TRUE);

    -- Determine the BAG  OF representation_items that reference
    -- item
    ELSE y := QUERY(z &lt;* USEDIN(item, '')|
           'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.REPRESENTATION_ITEM' IN  TYPEOF(z));

      -- Ensure that the BAG is NOT empty
      IF  SIZEOF(y)&gt; 0 THEN
      -- FOR each element IN  the bag
      REPEAT i := 1 TO  HIINDEX(y);

        -- Check TO see it is an item IN the input cntxt.
        IF item_in_context(y[i], cntxt)THEN
          RETURN (TRUE);

        END_IF;

      END_REPEAT;

    END_IF;

  END_IF;

  -- RETURN  FALSE when all possible branches have been checked
  -- WITH no success.
  RETURN(FALSE);</algorithm>
      </function>
      <function name="leap_year">
         <parameter name="year">
            <typename name="year_number"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF((((year MOD  4)= 0)AND((year MOD  100)&lt;&gt; 0))OR((year MOD 400)= 0))THEN
    RETURN (TRUE);

  ELSE
    RETURN(FALSE);

  END_IF;</algorithm>
      </function>
      <function name="list_face_loops">
         <parameter name="f">
            <typename name="face"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL

     loops : LIST[0:?] OF loop := [];

   END_LOCAL
;

   
   REPEAT i := 1 TO SIZEOF(f.bounds);

     loops := loops +(f.bounds[i].bound);

   END_REPEAT;

      
   RETURN(loops);</algorithm>
      </function>
      <function name="list_loop_edges">
         <parameter name="l">
            <typename name="loop"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="edge"/>
         <algorithm>LOCAL

     edges : LIST[0:?] OF edge := [];

   END_LOCAL
;

      
   IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.EDGE_LOOP' IN TYPEOF(l)THEN
     REPEAT i := 1 TO SIZEOF(l\path.edge_list);

       edges := edges +(l\path.edge_list[i].edge_element);

     END_REPEAT;

   END_IF;


   RETURN(edges);</algorithm>
      </function>
      <function name="list_of_topology_reversed">
         <parameter name="a_list">
            <typename name="list_of_reversible_topology_item"/>
         </parameter>
         <typename name="list_of_reversible_topology_item"/>
         <algorithm>LOCAL

     the_reverse : list_of_reversible_topology_item;

   END_LOCAL
;

    
   the_reverse := [];

   REPEAT i := 1 TO SIZEOF(a_list);

     the_reverse := topology_reversed(a_list [i])+ the_reverse;

   END_REPEAT;

  
   RETURN(the_reverse);</algorithm>
      </function>
      <function name="list_shell_edges">
         <parameter name="s">
            <typename name="shell"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="edge"/>
         <algorithm>LOCAL

     edges : LIST[0:?] OF edge := [];

   END_LOCAL
;

      
   REPEAT i := 1 TO SIZEOF(list_shell_loops(s));

     edges := edges + list_loop_edges(list_shell_loops(s)[i]);

   END_REPEAT;

   
   RETURN(edges);</algorithm>
      </function>
      <function name="list_shell_faces">
         <parameter name="s">
            <typename name="shell"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="face"/>
         <algorithm>LOCAL

     faces : LIST[0:?] OF face := [];

   END_LOCAL
;

   
   IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CLOSED_SHELL' IN  TYPEOF(s))OR 
     ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.OPEN_SHELL' IN TYPEOF(s))THEN
     REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);

       faces := faces + s\connected_face_set.cfs_faces[i];

     END_REPEAT;

   END_IF;

      
   RETURN(faces);</algorithm>
      </function>
      <function name="list_shell_loops">
         <parameter name="s">
            <typename name="shell"/>
         </parameter>
         <aggregate type="LIST" lower="0" upper="?"/>
         <typename name="loop"/>
         <algorithm>LOCAL

     loops : LIST[0:?] OF loop := [];

   END_LOCAL
;

      
   IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VERTEX_SHELL' IN  TYPEOF(s)THEN
     loops := loops + s.vertex_shell_extent;

   END_IF;

      
   IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.WIRE_SHELL' IN  TYPEOF(s)THEN
     REPEAT  i := 1 TO  SIZEOF(s.wire_shell_extent);

       loops := loops + s.wire_shell_extent[i];

     END_REPEAT;

   END_IF;

      
   IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.OPEN_SHELL' IN  TYPEOF(s))OR 
     ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CLOSED_SHELL' IN TYPEOF(s))THEN
     REPEAT i := 1 TO SIZEOF(s.cfs_faces);

       loops := loops + list_face_loops(s.cfs_faces[i]);

     END_REPEAT;

   END_IF;

      
   RETURN(loops);</algorithm>
      </function>
      <function name="list_to_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL

     n   : INTEGER;

     res : ARRAY [low:u] OF GENERIC : T;

   END_LOCAL
;

      
   n := SIZEOF(lis);

   IF(n &lt;&gt;(u-low +1))THEN
     RETURN(?);

   ELSE
     res := [lis[1] : n];

     REPEAT i := 2 TO n;

       res[low+i-1] := lis[i];

     END_REPEAT;

     RETURN(res);

   END_IF;</algorithm>
      </function>
      <function name="list_to_set">
         <parameter name="l">
            <aggregate type="LIST" lower="0" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL

     s : SET OF GENERIC:T := [];

   END_LOCAL
;

      
   REPEAT i := 1 TO SIZEOF(l);

     s := s + l[i];

   END_REPEAT;

   
   RETURN(s);</algorithm>
      </function>
      <function name="local_relatives_of_product_definitions">
         <parameter name="definition_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="total_definitions">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="relation_subtype">
            <builtintype type="STRING"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="product_definition"/>
         <algorithm>LOCAL

    local_def   : SET  OF  product_definition := [];

    local_pdr   : SET  OF  product_definition_relationship := [];

    local_total : SET OF product_definition := [];

  END_LOCAL
;

  REPEAT  i := 1 TO  HIINDEX(definition_set);

    local_pdr := local_pdr +
                 bag_to_set(USEDIN
                  (definition_set[i],
                    relation_subtype + '.RELATING_PRODUCT_DEFINITION'));

  END_REPEAT;

  REPEAT i := 1 TO HIINDEX(local_pdr);

    local_def := local_def + local_pdr[i].related_product_definition;

  END_REPEAT;

  IF(SIZEOF(local_def)- SIZEOF(total_definitions))= 0 THEN
    RETURN(local_def);

  ELSE
    local_total := total_definitions + local_def;

    RETURN(local_def +
         (local_relatives_of_product_definitions
         (local_def - total_definitions, local_total, relation_subtype)));

  END_IF;</algorithm>
      </function>
      <function name="local_relatives_of_shape_representations">
         <parameter name="shape_representation_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="shape_representation"/>
         </parameter>
         <parameter name="total_reps">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="shape_representation"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="shape_representation"/>
         <algorithm>LOCAL

      local_shape_rep : SET  OF  shape_representation := [];

      local_srr       : SET  OF  shape_representation_relationship := [];

      local_total     : SET OF shape_representation := [];

    END_LOCAL
;

    REPEAT  i := 1 TO  HIINDEX(shape_representation_set);

      local_srr := local_srr + QUERY(rr &lt;* bag_to_set
     (USEDIN(shape_representation_set[i],
       'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1'))|
'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP'
      IN  TYPEOF(rr));

    END_REPEAT;

    REPEAT i := 1 TO HIINDEX(local_srr);

      IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.'+
                  'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i])
      THEN
         local_shape_rep := local_shape_rep + local_srr[i].rep_2;

      END_IF;

    END_REPEAT;

    IF SIZEOF(local_shape_rep - total_reps)= 0 THEN
      RETURN(shape_representation_set);

    ELSE
      local_total := total_reps + local_shape_rep;

      RETURN(local_shape_rep +(local_relatives_of_shape_representations
                              (local_shape_rep - total_reps, local_total)));

    END_IF;</algorithm>
      </function>
      <function name="make_array_of_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL

     res   : ARRAY[low1:u1] OF  ARRAY [low2:u2] OF GENERIC : T;

   END_LOCAL
;


(* Check input dimensions FOR consistency *)
   IF (u1-low1+1)&lt;&gt; SIZEOF(lis)THEN
     RETURN (?);

   END_IF;

   IF (u2 - low2 + 1)&lt;&gt; SIZEOF(lis[1])THEN
     RETURN (?);

   END_IF;

(* Initialise res WITH values FROM lis[1] *)
   res := [list_to_array(lis[1], low2, u2):(u1-low1 + 1)];

   REPEAT i := 2 TO HIINDEX(lis);

     IF(u2-low2+1)&lt;&gt; SIZEOF(lis[i])THEN
       RETURN (?);

     END_IF;
     
     res[low1+i-1] := list_to_array(lis[i], low2, u2);

   END_REPEAT;
 
   
   RETURN(res);</algorithm>
      </function>
      <function name="make_array_of_array_of_array">
         <parameter name="lis">
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <aggregate type="LIST" lower="1" upper="?"/>
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="low1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u1">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u2">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="low3">
            <builtintype type="INTEGER"/>
         </parameter>
         <parameter name="u3">
            <builtintype type="INTEGER"/>
         </parameter>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <aggregate type="ARRAY" lower="0" upper="0"/>
         <builtintype type="GENERIC"/>
         <algorithm>LOCAL
 
   res   : ARRAY[low1:u1] OF  ARRAY [low2:u2] OF
             ARRAY[low3:u3] OF GENERIC : T;

 END_LOCAL
;
                

(* Check input dimensions FOR consistency *)
   IF (u1-low1+1)&lt;&gt; SIZEOF(lis)THEN
     RETURN (?);

   END_IF;

   IF (u2-low2+1)&lt;&gt; SIZEOF(lis[1])THEN
     RETURN (?);

   END_IF;

(* Initialise res WITH values FROM lis[1] *)
   res := [make_array_of_array(lis[1], low2, u2, low3, u3):(u1-low1 + 1)];

   REPEAT i := 2 TO HIINDEX(lis);

     IF(u2-low2+1)&lt;&gt; SIZEOF(lis[i])THEN
       RETURN (?);

     END_IF;
  
     res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);

   END_REPEAT;
 
   RETURN(res);</algorithm>
      </function>
      <function name="mixed_loop_type_set">
         <parameter name="l">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="loop"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL

      poly_loop_type: LOGICAL;

    END_LOCAL
;

    IF(SIZEOF(l)&lt;= 1)THEN
      RETURN(FALSE);

    END_IF;

    poly_loop_type :=('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.POLY_LOOP' IN  TYPEOF(l[1]));

    REPEAT i := 2 TO SIZEOF(l);

      IF(('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.POLY_LOOP' IN TYPEOF(l[i]))&lt;&gt; poly_loop_type)
          THEN
          RETURN(TRUE);

       END_IF;

    END_REPEAT;

    RETURN(FALSE);</algorithm>
      </function>
      <function name="msb_shells">
         <parameter name="brep">
            <typename name="manifold_solid_brep"/>
         </parameter>
         <aggregate type="SET" lower="1" upper="?"/>
         <typename name="closed_shell"/>
         <algorithm>IF SIZEOF(QUERY(msbtype &lt;* TYPEOF(brep)|
       msbtype LIKE '*BREP_WITH_VOIDS'))&gt;= 1 THEN
       RETURN(brep\brep_with_voids.voids + brep.outer);

     ELSE
       RETURN([brep.outer]);

     END_IF;</algorithm>
      </function>
      <function name="normalise">
         <parameter name="arg">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector_or_direction"/>
         <algorithm>LOCAL

     ndim   : INTEGER;

     v      : direction;

     result : vector_or_direction;

     vec    : vector;

     mag    : REAL;

   END_LOCAL
;

   
   IF  NOT EXISTS(arg)THEN
     result := ?;

(* When FUNCTION is called WITH invalid data a NULL result is RETURNed *)
   ELSE
     ndim := arg.dim;

     IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN  TYPEOF(arg)THEN
       BEGIN
             v := dummy_gri || direction(arg.orientation.direction_ratios);

         IF  arg.magnitude = 0.0 THEN
           RETURN(?);

         ELSE
          vec := dummy_gri || vector(v, 1.0);

         END_IF;

       END;

     ELSE
       v := dummy_gri || direction(arg.direction_ratios);

     END_IF;

     mag := 0.0;

     REPEAT   i := 1 TO  ndim;

       mag := mag + v.direction_ratios[i]*v.direction_ratios[i];

     END_REPEAT;

     IF  mag &gt; 0.0 THEN
       mag := SQRT(mag);

       REPEAT  i := 1 TO ndim;

         v.direction_ratios[i] := v.direction_ratios[i]/mag;

       END_REPEAT;

       IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN TYPEOF(arg)THEN
         vec.orientation := v;

         result := vec;

       ELSE
         result := v;

       END_IF;

     ELSE
       RETURN(?);

     END_IF;

   END_IF;

   RETURN(result);</algorithm>
      </function>
      <function name="open_shell_reversed">
         <parameter name="a_shell">
            <typename name="open_shell"/>
         </parameter>
         <typename name="oriented_open_shell"/>
         <algorithm>LOCAL

     the_reverse : oriented_open_shell;

   END_LOCAL
;

   IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(a_shell))THEN
     the_reverse := dummy_tri ||
                  connected_face_set(
                      a_shell\connected_face_set.cfs_faces)||
                  open_shell()|| oriented_open_shell(
                    a_shell\oriented_open_shell.open_shell_element,
                     (NOT(a_shell\oriented_open_shell.orientation)));

   ELSE
     the_reverse := dummy_tri ||
                 connected_face_set(
                     a_shell\connected_face_set.cfs_faces)||
                 open_shell()||  oriented_open_shell(a_shell, FALSE);

   END_IF;

   RETURN(the_reverse);</algorithm>
      </function>
      <function name="orthogonal_complement">
         <parameter name="vec">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL

     result :  direction ;

   END_LOCAL
;


   IF(vec.dim &lt;&gt; 2)OR NOT EXISTS(vec)THEN
     RETURN(?);

   ELSE
     result := dummy_gri || direction([-vec.direction_ratios[2],
                                          vec.direction_ratios[1]]);

     RETURN(result);

   END_IF;</algorithm>
      </function>
      <function name="path_head_to_tail">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL

     n : INTEGER;

     p : LOGICAL := TRUE;

   END_LOCAL
;

     
     n := SIZEOF(a_path.edge_list);

     REPEAT i := 2 TO n;

       p := p AND(a_path.edge_list[i-1].edge_end :=:
                   a_path.edge_list[i].edge_start);

     END_REPEAT;

     
     RETURN(p);</algorithm>
      </function>
      <function name="path_reversed">
         <parameter name="a_path">
            <typename name="path"/>
         </parameter>
         <typename name="oriented_path"/>
         <algorithm>LOCAL

    the_reverse : oriented_path ;

  END_LOCAL
;

  IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ORIENTED_PATH' IN TYPEOF(a_path))THEN
    the_reverse := dummy_tri ||
       path(list_of_topology_reversed(a_path.edge_list))||
          oriented_path(a_path\oriented_path.path_element,
                          NOT(a_path\oriented_path.orientation));

  ELSE
    the_reverse := dummy_tri ||
                   path(list_of_topology_reversed(a_path.edge_list))||
                       oriented_path(a_path, FALSE);

  END_IF;


  RETURN(the_reverse);</algorithm>
      </function>
      <function name="relatives_of_product_definitions">
         <parameter name="definition_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="product_definition"/>
         </parameter>
         <parameter name="relation_subtype">
            <builtintype type="STRING"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="product_definition"/>
         <algorithm>RETURN(local_relatives_of_product_definitions
      (definition_set, definition_set, relation_subtype));</algorithm>
      </function>
      <function name="relatives_of_shape_representations">
         <parameter name="shape_representation_set">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="shape_representation"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="shape_representation"/>
         <algorithm>RETURN(local_relatives_of_shape_representations
         (shape_representation_set, shape_representation_set));</algorithm>
      </function>
      <function name="same_side">
         <parameter name="plane_pts">
            <aggregate type="LIST" lower="3" upper="3"/>
            <typename name="cartesian_point"/>
         </parameter>
         <parameter name="test_points">
            <aggregate type="LIST" lower="2" upper="?"/>
            <typename name="cartesian_point"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

     val1, val2 : REAL;

     n          : INTEGER;

   END_LOCAL
;


   IF (plane_pts[1].dim = 2)OR(test_points[1].dim = 2)THEN
     RETURN(?);

   END_IF;

   n := SIZEOF(test_points);

   val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[1]);

   REPEAT i := 2 TO n;

     val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                       test_points[i]);

     IF(val1*val2 &lt;= 0.0)THEN
       RETURN(FALSE);

     END_IF;

   END_REPEAT;

   RETURN(TRUE);</algorithm>
      </function>
      <function name="scalar_times_vector">
         <parameter name="scalar">
            <builtintype type="REAL"/>
         </parameter>
         <parameter name="vec">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL

     v      : direction;

     mag    : REAL;

     result : vector;

   END_LOCAL
;


   IF  NOT  EXISTS (scalar)OR NOT EXISTS(vec)THEN
     RETURN (?);

    ELSE
     IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN TYPEOF(vec)THEN
       v   := dummy_gri || direction(vec.orientation.direction_ratios);

       mag := scalar * vec.magnitude;

     ELSE
       v   := dummy_gri || direction(vec.direction_ratios);

       mag := scalar;

     END_IF;

     IF(mag &lt; 0.0)THEN
       REPEAT i := 1 TO SIZEOF(v.direction_ratios);

         v.direction_ratios[i] := -v.direction_ratios[i];

       END_REPEAT;

       mag := -mag;

     END_IF;

     result := dummy_gri || vector(normalise(v), mag);

   END_IF;

   RETURN(result);</algorithm>
      </function>
      <function name="second_proj_axis">
         <parameter name="z_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="x_axis">
            <typename name="direction"/>
         </parameter>
         <parameter name="arg">
            <typename name="direction"/>
         </parameter>
         <typename name="direction"/>
         <algorithm>LOCAL

     y_axis : vector;

     v      : direction;

     temp   : vector;

   END_LOCAL
;

   
   IF NOT EXISTS(arg)THEN
     v := dummy_gri || direction([0.0,1.0,0.0]);

   ELSE
     v := arg;

   END_IF;

   
   temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);

   y_axis := vector_difference(v, temp);

   temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);

   y_axis := vector_difference(y_axis, temp);

   y_axis := normalise(y_axis);

   RETURN(y_axis.orientation);</algorithm>
      </function>
      <function name="set_of_topology_reversed">
         <parameter name="a_set">
            <typename name="set_of_reversible_topology_item"/>
         </parameter>
         <typename name="set_of_reversible_topology_item"/>
         <algorithm>LOCAL

     the_reverse : set_of_reversible_topology_item;

   END_LOCAL
;

   
   the_reverse := [];

   REPEAT i := 1 TO SIZEOF(a_set);

     the_reverse := the_reverse + topology_reversed(a_set [i]);

   END_REPEAT;

   
   RETURN(the_reverse);</algorithm>
      </function>
      <function name="shell_reversed">
         <parameter name="a_shell">
            <typename name="shell"/>
         </parameter>
         <typename name="shell"/>
         <algorithm>IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.OPEN_SHELL' IN  TYPEOF (a_shell))THEN
     RETURN (open_shell_reversed(a_shell));

   ELSE
     IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CLOSED_SHELL' IN TYPEOF(a_shell))THEN
       RETURN (closed_shell_reversed(a_shell));

     ELSE
       RETURN(?);

     END_IF;

   END_IF;</algorithm>
      </function>
      <function name="surface_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_surface"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

     result        : BOOLEAN := TRUE;

   END_LOCAL
;

   
   REPEAT  i := 0 TO  b.u_upper;

     REPEAT j := 0 TO b.v_upper;

       IF(b.weights[i][j] &lt;= 0.0) THEN
         result := FALSE;

         RETURN(result);

       END_IF;

     END_REPEAT;

   END_REPEAT;

   RETURN(result);</algorithm>
      </function>
      <function name="topology_reversed">
         <parameter name="an_item">
            <typename name="reversible_topology"/>
         </parameter>
         <typename name="reversible_topology"/>
         <algorithm>IF('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.EDGE' IN  TYPEOF (an_item))THEN
     RETURN (edge_reversed(an_item));

   END_IF;


   IF ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PATH' IN  TYPEOF (an_item))THEN
     RETURN (path_reversed(an_item));

   END_IF;


   IF ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.FACE_BOUND' IN  TYPEOF (an_item))THEN
     RETURN (face_bound_reversed(an_item));

   END_IF;

  
   IF ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.FACE' IN  TYPEOF (an_item))THEN
     RETURN (face_reversed(an_item));

   END_IF;


   IF ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SHELL' IN  TYPEOF (an_item))THEN
     RETURN (shell_reversed(an_item));

   END_IF;


   IF ('SET' IN  TYPEOF (an_item))THEN
     RETURN (set_of_topology_reversed(an_item));

   END_IF;


   IF('LIST' IN TYPEOF(an_item))THEN
     RETURN (list_of_topology_reversed(an_item));

   END_IF;


   RETURN(?);</algorithm>
      </function>
      <function name="type_check_function">
         <parameter name="the_type">
            <builtintype type="GENERIC"/>
         </parameter>
         <parameter name="sub_names">
            <aggregate type="SET" lower="0" upper="?"/>
            <builtintype type="STRING"/>
         </parameter>
         <parameter name="criterion">
            <builtintype type="INTEGER"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>IF((NOT EXISTS(the_type))OR(NOT({0&lt;= criterion &lt;=3}))OR
(SIZEOF(sub_names)= 0))THEN RETURN (UNKNOWN);

ELSE
  CASE criterion OF
       0: RETURN (SIZEOF(sub_names * TYPEOF (the_type))&gt; 0);

       1: RETURN (SIZEOF(sub_names * TYPEOF (the_type))= 0);

       2: RETURN (SIZEOF(sub_names * TYPEOF (the_type))= 1);

       3: RETURN(SIZEOF(sub_names * TYPEOF(the_type))&lt;= 1);

  END_CASE;

END_IF;</algorithm>
      </function>
      <function name="used_variables">
         <parameter name="arg">
            <typename name="generic_expression"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="generic_variable"/>
         <algorithm>LOCAL

	result : SET OF generic_variable := [];

END_LOCAL
;


IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.GENERIC_VARIABLE' 
	IN TYPEOF (arg)
THEN 
	RETURN([arg]);

END_IF;


IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.UNARY_GENERIC_EXPRESSION' 
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\unary_generic_expression.operand));

END_IF;


IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.BINARY_GENERIC_EXPRESSION'
	IN TYPEOF (arg)
THEN 
	RETURN(used_variables(arg\binary_generic_expression.operands[1])
		+ used_variables(arg\binary_generic_expression.operands[2]));

END_IF;


IF
'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MULTIPLE_ARITY_GENERIC_EXPRESSION' 
	IN TYPEOF(arg)
THEN
	REPEAT i := 1 TO 
		SIZEOF(arg\multiple_arity_generic_expression.operands);

		result := result + used_variables(
			arg\multiple_arity_generic_expression.operands[i]);

	END_REPEAT;

	
	RETURN(result);

END_IF;

RETURN([ ]);</algorithm>
      </function>
      <function name="using_items">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <parameter name="checked_items">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="founded_item_select"/>
         <algorithm>LOCAL

    new_check_items    : SET  OF  founded_item_select;

    result_items       : SET  OF  founded_item_select;

    next_items         : SET  OF  founded_item_select;

  END_LOCAL
;

  result_items := [];

  new_check_items := checked_items + item;

  -- Find the SET  OF  representation_items OR  founded_items
  -- IN  which item is used directly.
  next_items := QUERY(z &lt;* bag_to_set(USEDIN(item, ''))|
   ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.REPRESENTATION_ITEM' IN  TYPEOF(z))OR
   ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.FOUNDED_ITEM'        IN  TYPEOF(z)));

  -- IF  the SET  OF  next_items is NOT empty;

  IF  SIZEOF(next_items)&gt; 0 THEN
    -- FOR  each element IN  the set, find the using_items recursively
    REPEAT i := 1 TO HIINDEX(next_items);

      -- Check FOR loop IN  data model, i.e.one OF  the next_items
      -- occurred earlier IN  the SET  OF  check_items;

      IF NOT(next_items[i] IN  new_check_items)THEN
        result_items := result_items + next_items[i] +
                        using_items(next_items[i],new_check_items);

      END_IF;

    END_REPEAT;

  END_IF;

  -- RETURN  the SET OF representation_items OR founded_items
  -- IN which the input item is used directly AND indirectly.
  RETURN(result_items);</algorithm>
      </function>
      <function name="using_representations">
         <parameter name="item">
            <typename name="founded_item_select"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="representation"/>
         <algorithm>LOCAL

    results            : SET  OF  representation;

    result_bag         : BAG OF  representation;

    intermediate_items : SET  OF  founded_item_select;

  END_LOCAL
;

  -- Find the representations IN  which the item is used AND  add TO  the
  -- results set.
  results := [];

  result_bag :=
USEDIN(item,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.REPRESENTATION.ITEMS');

  IF  SIZEOF(result_bag)&gt; 0 THEN
    REPEAT  i := 1 TO  HIINDEX(result_bag);

      results := results + result_bag[i];

    END_REPEAT;

  END_IF;

  -- Find all representation_items OR  founded_items
  -- BY which item is referenced directly OR  indirectly.
  intermediate_items := using_items(item,[]);

  -- IF  the SET  OF  intermediate items is NOT empty;

  IF  SIZEOF(intermediate_items)&gt; 0 THEN
    -- FOR each element IN  the set, add the
    -- representations OF  that element.
    REPEAT  i := 1 TO  HIINDEX(intermediate_items);

      result_bag := USEDIN(intermediate_items[i],
                    'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.REPRESENTATION.ITEMS');

      IF SIZEOF(result_bag)&gt; 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);

          results := results + result_bag[j];

        END_REPEAT;

      END_IF;

    END_REPEAT;

  END_IF;

  -- RETURN  the SET OF representation IN which the input item is
  -- used directly AND indirectly(through intervening
  -- representation_items OR founded items).
  RETURN(results);</algorithm>
      </function>
      <function name="valid_calendar_date">
         <parameter name="date">
            <typename name="calendar_date"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>CASE date.month_component OF
    1  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });

    2  : BEGIN
           IF(leap_year(date.year_component))THEN
             RETURN({ 1 &lt;= date.day_component &lt;= 29 });

           ELSE
             RETURN({ 1 &lt;= date.day_component &lt;= 28 });

           END_IF;

         END;

    3  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });

    4  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });

    5  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });

    6  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });

    7  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });

    8  : RETURN({ 1 &lt;= date.day_component &lt;= 31 });

    9  : RETURN({ 1 &lt;= date.day_component &lt;= 30 });

    10 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });

    11 : RETURN({ 1 &lt;= date.day_component &lt;= 30 });

    12 : RETURN({ 1 &lt;= date.day_component &lt;= 31 });

  END_CASE;

  RETURN(FALSE);</algorithm>
      </function>
      <function name="valid_datum_target_parameters">
         <parameter name="pdf">
            <typename name="placed_datum_target_feature"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL


rep_set : SET  OF  representation := [] ;


parameter_representations: SET OF representation;

END_LOCAL
;



REPEAT i := 1 TO HIINDEX(pdf.representation_associations);

rep_set := rep_set + pdf.representation_associations[i].used_representation;

END_REPEAT;

 
parameter_representations := QUERY(rep &lt;* rep_set |
('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SHAPE_REPRESENTATION_WITH_PARAMETERS' IN
TYPEOF(rep)));



IF(SIZEOF(QUERY(srwp &lt;* parameter_representations |
         (SIZEOF(QUERY(i &lt;* srwp.items |
         (i.name='orientation')AND
         ('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PLACEMENT' IN TYPEOF(i))))= 1)))&lt;&gt; 1)THEN
   RETURN(FALSE);

END_IF;


CASE pdf\shape_aspect.description OF
'point': RETURN(SIZEOF(QUERY(srwp &lt;* parameter_representations |
             (SIZEOF(srwp.items)= 1)))= 1);


'circle': RETURN((SIZEOF(QUERY(srwp &lt;* parameter_representations |
             (SIZEOF(srwp.items)= 2)))= 1)AND
            (SIZEOF(QUERY(srwp &lt;* parameter_representations |
             (SIZEOF(QUERY(i &lt;* srwp.items |
               (i.name='target diameter')AND
               (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		   'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
               )= 2)))= 1)))= 1));


'line': RETURN(SIZEOF(QUERY(srwp &lt;* parameter_representations |
             (SIZEOF(QUERY(i &lt;* srwp.items |
               (i.name='target length')AND
               (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
               )= 2)))= 1)))= 1);


'rectangle': RETURN((SIZEOF(QUERY(srwp &lt;* parameter_representations |
             (SIZEOF(srwp.items)= 3)))= 1)AND
            (SIZEOF(QUERY(srwp &lt;* parameter_representations |
             (SIZEOF(QUERY(i &lt;* srwp.items |
               (i.name='target length')AND
               (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM',
		'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
               )= 2)))= 1)))= 1)AND
             (SIZEOF(QUERY(srwp &lt;* parameter_representations |
              (SIZEOF(QUERY(i &lt;* srwp.items |
                (i.name='target width')AND
                (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM',
 		'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LENGTH_MEASURE_WITH_UNIT']*TYPEOF(i)
                )= 2)))= 1)))= 1));

OTHERWISE : RETURN(FALSE);

END_CASE;</algorithm>
      </function>
      <function name="valid_measure_value">
         <parameter name="m">
            <typename name="measure_value"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF('REAL' IN  TYPEOF (m))THEN
  RETURN (m &gt; 0.0);

  ELSE
    IF('INTEGER' IN TYPEOF(m))THEN
    RETURN (m &gt; 0);

    ELSE
      RETURN(TRUE);

    END_IF;

  END_IF;</algorithm>
      </function>
      <function name="valid_selected_instance_representation">
         <parameter name="pd">
            <typename name="product_definition_or_assembly_relationship"/>
         </parameter>
         <builtintype type="LOGICAL"/>
         <algorithm>LOCAL

  properties: SET  OF  property_definition :=[];

  property_definition_representations: SET OF property_definition_representation :=[];

  selected_representation: representation;

END_LOCAL
;


properties :=QUERY(prd&lt;* USEDIN(pd ,'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PROPERTY_DEFINITION.DEFINITION')| 
(prd.name = 'occurrence selection'));

IF(SIZEOF(properties)&lt;&gt;1)THEN
	RETURN(FALSE);

END_IF;


property_definition_representations := QUERY(pdr &lt;* USEDIN(properties[1], 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')| 
	(pdr.used_representation.name = 'selection criteria'));

IF(SIZEOF(property_definition_representations)&lt;&gt;1)THEN
	RETURN(FALSE);

END_IF;


selected_representation := property_definition_representations[1].used_representation;


IF(SIZEOF(selected_representation.items)&lt;1)OR (SIZEOF(selected_representation.items)&gt;2)THEN
	RETURN(FALSE);

END_IF;


IF(SIZEOF(QUERY(i &lt;* selected_representation.used_representation.items |
	(SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MEASURE_REPRESENTATION_ITEM' ,
			'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VALUE_RANGE']* TYPEOF(i))= 1)AND
 	(i.name = 'selection quantity')))&lt;&gt; 1)THEN
	RETURN(FALSE);

END_IF;


IF(SIZEOF(QUERY(i &lt;* selected_representation.used_representation.items |
	('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN  TYPEOF(i))AND
 	(i.name = 'selection control')))&gt; 1)THEN
	RETURN(FALSE);

END_IF;
 --the selection control is NOT specified THEN the quantity shall be a qualified_representation_item OR a value_range
IF(SIZEOF(QUERY(i &lt;* selected_representation.used_representation.items |
	('AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF(i))AND
 	(i.name = 'selection control')))= 0)AND  
  (SIZEOF(QUERY(i &lt;* selected_representation.used_representation.items |
    (i.name = 'selection quantity')AND  
    (SIZEOF(['AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.QUALIFIED_REPRESENTATION_ITEM' ,
		'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VALUE_RANGE']* TYPEOF(i))=0)))&gt; 0)THEN
	RETURN(FALSE);

END_IF;

	
RETURN(TRUE);</algorithm>
      </function>
      <function name="valid_time">
         <parameter name="time">
            <typename name="local_time"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF EXISTS(time.second_component)THEN
    RETURN (EXISTS(time.minute_component));

  ELSE
    RETURN(TRUE);

  END_IF;</algorithm>
      </function>
      <function name="valid_units">
         <parameter name="m">
            <typename name="measure_with_unit"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>IF 'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LENGTH_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.MASS_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.TIME_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.ELECTRIC_CURRENT_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE'
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.CELSIUS_TEMPERATURE_MEASURE'
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.LUMINOUS_INTENSITY_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.PLANE_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.SOLID_ANGLE_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.AREA_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VOLUME_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.RATIO_MEASURE' IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.POSITIVE_LENGTH_MEASURE' 
  IN  TYPEOF(m.value_component)THEN
    IF  derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' 
  IN TYPEOF(m.value_component)THEN
    IF derive_dimensional_exponents(m.unit_component)&lt;&gt;
       dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)THEN
      RETURN (FALSE);

    END_IF;

  END_IF;

  RETURN(TRUE);</algorithm>
      </function>
      <function name="value_range_wr1">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
IF(SIZEOF(agg)= 2)AND((SIZEOF(QUERY(i1 &lt;* agg |(
'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF
(i1))))= 2)OR
(SIZEOF(QUERY(i2 &lt;* agg |(
'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF
(i2))))= 2))THEN
RETURN(TRUE);

ELSE
RETURN(FALSE);

END_IF;

END;</algorithm>
      </function>
      <function name="value_range_wr2">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
IF(SIZEOF(QUERY(i &lt;* agg |(i.name = 'upper limit')))= 1)
AND(SIZEOF(QUERY(i &lt;* agg |(i.name = 'lower limit')))= 1)
THEN
RETURN(TRUE);

ELSE
RETURN(FALSE);

END_IF;

END;</algorithm>
      </function>
      <function name="value_range_wr3">
         <parameter name="agg">
            <typename name="compound_item_definition"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>BEGIN
IF(SIZEOF(QUERY(i1 &lt;* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN  TYPEOF (i1))AND
(SIZEOF(QUERY(i2 &lt;* agg |
('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i2))AND
(i1 :&lt;&gt;: i2)AND(i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component)))= 1)))= 2)
THEN
RETURN(TRUE);

ELSE
RETURN(FALSE);

END_IF;

END;</algorithm>
      </function>
      <function name="vector_difference">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL

     result          : vector;

     res, vec1, vec2 : direction;

     mag, mag1, mag2 : REAL;

     ndim            : INTEGER;

   END_LOCAL
;


   IF ((NOT EXISTS (arg1))OR (NOT EXISTS(arg2)))OR(arg1.dim &lt;&gt; arg2.dim)
       THEN
     RETURN (?);

    ELSE
     BEGIN
       IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN
         mag1 := arg1.magnitude;

         vec1 := arg1.orientation;

       ELSE
         mag1 := 1.0;

         vec1 := arg1;

       END_IF;

       IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN
         mag2 := arg2.magnitude;

         vec2 := arg2.orientation;

       ELSE
         mag2 := 1.0;

         vec2 := arg2;

       END_IF;

       vec1 := normalise(vec1);

       vec2 := normalise(vec2);

       ndim := SIZEOF(vec1.direction_ratios);

       mag := 0.0;

       res := dummy_gri || direction(vec1.direction_ratios);

       REPEAT i := 1 TO ndim;

         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                     mag2*vec2.direction_ratios[i];

         mag := mag +(res.direction_ratios[i]*res.direction_ratios[i]);

       END_REPEAT;

       IF(mag &gt; 0.0)THEN
       result := dummy_gri || vector(res, SQRT(mag));

       ELSE
         result := dummy_gri || vector(vec1,  0.0);

       END_IF;

     END;

   END_IF;

   RETURN(result);</algorithm>
      </function>
      <function name="vector_sum">
         <parameter name="arg1">
            <typename name="vector_or_direction"/>
         </parameter>
         <parameter name="arg2">
            <typename name="vector_or_direction"/>
         </parameter>
         <typename name="vector"/>
         <algorithm>LOCAL

     result          : vector;

     res, vec1, vec2 : direction;

     mag, mag1, mag2 : REAL;

     ndim            : INTEGER;

   END_LOCAL
;


   IF ((NOT EXISTS (arg1))OR (NOT EXISTS(arg2)))OR(arg1.dim &lt;&gt; arg2.dim)
       THEN
     RETURN (?);


   ELSE
     BEGIN
       IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN  TYPEOF(arg1)THEN
         mag1 := arg1.magnitude;

         vec1 := arg1.orientation;

       ELSE
         mag1 := 1.0;

         vec1 := arg1;

       END_IF;

       IF  'AP210_INTERCONNECT_TECHNOLOGY_CONSTRAINTS_MIM_LF.VECTOR' IN TYPEOF(arg2)THEN
         mag2 := arg2.magnitude;

         vec2 := arg2.orientation;

       ELSE
         mag2 := 1.0;

         vec2 := arg2;

       END_IF;

       vec1 := normalise(vec1);

       vec2 := normalise(vec2);

       ndim := SIZEOF(vec1.direction_ratios);

       mag := 0.0;

       res := dummy_gri || direction(vec1.direction_ratios);

       REPEAT i := 1 TO ndim;

         res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                      mag2*vec2.direction_ratios[i];

         mag := mag +(res.direction_ratios[i]*res.direction_ratios[i]);

       END_REPEAT;

       IF(mag &gt; 0.0)THEN
       result := dummy_gri || vector(res, SQRT(mag));

       ELSE
         result := dummy_gri || vector(vec1,  0.0);

       END_IF;

     END;

   END_IF;

   RETURN(result);</algorithm>
      </function>
      <function name="vertex_point_pcurves">
         <parameter name="a_vertex">
            <typename name="vertex_point"/>
         </parameter>
         <parameter name="the_degenerates">
            <aggregate type="SET" lower="0" upper="?"/>
            <typename name="evaluated_degenerate_pcurve"/>
         </parameter>
         <aggregate type="SET" lower="0" upper="?"/>
         <typename name="degenerate_pcurve"/>
         <algorithm>LOCAL

  a_point : point;

  result  : SET OF degenerate_pcurve;

END_LOCAL
;

  a_point := a_vertex.vertex_geometry;

  result := [];

  IF  'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point)THEN
    result := result + a_point;

  ELSE
      REPEAT j := 1 TO SIZEOF(the_degenerates);

         IF(the_degenerates[j].equivalent_point :=: a_point) THEN
            result := result + the_degenerates[j];

         END_IF;

      END_REPEAT;

  END_IF;


  RETURN(RESULT);</algorithm>
      </function>
      <function name="volume_weights_positive">
         <parameter name="b">
            <typename name="rational_b_spline_volume"/>
         </parameter>
         <builtintype type="BOOLEAN"/>
         <algorithm>LOCAL

       result   : BOOLEAN := TRUE;

     END_LOCAL
;


     REPEAT  i := 0 TO  b.u_upper;

       REPEAT  j := 0 TO  b.v_upper;

         REPEAT k := 0 TO b.w_upper;

           IF(b.weights[i][j][k] &lt;= 0.0) THEN
             result := FALSE;

             RETURN(result);

           END_IF;

         END_REPEAT;

       END_REPEAT;

     END_REPEAT;

     RETURN(result);</algorithm>
      </function>
   </schema>
</express>
