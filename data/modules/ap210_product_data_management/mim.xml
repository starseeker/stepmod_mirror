<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../xsl/express.xsl"?>
<!DOCTYPE express SYSTEM "../../../dtd/express.dtd">

<express language_version="2" rcs.date="2004-12-24T15:04:55" rcs.revision="1.0" description.file="mim_descriptions.xml">
   <application name="JSDAI" owner="LKSoft" url="www.lksoft.com" version="4.0 beta" source="ap210_product_data_management_mim schema_instance"/>
   <schema name="Ap210_product_data_management_mim">
      <interface kind="use" schema="Activity_mim"/>
      <interface kind="use" schema="Activity_method_mim"/>
      <interface kind="use" schema="Approval_mim"/>
      <interface kind="use" schema="Certification_mim"/>
      <interface kind="use" schema="Characteristic_mim"/>
      <interface kind="use" schema="Class_mim"/>
      <interface kind="use" schema="Classification_assignment_mim"/>
      <interface kind="use" schema="Configuration_effectivity_mim"/>
      <interface kind="use" schema="Configuration_item_mim"/>
      <interface kind="use" schema="Contextual_shape_positioning_mim"/>
      <interface kind="use" schema="Contract_mim"/>
      <interface kind="use" schema="Date_time_mim"/>
      <interface kind="use" schema="Date_time_assignment_mim"/>
      <interface kind="use" schema="Document_assignment_mim"/>
      <interface kind="use" schema="Document_management_mim"/>
      <interface kind="use" schema="Document_structure_mim"/>
      <interface kind="use" schema="Effectivity_application_mim"/>
      <interface kind="use" schema="Effectivity_mim"/>
      <interface kind="use" schema="Event_mim"/>
      <interface kind="use" schema="Event_assignment_mim"/>
      <interface kind="use" schema="External_class_mim"/>
      <interface kind="use" schema="External_item_identification_assignment_mim"/>
      <interface kind="use" schema="File_identification_mim"/>
      <interface kind="use" schema="Foundation_representation_mim"/>
      <interface kind="use" schema="Group_mim"/>
      <interface kind="use" schema="Identification_assignment_mim"/>
      <interface kind="use" schema="Incomplete_data_reference_mechanism_mim"/>
      <interface kind="use" schema="Independent_property_mim"/>
      <interface kind="use" schema="Independent_property_representation_mim"/>
      <interface kind="use" schema="Item_definition_structure_mim"/>
      <interface kind="use" schema="Management_resource_information_mim"/>
      <interface kind="use" schema="Measure_representation_mim"/>
      <interface kind="use" schema="Multi_linguism_mim"/>
      <interface kind="use" schema="Name_assignment_mim"/>
      <interface kind="use" schema="Part_definition_relationship_mim"/>
      <interface kind="use" schema="Generic_material_aspects_mim"/>
      <interface kind="use" schema="Person_organization_mim"/>
      <interface kind="use" schema="Person_organization_assignment_mim"/>
      <interface kind="use" schema="Physical_unit_design_view_mim"/>
      <interface kind="use" schema="Process_property_assignment_mim"/>
      <interface kind="use" schema="Product_categorization_mim"/>
      <interface kind="use" schema="Product_concept_identification_mim"/>
      <interface kind="use" schema="Product_identification_mim"/>
      <interface kind="use" schema="Product_identification_extension_mim"/>
      <interface kind="use" schema="Part_occurrence_mim"/>
      <interface kind="use" schema="Product_replacement_mim"/>
      <interface kind="use" schema="Product_structure_mim"/>
      <interface kind="use" schema="Product_version_mim"/>
      <interface kind="use" schema="Product_version_relationship_mim"/>
      <interface kind="use" schema="Product_view_definition_mim"/>
      <interface kind="use" schema="Product_view_definition_properties_mim"/>
      <interface kind="use" schema="Project_mim"/>
      <interface kind="use" schema="Property_assignment_mim"/>
      <interface kind="use" schema="Requirement_assignment_mim"/>
      <interface kind="use" schema="Requirement_view_definition_mim"/>
      <interface kind="use" schema="Requirement_view_definition_relationship_mim"/>
      <interface kind="use" schema="Security_classification_mim"/>
      <interface kind="use" schema="Single_part_representation_mim"/>
      <interface kind="use" schema="Work_order_mim"/>
      <interface kind="use" schema="Work_request_mim"/>
      <interface kind="use" schema="contract_schema"/>
      <interface kind="use" schema="product_definition_schema"/>
      <type name="pdm_action_items">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_action_items" selectitems="product_definition_formation"/>
      </type>
      <type name="pdm_approval_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_approval_item" selectitems="action action_directive certification configuration_effectivity configuration_item contract date directed_action document general_property_relationship product product_definition product_definition_relationship product_definition_formation representation security_classification shape_aspect_relationship versioned_action_request"/>
      </type>
      <type name="pdm_certification_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_certification_item" selectitems="supplied_part_relationship make_from_usage_option"/>
      </type>
      <type name="pdm_classification_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_classification_item" selectitems="material_designation"/>
      </type>
      <type name="pdm_contract_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_contract_item" selectitems="alternate_product_relationship directed_action product product_definition_formation"/>
      </type>
      <type name="pdm_date_and_time_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_date_and_time_item" selectitems="approval_person_organization certification contract directed_action document product_definition security_classification versioned_action_request"/>
      </type>
      <type name="pdm_date_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_date_item" selectitems="product_definition versioned_action_request directed_action approval_person_organization contract document security_classification certification"/>
      </type>
      <type name="pdm_document_reference_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_document_reference_item" selectitems="action_method assembly_component_usage characterized_object coordinated_representation_item configuration_item descriptive_representation_item externally_defined_item material_designation measure_representation_item product product_definition product_definition_formation product_definition_formation_relationship property_definition representation representation_item shape_aspect"/>
      </type>
      <type name="pdm_groupable_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_groupable_item" selectitems="product_definition product_definition_formation property_definition_representation representation_item shape_aspect"/>
      </type>
      <type name="pdm_identification_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_identification_item" selectitems="characterized_class configuration_item material_designation person_and_organization product product_concept product_definition_formation organization"/>
      </type>
      <type name="pdm_organization_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_organization_item" selectitems="applied_identification_assignment configuration_item contract directed_action document versioned_action_request product product_definition product_definition_formation representation security_classification"/>
      </type>
      <type name="pdm_person_and_organization_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_person_and_organization_item" selectitems="configuration_item contract document product product_definition_formation product_definition directed_action security_classification versioned_action_request"/>
      </type>
      <type name="pdm_request_item">
         <select selectitems="product_definition_formation representation_relationship"/>
      </type>
      <type name="pdm_requirement_assigned_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_requirement_assigned_item" selectitems="descriptive_representation_item configuration_item product_definition product_definition_formation product shape_aspect representation"/>
      </type>
      <type name="pdm_security_classification_item">
         <select extensible="YES" genericentity="YES" basedon="_SELECT_security_classification_item" selectitems="applied_promissory_usage_in_product_model_assignment assembly_component_usage document make_from_usage_option product_definition_formation product_definition"/>
      </type>
      <type name="promissory_usage_in_product_model_assigned_item">
         <select selectitems="product_concept product_definition"/>
      </type>
      <type name="start_request_item">
         <select selectitems="product_definition_formation representation_relationship"/>
      </type>
      <type name="work_item">
         <select selectitems="product_definition_formation"/>
      </type>
      <entity name="applied_promissory_usage_in_product_model_assignment" supertypes="group_assignment">
         <explicit name="items">
            <aggregate type="SET" lower="1" upper="?"/>
            <typename name="promissory_usage_in_product_model_assigned_item"/>
         </explicit>
         <where label="WR1" expression=" SIZEOF ( QUERY ( pm &lt;* items | 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_CONCEPT' IN TYPEOF ( pm ) ) ) = 1 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( pd &lt;* items | 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION' IN TYPEOF ( pd ) ) ) = 1 "/>
         <where label="WR3" expression=" SIZEOF ( items ) = 2 "/>
         <where label="WR4" expression=" 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROMISSORY_USAGE_IN_PRODUCT_MODEL' IN TYPEOF ( SELF \ group_assignment . assigned_group ) "/>
         <where label="WR5" expression=" SIZEOF ( USEDIN ( SELF , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS' ) ) &lt;= 1 "/>
      </entity>
      <entity name="promissory_usage_in_product_model" supertypes="group">
         <where label="WR1" expression=" SIZEOF ( QUERY ( aga &lt;* USEDIN ( SELF , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) | 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PROMISSORY_USAGE_IN_PRODUCT_MODEL_ASSIGNMENT' IN TYPEOF ( aga ) ) ) &gt;= 1 "/>
      </entity>
      <entity name="supplied_part_relationship" supertypes="product_definition_relationship">
         <where label="WR1" expression=" 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION_WITH_SPECIFIED_SOURCE' IN TYPEOF ( SELF . related_product_definition . formation ) "/>
         <where label="WR2" expression=" NOT ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION' IN ROLESOF ( SELF ) ) "/>
      </entity>
      <rule name="approval_requires_approval_date_time" appliesto="approval approval_date_time">
         <where label="WR1" expression=" SIZEOF ( QUERY ( app &lt;* approval | NOT ( SIZEOF ( QUERY ( adt &lt;* approval_date_time | app :=: adt . dated_approval ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="approval_requires_approval_person_organization" appliesto="approval approval_person_organization">
         <where label="WR1" expression=" SIZEOF ( QUERY ( app &lt;* approval | NOT ( SIZEOF ( QUERY ( apo &lt;* approval_person_organization | app :=: apo . authorized_approval ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="approval_role_constraint" appliesto="approval_role">
         <where label="WR1" expression=" SIZEOF ( QUERY ( apr &lt;* approval_role | NOT ( apr \ approval_role . role = 'authorizer' ) ) ) = 0 "/>
      </rule>
      <rule name="approvals_are_assigned" appliesto="approval approval_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( app &lt;* approval | NOT ( SIZEOF ( QUERY ( aa &lt;* approval_assignment | app :=: aa . assigned_approval ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="assembly_composition_relationship_unique_constraint" appliesto="assembly_component_usage">
         <algorithm> LOCAL acr : BAG OF assembly_component_usage := QUERY ( acu &lt;* assembly_component_usage | ( acu \ product_definition_relationship . name = 'assembly composition' ) ) ; pu_bag : BAG OF physical_unit := [ ] ; acu_bag : BAG OF assembly_component_usage ; pass : BOOLEAN := TRUE ; cd_bag : BAG OF component_definition ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( acr ) by 1 ; IF EXISTS ( acr [ i ] . relating_product_definition ) THEN IF ( ( acr [ i ] . relating_product_definition . frame_of_reference . name = 'physical design' ) AND ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF ( acr [ i ] . relating_product_definition ) ) ) THEN IF ( NOT ( acr [ i ] . relating_product_definition IN pu_bag ) ) THEN pu_bag := pu_bag + acr [ i ] . relating_product_definition ; END_IF ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( pu_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; cd_bag := [ ] ; acu_bag := QUERY ( acu &lt;* acr | ( acu . relating_product_definition :=: pu_bag [ i ] ) ) ; REPEAT j := 1 to SIZEOF ( acu_bag ) by 1 ; IF EXISTS ( acu_bag [ j ] . related_product_definition ) THEN IF ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_DEFINITION' IN TYPEOF ( acu_bag [ j ] . related_product_definition ) ) THEN IF ( acu_bag [ j ] . related_product_definition IN cd_bag ) THEN pass := FALSE ; ESCAPE ; ELSE cd_bag := cd_bag + acu_bag [ j ] . related_product_definition ; END_IF ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="certification_requires_date_or_date_and_time" appliesto="certification applied_date_and_time_assignment applied_date_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( cert &lt;* certification | NOT ( ( SIZEOF ( QUERY ( adata &lt;* applied_date_and_time_assignment | cert IN adata . items ) ) = 1 ) OR ( SIZEOF ( QUERY ( ada &lt;* applied_date_assignment | cert IN ada . items ) ) = 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="certification_unique_constraint" appliesto="certification">
         <algorithm> LOCAL r : BAG OF certification := QUERY ( r &lt;* certification | TRUE ) ; pass : BOOLEAN := TRUE ; name_bag : BAG OF string := [ ] ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( r ) by 1 ; IF EXISTS ( r [ i ] \ certification . name ) THEN IF ( r [ i ] \ certification . name IN name_bag ) THEN pass := FALSE ; ESCAPE ; ELSE name_bag := name_bag + r [ i ] \ certification . name ; END_IF ; END_IF ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="configuration_item_requires_person_organization" appliesto="configuration_item applied_person_and_organization_assignment applied_organization_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ci &lt;* configuration_item | NOT ( ( SIZEOF ( QUERY ( apaoa &lt;* applied_person_and_organization_assignment | ci IN apaoa . items ) ) = 1 ) OR ( SIZEOF ( QUERY ( aoa &lt;* applied_organization_assignment | ci IN aoa . items ) ) = 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="contract_unique_constraint" appliesto="contract">
         <algorithm> LOCAL r : BAG OF contract := QUERY ( r &lt;* contract | TRUE ) ; pass : BOOLEAN := TRUE ; name_bag : BAG OF string := [ ] ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( r ) by 1 ; IF EXISTS ( r [ i ] \ contract . name ) THEN IF ( r [ i ] \ contract . name IN name_bag ) THEN pass := FALSE ; ESCAPE ; ELSE name_bag := name_bag + r [ i ] \ contract . name ; END_IF ; END_IF ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="date_and_time_require_minute_and_second" appliesto="date_and_time">
         <where label="WR1" expression=" SIZEOF ( QUERY ( dat &lt;* date_and_time | NOT ( Exists ( dat . time_component . minute_component ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( dat &lt;* date_and_time | NOT ( Exists ( dat . time_component . second_component ) ) ) ) = 0 "/>
      </rule>
      <rule name="date_constraint" appliesto="date">
         <where label="WR1" expression=" SIZEOF ( QUERY ( d &lt;* date | d . year_component &lt; 1856 ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_action_directive" appliesto="action_directive">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ad &lt;* action_directive | NOT ( SIZEOF ( USEDIN ( ad , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_approval_status" appliesto="approval_status">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ast &lt;* approval_status | NOT ( SIZEOF ( USEDIN ( ast , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_certification_type" appliesto="certification_type">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ct &lt;* certification_type | NOT ( SIZEOF ( USEDIN ( ct , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_contract_type" appliesto="contract_type">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ct &lt;* contract_type | NOT ( SIZEOF ( USEDIN ( ct , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_date" appliesto="date">
         <where label="WR1" expression=" SIZEOF ( QUERY ( dt &lt;* date | NOT ( SIZEOF ( USEDIN ( dt , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_date_role" appliesto="date_role">
         <where label="WR1" expression=" SIZEOF ( QUERY ( dr &lt;* date_role | NOT ( SIZEOF ( USEDIN ( dr , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_date_time_role" appliesto="date_time_role">
         <where label="WR1" expression=" SIZEOF ( QUERY ( dtr &lt;* date_time_role | NOT ( SIZEOF ( USEDIN ( dtr , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_document_type" appliesto="document_type">
         <where label="WR1" expression=" SIZEOF ( QUERY ( dt &lt;* document_type | NOT ( SIZEOF ( USEDIN ( dt , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_named_unit" appliesto="named_unit">
         <where label="WR1" expression=" SIZEOF ( QUERY ( nu &lt;* named_unit | NOT ( SIZEOF ( USEDIN ( nu , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_organization_role" appliesto="organization_role">
         <where label="WR1" expression=" SIZEOF ( QUERY ( org &lt;* organization_role | NOT ( SIZEOF ( USEDIN ( org , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_parametric_representation_context" appliesto="parametric_representation_context">
         <where label="WR1" expression=" SIZEOF ( QUERY ( prc &lt;* parametric_representation_context | NOT ( SIZEOF ( USEDIN ( prc , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_person_and_organization_role" appliesto="person_and_organization_role">
         <where label="WR1" expression=" SIZEOF ( QUERY ( poar &lt;* person_and_organization_role | NOT ( SIZEOF ( USEDIN ( poar , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_representation_item" appliesto="representation_item">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ri &lt;* representation_item | NOT ( SIZEOF ( USEDIN ( ri , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_security_classification_level" appliesto="security_classification_level">
         <where label="WR1" expression=" SIZEOF ( QUERY ( scl &lt;* security_classification_level | NOT ( SIZEOF ( USEDIN ( scl , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="dependent_instantiable_shape_representation" appliesto="shape_representation">
         <where label="WR1" expression=" SIZEOF ( QUERY ( sr &lt;* shape_representation | NOT ( SIZEOF ( USEDIN ( sr , '' ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="directed_action_requires_approval" appliesto="directed_action applied_approval_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( da &lt;* directed_action | NOT ( SIZEOF ( QUERY ( aaa &lt;* applied_approval_assignment | da IN aaa . items ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="directed_action_requires_date_or_date_and_time" appliesto="directed_action applied_date_and_time_assignment applied_date_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( da &lt;* directed_action | NOT ( ( SIZEOF ( QUERY ( adata &lt;* applied_date_and_time_assignment | ( da IN adata . items ) AND ( adata . role \ date_time_role . name = 'start date' ) ) ) = 1 ) OR ( SIZEOF ( QUERY ( ada &lt;* applied_date_assignment | ( da IN ada . items ) AND ( ada . role \ date_role . name = 'start date' ) ) ) = 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="ee_document_constraint" appliesto="document">
         <where label="WR1" expression=" SIZEOF ( QUERY ( doc &lt;* document | ( SIZEOF ( QUERY ( adata &lt;* USEDIN ( doc , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' ) | ( adata . role \ date_time_role . name = 'creation date' ) ) ) = 0 ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( doc &lt;* document | NOT ( ( SIZEOF ( QUERY ( aoa &lt;* USEDIN ( doc , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( aoa . role \ organization_role . name = 'publisher' ) ) ) = 1 ) OR ( SIZEOF ( QUERY ( apaoa &lt;* USEDIN ( doc , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( apaoa . role \ person_and_organization_role . name = 'publisher' ) ) ) = 1 ) ) ) ) = 0 "/>
         <where label="WR3" expression=" SIZEOF ( QUERY ( doc &lt;* document | NOT ( SIZEOF ( USEDIN ( doc , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT_IDENTIFIER_ASSIGNMENT.ITEMS' ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="ee_document_unique_constraint" appliesto="document document_identifier_assignment">
         <algorithm> LOCAL pass : BOOLEAN := TRUE ; rev_exists_bag : BAG OF document := [ ] ; dia_bag : BAG OF document_identifier_assignment := [ ] ; desc_bag : BAG OF STRING := [ ] ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( document ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; IF NOT ( EXISTS ( document [ i ] . description ) ) THEN pass := FALSE ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( document_identifier_assignment ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; desc_bag := [ ] ; REPEAT j := 1 to SIZEOF ( document_identifier_assignment [ i ] . items ) by 1 ; desc_bag := desc_bag + document_identifier_assignment [ i ] . items [ j ] \ document . description ; END_REPEAT ; IF NOT ( value_unique ( desc_bag ) ) THEN pass := FALSE ; END_IF ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="ee_material_unique_constraint" appliesto="material_designation">
         <algorithm> LOCAL name_bag : BAG OF STRING := [ ] ; md_bag : BAG OF material_designation ; adr_bag : BAG OF applied_document_reference ; pass : BOOLEAN := TRUE ; doc_bag : BAG OF ee_specification ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( material_designation ) by 1 ; IF EXISTS ( material_designation [ i ] . name ) THEN IF ( NOT ( material_designation [ i ] . name IN name_bag ) ) THEN name_bag := name_bag + material_designation [ i ] . name ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( name_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; md_bag := QUERY ( md &lt;* material_designation | ( md \ material_designation . name = name_bag [ i ] ) ) ; doc_bag := [ ] ; REPEAT j := 1 to SIZEOF ( md_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; adr_bag := QUERY ( adr &lt;* USEDIN ( md_bag [ j ] , ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) ) | ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'DOCUMENT' ) IN TYPEOF ( adr . assigned_document ) ) ) ; REPEAT k := 1 to SIZEOF ( adr_bag ) by 1 ; IF EXISTS ( adr_bag [ k ] . assigned_document ) THEN IF ( adr_bag [ k ] . assigned_document IN doc_bag ) THEN pass := FALSE ; ESCAPE ; ELSE doc_bag := doc_bag + adr_bag [ k ] . assigned_document ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="ee_product_configuration_unique_constraint" appliesto="configuration_item">
         <algorithm> LOCAL id_bag : BAG OF STRING := [ ] ; ci_bag : BAG OF configuration_item ; cd_bag : BAG OF configuration_design ; pass : BOOLEAN := TRUE ; pdf_bag : BAG OF product_definition_formation ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( configuration_item ) by 1 ; IF EXISTS ( configuration_item [ i ] . id ) THEN IF ( NOT ( configuration_item [ i ] . id IN id_bag ) ) THEN id_bag := id_bag + configuration_item [ i ] . id ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( id_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; pdf_bag := [ ] ; ci_bag := QUERY ( ci &lt;* configuration_item | ( ci . id = id_bag [ i ] ) ) ; REPEAT j := 1 to SIZEOF ( ci_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; cd_bag := USEDIN ( ci_bag [ j ] , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CONFIGURATION_DESIGN.CONFIGURATION' ) ; REPEAT k := 1 to SIZEOF ( cd_bag ) by 1 ; IF EXISTS ( cd_bag [ k ] . design ) THEN IF ( cd_bag [ k ] . design IN pdf_bag ) THEN pass := FALSE ; ESCAPE ; ELSE pdf_bag := pdf_bag + cd_bag [ k ] . design ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="ee_product_constraint" appliesto="product">
         <where label="WR1" expression=" SIZEOF ( QUERY ( prod &lt;* product | NOT ( ( SIZEOF ( QUERY ( aoa &lt;* USEDIN ( prod , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( aoa . role \ organization_role . name = 'design owner' ) ) ) = 1 ) OR ( SIZEOF ( QUERY ( apaoa &lt;* USEDIN ( prod , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( apaoa . role \ person_and_organization_role . name = 'design owner' ) ) ) = 1 ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( p &lt;* product | SIZEOF ( USEDIN ( p , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_FORMATION.OF_PRODUCT' ) ) = 0 ) ) = 0 "/>
      </rule>
      <rule name="ee_product_definition_constraint" appliesto="product_definition_with_associated_documents">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdwad &lt;* product_definition_with_associated_documents | NOT ( ( SIZEOF ( QUERY ( adata &lt;* USEDIN ( pdwad , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DATE_AND_TIME_ASSIGNMENT.ITEMS' ) | ( adata . role \ date_time_role . name = 'creation date' ) ) ) = 1 ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( pdwad &lt;* product_definition_with_associated_documents | NOT ( ( SIZEOF ( QUERY ( aoa &lt;* USEDIN ( pdwad , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( aoa . role \ organization_role . name = 'creator' ) ) ) = 1 ) OR ( SIZEOF ( QUERY ( apaoa &lt;* USEDIN ( pdwad , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( apaoa . role \ person_and_organization_role . name = 'creator' ) ) ) = 1 ) ) ) ) = 0 "/>
         <where label="WR3" expression=" SIZEOF ( QUERY ( pdwad &lt;* product_definition_with_associated_documents | NOT ( ( SIZEOF ( USEDIN ( pdwad , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS' ) ) = 1 ) ) ) ) = 0 "/>
         <where label="WR4" expression=" SIZEOF ( QUERY ( pdwad &lt;* product_definition_with_associated_documents | NOT ( ( SIZEOF ( USEDIN ( pdwad , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_SECURITY_CLASSIFICATION_ASSIGNMENT.ITEMS' ) ) = 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="ee_product_model_unique_constraint" appliesto="product_concept">
         <algorithm> LOCAL r : BAG OF product_concept := QUERY ( r &lt;* product_concept | TRUE ) ; pass : BOOLEAN := TRUE ; id_bag : BAG OF string := [ ] ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( r ) by 1 ; IF EXISTS ( r [ i ] . id ) THEN IF ( r [ i ] \ product_concept . id IN id_bag ) THEN pass := FALSE ; ESCAPE ; ELSE id_bag := id_bag + r [ i ] . id ; END_IF ; END_IF ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="ee_product_unique_constraint" appliesto="product">
         <algorithm> LOCAL id_bag : BAG OF STRING := [ ] ; p_bag : BAG OF product ; aoa_bag : BAG OF applied_organization_assignment ; apaoa_bag : BAG OF applied_person_and_organization_assignment ; pass : BOOLEAN := TRUE ; o_bag : BAG OF organization ; pao_bag : BAG OF person_and_organization ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( product ) by 1 ; IF EXISTS ( product [ i ] . id ) THEN IF ( NOT ( product [ i ] . id IN id_bag ) ) THEN id_bag := id_bag + product [ i ] . id ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( id_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; o_bag := [ ] ; pao_bag := [ ] ; p_bag := QUERY ( p &lt;* product | ( p . id = id_bag [ i ] ) ) ; REPEAT j := 1 to SIZEOF ( p_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; aoa_bag := QUERY ( aoa &lt;* USEDIN ( p_bag [ j ] , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ORGANIZATION' IN TYPEOF ( aoa . assigned_organization ) ) AND ( aoa . role \ organization_role . name = 'design owner' ) ) ) ; REPEAT k := 1 to SIZEOF ( aoa_bag ) by 1 ; IF EXISTS ( aoa_bag [ k ] . assigned_organization ) THEN IF ( aoa_bag [ k ] . assigned_organization IN o_bag ) THEN pass := FALSE ; ESCAPE ; ELSE o_bag := o_bag + aoa_bag [ k ] . assigned_organization ; END_IF ; END_IF ; END_REPEAT ; apaoa_bag := QUERY ( apaoa &lt;* USEDIN ( p_bag [ j ] , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_PERSON_AND_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERSON_AND_ORGANIZATION' IN TYPEOF ( apaoa . assigned_person_and_organization ) ) AND ( apaoa . role \ person_and_organization_role . name = 'design owner' ) ) ) ; REPEAT k := 1 to SIZEOF ( apaoa_bag ) by 1 ; IF EXISTS ( apaoa_bag [ k ] . assigned_person_and_organization ) THEN IF ( apaoa_bag [ k ] . assigned_person_and_organization IN pao_bag ) THEN pass := FALSE ; ESCAPE ; ELSE pao_bag := pao_bag + apaoa_bag [ k ] . assigned_person_and_organization ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="ee_product_version_supersedence_constraint" appliesto="product_definition_formation_relationship">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdfr &lt;* product_definition_formation_relationship | ( ( pdfr \ product_definition_formation_relationship . name = 'product version supersedence' ) AND ( NOT ( pdfr . relating_product_definition_formation . of_product :=: pdfr . related_product_definition_formation . of_product ) ) ) ) ) = 0 "/>
      </rule>
      <rule name="next_higher_assembly_relationship_constraint" appliesto="next_assembly_usage_occurrence">
         <where label="WR1" expression=" SIZEOF ( QUERY ( nauo &lt;* next_assembly_usage_occurrence | NOT ( SIZEOF ( QUERY ( pd &lt;* USEDIN ( nauo , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION.DEFINITION' ) | ( ( SIZEOF ( QUERY ( pdr &lt;* USEDIN ( pd , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION' IN TYPEOF ( pdr . used_representation ) ) AND ( pdr . used_representation . context_of_items \ geometric_representation_context . coordinate_space_dimension = 3 ) ) ) &lt;= 1 ) AND ( SIZEOF ( QUERY ( pdr &lt;* USEDIN ( pd , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION' ) | ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'COMPONENT_LOCATION' IN TYPEOF ( pdr . used_representation ) ) AND ( pdr . used_representation . context_of_items \ geometric_representation_context . coordinate_space_dimension = 2 ) ) ) &lt;= 1 ) ) ) ) &lt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="next_higher_assembly_relationship_unique_constraint" appliesto="next_assembly_usage_occurrence">
         <algorithm> LOCAL pu_bag : BAG OF physical_unit := [ ] ; nauo_bag : BAG OF next_assembly_usage_occurrence ; pass : BOOLEAN := TRUE ; refdes_bag : BAG OF STRING ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( next_assembly_usage_occurrence ) by 1 ; IF EXISTS ( next_assembly_usage_occurrence [ i ] . relating_product_definition ) THEN IF ( ( next_assembly_usage_occurrence [ i ] . relating_product_definition . frame_of_reference . name = 'physical design' ) AND ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PHYSICAL_UNIT' IN TYPEOF ( next_assembly_usage_occurrence [ i ] . relating_product_definition ) ) ) THEN IF ( NOT ( next_assembly_usage_occurrence [ i ] . relating_product_definition IN pu_bag ) ) THEN pu_bag := pu_bag + next_assembly_usage_occurrence [ i ] . relating_product_definition ; END_IF ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( pu_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; refdes_bag := [ ] ; nauo_bag := QUERY ( nauo &lt;* next_assembly_usage_occurrence | ( nauo . relating_product_definition :=: pu_bag [ i ] ) ) ; REPEAT j := 1 to SIZEOF ( nauo_bag ) by 1 ; IF EXISTS ( nauo_bag [ j ] . reference_designator ) THEN IF ( nauo_bag [ j ] . reference_designator IN refdes_bag ) THEN pass := FALSE ; ESCAPE ; ELSE refdes_bag := refdes_bag + nauo_bag [ j ] . reference_designator ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="organization_unique_constraint" appliesto="organization">
         <algorithm> LOCAL r : BAG OF organization := QUERY ( r &lt;* organization | TRUE ) ; pass : BOOLEAN := TRUE ; id_bag : BAG OF string := [ ] ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( r ) by 1 ; IF EXISTS ( r [ i ] . id ) THEN IF ( r [ i ] \ organization . id IN id_bag ) THEN pass := FALSE ; ESCAPE ; ELSE id_bag := id_bag + r [ i ] . id ; END_IF ; END_IF ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="planned_effectivity_constraint" appliesto="configuration_effectivity">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ce &lt;* configuration_effectivity | NOT ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF ( ce . usage ) ) AND ( ce . usage \ product_definition_relationship . name = 'assembly composition' ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( ce &lt;* configuration_effectivity | SIZEOF ( USEDIN ( ce , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_APPROVAL_ASSIGNMENT.ITEMS' ) ) = 0 ) ) = 0 "/>
      </rule>
      <rule name="planned_effectivity_unique_constraint" appliesto="configuration_effectivity">
         <algorithm> LOCAL ce_bag : BAG OF configuration_effectivity ; ci_bag : BAG OF configuration_item := [ ] ; pass : BOOLEAN := TRUE ; acu_bag : BAG OF assembly_component_usage ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( configuration_effectivity ) by 1 ; IF EXISTS ( configuration_effectivity [ i ] . configuration . configuration ) THEN IF ( NOT ( configuration_effectivity [ i ] . configuration . configuration IN ci_bag ) ) THEN ci_bag := ci_bag + configuration_effectivity [ i ] . configuration . configuration ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( ci_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; ce_bag := QUERY ( r &lt;* configuration_effectivity | ( ( r . configuration . configuration :=: ci_bag [ i ] ) AND ( r . usage \ product_definition_relationship . name = 'assembly composition' ) AND ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' IN TYPEOF ( r . usage ) ) ) ) ; acu_bag := [ ] ; REPEAT j := 1 to SIZEOF ( ce_bag ) by 1 ; IF EXISTS ( ce_bag [ j ] . usage ) THEN IF ( ce_bag [ j ] . usage IN acu_bag ) THEN pass := FALSE ; ESCAPE ; ELSE acu_bag := acu_bag + ce_bag [ j ] . usage ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="product_association_constraint" appliesto="product_definition_formation_relationship">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdfr &lt;* product_definition_formation_relationship | ( pdfr \ product_definition_formation_relationship . name = 'product association' ) AND ( SIZEOF ( QUERY ( adr &lt;* USEDIN ( pdfr , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) | ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' IN TYPEOF ( adr . assigned_document ) ) ) ) = 0 ) ) ) = 0 "/>
      </rule>
      <rule name="product_association_unique_constraint" appliesto="product_definition_formation_relationship">
         <algorithm> LOCAL pdfr : BAG OF product_definition_formation_relationship := QUERY ( r &lt;* product_definition_formation_relationship | ( r \ product_definition_formation_relationship . name = 'product association' ) ) ; pdf_bag : BAG OF product_definition_formation := [ ] ; pdfr_bag : BAG OF product_definition_formation_relationship ; pass : BOOLEAN := TRUE ; adr_bag : BAG OF applied_document_reference ; es_bag : BAG OF ee_specification ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( pdfr ) by 1 ; IF EXISTS ( pdfr [ i ] . relating_product_definition_formation ) THEN IF ( NOT ( pdfr [ i ] . relating_product_definition_formation IN pdf_bag ) ) THEN pdf_bag := pdf_bag + pdfr [ i ] . relating_product_definition_formation ; END_IF ; END_IF ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( pdf_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; pdfr_bag := QUERY ( r &lt;* pdfr | ( r . relating_product_definition_formation :=: pdf_bag [ i ] ) ) ; es_bag := [ ] ; REPEAT j := 1 to SIZEOF ( pdfr_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; adr_bag := QUERY ( adr &lt;* USEDIN ( pdfr_bag [ j ] , ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_DOCUMENT_REFERENCE.ITEMS' ) ) | ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'EE_SPECIFICATION' ) IN TYPEOF ( adr . assigned_document ) ) ) ; REPEAT k := 1 to SIZEOF ( adr_bag ) by 1 ; IF EXISTS ( adr_bag [ k ] . assigned_document ) THEN IF ( adr_bag [ k ] . assigned_document IN es_bag ) THEN pass := FALSE ; ESCAPE ; ELSE es_bag := es_bag + adr_bag [ k ] . assigned_document ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="product_concept_requires_configuration_item" appliesto="product_concept configuration_item">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pc &lt;* product_concept | NOT ( SIZEOF ( QUERY ( ci &lt;* configuration_item | pc :=: ci . item_concept ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="product_definition_formation_requires_approval" appliesto="product_definition applied_approval_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pd &lt;* product_definition | ( NOT ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF ( pd ) ) ) AND ( NOT ( SIZEOF ( QUERY ( aaa &lt;* applied_approval_assignment | pd . formation IN aaa . items ) ) = 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="product_definition_formation_requires_person_organization" appliesto="product_definition applied_person_and_organization_assignment applied_organization_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pd &lt;* product_definition | ( NOT ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_GROUP_COMPONENT_DEFINITION' IN TYPEOF ( pd ) ) ) AND ( NOT ( ( SIZEOF ( QUERY ( apaoa &lt;* applied_person_and_organization_assignment | ( pd . formation IN apaoa . items ) AND ( apaoa . role \ person_and_organization_role . name = 'creator' ) ) ) = 1 ) OR ( SIZEOF ( QUERY ( aoa &lt;* applied_organization_assignment | ( pd . formation IN aoa . items ) AND ( aoa . role \ organization_role . name = 'creator' ) ) ) = 1 ) ) ) ) ) = 0 "/>
      </rule>
      <rule name="product_definition_requires_date_or_date_and_time" appliesto="product_definition applied_date_and_time_assignment applied_date_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pd &lt;* product_definition | NOT ( NOT ( is_ee_product_definition ( pd ) ) OR ( ( SIZEOF ( QUERY ( adata &lt;* applied_date_and_time_assignment | pd IN adata . items ) ) = 1 ) OR ( SIZEOF ( QUERY ( ada &lt;* applied_date_assignment | pd IN ada . items ) ) = 1 ) ) ) ) ) = 0 "/>
      </rule>
      <rule name="product_definition_requires_person_organization" appliesto="product_definition applied_person_and_organization_assignment applied_organization_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pd &lt;* product_definition | NOT ( NOT ( is_ee_product_definition ( pd ) ) OR ( ( SIZEOF ( QUERY ( apaoa &lt;* applied_person_and_organization_assignment | pd IN apaoa . items ) ) = 1 ) OR ( SIZEOF ( QUERY ( aoa &lt;* applied_organization_assignment | pd IN aoa . items ) ) = 1 ) ) ) ) ) = 0 "/>
      </rule>
      <rule name="product_requires_person_organization" appliesto="product applied_person_and_organization_assignment applied_organization_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( prod &lt;* product | NOT ( ( SIZEOF ( QUERY ( apaoa &lt;* applied_person_and_organization_assignment | prod IN apaoa . items ) ) = 1 ) OR ( SIZEOF ( QUERY ( aoa &lt;* applied_organization_assignment | prod IN aoa . items ) ) = 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="product_requires_product_definition_formation" appliesto="product product_definition_formation">
         <where label="WR1" expression=" SIZEOF ( QUERY ( prod &lt;* product | NOT ( SIZEOF ( QUERY ( pdf &lt;* product_definition_formation | prod :=: pdf . of_product ) ) &gt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="restrict_action_request_status" appliesto="action_request_status">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ars &lt;* action_request_status | NOT ( ars \ action_request_status . status IN [ 'proposed' , 'in work' , 'issued' , 'hold' ] ) ) ) = 0 "/>
      </rule>
      <rule name="restrict_approval_status" appliesto="approval_status">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ast &lt;* approval_status | NOT ( ast \ approval_status . name IN [ 'approved' , 'not yet approved' , 'disapproved' , 'withdrawn' ] ) ) ) = 0 "/>
      </rule>
      <rule name="restrict_date_role" appliesto="date_role">
         <where label="WR1" expression=" SIZEOF ( QUERY ( dr &lt;* date_role | NOT ( dr \ date_role . name IN [ 'creation date' , 'request date' , 'release date' , 'start date' , 'contract date' , 'certification date' , 'sign off date' , 'classification date' , 'declassification date' ] ) ) ) = 0 "/>
      </rule>
      <rule name="security_classification_constraint" appliesto="security_classification applied_date_and_time_assignment applied_date_assignment applied_person_and_organization_assignment applied_approval_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( sc &lt;* security_classification | NOT ( ( SIZEOF ( QUERY ( adata &lt;* applied_date_and_time_assignment | ( sc IN adata . items ) AND ( 'classification date' = adata . role \ date_time_role . name ) ) ) = 1 ) OR ( SIZEOF ( QUERY ( ada &lt;* applied_date_assignment | ( sc IN ada . items ) AND ( 'classification date' = ada . role \ date_role . name ) ) ) = 1 ) ) ) ) = 0 "/>
         <where label="WR2" expression=" SIZEOF ( QUERY ( sc &lt;* security_classification | SIZEOF ( QUERY ( apa &lt;* applied_person_and_organization_assignment | ( sc IN apa . items ) AND ( apa . role \ person_and_organization_role . name = 'classification officer' ) ) ) = 0 ) ) = 0 "/>
         <where label="WR3" expression=" SIZEOF ( QUERY ( sc &lt;* security_classification | SIZEOF ( QUERY ( aaa &lt;* applied_approval_assignment | ( sc IN aaa . items ) ) ) = 0 ) ) = 0 "/>
      </rule>
      <rule name="subtype_exclusive_action_request_assignment" appliesto="action_request_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ara &lt;* action_request_assignment | NOT ( SIZEOF ( [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST' , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_REQUEST' ] * TYPEOF ( ara ) ) &lt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="subtype_exclusive_product_definition_relationship" appliesto="product_definition_relationship">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdr &lt;* product_definition_relationship | NOT ( SIZEOF ( [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_USAGE' , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_MATERIAL_COMPOSITION_RELATIONSHIP' , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SUPPLIED_PART_RELATIONSHIP' ] * TYPEOF ( pdr ) ) &lt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="subtype_exclusive_property_definition_representation" appliesto="property_definition_representation">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdr &lt;* property_definition_representation | NOT ( SIZEOF ( [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SHAPE_DEFINITION_REPRESENTATION' , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MATERIAL_PROPERTY_REPRESENTATION' ] * TYPEOF ( pdr ) ) &lt;= 1 ) ) ) = 0 "/>
      </rule>
      <rule name="subtype_mandatory_address" appliesto="address">
         <where label="WR1" expression=" SIZEOF ( QUERY ( add &lt;* address | NOT ( SIZEOF ( [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PERSONAL_ADDRESS' , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ORGANIZATIONAL_ADDRESS' ] * TYPEOF ( add ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="subtype_mandatory_date" appliesto="date">
         <where label="WR1" expression=" SIZEOF ( QUERY ( d &lt;* date | NOT ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CALENDAR_DATE' IN TYPEOF ( d ) ) ) ) = 0 "/>
      </rule>
      <rule name="subtype_mandatory_product_definition_usage" appliesto="product_definition_usage">
         <where label="WR1" expression=" SIZEOF ( QUERY ( pdu &lt;* product_definition_usage | NOT ( SIZEOF ( [ 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ASSEMBLY_COMPONENT_USAGE' , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'MAKE_FROM_USAGE_OPTION' ] * TYPEOF ( pdu ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="supplied_product_version_unique_constraint" appliesto="product_definition_formation_with_specified_source">
         <algorithm> LOCAL spv : BAG OF product_definition_formation_with_specified_source := QUERY ( r &lt;* product_definition_formation_with_specified_source | ( SIZEOF ( QUERY ( pd &lt;* USEDIN ( r , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION.FORMATION' ) | ( SIZEOF ( QUERY ( pdr &lt;* USEDIN ( pd , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION' ) | ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'SUPPLIED_PART_RELATIONSHIP' ) IN TYPEOF ( pdr ) ) ) ) &gt; 0 ) ) ) &gt; 0 ) ) ; aoa_bag : BAG OF applied_organization_assignment ; o_bag : BAG OF organization := [ ] ; pdf_bag : BAG OF product_definition_formation_with_specified_source ; spn_bag : BAG OF STRING ; pass : BOOLEAN := TRUE ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( spv ) by 1 ; aoa_bag := QUERY ( aoa &lt;* USEDIN ( spv [ i ] , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( aoa . role \ organization_role . name = 'supplier' ) ) ; REPEAT j := 1 to SIZEOF ( aoa_bag ) by 1 ; IF EXISTS ( aoa_bag [ j ] . assigned_organization ) THEN IF ( NOT ( aoa_bag [ j ] . assigned_organization IN o_bag ) ) THEN o_bag := o_bag + aoa_bag [ j ] . assigned_organization ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; REPEAT i := 1 to SIZEOF ( o_bag ) by 1 ; IF ( NOT pass ) THEN ESCAPE ; END_IF ; pdf_bag := QUERY ( pdf &lt;* spv | ( SIZEOF ( QUERY ( aoa &lt;* USEDIN ( pdf , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'APPLIED_ORGANIZATION_ASSIGNMENT.ITEMS' ) | ( ( aoa . role \ organization_role . name = 'supplier' ) AND ( aoa . assigned_organization :=: o_bag [ i ] ) ) ) ) &gt; 0 ) ) ; spn_bag := [ ] ; REPEAT j := 1 to SIZEOF ( pdf_bag ) by 1 ; IF EXISTS ( pdf_bag [ j ] . of_product . id ) THEN IF ( pdf_bag [ j ] . of_product . id IN spn_bag ) THEN pass := FALSE ; ESCAPE ; ELSE spn_bag := spn_bag + pdf_bag [ j ] . of_product . id ; END_IF ; END_IF ; END_REPEAT ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
      <rule name="versioned_action_request_requires_approval" appliesto="versioned_action_request applied_approval_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( varq &lt;* versioned_action_request | NOT ( SIZEOF ( QUERY ( aaa &lt;* applied_approval_assignment | varq IN aaa . items ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="versioned_action_request_requires_date_or_date_and_time" appliesto="versioned_action_request applied_date_and_time_assignment applied_date_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( varq &lt;* versioned_action_request | NOT ( ( SIZEOF ( QUERY ( adata &lt;* applied_date_and_time_assignment | varq IN adata . items ) ) = 1 ) OR ( SIZEOF ( QUERY ( ada &lt;* applied_date_assignment | varq IN ada . items ) ) = 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="versioned_action_request_requires_person_organization" appliesto="versioned_action_request applied_person_and_organization_assignment applied_organization_assignment">
         <where label="WR1" expression=" SIZEOF ( QUERY ( varq &lt;* versioned_action_request | NOT ( ( SIZEOF ( QUERY ( apaoa &lt;* applied_person_and_organization_assignment | varq IN apaoa . items ) ) &gt;= 1 ) OR ( SIZEOF ( QUERY ( aoa &lt;* applied_organization_assignment | varq IN aoa . items ) ) &gt;= 1 ) ) ) ) = 0 "/>
      </rule>
      <rule name="versioned_action_request_requires_status" appliesto="versioned_action_request action_request_status">
         <where label="WR1" expression=" SIZEOF ( QUERY ( ar &lt;* versioned_action_request | NOT ( SIZEOF ( QUERY ( ars &lt;* action_request_status | ar :=: ars . assigned_request ) ) = 1 ) ) ) = 0 "/>
      </rule>
      <rule name="work_request_unique_constraint" appliesto="versioned_action_request">
         <algorithm> LOCAL r : BAG OF versioned_action_request := QUERY ( r &lt;* versioned_action_request | ( SIZEOF ( QUERY ( ara &lt;* USEDIN ( r , 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'ACTION_REQUEST_ASSIGNMENT.ASSIGNED_ACTION_REQUEST' ) | ( ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'CHANGE_REQUEST' ) IN TYPEOF ( ara ) ) OR ( ( 'ELECTRONIC_ASSEMBLY_INTERCONNECT_AND_PACKAGING_DESIGN.' + 'START_REQUEST' ) IN TYPEOF ( ara ) ) ) ) ) &gt; 0 ) ) ; pass : BOOLEAN := TRUE ; id_bag : BAG OF STRING := [ ] ; END_LOCAL ; REPEAT i := 1 to SIZEOF ( r ) by 1 ; IF EXISTS ( r [ i ] . id ) THEN IF ( r [ i ] . id IN id_bag ) THEN pass := FALSE ; ESCAPE ; ELSE id_bag := id_bag + r [ i ] . id ; END_IF ; END_IF ; END_REPEAT ; </algorithm>
         <where label="WR1" expression=" pass "/>
      </rule>
   </schema>
</express>
