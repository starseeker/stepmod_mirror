(*
 $Id: arm_lf.exp,v 1.4 2005/02/28 13:56:54 rocc Exp $
 ISO TC184/SC4/WG3 N1340 - ISO/CD-TS 10303-436 ap236 furniture catalog and interior design - EXPRESS MIM Long form
*)

SCHEMA Ap236_furniture_catalog_and_interior_design_mim_lf;

CONSTANT

    DUMMY_GRI : geometric_representation_item := representation_item('')||
                                                 geometric_representation_item();

    DUMMY_TRI : topological_representation_item := representation_item('')||
                                                   topological_representation_item();

END_CONSTANT;

  TYPE ahead_or_behind = ENUMERATION OF
    (AHEAD,
     EXACT,
     BEHIND);
  END_TYPE;

  TYPE aliasable_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE amount_of_substance_measure = REAL;
  END_TYPE;

  TYPE angle_relator = ENUMERATION OF
    (EQUAL,
     LARGE,
     SMALL);
  END_TYPE;

  TYPE approval_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE area_measure = REAL;
  END_TYPE;

  TYPE attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT
    (multi_language_attribute_assignment);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE attribute_type = SELECT (); END_TYPE; *) 


  TYPE axis2_placement = SELECT
    (axis2_placement_2d,
     axis2_placement_3d);
  END_TYPE;

  TYPE b_spline_curve_form = ENUMERATION OF
    (POLYLINE_FORM,
     CIRCULAR_ARC,
     ELLIPTIC_ARC,
     PARABOLIC_ARC,
     HYPERBOLIC_ARC,
     UNSPECIFIED);
  END_TYPE;

  TYPE b_spline_surface_form = ENUMERATION OF
    (PLANE_SURF,
     CYLINDRICAL_SURF,
     CONICAL_SURF,
     SPHERICAL_SURF,
     TOROIDAL_SURF,
     SURF_OF_REVOLUTION,
     RULED_SURF,
     GENERALISED_CONE,
     QUADRIC_SURF,
     SURF_OF_LINEAR_EXTRUSION,
     UNSPECIFIED);
  END_TYPE;

  TYPE boolean_operand = SELECT
    (solid_model,
     half_space_solid,
     csg_primitive,
     boolean_result,
     half_space_2d);
  END_TYPE;

  TYPE boolean_operator = ENUMERATION OF
    (UNION,
     INTERSECTION,
     DIFFERENCE);
  END_TYPE;

  TYPE category_usage_item = SELECT
    (product_class);
  END_TYPE;

  TYPE celsius_temperature_measure = REAL;
  END_TYPE;

  TYPE certification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE characterized_action_definition = SELECT (); END_TYPE; *) 


  TYPE characterized_definition = SELECT
    (characterized_object,
     characterized_product_definition,
     shape_definition);
  END_TYPE;

  TYPE characterized_material_property = SELECT
    (product_material_composition_relationship);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE characterized_product_definition = SELECT (); END_TYPE; *) 


  TYPE characterized_resource_definition = SELECT
    (action_resource_requirement,
     action_resource_requirement_relationship);
  END_TYPE;

  TYPE class_system_item = EXTENSIBLE GENERIC_ENTITY SELECT
    (characterized_class);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE class_usage_effectivity_context_item = SELECT (); END_TYPE; *) 


  TYPE classification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE classification_item_extended = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON CLASSIFICATION_ITEM WITH
    (characterized_class);
  END_TYPE;

  TYPE classification_select = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE classified_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE complete_membership_select = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE compound_item_definition = SELECT
    (list_representation_item,
     set_representation_item);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE configuration_design_item = SELECT (); END_TYPE; *) 


(* NOTE: Empty SELECT set! *)
(* TYPE configured_effectivity_context_item = SELECT (); END_TYPE; *) 


  TYPE configured_effectivity_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE context_dependent_measure = REAL;
  END_TYPE;

  TYPE contract_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE count_measure = NUMBER;
  END_TYPE;

  TYPE csg_primitive = SELECT
    (sphere,
     ellipsoid,
     block,
     right_angular_wedge,
     faceted_primitive,
     rectangular_pyramid,
     torus,
     right_circular_cone,
     eccentric_cone,
     right_circular_cylinder,
     cyclide_segment_solid,
     primitive_2d);
  END_TYPE;

  TYPE csg_select = SELECT
    (boolean_result,
     csg_primitive);
  END_TYPE;

  TYPE curve_on_surface = SELECT
    (pcurve,
     surface_curve,
     composite_curve_on_surface);
  END_TYPE;

  TYPE date_and_time_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE date_and_time_item_approval = SELECT BASED_ON DATE_AND_TIME_ITEM;
  END_TYPE;

  TYPE date_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE date_item_approval = SELECT BASED_ON DATE_ITEM;
  END_TYPE;

  TYPE date_time_or_event_occurrence = SELECT
    (date_time_select,
     event_occurrence);
  END_TYPE;

  TYPE date_time_select = SELECT
    (date,
     date_and_time,
     local_time);
  END_TYPE;

  TYPE day_in_month_number = INTEGER;
    WHERE
      WR1 : {1 <= SELF <= 31};
  END_TYPE;

  TYPE day_in_week_number = INTEGER;
    WHERE
      WR1 : { 1 <= SELF <= 7 };
  END_TYPE;

  TYPE day_in_year_number = INTEGER;
    WHERE
      WR1 : {1 <= SELF <= 366};
  END_TYPE;

  TYPE derived_property_select = SELECT
    (property_definition);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE description_attribute_select = SELECT (); END_TYPE; *) 


  TYPE descriptive_measure = STRING;
  END_TYPE;

  TYPE dimension_count = INTEGER;
    WHERE
      WR1 : SELF > 0;
  END_TYPE;

  TYPE dimension_identification_item = SELECT BASED_ON IDENTIFICATION_ITEM;
  END_TYPE;

  TYPE dimension_tolerance_document_reference_item = SELECT BASED_ON DOCUMENT_REFERENCE_ITEM WITH
    (externally_defined_dimension_definition);
  END_TYPE;

  TYPE dimensional_characteristic = SELECT
    (dimensional_location,
     dimensional_size);
  END_TYPE;

  TYPE document_location_select = SELECT BASED_ON EXTERNAL_IDENTIFICATION_ITEM;
  END_TYPE;

  TYPE document_reference_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE effectivity_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE effectivity_item_for_replacement = SELECT BASED_ON EFFECTIVITY_ITEM;
  END_TYPE;

  TYPE effectivity_specification_for_replacement = SELECT BASED_ON EFFECTIVITY_ITEM;
  END_TYPE;

  TYPE electric_current_measure = REAL;
  END_TYPE;

  TYPE event_occurrence_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON DATE_AND_TIME_ITEM;
  END_TYPE;

  TYPE event_occurrence_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON DATE_ITEM;
  END_TYPE;

  TYPE event_occurrence_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE extent_enumeration = ENUMERATION OF
    (INVALID,
     ZERO,
     FINITE_NON_ZERO,
     INFINITE);
  END_TYPE;

  TYPE external_class_name_item = SELECT BASED_ON NAME_ITEM WITH
    (external_class_library);
  END_TYPE;

  TYPE external_identification_for_plib_property = SELECT BASED_ON EXTERNAL_IDENTIFICATION_ITEM WITH
    (externally_defined_general_property);
  END_TYPE;

  TYPE external_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE externally_versioned_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE file_identification_item = SELECT BASED_ON IDENTIFICATION_ITEM WITH
    (document_file);
  END_TYPE;

  TYPE file_location_select = SELECT BASED_ON EXTERNAL_IDENTIFICATION_ITEM WITH
    (document_file);
  END_TYPE;

  TYPE file_version_item = SELECT BASED_ON VERSIONABLE_ITEM WITH
    (document_file);
  END_TYPE;

  TYPE founded_item_select = SELECT
    (founded_item,
     representation_item);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE geometric_set_select = SELECT (); END_TYPE; *) 


  TYPE groupable_item = EXTENSIBLE GENERIC_ENTITY SELECT;
    WHERE
      WR1 : NOT ('GROUP_MIM.GROUP' IN TYPEOF(SELF));
  END_TYPE;

  TYPE hour_in_day = INTEGER;
    WHERE
      WR1 : { 0 <= SELF < 24 };
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE id_attribute_select = SELECT (); END_TYPE; *) 


  TYPE id_for_class = SELECT BASED_ON IDENTIFICATION_ITEM WITH
    (characterized_class);
  END_TYPE;

  TYPE id_for_product_identification = SELECT BASED_ON IDENTIFICATION_ITEM WITH
    (product_identification);
  END_TYPE;

  TYPE identification_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE identifier = STRING;
  END_TYPE;

  TYPE idrm_marked_item = EXTENSIBLE SELECT BASED_ON CLASSIFICATION_ITEM;
  END_TYPE;

  TYPE instance_usage_context_select = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE knot_type = ENUMERATION OF
    (UNIFORM_KNOTS,
     QUASI_UNIFORM_KNOTS,
     PIECEWISE_BEZIER_KNOTS,
     UNSPECIFIED);
  END_TYPE;

  TYPE label = STRING;
  END_TYPE;

  TYPE length_measure = REAL;
  END_TYPE;

  TYPE limit_condition = ENUMERATION OF
    (MAXIMUM_MATERIAL_CONDITION,
     LEAST_MATERIAL_CONDITION,
     REGARDLESS_OF_FEATURE_SIZE);
  END_TYPE;

  TYPE list_of_reversible_topology_item = LIST OF reversible_topology_item;
  END_TYPE;

  TYPE list_representation_item = LIST [1:?] OF representation_item;
  END_TYPE;

  TYPE luminous_intensity_measure = REAL;
  END_TYPE;

  TYPE mass_measure = REAL;
  END_TYPE;

  TYPE mce_organization_item = SELECT BASED_ON ORGANIZATION_ITEM;
  END_TYPE;

  TYPE measure_value = SELECT
    (amount_of_substance_measure,
     area_measure,
     celsius_temperature_measure,
     context_dependent_measure,
     count_measure,
     descriptive_measure,
     electric_current_measure,
     length_measure,
     luminous_intensity_measure,
     mass_measure,
     numeric_measure,
     parameter_value,
     plane_angle_measure,
     positive_length_measure,
     positive_plane_angle_measure,
     positive_ratio_measure,
     ratio_measure,
     solid_angle_measure,
     thermodynamic_temperature_measure,
     time_measure,
     volume_measure);
  END_TYPE;

  TYPE message = STRING;
  END_TYPE;

  TYPE minute_in_hour = INTEGER;
    WHERE
      WR1 : { 0 <= SELF <= 59 };
  END_TYPE;

  TYPE month_in_year_number = INTEGER;
    WHERE
      WR1 : { 1 <= SELF <= 12 };
  END_TYPE;

  TYPE mri_aliasable_item = EXTENSIBLE SELECT BASED_ON ALIASABLE_ITEM;
  END_TYPE;

  TYPE mri_approval_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON APPROVAL_ITEM;
  END_TYPE;

  TYPE mri_attribute_language_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ATTRIBUTE_LANGUAGE_ITEM;
  END_TYPE;

  TYPE mri_date_and_time_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON DATE_AND_TIME_ITEM;
  END_TYPE;

  TYPE mri_date_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON DATE_ITEM;
  END_TYPE;

  TYPE mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON IDENTIFICATION_ITEM;
  END_TYPE;

  TYPE mri_multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON MULTI_LANGUAGE_ATTRIBUTE_ITEM;
  END_TYPE;

  TYPE mri_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON ORGANIZATION_ITEM;
  END_TYPE;

  TYPE mri_person_and_organization_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON PERSON_AND_ORGANIZATION_ITEM;
  END_TYPE;

  TYPE multi_language_attribute_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE name_attribute_select = SELECT (); END_TYPE; *) 


  TYPE name_item = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

  TYPE numeric_measure = NUMBER;
  END_TYPE;

  TYPE organization_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE organization_item_solution = SELECT BASED_ON ORGANIZATION_ITEM;
  END_TYPE;

  TYPE parameter_value = REAL;
  END_TYPE;

  TYPE pcurve_or_surface = SELECT
    (pcurve,
     surface);
  END_TYPE;

  TYPE person_and_organization_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE person_organization_select = SELECT
    (organization,
     person,
     person_and_organization);
  END_TYPE;

  TYPE plane_angle_measure = REAL;
  END_TYPE;

  TYPE plib_class_identification_item = SELECT BASED_ON EXTERNAL_IDENTIFICATION_ITEM;
  END_TYPE;

  TYPE plib_class_organization_item = SELECT BASED_ON ORGANIZATION_ITEM;
  END_TYPE;

  TYPE positive_length_measure = length_measure;
    WHERE
      WR1 : SELF > 0.0;
  END_TYPE;

  TYPE positive_plane_angle_measure = plane_angle_measure;
    WHERE
      WR1 : SELF > 0.0;
  END_TYPE;

  TYPE positive_ratio_measure = ratio_measure;
    WHERE
      WR1 : SELF > 0.0;
  END_TYPE;

  TYPE preferred_surface_curve_representation = ENUMERATION OF
    (CURVE_3D,
     PCURVE_S1,
     PCURVE_S2);
  END_TYPE;

  TYPE product_as_individual_identification_item = SELECT BASED_ON IDENTIFICATION_ITEM WITH
    (product_as_individual,
     product_as_individual_version,
     product_as_individual_view);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE product_definition_or_assembly_relationship = SELECT (); END_TYPE; *) 


  TYPE product_definition_or_breakdown_element_usage = EXTENSIBLE GENERIC_ENTITY SELECT
    (breakdown_element_usage);
  END_TYPE;

  TYPE product_definition_or_product_definition_relationship = EXTENSIBLE GENERIC_ENTITY SELECT;
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE product_or_formation_or_definition = SELECT (); END_TYPE; *) 


  TYPE project_as_date_and_time_item = SELECT BASED_ON DATE_AND_TIME_ITEM;
  END_TYPE;

  TYPE project_as_date_item = SELECT BASED_ON DATE_ITEM;
  END_TYPE;

  TYPE project_item = EXTENSIBLE SELECT;
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE property_or_shape_select = SELECT (); END_TYPE; *) 


  TYPE ratio_measure = REAL;
  END_TYPE;

  TYPE representation_identification_item = SELECT BASED_ON IDENTIFICATION_ITEM;
  END_TYPE;

  TYPE representation_version_item = SELECT BASED_ON VERSIONABLE_ITEM;
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE represented_definition = SELECT (); END_TYPE; *) 


  TYPE requirement_identification_and_version_mri_identification_item = EXTENSIBLE GENERIC_ENTITY SELECT BASED_ON MRI_IDENTIFICATION_ITEM;
  END_TYPE;

  TYPE reversible_topology = SELECT
    (reversible_topology_item,
     list_of_reversible_topology_item,
     set_of_reversible_topology_item);
  END_TYPE;

  TYPE reversible_topology_item = SELECT
    (edge,
     path,
     face,
     face_bound,
     closed_shell,
     open_shell);
  END_TYPE;

(* NOTE: Empty SELECT set! *)
(* TYPE role_select = SELECT (); END_TYPE; *) 


  TYPE second_in_minute = REAL;
    WHERE
      WR1 : { 0 <= SELF <= 60.0 };
  END_TYPE;

  TYPE security_classification_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE set_of_reversible_topology_item = SET OF reversible_topology_item;
  END_TYPE;

  TYPE set_representation_item = SET [1:?] OF representation_item;
  END_TYPE;

  TYPE shape_definition = SELECT
    (product_definition_shape,
     shape_aspect,
     shape_aspect_relationship);
  END_TYPE;

  TYPE shape_tolerance_select = SELECT
    (geometric_tolerance,
     plus_minus_tolerance);
  END_TYPE;

  TYPE shell = SELECT
    (vertex_shell,
     wire_shell,
     open_shell,
     closed_shell);
  END_TYPE;

  TYPE si_prefix = ENUMERATION OF
    (EXA,
     PETA,
     TERA,
     GIGA,
     MEGA,
     KILO,
     HECTO,
     DECA,
     DECI,
     CENTI,
     MILLI,
     MICRO,
     NANO,
     PICO,
     FEMTO,
     ATTO);
  END_TYPE;

  TYPE si_unit_name = ENUMERATION OF
    (METRE,
     GRAM,
     SECOND,
     AMPERE,
     KELVIN,
     MOLE,
     CANDELA,
     RADIAN,
     STERADIAN,
     HERTZ,
     NEWTON,
     PASCAL,
     JOULE,
     WATT,
     COULOMB,
     VOLT,
     FARAD,
     OHM,
     SIEMENS,
     WEBER,
     TESLA,
     HENRY,
     DEGREE_CELSIUS,
     LUMEN,
     LUX,
     BECQUEREL,
     GRAY,
     SIEVERT);
  END_TYPE;

  TYPE solid_angle_measure = REAL;
  END_TYPE;

  TYPE source = ENUMERATION OF
    (MADE,
     BOUGHT,
     NOT_KNOWN);
  END_TYPE;

  TYPE source_item = SELECT
    (message);
  END_TYPE;

  TYPE specification_for_category = SELECT BASED_ON GROUPABLE_ITEM WITH
    (package_product_concept_feature);
  END_TYPE;

  TYPE spr_document_reference_item = SELECT BASED_ON DOCUMENT_REFERENCE_ITEM;
  END_TYPE;

  TYPE spr_organization_item = EXTENSIBLE SELECT BASED_ON ORGANIZATION_ITEM;
  END_TYPE;

  TYPE spr_person_and_organization_item = EXTENSIBLE SELECT BASED_ON PERSON_AND_ORGANIZATION_ITEM;
  END_TYPE;

  TYPE supported_item = SELECT
    (action,
     action_directive,
     action_method);
  END_TYPE;

  TYPE surface_boundary = SELECT
    (boundary_curve,
     degenerate_pcurve);
  END_TYPE;

  TYPE surface_model = SELECT
    (shell_based_surface_model,
     face_based_surface_model);
  END_TYPE;

  TYPE text = STRING;
  END_TYPE;

  TYPE thermodynamic_temperature_measure = REAL;
  END_TYPE;

  TYPE time_measure = REAL;
  END_TYPE;

  TYPE tolerance_method_definition = SELECT
    (tolerance_value,
     limits_and_fits);
  END_TYPE;

  TYPE transformation = SELECT
    (item_defined_transformation,
     functionally_defined_transformation);
  END_TYPE;

  TYPE transition_code = ENUMERATION OF
    (DISCONTINUOUS,
     CONTINUOUS,
     CONT_SAME_GRADIENT,
     CONT_SAME_GRADIENT_SAME_CURVATURE);
  END_TYPE;

  TYPE trimming_preference = ENUMERATION OF
    (CARTESIAN,
     PARAMETER,
     UNSPECIFIED);
  END_TYPE;

  TYPE trimming_select = SELECT
    (cartesian_point);
  END_TYPE;

  TYPE unit = SELECT
    (derived_unit,
     named_unit);
  END_TYPE;

  TYPE value_qualifier = SELECT
    (precision_qualifier,
     type_qualifier,
     uncertainty_qualifier);
  END_TYPE;

  TYPE vector_or_direction = SELECT
    (vector,
     direction);
  END_TYPE;

  TYPE version_for_class = SELECT BASED_ON VERSIONABLE_ITEM WITH
    (characterized_class);
  END_TYPE;

  TYPE version_for_plib_property = SELECT BASED_ON externally_versioned_item WITH
    (externally_defined_general_property);
  END_TYPE;

  TYPE version_for_product_identification = SELECT BASED_ON VERSIONABLE_ITEM WITH
    (product_identification);
  END_TYPE;

  TYPE versionable_item = EXTENSIBLE SELECT;
  END_TYPE;

  TYPE volume_measure = REAL;
  END_TYPE;

  TYPE week_in_year_number = INTEGER;
    WHERE
      WR1 : { 1 <= SELF <= 53 };
  END_TYPE;

  TYPE wireframe_model = SELECT
    (shell_based_wireframe_model,
     edge_based_wireframe_model);
  END_TYPE;

  TYPE year_number = INTEGER;
  END_TYPE;

  ENTITY action;
      name          : label;
      description   : OPTIONAL text;
      chosen_method : action_method;
    DERIVE
      id            : identifier := get_id_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_assignment
     ABSTRACT SUPERTYPE;
      assigned_action : ACTION;
    DERIVE
      role            : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY action_directive;
      name        : label;
      description : OPTIONAL text;
      analysis    : text;
      comment     : text;
      requests    : SET [1:?] OF versioned_action_request;
  END_ENTITY;

  ENTITY action_method;
      name        : label;
      description : OPTIONAL text;
      consequence : text;
      purpose     : text;
  END_ENTITY;

  ENTITY action_method_assignment
     ABSTRACT SUPERTYPE;
      assigned_action_method : ACTION_METHOD;
      role                   : action_method_role;
  END_ENTITY;

  ENTITY action_method_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_method : action_method;
      related_method  : action_method;
  END_ENTITY;

  ENTITY action_method_role;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY action_property;
      name        : label;
      description : text;
      definition  : characterized_action_definition;
  END_ENTITY;

  ENTITY action_property_relationship;
      name                     : label;
      description              : text;
      relating_action_property : action_property;
      related_action_property  : action_property;
    WHERE
      WR1 : relating_action_property :<>: related_action_property;
  END_ENTITY;

  ENTITY action_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_action : action;
      related_action  : action;
  END_ENTITY;

  ENTITY action_request_assignment
     ABSTRACT SUPERTYPE;
      assigned_action_request : VERSIONED_ACTION_REQUEST;
    DERIVE
      role                    : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY action_request_solution;
      method      : action_method;
      request     : versioned_action_request;
    DERIVE
      description : text := get_description_value (SELF);
      name        : label := get_name_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY action_request_status;
      status           : label;
      assigned_request : versioned_action_request;
  END_ENTITY;

  ENTITY action_resource;
      name        : label;
      description : OPTIONAL text;
      usage       : SET [1:?] OF supported_item;
      kind        : action_resource_type;
  END_ENTITY;

  ENTITY action_resource_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_resource : action_resource;
      related_resource  : action_resource;
  END_ENTITY;

  ENTITY action_resource_requirement;
      name        : label;
      description : text;
      kind        : resource_requirement_type;
      operations  : SET [1:?] OF characterized_action_definition;
  END_ENTITY;

  ENTITY action_resource_requirement_relationship;
      name                                 : label;
      description                          : text;
      relating_action_resource_requirement : action_resource_requirement;
      related_action_resource_requirement  : action_resource_requirement;
    WHERE
      WR1 : relating_action_resource_requirement :<>: 
            related_action_resource_requirement;
  END_ENTITY;

  ENTITY action_resource_type;
      name : label;
  END_ENTITY;

  ENTITY action_status;
      status          : label;
      assigned_action : executed_action;
  END_ENTITY;

  ENTITY address;
      internal_location       : OPTIONAL label;
      street_number           : OPTIONAL label;
      street                  : OPTIONAL label;
      postal_box              : OPTIONAL label;
      town                    : OPTIONAL label;
      region                  : OPTIONAL label;
      postal_code             : OPTIONAL label;
      country                 : OPTIONAL label;
      facsimile_number        : OPTIONAL label;
      telephone_number        : OPTIONAL label;
      electronic_mail_address : OPTIONAL label;
      telex_number            : OPTIONAL label;
    DERIVE
      name                    : label := get_name_value(SELF);
      url                     : identifier := get_id_value(SELF);
    WHERE
      WR1 : EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
  END_ENTITY;

  ENTITY advanced_face
    SUBTYPE OF(face_surface);
    WHERE
          WR1 : 
            SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ELEMENTARY_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_SURFACE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' ] * TYPEOF (face_geometry)) = 1;
      WR2 : 
            SIZEOF ( 
            QUERY ( elp_fbnds <* 
            QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
            QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element)) )) = 0) )) = 0;
      WR3 : 
            SIZEOF ( 
            QUERY ( elp_fbnds <* 
            QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
            QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (oe.edge_element\edge_curve.edge_geometry)) = 1) )) = 0) )) = 0;
      WR4 : 
            SIZEOF ( 
            QUERY ( elp_fbnds <* 
            QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
            QUERY ( oe <* elp_fbnds.bound\path.edge_list| NOT ((('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_start)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_start\vertex_point.vertex_geometry))) AND (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (oe\edge.edge_end)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (oe\edge.edge_end\vertex_point.vertex_geometry)))) )) = 0) )) = 0;
      WR5 : 
            SIZEOF ( 
            QUERY ( elp_fbnds <* 
            QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.ORIENTED_PATH' IN TYPEOF (elp_fbnds.bound)) )) = 0;
          WR6 : NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.LINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CONIC', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.B_SPLINE_CURVE' ] * TYPEOF (face_geometry\swept_surface.swept_curve)) = 1);
      WR7 : 
            SIZEOF ( 
            QUERY ( vlp_fbnds <* 
            QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' IN TYPEOF (bnds.bound)) )| NOT (('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex)) AND ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.CARTESIAN_POINT' IN TYPEOF (vlp_fbnds\face_bound.bound\vertex_loop.loop_vertex\vertex_point.vertex_geometry))) )) = 0;
      WR8 : 
            SIZEOF ( 
            QUERY ( bnd <* bounds| NOT ( SIZEOF ([ 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP', 'AIC_TOPOLOGICALLY_BOUNDED_SURFACE.VERTEX_LOOP' ] * TYPEOF (bnd.bound)) = 1) )) = 0;
      WR9 : 
            SIZEOF ( 
            QUERY ( elp_fbnds <* 
            QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
            QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SURFACE_CURVE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF ( 
            QUERY ( sc_ag <* oe.edge_element\edge_curve.edge_geometry\surface_curve.associated_geometry| NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.PCURVE' IN TYPEOF (sc_ag)) )) = 0) )) = 0) )) = 0;
          WR10 : (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.SWEPT_SURFACE' IN TYPEOF (face_geometry)) OR (NOT ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (face_geometry\swept_surface.swept_curve)) OR ( SIZEOF (face_geometry\swept_surface.swept_curve\polyline.points) >= 3))) AND ( SIZEOF ( 
            QUERY ( elp_fbnds <* 
            QUERY ( bnds <* bounds| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.EDGE_LOOP' IN TYPEOF (bnds.bound)) )| NOT ( SIZEOF ( 
            QUERY ( oe <* elp_fbnds.bound\path.edge_list| ('AIC_TOPOLOGICALLY_BOUNDED_SURFACE.POLYLINE' IN TYPEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry)) AND NOT ( SIZEOF (oe\oriented_edge.edge_element\edge_curve.edge_geometry\polyline.points) >= 3) )) = 0) )) = 0);
  END_ENTITY;

  ENTITY alternate_product_relationship;
      name       : label;
      definition : OPTIONAL text;
      alternate  : product;
      base       : product;
      basis      : text;
    UNIQUE
      UR1 : alternate, base;
    WHERE
       WR1: alternate :<>: base;
  END_ENTITY;

  ENTITY amount_of_substance_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY amount_of_substance_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY angular_location
    SUBTYPE OF(dimensional_location);
      angle_selection : angle_relator;
  END_ENTITY;

  ENTITY angular_size
    SUBTYPE OF(dimensional_size);
      angle_selection : angle_relator;
  END_ENTITY;

  ENTITY apex
    SUBTYPE OF(derived_shape_aspect);
  END_ENTITY;

  ENTITY application_context;
      application      : label;
    DERIVE
      description      : text := get_description_value (SELF);
      id               : identifier := get_id_value (SELF);
    INVERSE
      context_elements : SET [1:?] OF application_context_element FOR frame_of_reference;
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY application_context_element
    SUPERTYPE OF (ONEOF (
              LIBRARY_CONTEXT,
              PRODUCT_CONCEPT_CONTEXT,
              PRODUCT_CONTEXT,
              PRODUCT_DEFINITION_CONTEXT));
      name               : label;
      frame_of_reference : application_context;
  END_ENTITY;

  ENTITY application_context_relationship;
      name             : label;
      description      : OPTIONAL text;
      relating_context : application_context;
      related_context  : application_context;
  END_ENTITY;

  ENTITY application_protocol_definition;
      status                                    : label;
      application_interpreted_model_schema_name : label;
      application_protocol_year                 : year_number;
      application                               : application_context;
  END_ENTITY;

  ENTITY applied_approval_assignment
    SUBTYPE OF(approval_assignment);
      items : SET [1:?] OF approval_item;
  END_ENTITY;

  ENTITY applied_certification_assignment
    SUBTYPE OF(certification_assignment);
      items : SET [1:?] OF certification_item;
  END_ENTITY;

  ENTITY applied_classification_assignment
    SUBTYPE OF(classification_assignment);
      items : SET [1:?] OF classification_item;
  END_ENTITY;

  ENTITY applied_contract_assignment
    SUBTYPE OF(contract_assignment);
      items : SET [1:?] OF contract_item;
  END_ENTITY;

  ENTITY applied_date_and_time_assignment
    SUBTYPE OF(date_and_time_assignment);
      items : SET [1:?] OF date_and_time_item;
  END_ENTITY;

  ENTITY applied_date_assignment
    SUBTYPE OF(date_assignment);
      items : SET [1:?] OF date_item;
  END_ENTITY;

  ENTITY applied_document_reference
    SUBTYPE OF(document_reference);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY;

  ENTITY applied_document_usage_constraint_assignment
    SUBTYPE OF(document_usage_constraint_assignment);
      items : SET [1:?] OF document_reference_item;
  END_ENTITY;

  ENTITY applied_effectivity_assignment
    SUBTYPE OF(effectivity_assignment);
      items : SET [1:?] OF effectivity_item;
  END_ENTITY;

  ENTITY applied_event_occurrence_assignment
    SUBTYPE OF(event_occurrence_assignment);
      items : SET [1:?] OF event_occurrence_item;
  END_ENTITY;

  ENTITY applied_external_identification_assignment
    SUBTYPE OF(external_identification_assignment);
      items : SET [1:?] OF external_identification_item;
  END_ENTITY;

  ENTITY applied_group_assignment
    SUBTYPE OF(group_assignment);
      items : SET [1:?] OF groupable_item;
  END_ENTITY;

  ENTITY applied_identification_assignment
    SUBTYPE OF(identification_assignment);
      items : SET [1:?] OF identification_item;
  END_ENTITY;

  ENTITY applied_name_assignment
    SUBTYPE OF(name_assignment);
      item : name_item;
  END_ENTITY;

  ENTITY applied_organization_assignment
    SUBTYPE OF(organization_assignment);
      items : SET [1:?] OF organization_item;
  END_ENTITY;

  ENTITY applied_organizational_project_assignment
    SUBTYPE OF(organizational_project_assignment);
      items : SET [1:?] OF project_item;
  END_ENTITY;

  ENTITY applied_person_and_organization_assignment
    SUBTYPE OF(person_and_organization_assignment);
      items : SET [1:?] OF person_and_organization_item;
  END_ENTITY;

  ENTITY applied_security_classification_assignment
    SUBTYPE OF(security_classification_assignment);
      items : SET [1:?] OF security_classification_item;
  END_ENTITY;

  ENTITY approval;
      status : approval_status;
      level  : label;
  END_ENTITY;

  ENTITY approval_assignment
     ABSTRACT SUPERTYPE;
      assigned_approval : APPROVAL;
    DERIVE
      role              : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_date_time;
      date_time      : date_time_select;
      dated_approval : approval;
    DERIVE
      role           : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY approval_person_organization;
      person_organization : person_organization_select;
      authorized_approval : approval;
      role                : approval_role;
  END_ENTITY;

  ENTITY approval_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_approval : approval;
      related_approval  : approval;
  END_ENTITY;

  ENTITY approval_role;
      role        : label;
    DERIVE
      description : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY approval_status;
      name : label;
  END_ENTITY;

  ENTITY area_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.AREA_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY area_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY assembly_component_usage
    SUPERTYPE OF (ONEOF (
              NEXT_ASSEMBLY_USAGE_OCCURRENCE,
              SPECIFIED_HIGHER_USAGE_OCCURRENCE,
              PROMISSORY_USAGE_OCCURRENCE)
              ANDOR 
              QUANTIFIED_ASSEMBLY_COMPONENT_USAGE)
  SUBTYPE OF(product_definition_usage);
      reference_designator : OPTIONAL identifier;
  END_ENTITY;

  ENTITY assembly_component_usage_substitute;
      name       : label;
      definition : OPTIONAL text;
      base       : assembly_component_usage;
      substitute : assembly_component_usage;
    UNIQUE
      UR1 : base, substitute;
    WHERE
          WR1: base.relating_product_definition :=:
            substitute.relating_product_definition;
      WR2 : base :<>: substitute;
  END_ENTITY;

  ENTITY assembly_component_usage_substitute_with_ranking
    SUBTYPE OF(assembly_component_usage_substitute);
      ranking           : INTEGER;
      ranking_rationale : text;
  END_ENTITY;

  ENTITY attribute_classification_assignment
     ABSTRACT SUPERTYPE;
      assigned_class : GROUP;
      attribute_name : LABEL;
      role           : classification_role;
  END_ENTITY;

  ENTITY attribute_language_assignment
    SUBTYPE OF(attribute_classification_assignment);
      SELF\attribute_classification_assignment.assigned_class : language;
      items                                                   : SET [1:?] OF attribute_language_item;
    WHERE
       WR1: SELF\attribute_classification_assignment.role.name IN ['primary', 'translated'];
       WR2: SELF\attribute_classification_assignment.attribute_name<> '';
  END_ENTITY;

  ENTITY attribute_value_assignment
     ABSTRACT SUPERTYPE;
      attribute_name  : LABEL;
      attribute_value : attribute_type;
      role            : attribute_value_role;
  END_ENTITY;

  ENTITY attribute_value_role;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY axis1_placement
    SUBTYPE OF(placement);
      axis : OPTIONAL direction;
    DERIVE
      z    : direction := NVL(normalise(axis), dummy_gri ||
             direction([0.0,0.0,1.0]));
    WHERE
      WR1 : SELF\geometric_representation_item.dim  = 3;
  END_ENTITY;

  ENTITY axis2_placement_2d
    SUBTYPE OF(placement);
      ref_direction : OPTIONAL direction;
    DERIVE
      p             : LIST [2:2] OF direction := build_2axes(ref_direction);
    WHERE
      WR1 : SELF\geometric_representation_item.dim = 2;
  END_ENTITY;

  ENTITY axis2_placement_3d
    SUBTYPE OF(placement);
      axis          : OPTIONAL direction;
      ref_direction : OPTIONAL direction;
    DERIVE
      p             : LIST [3:3] OF direction := build_axes(axis,ref_direction);
    WHERE
      WR1 : SELF\placement.location.dim = 3;
      WR2 : (NOT (EXISTS (axis))) OR (axis.dim = 3);
      WR3 : (NOT (EXISTS (ref_direction))) OR (ref_direction.dim = 3);
          WR4: (NOT (EXISTS (axis))) OR (NOT (EXISTS (ref_direction))) OR
            (cross_product(axis,ref_direction).magnitude > 0.0);
  END_ENTITY;

  ENTITY b_spline_curve
    SUPERTYPE OF (ONEOF (
              UNIFORM_CURVE,
              B_SPLINE_CURVE_WITH_KNOTS,
              QUASI_UNIFORM_CURVE,
              BEZIER_CURVE)
              ANDOR 
              RATIONAL_B_SPLINE_CURVE)
  SUBTYPE OF(bounded_curve);
      degree                        : INTEGER;
      control_points_list           : LIST [2:?] OF cartesian_point;
      curve_form                    : b_spline_curve_form;
      closed_curve                  : LOGICAL;
      self_intersect                : LOGICAL;
    DERIVE
      upper_index_on_control_points : INTEGER := (SIZEOF(control_points_list) - 1);
      control_points                : ARRAY [0:100] OF cartesian_point := list_to_array(control_points_list,0,
                                      upper_index_on_control_points);
    WHERE
      WR1 : ('GEOMETRY_SCHEMA.UNIFORM_CURVE' IN TYPEOF(self)) OR
            ('GEOMETRY_SCHEMA.QUASI_UNIFORM_CURVE' IN TYPEOF(self)) OR
            ('GEOMETRY_SCHEMA.BEZIER_CURVE' IN TYPEOF(self)) OR
            ('GEOMETRY_SCHEMA.B_SPLINE_CURVE_WITH_KNOTS' IN TYPEOF(self));
  END_ENTITY;

  ENTITY b_spline_curve_with_knots
    SUBTYPE OF(b_spline_curve);
      knot_multiplicities  : LIST [2:?] OF INTEGER;
      knots                : LIST [2:?] OF parameter_value;
      knot_spec            : knot_type;
    DERIVE
      upper_index_on_knots : INTEGER := SIZEOF(knots);
    WHERE
      WR1 : constraints_param_b_spline(degree, upper_index_on_knots,
            upper_index_on_control_points,
            knot_multiplicities, knots);
      WR2 : SIZEOF(knot_multiplicities) = upper_index_on_knots;
  END_ENTITY;

  ENTITY b_spline_surface
    SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE_WITH_KNOTS,
              UNIFORM_SURFACE,
              QUASI_UNIFORM_SURFACE,
              BEZIER_SURFACE)
              ANDOR 
              RATIONAL_B_SPLINE_SURFACE)
  SUBTYPE OF(bounded_surface);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF cartesian_point;
      surface_form        : b_spline_surface_form;
      u_closed            : LOGICAL;
      v_closed            : LOGICAL;
      self_intersect      : LOGICAL;
    DERIVE
      u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
      control_points      : ARRAY [0:100] OF ARRAY [0:100] OF cartesian_point := make_array_of_array(control_points_list,
                            0,u_upper,0,v_upper);
    WHERE
      WR1 : ('GEOMETRY_SCHEMA.UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
            ('GEOMETRY_SCHEMA.QUASI_UNIFORM_SURFACE' IN TYPEOF(SELF)) OR
            ('GEOMETRY_SCHEMA.BEZIER_SURFACE' IN TYPEOF(SELF)) OR
            ('GEOMETRY_SCHEMA.B_SPLINE_SURFACE_WITH_KNOTS' IN TYPEOF(SELF));
  END_ENTITY;

  ENTITY b_spline_surface_with_knots
    SUBTYPE OF(b_spline_surface);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      knot_spec        : knot_type;
    DERIVE
      knot_u_upper     : INTEGER := SIZEOF(u_knots);
      knot_v_upper     : INTEGER := SIZEOF(v_knots);
    WHERE
      WR1 : constraints_param_b_spline(SELF\b_spline_surface.u_degree,
            knot_u_upper, SELF\b_spline_surface.u_upper,
            u_multiplicities, u_knots);
      WR2 : constraints_param_b_spline(SELF\b_spline_surface.v_degree,
            knot_v_upper, SELF\b_spline_surface.v_upper,
            v_multiplicities, v_knots);
      WR3 : SIZEOF(u_multiplicities) = knot_u_upper;
      WR4 : SIZEOF(v_multiplicities) = knot_v_upper;
  END_ENTITY;

  ENTITY b_spline_volume
    SUPERTYPE OF (ONEOF (
              B_SPLINE_VOLUME_WITH_KNOTS,
              UNIFORM_VOLUME,
              QUASI_UNIFORM_VOLUME,
              BEZIER_VOLUME)
              ANDOR 
              RATIONAL_B_SPLINE_VOLUME)
  SUBTYPE OF(volume);
      u_degree            : INTEGER;
      v_degree            : INTEGER;
      w_degree            : INTEGER;
      control_points_list : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF cartesian_point;
    DERIVE
      u_upper             : INTEGER := SIZEOF(control_points_list) - 1;
      v_upper             : INTEGER := SIZEOF(control_points_list[1]) - 1;
      w_upper             : INTEGER := SIZEOF(control_points_list[1][1]) - 1;
      control_points      : ARRAY [0:100] OF ARRAY [0:100] OF ARRAY [0:100] OF cartesian_point := make_array_of_array_of_array (control_points_list,
                            0,u_upper,0,v_upper,
                            0,w_upper );
    WHERE
      WR1 : ('GEOMETRY_SCHEMA.BEZIER_VOLUME' IN TYPEOF(SELF)) OR
            ('GEOMETRY_SCHEMA.UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
            ('GEOMETRY_SCHEMA.QUASI_UNIFORM_VOLUME' IN TYPEOF(SELF)) OR
            ('GEOMETRY_SCHEMA.B_SPLINE_VOLUME_WITH_KNOTS' IN TYPEOF(SELF)) ;
  END_ENTITY;

  ENTITY b_spline_volume_with_knots
    SUBTYPE OF(b_spline_volume);
      u_multiplicities : LIST [2:?] OF INTEGER;
      v_multiplicities : LIST [2:?] OF INTEGER;
      w_multiplicities : LIST [2:?] OF INTEGER;
      u_knots          : LIST [2:?] OF parameter_value;
      v_knots          : LIST [2:?] OF parameter_value;
      w_knots          : LIST [2:?] OF parameter_value;
    DERIVE
      knot_u_upper     : INTEGER := SIZEOF(u_knots);
      knot_v_upper     : INTEGER := SIZEOF(v_knots);
      knot_w_upper     : INTEGER := SIZEOF(w_knots);
    WHERE
      WR1 : constraints_param_b_spline(SELF\b_spline_volume.u_degree,
            knot_u_upper, SELF\b_spline_volume.u_upper,
            u_multiplicities, u_knots);
      WR2 : constraints_param_b_spline(SELF\b_spline_volume.v_degree,
            knot_v_upper, SELF\b_spline_volume.v_upper,
            v_multiplicities, v_knots);
      WR3 : constraints_param_b_spline(SELF\b_spline_volume.w_degree,
            knot_w_upper, SELF\b_spline_volume.w_upper,
            w_multiplicities, w_knots);
      WR4 : SIZEOF(u_multiplicities) = knot_u_upper;
      WR5 : SIZEOF(v_multiplicities) = knot_v_upper;
      WR6 : SIZEOF(w_multiplicities) = knot_w_upper;
  END_ENTITY;

  ENTITY bezier_curve
    SUBTYPE OF(b_spline_curve);
  END_ENTITY;

  ENTITY bezier_surface
    SUBTYPE OF(b_spline_surface);
  END_ENTITY;

  ENTITY bezier_volume
    SUBTYPE OF(b_spline_volume);
  END_ENTITY;

  ENTITY block
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position : AXIS2_PLACEMENT_3D;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
  END_ENTITY;

  ENTITY block_volume
    SUBTYPE OF(volume);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
  END_ENTITY;

  ENTITY boolean_result
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      operator       : boolean_operator;
      first_operand  : boolean_operand;
      second_operand : boolean_operand;
  END_ENTITY;

  ENTITY boundary_curve
    SUBTYPE OF(composite_curve_on_surface);
    WHERE
      WR1 : SELF\composite_curve.closed_curve;
  END_ENTITY;

  ENTITY bounded_curve
    SUPERTYPE OF (ONEOF (
              POLYLINE,
              B_SPLINE_CURVE,
              TRIMMED_CURVE,
              BOUNDED_PCURVE,
              BOUNDED_SURFACE_CURVE,
              COMPOSITE_CURVE))
  SUBTYPE OF(curve);
  END_ENTITY;

  ENTITY bounded_pcurve
    SUBTYPE OF(pcurve, bounded_curve);
    WHERE
       WR1: ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN
         TYPEOF(SELF\pcurve.reference_to_curve.items[1]));
  END_ENTITY;

  ENTITY bounded_surface
    SUPERTYPE OF (ONEOF (
              B_SPLINE_SURFACE,
              RECTANGULAR_TRIMMED_SURFACE,
              CURVE_BOUNDED_SURFACE,
              RECTANGULAR_COMPOSITE_SURFACE))
  SUBTYPE OF(surface);
  END_ENTITY;

  ENTITY bounded_surface_curve
    SUBTYPE OF(surface_curve, bounded_curve);
    WHERE
      WR1 : ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN
            TYPEOF(SELF\surface_curve.curve_3d));
  END_ENTITY;

  ENTITY box_domain
    SUBTYPE OF(founded_item);
      corner  : CARTESIAN_POINT;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
      zlength : positive_length_measure;
    WHERE
      WR1 : SIZEOF(QUERY(item <* USEDIN(SELF,'')|
            NOT ('GEOMETRIC_MODEL_SCHEMA.BOXED_HALF_SPACE'
            IN TYPEOF(item)))) = 0;
  END_ENTITY;

  ENTITY boxed_half_space
    SUBTYPE OF(half_space_solid);
      enclosure : box_domain;
  END_ENTITY;

  ENTITY breakdown_context
    SUBTYPE OF(product_definition_relationship);
  END_ENTITY;

  ENTITY breakdown_element_group_assignment
    SUBTYPE OF(group_assignment);
      SELF\group_assignment.assigned_group : product_definition_element_relationship;
      items                                : SET [1:1] OF product_definition_or_breakdown_element_usage;
  END_ENTITY;

  ENTITY breakdown_element_realization
    SUBTYPE OF(CHARACTERIZED_OBJECT, product_definition_element_relationship);
  END_ENTITY;

  ENTITY breakdown_element_usage
    SUBTYPE OF(product_definition_relationship);
  END_ENTITY;

  ENTITY breakdown_of
    SUBTYPE OF(product_definition_relationship);
  END_ENTITY;

  ENTITY brep_2d
    SUBTYPE OF(solid_model);
      extent : FACE;
    WHERE
      WR1 : SIZEOF (['TOPOLOGY_SCHEMA.FACE_SURFACE',
            'TOPOLOGY_SCHEMA.SUBFACE', 'TOPOLOGY_SCHEMA.ORIENTED_FACE'] *
            TYPEOF (SELF.extent)) = 0;
      WR2 : SIZEOF (QUERY (bnds <* extent.bounds |
            NOT ('TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound))) ) = 0;
      WR3 : SIZEOF (QUERY (bnds <* extent.bounds |
            'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF(bnds))) = 1;
      WR4 : SIZEOF(QUERY (elp_fbnds <* QUERY (bnds <* extent.bounds |
            'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(bnds.bound)) |
            NOT (SIZEOF (QUERY (oe <* elp_fbnds.bound\path.edge_list | NOT
            (('TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF(oe.edge_element)) AND
            (oe.edge_element\geometric_representation_item.dim = 2)))) =
            0))) = 0;
  END_ENTITY;

  ENTITY brep_with_voids
    SUBTYPE OF(manifold_solid_brep);
      voids : SET [1:?] OF ORIENTED_CLOSED_SHELL;
  END_ENTITY;

  ENTITY calendar_date
    SUBTYPE OF(date);
      day_component   : day_in_month_number;
      month_component : month_in_year_number;
    WHERE
      WR1 : valid_calendar_date (SELF);
  END_ENTITY;

  ENTITY cartesian_point
    SUPERTYPE OF (ONEOF (
              CYLINDRICAL_POINT,
              POLAR_POINT,
              SPHERICAL_POINT))
  SUBTYPE OF(point);
      coordinates : LIST [1:3] OF length_measure;
  END_ENTITY;

  ENTITY cartesian_transformation_operator
    SUPERTYPE OF (ONEOF (
              CARTESIAN_TRANSFORMATION_OPERATOR_2D,
              CARTESIAN_TRANSFORMATION_OPERATOR_3D))
  SUBTYPE OF(geometric_representation_item, functionally_defined_transformation);
      axis1        : OPTIONAL direction;
      axis2        : OPTIONAL direction;
      local_origin : cartesian_point;
      scale        : OPTIONAL REAL;
    DERIVE
      scl          : REAL := NVL(scale, 1.0);
    WHERE
      WR1 : scl > 0.0;
  END_ENTITY;

  ENTITY cartesian_transformation_operator_2d
    SUBTYPE OF(cartesian_transformation_operator);
    DERIVE
      u : LIST [2:2] OF direction := 
          base_axis(2,SELF\cartesian_transformation_operator.axis1,
          SELF\cartesian_transformation_operator.axis2,?);
    WHERE
      WR1 : SELF\geometric_representation_item.dim = 2;
  END_ENTITY;

  ENTITY cartesian_transformation_operator_3d
    SUBTYPE OF(cartesian_transformation_operator);
      axis3 : OPTIONAL direction;
    DERIVE
      u     : LIST [3:3] OF direction := base_axis(3,SELF\cartesian_transformation_operator.axis1,
              SELF\cartesian_transformation_operator.axis2,axis3);
    WHERE
      WR1 : SELF\geometric_representation_item.dim = 3;
  END_ENTITY;

  ENTITY celsius_temperature_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY centre_of_symmetry
    SUBTYPE OF(derived_shape_aspect);
    WHERE
      WR1 : SIZEOF
            (QUERY(sadr<*SELF\derived_shape_aspect.deriving_relationships|
            NOT('SHAPE_ASPECT_DEFINITION_SCHEMA.SYMMETRIC_SHAPE_ASPECT'
            IN TYPEOF
            (sadr\shape_aspect_relationship.related_shape_aspect))))=0;
  END_ENTITY;

  ENTITY certification;
      name    : label;
      purpose : text;
      kind    : certification_type;
  END_ENTITY;

  ENTITY certification_assignment
     ABSTRACT SUPERTYPE;
      assigned_certification : CERTIFICATION;
    DERIVE
      role                   : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY certification_type;
      description : label;
  END_ENTITY;

  ENTITY characterized_class
    SUBTYPE OF(characterized_object, CLASS);
  END_ENTITY;

  ENTITY characterized_object;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY characterized_object_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_object : characterized_object;
      related_object  : characterized_object;
  END_ENTITY;

  ENTITY circle
    SUBTYPE OF(conic);
      radius : positive_length_measure;
  END_ENTITY;

  ENTITY circular_area
    SUBTYPE OF(primitive_2d);
      centre : CARTESIAN_POINT;
      radius : positive_length_measure;
  END_ENTITY;

  ENTITY circular_involute
    SUBTYPE OF(curve);
      position    : axis2_placement;
      base_radius : positive_length_measure;
  END_ENTITY;

  ENTITY class
    SUBTYPE OF(group);
  END_ENTITY;

  ENTITY class_by_extension
    SUBTYPE OF(class);
  END_ENTITY;

  ENTITY class_by_intension
    SUBTYPE OF(class);
  END_ENTITY;

  ENTITY class_system
    SUBTYPE OF(group);
  END_ENTITY;

  ENTITY class_usage_effectivity_context_assignment
    SUBTYPE OF(EFFECTIVITY_CONTEXT_ASSIGNMENT);
      items : SET [1:?] OF class_usage_effectivity_context_item;
    WHERE
          WR1: SELF.role.name = 'class usage influence';
      WR2 : SIZEOF( QUERY( i <* SELF.items | NOT ('SPECIFICATION_CONTROL_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) )) = 0;
          WR3: ('SPECIFICATION_CONTROL_MIM.APPLIED_EFFECTIVITY_ASSIGNMENT' IN TYPEOF(SELF.assigned_effectivity_assignment)) AND 
            (SIZEOF(TYPEOF(SELF.assigned_effectivity_assignment.assigned_effectivity) ) = 1) AND 
            (SELF.assigned_effectivity_assignment.assigned_effectivity.id = 'class usage') AND 
            (SIZEOF( QUERY( i <* SELF.assigned_effectivity_assignment\applied_effectivity_assignment.items | 
            NOT('SPECIFICATION_CONTROL_MIM.PRODUCT_CONCEPT_FEATURE_CATEGORY_USAGE' IN TYPEOF(i)) )) = 0);
  END_ENTITY;

  ENTITY classification
    SUBTYPE OF(classification_assignment);
      classified : classification_select;
    DERIVE
      classifier : class := SELF\classification_assignment.assigned_class;
  END_ENTITY;

  ENTITY classification_assignment
     ABSTRACT SUPERTYPE;
      assigned_class : GROUP;
      role           : classification_role;
  END_ENTITY;

  ENTITY classification_role;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY closed_shell
    SUBTYPE OF(connected_face_set);
  END_ENTITY;

  ENTITY clothoid
    SUBTYPE OF(curve);
      position          : axis2_placement;
      clothoid_constant : length_measure;
  END_ENTITY;

  ENTITY complete_membership
    SUBTYPE OF(classification_assignment);
    DERIVE
      containing_set : class := SELF\classification_assignment.assigned_class;
  END_ENTITY;

  ENTITY complete_membership_of_empty_set
    SUBTYPE OF(complete_membership);
  END_ENTITY;

  ENTITY complete_membership_of_non_empty_set
    SUBTYPE OF(complete_membership);
      members : SET [1:?] OF complete_membership_select;
  END_ENTITY;

  ENTITY composite_curve
    SUBTYPE OF(bounded_curve);
      segments       : LIST [1:?] OF composite_curve_segment;
      self_intersect : LOGICAL;
    DERIVE
      n_segments     : INTEGER := SIZEOF(segments);
      closed_curve   : LOGICAL := segments[n_segments].transition <> discontinuous;
    WHERE
      WR1 : ((NOT closed_curve) AND (SIZEOF(QUERY(temp <* segments |
            temp.transition = discontinuous)) = 1)) OR
            ((closed_curve) AND (SIZEOF(QUERY(temp <* segments | 
            temp.transition = discontinuous)) = 0));
  END_ENTITY;

  ENTITY composite_curve_on_surface
    SUBTYPE OF(composite_curve);
    DERIVE
      basis_surface : SET [0:2] OF surface := 
                      get_basis_surface(SELF);
    WHERE
      WR1 : SIZEOF(basis_surface) > 0;
      WR2 : constraints_composite_curve_on_surface(SELF);
  END_ENTITY;

  ENTITY composite_curve_segment
    SUBTYPE OF(founded_item);
      transition   : transition_code;
      same_sense   : BOOLEAN;
      parent_curve : curve;
    INVERSE
      using_curves : BAG [1:?] OF composite_curve FOR segments;
    WHERE
      WR1 : ('GEOMETRY_SCHEMA.BOUNDED_CURVE' IN TYPEOF(parent_curve));
  END_ENTITY;

  ENTITY composite_shape_aspect
    SUBTYPE OF(shape_aspect);
    INVERSE
      component_relationships : SET [2:?] OF shape_aspect_relationship FOR relating_shape_aspect;
  END_ENTITY;

  ENTITY compound_representation_item
    SUBTYPE OF(representation_item);
      item_element : compound_item_definition;
  END_ENTITY;

  ENTITY concept_feature_operator;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY concept_feature_relationship;
      name                             : label;
      description                      : OPTIONAL text;
      relating_product_concept_feature : product_concept_feature;
      related_product_concept_feature  : product_concept_feature;
  END_ENTITY;

  ENTITY concept_feature_relationship_with_condition
    SUBTYPE OF(concept_feature_relationship);
      conditional_operator : concept_feature_operator;
  END_ENTITY;

  ENTITY conditional_concept_feature
    SUBTYPE OF(product_concept_feature);
      condition : concept_feature_relationship_with_condition;
  END_ENTITY;

  ENTITY configurable_item
    SUBTYPE OF(configuration_item);
      item_concept_feature : SET [1:?] OF product_concept_feature_association;
  END_ENTITY;

  ENTITY configuration_design;
      configuration : configuration_item;
      design        : configuration_design_item;
    DERIVE
      name          : label := get_name_value (SELF);
      description   : text := get_description_value (SELF);
    UNIQUE
      UR1 : configuration, design;
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
            'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
            'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY configuration_effectivity
    SUBTYPE OF(product_definition_effectivity);
      configuration : configuration_design;
    WHERE
       WR1: 'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE' IN
         TYPEOF (SELF\product_definition_effectivity.usage);
  END_ENTITY;

  ENTITY configuration_item;
      id           : identifier;
      name         : label;
      description  : OPTIONAL text;
      item_concept : product_concept;
      purpose      : OPTIONAL label;
  END_ENTITY;

  ENTITY configuration_item_relationship;
      name                        : label;
      description                 : OPTIONAL text;
      relating_configuration_item : configuration_item;
      related_configuration_item  : configuration_item;
  END_ENTITY;

  ENTITY configured_effectivity_assignment
    SUBTYPE OF(EFFECTIVITY_ASSIGNMENT);
      items : SET [1:?] OF configured_effectivity_item;
    WHERE
          WR1: (SIZEOF(['SPECIFICATION_BASED_CONFIGURATION_MIM.EFFECTIVITY'] * TYPEOF(SELF.assigned_effectivity) ) = 1) 
            AND (SELF.assigned_effectivity.id = 'configuration validity');
      WR2 : SIZEOF(SELF.items) = 1;
      WR3 : SIZEOF( QUERY( i <* SELF.items | NOT ('SPECIFICATION_BASED_CONFIGURATION_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) 
            OR NOT (i\product_definition.frame_of_reference.name IN ['conceptual definition','part occurrence', 'functional definition','alternative definition']) )) = 0;
          WR4: SELF.role.name IN ['design', 'usage'];
          WR5: (SELF.role.name <> 'design') 
            OR (SIZEOF( QUERY( i <* SELF.items | ('SPECIFICATION_BASED_CONFIGURATION_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'part occurrence') )) = 0);
          WR6: (SELF.role.name <> 'usage') OR (SIZEOF( QUERY( i <* SELF.items | ('SPECIFICATION_BASED_CONFIGURATION_MIM.PRODUCT_DEFINITION' IN TYPEOF(i)) AND (i\product_definition.frame_of_reference.name = 'conceptual definition') )) = 0);
          WR7: SELF.role.description IN ['exception', 'inherited', 'local'];
      WR8 : SIZEOF( QUERY( x <* USEDIN(SELF,'SPECIFICATION_BASED_CONFIGURATION_MIM.' + 'EFFECTIVITY_CONTEXT_ASSIGNMENT.ASSIGNED_EFFECTIVITY_ASSIGNMENT') | 'SPECIFICATION_BASED_CONFIGURATION_MIM.CONFIGURED_EFFECTIVITY_CONTEXT_ASSIGNMENT' IN TYPEOF(x) )) = 1;
  END_ENTITY;

  ENTITY configured_effectivity_context_assignment
    SUBTYPE OF(effectivity_context_assignment);
      SELF\effectivity_context_assignment.assigned_effectivity_assignment : configured_effectivity_assignment;
      items                                                               : SET [1:?] OF configured_effectivity_context_item;
    WHERE
      WR1 : SIZEOF(SELF.items) = 1;
  END_ENTITY;

  ENTITY conic
    SUPERTYPE OF (ONEOF (
              CIRCLE,
              ELLIPSE,
              HYPERBOLA,
              PARABOLA))
  SUBTYPE OF(curve);
      position : axis2_placement;
  END_ENTITY;

  ENTITY conical_surface
    SUBTYPE OF(elementary_surface);
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
       WR1: radius >= 0.0;
  END_ENTITY;

  ENTITY connected_edge_set
    SUBTYPE OF(topological_representation_item);
      ces_edges : SET [1:?] OF edge;
  END_ENTITY;

  ENTITY connected_face_set
    SUPERTYPE OF (ONEOF (
              CLOSED_SHELL,
              OPEN_SHELL)
              ANDOR 
              CONNECTED_FACE_SUB_SET)
  SUBTYPE OF(topological_representation_item);
      cfs_faces : SET [1:?] OF face;
  END_ENTITY;

  ENTITY connected_face_sub_set
    SUBTYPE OF(connected_face_set);
      parent_face_set : connected_face_set;
  END_ENTITY;

  ENTITY constructive_geometry_representation
    SUBTYPE OF(representation);
    WHERE
          WR1: ('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.context_of_items)) AND ({2 <= SELF.context_of_items\geometric_representation_context. coordinate_space_dimension <= 3});
      WR2 : SIZEOF( QUERY( cgr_i <* SELF.items | SIZEOF(['CONSTRUCTION_GEOMETRY_MIM.PLACEMENT', 'CONSTRUCTION_GEOMETRY_MIM.CURVE', 'CONSTRUCTION_GEOMETRY_MIM.EDGE', 'CONSTRUCTION_GEOMETRY_MIM.FACE', 'CONSTRUCTION_GEOMETRY_MIM.POINT', 'CONSTRUCTION_GEOMETRY_MIM.SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.FACE_SURFACE', 'CONSTRUCTION_GEOMETRY_MIM.VERTEX_POINT'] * TYPEOF(cgr_i)) <> 1 )) = 0;
      WR3 : SIZEOF( USEDIN( SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_RELATIONSHIP.REP_2') ) > 0;
      WR4 : SIZEOF( USEDIN( SELF, 'REPRESENTATION_SCHEMA.' + 'REPRESENTATION_MAP.MAPPED_REPRESENTATION') ) = 0;
  END_ENTITY;

  ENTITY constructive_geometry_representation_relationship
    SUBTYPE OF(representation_relationship);
    WHERE
          WR1: (SELF.rep_1.context_of_items :=: SELF.rep_2.context_of_items) AND ('CONSTRUCTION_GEOMETRY_MIM.GEOMETRIC_REPRESENTATION_CONTEXT' IN TYPEOF(SELF.rep_1.context_of_items));
          WR2: 'CONSTRUCTION_GEOMETRY_MIM.CONSTRUCTIVE_GEOMETRY_REPRESENTATION' IN TYPEOF(SELF.rep_2);
          WR3: SIZEOF(['CONSTRUCTION_GEOMETRY_MIM.SHAPE_REPRESENTATION', 'CONSTRUCTION_GEOMETRY_MIM.CONSTRUCTIVE_GEOMETRY_REPRESENTATION'] * TYPEOF(SELF.rep_1)) = 1;
      WR4 : NOT('CONSTRUCTION_GEOMETRY_MIM.' + 'REPRESENTATION_RELATIONSHIP_WITH_TRANSFORMATION' IN TYPEOF(SELF));
  END_ENTITY;

  ENTITY contact_ratio_representation
    SUBTYPE OF(REPRESENTATION);
    WHERE
          WR1: ( SIZEOF ( SELF.items ) =1 ) AND ( SIZEOF ( QUERY ( i <*
            SELF.items | ( SIZEOF ( ['SURFACE_CONDITIONS_MIM.'+
            'MEASURE_REPRESENTATION_ITEM' , 'SURFACE_CONDITIONS_MIM.'+
            'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) AND ( i.name =
            'ratio value' ) ) ) =1 ) ;
      WR2 : ( SIZEOF ( QUERY ( pdr <* USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) | pdr. name =
            'contact ratio reference' ) ) =1 ) AND ( SIZEOF ( QUERY (
            pdr <* USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) | ( pdr. name =
            'contact ratio reference' ) AND ( 'SURFACE_CONDITIONS_MIM.'+
            'PHYSICALLY_MODELLED_PRODUCT_DEFINITION' IN TYPEOF ( pdr.
            definition.definition ) ) ) ) =1 ) ;
      WR3 : ( SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
            <* USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
            pdr. definition ,
            'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+
            'DERIVED_DEFINITION' ) | ( 'SURFACE_CONDITIONS_MIM.'+
            'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
            ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
            ) =1 ) ;
  END_ENTITY;

  ENTITY context_dependent_shape_representation;
      representation_relation      : shape_representation_relationship;
      represented_product_relation : product_definition_shape;
    DERIVE
      description                  : text := get_description_value (SELF);
      name                         : label := get_name_value (SELF);
    WHERE
          WR1: 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP' IN TYPEOF (SELF.represented_product_relation.definition);
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR3 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY context_dependent_unit
    SUBTYPE OF(named_unit);
      name : LABEL;
  END_ENTITY;

  ENTITY contract;
      name    : label;
      purpose : text;
      kind    : contract_type;
  END_ENTITY;

  ENTITY contract_assignment
     ABSTRACT SUPERTYPE;
      assigned_contract : CONTRACT;
    DERIVE
      role              : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY contract_relationship;
      id                : identifier;
      name              : label;
      description       : OPTIONAL text;
      relating_contract : contract;
      related_contract  : contract;
  END_ENTITY;

  ENTITY contract_type;
      description : label;
  END_ENTITY;

  ENTITY conversion_based_unit
    SUBTYPE OF(named_unit);
      name              : LABEL;
      conversion_factor : measure_with_unit;
  END_ENTITY;

  ENTITY convex_hexahedron
    SUBTYPE OF(faceted_primitive);
    WHERE
      WR1 : SIZEOF(points) = 8 ;
          WR2: above_plane(points[1], points[2], points[3], points[4]) = 0.0;
          WR3: above_plane(points[5], points[8], points[7], points[6]) = 0.0;
          WR4: above_plane(points[1], points[4], points[8], points[5]) = 0.0;
          WR5: above_plane(points[4], points[3], points[7], points[8]) = 0.0;
          WR6: above_plane(points[3], points[2], points[6], points[7]) = 0.0;
          WR7: above_plane(points[1], points[5], points[6], points[2]) = 0.0;
          WR8: same_side([points[1], points[2], points[3]],
            [points[5], points[6], points[7], points[8]]);
          WR9: same_side([points[1], points[4], points[8]],
            [points[3], points[7], points[6], points[2]]);
          WR10: same_side([points[1], points[2], points[5]],
            [points[3], points[7], points[8], points[4]]);
          WR11: same_side([points[5], points[6], points[7]],
            [points[1], points[2], points[3], points[4]]);
          WR12: same_side([points[3], points[7], points[6]],
            [points[1], points[4], points[8], points[5]]);
          WR13: same_side([points[3], points[7], points[8]],
            [points[1], points[5], points[6], points[2]]);
  END_ENTITY;

  ENTITY coordinated_universal_time_offset;
      hour_offset          : INTEGER;
      minute_offset        : OPTIONAL INTEGER;
      sense                : ahead_or_behind;
    DERIVE
      actual_minute_offset : INTEGER := NVL(minute_offset,0);
    WHERE
      WR1 : { 0 <= hour_offset < 24 };
      WR2 : { 0 <= actual_minute_offset <= 59 };
      WR3 : NOT (((hour_offset <> 0) OR (actual_minute_offset <>0)) AND (sense = exact));
  END_ENTITY;

  ENTITY csg_solid
    SUBTYPE OF(solid_model);
      tree_root_expression : csg_select;
  END_ENTITY;

  ENTITY curve
    SUPERTYPE OF (ONEOF (
              LINE,
              CONIC,
              CLOTHOID,
              CIRCULAR_INVOLUTE,
              PCURVE,
              SURFACE_CURVE,
              OFFSET_CURVE_2D,
              OFFSET_CURVE_3D,
              CURVE_REPLICA)
              ANDOR 
              BOUNDED_CURVE)
  SUBTYPE OF(geometric_representation_item);
  END_ENTITY;

  ENTITY curve_bounded_surface
    SUBTYPE OF(bounded_surface);
      basis_surface  : surface;
      boundaries     : SET [1:?] OF boundary_curve;
      implicit_outer : BOOLEAN;
    WHERE
      WR1 : (NOT implicit_outer) OR
            (SIZEOF (QUERY (temp <* boundaries |
            'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN TYPEOF(temp))) = 0);
      WR2 : (NOT(implicit_outer)) OR
            ('GEOMETRY_SCHEMA.BOUNDED_SURFACE' IN TYPEOF(basis_surface));
      WR3 : SIZEOF(QUERY(temp <* boundaries |
            'GEOMETRY_SCHEMA.OUTER_BOUNDARY_CURVE' IN
            TYPEOF(temp))) <= 1;
      WR4 : SIZEOF(QUERY(temp <* boundaries |
            (temp\composite_curve_on_surface.basis_surface [1] <>
            SELF.basis_surface))) = 0;
  END_ENTITY;

  ENTITY curve_replica
    SUBTYPE OF(curve);
      parent_curve   : curve;
      transformation : cartesian_transformation_operator;
    WHERE
      WR1 : transformation.dim = parent_curve.dim;
      WR2 : acyclic_curve_replica (SELF, parent_curve);
  END_ENTITY;

  ENTITY cyclide_segment_solid
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position    : AXIS2_PLACEMENT_3D;
      radius1     : positive_length_measure;
      radius2     : positive_length_measure;
      cone_angle1 : plane_angle_measure;
      cone_angle2 : plane_angle_measure;
      turn_angle  : plane_angle_measure;
  END_ENTITY;

  ENTITY cylindrical_point
    SUBTYPE OF(cartesian_point);
      r                                : length_measure;
      theta                            : plane_angle_measure;
      z                                : length_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := 
                                         [r*cos(theta), r*sin(theta), z];
    WHERE
       WR1: r >= 0.0;
  END_ENTITY;

  ENTITY cylindrical_surface
    SUBTYPE OF(elementary_surface);
      radius : positive_length_measure;
  END_ENTITY;

  ENTITY cylindrical_volume
    SUBTYPE OF(volume);
      position : axis2_placement_3d;
      radius   : positive_length_measure;
      height   : positive_length_measure;
  END_ENTITY;

  ENTITY data_environment;
      name        : label;
      description : text;
      elements    : SET [1:?] OF property_definition_representation;
  END_ENTITY;

  ENTITY data_environment_relationship;
      name                      : label;
      description               : text;
      relating_data_environment : data_environment;
      related_data_environment  : data_environment;
  END_ENTITY;

  ENTITY date
    SUPERTYPE OF (ONEOF (
              CALENDAR_DATE,
              ORDINAL_DATE,
              WEEK_OF_YEAR_AND_DAY_DATE));
      year_component : year_number;
  END_ENTITY;

  ENTITY date_and_time;
      date_component : date;
      time_component : local_time;
  END_ENTITY;

  ENTITY date_and_time_assignment
     ABSTRACT SUPERTYPE;
      assigned_date_and_time : DATE_AND_TIME;
      role                   : DATE_TIME_ROLE;
  END_ENTITY;

  ENTITY date_assignment
     ABSTRACT SUPERTYPE;
      assigned_date : DATE;
      role          : DATE_ROLE;
  END_ENTITY;

  ENTITY date_role;
      name        : label;
    DERIVE
      description : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY date_time_role;
      name        : label;
    DERIVE
      description : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY dated_effectivity
    SUBTYPE OF(effectivity);
      effectivity_end_date   : OPTIONAL date_time_or_event_occurrence;
      effectivity_start_date : date_time_or_event_occurrence;
  END_ENTITY;

  ENTITY datum
    SUBTYPE OF(shape_aspect);
      identification               : identifier;
    INVERSE
      established_by_relationships : SET [1:?] OF shape_aspect_relationship FOR related_shape_aspect;
    WHERE
      WR1 : SIZEOF (QUERY (x<*SELF\datum.established_by_relationships |
            SIZEOF (TYPEOF(x\shape_aspect_relationship.relating_shape_aspect)* 
            ['SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_FEATURE', 
            'SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM_TARGET']) <> 1))=0;
  END_ENTITY;

  ENTITY datum_feature
    SUBTYPE OF(shape_aspect);
    INVERSE
      feature_basis_relationship : shape_aspect_relationship FOR relating_shape_aspect;
    WHERE
      WR1 : SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
            'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.'+
            'RELATING_SHAPE_ASPECT'))
            | NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF
            (sar\shape_aspect_relationship.related_shape_aspect))))=0;
          WR2: SELF\shape_aspect.product_definitional = TRUE;
  END_ENTITY;

  ENTITY datum_reference;
      precedence       : INTEGER;
      referenced_datum : datum;
    WHERE
      WR1 : precedence > 0;
  END_ENTITY;

  ENTITY datum_target
    SUBTYPE OF(shape_aspect);
      target_id                 : identifier;
    INVERSE
      target_basis_relationship : shape_aspect_relationship FOR relating_shape_aspect;
    WHERE
      WR1 : SIZEOF (QUERY (sar<* bag_to_set (USEDIN (SELF,
            'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT_RELATIONSHIP.' +
            'RELATING_SHAPE_ASPECT'))
            | NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.DATUM' IN TYPEOF 
            (sar\shape_aspect_relationship.related_shape_aspect))))=0;
          WR2: SELF\shape_aspect.product_definitional = TRUE;
  END_ENTITY;

  ENTITY definitional_representation
    SUBTYPE OF(representation);
    WHERE
      WR1 : 'REPRESENTATION_SCHEMA.PARAMETRIC_REPRESENTATION_CONTEXT' IN
            TYPEOF (SELF\representation.context_of_items );
  END_ENTITY;

  ENTITY degenerate_pcurve
    SUBTYPE OF(point);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
       WR1: SIZEOF(reference_to_curve\representation.items) = 1;
       WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF
         (reference_to_curve\representation.items[1]);
       WR3: reference_to_curve\representation.
         items[1]\geometric_representation_item.dim =2;
  END_ENTITY;

  ENTITY degenerate_toroidal_surface
    SUBTYPE OF(toroidal_surface);
      select_outer : BOOLEAN;
    WHERE
       WR1: major_radius <   minor_radius;
  END_ENTITY;

  ENTITY derived_shape_aspect
    SUPERTYPE OF (ONEOF (
              APEX,
              CENTRE_OF_SYMMETRY,
              GEOMETRIC_ALIGNMENT,
              GEOMETRIC_INTERSECTION,
              PARALLEL_OFFSET,
              PERPENDICULAR_TO,
              EXTENSION,
              TANGENT))
  SUBTYPE OF(shape_aspect);
    INVERSE
      deriving_relationships : SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
    WHERE
      WR1 : SIZEOF (QUERY (dr <*
            SELF\derived_shape_aspect.deriving_relationships |
            NOT ('SHAPE_ASPECT_DEFINITION_SCHEMA.' +
            'SHAPE_ASPECT_DERIVING_RELATIONSHIP'
            IN TYPEOF (dr)))) = 0;
  END_ENTITY;

  ENTITY derived_unit;
      elements : SET [1:?] OF derived_unit_element;
    DERIVE
      name     : LABEL := get_name_value (SELF);
    WHERE
      WR1 : (SIZEOF (elements) > 1) OR ((SIZEOF (elements) = 1) AND (elements[1].exponent <> 1.0));
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY derived_unit_element;
      unit     : named_unit;
      exponent : REAL;
  END_ENTITY;

  ENTITY description_attribute;
      attribute_value : text;
      described_item  : description_attribute_select;
  END_ENTITY;

  ENTITY descriptive_representation_item
    SUBTYPE OF(representation_item);
      description : text;
  END_ENTITY;

  ENTITY dimension_related_tolerance_zone_element;
      related_dimension : dimensional_location;
      related_element   : tolerance_zone_definition;
  END_ENTITY;

  ENTITY dimensional_characteristic_representation;
      dimension      : dimensional_characteristic;
      representation : shape_dimension_representation;
  END_ENTITY;

  ENTITY dimensional_exponents;
      length_exponent                    : REAL;
      mass_exponent                      : REAL;
      time_exponent                      : REAL;
      electric_current_exponent          : REAL;
      thermodynamic_temperature_exponent : REAL;
      amount_of_substance_exponent       : REAL;
      luminous_intensity_exponent        : REAL;
  END_ENTITY;

  ENTITY dimensional_location
    SUPERTYPE OF (ONEOF (
              ANGULAR_LOCATION,
              DIMENSIONAL_LOCATION_WITH_PATH))
  SUBTYPE OF(shape_aspect_relationship);
  END_ENTITY;

  ENTITY dimensional_location_with_path
    SUBTYPE OF(dimensional_location);
      path : shape_aspect;
  END_ENTITY;

  ENTITY dimensional_size
    SUPERTYPE OF (ONEOF (
              ANGULAR_SIZE,
              DIMENSIONAL_SIZE_WITH_PATH));
      applies_to : shape_aspect;
      name       : label;
    WHERE
       WR1: applies_to.product_definitional = TRUE;
  END_ENTITY;

  ENTITY dimensional_size_with_path
    SUBTYPE OF(dimensional_size);
      path : shape_aspect;
  END_ENTITY;

  ENTITY directed_action
    SUBTYPE OF(executed_action);
      directive : action_directive;
  END_ENTITY;

  ENTITY directed_dimensional_location
    SUBTYPE OF(DIMENSIONAL_LOCATION);
  END_ENTITY;

  ENTITY direction
    SUBTYPE OF(geometric_representation_item);
      direction_ratios : LIST [2:3] OF REAL;
    WHERE
      WR1 : SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
  END_ENTITY;

  ENTITY document;
      id                   : identifier;
      name                 : label;
      description          : OPTIONAL text;
      kind                 : document_type;
    INVERSE
      representation_types : SET OF document_representation_type FOR represented_document;
  END_ENTITY;

  ENTITY document_file
    SUBTYPE OF(document, characterized_object);
    WHERE
          WR1: SELF\characterized_object.name = '';
          WR2: NOT EXISTS(SELF\characterized_object.description);
      WR3 : SIZEOF( QUERY( drt <* SELF\document.representation_types |
            drt.name IN ['digital','physical'])) = 1;
  END_ENTITY;

  ENTITY document_product_association;
      name              : label;
      description       : OPTIONAL text;
      relating_document : document;
      related_product   : product_or_formation_or_definition;
  END_ENTITY;

  ENTITY document_product_equivalence
    SUBTYPE OF(document_product_association);
    WHERE
       WR1: SELF\document_product_association.name = 'equivalence';
       WR2: NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT' IN TYPEOF(SELF\document_product_association.related_product)) OR ((SELF\document_product_association.relating_document.kind. product_data_type = 'configuration controlled document') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product,'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
       WR3: NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION_FORMATION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document version') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF.related_product\product_definition_formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document')) = 1));
       WR4: NOT('DOCUMENT_ASSIGNMENT_MIM.PRODUCT_DEFINITION' IN TYPEOF(SELF.related_product)) OR ((SELF\document_product_association.relating_document.kind.product_data_type = 'configuration controlled document definition') AND (SIZEOF( QUERY( prpc <* USEDIN(SELF\document_product_association.related_product\product_definition.formation.of_product, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | prpc.name = 'document' )) = 1));
  END_ENTITY;

  ENTITY document_reference
     ABSTRACT SUPERTYPE;
      assigned_document : DOCUMENT;
      source            : LABEL;
    DERIVE
      role              : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY document_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_document : document;
      related_document  : document;
  END_ENTITY;

  ENTITY document_representation_type;
      name                 : label;
      represented_document : document;
  END_ENTITY;

  ENTITY document_type;
      product_data_type : label;
  END_ENTITY;

  ENTITY document_usage_constraint;
      source                : document;
      subject_element       : label;
      subject_element_value : text;
  END_ENTITY;

  ENTITY document_usage_constraint_assignment
     ABSTRACT SUPERTYPE;
      assigned_document_usage : DOCUMENT_USAGE_CONSTRAINT;
      role                    : document_usage_role;
  END_ENTITY;

  ENTITY document_usage_role;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY document_with_class
    SUBTYPE OF(document);
      class : identifier;
  END_ENTITY;

  ENTITY dupin_cyclide_surface
    SUBTYPE OF(elementary_surface);
      generalised_major_radius : positive_length_measure;
      generalised_minor_radius : positive_length_measure;
      skewness                 : length_measure;
    WHERE
       WR1: skewness >= 0.0;
  END_ENTITY;

  ENTITY eccentric_cone
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position    : AXIS2_PLACEMENT_3D;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      height      : positive_length_measure;
      x_offset    : length_measure;
      y_offset    : length_measure;
      ratio       : REAL;
    WHERE
      WR1 : ratio >= 0.0;
  END_ENTITY;

  ENTITY eccentric_conical_volume
    SUBTYPE OF(volume);
      position    : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      height      : positive_length_measure;
      x_offset    : length_measure;
      y_offset    : length_measure;
      ratio       : REAL;
    WHERE
      WR1 : ratio >= 0.0;
  END_ENTITY;

  ENTITY edge
    SUPERTYPE OF (ONEOF (
              EDGE_CURVE,
              ORIENTED_EDGE,
              SUBEDGE))
  SUBTYPE OF(topological_representation_item);
      edge_start : vertex;
      edge_end   : vertex;
  END_ENTITY;

  ENTITY edge_based_wireframe_model
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      ebwm_boundary : SET [1:?] OF CONNECTED_EDGE_SET;
  END_ENTITY;

  ENTITY edge_curve
    SUBTYPE OF(edge, GEOMETRIC_REPRESENTATION_ITEM);
      edge_geometry : CURVE;
      same_sense    : BOOLEAN;
  END_ENTITY;

  ENTITY edge_loop
    SUBTYPE OF(loop, path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      WR1 : (SELF\path.edge_list[1].edge_start) :=:
            (SELF\path.edge_list[ne].edge_end);
  END_ENTITY;

  ENTITY effectivity
    SUPERTYPE OF (ONEOF (
              SERIAL_NUMBERED_EFFECTIVITY,
              DATED_EFFECTIVITY,
              LOT_EFFECTIVITY,
              TIME_INTERVAL_BASED_EFFECTIVITY));
      id          : identifier;
    DERIVE
      name        : label := get_name_value(SELF);
      description : text := get_description_value(SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY effectivity_assignment
     ABSTRACT SUPERTYPE;
      assigned_effectivity : EFFECTIVITY;
    DERIVE
      role                 : object_role := get_role(SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY effectivity_context_assignment
     ABSTRACT SUPERTYPE;
      assigned_effectivity_assignment : effectivity_assignment;
      role                            : effectivity_context_role;
  END_ENTITY;

  ENTITY effectivity_context_role;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY effectivity_relationship;
      name                 : label;
      description          : OPTIONAL text;
      related_effectivity  : effectivity;
      relating_effectivity : effectivity;
  END_ENTITY;

  ENTITY electric_current_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.ELECTRIC_CURRENT_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY electric_current_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY elementary_surface
    SUPERTYPE OF (ONEOF (
              PLANE,
              CYLINDRICAL_SURFACE,
              CONICAL_SURFACE,
              SPHERICAL_SURFACE,
              TOROIDAL_SURFACE)
              ANDOR 
              DUPIN_CYCLIDE_SURFACE)
  SUBTYPE OF(surface);
      position : axis2_placement_3d;
  END_ENTITY;

  ENTITY ellipse
    SUBTYPE OF(conic);
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY;

  ENTITY ellipsoid
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position    : AXIS2_PLACEMENT_3D;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      semi_axis_3 : positive_length_measure;
  END_ENTITY;

  ENTITY ellipsoid_volume
    SUBTYPE OF(volume);
      position    : axis2_placement_3d;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
      semi_axis_3 : positive_length_measure;
  END_ENTITY;

  ENTITY elliptic_area
    SUBTYPE OF(primitive_2d);
      position    : AXIS2_PLACEMENT_2D;
      semi_axis_1 : positive_length_measure;
      semi_axis_2 : positive_length_measure;
  END_ENTITY;

  ENTITY evaluated_degenerate_pcurve
    SUBTYPE OF(degenerate_pcurve);
      equivalent_point : cartesian_point;
  END_ENTITY;

  ENTITY event_occurrence;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY event_occurrence_assignment
     ABSTRACT SUPERTYPE;
      assigned_event_occurrence : EVENT_OCCURRENCE;
      role                      : EVENT_OCCURRENCE_ROLE;
  END_ENTITY;

  ENTITY event_occurrence_context_assignment
     ABSTRACT SUPERTYPE;
      assigned_event_occurrence_assignment : event_occurrence_assignment;
      role                                 : EVENT_OCCURRENCE_CONTEXT_ROLE;
  END_ENTITY;

  ENTITY event_occurrence_context_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY event_occurrence_relationship;
      name           : label;
      description    : OPTIONAL text;
      relating_event : event_occurrence;
      related_event  : event_occurrence;
  END_ENTITY;

  ENTITY event_occurrence_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY exclusive_product_concept_feature_category
    SUBTYPE OF(product_concept_feature_category);
  END_ENTITY;

  ENTITY executed_action
    SUBTYPE OF(action);
  END_ENTITY;

  ENTITY expanded_uncertainty
    SUBTYPE OF(standard_uncertainty);
      coverage_factor : REAL;
  END_ENTITY;

  ENTITY experience;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_assignment
     ABSTRACT SUPERTYPE;
      id                  : IDENTIFIER;
      name                : LABEL;
      description         : OPTIONAL TEXT;
      assigned_experience : EXPERIENCE;
      role                : experience_role;
  END_ENTITY;

  ENTITY experience_relationship;
      id                  : identifier;
      name                : label;
      description         : OPTIONAL text;
      relating_experience : experience;
      related_experience  : experience;
  END_ENTITY;

  ENTITY experience_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY experience_type;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY experience_type_assignment
     ABSTRACT SUPERTYPE;
      id                       : IDENTIFIER;
      name                     : LABEL;
      description              : OPTIONAL TEXT;
      assigned_experience_type : EXPERIENCE_TYPE;
      role                     : experience_type_role;
  END_ENTITY;

  ENTITY experience_type_relationship;
      id                       : identifier;
      name                     : label;
      description              : OPTIONAL text;
      relating_experience_type : experience_type;
      related_experience_type  : experience_type;
  END_ENTITY;

  ENTITY experience_type_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY extension
    SUBTYPE OF(derived_shape_aspect);
    WHERE
      WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
  END_ENTITY;

  ENTITY external_class_library
    SUBTYPE OF(external_source);
  END_ENTITY;

  ENTITY external_identification_assignment
     ABSTRACT SUPERTYPE
  SUBTYPE OF(identification_assignment);
      source : external_source;
  END_ENTITY;

  ENTITY external_referent_assignment
     ABSTRACT SUPERTYPE;
      assigned_name : LABEL;
    DERIVE
      role          : object_role := get_role(SELF);
    UNIQUE
      UR1 : assigned_name;
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY external_source;
      source_id   : source_item;
    DERIVE
      description : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY external_source_relationship;
      name            : label;
      description     : OPTIONAL text;
      relating_source : external_source;
      related_source  : external_source;
  END_ENTITY;

  ENTITY externally_defined_class
    SUBTYPE OF(class, externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_dimension_definition
    SUBTYPE OF(DIMENSIONAL_SIZE, externally_defined_item);
    WHERE
          WR1: (SELF\externally_defined_item.item_id = 'external size dimension') AND (SELF\externally_defined_item.source.source_id = 'external size dimension specification');
      WR2 : 1 >= SIZEOF(QUERY ( adr <* USEDIN(SELF, 'DOCUMENT_ASSIGNMENT_MIM.APPLIED_DOCUMENT_REFERENCE.ITEMS')| (adr.assigned_document.description = 'external size dimension specification') ));
  END_ENTITY;

  ENTITY externally_defined_general_property
    SUBTYPE OF(GENERAL_PROPERTY, externally_defined_item);
  END_ENTITY;

  ENTITY externally_defined_item;
      item_id : source_item;
      source  : external_source;
  END_ENTITY;

  ENTITY externally_defined_item_relationship;
      name          : label;
      description   : OPTIONAL text;
      relating_item : externally_defined_item;
      related_item  : externally_defined_item;
  END_ENTITY;

  ENTITY extruded_area_solid
    SUBTYPE OF(swept_area_solid);
      extruded_direction : DIRECTION;
      depth              : positive_length_measure;
    WHERE
       WR1: dot_product(
         (SELF\swept_area_solid.swept_area.basis_surface\
         elementary_surface.position.p[3]), extruded_direction) <> 0.0;
  END_ENTITY;

  ENTITY extruded_face_solid
    SUBTYPE OF(swept_face_solid);
      extruded_direction : DIRECTION;
      depth              : positive_length_measure;
    WHERE
       WR1: dot_product(
         (SELF\swept_face_solid.swept_face.face_geometry\
         elementary_surface.position.p[3]), extruded_direction) <> 0.0;
  END_ENTITY;

  ENTITY face
    SUPERTYPE OF (ONEOF (
              FACE_SURFACE,
              SUBFACE,
              ORIENTED_FACE))
  SUBTYPE OF(topological_representation_item);
      bounds : SET [1:?] OF face_bound;
    WHERE
      WR1 : NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF))));
      WR2 : SIZEOF(QUERY(temp <* bounds | 'TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN
            TYPEOF(temp))) <= 1;
  END_ENTITY;

  ENTITY face_based_surface_model
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      fbsm_faces : SET [1:?] OF CONNECTED_FACE_SET;
  END_ENTITY;

  ENTITY face_bound
    SUBTYPE OF(topological_representation_item);
      bound       : loop;
      orientation : BOOLEAN;
  END_ENTITY;

  ENTITY face_outer_bound
    SUBTYPE OF(face_bound);
  END_ENTITY;

  ENTITY face_surface
    SUBTYPE OF(face, GEOMETRIC_REPRESENTATION_ITEM);
      face_geometry : SURFACE;
      same_sense    : BOOLEAN;
    WHERE
      WR1 : NOT ('GEOMETRY_SCHEMA.ORIENTED_SURFACE' IN TYPEOF(face_geometry));
  END_ENTITY;

  ENTITY faceted_brep
    SUBTYPE OF(manifold_solid_brep);
  END_ENTITY;

  ENTITY faceted_primitive
    SUPERTYPE OF (ONEOF (
              TETRAHEDRON,
              CONVEX_HEXAHEDRON))
  SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      points : LIST [4:?] OF CARTESIAN_POINT;
    WHERE
       WR1: points[1].dim = 3 ;
  END_ENTITY;

  ENTITY fixed_reference_swept_surface
    SUBTYPE OF(swept_surface);
      directrix       : curve;
      fixed_reference : direction;
  END_ENTITY;

  ENTITY founded_item;
  END_ENTITY;

  ENTITY functional_breakdown_context
    SUBTYPE OF(BREAKDOWN_CONTEXT);
  END_ENTITY;

  ENTITY functional_element_usage
    SUBTYPE OF(BREAKDOWN_ELEMENT_USAGE);
  END_ENTITY;

  ENTITY functionally_defined_transformation;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY general_material_property
    SUBTYPE OF(GENERAL_PROPERTY);
    WHERE
      WR1 : SIZEOF( QUERY( gpa <* USEDIN(SELF,'MATERIAL_ASPECTS_MIM.GENERAL_PROPERTY_ASSOCIATION.BASE_DEFINITION') | 
            NOT ('MATERIAL_ASPECTS_MIM.MATERIAL_PROPERTY' IN TYPEOF(gpa.derived_definition)) )) = 0;
  END_ENTITY;

  ENTITY general_property;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY general_property_association;
      name               : label;
      description        : OPTIONAL text;
      base_definition    : general_property;
      derived_definition : derived_property_select;
    WHERE
      WR1 : SIZEOF( USEDIN( derived_definition, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_ASSOCIATION.' + 'DERIVED_DEFINITION')) = 1;
      WR2 : derived_definition.name = base_definition.name;
  END_ENTITY;

  ENTITY general_property_relationship;
      name              : label;
      description       : OPTIONAL text;
      relating_property : general_property;
      related_property  : general_property;
  END_ENTITY;

  ENTITY geometric_alignment
    SUBTYPE OF(derived_shape_aspect);
    WHERE
      WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
  END_ENTITY;

  ENTITY geometric_curve_set
    SUBTYPE OF(geometric_set);
    WHERE
      WR1 : SIZEOF(QUERY(temp <* SELF\geometric_set.elements |
            'GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(temp))) = 0;
  END_ENTITY;

  ENTITY geometric_intersection
    SUBTYPE OF(derived_shape_aspect);
    WHERE
      WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)> 1;
  END_ENTITY;

  ENTITY geometric_representation_context
    SUBTYPE OF(representation_context);
      coordinate_space_dimension : dimension_count;
  END_ENTITY;

  ENTITY geometric_representation_item
    SUPERTYPE OF (ONEOF (
              POINT,
              DIRECTION,
              VECTOR,
              PLACEMENT,
              CARTESIAN_TRANSFORMATION_OPERATOR,
              CURVE,
              SURFACE,
              EDGE_CURVE,
              FACE_SURFACE,
              POLY_LOOP,
              VERTEX_POINT,
              SOLID_MODEL,
              BOOLEAN_RESULT,
              SPHERE,
              RIGHT_CIRCULAR_CONE,
              RIGHT_CIRCULAR_CYLINDER,
              TORUS,
              BLOCK,
              PRIMITIVE_2D,
              RIGHT_ANGULAR_WEDGE,
              ELLIPSOID,
              FACETED_PRIMITIVE,
              RECTANGULAR_PYRAMID,
              CYCLIDE_SEGMENT_SOLID,
              VOLUME,
              HALF_SPACE_SOLID,
              HALF_SPACE_2D,
              SHELL_BASED_SURFACE_MODEL,
              FACE_BASED_SURFACE_MODEL,
              SHELL_BASED_WIREFRAME_MODEL,
              EDGE_BASED_WIREFRAME_MODEL,
              GEOMETRIC_SET))
  SUBTYPE OF(representation_item);
    DERIVE
      dim : dimension_count := dimension_of(SELF);
    WHERE
      WR1 : SIZEOF (QUERY (using_rep <* using_representations (SELF) |
            NOT ('GEOMETRY_SCHEMA.GEOMETRIC_REPRESENTATION_CONTEXT' IN
            TYPEOF (using_rep.context_of_items)))) = 0;
  END_ENTITY;

  ENTITY geometric_set
    SUPERTYPE OF (ONEOF (
              GEOMETRIC_CURVE_SET,
              GEOMETRIC_SET_REPLICA))
  SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      elements : SET [1:?] OF geometric_set_select;
  END_ENTITY;

  ENTITY geometric_set_replica
    SUBTYPE OF(geometric_set);
      parent_set                  : geometric_set;
      transformation              : CARTESIAN_TRANSFORMATION_OPERATOR;
    DERIVE
      SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := 
                                    build_transformed_set(transformation, parent_set);
    WHERE
      WR1 : acyclic_set_replica(SELF, parent_set);
  END_ENTITY;

  ENTITY geometric_tolerance;
      name                    : label;
      description             : text;
      magnitude               : measure_with_unit;
      toleranced_shape_aspect : shape_aspect;
    WHERE
       WR1: ('NUMBER' IN TYPEOF
         (magnitude\measure_with_unit.value_component)) AND
         (magnitude\measure_with_unit.value_component >= 0.0);
  END_ENTITY;

  ENTITY geometric_tolerance_relationship;
      name                         : label;
      description                  : text;
      relating_geometric_tolerance : geometric_tolerance;
      related_geometric_tolerance  : geometric_tolerance;
  END_ENTITY;

  ENTITY geometric_tolerance_with_datum_reference
    SUBTYPE OF(geometric_tolerance);
      datum_system : SET [1:?] OF datum_reference;
  END_ENTITY;

  ENTITY geometric_tolerance_with_defined_unit
    SUBTYPE OF(geometric_tolerance);
      unit_size : measure_with_unit;
    WHERE
       WR1: ('NUMBER' IN TYPEOF
         (unit_size\measure_with_unit.value_component)) AND
         (unit_size\measure_with_unit.value_component > 0.0);
  END_ENTITY;

  ENTITY geometrically_bounded_2d_wireframe_representation
    SUBTYPE OF(shape_representation);
    WHERE
          WR1: SELF.context_of_items\geometric_representation_context.
            coordinate_space_dimension = 2;
      WR2 : SIZEOF (QUERY (item <* SELF.items |
            NOT (SIZEOF (TYPEOF (item) *
            ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
            
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.AXIS2_PLACEMENT_2D',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1)
            )) = 0;
      WR3 : SIZEOF (QUERY (item <* SELF.items |
            SIZEOF (TYPEOF (item) *
            
            ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM']) = 1
            )) >= 1;
      WR4 : SIZEOF (QUERY (mi <* QUERY (item <* SELF.items |
            ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.MAPPED_ITEM'
            IN TYPEOF (item))) |
            NOT ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.' +
            'GEOMETRICALLY_BOUNDED_2D_WIREFRAME_REPRESENTATION'
            IN TYPEOF
            (mi\mapped_item.mapping_source.mapped_representation))
            )) = 0;
      WR5 : SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
            ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
            IN TYPEOF (item))) |
            NOT (SIZEOF (QUERY (elem <* gcs\geometric_set.elements |
            NOT (SIZEOF (TYPEOF (elem) *
            ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE']) =
            1)
            )) = 0)
            )) = 0;
      WR6 : SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
            ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
            IN TYPEOF (item))) |
            NOT (SIZEOF (QUERY (crv <* 
            QUERY (elem <* gcs\geometric_set.elements |
            ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE'
            IN TYPEOF (elem))) |
            NOT (valid_basis_curve_in_2d_wireframe
            (crv))
            )) = 0)
            )) = 0;
      WR7 : SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |         ('AIC_- GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
            IN TYPEOF (item))) |
            NOT (SIZEOF (QUERY (pnt <*
            QUERY (elem <* gcs\geometric_set.elements |
            ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT'
            IN TYPEOF(elem))) |
            NOT (SIZEOF (TYPEOF (pnt) *
            ['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CARTESIAN_POINT',
            'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POINT_ON_CURVE'])
            = 1)
            )) = 0)
            )) = 0;
      WR8 : SIZEOF (QUERY (gcs <* QUERY (item <* SELF.items |
            
            ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.GEOMETRIC_CURVE_SET'
            IN TYPEOF (item))) |
            NOT (SIZEOF (QUERY (pl <* 
            QUERY (elem <* gcs\geometric_set.elements |
            ('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE'
            IN TYPEOF (elem))) |
            NOT (SIZEOF (pl\polyline.points) > 2)
            )) = 0)
            )) = 0;
  END_ENTITY;

  ENTITY global_uncertainty_assigned_context
    SUBTYPE OF(representation_context);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY global_unit_assigned_context
    SUBTYPE OF(representation_context);
      units : SET [1:?] OF unit;
  END_ENTITY;

  ENTITY group;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id          : identifier := get_id_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY group_assignment
     ABSTRACT SUPERTYPE;
      assigned_group : GROUP;
    DERIVE
      role           : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY group_relationship;
      name           : label;
      description    : OPTIONAL text;
      relating_group : group;
      related_group  : group;
  END_ENTITY;

  ENTITY half_space_2d
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      base_curve     : CURVE;
      agreement_flag : BOOLEAN;
  END_ENTITY;

  ENTITY half_space_solid
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      base_surface   : SURFACE;
      agreement_flag : BOOLEAN;
  END_ENTITY;

  ENTITY hardness_representation
    SUBTYPE OF(REPRESENTATION);
    WHERE
          WR1: ( {2<= SIZEOF ( SELF.items ) <=4} ) AND ( SIZEOF ( QUERY (
            i <* items | ( 'SURFACE_CONDITIONS_MIM.'+
            'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
            i.name IN [ 'measuring method' , 'measuring position' ] ) )
            ) + SIZEOF ( QUERY ( i <* items | ( SIZEOF (
            ['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,
            'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 )
            AND ( i.name IN ['depth' , 'hardness'] ) ) ) = SIZEOF (
            SELF.items ) ) ;
      WR2 : SIZEOF ( QUERY ( i <* SELF.items | i.name =
            'measuring method' ) ) =1;
      WR3 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='hardness' ) )
            =1;
      WR4 : SIZEOF ( QUERY ( i <* SELF.items | i.name =
            'measuring position' ) ) <=1;
      WR5 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='depth' ) )
            <=1;
      WR6 : ( SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
            <* USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
            pdr. definition ,
            'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+
            'DERIVED_DEFINITION' ) | ( 'SURFACE_CONDITIONS_MIM.'+
            'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
            ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
            ) =1 ) ;
  END_ENTITY;

  ENTITY hexahedron_volume
    SUBTYPE OF(volume);
      points : LIST [8:8] OF cartesian_point;
    WHERE
      WR1  : above_plane(points[1], points[2], points[3], points[4]) = 0.0;
      WR2  : above_plane(points[5], points[8], points[7], points[6]) = 0.0;
      WR3  : above_plane(points[1], points[4], points[8], points[5]) = 0.0;
      WR4  : above_plane(points[4], points[3], points[7], points[8]) = 0.0;
      WR5  : above_plane(points[3], points[2], points[6], points[7]) = 0.0;
      WR6  : above_plane(points[1], points[5], points[6], points[2]) = 0.0;
      WR7  : same_side([points[1], points[2], points[3]],
             [points[5], points[6], points[7], points[8]]);
      WR8  : same_side([points[1], points[4], points[8]],
             [points[3], points[7], points[6], points[2]]);
      WR9  : same_side([points[1], points[2], points[5]],
             [points[3], points[7], points[8], points[4]]);
      WR10 : same_side([points[5], points[6], points[7]],
             [points[1], points[2], points[3], points[4]]);
      WR11 : same_side([points[3], points[7], points[6]],
             [points[1], points[4], points[8], points[5]]);
      WR12 : same_side([points[3], points[7], points[8]],
             [points[1], points[5], points[6], points[2]]);
      WR13 : points[1].dim = 3;
  END_ENTITY;

  ENTITY hyperbola
    SUBTYPE OF(conic);
      semi_axis      : positive_length_measure;
      semi_imag_axis : positive_length_measure;
  END_ENTITY;

  ENTITY id_attribute;
      attribute_value : identifier;
      identified_item : id_attribute_select;
  END_ENTITY;

  ENTITY identification_assignment
     ABSTRACT SUPERTYPE;
      assigned_id : IDENTIFIER;
      role        : identification_role;
  END_ENTITY;

  ENTITY identification_assignment_relationship;
      name                               : LABEL;
      description                        : OPTIONAL TEXT;
      relating_identification_assignment : identification_assignment;
      related_identification_assignment  : identification_assignment;
  END_ENTITY;

  ENTITY identification_role;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY inclusion_product_concept_feature
    SUBTYPE OF(conditional_concept_feature);
    WHERE
      WR1 : NOT ( 'PRODUCT_CLASS_MIM.' + 'PACKAGE_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
      WR2 : SIZEOF (QUERY( cfr <* USEDIN ( SELF ,'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATING_PRODUCT_CONCEPT_FEATURE' ) | 
            'PRODUCT_CLASS_MIM.'+ 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF( cfr ) ) ) + 
            SIZEOF(QUERY( cfr <* USEDIN ( SELF , 'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP.RELATED_PRODUCT_CONCEPT_FEATURE' ) | 
            'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF(cfr)))= 0;
          WR3: SELF.condition.conditional_operator.name = 'implication';
  END_ENTITY;

  ENTITY instance_usage_context_assignment
    SUBTYPE OF(PRODUCT_DEFINITION_CONTEXT);
      items : SET [1:?] OF instance_usage_context_select;
  END_ENTITY;

  ENTITY intersection_curve
    SUBTYPE OF(surface_curve);
    WHERE
      WR1 : SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2 : associated_surface(SELF\surface_curve.associated_geometry[1]) <>
            associated_surface(SELF\surface_curve.associated_geometry[2]);
  END_ENTITY;

  ENTITY item_defined_transformation;
      name             : label;
      description      : OPTIONAL text;
      transform_item_1 : representation_item;
      transform_item_2 : representation_item;
  END_ENTITY;

  ENTITY item_identified_representation_usage;
      name                : label;
      description         : OPTIONAL text;
      definition          : represented_definition;
      used_representation : representation;
      identified_item     : representation_item;
    WHERE
       WR1: SELF.used_representation IN using_representations(SELF.identified_item);
  END_ENTITY;

  ENTITY known_source
    SUBTYPE OF(external_source, pre_defined_item);
  END_ENTITY;

  ENTITY language
    SUBTYPE OF(group);
    WHERE
       WR1: SELF\group.name <> '';
  END_ENTITY;

  ENTITY length_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.LENGTH_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY length_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY library_assignment
     ABSTRACT SUPERTYPE
  SUBTYPE OF(external_referent_assignment);
      frame_of_reference : library_context;
    UNIQUE
      UR1 : frame_of_reference;
  END_ENTITY;

  ENTITY library_context
    SUBTYPE OF(application_context_element);
      library_reference : label;
  END_ENTITY;

  ENTITY limits_and_fits;
      form_variance : label;
      zone_variance : label;
      grade         : label;
      source        : text;
  END_ENTITY;

  ENTITY line
    SUBTYPE OF(curve);
      pnt : cartesian_point;
      dir : vector;
    WHERE
      WR1 : dir.dim  = pnt.dim;
  END_ENTITY;

  ENTITY local_time;
      hour_component   : hour_in_day;
      minute_component : OPTIONAL minute_in_hour;
      second_component : OPTIONAL second_in_minute;
      zone             : coordinated_universal_time_offset;
    WHERE
      WR1 : valid_time (SELF);
  END_ENTITY;

  ENTITY location;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY location_assignment
     ABSTRACT SUPERTYPE;
      id                : IDENTIFIER;
      name              : LABEL;
      description       : OPTIONAL TEXT;
      assigned_location : LOCATION;
      role              : location_role;
  END_ENTITY;

  ENTITY location_relationship;
      id                : identifier;
      name              : label;
      description       : OPTIONAL text;
      relating_location : location;
      related_location  : location;
  END_ENTITY;

  ENTITY location_representation_assignment
     ABSTRACT SUPERTYPE;
      id                   : IDENTIFIER;
      name                 : LABEL;
      description          : OPTIONAL TEXT;
      represented_location : LOCATION;
      role                 : location_representation_role;
  END_ENTITY;

  ENTITY location_representation_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY location_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY loop
    SUPERTYPE OF (ONEOF (
              VERTEX_LOOP,
              EDGE_LOOP,
              POLY_LOOP))
  SUBTYPE OF(topological_representation_item);
  END_ENTITY;

  ENTITY lot_effectivity
    SUBTYPE OF(effectivity);
      effectivity_lot_id   : identifier;
      effectivity_lot_size : measure_with_unit;
  END_ENTITY;

  ENTITY luminous_intensity_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_UNIT' IN TYPEOF(SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY luminous_intensity_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 1.0);
  END_ENTITY;

  ENTITY make_from_usage_option
    SUBTYPE OF(product_definition_usage);
      ranking           : INTEGER;
      ranking_rationale : text;
      quantity          : measure_with_unit;
    WHERE
       WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
         OR (quantity.value_component > 0);
  END_ENTITY;

  ENTITY make_from_usage_option_group;
      members : SET [2:?] OF make_from_usage_option;
    WHERE
      WR1 : SIZEOF (QUERY (example <* members |
            example.related_product_definition
            :=: members[1].related_product_definition)) =SIZEOF(members);
  END_ENTITY;

  ENTITY manifold_solid_brep
    SUBTYPE OF(solid_model);
      outer : CLOSED_SHELL;
  END_ENTITY;

  ENTITY mapped_item
    SUBTYPE OF(representation_item);
      mapping_source : representation_map;
      mapping_target : representation_item;
    WHERE
      WR1 : acyclic_mapped_representation(using_representations(SELF), [SELF]);
  END_ENTITY;

  ENTITY mass_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.MASS_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY mass_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY material_designation;
      name        : label;
      definitions : SET [1:?] OF characterized_definition;
  END_ENTITY;

  ENTITY material_designation_characterization;
      name        : label;
      description : text;
      designation : material_designation;
      property    : characterized_material_property;
  END_ENTITY;

  ENTITY material_property
    SUBTYPE OF(property_definition);
    WHERE
       WR1 : ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT' IN
         TYPEOF(SELF\property_definition.definition)) OR
         (SIZEOF(bag_to_set(USEDIN(SELF ,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
         'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) -
         QUERY(temp <* bag_to_set(USEDIN(SELF ,
         'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' +
         'PROPERTY_DEFINITION_REPRESENTATION.DEFINITION')) |
         ('MATERIAL_PROPERTY_REPRESENTATION_SCHEMA.' +
         'MATERIAL_PROPERTY_REPRESENTATION' IN
         TYPEOF(temp)))) = 0);
  END_ENTITY;

  ENTITY material_property_representation
    SUBTYPE OF(property_definition_representation);
      dependent_environment : data_environment;
  END_ENTITY;

  ENTITY measure_qualification;
      name              : label;
      description       : text;
      qualified_measure : measure_with_unit;
      qualifiers        : SET [1:?] OF value_qualifier;
    WHERE
      WR1 : SIZEOF(QUERY(temp <* qualifiers |
            'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
            IN TYPEOF(temp))) < 2;
  END_ENTITY;

  ENTITY measure_representation_item
    SUBTYPE OF(representation_item, measure_with_unit);
  END_ENTITY;

  ENTITY measure_with_unit
    SUPERTYPE OF (ONEOF (
              LENGTH_MEASURE_WITH_UNIT,
              MASS_MEASURE_WITH_UNIT,
              TIME_MEASURE_WITH_UNIT,
              ELECTRIC_CURRENT_MEASURE_WITH_UNIT,
              THERMODYNAMIC_TEMPERATURE_MEASURE_WITH_UNIT,
              CELSIUS_TEMPERATURE_MEASURE_WITH_UNIT,
              AMOUNT_OF_SUBSTANCE_MEASURE_WITH_UNIT,
              LUMINOUS_INTENSITY_MEASURE_WITH_UNIT,
              PLANE_ANGLE_MEASURE_WITH_UNIT,
              SOLID_ANGLE_MEASURE_WITH_UNIT,
              AREA_MEASURE_WITH_UNIT,
              VOLUME_MEASURE_WITH_UNIT,
              RATIO_MEASURE_WITH_UNIT));
      value_component : measure_value;
      unit_component  : unit;
    WHERE
      WR1 : valid_units (SELF);
  END_ENTITY;

  ENTITY modified_geometric_tolerance
    SUBTYPE OF(geometric_tolerance);
      modifier : limit_condition;
  END_ENTITY;

  ENTITY moments_of_inertia_representation
    SUBTYPE OF(REPRESENTATION);
    WHERE
          WR1: (SIZEOF(SELF.items) = 1) AND 
            (SIZEOF( QUERY( i <* SELF.items | ('INERTIA_CHARACTERISTICS_MIM' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
            (i.name = 'moments of inertia matrix') )) = 1);
      WR2 : SIZEOF( QUERY( i <* SELF.items | ('INERTIA_CHARACTERISTICS_MIM' + '.COMPOUND_REPRESENTATION_ITEM' IN TYPEOF(i)) AND 
            ('INERTIA_CHARACTERISTICS_MIM' + '.LIST_REPRESENTATION_ITEM' IN TYPEOF(i\compound_representation_item.item_element)) AND 
            value_range_aggregate_rep_item (i\compound_representation_item.item_element) )) = 1;
  END_ENTITY;

  ENTITY multi_language_attribute_assignment
    SUBTYPE OF(attribute_value_assignment);
      items                : SET [1:?] OF multi_language_attribute_item;
    DERIVE
      translation_language : language := language_indication[1]\attribute_classification_assignment.assigned_class;
    INVERSE
      language_indication  : SET [1:1] OF attribute_language_assignment FOR items;
    WHERE
          WR1: (SELF\attribute_value_assignment.role.name = 'alternate language');
      WR2 : SIZEOF( QUERY( ala <* language_indication |  
            (ala\attribute_classification_assignment.attribute_name = 'attribute_value') AND 
            (ala\attribute_classification_assignment.role.name='translated') )) = 1 ;
          WR3: SELF\attribute_value_assignment.attribute_name <> '' ;
      WR4 : SIZEOF(QUERY(ci <* items |
            SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS') |
            (ata\attribute_value_assignment.attribute_name = SELF\attribute_value_assignment.attribute_name) AND 
            (ata.translation_language :=: translation_language) ))>1 )) =0;
      WR5 : SIZEOF(QUERY(ci <* items |
            SIZEOF(QUERY(ata <* USEDIN(ci, 'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS') |
            (ata\attribute_classification_assignment.role.name='primary') AND
            (ata\attribute_classification_assignment.attribute_name= SELF\attribute_value_assignment.attribute_name) AND 
            (ata\attribute_classification_assignment.assigned_class :=: translation_language) ))>0 )) =0;
  END_ENTITY;

  ENTITY name_assignment
     ABSTRACT SUPERTYPE;
      assigned_name : LABEL;
    DERIVE
      role          : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1 ;
  END_ENTITY;

  ENTITY name_attribute;
      attribute_value : label;
      named_item      : name_attribute_select;
  END_ENTITY;

  ENTITY named_unit
    SUPERTYPE OF (ONEOF (
              SI_UNIT,
              CONVERSION_BASED_UNIT,
              CONTEXT_DEPENDENT_UNIT)
              ANDOR ONEOF (
              LENGTH_UNIT,
              MASS_UNIT,
              TIME_UNIT,
              ELECTRIC_CURRENT_UNIT,
              THERMODYNAMIC_TEMPERATURE_UNIT,
              AMOUNT_OF_SUBSTANCE_UNIT,
              LUMINOUS_INTENSITY_UNIT,
              PLANE_ANGLE_UNIT,
              SOLID_ANGLE_UNIT,
              AREA_UNIT,
              VOLUME_UNIT,
              RATIO_UNIT));
      dimensions : dimensional_exponents;
  END_ENTITY;

  ENTITY next_assembly_usage_occurrence
    SUBTYPE OF(assembly_component_usage);
  END_ENTITY;

  ENTITY object_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY offset_curve_2d
    SUBTYPE OF(curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
    WHERE
      WR1 : basis_curve.dim = 2;
  END_ENTITY;

  ENTITY offset_curve_3d
    SUBTYPE OF(curve);
      basis_curve    : curve;
      distance       : length_measure;
      self_intersect : LOGICAL;
      ref_direction  : direction;
    WHERE
      WR1 : (basis_curve.dim = 3) AND (ref_direction.dim = 3);
  END_ENTITY;

  ENTITY offset_surface
    SUBTYPE OF(surface);
      basis_surface  : surface;
      distance       : length_measure;
      self_intersect : LOGICAL;
  END_ENTITY;

  ENTITY open_path
    SUBTYPE OF(path);
    DERIVE
      ne : INTEGER := SIZEOF(SELF\path.edge_list);
    WHERE
      WR1 : (SELF\path.edge_list[1].edge_element.edge_start) :<>:
            (SELF\path.edge_list[ne].edge_element.edge_end);
  END_ENTITY;

  ENTITY open_shell
    SUBTYPE OF(connected_face_set);
  END_ENTITY;

  ENTITY ordinal_date
    SUBTYPE OF(date);
      day_component : day_in_year_number;
    WHERE
      WR1 : (NOT leap_year(SELF.year_component) AND { 1 <= day_component <= 365 }) OR (leap_year(SELF.year_component) AND { 1 <= day_component <= 366 });
  END_ENTITY;

  ENTITY organization;
      id          : OPTIONAL identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_assignment
     ABSTRACT SUPERTYPE;
      assigned_organization : ORGANIZATION;
      role                  : ORGANIZATION_ROLE;
  END_ENTITY;

  ENTITY organization_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_organization : organization;
      related_organization  : organization;
  END_ENTITY;

  ENTITY organization_role;
      name        : label;
    DERIVE
      description : text := get_description_value(SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organization_type;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY organization_type_assignment
     ABSTRACT SUPERTYPE;
      id                         : IDENTIFIER;
      name                       : LABEL;
      description                : OPTIONAL TEXT;
      assigned_organization_type : ORGANIZATION_TYPE;
      role                       : organization_type_role;
  END_ENTITY;

  ENTITY organization_type_relationship;
      id                         : identifier;
      name                       : label;
      description                : OPTIONAL text;
      relating_organization_type : organization_type;
      related_organization_type  : organization_type;
  END_ENTITY;

  ENTITY organization_type_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY organizational_address
    SUBTYPE OF(address);
      organizations : SET [1:?] OF organization;
      description   : OPTIONAL text;
  END_ENTITY;

  ENTITY organizational_project;
      name                      : label;
      description               : OPTIONAL text;
      responsible_organizations : SET [1:?] OF organization;
    DERIVE
      id                        : identifier := get_id_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY organizational_project_assignment
     ABSTRACT SUPERTYPE;
      assigned_organizational_project : ORGANIZATIONAL_PROJECT;
      role                            : organizational_project_role;
  END_ENTITY;

  ENTITY organizational_project_relationship;
      name                            : label;
      description                     : OPTIONAL text;
      relating_organizational_project : organizational_project;
      related_organizational_project  : organizational_project;
  END_ENTITY;

  ENTITY organizational_project_role;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY oriented_closed_shell
    SUBTYPE OF(closed_shell);
      closed_shell_element              : closed_shell;
      orientation                       : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                          SELF.closed_shell_element.cfs_faces);
    WHERE
      WR1 : NOT ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' 
            IN TYPEOF (SELF.closed_shell_element));
  END_ENTITY;

  ENTITY oriented_edge
    SUBTYPE OF(edge);
      edge_element         : edge;
      orientation          : BOOLEAN;
    DERIVE
      SELF\edge.edge_start : vertex := boolean_choose (SELF.orientation,
                             SELF.edge_element.edge_start,
                             SELF.edge_element.edge_end);
      SELF\edge.edge_end   : vertex := boolean_choose (SELF.orientation,
                             SELF.edge_element.edge_end,
                             SELF.edge_element.edge_start);
    WHERE
      WR1 : NOT ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (SELF.edge_element));
  END_ENTITY;

  ENTITY oriented_face
    SUBTYPE OF(face);
      face_element     : face;
      orientation      : BOOLEAN;
    DERIVE
      SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.orientation,SELF.face_element.bounds);
    WHERE
      WR1 : NOT ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (SELF.face_element));
  END_ENTITY;

  ENTITY oriented_open_shell
    SUBTYPE OF(open_shell);
      open_shell_element                : open_shell;
      orientation                       : BOOLEAN;
    DERIVE
      SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(SELF.orientation,
                                          SELF.open_shell_element.cfs_faces);
    WHERE
      WR1 : NOT ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' 
            IN TYPEOF (SELF.open_shell_element));
  END_ENTITY;

  ENTITY oriented_path
    SUBTYPE OF(path);
      path_element        : path;
      orientation         : BOOLEAN;
    DERIVE
      SELF\path.edge_list : LIST [1:?] OF oriented_edge := conditional_reverse(SELF.orientation,
                            SELF.path_element.edge_list);
    WHERE
      WR1 : NOT ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (SELF.path_element));
  END_ENTITY;

  ENTITY oriented_surface
    SUBTYPE OF(surface);
      orientation : BOOLEAN;
  END_ENTITY;

  ENTITY outer_boundary_curve
    SUBTYPE OF(boundary_curve);
  END_ENTITY;

  ENTITY package_product_concept_feature
    SUBTYPE OF(product_concept_feature);
    WHERE
      WR1 : NOT ( 'PRODUCT_CLASS_MIM.' + 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF ( SELF ) ) ;
      WR2 : SIZEOF ( QUERY ( cfr <* USEDIN ( SELF ,
            'PRODUCT_CLASS_MIM.' + 'CONCEPT_FEATURE_RELATIONSHIP.' +'RELATING_PRODUCT_CONCEPT_FEATURE' ) | 
            ('AUTOMOTIVE_DESIGN.' + 'CONCEPT_FEATURE_RELATIONSHIP_WITH_CONDITION' IN TYPEOF (cfr ) ) AND 
            ( SIZEOF ( QUERY ( ipcf <* USEDIN ( cfr , 'PRODUCT_CLASS_MIM.' + 'CONDITIONAL_CONCEPT_FEATURE.' +
            'CONDITION' ) | 
            'PRODUCT_CLASS_MIM.' + 'INCLUSION_PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( ipcf ) ))= 1 )))>0;
  END_ENTITY;

  ENTITY parabola
    SUBTYPE OF(conic);
      focal_dist : length_measure;
    WHERE
       WR1: focal_dist <> 0.0;
  END_ENTITY;

  ENTITY parallel_offset
    SUBTYPE OF(derived_shape_aspect);
      offset : measure_with_unit;
    WHERE
      WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
  END_ENTITY;

  ENTITY parametric_representation_context
    SUBTYPE OF(representation_context);
  END_ENTITY;

  ENTITY path
    SUPERTYPE OF (ONEOF (
              OPEN_PATH,
              EDGE_LOOP,
              ORIENTED_PATH))
  SUBTYPE OF(topological_representation_item);
      edge_list : LIST [1:?] OF oriented_edge;
    WHERE
      WR1 : path_head_to_tail(SELF);
  END_ENTITY;

  ENTITY pcurve
    SUBTYPE OF(curve);
      basis_surface      : surface;
      reference_to_curve : definitional_representation;
    WHERE
       WR1: SIZEOF(reference_to_curve\representation.items) = 1;
       WR2: 'GEOMETRY_SCHEMA.CURVE' IN TYPEOF
         (reference_to_curve\representation.items[1]);
       WR3: reference_to_curve\representation.items[1]\
         geometric_representation_item.dim =2;
  END_ENTITY;

  ENTITY perpendicular_to
    SUBTYPE OF(derived_shape_aspect);
    WHERE
      WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
  END_ENTITY;

  ENTITY person;
      id            : identifier;
      last_name     : OPTIONAL label;
      first_name    : OPTIONAL label;
      middle_names  : OPTIONAL LIST [1:?] OF label;
      prefix_titles : OPTIONAL LIST [1:?] OF label;
      suffix_titles : OPTIONAL LIST [1:?] OF label;
    WHERE
      WR1 : EXISTS(last_name) OR EXISTS(first_name);
  END_ENTITY;

  ENTITY person_and_organization;
      the_person       : person;
      the_organization : organization;
    DERIVE
      name             : label := get_name_value (SELF);
      description      : text := get_description_value(SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_and_organization_address
    SUBTYPE OF(organizational_address, personal_address);
      SELF\organizational_address.organizations : SET [1:1] OF organization;
      SELF\personal_address.people              : SET [1:1] OF person;
    WHERE
      WR1 : SIZEOF(QUERY(pao <* USEDIN (SELF\personal_address.people[1], 'PERSON_ORGANIZATION_SCHEMA.PERSON_AND_ORGANIZATION.THE_PERSON') | pao.the_organization :=: SELF\organizational_address.organizations[1])) = 1;
  END_ENTITY;

  ENTITY person_and_organization_assignment
     ABSTRACT SUPERTYPE;
      assigned_person_and_organization : PERSON_AND_ORGANIZATION;
      role                             : PERSON_AND_ORGANIZATION_ROLE;
  END_ENTITY;

  ENTITY person_and_organization_role;
      name        : label;
    DERIVE
      description : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_assignment
     ABSTRACT SUPERTYPE;
      assigned_person : PERSON;
      role            : PERSON_ROLE;
  END_ENTITY;

  ENTITY person_role;
      name        : label;
    DERIVE
      description : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY person_type;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY person_type_assignment
     ABSTRACT SUPERTYPE;
      id                   : IDENTIFIER;
      name                 : LABEL;
      description          : OPTIONAL TEXT;
      assigned_person_type : PERSON_TYPE;
      role                 : person_type_role;
  END_ENTITY;

  ENTITY person_type_definition;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
      formation   : person_type_definition_formation;
  END_ENTITY;

  ENTITY person_type_definition_assignment
     ABSTRACT SUPERTYPE;
      id                              : IDENTIFIER;
      name                            : LABEL;
      description                     : OPTIONAL TEXT;
      assigned_person_type_definition : PERSON_TYPE_DEFINITION;
      role                            : person_type_definition_role;
  END_ENTITY;

  ENTITY person_type_definition_formation;
      id             : identifier;
      name           : label;
      description    : OPTIONAL text;
      of_person_type : person_type;
  END_ENTITY;

  ENTITY person_type_definition_relationship;
      id                              : identifier;
      name                            : label;
      description                     : OPTIONAL text;
      relating_person_type_definition : person_type_definition;
      related_person_type_definition  : person_type_definition;
  END_ENTITY;

  ENTITY person_type_definition_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY person_type_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY personal_address
    SUBTYPE OF(address);
      people      : SET [1:?] OF person;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY physical_breakdown_context
    SUBTYPE OF(BREAKDOWN_CONTEXT);
  END_ENTITY;

  ENTITY physical_element_usage
    SUBTYPE OF(BREAKDOWN_ELEMENT_USAGE);
  END_ENTITY;

  ENTITY physically_modelled_product_definition
    SUBTYPE OF(PRODUCT_DEFINITION);
    WHERE
       WR1: SELF.frame_of_reference\application_context_element.name = 'physical model occurrence';
       WR2: 'document' IN categories_of_product(SELF\product_definition.formation.of_product);
  END_ENTITY;

  ENTITY placement
    SUPERTYPE OF (ONEOF (
              AXIS1_PLACEMENT,
              AXIS2_PLACEMENT_2D,
              AXIS2_PLACEMENT_3D))
  SUBTYPE OF(geometric_representation_item);
      location : cartesian_point;
  END_ENTITY;

  ENTITY plane
    SUBTYPE OF(elementary_surface);
  END_ENTITY;

  ENTITY plane_angle_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.PLANE_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY plane_angle_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY plus_minus_tolerance;
      range                : tolerance_method_definition;
      toleranced_dimension : dimensional_characteristic;
    UNIQUE
      UR1 : toleranced_dimension;
  END_ENTITY;

  ENTITY point
    SUPERTYPE OF (ONEOF (
              CARTESIAN_POINT,
              POINT_ON_CURVE,
              POINT_ON_SURFACE,
              POINT_IN_VOLUME,
              POINT_REPLICA,
              DEGENERATE_PCURVE))
  SUBTYPE OF(geometric_representation_item);
  END_ENTITY;

  ENTITY point_in_volume
    SUBTYPE OF(point);
      basis_volume      : volume;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
      point_parameter_w : parameter_value;
  END_ENTITY;

  ENTITY point_on_curve
    SUBTYPE OF(point);
      basis_curve     : curve;
      point_parameter : parameter_value;
  END_ENTITY;

  ENTITY point_on_surface
    SUBTYPE OF(point);
      basis_surface     : surface;
      point_parameter_u : parameter_value;
      point_parameter_v : parameter_value;
  END_ENTITY;

  ENTITY point_replica
    SUBTYPE OF(point);
      parent_pt      : point;
      transformation : cartesian_transformation_operator;
    WHERE
      WR1 : transformation.dim = parent_pt.dim;
      WR2 : acyclic_point_replica (SELF,parent_pt);
  END_ENTITY;

  ENTITY polar_point
    SUBTYPE OF(cartesian_point);
      r                                : length_measure;
      theta                            : plane_angle_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := 
                                         [r*cos(theta), r*sin(theta)];
    WHERE
       WR1: r >= 0.0;
  END_ENTITY;

  ENTITY poly_loop
    SUBTYPE OF(loop, GEOMETRIC_REPRESENTATION_ITEM);
      polygon : LIST [3:?] OF CARTESIAN_POINT;
  END_ENTITY;

  ENTITY polygonal_area
    SUBTYPE OF(primitive_2d);
      bounds : LIST [3:?] OF CARTESIAN_POINT;
  END_ENTITY;

  ENTITY polyline
    SUBTYPE OF(bounded_curve);
      points : LIST [2:?] OF cartesian_point;
  END_ENTITY;

  ENTITY position_in_organization;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_assignment
     ABSTRACT SUPERTYPE;
      id                                : IDENTIFIER;
      name                              : LABEL;
      description                       : OPTIONAL TEXT;
      assigned_position_in_organization : POSITION_IN_ORGANIZATION;
      role                              : position_in_organization_role;
  END_ENTITY;

  ENTITY position_in_organization_relationship;
      id                                : identifier;
      name                              : label;
      description                       : OPTIONAL text;
      relating_position_in_organization : position_in_organization;
      related_position_in_organization  : position_in_organization;
  END_ENTITY;

  ENTITY position_in_organization_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY position_in_organization_type;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY position_in_organization_type_assignment
     ABSTRACT SUPERTYPE;
      id                                     : IDENTIFIER;
      name                                   : LABEL;
      description                            : OPTIONAL TEXT;
      assigned_position_in_organization_type : POSITION_IN_ORGANIZATION_TYPE;
      role                                   : position_in_organization_type_role;
  END_ENTITY;

  ENTITY position_in_organization_type_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY pre_defined_item;
      name : label;
  END_ENTITY;

  ENTITY precision_qualifier;
      precision_value : INTEGER;
  END_ENTITY;

  ENTITY primitive_2d
    SUPERTYPE OF (ONEOF (
              CIRCULAR_AREA,
              ELLIPTIC_AREA,
              RECTANGULAR_AREA,
              POLYGONAL_AREA))
  SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
    WHERE
       WR1 : SELF\geometric_representation_item.dim = 2;
  END_ENTITY;

  ENTITY process_product_association;
      name            : label;
      description     : text;
      defined_product : characterized_product_definition;
      process         : product_definition_process;
  END_ENTITY;

  ENTITY process_property_association;
      name              : label;
      description       : text;
      process           : property_process;
      property_or_shape : property_or_shape_select;
  END_ENTITY;

  ENTITY product;
      id                 : identifier;
      name               : label;
      description        : OPTIONAL text;
      frame_of_reference : SET [1:?] OF product_context;
  END_ENTITY;

  ENTITY product_as_individual
    SUBTYPE OF(product);
  END_ENTITY;

  ENTITY product_as_individual_version
     ABSTRACT SUPERTYPE OF (ONEOF (
                        PRODUCT_AS_PLANNED,
                        PRODUCT_AS_REALIZED))
  SUBTYPE OF(product_definition_formation);
      SELF\product_definition_formation.of_product : product_as_individual;
  END_ENTITY;

  ENTITY product_as_individual_view
    SUBTYPE OF(product_definition);
      SELF\product_definition.defined_version : product_as_individual_version;
  END_ENTITY;

  ENTITY product_as_planned
    SUBTYPE OF(product_as_individual_version);
  END_ENTITY;

  ENTITY product_as_realized
    SUBTYPE OF(product_as_individual_version);
  END_ENTITY;

  ENTITY product_category;
      name        : label;
      description : OPTIONAL text;
    DERIVE
      id          : identifier := get_id_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_category_relationship;
      name         : label;
      description  : OPTIONAL text;
      category     : product_category;
      sub_category : product_category;
    WHERE
      WR1 : acyclic_product_category_relationship (SELF, [SELF.sub_category]);
  END_ENTITY;

  ENTITY product_class
    SUBTYPE OF(PRODUCT_CONCEPT, characterized_object);
  END_ENTITY;

  ENTITY product_concept;
      id             : identifier;
      name           : label;
      description    : OPTIONAL text;
      market_context : product_concept_context;
    UNIQUE
      UR1 : id;
  END_ENTITY;

  ENTITY product_concept_context
    SUBTYPE OF(application_context_element);
      market_segment_type : label;
  END_ENTITY;

  ENTITY product_concept_feature;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY product_concept_feature_association;
      name        : label;
      description : OPTIONAL text;
      concept     : product_concept;
      feature     : product_concept_feature;
  END_ENTITY;

  ENTITY product_concept_feature_category
    SUBTYPE OF(GROUP);
    WHERE
      WR1 : SIZEOF(QUERY( aga <* USEDIN( SELF, 'PRODUCT_CLASS_MIM.' + 'GROUP_ASSIGNMENT.ASSIGNED_GROUP' ) |
            ('PRODUCT_CLASS_MIM.'+ 'APPLIED_GROUP_ASSIGNMENT' IN TYPEOF(aga)) AND
            (( aga.role.name <> 'specification category member' ) OR 
            ( SIZEOF(QUERY ( i <* aga.items | ('PRODUCT_CLASS_MIM.'+ 'PRODUCT_CONCEPT_FEATURE' IN TYPEOF ( i ) ) AND 
            NOT ('PRODUCT_CLASS_MIM.'+ 'CONDITIONAL_CONCEPT_FEATURE' IN TYPEOF (i)))) <> SIZEOF (aga.items))) 
            ) ) =0;
  END_ENTITY;

  ENTITY product_concept_feature_category_usage
    SUBTYPE OF(GROUP_ASSIGNMENT);
      SELF\group_assignment.assigned_group : product_concept_feature_category;
      items                                : SET [1:?] OF category_usage_item;
    WHERE
       WR1 : SELF.role.name IN [ 'mandatory category usage', 'optional category usage' ];
  END_ENTITY;

  ENTITY product_concept_relationship;
      name                     : label;
      description              : OPTIONAL text;
      relating_product_concept : product_concept;
      related_product_concept  : product_concept;
  END_ENTITY;

  ENTITY product_context
    SUBTYPE OF(application_context_element);
      discipline_type : label;
  END_ENTITY;

  ENTITY product_definition;
      id                 : identifier;
      description        : OPTIONAL text;
      formation          : product_definition_formation;
      frame_of_reference : product_definition_context;
    DERIVE
      name               : label := get_name_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_context
    SUBTYPE OF(application_context_element);
      life_cycle_stage : label;
  END_ENTITY;

  ENTITY product_definition_context_association;
      definition         : product_definition;
      frame_of_reference : product_definition_context;
      role               : product_definition_context_role;
  END_ENTITY;

  ENTITY product_definition_context_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY product_definition_effectivity
    SUBTYPE OF(effectivity);
      usage : product_definition_relationship;
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY')) = 0;
  END_ENTITY;

  ENTITY product_definition_element_relationship
    SUBTYPE OF(GROUP);
  END_ENTITY;

  ENTITY product_definition_formation;
      id          : identifier;
      description : OPTIONAL text;
      of_product  : product;
    UNIQUE
      UR1 : id, of_product;
  END_ENTITY;

  ENTITY product_definition_formation_relationship;
      id                                    : identifier;
      name                                  : label;
      description                           : OPTIONAL text;
      relating_product_definition_formation : product_definition_formation;
      related_product_definition_formation  : product_definition_formation;
  END_ENTITY;

  ENTITY product_definition_formation_with_specified_source
    SUBTYPE OF(product_definition_formation);
      make_or_buy : source;
  END_ENTITY;

  ENTITY product_definition_group_assignment
    SUBTYPE OF(group_assignment);
      SELF\group_assignment.assigned_group : product_definition_element_relationship;
      items                                : SET [1:1] OF product_definition_or_product_definition_relationship;
  END_ENTITY;

  ENTITY product_definition_occurrence_relationship;
      name             : label;
      description      : OPTIONAL text;
      occurrence       : product_definition;
      occurrence_usage : assembly_component_usage;
    WHERE
       WR1: occurrence_usage.relating_product_definition :<>: 
         occurrence;
       WR2: occurrence_usage.related_product_definition :<>: 
         occurrence;
       WR3: occurrence.formation :=:
         occurrence_usage.related_product_definition.formation;
  END_ENTITY;

  ENTITY product_definition_process
    SUBTYPE OF(action);
      identification      : identifier;
    INVERSE
      product_definitions : SET [1:?] OF process_product_association FOR process;
  END_ENTITY;

  ENTITY product_definition_relationship;
      id                          : identifier;
      name                        : label;
      description                 : OPTIONAL text;
      relating_product_definition : product_definition;
      related_product_definition  : product_definition;
  END_ENTITY;

  ENTITY product_definition_shape
    SUBTYPE OF(property_definition);
    UNIQUE
      UR1 : definition;
    WHERE
      WR1 : SIZEOF(['PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_PRODUCT_DEFINITION', 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.CHARACTERIZED_OBJECT'] * TYPEOF(SELF\property_definition.definition)) > 0;
  END_ENTITY;

  ENTITY product_definition_substitute;
      description           : OPTIONAL text;
      context_relationship  : product_definition_relationship;
      substitute_definition : product_definition;
    DERIVE
      name                  : label := get_name_value (SELF);
    WHERE
      WR1 : context_relationship.related_product_definition :<>: substitute_definition;
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY product_definition_usage
    SUPERTYPE OF (ONEOF (
              MAKE_FROM_USAGE_OPTION,
              ASSEMBLY_COMPONENT_USAGE))
  SUBTYPE OF(product_definition_relationship);
    WHERE
       WR1:  acyclic_product_definition_relationship
         (SELF,
         [SELF\product_definition_relationship.related_product_definition],
         'PRODUCT_STRUCTURE_SCHEMA.PRODUCT_DEFINITION_USAGE');
  END_ENTITY;

  ENTITY product_definition_with_associated_documents
    SUBTYPE OF(product_definition);
      documentation_ids : SET [1:?] OF document;
  END_ENTITY;

  ENTITY product_design_to_individual
    SUBTYPE OF(product_relationship);
      SELF\product_relationship.individual_product : product_as_individual;
      SELF\product_relationship.product_design     : product;
  END_ENTITY;

  ENTITY product_design_version_to_individual
    SUBTYPE OF(product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.individual_product     : product_as_individual_version;
      SELF\product_definition_formation_relationship.product_design_version : product_definition_formation;
  END_ENTITY;

  ENTITY product_identification
    SUBTYPE OF(CONFIGURATION_ITEM, characterized_object);
      SELF\configuration_item.item_concept : PRODUCT_CLASS;
    WHERE
      WR1 : SIZEOF(QUERY ( cd <* USEDIN ( SELF ,'SPECIFIED_PRODUCT_MIM.CONFIGURATION_DESIGN.CONFIGURATION' ) |
            ( 'SPECIFIED_PRODUCT_MIM.'+ 'PRODUCT_DEFINITION_FORMATION' IN TYPEOF ( cd. design ) ) AND 
            ( SIZEOF ( QUERY ( prpc <* USEDIN ( cd. design\product_definition_formation.of_product ,
            'SPECIFIED_PRODUCT_MIM.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS') | 
            prpc. name IN ['part' , 'raw material' , 'tool'] ) ) >0
            ) ) ) <=1;
      WR2 : NOT ( 'SPECIFIED_PRODUCT_MIM.'+ 'CONFIGURABLE_ITEM' IN TYPEOF( SELF ) ) XOR 
            ( 'SPECIFIED_PRODUCT_MIM.'+ 'PRODUCT_SPECIFICATION' IN TYPEOF ( SELF ) ) ;
  END_ENTITY;

  ENTITY product_material_composition_relationship
    SUBTYPE OF(product_definition_relationship);
      class                : label;
      constituent_amount   : SET [1:?] OF measure_with_unit;
      composition_basis    : label;
      determination_method : text;
  END_ENTITY;

  ENTITY product_planned_to_realized
    SUBTYPE OF(product_definition_formation_relationship);
      SELF\product_definition_formation_relationship.planned_product  : product_as_planned;
      SELF\product_definition_formation_relationship.realized_product : product_as_realized;
  END_ENTITY;

  ENTITY product_related_product_category
    SUBTYPE OF(product_category);
      products : SET [1:?] OF product;
  END_ENTITY;

  ENTITY product_relationship;
      id               : identifier;
      name             : label;
      description      : OPTIONAL text;
      relating_product : product;
      related_product  : product;
  END_ENTITY;

  ENTITY product_specification
    SUBTYPE OF(product_identification, configurable_item);
  END_ENTITY;

  ENTITY projected_zone_definition
    SUBTYPE OF(tolerance_zone_definition);
      projection_end   : shape_aspect;
      projected_length : measure_with_unit;
    WHERE
       WR1: ('NUMBER' IN TYPEOF
         (projected_length\measure_with_unit.value_component)) AND
         (projected_length\measure_with_unit.value_component > 0.0);
       WR2: (derive_dimensional_exponents
         (projected_length\measure_with_unit.unit_component)=
         dimensional_exponents(1,0,0,0,0,0,0));
  END_ENTITY;

  ENTITY promissory_usage_occurrence
    SUBTYPE OF(assembly_component_usage);
  END_ENTITY;

  ENTITY property_definition;
      name        : label;
      description : OPTIONAL text;
      definition  : characterized_definition;
    DERIVE
      id          : identifier := get_id_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY property_definition_relationship;
      name                         : label;
      description                  : text;
      relating_property_definition : property_definition;
      related_property_definition  : property_definition;
  END_ENTITY;

  ENTITY property_definition_representation;
      definition          : represented_definition;
      used_representation : representation;
    DERIVE
      description         : text := get_description_value (SELF);
      name                : label := get_name_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY property_process
    SUBTYPE OF(action);
      identification : identifier;
    INVERSE
      properties     : SET [1:?] OF process_property_association FOR process;
  END_ENTITY;

  ENTITY pyramid_volume
    SUBTYPE OF(volume);
      position : axis2_placement_3d;
      xlength  : positive_length_measure;
      ylength  : positive_length_measure;
      height   : positive_length_measure;
  END_ENTITY;

  ENTITY qualification;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_assignment
     ABSTRACT SUPERTYPE;
      id                     : IDENTIFIER;
      name                   : LABEL;
      description            : OPTIONAL TEXT;
      assigned_qualification : QUALIFICATION;
      role                   : qualification_role;
  END_ENTITY;

  ENTITY qualification_relationship;
      id                     : identifier;
      name                   : label;
      description            : OPTIONAL text;
      relating_qualification : qualification;
      related_qualification  : qualification;
  END_ENTITY;

  ENTITY qualification_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY qualification_type;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY qualification_type_assignment
     ABSTRACT SUPERTYPE;
      id                          : IDENTIFIER;
      name                        : LABEL;
      description                 : OPTIONAL TEXT;
      assigned_qualification_type : QUALIFICATION_TYPE;
      role                        : qualification_type_role;
  END_ENTITY;

  ENTITY qualification_type_relationship;
      id                          : identifier;
      name                        : label;
      description                 : OPTIONAL text;
      relating_qualification_type : qualification_type;
      related_qualification_type  : qualification_type;
  END_ENTITY;

  ENTITY qualification_type_role;
      id          : IDENTIFIER;
      name        : LABEL;
      description : OPTIONAL TEXT;
  END_ENTITY;

  ENTITY qualified_representation_item
    SUBTYPE OF(representation_item);
      qualifiers : SET [1:?] OF value_qualifier;
    WHERE
      WR1 : SIZEOF(QUERY(temp <* qualifiers |
            'QUALIFIED_MEASURE_SCHEMA.PRECISION_QUALIFIER'
            IN TYPEOF(temp))) < 2;
  END_ENTITY;

  ENTITY qualitative_uncertainty
    SUBTYPE OF(uncertainty_qualifier);
      uncertainty_value : text;
  END_ENTITY;

  ENTITY quantified_assembly_component_usage
    SUBTYPE OF(assembly_component_usage);
      quantity : measure_with_unit;
    WHERE
       WR1: (NOT ('NUMBER' IN TYPEOF(quantity.value_component)))
         OR (quantity.value_component > 0);
  END_ENTITY;

  ENTITY quasi_uniform_curve
    SUBTYPE OF(b_spline_curve);
  END_ENTITY;

  ENTITY quasi_uniform_surface
    SUBTYPE OF(b_spline_surface);
  END_ENTITY;

  ENTITY quasi_uniform_volume
    SUBTYPE OF(b_spline_volume);
  END_ENTITY;

  ENTITY ratio_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.RATIO_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY ratio_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY rational_b_spline_curve
    SUBTYPE OF(b_spline_curve);
      weights_data : LIST [2:?] OF REAL;
    DERIVE
      weights      : ARRAY [0:100] OF REAL := list_to_array(weights_data,0,
                     upper_index_on_control_points);
    WHERE
      WR1 : SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.
            control_points_list);
      WR2 : curve_weights_positive(SELF);
  END_ENTITY;

  ENTITY rational_b_spline_surface
    SUBTYPE OF(b_spline_surface);
      weights_data : LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights      : ARRAY [0:100] OF ARRAY [0:100] OF REAL := make_array_of_array(weights_data,0,u_upper,0,v_upper);
    WHERE
      WR1 : (SIZEOF(weights_data) =
            SIZEOF(SELF\b_spline_surface.control_points_list))
            AND (SIZEOF(weights_data[1]) =
            SIZEOF(SELF\b_spline_surface.control_points_list[1]));
      WR2 : surface_weights_positive(SELF);
  END_ENTITY;

  ENTITY rational_b_spline_volume
    SUBTYPE OF(b_spline_volume);
      weights_data : LIST [2:?] OF LIST [2:?] OF LIST [2:?] OF REAL;
    DERIVE
      weights      : ARRAY [0:100] OF ARRAY [0:100] OF ARRAY [0:100] OF REAL := make_array_of_array_of_array
                     (weights_data,0,u_upper,0,v_upper,0,w_upper);
    WHERE
      WR1 : (SIZEOF(weights_data) =
            SIZEOF(SELF\b_spline_volume.control_points_list))
            AND (SIZEOF(weights_data[1]) =
            SIZEOF(SELF\b_spline_volume.control_points_list[1]))
            AND (SIZEOF(weights_data[1][1]) =
            SIZEOF(SELF\b_spline_volume.control_points_list[1][1]));
      WR2 : volume_weights_positive(SELF);
  END_ENTITY;

  ENTITY rectangle_domain
    SUBTYPE OF(founded_item);
      corner  : CARTESIAN_POINT;
      xlength : positive_length_measure;
      ylength : positive_length_measure;
    WHERE
      WR1 : SIZEOF(QUERY(item <* USEDIN(SELF, '')| NOT
            ('GEOMETRIC_MODEL_SCHEMA.RECTANGLED_HALF_SPACE' IN TYPEOF(item)))) = 0;
  END_ENTITY;

  ENTITY rectangled_half_space
    SUBTYPE OF(half_space_2d);
      enclosure : rectangle_domain;
  END_ENTITY;

  ENTITY rectangular_area
    SUBTYPE OF(primitive_2d);
      position : AXIS2_PLACEMENT_2D;
      x        : positive_length_measure;
      y        : positive_length_measure;
  END_ENTITY;

  ENTITY rectangular_composite_surface
    SUBTYPE OF(bounded_surface);
      segments : LIST [1:?] OF LIST [1:?] OF surface_patch;
    DERIVE
      n_u      : INTEGER := SIZEOF(segments);
      n_v      : INTEGER := SIZEOF(segments[1]);
    WHERE
      WR1 : SIZEOF(QUERY (s <* segments | n_v <> SIZEOF (s))) = 0;
      WR2 : constraints_rectangular_composite_surface(SELF);
  END_ENTITY;

  ENTITY rectangular_pyramid
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position : AXIS2_PLACEMENT_3D;
      xlength  : positive_length_measure;
      ylength  : positive_length_measure;
      height   : positive_length_measure;
  END_ENTITY;

  ENTITY rectangular_trimmed_surface
    SUBTYPE OF(bounded_surface);
      basis_surface : surface;
      u1            : parameter_value;
      u2            : parameter_value;
      v1            : parameter_value;
      v2            : parameter_value;
      usense        : BOOLEAN;
      vsense        : BOOLEAN;
    WHERE
       WR1: u1 <> u2;
       WR2: v1 <> v2;
       WR3: (('GEOMETRY_SCHEMA.ELEMENTARY_SURFACE' IN TYPEOF(basis_surface))
         AND  (NOT ('GEOMETRY_SCHEMA.PLANE' IN TYPEOF(basis_surface)))) OR
         ('GEOMETRY_SCHEMA.SURFACE_OF_REVOLUTION' IN TYPEOF(basis_surface))
         OR (usense = (u2 > u1));
       WR4: (('GEOMETRY_SCHEMA.SPHERICAL_SURFACE' IN TYPEOF(basis_surface))
         OR
         ('GEOMETRY_SCHEMA.TOROIDAL_SURFACE' IN TYPEOF(basis_surface)))
         OR (vsense = (v2 > v1));
  END_ENTITY;

  ENTITY referenced_modified_datum
    SUBTYPE OF(datum_reference);
      modifier : limit_condition;
  END_ENTITY;

  ENTITY relative_event_occurrence
    SUBTYPE OF(event_occurrence);
      base_event : event_occurrence;
      offset     : time_measure_with_unit;
  END_ENTITY;

  ENTITY reparametrised_composite_curve_segment
    SUBTYPE OF(composite_curve_segment);
      param_length : parameter_value;
    WHERE
       WR1: param_length > 0.0;
  END_ENTITY;

  ENTITY replacement_relationship
    SUBTYPE OF(action_relationship);
    WHERE
       WR1: acyclic_action_relationship (SELF,
         [SELF\action_relationship.related_action],
         'PROCESS_PROPERTY_SCHEMA.REPLACEMENT_RELATIONSHIP');
  END_ENTITY;

  ENTITY representation;
      name             : label;
      items            : SET [1:?] OF representation_item;
      context_of_items : representation_context;
    DERIVE
      id               : identifier := get_id_value (SELF);
      description      : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
            'ID_ATTRIBUTE.IDENTIFIED_ITEM'))
            <= 1;
      WR2 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' +
            'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'))
            <= 1;
  END_ENTITY;

  ENTITY representation_context;
      context_identifier         : identifier;
      context_type               : text;
    INVERSE
      representations_in_context : SET [1:?] OF representation FOR context_of_items;
  END_ENTITY;

  ENTITY representation_item;
      name : label;
    WHERE
      WR1 : SIZEOF(using_representations(SELF)) > 0;
  END_ENTITY;

  ENTITY representation_item_relationship;
      name                         : label;
      description                  : OPTIONAL text;
      relating_representation_item : representation_item;
      related_representation_item  : representation_item;
  END_ENTITY;

  ENTITY representation_map;
      mapping_origin        : representation_item;
      mapped_representation : representation;
    INVERSE
      map_usage             : SET [1:?] OF mapped_item FOR mapping_source;
    WHERE
      WR1 : item_in_context(SELF.mapping_origin,
            SELF.mapped_representation.context_of_items);
  END_ENTITY;

  ENTITY representation_relationship;
      name        : label;
      description : OPTIONAL text;
      rep_1       : representation;
      rep_2       : representation;
  END_ENTITY;

  ENTITY representation_relationship_with_transformation
    SUBTYPE OF(representation_relationship);
      transformation_operator : transformation;
    WHERE
      WR1 : 
            SELF\representation_relationship.rep_1.context_of_items
            :<>: SELF\representation_relationship.rep_2.context_of_items;
  END_ENTITY;

  ENTITY requirement_for_action_resource
    SUBTYPE OF(action_resource_requirement);
      resources : SET [1:?] OF action_resource;
  END_ENTITY;

  ENTITY resource_property;
      name        : label;
      description : text;
      resource    : characterized_resource_definition;
  END_ENTITY;

  ENTITY resource_property_relationship;
      name                       : label;
      description                : text;
      relating_resource_property : resource_property;
      related_resource_property  : resource_property;
    WHERE
      WR1 : relating_resource_property :<>: related_resource_property;
  END_ENTITY;

  ENTITY resource_requirement_type;
      name        : label;
      description : text;
  END_ENTITY;

  ENTITY resource_requirement_type_relationship;
      name                      : label;
      description               : text;
      relating_requirement_type : resource_requirement_type;
      related_requirement_type  : resource_requirement_type;
    WHERE
      WR1 : relating_requirement_type :<>: related_requirement_type;
  END_ENTITY;

  ENTITY revolved_area_solid
    SUBTYPE OF(swept_area_solid);
      axis      : AXIS1_PLACEMENT;
      angle     : plane_angle_measure;
    DERIVE
      axis_line : LINE := representation_item('')||
                  geometric_representation_item()|| curve()||
                  line(axis.location, representation_item('')||
                  geometric_representation_item()||
                  vector(axis.z, 1.0));
  END_ENTITY;

  ENTITY revolved_face_solid
    SUBTYPE OF(swept_face_solid);
      axis      : AXIS1_PLACEMENT;
      angle     : plane_angle_measure;
    DERIVE
      axis_line : LINE := representation_item('')||
                  geometric_representation_item()|| curve()||
                  line(axis.location, representation_item('')||
                  geometric_representation_item()||
                  vector(axis.z, 1.0));
  END_ENTITY;

  ENTITY right_angular_wedge
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position : AXIS2_PLACEMENT_3D;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
      ltx      : length_measure;
    WHERE
       WR1: ((0.0 <= ltx) AND (ltx < x));
  END_ENTITY;

  ENTITY right_circular_cone
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position   : AXIS1_PLACEMENT;
      height     : positive_length_measure;
      radius     : length_measure;
      semi_angle : plane_angle_measure;
    WHERE
       WR1: radius >= 0.0;
  END_ENTITY;

  ENTITY right_circular_cylinder
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position : AXIS1_PLACEMENT;
      height   : positive_length_measure;
      radius   : positive_length_measure;
  END_ENTITY;

  ENTITY role_association;
      role           : object_role;
      item_with_role : role_select;
  END_ENTITY;

  ENTITY runout_zone_definition
    SUBTYPE OF(tolerance_zone_definition);
      orientation : runout_zone_orientation;
  END_ENTITY;

  ENTITY runout_zone_orientation;
      angle : measure_with_unit;
  END_ENTITY;

  ENTITY runout_zone_orientation_reference_direction
    SUBTYPE OF(runout_zone_orientation);
      orientation_defining_relationship : shape_aspect_relationship;
  END_ENTITY;

  ENTITY seam_curve
    SUBTYPE OF(surface_curve);
    WHERE
      WR1 : SIZEOF(SELF\surface_curve.associated_geometry) = 2;
      WR2 : associated_surface(SELF\surface_curve.associated_geometry[1]) =
            associated_surface(SELF\surface_curve.associated_geometry[2]);
      WR3 : 'GEOMETRY_SCHEMA.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[1]);
      WR4 : 'GEOMETRY_SCHEMA.PCURVE' IN
            TYPEOF(SELF\surface_curve.associated_geometry[2]);
  END_ENTITY;

  ENTITY seam_edge
    SUBTYPE OF(oriented_edge);
      pcurve_reference : PCURVE;
    WHERE
      WR1 : ( 'TOPOLOGY_SCHEMA.EDGE_CURVE' IN TYPEOF (edge_element) )  AND
            ('TOPOLOGY_SCHEMA.SEAM_CURVE' IN TYPEOF
            (edge_element\edge_curve.edge_geometry)) ;
          WR2 :  pcurve_reference IN edge_element\edge_curve.edge_geometry\
            surface_curve.associated_geometry ;
  END_ENTITY;

  ENTITY sectioned_spine
    SUBTYPE OF(geometric_curve_set);
      cross_sections : LIST [2:?] OF CURVE;
      spine_points   : LIST [2:?] OF POINT;
    WHERE
      WR1 : SIZEOF(SELF\geometric_set.elements) = 1;
      WR2 : 'GEOMETRY_SCHEMA.CURVE' IN
            TYPEOF(SELF\geometric_set.elements[1]);
      WR3 : SIZEOF(cross_sections) = SIZEOF(spine_points);
          WR4 : SELF\geometric_representation_item.dim = 3;
  END_ENTITY;

  ENTITY security_classification;
      name           : label;
      purpose        : text;
      security_level : security_classification_level;
  END_ENTITY;

  ENTITY security_classification_assignment
     ABSTRACT SUPERTYPE;
      assigned_security_classification : SECURITY_CLASSIFICATION;
    DERIVE
      role                             : object_role := get_role (SELF);
    WHERE
      WR1 : SIZEOF(USEDIN(SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.ITEM_WITH_ROLE')) <= 1;
  END_ENTITY;

  ENTITY security_classification_level;
      name : label;
  END_ENTITY;

  ENTITY serial_numbered_effectivity
    SUBTYPE OF(effectivity);
      effectivity_start_id : identifier;
      effectivity_end_id   : OPTIONAL identifier;
  END_ENTITY;

  ENTITY shape_aspect;
      name                 : label;
      description          : OPTIONAL text;
      of_shape             : product_definition_shape;
      product_definitional : LOGICAL;
    DERIVE
      id                   : identifier := get_id_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_aspect_deriving_relationship
    SUBTYPE OF(shape_aspect_relationship);
    WHERE
       WR1: 'SHAPE_ASPECT_DEFINITION_SCHEMA.DERIVED_SHAPE_ASPECT' IN
         TYPEOF
         (SELF\SHAPE_ASPECT_RELATIONSHIP.RELATING_SHAPE_ASPECT);
  END_ENTITY;

  ENTITY shape_aspect_relationship;
      name                  : label;
      description           : OPTIONAL text;
      relating_shape_aspect : shape_aspect;
      related_shape_aspect  : shape_aspect;
    DERIVE
      id                    : identifier := get_id_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.IDENTIFIED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY shape_definition_representation
    SUBTYPE OF(property_definition_representation);
    WHERE
          WR1: ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF (SELF.definition)) OR ('PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_DEFINITION' IN TYPEOF (SELF.definition.definition));
      WR2 : 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN TYPEOF(SELF.used_representation);
  END_ENTITY;

  ENTITY shape_dimension_representation
    SUBTYPE OF(shape_representation);
    WHERE
      WR1 : SIZEOF (QUERY (temp <* SELF\representation.items | 
            NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
            IN TYPEOF (temp)))) = 0;
          WR2: SIZEOF (SELF\representation.items) <= 3;
      WR3 : SIZEOF (QUERY (pos_mri <* QUERY (real_mri <*
            SELF\representation.items | 'REAL' IN TYPEOF
            (real_mri\measure_with_unit.value_component) ) |        
            NOT  (pos_mri\measure_with_unit.value_component > 0.0 ))) = 0;
  END_ENTITY;

  ENTITY shape_representation
    SUBTYPE OF(representation);
  END_ENTITY;

  ENTITY shape_representation_relationship
    SUBTYPE OF(representation_relationship);
    WHERE
       WR1: 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION' IN (TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\representation_relationship.rep_2));
  END_ENTITY;

  ENTITY shell_based_surface_model
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      sbsm_boundary : SET [1:?] OF SHELL;
    WHERE
      WR1 : constraints_geometry_shell_based_surface_model(SELF);
  END_ENTITY;

  ENTITY shell_based_wireframe_model
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      sbwm_boundary : SET [1:?] OF SHELL;
    WHERE
      WR1 : constraints_geometry_shell_based_wireframe_model(SELF);
  END_ENTITY;

  ENTITY si_unit
    SUBTYPE OF(named_unit);
      prefix                     : OPTIONAL si_prefix;
      name                       : si_unit_name;
    DERIVE
      SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit (name);
  END_ENTITY;

  ENTITY solid_angle_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.SOLID_ANGLE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY solid_angle_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY solid_model
    SUPERTYPE OF (ONEOF (
              CSG_SOLID,
              MANIFOLD_SOLID_BREP,
              SWEPT_FACE_SOLID,
              SWEPT_AREA_SOLID,
              SWEPT_DISK_SOLID,
              SOLID_REPLICA,
              BREP_2D,
              TRIMMED_VOLUME))
  SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
  END_ENTITY;

  ENTITY solid_replica
    SUBTYPE OF(solid_model);
      parent_solid   : solid_model;
      transformation : CARTESIAN_TRANSFORMATION_OPERATOR_3D;
    WHERE
      WR1 : acyclic_solid_replica(SELF, parent_solid);
          WR2: parent_solid\geometric_representation_item.dim = 3;
  END_ENTITY;

  ENTITY specified_higher_usage_occurrence
    SUBTYPE OF(assembly_component_usage);
      upper_usage : assembly_component_usage;
      next_usage  : next_assembly_usage_occurrence;
    UNIQUE
      UR1 : upper_usage, next_usage;
    WHERE
      WR1 : SELF :<>: upper_usage;
          WR2: SELF\product_definition_relationship.relating_product_definition
            :=: upper_usage.relating_product_definition;
          WR3: SELF\product_definition_relationship.related_product_definition
            :=: next_usage.related_product_definition;
          WR4: (upper_usage.related_product_definition :=:
            next_usage.relating_product_definition) OR
            (SIZEOF (QUERY (pdr <* USEDIN (upper_usage.related_product_definition,
            'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_RELATIONSHIP.' +
            'RELATED_PRODUCT_DEFINITION') |
            pdr.relating_product_definition :=: 
            next_usage.relating_product_definition)) = 1);
      WR5 : SIZEOF (['PRODUCT_STRUCTURE_SCHEMA.NEXT_ASSEMBLY_USAGE_OCCURRENCE',
            'PRODUCT_STRUCTURE_SCHEMA.SPECIFIED_HIGHER_USAGE_OCCURRENCE']
            * TYPEOF(upper_usage)) = 1;
  END_ENTITY;

  ENTITY sphere
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      radius : positive_length_measure;
      centre : POINT;
  END_ENTITY;

  ENTITY spherical_point
    SUBTYPE OF(cartesian_point);
      r                                : length_measure;
      theta                            : plane_angle_measure;
      phi                              : plane_angle_measure;
    DERIVE
      SELF\cartesian_point.coordinates : LIST [1:3] OF length_measure := 
                                         [r*sin(theta)*cos(phi), r*sin(theta)*sin(phi), r*cos(theta)];
    WHERE
       WR1: r >= 0.0;
  END_ENTITY;

  ENTITY spherical_surface
    SUBTYPE OF(elementary_surface);
      radius : positive_length_measure;
  END_ENTITY;

  ENTITY spherical_volume
    SUBTYPE OF(volume);
      position : axis2_placement_3d;
      radius   : positive_length_measure;
  END_ENTITY;

  ENTITY standard_uncertainty
    SUBTYPE OF(uncertainty_qualifier);
      uncertainty_value : REAL;
  END_ENTITY;

  ENTITY statistical_distribution_for_tolerance
    SUBTYPE OF(representation);
    WHERE
      WR1 : SIZEOF (QUERY (item <* SELF\representation.items |
            NOT ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' 
            IN TYPEOF (item)))) = 0;
  END_ENTITY;

  ENTITY subedge
    SUBTYPE OF(edge);
      parent_edge : edge;
  END_ENTITY;

  ENTITY subface
    SUBTYPE OF(face);
      parent_face : face;
    WHERE
      WR1 : NOT (mixed_loop_type_set(list_to_set(list_face_loops(SELF)) +
            list_to_set(list_face_loops(parent_face))));
  END_ENTITY;

  ENTITY surface
    SUPERTYPE OF (ONEOF (
              ELEMENTARY_SURFACE,
              SWEPT_SURFACE,
              BOUNDED_SURFACE,
              OFFSET_SURFACE,
              SURFACE_REPLICA)
              ANDOR 
              ORIENTED_SURFACE)
  SUBTYPE OF(geometric_representation_item);
  END_ENTITY;

  ENTITY surface_curve
    SUPERTYPE OF (ONEOF (
              INTERSECTION_CURVE,
              SEAM_CURVE)
              ANDOR 
              BOUNDED_SURFACE_CURVE)
  SUBTYPE OF(curve);
      curve_3d              : curve;
      associated_geometry   : LIST [1:2] OF pcurve_or_surface;
      master_representation : preferred_surface_curve_representation;
    DERIVE
      basis_surface         : SET [1:2] OF surface := get_basis_surface(SELF);
    WHERE
      WR1 : curve_3d.dim = 3;
      WR2 : ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[1])) OR
            (master_representation <> pcurve_s1);
      WR3 : ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(associated_geometry[2])) OR
            (master_representation <> pcurve_s2);
      WR4 : NOT ('GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(curve_3d));
  END_ENTITY;

  ENTITY surface_curve_swept_area_solid
    SUBTYPE OF(swept_area_solid);
      directrix         : CURVE;
      start_param       : REAL;
      end_param         : REAL;
      reference_surface : SURFACE;
    WHERE
       WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
         (reference_surface IN (directrix\surface_curve.basis_surface));
  END_ENTITY;

  ENTITY surface_curve_swept_face_solid
    SUBTYPE OF(swept_face_solid);
      directrix         : CURVE;
      start_param       : REAL;
      end_param         : REAL;
      reference_surface : SURFACE;
    WHERE
       WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
         (reference_surface IN (directrix\surface_curve.basis_surface));
  END_ENTITY;

  ENTITY surface_curve_swept_surface
    SUBTYPE OF(swept_surface);
      directrix         : curve;
      reference_surface : surface;
    WHERE
      WR1 : (NOT ('GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(directrix))) OR
            (reference_surface IN (directrix\surface_curve.basis_surface));
  END_ENTITY;

  ENTITY surface_of_linear_extrusion
    SUBTYPE OF(swept_surface);
      extrusion_axis : vector;
  END_ENTITY;

  ENTITY surface_of_revolution
    SUBTYPE OF(swept_surface);
      axis_position : axis1_placement;
    DERIVE
      axis_line     : line := representation_item('')||
                      geometric_representation_item()|| curve()||
                      line(axis_position.location, representation_item('')||
                      geometric_representation_item()||
                      vector(axis_position.z, 1.0));
  END_ENTITY;

  ENTITY surface_patch
    SUBTYPE OF(founded_item);
      parent_surface : bounded_surface;
      u_transition   : transition_code;
      v_transition   : transition_code;
      u_sense        : BOOLEAN;
      v_sense        : BOOLEAN;
    INVERSE
      using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR segments;
    WHERE
      WR1 : (NOT ('GEOMETRY_SCHEMA.CURVE_BOUNDED_SURFACE' 
            IN TYPEOF(parent_surface)));
  END_ENTITY;

  ENTITY surface_replica
    SUBTYPE OF(surface);
      parent_surface : surface;
      transformation : cartesian_transformation_operator_3d;
    WHERE
      WR1 : acyclic_surface_replica(SELF, parent_surface);
  END_ENTITY;

  ENTITY surface_texture_representation
    SUBTYPE OF(REPRESENTATION);
    WHERE
      WR1 : SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
            ['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,
            'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE' , 'SURFACE_CONDITIONS_MIM.'+
            'DESCRIPTIVE_REPRESENTATION_ITEM']* TYPEOF ( i ) ) <>1 ) )
            =0;
      WR2 : ( SIZEOF ( QUERY ( i <* SELF.items | 'SURFACE_CONDITIONS_MIM.'+
            'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) ) =1 )
            AND ( SIZEOF ( QUERY ( i <* SELF.items | (
            'SURFACE_CONDITIONS_MIM.'+ 'DESCRIPTIVE_REPRESENTATION_ITEM' IN
            TYPEOF ( i ) ) AND ( i.name = 'measuring method' ) ) ) =1 )
            ;
      WR3 : SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
            ['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,
            'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) =1 ) )
            >0;
      WR4 : ( SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+
            'REP_1' ) ) <=1 ) AND ( SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+
            'REP_2' ) ) =0 ) AND ( SIZEOF ( QUERY ( rr <* USEDIN ( SELF
            , 'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+
            'REP_1' ) | rr. rep_2.name = 'measuring direction' ) ) =
            SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'REPRESENTATION_RELATIONSHIP.'+
            'REP_1' ) ) ) ;
      WR5 : ( SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
            <* USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
            pdr. definition ,
            'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+
            'DERIVED_DEFINITION' ) | ( 'SURFACE_CONDITIONS_MIM.'+
            'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
            ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
            ) =1 ) ;
  END_ENTITY;

  ENTITY swept_area_solid
    SUPERTYPE OF (ONEOF (
              REVOLVED_AREA_SOLID,
              EXTRUDED_AREA_SOLID,
              SURFACE_CURVE_SWEPT_AREA_SOLID))
  SUBTYPE OF(solid_model);
      swept_area : CURVE_BOUNDED_SURFACE;
    WHERE
       WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_area.basis_surface);
  END_ENTITY;

  ENTITY swept_disk_solid
    SUBTYPE OF(solid_model);
      directrix    : CURVE;
      radius       : positive_length_measure;
      inner_radius : OPTIONAL positive_length_measure;
      start_param  : REAL;
      end_param    : REAL;
    WHERE
       WR1 : directrix.dim = 3;
       WR2 : (NOT EXISTS(inner_radius)) OR (radius > inner_radius) ;
  END_ENTITY;

  ENTITY swept_face_solid
    SUPERTYPE OF (ONEOF (
              EXTRUDED_FACE_SOLID,
              REVOLVED_FACE_SOLID,
              SURFACE_CURVE_SWEPT_FACE_SOLID))
  SUBTYPE OF(solid_model);
      swept_face : FACE_SURFACE;
    WHERE
       WR1: 'GEOMETRY_SCHEMA.PLANE' IN TYPEOF(swept_face.face_geometry);
  END_ENTITY;

  ENTITY swept_surface
    SUPERTYPE OF (ONEOF (
              SURFACE_OF_LINEAR_EXTRUSION,
              SURFACE_OF_REVOLUTION,
              SURFACE_CURVE_SWEPT_SURFACE,
              FIXED_REFERENCE_SWEPT_SURFACE))
  SUBTYPE OF(surface);
      swept_curve : curve;
  END_ENTITY;

  ENTITY symmetric_shape_aspect
    SUBTYPE OF(shape_aspect);
    INVERSE
      basis_relationships : SET [1:?] OF shape_aspect_relationship FOR relating_shape_aspect;
    WHERE
      WR1 : SIZEOF (QUERY (x<*SELF\symmetric_shape_aspect.basis_relationships |
            'SHAPE_ASPECT_DEFINITION_SCHEMA.CENTRE_OF_SYMMETRY' IN TYPEOF 
            (x\shape_aspect_relationship.related_shape_aspect)))>=1;
  END_ENTITY;

  ENTITY tactile_appearance_representation
    SUBTYPE OF(REPRESENTATION);
    WHERE
      WR1 : SIZEOF ( QUERY ( i <* SELF.items | SIZEOF (
            ['SURFACE_CONDITIONS_MIM.'+ 'MEASURE_REPRESENTATION_ITEM' ,
            'SURFACE_CONDITIONS_MIM.'+ 'VALUE_RANGE']* TYPEOF ( i ) ) <>1 )
            ) =0;
      WR2 : SIZEOF ( QUERY ( i <* SELF.items | name ='depth' ) ) <=1;
      WR3 : ( SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
            <* USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
            pdr. definition ,
            'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+
            'DERIVED_DEFINITION' ) | ( 'SURFACE_CONDITIONS_MIM.'+
            'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
            ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
            ) =1 ) ;
  END_ENTITY;

  ENTITY tangent
    SUBTYPE OF(derived_shape_aspect);
    WHERE
      WR1 : SIZEOF (SELF\derived_shape_aspect.deriving_relationships)= 1;
  END_ENTITY;

  ENTITY tetrahedron
    SUBTYPE OF(faceted_primitive);
    WHERE
      WR1 : SIZEOF(points) = 4 ;
          WR2: above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
  END_ENTITY;

  ENTITY tetrahedron_volume
    SUBTYPE OF(volume);
      point_1 : cartesian_point;
      point_2 : cartesian_point;
      point_3 : cartesian_point;
      point_4 : cartesian_point;
    WHERE
      WR1 : point_1.dim = 3 ;
      WR2 : above_plane(point_1, point_2, point_3, point_4) <> 0.0 ;
  END_ENTITY;

  ENTITY thermodynamic_temperature_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY thermodynamic_temperature_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 0.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY time_assignment
     ABSTRACT SUPERTYPE;
      assigned_time : LOCAL_TIME;
      role          : TIME_ROLE;
  END_ENTITY;

  ENTITY time_interval;
      id          : identifier;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY time_interval_assignment
     ABSTRACT SUPERTYPE;
      assigned_time_interval : TIME_INTERVAL;
      role                   : TIME_INTERVAL_ROLE;
  END_ENTITY;

  ENTITY time_interval_based_effectivity
    SUBTYPE OF(effectivity);
      effectivity_period : time_interval;
  END_ENTITY;

  ENTITY time_interval_relationship;
      name                   : label;
      description            : OPTIONAL text;
      relating_time_interval : time_interval;
      related_time_interval  : time_interval;
  END_ENTITY;

  ENTITY time_interval_role;
      name        : label;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY time_interval_with_bounds
    SUBTYPE OF(time_interval);
      primary_bound   : OPTIONAL date_time_or_event_occurrence;
      secondary_bound : OPTIONAL date_time_or_event_occurrence;
      duration        : OPTIONAL time_measure_with_unit;
    WHERE
      WR1 : NOT (EXISTS(secondary_bound) AND EXISTS(duration));
      WR2 : EXISTS(primary_bound) OR EXISTS(secondary_bound);
  END_ENTITY;

  ENTITY time_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.TIME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY time_role;
      name        : label;
    DERIVE
      description : text := get_description_value (SELF);
    WHERE
      WR1 : SIZEOF (USEDIN (SELF, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM')) <= 1;
  END_ENTITY;

  ENTITY time_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit.dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.time_exponent = 1.0) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.0);
  END_ENTITY;

  ENTITY tolerance_value;
      lower_bound : measure_with_unit;
      upper_bound : measure_with_unit;
    WHERE
       WR1: upper_bound\measure_with_unit.value_component >
         lower_bound\measure_with_unit.value_component;
       WR2: upper_bound\measure_with_unit.unit_component =
         lower_bound\measure_with_unit.unit_component;
  END_ENTITY;

  ENTITY tolerance_with_statistical_distribution;
      associated_tolerance : shape_tolerance_select;
      tolerance_allocation : statistical_distribution_for_tolerance;
  END_ENTITY;

  ENTITY tolerance_zone
    SUBTYPE OF(shape_aspect);
      defining_tolerance : SET [1:?] OF geometric_tolerance;
      form               : tolerance_zone_form;
  END_ENTITY;

  ENTITY tolerance_zone_definition
    SUPERTYPE OF (ONEOF (
              PROJECTED_ZONE_DEFINITION,
              RUNOUT_ZONE_DEFINITION));
      zone       : tolerance_zone;
      boundaries : SET [1:?] OF shape_aspect;
  END_ENTITY;

  ENTITY tolerance_zone_form;
      name : label;
  END_ENTITY;

  ENTITY topological_representation_item
    SUPERTYPE OF (ONEOF (
              VERTEX,
              EDGE,
              FACE_BOUND,
              FACE,
              VERTEX_SHELL,
              WIRE_SHELL,
              CONNECTED_EDGE_SET,
              CONNECTED_FACE_SET,
              LOOP
              ANDOR 
              PATH))
  SUBTYPE OF(representation_item);
  END_ENTITY;

  ENTITY toroidal_surface
    SUBTYPE OF(elementary_surface);
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
  END_ENTITY;

  ENTITY toroidal_volume
    SUBTYPE OF(volume);
      position     : axis2_placement_3d;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
    WHERE
       WR1 : minor_radius < major_radius;
  END_ENTITY;

  ENTITY torus
    SUBTYPE OF(GEOMETRIC_REPRESENTATION_ITEM);
      position     : AXIS1_PLACEMENT;
      major_radius : positive_length_measure;
      minor_radius : positive_length_measure;
    WHERE
       WR1: major_radius > minor_radius;
  END_ENTITY;

  ENTITY trimmed_curve
    SUBTYPE OF(bounded_curve);
      basis_curve           : curve;
      trim_1                : SET [1:2] OF trimming_select;
      trim_2                : SET [1:2] OF trimming_select;
      sense_agreement       : BOOLEAN;
      master_representation : trimming_preference;
    WHERE
      WR1 : (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
      WR2 : (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
  END_ENTITY;

  ENTITY trimmed_volume
    SUBTYPE OF(solid_model);
      basis_volume : VOLUME;
      u1           : parameter_value;
      u2           : parameter_value;
      v1           : parameter_value;
      v2           : parameter_value;
      w1           : parameter_value;
      w2           : parameter_value;
    WHERE
       WR1 : u1 <> u2;
       WR2 : v1 <> v2;
       WR3 : w1 <> w2;
  END_ENTITY;

  ENTITY type_qualifier;
      name : label;
  END_ENTITY;

  ENTITY uncertainty_assigned_representation
    SUBTYPE OF(representation);
      uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
  END_ENTITY;

  ENTITY uncertainty_measure_with_unit
    SUBTYPE OF(measure_with_unit);
      name        : label;
      description : OPTIONAL text;
    WHERE
      WR1 : valid_measure_value (SELF\measure_with_unit.value_component);
  END_ENTITY;

  ENTITY uncertainty_qualifier
    SUPERTYPE OF (ONEOF (
              STANDARD_UNCERTAINTY,
              QUALITATIVE_UNCERTAINTY));
      measure_name : label;
      description  : text;
  END_ENTITY;

  ENTITY uniform_curve
    SUBTYPE OF(b_spline_curve);
  END_ENTITY;

  ENTITY uniform_surface
    SUBTYPE OF(b_spline_surface);
  END_ENTITY;

  ENTITY uniform_volume
    SUBTYPE OF(b_spline_volume);
  END_ENTITY;

  ENTITY value_range
    SUBTYPE OF(compound_representation_item);
    WHERE
          WR1: ( 'value_with_unit_mim.'+ 'SET_REPRESENTATION_ITEM' IN TYPEOF ( item_element ) ) AND value_range_wr1 ( item_element );
      WR2 : value_range_wr2 ( item_element );
      WR3 : value_range_wr3 ( item_element );
  END_ENTITY;

  ENTITY value_representation_item
    SUBTYPE OF(representation_item);
      value_component : measure_value;
    WHERE
      WR1 : SIZEOF (QUERY (rep <* using_representations (SELF) |
            NOT ('MEASURE_SCHEMA.GLOBAL_UNIT_ASSIGNED_CONTEXT'
            IN TYPEOF (rep.context_of_items)
            ))) = 0;
  END_ENTITY;

  ENTITY vector
    SUBTYPE OF(geometric_representation_item);
      orientation : direction;
      magnitude   : length_measure;
    WHERE
       WR1 : magnitude >= 0.0;
  END_ENTITY;

  ENTITY versioned_action_request;
      id          : identifier;
      version     : label;
      purpose     : text;
      description : OPTIONAL text;
  END_ENTITY;

  ENTITY versioned_action_request_relationship;
      id                                : identifier;
      name                              : label;
      description                       : OPTIONAL text;
      relating_versioned_action_request : versioned_action_request;
      related_versioned_action_request  : versioned_action_request;
  END_ENTITY;

  ENTITY vertex
    SUBTYPE OF(topological_representation_item);
  END_ENTITY;

  ENTITY vertex_loop
    SUBTYPE OF(loop);
      loop_vertex : vertex;
  END_ENTITY;

  ENTITY vertex_point
    SUBTYPE OF(vertex, GEOMETRIC_REPRESENTATION_ITEM);
      vertex_geometry : POINT;
  END_ENTITY;

  ENTITY vertex_shell
    SUBTYPE OF(topological_representation_item);
      vertex_shell_extent : vertex_loop;
  END_ENTITY;

  ENTITY visual_appearance_representation
    SUBTYPE OF(REPRESENTATION);
    WHERE
          WR1: ( {2<= SIZEOF ( SELF.items ) <=5} ) AND ( SIZEOF ( QUERY (
            i <* items | ( 'SURFACE_CONDITIONS_MIM.'+
            'DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND (
            i.name IN [ 'colour id' , 'colour name' , 'lustre' ,
            'pattern' , 'transparency'] ) ) ) = SIZEOF ( SELF.items ) )
            ;
      WR2 : SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour id' )
            ) =1;
      WR3 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='lustre' ) )
            =1;
      WR4 : SIZEOF ( QUERY ( i <* SELF.items | i.name = 'colour name'
            ) ) <=1;
      WR5 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='pattern' ) )
            <=1;
      WR6 : SIZEOF ( QUERY ( i <* SELF.items | i.name ='transparency'
            ) ) <=1;
      WR7 : ( SIZEOF ( USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) ) =1 ) AND ( SIZEOF ( QUERY ( pdr
            <* USEDIN ( SELF ,
            'SURFACE_CONDITIONS_MIM.'+'PROPERTY_DEFINITION_REPRESENTATION.'+
            'USED_REPRESENTATION' ) | SIZEOF ( QUERY ( gpa <* USEDIN (
            pdr. definition ,
            'SURFACE_CONDITIONS_MIM.'+'GENERAL_PROPERTY_ASSOCIATION.'+
            'DERIVED_DEFINITION' ) | ( 'SURFACE_CONDITIONS_MIM.'+
            'GENERAL_PROPERTY' IN TYPEOF ( gpa. base_definition ) ) AND
            ( gpa. base_definition.name ='surface_condition' ) ) ) =1 )
            ) =1 ) ;
  END_ENTITY;

  ENTITY volume
    SUPERTYPE OF (ONEOF (
              BLOCK_VOLUME,
              WEDGE_VOLUME,
              SPHERICAL_VOLUME,
              CYLINDRICAL_VOLUME,
              ECCENTRIC_CONICAL_VOLUME,
              TOROIDAL_VOLUME,
              PYRAMID_VOLUME,
              B_SPLINE_VOLUME,
              ELLIPSOID_VOLUME,
              TETRAHEDRON_VOLUME,
              HEXAHEDRON_VOLUME))
  SUBTYPE OF(geometric_representation_item);
    WHERE
      WR1 : SELF\geometric_representation_item.dim = 3;
  END_ENTITY;

  ENTITY volume_measure_with_unit
    SUBTYPE OF(measure_with_unit);
    WHERE
      WR1 : 'MEASURE_SCHEMA.VOLUME_UNIT' IN TYPEOF (SELF\measure_with_unit.unit_component);
  END_ENTITY;

  ENTITY volume_unit
    SUBTYPE OF(named_unit);
    WHERE
      WR1 : (SELF\named_unit.dimensions.length_exponent = 3.000000) AND (SELF\named_unit.dimensions.mass_exponent = 0.000000) AND (SELF\named_unit.dimensions.time_exponent = 0.000000) AND (SELF\named_unit.dimensions.electric_current_exponent = 0.000000) AND (SELF\named_unit.dimensions.thermodynamic_temperature_exponent = 0.000000) AND (SELF\named_unit.dimensions.amount_of_substance_exponent = 0.000000) AND (SELF\named_unit.dimensions.luminous_intensity_exponent = 0.000000);
  END_ENTITY;

  ENTITY wedge_volume
    SUBTYPE OF(volume);
      position : axis2_placement_3d;
      x        : positive_length_measure;
      y        : positive_length_measure;
      z        : positive_length_measure;
      ltx      : length_measure;
    WHERE
       WR1: ((0.0 <= ltx) AND (ltx < x));
  END_ENTITY;

  ENTITY week_of_year_and_day_date
    SUBTYPE OF(date);
      week_component : week_in_year_number;
      day_component  : OPTIONAL day_in_week_number;
  END_ENTITY;

  ENTITY wire_shell
    SUBTYPE OF(topological_representation_item);
      wire_shell_extent : SET [1:?] OF loop;
    WHERE
      WR1 : NOT mixed_loop_type_set(wire_shell_extent);
  END_ENTITY;

  FUNCTION above_plane
  (p1, p2, p3, p4 : cartesian_point) : REAL;
     LOCAL
       dir2, dir3, dir4 : direction :=
                   dummy_gri || direction([1.0, 0.0, 0.0]);
       val, mag         : REAL;
     END_LOCAL;
  
     IF (p1.dim <> 3) THEN
       RETURN(?);
     END_IF;
     REPEAT i := 1 TO 3;
       dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
       dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
       dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
       mag := dir4.direction_ratios[i]*dir4.direction_ratios[i];
    END_REPEAT;
    mag := sqrt(mag);
    val := mag*dot_product(dir4, cross_product(dir2, dir3).orientation);
    RETURN(val);

  END_FUNCTION;

  FUNCTION acyclic_action_method_relationship
  (relation : action_method_relationship; relatives : SET [1:?] OF action_method; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF action_method_relationship;
      END_LOCAL;
  
      IF relation.relating_method IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 'ACTION_SCHEMA.' + 'ACTION_METHOD_RELATIONSHIP.' + 'RELATED_METHOD')) | specific_relation IN TYPEOF(am));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_action_method_relationship(x[i], relatives + relation.relating_method, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_action_relationship
  (relation : action_relationship; relatives : SET [1:?] OF action; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF action_relationship;
      END_LOCAL;
  
      IF relation.relating_action IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 'ACTION_SCHEMA.' + 'ACTION_RELATIONSHIP.' + 'RELATED_ACTION')) | specific_relation IN TYPEOF(actn));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_action_relationship(x[i], relatives + relation.relating_action, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_action_resource_relationship
  (relation : action_resource_relationship; relatives : SET [1:?] OF action_resource; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF action_resource_relationship;
      END_LOCAL;
  
      IF relation.relating_resource IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 'ACTION_SCHEMA.' + 'ACTION_RESOURCE_RELATIONSHIP.' + 'RELATED_RESOURCE')) | specific_relation IN TYPEOF(ar));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.relating_resource, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_approval_relationship
  (relation : approval_relationship; relatives : SET[1:?] OF approval; specific_relation : STRING) : BOOLEAN; 
   LOCAL
        x : SET OF approval_relationship;
      END_LOCAL;
  
      IF relation.relating_approval IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 'APPROVAL_SCHEMA.' + 'APPROVAL_RELATIONSHIP.' + 'RELATED_APPROVAL')) | specific_relation IN TYPEOF(app));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_approval_relationship(x[i], relatives + relation.relating_approval, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_characterized_object_relationship
  (relation : characterized_object_relationship; relatives : SET[1:?] OF characterized_object; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF characterized_object_relationship;
      END_LOCAL;
  
      IF relation.relating_object IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'CHARACTERIZED_OBJECT_RELATIONSHIP.' + 'RELATED_OBJECT')) | specific_relation IN TYPEOF(ca));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation.relating_object, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
  RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_contract_relationship
  (relation : contract_relationship; relatives : SET[1:?] OF contract; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF contract_relationship;
      END_LOCAL;
  
      IF relation.relating_contract IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 'CONTRACT_SCHEMA.' + 'CONTRACT_RELATIONSHIP.' + 'RELATED_CONTRACT')) | specific_relation IN TYPEOF(cont));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_contract_relationship(x[i], relatives + relation.relating_contract, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_curve_replica
  (rep : curve_replica; parent : curve)
                                                : BOOLEAN;
     IF NOT (('GEOMETRY_SCHEMA.CURVE_REPLICA') IN TYPEOF(parent)) THEN
        RETURN (TRUE);
     END_IF;
   (* Return TRUE if the parent is not of type curve_replica *)
     IF (parent :=: rep) THEN
        RETURN (FALSE);
    (* Return FALSE if the parent is the same curve_replica, otherwise,
     call function again with the parents own parent_curve.     *)
      ELSE
      RETURN(acyclic_curve_replica(rep,
                 parent\curve_replica.parent_curve));
      END_IF;

  END_FUNCTION;

  FUNCTION acyclic_document_relationship
  (relation : document_relationship; relatives : SET[1:?] OF document; specific_relation : STRING) : BOOLEAN; 
   LOCAL
        x : SET OF document_relationship;
      END_LOCAL;
  
      IF relation.relating_document IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 'DOCUMENT_SCHEMA.' + 'DOCUMENT_RELATIONSHIP.' + 'RELATED_DOCUMENT')) | specific_relation IN TYPEOF(doc));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_document_relationship(x[i], relatives + relation.relating_document, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_effectivity_relationship
  (relation : effectivity_relationship; relatives : SET[1:?] OF effectivity; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF effectivity_relationship;
      END_LOCAL;
  
      IF relation.relating_effectivity IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 'EFFECTIVITY_SCHEMA.' + 'EFFECTIVITY_RELATIONSHIP.' + 'RELATED_EFFECTIVITY')) | specific_relation IN TYPEOF(eff));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.relating_effectivity, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_event_occurrence_relationship
  (relation : event_occurrence_relationship; relatives : SET[1:?] OF event_occurrence; specific_relation : STRING) : BOOLEAN; 
   LOCAL
        x : SET OF event_occurrence_relationship;
      END_LOCAL;
  
      IF relation.relating_event IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 'DATE_TIME_SCHEMA.' + 'EVENT_OCCURRENCE_RELATIONSHIP.' + 'RELATED_EVENT')) | specific_relation IN TYPEOF(evnt));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.relating_event, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_experience_relationship
  (relation : experience_relationship; relatives : SET OF experience; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF experience_relationship;
      END_LOCAL;
  
      IF relation.relating_experience IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(expr <* bag_to_set(USEDIN(relation.relating_experience, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_RELATIONSHIP.' + 'RELATED_EXPERIENCE')) | specific_relation IN TYPEOF(expr));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_experience_relationship(x[i], relatives + relation.relating_experience, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_experience_type_relationship
  (relation : experience_type_relationship; relatives : SET OF experience_type; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF experience_type_relationship;
      END_LOCAL;
  
      IF relation.relating_experience_type IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(exptyp <* bag_to_set(USEDIN(relation.relating_experience_type, 'EXPERIENCE_SCHEMA.' + 'EXPERIENCE_TYPE_RELATIONSHIP.' + 'RELATED_EXPERIENCE_TYPE')) | specific_relation IN TYPEOF(exptyp));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_experience_type_relationship(x[i], relatives + relation.relating_experience_type, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_external_source_relationship
  (relation : external_source_relationship; relatives : SET[1:?] OF external_source; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF external_source_relationship;
      END_LOCAL;
  
      IF relation.relating_source IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNAL_SOURCE_RELATIONSHIP.' + 'RELATED_SOURCE')) | specific_relation IN TYPEOF(es));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_external_source_relationship(x[i], relatives + relation.relating_source, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_externally_defined_item_relationship
  (relation : externally_defined_item_relationship; relatives : SET[1:?] OF externally_defined_item; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF externally_defined_item_relationship;
      END_LOCAL;
  
      IF relation.relating_item IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 'EXTERNAL_REFERENCE_SCHEMA.' + 'EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.' + 'RELATED_ITEM')) | specific_relation IN TYPEOF(edi));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + relation.relating_item, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_general_property_relationship
  (relation : general_property_relationship; relatives : SET[1:?] OF general_property; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF general_property_relationship;
      END_LOCAL;
  
      IF relation.relating_property IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'GENERAL_PROPERTY_RELATIONSHIP.' + 'RELATED_PROPERTY')) | specific_relation IN TYPEOF(genp));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_general_property_relationship(x[i], relatives + relation.relating_property, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_group_relationship
  (relation : group_relationship; relatives : SET[1:?] OF group; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF group_relationship;
      END_LOCAL;
  
      IF relation.relating_group IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 'GROUP_SCHEMA.' + 'GROUP_RELATIONSHIP.' + 'RELATED_GROUP')) | specific_relation IN TYPEOF(grp));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_identification_assignment_relationship
  (relation : identification_assignment_relationship; relatives : SET[1:?] OF identification_assignment; specific_relation : STRING) : BOOLEAN; 
   LOCAL
        x : SET OF identification_assignment_relationship;
      END_LOCAL;
  
      IF relation.relating_identification_assignment IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(ia <* bag_to_set(USEDIN(relation.relating_identification_assignment, 'MANAGEMENT_RESOURCES_SCHEMA.' + 'IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.' + 'RELATED_IDENTIFICATION_ASSIGNMENT')) | specific_relation IN TYPEOF(ia));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_identification_assignment_relationship(x[i], relatives + relation.relating_identification_assignment, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_location_relationship
  (relation : location_relationship; relatives : SET OF location; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF location_relationship;
      END_LOCAL;
  
      IF relation.relating_location IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(lctn <* bag_to_set(USEDIN(relation.relating_location, 'LOCATION_SCHEMA.' + 'LOCATION_RELATIONSHIP.' + 'RELATED_LOCATION')) | specific_relation IN TYPEOF(lctn));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_location_relationship(x[i], relatives + relation.relating_location, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_mapped_representation
  (parent_set   : SET OF representation;
     children_set : SET OF representation_item) : BOOLEAN;
    LOCAL
      x,y : SET OF representation_item;
    END_LOCAL;
    -- Determine the subset of children_set that are mapped_items
    x := QUERY(z <* children_set | 'REPRESENTATION_SCHEMA.MAPPED_ITEM'
         IN TYPEOF(z));
    -- Determine that the subset has elements
    IF SIZEOF(x) > 0 THEN
      -- Check each element of the set
      REPEAT i := 1 TO HIINDEX(x);
        -- If the selected element maps a representation in the
        -- parent_set, then return false
        IF x[i]\mapped_item.mapping_source.mapped_representation
          IN parent_set THEN
          RETURN (FALSE);
        END_IF;
        -- Recursive check of the items of mapped_representation
        IF NOT acyclic_mapped_representation
          (parent_set +
          x[i]\mapped_item.mapping_source.mapped_representation,
          x[i]\mapped_item.mapping_source.mapped_representation.items) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    -- Determine the subset of children_set that are not
    -- mapped_items
    x := children_set - x;
    -- Determine that the subset has elements
    IF SIZEOF(x) > 0 THEN
      -- For each element of the set:
      REPEAT i := 1 TO HIINDEX(x);
        -- Determine the set of representation_items referenced
        y := QUERY(z <* bag_to_set( USEDIN(x[i], '')) |
             'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Recursively check for an offending mapped_item
        -- Return false for any errors encountered
        IF NOT acyclic_mapped_representation(parent_set, y) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return true when all elements are checked and
    -- no error conditions found
    RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_organization_relationship
  (relation : organization_relationship; relatives : SET [1:?] OF organization; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF organization_relationship;
      END_LOCAL;
  
      IF relation.relating_organization IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_RELATIONSHIP.' + 'RELATED_ORGANIZATION')) | specific_relation IN TYPEOF(org));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_organization_relationship(x[i], relatives + relation.relating_organization, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_organization_type_relationship
  (relation : organization_type_relationship; relatives : SET OF organization_type; specific_relation : STRING) : BOOLEAN; 
     LOCAL
        x : SET OF organization_type_relationship;
      END_LOCAL;
  
      IF relation.relating_organization_type IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(orgtyp <* bag_to_set(USEDIN(relation.relating_organization_type, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATION_TYPE_RELATIONSHIP.' + 'RELATED_ORGANIZATION_TYPE')) | specific_relation IN TYPEOF(orgtyp));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_organization_type_relationship(x[i], relatives + relation.relating_organization_type, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_organizational_project_relationship
  (relation : organizational_project_relationship; relatives : SET [1:?] OF organizational_project; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF organizational_project_relationship;
      END_LOCAL;
  
      IF relation.relating_organizational_project IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 'PERSON_ORGANIZATION_SCHEMA.' + 'ORGANIZATIONAL_PROJECT_RELATIONSHIP.' + 'RELATED_ORGANIZATIONAL_PROJECT')) | specific_relation IN TYPEOF(op));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_organizational_project_relationship(x[i], relatives + relation.relating_organizational_project, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_person_type_definition_relationship
  (relation : person_type_definition_relationship; relatives : SET OF person_type_definition; specific_relation : STRING) : BOOLEAN; 
     LOCAL
        x : SET OF person_type_definition_relationship;
      END_LOCAL;
  
      IF relation.relating_person_type_definition IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(ptdef <* bag_to_set(USEDIN(relation.relating_person_type_definition, 'PERSON_ORGANIZATION_SCHEMA.' + 'PERSON_TYPE_DEFINITION_RELATIONSHIP.' + 'RELATED_PERSON_TYPE_DEFINITION')) | specific_relation IN TYPEOF(ptdef));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_person_type_definition_relationship(x[i], relatives + relation.relating_person_type_definition, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_point_replica
  (rep : point_replica; parent : point)
                                                : BOOLEAN;
     IF NOT (('GEOMETRY_SCHEMA.POINT_REPLICA') IN TYPEOF(parent)) THEN
        RETURN (TRUE);
     END_IF;
   (* Return TRUE if the parent is not of type point_replica *)
     IF (parent :=: rep) THEN
        RETURN (FALSE);
    (* Return FALSE if the parent is the same point_replica, otherwise,
     call function again with the parents own parent_pt.     *)
      ELSE RETURN(acyclic_point_replica(rep, parent\point_replica.parent_pt));
      END_IF;

  END_FUNCTION;

  FUNCTION acyclic_position_in_organization_relationship
  (relation : position_in_organization_relationship; relatives : SET OF position_in_organization; specific_relation : STRING) : BOOLEAN; 
     LOCAL
        x : SET OF position_in_organization_relationship;
      END_LOCAL;
  
      IF relation.relating_position_in_organization IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(piorg <* bag_to_set(USEDIN(relation.relating_position_in_organization, 'PERSON_ORGANIZATION_SCHEMA.' + 'POSITION_IN_ORGANIZATION_RELATIONSHIP.' + 'RELATED_POSITION_IN_ORGANIZATION')) | specific_relation IN TYPEOF(piorg));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_position_in_organization_relationship(x[i], relatives + relation.relating_position_in_organization, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_product_category_relationship
  (relation : product_category_relationship; children : SET OF product_category) : BOOLEAN; 
  LOCAL
        x : SET OF product_category_relationship;
        local_children : SET OF product_category;
      END_LOCAL;
  
      REPEAT i := 1 TO HIINDEX(children);
        IF relation.category :=: children[i] THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      x := bag_to_set(USEDIN(relation.category, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'));
      local_children := children + relation.category;
      IF SIZEOF(x) > 0 THEN
        REPEAT i := 1 TO HIINDEX(x);
          IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
            RETURN (FALSE);
          END_IF;
        END_REPEAT;
      END_IF;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_product_definition_formation_relationship
  (relation : product_definition_formation_relationship; relatives : SET[1:?] OF product_definition_formation; specific_relation : STRING) : BOOLEAN; 
   LOCAL
        x : SET OF product_definition_formation_relationship;
      END_LOCAL;
  
      IF relation.relating_product_definition_formation IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(pdf <* bag_to_set(USEDIN(relation.relating_product_definition_formation, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION_FORMATION')) | specific_relation IN TYPEOF(pdf));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + relation.relating_product_definition_formation, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_product_definition_relationship
  (relation : product_definition_relationship; relatives : SET[1:?] OF product_definition; specific_relation : STRING) : BOOLEAN; 
  LOCAL
        x : SET OF product_definition_relationship;
      END_LOCAL;
  
      IF relation.relating_product_definition IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_DEFINITION_RELATIONSHIP.' + 'RELATED_PRODUCT_DEFINITION')) | specific_relation IN TYPEOF(pd));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.relating_product_definition, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
  RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_product_relationship
  (relation : product_relationship; relatives : SET[1:?] OF product; specific_relation : STRING) : BOOLEAN; 
   LOCAL
        x : SET OF product_relationship;
      END_LOCAL;
  
      IF relation.relating_product IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 'PRODUCT_DEFINITION_SCHEMA.' + 'PRODUCT_RELATIONSHIP.' + 'RELATED_PRODUCT')) | specific_relation IN TYPEOF(prod));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_product_relationship(x[i], relatives + relation.relating_product, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_property_definition_relationship
  (relation          : property_definition_relationship;
     relatives         : SET [1:?] OF property_definition;
     specific_relation : STRING) : LOGICAL;
  
    LOCAL
      x                : SET OF property_definition_relationship;
    END_LOCAL;
  
    IF relation.relating_property_definition IN 
              relatives THEN
      RETURN (FALSE);
    END_IF;             -- IN is based in instance equality
  
    x := QUERY (pd <* bag_to_set (USEDIN
         (relation.relating_property_definition,
          'MATERIAL_PROPERTY_DEFINITION_SCHEMA.' +
          'PROPERTY_DEFINITION_RELATIONSHIP.' +
          'RELATED_PROPERTY_DEFINITION')) |
           specific_relation IN TYPEOF (pd));
  
    REPEAT I := 1 TO HIINDEX(x);             -- pre-checked loop
      IF NOT acyclic_property_definition_relationship
        (x[i],
         relatives + relation.relating_property_definition,
         specific_relation) THEN
        RETURN(FALSE);
      END_IF;
    END_REPEAT;
  
    RETURN(TRUE);

  END_FUNCTION;

  FUNCTION acyclic_qualification_relationship
  (relation : qualification_relationship; relatives : SET OF qualification; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF qualification_relationship;
      END_LOCAL;
  
      IF relation.relating_qualification IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(qual <* bag_to_set(USEDIN(relation.relating_qualification, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_RELATIONSHIP.' + 'RELATED_QUALIFICATION')) | specific_relation IN TYPEOF(qual));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_qualification_relationship(x[i], relatives + relation.relating_qualification, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_qualification_type_relationship
  (relation : qualification_type_relationship; relatives : SET OF qualification_type; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF qualification_type_relationship;
      END_LOCAL;
  
      IF relation.relating_qualification_type IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(qultyp <* bag_to_set(USEDIN(relation.relating_qualification_type, 'QUALIFICATIONS_SCHEMA.' + 'QUALIFICATION_TYPE_RELATIONSHIP.' + 'RELATED_QUALIFICATION_TYPE')) | specific_relation IN TYPEOF(qultyp));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_qualification_type_relationship(x[i], relatives + relation.relating_qualification_type, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_set_replica
  (rep : geometric_set_replica;
                             parent : geometric_set) : BOOLEAN;
     IF NOT (('GEOMETRY_SCHEMA.GEOMETRIC_SET_REPLICA') IN TYPEOF(parent))
          THEN  RETURN (TRUE);
     END_IF;
   (* Return TRUE if the parent is not of type geometric_set_replica *)
     IF (parent :=: rep) THEN
        RETURN (FALSE);
    (* Return FALSE if the parent is the same geometric_set_replica,
       otherwise, call function again with the parents own parent_set.  *)
      ELSE RETURN(acyclic_set_replica(rep,
                            parent\geometric_set_replica.parent_set));
      END_IF;

  END_FUNCTION;

  FUNCTION acyclic_shape_aspect_relationship
  (relation : shape_aspect_relationship; relatives : SET[1:?] OF shape_aspect; specific_relation : STRING) : BOOLEAN; 
   LOCAL
        x : SET OF shape_aspect_relationship;
      END_LOCAL;
  
      IF relation.relating_shape_aspect IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.' + 'SHAPE_ASPECT_RELATIONSHIP.' + 'RELATED_SHAPE_ASPECT')) | specific_relation IN TYPEOF(sa));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.relating_shape_aspect, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_solid_replica
  (rep : solid_replica; parent :
                      solid_model) : BOOLEAN;
     IF NOT (('GEOMETRY_SCHEMA.SOLID_REPLICA') IN TYPEOF(parent)) THEN
        RETURN (TRUE);
     END_IF;
   (* Return TRUE if the parent is not of type solid_replica. *)
     IF (parent :=: rep) THEN
        RETURN (FALSE);
    (* Return FALSE if the parent is the same solid_replica, otherwise,
     call function again with the parents own parent_solid.     *)
      ELSE RETURN(acyclic_solid_replica(rep,
                        parent\solid_replica.parent_solid));
      END_IF;

  END_FUNCTION;

  FUNCTION acyclic_surface_replica
  (rep : surface_replica; parent : surface)
                                                : BOOLEAN;
     IF NOT (('GEOMETRY_SCHEMA.SURFACE_REPLICA') IN TYPEOF(parent)) THEN
        RETURN (TRUE);
     END_IF;
   (* Return TRUE if the parent is not of type surface_replica *)
     IF (parent :=: rep) THEN
        RETURN (FALSE);
    (* Return FALSE if the parent is the same surface_replica, otherwise,
     call function again with the parents own parent_surface.     *)
      ELSE RETURN(acyclic_surface_replica(rep,
                     parent\surface_replica.parent_surface));
      END_IF;

  END_FUNCTION;

  FUNCTION acyclic_time_interval_relationship
  (relation : time_interval_relationship; relatives : SET[1:?] OF time_interval; specific_relation : STRING) : BOOLEAN; 
    LOCAL
        x : SET OF time_interval_relationship;
      END_LOCAL;
  
      IF relation.relating_time_interval IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 'DATE_TIME_SCHEMA.' + 'TIME_INTERVAL_RELATIONSHIP.' + 'RELATED_TIME_INTERVAL')) | specific_relation IN TYPEOF(ti));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.relating_time_interval, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION acyclic_versioned_action_request_relationship
  (relation : versioned_action_request_relationship; relatives : SET OF versioned_action_request; specific_relation : STRING):BOOLEAN;
      LOCAL
        x : SET OF versioned_action_request_relationship;
      END_LOCAL;
  
      IF relation.relating_versioned_action_request IN relatives THEN
        RETURN (FALSE);
      END_IF;
      x := QUERY(varr <* bag_to_set(USEDIN(relation.relating_versioned_action_request, 'ACTION_SCHEMA.' + 'VERSIONED_ACTION_REQUEST_RELATIONSHIP.' + 'RELATED_VERSIONED_ACTION_REQUEST')) | specific_relation IN TYPEOF(varr));
      REPEAT i := 1 TO HIINDEX(x);
        IF NOT acyclic_versioned_action_request_relationship(x[i], relatives + relation.relating_versioned_action_request, specific_relation) THEN
          RETURN (FALSE);
        END_IF;
      END_REPEAT;
      RETURN (TRUE);

  END_FUNCTION;

  FUNCTION associated_surface
  (arg : pcurve_or_surface) : surface;
     LOCAL
       surf : surface;
     END_LOCAL;
     
     IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(arg) THEN
       surf := arg.basis_surface;
     ELSE
       surf := arg;
     END_IF;
     RETURN(surf);

  END_FUNCTION;

  FUNCTION bag_to_set
  (the_bag : BAG OF GENERIC:intype):SET OF GENERIC:intype;
      LOCAL
        the_set : SET OF GENERIC:intype := [];
      END_LOCAL;
  
      IF SIZEOF(the_bag) > 0 THEN
        REPEAT i := 1 TO HIINDEX(the_bag);
          the_set := the_set + the_bag[i];
        END_REPEAT;
      END_IF;
      RETURN (the_set);

  END_FUNCTION;

  FUNCTION base_axis
  (dim : INTEGER; axis1, axis2, axis3 : direction) :
                                                   LIST [2:3] OF 
  direction;
    LOCAL
      u      : LIST [2:3] OF direction;
      factor : REAL;
      d1, d2 : direction;
    END_LOCAL;
    
    IF (dim = 3) THEN
      d1 := NVL(normalise(axis3),  dummy_gri || direction([0.0,0.0,1.0]));
      d2 := first_proj_axis(d1,axis1);
      u := [d2, second_proj_axis(d1,d2,axis2), d1];
    ELSE
       IF EXISTS(axis1) THEN
        d1 := normalise(axis1);
        u := [d1, orthogonal_complement(d1)];
        IF EXISTS(axis2) THEN
          factor := dot_product(axis2,u[2]);
          IF (factor < 0.0) THEN
            u[2].direction_ratios[1] := -u[2].direction_ratios[1];
            u[2].direction_ratios[2] := -u[2].direction_ratios[2];
          END_IF;
        END_IF;
      ELSE
        IF EXISTS(axis2) THEN
          d1 := normalise(axis2);
          u := [orthogonal_complement(d1), d1]; 
          u[1].direction_ratios[1] := -u[1].direction_ratios[1];
          u[1].direction_ratios[2] := -u[1].direction_ratios[2];
        ELSE
          u := [dummy_gri || direction([1.0, 0.0]), dummy_gri ||
                                                  direction([0.0, 1.0])];
        END_IF;
      END_IF;
    END_IF;
    RETURN(u);

  END_FUNCTION;

  FUNCTION boolean_choose
  (b : boolean;
              choice1, choice2 : generic : item)  : generic : item;
   
       IF b THEN
         RETURN (choice1);
       ELSE
         RETURN (choice2);
       END_IF;

  END_FUNCTION;

  FUNCTION build_2axes
  (ref_direction : direction) : LIST [2:2] OF direction;
     LOCAL
       d : direction := NVL(normalise(ref_direction),
                            dummy_gri || direction([1.0,0.0]));
     END_LOCAL;
  
     RETURN([d, orthogonal_complement(d)]);

  END_FUNCTION;

  FUNCTION build_axes
  (axis, ref_direction : direction) :
                                            LIST [3:3] OF direction;
     LOCAL
       d1, d2 : direction;
     END_LOCAL;
    d1 := NVL(normalise(axis), dummy_gri || direction([0.0,0.0,1.0]));
    d2 := first_proj_axis(d1, ref_direction);
    RETURN([d2, normalise(cross_product(d1,d2)).orientation, d1]);

  END_FUNCTION;

  FUNCTION build_transformed_set
  (tr: cartesian_transformation_operator;
             gset : geometric_set) : SET [0:?] OF geometric_set_select;
    LOCAL
     s          : SET [1:?] OF geometric_set_select := gset.elements;
     trset      : SET [0:?] OF geometric_set_select := [];
    END_LOCAL;
    REPEAT j := 1 TO SIZEOF(s);
      IF ('GEOMETRY_SCHEMA.CURVE' IN TYPEOF(s[j])) THEN
       trset := trset + dummy_gri || curve() ||curve_replica(s[j],tr); ELSE
       IF ('GEOMETRY_SCHEMA.POINT' IN TYPEOF(s[j])) THEN
         trset := trset + dummy_gri || point() || point_replica(s[j],tr);
         ELSE
         IF ('GEOMETRY_SCHEMA.SURFACE' IN TYPEOF(s[j])) THEN
           trset := trset + dummy_gri || surface()  || surface_replica(s[j],
             tr || cartesian_transformation_operator_3d (?));
         END_IF;
       END_IF;
      END_IF;
    END_REPEAT;
    RETURN(trset);

  END_FUNCTION;

  FUNCTION categories_of_product
  (obj : product) : SET OF STRING; 
  LOCAL
  category_assignments: BAG OF product_category;
  categories: SET OF STRING:=[];
  i: INTEGER;
  END_LOCAL;
  category_assignments := USEDIN(obj, 'PRODUCT_DEFINITION_SCHEMA' + '.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS');
  REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments) BY 1;
  categories := categories + category_assignments[i].name;
  END_REPEAT;
  RETURN(categories);

  END_FUNCTION;

  FUNCTION class_assignment_is_valid
  (aia: applied_classification_assignment): BOOLEAN;
  LOCAL
    item: classification_item;
    role: classification_role;
  END_LOCAL;
  
  role:= aia.role;
  IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.' +'CLASS_SYSTEM' IN TYPEOF(aia.assigned_class)) THEN
    IF(role.name <> 'class system membership') THEN
      RETURN(FALSE);
    END_IF;
    REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
      item:= aia.items[i];
  
      IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.' + 'CLASS_SYSTEM_ITEM']*TYPEOF(item))=0) THEN
  -- item invalid if item does not belong to the types that may have a class_system
  	RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  
  IF ('CLASSIFICATION_WITH_ATTRIBUTES_MIM.' +'CHARACTERIZED_CLASS' IN TYPEOF(aia.assigned_class)) THEN
    IF	NOT(role.name IN ['definitional','non-definitional','']) THEN
      RETURN(FALSE); 
    END_IF;
  
    REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
      item:= aia.items[i];
  
      IF (SIZEOF(['CLASSIFICATION_WITH_ATTRIBUTES_MIM.' + 'CLASSIFIED_ITEM']*TYPEOF(item))=0) THEN
  -- item invalid if item does not belong to the types that may have a characterized_class
  	RETURN(FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN(TRUE);

  END_FUNCTION;

  FUNCTION closed_shell_reversed
  (a_shell : closed_shell) :
                                         oriented_closed_shell;
    LOCAL
      the_reverse : oriented_closed_shell;
    END_LOCAL;
     IF ('TOPOLOGY_SCHEMA.ORIENTED_CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
        the_reverse := dummy_tri ||
                      connected_face_set (
                         a_shell\connected_face_set.cfs_faces) ||
                      closed_shell () || oriented_closed_shell(
                       a_shell\oriented_closed_shell.closed_shell_element,
                         NOT(a_shell\oriented_closed_shell.orientation));
     ELSE
        the_reverse := dummy_tri ||
                 connected_face_set (
                   a_shell\connected_face_set.cfs_faces) ||
                 closed_shell () || oriented_closed_shell (a_shell, FALSE);
     END_IF;
     RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION conditional_reverse
  (p       : BOOLEAN;
                                 an_item : reversible_topology)
                                         : reversible_topology;
     IF p THEN
       RETURN (an_item);
     ELSE
       RETURN (topology_reversed (an_item));
     END_IF;

  END_FUNCTION;

  FUNCTION constraints_composite_curve_on_surface
  (c: composite_curve_on_surface) : BOOLEAN;
     LOCAL
       n_segments : INTEGER := SIZEOF(c.segments);
     END_LOCAL;
          
     REPEAT k := 1 TO n_segments;
       IF (NOT('GEOMETRY_SCHEMA.PCURVE' IN 
             TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
          (NOT('GEOMETRY_SCHEMA.SURFACE_CURVE' IN 
             TYPEOF(c\composite_curve.segments[k].parent_curve))) AND
          (NOT('GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN
             TYPEOF(c\composite_curve.segments[k].parent_curve)))  THEN
         RETURN (FALSE);
       END_IF;
     END_REPEAT;
     RETURN(TRUE);

  END_FUNCTION;

  FUNCTION constraints_geometry_shell_based_surface_model
  (m: shell_based_surface_model): BOOLEAN;
     LOCAL
       result : BOOLEAN := TRUE;
     END_LOCAL;
     
     REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
       IF (NOT ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN
                       TYPEOF(m.sbsm_boundary[j])) AND
          (NOT ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN
             TYPEOF(m.sbsm_boundary[j]))))
       THEN
         result := FALSE;
         RETURN(result);
         (* A surface model is composed of OPEN_ and CLOSED_SHELLs. *)
       END_IF;
     END_REPEAT;
     RETURN(result);

  END_FUNCTION;

  FUNCTION constraints_geometry_shell_based_wireframe_model
  (m : shell_based_wireframe_model) : BOOLEAN;
     LOCAL
       result : BOOLEAN := TRUE;
     END_LOCAL;
  
     REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
       IF (NOT ('TOPOLOGY_SCHEMA.WIRE_SHELL' IN
                      TYPEOF(m.sbwm_boundary[j])) AND
          (NOT ('TOPOLOGY_SCHEMA.VERTEX_SHELL' IN
                        TYPEOF(m.sbwm_boundary[j]))))
       THEN
         result := FALSE;
         RETURN(result);
         (* A wireframe model is composed of WIRE_ and VERTEX_SHELLs *)
       END_IF;
     END_REPEAT;
     RETURN(result);

  END_FUNCTION;

  FUNCTION constraints_param_b_spline
  (degree, up_knots, up_cp : INTEGER;
                                                 knot_mult : LIST OF INTEGER;
                          knots : LIST OF parameter_value) : BOOLEAN;
     LOCAL
       result  : BOOLEAN := TRUE;
       k, sum  : INTEGER;
     END_LOCAL;
     
     (* Find sum of knot multiplicities. *)
     sum := knot_mult[1];
     
     REPEAT i := 2 TO up_knots;
       sum := sum + knot_mult[i];
     END_REPEAT;
     
     (* Check limits holding for all B-spline parametrisations *)
     IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR
           (sum <> (degree + up_cp + 2)) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
     
     k := knot_mult[1];
     
     IF (k < 1) OR (k > degree + 1) THEN
       result := FALSE;
       RETURN(result);
     END_IF;
        
     REPEAT i := 2 TO up_knots;
       IF (knot_mult[i] < 1) OR (knots[i] <= knots[i-1]) THEN
         result := FALSE;
         RETURN(result);
       END_IF;
          
       k := knot_mult[i];
       
       IF (i < up_knots) AND (k > degree) THEN
         result := FALSE;
         RETURN(result);
       END_IF;
          
       IF (i = up_knots) AND (k > degree + 1) THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
     RETURN(result);

  END_FUNCTION;

  FUNCTION constraints_rectangular_composite_surface
  (s : rectangular_composite_surface) : BOOLEAN;
  
     (* Check the surface types *)
       REPEAT i := 1 TO s.n_u;
         REPEAT j := 1 TO s.n_v;
           IF NOT (('GEOMETRY_SCHEMA.B_SPLINE_SURFACE' IN TYPEOF
                      (s.segments[i][j].parent_surface)) OR
                   ('GEOMETRY_SCHEMA.RECTANGULAR_TRIMMED_SURFACE' IN TYPEOF
                      (s.segments[i][j].parent_surface))) THEN
             RETURN(FALSE);
         END_IF;
       END_REPEAT;
     END_REPEAT;
  
     (* Check the transition codes, omitting the last row or column *)
     REPEAT i := 1 TO s.n_u-1;
       REPEAT j := 1 TO s.n_v;
         IF s.segments[i][j].u_transition = discontinuous THEN
           RETURN(FALSE);
         END_IF;
       END_REPEAT;
     END_REPEAT;
     
     REPEAT i := 1 TO s.n_u;
       REPEAT j := 1 TO s.n_v-1;
         IF s.segments[i][j].v_transition = discontinuous THEN
           RETURN(FALSE);
         END_IF;
       END_REPEAT;
     END_REPEAT;
     RETURN(TRUE);

  END_FUNCTION;

  FUNCTION cross_product
  (arg1, arg2 : direction) : vector;
    LOCAL
      mag    : REAL;
      res    : direction;
      v1,v2  : LIST[3:3] OF REAL;
      result : vector;
    END_LOCAL;
    
    IF ( NOT EXISTS (arg1) OR (arg1.dim = 2)) OR
       ( NOT EXISTS (arg2) OR (arg2.dim = 2)) THEN
      RETURN(?);
    ELSE
      BEGIN
        v1  := normalise(arg1).direction_ratios;
        v2  := normalise(arg2).direction_ratios;
        res := dummy_gri || direction([(v1[2]*v2[3] - v1[3]*v2[2]),
              (v1[3]*v2[1] - v1[1]*v2[3]), (v1[1]*v2[2] - v1[2]*v2[1])]);
        mag := 0.0;
        REPEAT i := 1 TO 3;
          mag := mag + res.direction_ratios[i]*res.direction_ratios[i];
        END_REPEAT;
        IF (mag > 0.0) THEN
          result := dummy_gri || vector(res, SQRT(mag));
        ELSE
          result := dummy_gri || vector(arg1, 0.0);
        END_IF;
        RETURN(result);
      END;
    END_IF;

  END_FUNCTION;

  FUNCTION curve_weights_positive
  (b: rational_b_spline_curve) : BOOLEAN;
     LOCAL
       result : BOOLEAN := TRUE;
     END_LOCAL;
  
     REPEAT i := 0 TO b.upper_index_on_control_points;
       IF b.weights[i] <= 0.0  THEN
         result := FALSE;
         RETURN(result);
       END_IF;
     END_REPEAT;
     RETURN(result);

  END_FUNCTION;

  FUNCTION default_b_spline_curve_weights
  (up_cp : INTEGER)
                                            : ARRAY [0:up_cp] OF REAL;
     RETURN([1:up_cp + 1]);

  END_FUNCTION;

  FUNCTION default_b_spline_knot_mult
  (degree, up_knots : INTEGER;
                                            uniform : knot_type) 
                                                    : LIST [2:?] OF INTEGER;
     LOCAL
       knot_mult : LIST [1:up_knots] OF INTEGER;
     END_LOCAL;
          
     IF uniform = uniform_knots THEN
       knot_mult := [1:up_knots];
     ELSE
       IF uniform = quasi_uniform_knots THEN
         knot_mult := [1:up_knots];
         knot_mult[1] := degree + 1;
         knot_mult[up_knots] := degree + 1;
       ELSE
         IF uniform = piecewise_bezier_knots THEN
           knot_mult := [degree:up_knots];
           knot_mult[1] := degree + 1;
           knot_mult[up_knots] := degree + 1;
         ELSE
           knot_mult := [0:up_knots];
         END_IF;
       END_IF;
     END_IF;
     RETURN(knot_mult);

  END_FUNCTION;

  FUNCTION default_b_spline_knots
  (degree,up_knots : INTEGER;
                                uniform : knot_type)
                                        : LIST [2:?] OF parameter_value;
    LOCAL
      knots  : LIST [1:up_knots] OF parameter_value := [0:up_knots];
      ishift : INTEGER := 1;
    END_LOCAL;
  
    IF (uniform = uniform_knots) THEN
       ishift := degree + 1;
    END_if;
    IF (uniform = uniform_knots) OR 
       (uniform = quasi_uniform_knots) OR
       (uniform = piecewise_bezier_knots) THEN
      
      REPEAT i := 1 TO up_knots;
        knots[i] := i - ishift;
      END_REPEAT;
    END_IF;
    RETURN(knots);

  END_FUNCTION;

  FUNCTION default_b_spline_surface_weights
  (u_upper, v_upper: INTEGER)
                                        : ARRAY [0:u_upper] OF 
                                          ARRAY [0:v_upper] OF REAL;
      RETURN([[1:v_upper + 1]:u_upper +1]);

  END_FUNCTION;

  FUNCTION derive_dimensional_exponents
  (x : unit) : dimensional_exponents; 
    LOCAL
      result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    END_LOCAL;
  
    IF 'MEASURE_SCHEMA.DERIVED_UNIT' IN TYPEOF(x) THEN
      REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
        result.length_exponent := result.length_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.length_exponent);
        result.mass_exponent := result.mass_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.mass_exponent);
        result.time_exponent := result.time_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.time_exponent);
        result.electric_current_exponent := result.electric_current_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.electric_current_exponent);
        result.thermodynamic_temperature_exponent := result.thermodynamic_temperature_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.thermodynamic_temperature_exponent);
        result.amount_of_substance_exponent := result.amount_of_substance_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.amount_of_substance_exponent);
        result.luminous_intensity_exponent := result.luminous_intensity_exponent + (x.elements[i].exponent * x.elements[i].unit.dimensions.luminous_intensity_exponent);
      END_REPEAT;
    ELSE
      result := x.dimensions;
    END_IF;
    RETURN (result);

  END_FUNCTION;

  FUNCTION dimension_of
  (item : geometric_representation_item) :
    dimension_count;
    LOCAL
      x   : SET OF representation;
      y   : representation_context;
      dim : dimension_count;
    END_LOCAL;
    -- For cartesian_point, direction, or vector dimension is determined by
    -- counting components.
      IF 'GEOMETRY_SCHEMA.CARTESIAN_POINT' IN TYPEOF(item) THEN
         dim := SIZEOF(item\cartesian_point.coordinates);
         RETURN(dim);
      END_IF;
      IF 'GEOMETRY_SCHEMA.DIRECTION' IN TYPEOF(item) THEN
         dim := SIZEOF(item\direction.direction_ratios);
         RETURN(dim);
      END_IF;
      IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(item) THEN
         dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
         RETURN(dim);
      END_IF;
    -- For all other types of geometric_representation_item dim is obtained
    -- via context.
    -- Find the set of representation in which the item is used. 
  
    x := using_representations(item);
  
    -- Determines the dimension_count of the 
    -- geometric_representation_context. Note that the 
    -- RULE compatible_dimension ensures that the context_of_items
    -- is of type geometric_representation_context and has
    -- the same dimension_count for all values of x.
    -- The SET x is non-empty since this is required by WR1 of
    -- representation_item.
      y := x[1].context_of_items;
      dim := y\geometric_representation_context.coordinate_space_dimension;
      RETURN (dim);

  END_FUNCTION;

  FUNCTION dimensions_for_si_unit
  (n : si_unit_name) : dimensional_exponents; 
   CASE n OF
      metre          : RETURN (dimensional_exponents
                            (1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      gram           : RETURN (dimensional_exponents
                           (0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      second         : RETURN (dimensional_exponents
                           (0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
      ampere         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
      kelvin         : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      mole           : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
      candela        : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      radian         : RETURN (dimensional_exponents
                             (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      steradian      : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
      hertz          : RETURN (dimensional_exponents
                           (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      newton         : RETURN (dimensional_exponents
                           (1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      pascal         : RETURN (dimensional_exponents
                           (-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      joule          : RETURN (dimensional_exponents
                           (2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      watt           : RETURN (dimensional_exponents
                           (2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
      coulomb        : RETURN (dimensional_exponents
                           (0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0));
      volt           : RETURN (dimensional_exponents
                           (2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
      farad          : RETURN (dimensional_exponents
                           (-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0));
      ohm            : RETURN (dimensional_exponents
                           (2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
      siemens        : RETURN (dimensional_exponents
                           (-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0));
      weber          : RETURN (dimensional_exponents
                           (2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      tesla          : RETURN (dimensional_exponents
                           (0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0));
      henry          : RETURN (dimensional_exponents
                           (2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0));
      degree_Celsius : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
      lumen          : RETURN (dimensional_exponents
                           (0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      lux            : RETURN (dimensional_exponents
                           (-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
      becquerel      : RETURN (dimensional_exponents
                           (0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
      gray           : RETURN (dimensional_exponents
                           (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      sievert        : RETURN (dimensional_exponents
                           (2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
      OTHERWISE      : RETURN (?);
    END_CASE;

  END_FUNCTION;

  FUNCTION dot_product
  (arg1, arg2 : direction) : REAL;
     LOCAL
       scalar : REAL;
       vec1, vec2: direction;
       ndim : INTEGER;
     END_LOCAL;
     
     IF NOT EXISTS (arg1) OR NOT EXISTS (arg2) THEN
       scalar := ?;
       (* When function is called with invalid data an indeterminate result
       is returned *)
     ELSE
       IF (arg1.dim <> arg2.dim) THEN
         scalar := ?;
       (* When function is called with invalid data an indeterminate result
       is returned *)
       ELSE
         BEGIN
           vec1   := normalise(arg1);
           vec2   := normalise(arg2);
           ndim   := arg1.dim;
           scalar := 0.0;
           REPEAT  i := 1 TO ndim;
             scalar := scalar +
                         vec1.direction_ratios[i]*vec2.direction_ratios[i];
           END_REPEAT;
         END;
       END_IF;
     END_IF;
     RETURN (scalar);

  END_FUNCTION;

  FUNCTION edge_curve_pcurves
  (an_edge  : edge_curve;
                         the_surface_curves : SET OF surface_curve)
        : SET OF pcurve;
  LOCAL
    a_curve      : curve;
    result       : SET OF pcurve;
    the_geometry : LIST[1:2] OF pcurve_or_surface;
  END_LOCAL;
    a_curve := an_edge.edge_geometry;
    result := [];
    IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF(a_curve) THEN
      result := result + a_curve;
    ELSE
      IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF(a_curve) THEN
        the_geometry := a_curve\surface_curve.associated_geometry;
        REPEAT k := 1 TO SIZEOF(the_geometry);
           IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
           THEN
              result := result + the_geometry[k];
           END_IF;
        END_REPEAT;
      ELSE
        REPEAT j := 1 TO SIZEOF(the_surface_curves);
          the_geometry := the_surface_curves[j].associated_geometry;
          IF the_surface_curves[j].curve_3d :=: a_curve
          THEN
            REPEAT k := 1 TO SIZEOF(the_geometry);
              IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (the_geometry[k])
              THEN
                result := result + the_geometry[k];
              END_IF;
            END_REPEAT;
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
  
    RETURN (RESULT);

  END_FUNCTION;

  FUNCTION edge_reversed
  (an_edge : edge) : oriented_edge;
     LOCAL
       the_reverse : oriented_edge;
     END_LOCAL;
  
     IF ('TOPOLOGY_SCHEMA.ORIENTED_EDGE' IN TYPEOF (an_edge) ) THEN
       the_reverse  := dummy_tri ||
               edge(an_edge.edge_end, an_edge.edge_start) ||
               oriented_edge(an_edge\oriented_edge.edge_element,
                          NOT (an_edge\oriented_edge.orientation)) ;
     ELSE
       the_reverse := dummy_tri ||
               edge(an_edge.edge_end, an_edge.edge_start) ||
               oriented_edge(an_edge, FALSE);
     END_IF;
     RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION external_version_assignment_is_valid
  (aia: applied_external_identification_assignment): BOOLEAN;
  LOCAL
    item: identification_item;
    role: identification_role;
  END_LOCAL;
  
  role:= aia.role;
  IF role.name='version' THEN
    REPEAT i:=LOINDEX(aia.items) TO HIINDEX(aia.items);
      item:= aia.items[i];
  
      IF (SIZEOF(['EXTERNAL_PROPERTIES_MIM.' + 'EXTERNALLY_VERSIONED_ITEM']*TYPEOF(item))=0) THEN
  -- item invalid if item does not belong to versionable types
  	RETURN(FALSE);
      END_IF;
    END_REPEAT;
    RETURN(TRUE);
  
  ELSE		-- case where aia does not convey a version id
    RETURN(TRUE);
  END_IF;

  END_FUNCTION;

  FUNCTION face_bound_reversed
  (a_face_bound : face_bound) : face_bound;
     LOCAL
       the_reverse : face_bound ;
     END_LOCAL;
     IF ('TOPOLOGY_SCHEMA.FACE_OUTER_BOUND' IN TYPEOF (a_face_bound) ) THEN
       the_reverse := dummy_tri ||
                        face_bound(a_face_bound\face_bound.bound,
                             NOT (a_face_bound\face_bound.orientation))
                              || face_outer_bound() ;
     ELSE
       the_reverse := dummy_tri ||
           face_bound(a_face_bound.bound, NOT(a_face_bound.orientation));
     END_IF;
    RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION face_reversed
  (a_face : face) : oriented_face;
     LOCAL
       the_reverse : oriented_face ;
     END_LOCAL;
     IF ('TOPOLOGY_SCHEMA.ORIENTED_FACE' IN TYPEOF (a_face) ) THEN
       the_reverse := dummy_tri ||
         face(set_of_topology_reversed(a_face.bounds)) ||
            oriented_face(a_face\oriented_face.face_element,
                             NOT (a_face\oriented_face.orientation)) ;
     ELSE
       the_reverse := dummy_tri ||
         face(set_of_topology_reversed(a_face.bounds)) ||
                                 oriented_face(a_face, FALSE) ;
     END_IF;
        RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION first_proj_axis
  (z_axis, arg : direction) : direction;
    LOCAL
      x_axis : direction;
      v      : direction;
      z      : direction;
      x_vec  : vector;
    END_LOCAL;
    
    IF (NOT EXISTS(z_axis)) THEN
      RETURN (?) ;
    ELSE
      z := normalise(z_axis);
      IF NOT EXISTS(arg) THEN
        IF ((z.direction_ratios <> [1.0,0.0,0.0]) AND
            (z.direction_ratios <> [-1.0,0.0,0.0]))  THEN
          v :=  dummy_gri || direction([1.0,0.0,0.0]);
        ELSE
          v := dummy_gri || direction([0.0,1.0,0.0]);
        END_IF;
      ELSE
        IF  (arg.dim <> 3) THEN
          RETURN (?) ;
        END_IF;
        IF ((cross_product(arg,z).magnitude) = 0.0) THEN
          RETURN (?);
        ELSE
          v := normalise(arg);
        END_IF;
      END_IF;
      x_vec := scalar_times_vector(dot_product(v, z), z);
      x_axis := vector_difference(v, x_vec).orientation;
      x_axis := normalise(x_axis);
    END_IF;
    RETURN(x_axis);

  END_FUNCTION;

  FUNCTION get_basis_surface
  (c : curve_on_surface) : SET[0:2] OF surface;
    LOCAL
      surfs  : SET[0:2] OF surface;
      n      : INTEGER;
    END_LOCAL;
    surfs := [];
    IF 'GEOMETRY_SCHEMA.PCURVE' IN TYPEOF (c) THEN
      surfs := [c\pcurve.basis_surface];
    ELSE
      IF 'GEOMETRY_SCHEMA.SURFACE_CURVE' IN TYPEOF (c) THEN
        n := SIZEOF(c\surface_curve.associated_geometry);
        REPEAT i := 1 TO n;
        surfs := surfs +
                  associated_surface(c\surface_curve.associated_geometry[i]);
        END_REPEAT;
      END_IF;
    END_IF;
    IF 'GEOMETRY_SCHEMA.COMPOSITE_CURVE_ON_SURFACE' IN TYPEOF (c) THEN
     (* For a composite_curve_on_surface the basis_surface is the intersection
      of the basis_surfaces of all the segments. *)
       n := SIZEOF(c\composite_curve.segments);
       surfs := get_basis_surface(
                       c\composite_curve.segments[1].parent_curve);
       IF n > 1 THEN
         REPEAT i := 2 TO n;
           surfs := surfs * get_basis_surface(
                    c\composite_curve.segments[i].parent_curve);
         END_REPEAT;
       END_IF;
  
    END_IF;
    RETURN(surfs);

  END_FUNCTION;

  FUNCTION get_description_value
  (obj : description_attribute_select) : text; 
    LOCAL
      description_bag : BAG OF description_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'DESCRIPTION_ATTRIBUTE.' + 'DESCRIBED_ITEM'));
    END_LOCAL;
  
    IF SIZEOF(description_bag) = 1 THEN
      RETURN (description_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;

  END_FUNCTION;

  FUNCTION get_id_value
  (obj : id_attribute_select) : identifier; 
  LOCAL
        id_bag : BAG OF id_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ID_ATTRIBUTE.' + 'IDENTIFIED_ITEM'));
  END_LOCAL;
  IF SIZEOF(id_bag) = 1 THEN
        RETURN (id_bag[1].attribute_value);
  ELSE
        RETURN (?);
  END_IF;

  END_FUNCTION;

  FUNCTION get_name_value
  (obj : name_attribute_select) : label; 
    LOCAL
      name_bag : BAG OF name_attribute := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'NAME_ATTRIBUTE.' + 'NAMED_ITEM'));
    END_LOCAL;
  
    IF SIZEOF(name_bag) = 1 THEN
      RETURN (name_bag[1].attribute_value);
    ELSE
      RETURN (?);
    END_IF;

  END_FUNCTION;

  FUNCTION get_product_definitions
  (c_def_instance : product) : SET OF product_definition; 
    LOCAL
        pd_set : SET OF product_definition_formation := [];
        pdr_set : SET OF product_definition := [];
      END_LOCAL;
  
      pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'));
      IF (SIZEOF(pd_set) < 1) THEN
        RETURN (pdr_set);
      END_IF;
      REPEAT i := 1 TO HIINDEX(pd_set);
        pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_DEFINITION_SCHEMA.PRODUCT_DEFINITION.FORMATION'));
      END_REPEAT;
      RETURN (pdr_set);

  END_FUNCTION;

  FUNCTION get_property_definition_representations
  (c_def_instance : characterized_definition) : SET OF property_definition_representation; 
  LOCAL
        pd_set : SET OF property_definition := [];
        pdr_set : SET OF property_definition_representation := [];
      END_LOCAL;
  
      pd_set := bag_to_set(USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION'));
      IF (SIZEOF(pd_set) < 1) THEN
        RETURN (pdr_set);
      END_IF;
      REPEAT i := 1 TO HIINDEX(pd_set);
        pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'));
      END_REPEAT;
      RETURN (pdr_set);

  END_FUNCTION;

  FUNCTION get_role
  (obj : role_select) : object_role; 
    LOCAL
      role_bag : BAG OF role_association := (USEDIN(obj, 'BASIC_ATTRIBUTE_SCHEMA.' + 'ROLE_ASSOCIATION.' + 'ITEM_WITH_ROLE'));
    END_LOCAL;
  
    IF SIZEOF(role_bag) = 1 THEN
      RETURN (role_bag[1].role);
    ELSE
      RETURN (?);
    END_IF;

  END_FUNCTION;

  FUNCTION get_shape_aspects
  (c_def_instance : characterized_definition) : SET OF shape_aspect; 
    LOCAL
        pd_set : SET OF product_definition_shape := [];
        pdr_set : SET OF shape_aspect := [];
      END_LOCAL;
  
      pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PROPERTY_DEFINITION.DEFINITION') | 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(pd)));
      IF (SIZEOF(pd_set) < 1) THEN
        RETURN (pdr_set);
      END_IF;
      REPEAT i := 1 TO HIINDEX(pd_set);
        pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 'PRODUCT_PROPERTY_DEFINITION_SCHEMA.SHAPE_ASPECT.OF_SHAPE'));
      END_REPEAT;
      RETURN (pdr_set);

  END_FUNCTION;

  FUNCTION item_in_context
  (item  : representation_item;
     cntxt : representation_context) : BOOLEAN;
    LOCAL
      y : BAG OF representation_item;
    END_LOCAL;
    -- If there is one or more representation using both the item
    -- and cntxt return true.
    IF SIZEOF(USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS')
      * cntxt.representations_in_context) > 0 THEN
      RETURN (TRUE);
      -- Determine the bag of representation_items that reference
      -- item
      ELSE y := QUERY(z <* USEDIN (item , '') |
             'REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z));
        -- Ensure that the bag is not empty
        IF SIZEOF(y) > 0 THEN
        -- For each element in the bag
        REPEAT i := 1 TO HIINDEX(y);
          -- Check to see it is an item in the input cntxt.
          IF item_in_context(y[i], cntxt) THEN
            RETURN (TRUE);
          END_IF;
        END_REPEAT;
      END_IF;
    END_IF;
    -- Return false when all possible branches have been checked
    -- with no success.
    RETURN (FALSE);

  END_FUNCTION;

  FUNCTION leap_year
  (year : year_number) : BOOLEAN; 
    IF ((((year MOD 4) = 0) AND ((year MOD 100) <> 0)) OR ((year MOD 400) = 0)) THEN
      RETURN (TRUE);
    ELSE
      RETURN (FALSE);
    END_IF;

  END_FUNCTION;

  FUNCTION list_face_loops
  (f: face) : LIST[0:?] OF loop;
     LOCAL
       loops : LIST[0:?] OF loop := [];
     END_LOCAL;
     
     REPEAT i := 1 TO SIZEOF(f.bounds);
       loops := loops +(f.bounds[i].bound);
     END_REPEAT;
        
     RETURN(loops);

  END_FUNCTION;

  FUNCTION list_loop_edges
  (l: loop): LIST[0:?] OF edge;
     LOCAL
       edges : LIST[0:?] OF edge := [];
     END_LOCAL;
        
     IF 'TOPOLOGY_SCHEMA.EDGE_LOOP' IN TYPEOF(l) THEN
       REPEAT i := 1 TO SIZEOF(l\path.edge_list);
         edges := edges + (l\path.edge_list[i].edge_element);
       END_REPEAT;
     END_IF;
  
     RETURN(edges);

  END_FUNCTION;

  FUNCTION list_of_topology_reversed
  (a_list
                                    : list_of_reversible_topology_item)
                                    : list_of_reversible_topology_item;
     LOCAL
       the_reverse : list_of_reversible_topology_item;
     END_LOCAL;
      
     the_reverse := [];
     REPEAT i := 1 TO SIZEOF (a_list);
       the_reverse := topology_reversed (a_list [i]) + the_reverse;
     END_REPEAT;
    
     RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION list_shell_edges
  (s : shell) : LIST[0:?] OF edge;
     LOCAL
       edges : LIST[0:?] OF edge := [];
     END_LOCAL;
        
     REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
       edges := edges + list_loop_edges(list_shell_loops(s)[i]);
     END_REPEAT;
     
     RETURN(edges);

  END_FUNCTION;

  FUNCTION list_shell_faces
  (s : shell) : LIST[0:?] OF face;
     LOCAL
       faces : LIST[0:?] OF face := [];
     END_LOCAL;
     
     IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) OR 
        ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) THEN
       REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
         faces := faces + s\connected_face_set.cfs_faces[i];
       END_REPEAT;
     END_IF;
        
     RETURN(faces);

  END_FUNCTION;

  FUNCTION list_shell_loops
  (s : shell) : LIST[0:?] OF loop;
     LOCAL
       loops : LIST[0:?] OF loop := [];
     END_LOCAL;
        
     IF 'TOPOLOGY_SCHEMA.VERTEX_SHELL' IN TYPEOF(s) THEN
       loops := loops + s.vertex_shell_extent;
     END_IF;
        
     IF 'TOPOLOGY_SCHEMA.WIRE_SHELL' IN TYPEOF(s) THEN
       REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
         loops := loops + s.wire_shell_extent[i];
       END_REPEAT;
     END_IF;
        
     IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF(s)) OR 
        ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF(s)) THEN
       REPEAT i := 1 TO SIZEOF(s.cfs_faces);
         loops := loops + list_face_loops(s.cfs_faces[i]);
       END_REPEAT;
     END_IF;
        
     RETURN(loops);

  END_FUNCTION;

  FUNCTION list_to_array
  (lis : LIST [0:?] OF GENERIC : T;
                        low,u : INTEGER) : ARRAY [low:u] OF GENERIC : T;
     LOCAL
       n   : INTEGER;
       res : ARRAY [low:u] OF GENERIC : T;
     END_LOCAL;
        
     n := SIZEOF(lis);
     IF (n <> (u-low +1)) THEN
       RETURN(?);
     ELSE
       res := [lis[1] : n];
       REPEAT i := 2 TO n;
         res[low+i-1] := lis[i];
       END_REPEAT;
       RETURN(res);
     END_IF;

  END_FUNCTION;

  FUNCTION list_to_set
  (l : LIST [0:?] OF GENERIC:T) : SET OF GENERIC:T;
     LOCAL
       s : SET OF GENERIC:T := [];
     END_LOCAL;
        
     REPEAT i := 1 TO SIZEOF(l);
       s := s + l[i];
     END_REPEAT;
     
     RETURN(s);

  END_FUNCTION;

  FUNCTION make_array_of_array
  (lis : LIST[1:?] OF LIST [1:?] OF GENERIC : T;
                                low1, u1, low2, u2 : INTEGER):
                   ARRAY [low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
     LOCAL
       res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF GENERIC : T;
     END_LOCAL;
  
  (* Check input dimensions for consistency *)
     IF (u1-low1+1) <> SIZEOF(lis) THEN
       RETURN (?);
     END_IF;
     IF (u2 - low2 + 1 ) <> SIZEOF(lis[1]) THEN
       RETURN (?) ;
     END_IF;
  (* Initialise res with values from lis[1] *)
     res := [list_to_array(lis[1], low2, u2) : (u1-low1 + 1)];
     REPEAT i := 2 TO HIINDEX(lis);
       IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
         RETURN (?);
       END_IF;     
       res[low1+i-1] := list_to_array(lis[i], low2, u2);
     END_REPEAT; 
     
     RETURN (res);

  END_FUNCTION;

  FUNCTION make_array_of_array_of_array
  (lis : LIST[1:?] OF
                LIST [1:?] OF LIST [1:?] OF GENERIC : T;
                low1, u1, low2, u2, low3, u3 : INTEGER):
        ARRAY[low1:u1] OF ARRAY[low2:u2] OF ARRAY[low3:u3] OF GENERIC : T;
   LOCAL 
     res   : ARRAY[low1:u1] OF ARRAY [low2:u2] OF
               ARRAY[low3:u3] OF GENERIC : T;
   END_LOCAL;                
  
  (* Check input dimensions for consistency *)
     IF (u1-low1+1) <> SIZEOF(lis) THEN
       RETURN (?);
     END_IF;
     IF (u2-low2+1) <> SIZEOF(lis[1]) THEN
       RETURN (?);
     END_IF;
  (* Initialise res with values from lis[1] *)
     res := [make_array_of_array(lis[1], low2, u2, low3, u3) : (u1-low1 + 1)];
     REPEAT i := 2 TO HIINDEX(lis);
       IF (u2-low2+1) <> SIZEOF(lis[i]) THEN
         RETURN (?);
       END_IF;  
       res[low1+i-1] := make_array_of_array(lis[i], low2, u2, low3, u3);
     END_REPEAT; 
     RETURN (res);

  END_FUNCTION;

  FUNCTION mixed_loop_type_set
  (l: SET[0:?] OF loop): LOGICAL;
      LOCAL
        poly_loop_type: LOGICAL;
      END_LOCAL;
      IF(SIZEOF(l) <= 1) THEN
        RETURN(FALSE);
      END_IF;
      poly_loop_type := ('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[1]));
      REPEAT i := 2 TO SIZEOF(l);
        IF(('TOPOLOGY_SCHEMA.POLY_LOOP' IN TYPEOF(l[i])) <> poly_loop_type)
            THEN
            RETURN(TRUE);
         END_IF;
      END_REPEAT;
      RETURN(FALSE);

  END_FUNCTION;

  FUNCTION msb_shells
  (brep: manifold_solid_brep) :
                            SET [1:?] OF  closed_shell;
   
       IF SIZEOF (QUERY (msbtype <* TYPEOF (brep) |
         msbtype LIKE '*BREP_WITH_VOIDS')) >= 1 THEN
         RETURN (brep\brep_with_voids.voids + brep.outer);
       ELSE
         RETURN([brep.outer]);
       END_IF;

  END_FUNCTION;

  FUNCTION normalise
  (arg : vector_or_direction) : vector_or_direction;
     LOCAL
       ndim   : INTEGER;
       v      : direction;
       result : vector_or_direction;
       vec    : vector;
       mag    : REAL;
     END_LOCAL;
     
     IF NOT EXISTS (arg) THEN
       result := ?;
   (* When function is called with invalid data a NULL result is returned *)
     ELSE
       ndim := arg.dim;
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
         BEGIN
               v := dummy_gri || direction(arg.orientation.direction_ratios);
           IF arg.magnitude = 0.0 THEN
             RETURN(?);
           ELSE
            vec := dummy_gri || vector (v, 1.0);
           END_IF;
         END;
       ELSE
         v := dummy_gri || direction (arg.direction_ratios);
       END_IF;
       mag := 0.0;
       REPEAT  i := 1 TO ndim;
         mag := mag + v.direction_ratios[i]*v.direction_ratios[i];
       END_REPEAT;
       IF mag > 0.0 THEN
         mag := SQRT(mag);
         REPEAT  i := 1 TO ndim;
           v.direction_ratios[i] := v.direction_ratios[i]/mag;
         END_REPEAT;
         IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg) THEN
           vec.orientation := v;
           result := vec;
         ELSE
           result := v;
         END_IF;
       ELSE
         RETURN(?);
       END_IF;
     END_IF;
     RETURN (result);

  END_FUNCTION;

  FUNCTION open_shell_reversed
  ( a_shell : open_shell) :
                                           oriented_open_shell;
     LOCAL
       the_reverse : oriented_open_shell;
     END_LOCAL;
     IF ('TOPOLOGY_SCHEMA.ORIENTED_OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
       the_reverse := dummy_tri ||
                    connected_face_set (
                        a_shell\connected_face_set.cfs_faces) ||
                    open_shell () || oriented_open_shell(
                      a_shell\oriented_open_shell.open_shell_element,
                        (NOT (a_shell\oriented_open_shell.orientation)));
     ELSE
       the_reverse := dummy_tri ||
                   connected_face_set (
                       a_shell\connected_face_set.cfs_faces) ||
                   open_shell () ||  oriented_open_shell (a_shell, FALSE);
     END_IF;
     RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION orthogonal_complement
  (vec : direction) : direction;
     LOCAL
       result :  direction ;
     END_LOCAL;
  
     IF (vec.dim <> 2) OR NOT EXISTS (vec) THEN
       RETURN(?);
     ELSE
       result := dummy_gri || direction([-vec.direction_ratios[2],
                                            vec.direction_ratios[1]]);
       RETURN(result);
     END_IF;

  END_FUNCTION;

  FUNCTION path_head_to_tail
  (a_path : path) : LOGICAL;
     LOCAL
       n : INTEGER;
       p : LOGICAL := TRUE;
     END_LOCAL;
       
       n := SIZEOF (a_path.edge_list);
       REPEAT i := 2 TO n;
         p := p AND (a_path.edge_list[i-1].edge_end :=:
                     a_path.edge_list[i].edge_start);
       END_REPEAT;
       
       RETURN (p);

  END_FUNCTION;

  FUNCTION path_reversed
  (a_path : path) : oriented_path;
    LOCAL
      the_reverse : oriented_path ;
    END_LOCAL;
    IF ('TOPOLOGY_SCHEMA.ORIENTED_PATH' IN TYPEOF (a_path) ) THEN
      the_reverse := dummy_tri ||
         path(list_of_topology_reversed (a_path.edge_list)) ||
            oriented_path(a_path\oriented_path.path_element,
                            NOT(a_path\oriented_path.orientation)) ;
    ELSE
      the_reverse := dummy_tri ||
                     path(list_of_topology_reversed (a_path.edge_list)) ||
                         oriented_path(a_path, FALSE);
    END_IF;
  
    RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION relatives_of_product_definitions
  (definition_set : SET OF product_definition; relation_subtype : STRING) : SET OF product_definition; 
  FUNCTION local_relatives_of_product_definitions (definition_set : SET OF product_definition; total_definitions : SET OF product_definition; relation_subtype : STRING):SET OF product_definition;
        LOCAL
          local_def : SET OF product_definition := [];
          local_pdr : SET OF product_definition_relationship := [];
          local_total : SET OF product_definition := [];
        END_LOCAL;
  
        REPEAT i := 1 TO HIINDEX(definition_set);
          local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], relation_subtype + '.RELATING_PRODUCT_DEFINITION'));
        END_REPEAT;
        REPEAT i := 1 TO HIINDEX(local_pdr);
          local_def := local_def + local_pdr[i].related_product_definition;
        END_REPEAT;
        IF (SIZEOF(local_def) - SIZEOF(total_definitions)) = 0 THEN
          RETURN (local_def);
        ELSE
          local_total := total_definitions + local_def;
          RETURN (local_def + (local_relatives_of_product_definitions(local_def - total_definitions, local_total, relation_subtype)));
        END_IF;
      END_FUNCTION;
  
      RETURN (local_relatives_of_product_definitions(definition_set, definition_set, relation_subtype));

  END_FUNCTION;

  FUNCTION relatives_of_shape_representations
  (shape_representation_set : SET OF shape_representation) : SET OF shape_representation; 
   FUNCTION local_relatives_of_shape_representations (shape_representation_set : SET OF shape_representation; total_reps : SET OF shape_representation):SET OF shape_representation;
        LOCAL
          local_shape_rep : SET OF shape_representation := [];
          local_srr : SET OF shape_representation_relationship := [];
          local_total : SET OF shape_representation := [];
        END_LOCAL;
  
        REPEAT i := 1 TO HIINDEX(shape_representation_set);
          local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(shape_representation_set[i], 'REPRESENTATION_SCHEMA.REPRESENTATION_RELATIONSHIP.REP_1')) | 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
        END_REPEAT;
        REPEAT i := 1 TO HIINDEX(local_srr);
          IF 'PRODUCT_PROPERTY_REPRESENTATION_SCHEMA.' + 'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
            local_shape_rep := local_shape_rep + local_srr[i].rep_2;
          END_IF;
        END_REPEAT;
        IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
          RETURN (shape_representation_set);
        ELSE
          local_total := total_reps + local_shape_rep;
          RETURN (local_shape_rep + (local_relatives_of_shape_representations(local_shape_rep - total_reps, local_total)));
        END_IF;
      END_FUNCTION;
  
      RETURN (local_relatives_of_shape_representations(shape_representation_set, shape_representation_set));

  END_FUNCTION;

  FUNCTION same_side
  (plane_pts : LIST [3:3] of cartesian_point;
                      test_points : LIST [2:?] of cartesian_point) : BOOLEAN;
     LOCAL
       val1, val2 : REAL;
       n          : INTEGER;
     END_LOCAL;
  
     IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
       RETURN(?);
     END_IF;
     n := SIZEOF(test_points);
     val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                         test_points[1] );
     REPEAT i := 2 TO n;
       val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3],
                         test_points[i] );
       IF (val1*val2 <= 0.0) THEN
         RETURN(FALSE);
       END_IF;
     END_REPEAT;
     RETURN(TRUE);

  END_FUNCTION;

  FUNCTION scalar_times_vector
  (scalar : REAL; vec : vector_or_direction)
                                        : vector;
     LOCAL
       v      : direction;
       mag    : REAL;
       result : vector;
     END_LOCAL;
  
     IF NOT EXISTS (scalar) OR NOT EXISTS (vec) THEN
       RETURN (?) ;
      ELSE
       IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF (vec) THEN
         v   := dummy_gri || direction(vec.orientation.direction_ratios);
         mag := scalar * vec.magnitude;
       ELSE
         v   := dummy_gri || direction(vec.direction_ratios);
         mag := scalar;
       END_IF;
       IF (mag < 0.0 ) THEN
         REPEAT i := 1 TO SIZEOF(v.direction_ratios);
           v.direction_ratios[i] := -v.direction_ratios[i];
         END_REPEAT;
         mag := -mag;
       END_IF;
       result := dummy_gri || vector(normalise(v), mag);
     END_IF;
     RETURN (result);

  END_FUNCTION;

  FUNCTION second_proj_axis
  (z_axis, x_axis, arg: direction) : direction;
     LOCAL
       y_axis : vector;
       v      : direction;
       temp   : vector;
     END_LOCAL;
     
     IF NOT EXISTS(arg) THEN
       v := dummy_gri || direction([0.0,1.0,0.0]);
     ELSE
       v := arg;
     END_IF;
     
     temp   := scalar_times_vector(dot_product(v, z_axis), z_axis);
     y_axis := vector_difference(v, temp);
     temp   := scalar_times_vector(dot_product(v, x_axis), x_axis);
     y_axis := vector_difference(y_axis, temp);
     y_axis := normalise(y_axis);
     RETURN(y_axis.orientation);

  END_FUNCTION;

  FUNCTION set_of_topology_reversed
  (a_set : set_of_reversible_topology_item)
                                            : set_of_reversible_topology_item;
     LOCAL
       the_reverse : set_of_reversible_topology_item;
     END_LOCAL;
     
     the_reverse := [];
     REPEAT i := 1 TO SIZEOF (a_set);
       the_reverse := the_reverse + topology_reversed (a_set [i]);
     END_REPEAT;
     
     RETURN (the_reverse);

  END_FUNCTION;

  FUNCTION shell_reversed
  (a_shell : shell) : shell;
     IF ('TOPOLOGY_SCHEMA.OPEN_SHELL' IN TYPEOF (a_shell) ) THEN
       RETURN (open_shell_reversed (a_shell));
     ELSE
       IF ('TOPOLOGY_SCHEMA.CLOSED_SHELL' IN TYPEOF (a_shell) ) THEN
         RETURN (closed_shell_reversed (a_shell));
       ELSE
         RETURN (?);
       END_IF;
     END_IF;

  END_FUNCTION;

  FUNCTION surface_condition_correlation
  (pd: property_definition; rep: representation): LOGICAL;
  
  CASE pd.name OF
  'visual appearance', 'tactile appearance', 'contact ratio', 'hardness', 'treatment result', 'surface texture' : 
  	RETURN(pd.name = rep.name);
  
  OTHERWISE : RETURN(UNKNOWN);
  END_CASE;

  END_FUNCTION;

  FUNCTION surface_weights_positive
  (b: rational_b_spline_surface) : BOOLEAN;
     LOCAL
       result        : BOOLEAN := TRUE;
     END_LOCAL;
     
     REPEAT i := 0 TO b.u_upper;
       REPEAT j := 0 TO b.v_upper;
         IF (b.weights[i][j] <= 0.0)  THEN
           result := FALSE;
           RETURN(result);
         END_IF;
       END_REPEAT;
     END_REPEAT;
     RETURN(result);

  END_FUNCTION;

  FUNCTION topology_reversed
  (an_item : reversible_topology)
                                       : reversible_topology;
  
     IF ('TOPOLOGY_SCHEMA.EDGE' IN TYPEOF (an_item)) THEN
       RETURN (edge_reversed (an_item));
     END_IF;
  
     IF ('TOPOLOGY_SCHEMA.PATH' IN TYPEOF (an_item)) THEN
       RETURN (path_reversed (an_item));
     END_IF;
  
     IF ('TOPOLOGY_SCHEMA.FACE_BOUND' IN TYPEOF (an_item)) THEN
       RETURN (face_bound_reversed (an_item));
     END_IF;
    
     IF ('TOPOLOGY_SCHEMA.FACE' IN TYPEOF (an_item)) THEN
       RETURN (face_reversed (an_item));
     END_IF;
  
     IF ('TOPOLOGY_SCHEMA.SHELL' IN TYPEOF (an_item)) THEN
       RETURN (shell_reversed (an_item));
     END_IF;
  
     IF ('SET' IN TYPEOF (an_item)) THEN
       RETURN (set_of_topology_reversed (an_item));
     END_IF;
  
     IF ('LIST' IN TYPEOF (an_item)) THEN
       RETURN (list_of_topology_reversed (an_item));
     END_IF;
  
     RETURN (?);

  END_FUNCTION;

  FUNCTION type_check_function
  (the_type : GENERIC; sub_names : SET OF STRING; criterion : INTEGER) : LOGICAL; 
  IF (( NOT EXISTS ( the_type ) ) OR (NOT ({0<= criterion <=3})) OR
  (SIZEOF ( sub_names ) = 0 ) ) THEN RETURN (UNKNOWN);
  ELSE
    CASE criterion OF
         0: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) > 0);
         1: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 0);
         2: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) = 1);
         3: RETURN (SIZEOF ( sub_names * TYPEOF (the_type) ) <= 1);
    END_CASE;
  END_IF;

  END_FUNCTION;

  FUNCTION using_items
  (item : founded_item_select;
                        checked_items: SET OF founded_item_select)
                      : SET OF founded_item_select;
    LOCAL
      new_check_items    : SET OF founded_item_select;
      result_items       : SET OF founded_item_select;
      next_items         : SET OF founded_item_select;
    END_LOCAL;
    result_items := [];
    new_check_items := checked_items + item;
    -- Find the set of representation_items or founded_items
    -- in which item is used directly.
    next_items := QUERY(z <* bag_to_set( USEDIN(item , '')) |
      ('REPRESENTATION_SCHEMA.REPRESENTATION_ITEM' IN TYPEOF(z)) OR
      ('REPRESENTATION_SCHEMA.FOUNDED_ITEM'        IN TYPEOF(z)));
    -- If the set of next_items is not empty;
    IF SIZEOF(next_items) > 0 THEN
      -- For each element in the set, find the using_items recursively
      REPEAT i := 1 TO HIINDEX(next_items);
        -- Check for loop in data model, i.e. one of the next_items
        -- occurred earlier in the set of check_items;
        IF NOT(next_items[i] IN new_check_items) THEN
          result_items := result_items + next_items[i] +
                          using_items(next_items[i],new_check_items);
        END_IF;
      END_REPEAT;
    END_IF;
    -- return the set of representation_items or founded_items
    -- in which the input item is used directly and indirectly.
    RETURN (result_items);

  END_FUNCTION;

  FUNCTION using_representations
  (item : founded_item_select)
    : SET OF representation;
    LOCAL
      results            : SET OF representation;
      result_bag         : BAG OF representation;
      intermediate_items : SET OF founded_item_select;
    END_LOCAL;
    -- Find the representations in which the item is used and add to the
    -- results set.
    results := [];
    result_bag :=
  USEDIN(item,'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
    IF SIZEOF(result_bag) > 0 THEN
      REPEAT i := 1 TO HIINDEX(result_bag);
        results := results + result_bag[i];
      END_REPEAT;
    END_IF;
    -- Find all representation_items or founded_items
    -- by which item is referenced directly or indirectly.
    intermediate_items := using_items(item,[]);
    -- If the set of intermediate items is not empty;
    IF SIZEOF(intermediate_items) > 0 THEN
      -- For each element in the set, add the
      -- representations of that element.
      REPEAT i := 1 TO HIINDEX(intermediate_items);
        result_bag := USEDIN(intermediate_items[i],
                      'REPRESENTATION_SCHEMA.REPRESENTATION.ITEMS');
        IF SIZEOF(result_bag) > 0 THEN
          REPEAT j := 1 TO HIINDEX(result_bag);
            results := results + result_bag[j];
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
    -- Return the set of representation in which the input item is
    -- used directly and indirectly (through intervening
    -- representation_items or founded items).
    RETURN (results);

  END_FUNCTION;

  FUNCTION valid_basis_curve_in_2d_wireframe
  (crv: curve) : BOOLEAN;
     -- check for valid basic curve types
    IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.POLYLINE',
                 'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.B_SPLINE_CURVE',
                 'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.ELLIPSE',
                 'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CIRCLE'] * 
                 TYPEOF (crv)) = 1
      THEN RETURN (TRUE);
    ELSE
      -- if the curve is a trimmed_curve
      IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.TRIMMED_CURVE') 
      IN TYPEOF (crv)) THEN
        -- if a line, parabola, or hyperbola is being trimmed, then valid
        IF SIZEOF (['AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.LINE',
                     'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.PARABOLA',
                     'AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.HYPERBOLA'] *
             TYPEOF(crv\trimmed_curve.basis_curve)) = 1
          THEN RETURN (TRUE);
        -- otherwise, recursively check basis_curve
        ELSE RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\trimmed_curve.basis_curve));
        END_IF;
      ELSE
        -- recursively check the offset_curve basis curve
        IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.OFFSET_CURVE_2D') 
        IN TYPEOF (crv))
          THEN RETURN (valid_basis_curve_in_2d_wireframe
                             (crv\offset_curve_2d.basis_curve));
        ELSE
          -- recursively check the curve_replica parent curve
          IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.CURVE_REPLICA') 
          IN TYPEOF (crv))
            THEN RETURN (valid_basis_curve_in_2d_wireframe
                           (crv\curve_replica.parent_curve));
          ELSE
            -- recursively check the composite_curve segments
            IF (('AIC_GEOMETRICALLY_BOUNDED_2D_WIREFRAME.COMPOSITE_CURVE') 
            IN TYPEOF (crv)) THEN
              RETURN (SIZEOF (QUERY (ccs <* crv\composite_curve.segments |
                        NOT (valid_basis_curve_in_2d_wireframe
                               (ccs.parent_curve)))) = 0);
            END_IF;
          END_IF;
        END_IF;
      END_IF;
    END_IF;
    RETURN (FALSE);

  END_FUNCTION;

  FUNCTION valid_calendar_date
  (date : calendar_date) : LOGICAL; 
    CASE date.month_component OF
      1  : RETURN({ 1 <= date.day_component <= 31 });
      2  : BEGIN
             IF (leap_year(date.year_component)) THEN
               RETURN({ 1 <= date.day_component <= 29 });
             ELSE
               RETURN({ 1 <= date.day_component <= 28 });
             END_IF;
           END;
      3  : RETURN({ 1 <= date.day_component <= 31 });
      4  : RETURN({ 1 <= date.day_component <= 30 });
      5  : RETURN({ 1 <= date.day_component <= 31 });
      6  : RETURN({ 1 <= date.day_component <= 30 });
      7  : RETURN({ 1 <= date.day_component <= 31 });
      8  : RETURN({ 1 <= date.day_component <= 31 });
      9  : RETURN({ 1 <= date.day_component <= 30 });
      10 : RETURN({ 1 <= date.day_component <= 31 });
      11 : RETURN({ 1 <= date.day_component <= 30 });
      12 : RETURN({ 1 <= date.day_component <= 31 });
    END_CASE;
    RETURN (FALSE);

  END_FUNCTION;

  FUNCTION valid_measure_value
  (m : measure_value) : BOOLEAN;
    IF ('REAL' IN TYPEOF (m)) THEN
    RETURN (m > 0.0);
    ELSE
      IF ('INTEGER' IN TYPEOF (m)) THEN
      RETURN (m > 0);
      ELSE
        RETURN (TRUE);
      END_IF;
    END_IF;

  END_FUNCTION;

  FUNCTION valid_selected_instance_representation
  (pd: product_definition_or_assembly_relationship): LOGICAL;
  LOCAL
    properties: SET OF property_definition :=[];
    property_definition_representations: SET OF property_definition_representation :=[];
    selected_representation: representation;
  END_LOCAL;
  
  properties :=QUERY( prd<* USEDIN ( pd ,'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION.DEFINITION' ) | 
   (prd.name = 'occurrence selection' ));
  IF (SIZEOF( properties)<>1) THEN
  	RETURN(FALSE);
  END_IF;
  
  property_definition_representations := QUERY ( pdr <* USEDIN ( properties[1] , 'PRODUCT_OCCURRENCE_MIM.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION') | 
  	( pdr.used_representation.name = 'selection criteria' ));
  IF (SIZEOF(property_definition_representations)<>1) THEN
  	RETURN(FALSE);
  END_IF;
  
  selected_representation := property_definition_representations[1].used_representation;
  
  IF (SIZEOF(selected_representation.items) <1) OR (SIZEOF(selected_representation.items) >2) THEN
  	RETURN(FALSE);
  END_IF;
  
  IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
  	( SIZEOF (['PRODUCT_OCCURRENCE_MIM.MEASURE_REPRESENTATION_ITEM' ,
  			'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF ( i ) ) = 1) AND
   	( i.name = 'selection quantity' ))) <> 1 ) THEN
  	RETURN(FALSE);
  END_IF;
  
  IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
  	( 'PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF ( i ) ) AND
   	( i.name = 'selection control' )))> 1) THEN
  	RETURN(FALSE);
  END_IF;
  
  -- if the selection control is not specified then the quantity shall be a qualified_representation_item or a value_range
  IF (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
  	( 'PRODUCT_OCCURRENCE_MIM.DESCRIPTIVE_REPRESENTATION_ITEM' IN TYPEOF( i ) ) AND
   	( i.name = 'selection control' ) ))= 0) AND 
     (SIZEOF ( QUERY ( i <* selected_representation.used_representation.items |
        ( i.name = 'selection quantity' ) AND  
        ( SIZEOF(['PRODUCT_OCCURRENCE_MIM.QUALIFIED_REPRESENTATION_ITEM' ,
  		'PRODUCT_OCCURRENCE_MIM.VALUE_RANGE']* TYPEOF ( i ) ) =0 ))) > 0 ) THEN
  	RETURN(FALSE);
  END_IF;
  	
  RETURN(TRUE);

  END_FUNCTION;

  FUNCTION valid_time
  (time : local_time) : BOOLEAN; 
    IF EXISTS(time.second_component) THEN
      RETURN (EXISTS(time.minute_component));
    ELSE
      RETURN (TRUE);
    END_IF;

  END_FUNCTION;

  FUNCTION valid_units
  (m : measure_with_unit) : BOOLEAN; 
   IF 'MEASURE_SCHEMA.LENGTH_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.MASS_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.TIME_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.ELECTRIC_CURRENT_MEASURE' 
    IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.THERMODYNAMIC_TEMPERATURE_MEASURE'
    IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.CELSIUS_TEMPERATURE_MEASURE'
    IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AMOUNT_OF_SUBSTANCE_MEASURE' 
    IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.LUMINOUS_INTENSITY_MEASURE' 
    IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.PLANE_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.SOLID_ANGLE_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.AREA_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.VOLUME_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.RATIO_MEASURE' IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_LENGTH_MEASURE' 
    IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    IF 'MEASURE_SCHEMA.POSITIVE_PLANE_ANGLE_MEASURE' 
    IN TYPEOF ( m.value_component ) THEN
      IF derive_dimensional_exponents ( m.unit_component ) <>
         dimensional_exponents ( 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ) THEN
        RETURN (FALSE);
      END_IF;
    END_IF;
    RETURN (TRUE);

  END_FUNCTION;

  FUNCTION value_range_aggregate_rep_item
  (agg : AGGREGATE OF representation_item) : BOOLEAN; 
    BEGIN 
    IF (SIZEOF(QUERY(i1 <* agg | ('INERTIA_CHARACTERISTICS_MIM' + '.MEASURE_REPRESENTATION_ITEM' IN TYPEOF(i1)) )) = 6) THEN 
  	  RETURN (TRUE); 
     ELSE 
  	RETURN (FALSE); 
     END_IF; 
     END;

  END_FUNCTION;

  FUNCTION value_range_wr1
  (agg : compound_item_definition) : BOOLEAN; 
  BEGIN
  IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY (i1 <* agg | (
  'QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF
  (i1)))) = 2) OR
  (SIZEOF(QUERY (i2 <* agg | (
  'REPRESENTATION_SCHEMA.VALUE_REPRESENTATION_ITEM' IN TYPEOF
  (i2)))) = 2)) THEN
  RETURN(TRUE);
  ELSE
  RETURN(FALSE);
  END_IF;
  END;

  END_FUNCTION;

  FUNCTION value_range_wr2
  (agg : compound_item_definition) : BOOLEAN; 
  BEGIN
  IF (SIZEOF(QUERY (i <* agg | (i.name = 'upper limit'))) = 1)
  AND (SIZEOF(QUERY (i <* agg | (i.name = 'lower limit'))) = 1)
  THEN
  RETURN(TRUE);
  ELSE
  RETURN(FALSE);
  END_IF;
  END;

  END_FUNCTION;

  FUNCTION value_range_wr3
  (agg : compound_item_definition) : BOOLEAN; 
  BEGIN
  IF (SIZEOF(QUERY(i1 <* agg |
  ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i1)) AND
  (SIZEOF (QUERY (i2 <* agg |
  ('QUALIFIED_MEASURE_SCHEMA.MEASURE_REPRESENTATION_ITEM' IN TYPEOF (i2)) AND
  (i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\measure_with_unit.unit_component))) = 1))) = 2)
  THEN
  RETURN (TRUE);
  ELSE
  RETURN (FALSE);
  END_IF;
  END;

  END_FUNCTION;

  FUNCTION vector_difference
  (arg1, arg2 : vector_or_direction) : vector;
     LOCAL
       result          : vector;
       res, vec1, vec2 : direction;
       mag, mag1, mag2 : REAL;
       ndim            : INTEGER;
     END_LOCAL;
  
     IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
         THEN
       RETURN (?) ;
      ELSE
       BEGIN
         IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
           mag1 := arg1.magnitude;
           vec1 := arg1.orientation;
         ELSE
           mag1 := 1.0;
           vec1 := arg1;
         END_IF;
         IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
           mag2 := arg2.magnitude;
           vec2 := arg2.orientation;
         ELSE
           mag2 := 1.0;
           vec2 := arg2;
         END_IF;
         vec1 := normalise (vec1);
         vec2 := normalise (vec2);
         ndim := SIZEOF(vec1.direction_ratios);
         mag := 0.0;
         res := dummy_gri || direction(vec1.direction_ratios);
         REPEAT i := 1 TO ndim;
           res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                       mag2*vec2.direction_ratios[i];
           mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
         END_REPEAT;
         IF (mag > 0.0 ) THEN
         result := dummy_gri || vector( res, SQRT(mag));
         ELSE
           result := dummy_gri || vector( vec1,  0.0);
         END_IF;
       END;
     END_IF;
     RETURN (result);

  END_FUNCTION;

  FUNCTION vector_sum
  (arg1, arg2 : vector_or_direction) : vector;
     LOCAL
       result          : vector;
       res, vec1, vec2 : direction;
       mag, mag1, mag2 : REAL;
       ndim            : INTEGER;
     END_LOCAL;
  
     IF ((NOT EXISTS (arg1)) OR (NOT EXISTS (arg2))) OR (arg1.dim <> arg2.dim)
         THEN
       RETURN (?) ;
  
     ELSE
       BEGIN
         IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg1) THEN
           mag1 := arg1.magnitude;
           vec1 := arg1.orientation;
         ELSE
           mag1 := 1.0;
           vec1 := arg1;
         END_IF;
         IF 'GEOMETRY_SCHEMA.VECTOR' IN TYPEOF(arg2) THEN
           mag2 := arg2.magnitude;
           vec2 := arg2.orientation;
         ELSE
           mag2 := 1.0;
           vec2 := arg2;
         END_IF;
         vec1 := normalise (vec1);
         vec2 := normalise (vec2);
         ndim := SIZEOF(vec1.direction_ratios);
         mag := 0.0;
         res := dummy_gri || direction(vec1.direction_ratios);
         REPEAT i := 1 TO ndim;
           res.direction_ratios[i] := mag1*vec1.direction_ratios[i] +
                                        mag2*vec2.direction_ratios[i];
           mag := mag + (res.direction_ratios[i]*res.direction_ratios[i]);
         END_REPEAT;
         IF (mag > 0.0 ) THEN
         result := dummy_gri || vector( res, SQRT(mag));
         ELSE
           result := dummy_gri || vector( vec1,  0.0);
         END_IF;
       END;
     END_IF;
     RETURN (result);

  END_FUNCTION;

  FUNCTION vertex_point_pcurves
  (a_vertex  : vertex_point; 
        the_degenerates : SET OF evaluated_degenerate_pcurve)
        : SET OF degenerate_pcurve;
  LOCAL
    a_point : point;
    result  : SET OF degenerate_pcurve;
  END_LOCAL;
    a_point := a_vertex.vertex_geometry;
    result := [];
    IF 'GEOMETRY_SCHEMA.DEGENERATE_PCURVE' IN TYPEOF(a_point) THEN
      result := result + a_point;
    ELSE
        REPEAT j := 1 TO SIZEOF(the_degenerates);
           IF (the_degenerates[j].equivalent_point :=: a_point)  THEN
              result := result + the_degenerates[j];
           END_IF;
        END_REPEAT;
    END_IF;
  
    RETURN (RESULT);

  END_FUNCTION;

  FUNCTION volume_weights_positive
  (b: rational_b_spline_volume): BOOLEAN;
       LOCAL
         result   : BOOLEAN := TRUE;
       END_LOCAL;
  
       REPEAT i := 0 TO b.u_upper;
         REPEAT j := 0 TO b.v_upper;
           REPEAT k := 0 TO b.w_upper;
             IF (b.weights[i][j][k] <= 0.0)  THEN
               result := FALSE;
               RETURN(result);
             END_IF;
           END_REPEAT;
         END_REPEAT;
       END_REPEAT;
       RETURN(result);

  END_FUNCTION;

  RULE compatible_dimension FOR
    (cartesian_point,
     direction,
     geometric_representation_context);
    WHERE
      WR1 : -- ensure that the count of coordinates of each cartesian_point
            -- matches the coordinate_space_dimension of each geometric_context in
            -- which it is geometrically founded
            SIZEOF(QUERY(x <* cartesian_point| SIZEOF(QUERY
            (y <* geometric_representation_context | item_in_context(x,y) AND
            (HIINDEX(x.coordinates) <> y.coordinate_space_dimension))) > 0 )) =0;
      WR2 : SIZEOF(QUERY(x <* direction | SIZEOF( QUERY
            (y <* geometric_representation_context | item_in_context(x,y) AND
            (HIINDEX(x.direction_ratios) <> y.coordinate_space_dimension)))
            > 0 )) = 0;
  END_RULE;

  RULE plib_property_reference_requires_name_scope FOR
    (externally_defined_general_property);
    LOCAL
       known_sourced_properties : SET OF externally_defined_general_property;
    END_LOCAL;
      known_sourced_properties := QUERY( edc <* externally_defined_general_property | 
    	'EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' IN TYPEOF(edc.source) );
    WHERE
      WR1 : SIZEOF ( QUERY ( edgp <* known_sourced_properties | 
            ( SIZEOF ( QUERY ( edir <* USEDIN ( edgp, 'EXTERNAL_PROPERTIES_MIM' + '.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATING_ITEM' )| 
            ( edir.name =  'name scope' ) AND 
            ('EXTERNAL_PROPERTIES_MIM' + '.EXTERNALLY_DEFINED_CLASS' IN  TYPEOF ( edir.related_item ) ) AND 
            ( 'EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' IN TYPEOF ( edir.related_item.source ) ) ) ) <>1 ) ) ) =  0;
  END_RULE;

  RULE plib_property_reference_requires_version FOR
    (externally_defined_general_property);
    LOCAL
      plib_properties : SET OF externally_defined_general_property := [];
    END_LOCAL;
    plib_properties := QUERY ( edgp <* externally_defined_general_property | 
    	( 'EXTERNAL_PROPERTIES_MIM' + '.KNOWN_SOURCE' IN TYPEOF ( edgp.source ) ) AND
    	( known_source\pre_defined_item.name = 'ISO 13584 library' ) );
    WHERE
      WR1 : SIZEOF( QUERY( edgp <* plib_properties | 
            (SIZEOF( QUERY( edir <* USEDIN(edgp, 'EXTERNAL_PROPERTIES_MIM' + '.APPLIED_EXTERNAL_IDENTIFICATION_ASSIGNMENT.ITEMS') | 
            (edir.role.name = 'version') )) <> 1) )) = 0;
  END_RULE;

  RULE restrict_language_assignment_per_attribute FOR
    (attribute_language_assignment);
    WHERE
      WR1 : SIZEOF ( QUERY ( ala1 <* attribute_language_assignment |
            SIZEOF(QUERY( it <* ala1.items |
            SIZEOF ( QUERY ( ala2 <* USEDIN ( it ,'MULTI_LINGUISM_MIM.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS' ) | 
            ( ala1\attribute_classification_assignment.attribute_name = ala2\attribute_classification_assignment.attribute_name ) AND 
            ( ala1\attribute_classification_assignment.assigned_class :=: ala2\attribute_classification_assignment.assigned_class )
            )) >1 
            )) >0 
            )) =0;
  END_RULE;

  SUBTYPE_CONSTRAINT classification_or_complete_membership FOR classification_assignment;
    ONEOF(classification, complete_membership);
  END_SUBTYPE_CONSTRAINT;


END_SCHEMA;

