(*
   $Id: mim_lf.exp,v 1.1 2003/04/24 17:59:37 robbod Exp $
   N - ISO/CD-TS - 10303- ap239_product_life_cycle_support - EXPRESS MIM_LF*)
(* UNDER DEVELOPMENT *)

SCHEMA ap239_product_life_cycle_support_mim_lf;

 
CONSTANT
  dummy_gri : geometric_representation_item := representation_item('')||
  geometric_representation_item();
  schema_name : STRING := 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF';
  dummy_tri : topological_representation_item := representation_item('')||
  topological_representation_item();
(* schema_name : STRING := 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF'; *)
END_CONSTANT;
 
TYPE actchar_ap239_mri_attribute_classification_item = SELECT 
  (name_attribute, event_occurrence_context_role, organization_role, 
  approval_relationship, contract_type, organization_relationship, 
  approval_status, group, person_and_organization_role, 
  organizational_project_role, date_role, certification, 
  person_and_organization_address, event_occurrence_relationship, 
  identification_role, certification_type, approval, 
  security_classification_level, organizational_address, approval_role, 
  organizational_project_relationship, date_time_role, object_role, 
  action_relationship, executed_action);
END_TYPE;
 
TYPE actchar_ap239_mri_classification_item = SELECT 
  (language, event_occurrence_relationship, organizational_project_relationship
  , applied_certification_assignment, certification, approval, 
  person_and_organization, applied_event_occurrence_assignment, 
  approval_person_organization, person_and_organization_address, 
  event_occurrence, applied_organizational_project_assignment, 
  applied_organization_assignment, organizational_address, contract, 
  approval_relationship, organization_relationship, 
  applied_identification_assignment, applied_date_and_time_assignment, 
  applied_approval_assignment, date_and_time, approval_status, 
  applied_date_assignment, organizational_project, applied_contract_assignment
  , security_classification, multi_language_attribute_assignment, 
  applied_person_and_organization_assignment, calendar_date, 
  applied_security_classification_assignment, organization, address, 
  action_relationship, executed_action);
END_TYPE;
 
TYPE actchar_mri_approval_item = SELECT 
  (contract, certification, executed_action);
END_TYPE;
 
TYPE actchar_mri_attribute_language_item = SELECT 
  (organizational_project_role, certification, contract, 
  person_and_organization, date_time_role, date_role, identification_role, 
  approval, approval_status, approval_relationship, organization_relationship, 
  organizational_project_relationship, organizational_project, 
  certification_type, action_relationship, executed_action);
END_TYPE;
 
TYPE actchar_mri_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, action_relationship, 
  executed_action);
END_TYPE;
 
TYPE actchar_mri_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, action_relationship, executed_action);
END_TYPE;
 
TYPE actchar_mri_identification_item = SELECT 
  (security_classification_level, organization, contract, executed_action);
END_TYPE;
 
TYPE actchar_mri_multi_language_attribute_item = SELECT 
  (organizational_project_role, date_time_role, date_role, contract, 
  organization_relationship, certification_type, certification, 
  organizational_project_relationship, approval, person_and_organization, 
  approval_status, organizational_project, identification_role, 
  multi_language_attribute_assignment, approval_relationship, 
  action_relationship, executed_action);
END_TYPE;
 
TYPE actchar_mri_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, action_relationship, 
  executed_action);
END_TYPE;
 
TYPE actchar_mri_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, action_relationship, executed_action);
END_TYPE;
 
TYPE action_items = SELECT 
  (action, action_method, product_group, product_definition, 
  product_definition_formation, document_file, action_resource, organization, 
  product_as_realized, person_and_organization, ascribable_state, product, 
  event_occurrence, representation, product_definition_relationship, contract, 
  person);
END_TYPE;
 
TYPE action_method_implementation_groupable_item = SELECT 
  (action_method_relationship);
END_TYPE;
 
TYPE action_method_implementation_identification_item = SELECT 
  (action_method_relationship);
END_TYPE;
 
TYPE action_method_items = SELECT 
  (product_group, product_definition_relationship, contract, action, 
  action_resource, product_definition_formation, location, state_type, 
  person_type_definition, action_resource_requirement, person_type, 
  breakdown_element_usage, state_type_relationship, product_definition, 
  applied_action_method_assignment, position_in_organization, product, person, 
  organizational_project, event_occurrence, organization, 
  position_in_organization_type, action_method_relationship, action_method, 
  document_file, product_as_individual, person_and_organization, 
  applied_action_assignment, organization_role);
END_TYPE;
 
TYPE action_request_item = SELECT 
  (product_definition, document_file, product, action_resource, organization, 
  person_and_organization, person, product_group, product_definition_formation
  , action_method, product_definition_relationship, contract);
END_TYPE;
 
TYPE activity_method_implementation_classification_item = SELECT 
  (action_method_relationship, group);
END_TYPE;
 
TYPE actmethchar_ap239_mri_attribute_classification_item = SELECT 
  (name_attribute, event_occurrence_context_role, organization_role, 
  approval_relationship, contract_type, organization_relationship, 
  approval_status, group, person_and_organization_role, 
  organizational_project_role, date_role, certification, 
  person_and_organization_address, event_occurrence_relationship, 
  identification_role, certification_type, approval, 
  security_classification_level, organizational_address, approval_role, 
  organizational_project_relationship, date_time_role, object_role, 
  action_method);
END_TYPE;
 
TYPE actmethchar_ap239_mri_classification_item = SELECT 
  (language, event_occurrence_relationship, organizational_project_relationship
  , applied_certification_assignment, certification, approval, 
  person_and_organization, applied_event_occurrence_assignment, 
  approval_person_organization, person_and_organization_address, 
  event_occurrence, applied_organizational_project_assignment, 
  applied_organization_assignment, organizational_address, contract, 
  approval_relationship, organization_relationship, 
  applied_identification_assignment, applied_date_and_time_assignment, 
  applied_approval_assignment, date_and_time, approval_status, 
  applied_date_assignment, organizational_project, applied_contract_assignment
  , security_classification, multi_language_attribute_assignment, 
  applied_person_and_organization_assignment, calendar_date, 
  applied_security_classification_assignment, organization, address, 
  action_method);
END_TYPE;
 
TYPE actmethchar_mri_approval_item = SELECT 
  (contract, certification, action_method);
END_TYPE;
 
TYPE actmethchar_mri_attribute_language_item = SELECT 
  (organizational_project_role, date_time_role, date_role, contract, 
  organization_relationship, certification_type, certification, 
  organizational_project_relationship, approval, person_and_organization, 
  approval_status, organizational_project, identification_role, 
  multi_language_attribute_assignment, approval_relationship, action_method);
END_TYPE;
 
TYPE actmethchar_mri_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, action_method);
END_TYPE;
 
TYPE actmethchar_mri_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, action_method);
END_TYPE;
 
TYPE actmethchar_mri_identification_item = SELECT 
  (security_classification_level, organization, contract, action_method);
END_TYPE;
 
TYPE actmethchar_mri_multi_language_attribute_item = SELECT 
  (organizational_project_role, certification, contract, 
  person_and_organization, date_time_role, date_role, identification_role, 
  approval, approval_status, approval_relationship, organization_relationship, 
  organizational_project_relationship, organizational_project, 
  certification_type, action_method);
END_TYPE;
 
TYPE actmethchar_mri_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, action_method);
END_TYPE;
 
TYPE actmethchar_mri_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, action_method);
END_TYPE;
 
TYPE ahead_or_behind = ENUMERATION OF 
  (ahead, exact, behind);
END_TYPE;
 
TYPE aliasable_item = SELECT 
  (product_definition_relationship, product_definition, organization, 
  interface_connector_as_planned, document_file, product_as_planned, 
  interface_connector_as_realized, interface_connector_design, 
  product_definition_formation, requirement_source, requirement_assignment, 
  organizational_project, product, approval_status, 
  product_definition_formation_relationship, event_occurrence, 
  product_as_realized, certification, security_classification);
END_TYPE;
 
TYPE amount_of_substance_measure = REAL;
END_TYPE;
 
TYPE ap239_dm_approval_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment);
END_TYPE;
 
TYPE ap239_dm_attribute_classification_item = SELECT 
  (descriptive_representation_item, document_relationship, document_type, 
  document_usage_role, envelope, envelope_relationship, identification_role, 
  information_right, information_usage_right, measure_representation_item, 
  message_relationship, object_role, product_definition_relationship, 
  representation, representation_item, structured_message, usage_association);
END_TYPE;
 
TYPE ap239_dm_attribute_language_item = SELECT 
  (multi_language_attribute_assignment, envelope, envelope_relationship, 
  information_right, information_usage_right, message_relationship, 
  structured_message);
END_TYPE;
 
TYPE ap239_dm_classification_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment, 
  applied_external_identification_assignment, applied_usage_right, 
  descriptive_representation_item, document_file, document_relationship, 
  envelope, envelope_relationship, information_right, information_usage_right, 
  measure_representation_item, message_relationship, product, 
  product_definition, product_definition_formation, 
  product_definition_relationship, representation, structured_message, 
  usage_association);
END_TYPE;
 
TYPE ap239_dm_contract_item = SELECT 
  (product, structured_message);
END_TYPE;
 
TYPE ap239_dm_date_and_time_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment, 
  applied_usage_right, product);
END_TYPE;
 
TYPE ap239_dm_date_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment, 
  applied_usage_right, product);
END_TYPE;
 
TYPE ap239_dm_document_reference_item = SELECT 
  (applied_identification_assignment, certification, contract, 
  information_right, information_usage_right, organization, person);
END_TYPE;
 
TYPE ap239_dm_ir_usage_item = SELECT 
  (applied_certification_assignment, certification, document_file, 
  document_relationship, product, product_definition, 
  product_definition_formation, product_definition_relationship, 
  structured_message);
END_TYPE;
 
TYPE ap239_dm_multi_language_attribute_item = SELECT 
  (envelope, envelope_relationship, information_right, information_usage_right
  , message_relationship, structured_message);
END_TYPE;
 
TYPE ap239_dm_organization_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment);
END_TYPE;
 
TYPE ap239_dm_person_and_organization_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment);
END_TYPE;
 
TYPE ap239_dm_security_classification_item = SELECT 
  (applied_document_reference, applied_document_usage_constraint_assignment);
END_TYPE;
 
TYPE ap239_dm_state_of_item = SELECT 
  (applied_external_identification_assignment, document_file, product, 
  product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_dm_state_type_of_item = SELECT 
  (applied_external_identification_assignment, document_file, product, 
  product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_mri_aliasable_item = SELECT 
  (approval_status, certification, event_occurrence, organization, 
  organizational_project, security_classification);
END_TYPE;
 
TYPE ap239_mri_approval_item = SELECT 
  (applied_contract_assignment, applied_event_occurrence_assignment, 
  applied_identification_assignment, applied_organizational_project_assignment
  , event_occurrence, organizational_project);
END_TYPE;
 
TYPE ap239_mri_attribute_classification_item = SELECT 
  (approval, approval_relationship, approval_role, approval_status, 
  certification, certification_type, contract_type, date_role, date_time_role, 
  event_occurrence_context_role, event_occurrence_relationship, group, 
  identification_role, name_attribute, object_role, organization_relationship, 
  organization_role, organizational_address, 
  organizational_project_relationship, organizational_project_role, 
  person_and_organization_address, person_and_organization_role, 
  security_classification_level, action_request_status, state_observed, 
  applied_state_assignment, executed_action, state_type, action_relationship, 
  state_observed_relationship, state_type_relationship, action_method, 
  applied_state_type_assignment, action_directive, versioned_action_request);
END_TYPE;
 
TYPE ap239_mri_attribute_language_item = SELECT 
  (multi_language_attribute_assignment, event_occurrence);
END_TYPE;
 
TYPE ap239_mri_certification_item = SELECT 
  (organizational_project);
END_TYPE;
 
TYPE ap239_mri_classification_item = SELECT 
  (address, applied_approval_assignment, applied_certification_assignment, 
  applied_contract_assignment, applied_date_and_time_assignment, 
  applied_date_assignment, applied_event_occurrence_assignment, 
  applied_identification_assignment, applied_organization_assignment, 
  applied_organizational_project_assignment, 
  applied_person_and_organization_assignment, 
  applied_security_classification_assignment, approval, 
  approval_person_organization, approval_relationship, approval_status, 
  calendar_date, certification, contract, date_and_time, event_occurrence, 
  event_occurrence_relationship, language, multi_language_attribute_assignment
  , organization, organization_relationship, organizational_address, 
  organizational_project, organizational_project_relationship, 
  person_and_organization, person_and_organization_address, 
  security_classification, versioned_action_request, action_directive, 
  action_method, action_relationship, applied_action_request_assignment, 
  directed_action, executed_action);
END_TYPE;
 
TYPE ap239_mri_date_and_time_item = SELECT 
  (applied_certification_assignment, applied_contract_assignment, 
  applied_identification_assignment, organizational_address, 
  person_and_organization_address);
END_TYPE;
 
TYPE ap239_mri_date_item = SELECT 
  (applied_certification_assignment, applied_contract_assignment, 
  applied_identification_assignment, organizational_address, 
  person_and_organization_address);
END_TYPE;
 
TYPE ap239_mri_event_occurrence_item = SELECT 
  (certification, organizational_project);
END_TYPE;
 
TYPE ap239_mri_identification_item = SELECT 
  (approval_status, certification, event_occurrence, organization, 
  organizational_project, security_classification);
END_TYPE;
 
TYPE ap239_mri_multi_language_attribute_item = SELECT 
  (event_occurrence);
END_TYPE;
 
TYPE ap239_mri_organization_item = SELECT 
  (applied_certification_assignment, applied_contract_assignment, 
  applied_event_occurrence_assignment, 
  applied_organizational_project_assignment, certification, event_occurrence, 
  organizational_project);
END_TYPE;
 
TYPE ap239_mri_person_and_organization_item = SELECT 
  (applied_certification_assignment, applied_contract_assignment, 
  applied_event_occurrence_assignment, 
  applied_organizational_project_assignment, certification, event_occurrence, 
  organizational_project);
END_TYPE;
 
TYPE ap239_padi_aliasable_item = SELECT 
  (interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, product, product_as_planned, product_as_realized
  , product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_approval_item = SELECT 
  (interface_connection, interface_connector_as_planned, 
  interface_connector_as_realized, interface_connector_design, 
  interface_connector_design_to_planned, interface_connector_design_to_realized
  , interface_connector_planned_to_realized, product, product_as_planned, 
  product_as_realized, product_concept, product_definition, 
  product_definition_formation, product_design_to_individual, 
  product_planned_to_realized);
END_TYPE;
 
TYPE ap239_padi_attribute_classification_item = SELECT 
  (application_context, application_context_element, product_category, 
  product_concept, product_concept_context, product_definition, 
  product_definition_context, product_definition_formation_relationship, 
  product_definition_relationship);
END_TYPE;
 
TYPE ap239_padi_attribute_language_item = SELECT 
  (multi_language_attribute_assignment, connector_on, product, 
  product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_certification_item = SELECT 
  (interface_connection, product, product_as_planned, product_as_realized, 
  product_definition_formation, product_definition_formation_relationship);
END_TYPE;
 
TYPE ap239_padi_classification_item = SELECT 
  (interface_connection, interface_connector_as_planned, 
  interface_connector_as_realized, interface_connector_design, 
  interface_connector_design_to_planned, interface_connector_design_to_realized
  , interface_connector_planned_to_realized, interface_definition_for, product
  , product_as_planned, product_as_realized, product_category, product_concept
  , product_definition, product_definition_context, 
  product_definition_formation, product_definition_formation_relationship, 
  product_definition_relationship, product_design_to_individual, 
  product_planned_to_realized, requirement_assignment, requirement_source);
END_TYPE;
 
TYPE ap239_padi_condition_action_method_items = SELECT 
  (action_method_relationship, applied_approval_assignment, 
  applied_certification_assignment, applied_classification_assignment, 
  applied_contract_assignment, applied_date_and_time_assignment, 
  applied_date_assignment, applied_document_reference, 
  applied_document_usage_constraint_assignment, 
  applied_identification_assignment, applied_organization_assignment, 
  applied_person_and_organization_assignment, calendar_date, date_and_time, 
  product, product_as_individual, product_definition, 
  product_definition_formation, product_related_product_category, 
  property_definition);
END_TYPE;
 
TYPE ap239_padi_condition_evaluation_action_items = SELECT 
  (applied_approval_assignment, applied_certification_assignment, 
  applied_classification_assignment, applied_contract_assignment, 
  applied_date_and_time_assignment, applied_date_assignment, 
  applied_document_reference, applied_document_usage_constraint_assignment, 
  applied_identification_assignment, applied_organization_assignment, 
  applied_person_and_organization_assignment, calendar_date, date_and_time, 
  product, product_as_individual, product_definition, 
  product_definition_formation, product_related_product_category, 
  property_definition);
END_TYPE;
 
TYPE ap239_padi_contract_item = SELECT 
  (interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, organizational_project, product, 
  product_as_planned, product_as_realized, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_date_and_time_item = SELECT 
  (applied_organizational_project_assignment, interface_connector_as_planned, 
  interface_connector_as_realized, interface_connector_design_to_planned, 
  interface_connector_design_to_realized, 
  interface_connector_planned_to_realized, product, product_as_planned, 
  product_as_realized, product_concept, product_definition, 
  product_definition_formation, product_design_to_individual, 
  product_planned_to_realized);
END_TYPE;
 
TYPE ap239_padi_date_item = SELECT 
  (applied_organizational_project_assignment, interface_connector_as_planned, 
  interface_connector_as_realized, interface_connector_design_to_planned, 
  interface_connector_design_to_realized, 
  interface_connector_planned_to_realized, product, product_as_planned, 
  product_as_realized, product_concept, product_definition, 
  product_definition_formation, product_design_to_individual, 
  product_planned_to_realized);
END_TYPE;
 
TYPE ap239_padi_document_reference_item = SELECT 
  (interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, interface_connector_design_to_planned, 
  interface_connector_design_to_realized, 
  interface_connector_planned_to_realized, organizational_project, product, 
  product_as_planned, product_as_realized, product_concept, product_definition
  , product_definition_formation, product_definition_formation_relationship, 
  product_design_to_individual, product_planned_to_realized);
END_TYPE;
 
TYPE ap239_padi_identification_item = SELECT 
  (interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, product, product_as_planned, product_as_realized
  , product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_ir_usage_item = SELECT 
  (applied_security_classification_assignment, interface_connection, 
  interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, product, product_as_planned, product_as_realized
  , product_definition, product_definition_formation, 
  product_definition_formation_relationship, requirement_assignment, 
  security_classification);
END_TYPE;
 
TYPE ap239_padi_multi_language_attribute_item = SELECT 
  (connector_on, product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_organization_item = SELECT 
  (applied_identification_assignment, interface_connector_as_planned, 
  interface_connector_as_realized, product, product_as_planned, 
  product_as_realized, product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_person_and_organization_item = SELECT 
  (applied_identification_assignment, interface_connector_as_planned, 
  interface_connector_as_realized, product, product_as_planned, 
  product_as_realized, product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_project_item = SELECT 
  (product_concept);
END_TYPE;
 
TYPE ap239_padi_requirement_assigned_item = SELECT 
  (organizational_project, product, product_as_planned, product_as_realized, 
  product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_requirement_source_item = SELECT 
  (product_as_individual, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_security_classification_item = SELECT 
  (interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, product_as_planned, product_as_realized, 
  product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_padi_state_of_item = SELECT 
  (certification, connector_on, contract, interface_connection, 
  interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, organization, organizational_project, 
  person_and_organization, product, product_as_planned, product_as_realized, 
  product_definition, product_definition_formation, security_classification);
END_TYPE;
 
TYPE ap239_padi_state_type_of_item = SELECT 
  (certification, connector_on, contract, interface_connection, 
  interface_connector_as_planned, interface_connector_as_realized, 
  interface_connector_design, organization, organizational_project, 
  person_and_organization, product, product_as_planned, product_as_realized, 
  product_category, product_definition, product_definition_formation, 
  security_classification);
END_TYPE;
 
TYPE ap239_prdi_aliasable_item = SELECT 
  (product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_prdi_approval_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  breakdown_element_group_assignment, breakdown_element_usage, in_zone, product
  , product_definition, product_definition_formation, 
  product_definition_group_assignment, product_in_slot, 
  selected_item_assignment, slot_as_planned, slot_as_realized, slot_design, 
  slot_design_to_planned, slot_design_to_realized, slot_on_product, 
  slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_attribute_classification_item = SELECT 
  (alternate_product_relationship, breakdown_context, 
  breakdown_element_group_assignment, breakdown_element_usage, 
  product_definition_group_assignment);
END_TYPE;
 
TYPE ap239_prdi_certification_item = SELECT 
  (product);
END_TYPE;
 
TYPE ap239_prdi_classification_item = SELECT 
  (alternate_product_relationship, assembly_component_usage_substitute, 
  breakdown_context, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition_formation, 
  product_definition_group_assignment, selected_item, selected_item_assignment
  , slot_design_to_planned, slot_design_to_realized, slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_contract_item = SELECT 
  (product, product_definition_formation);
END_TYPE;
 
TYPE ap239_prdi_date_and_time_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition, 
  product_definition_formation, product_definition_group_assignment, 
  selected_item, selected_item_assignment, slot_design_to_planned, 
  slot_design_to_realized, slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_date_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition, 
  product_definition_formation, product_definition_group_assignment, 
  selected_item, selected_item_assignment, slot_design_to_planned, 
  slot_design_to_realized, slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_document_reference_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition_formation, 
  product_definition_group_assignment, selected_item, slot_design_to_planned, 
  slot_design_to_realized, slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_effectivity_item = SELECT 
  (alternate_product_relationship, applied_certification_assignment, 
  applied_contract_assignment, applied_document_reference, 
  applied_document_usage_constraint_assignment, 
  applied_external_identification_assignment, applied_identification_assignment
  , applied_organizational_project_assignment, 
  applied_security_classification_assignment, applied_usage_right, 
  assembly_component_usage, assembly_component_usage_substitute, 
  breakdown_element_group_assignment, breakdown_element_usage, 
  document_relationship, document_type, interface_connection, 
  interface_connector_design_to_planned, interface_connector_design_to_realized
  , interface_connector_planned_to_realized, make_from_usage_option, 
  organizational_address, person_and_organization_address, product, 
  product_as_individual, product_definition, product_definition_formation, 
  product_definition_formation_relationship, 
  product_definition_group_assignment, product_definition_relationship, 
  product_design_to_individual, product_in_slot, product_planned_to_realized, 
  property_definition, requirement_assignment, requirement_source, 
  selected_item_assignment, slot_as_planned, slot_as_realized, slot_design, 
  slot_design_to_planned, slot_design_to_realized, slot_on_product, 
  slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_identification_item = SELECT 
  (product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE ap239_prdi_ir_usage_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition, 
  product_definition_formation, product_definition_group_assignment, 
  slot_design_to_planned, slot_design_to_realized, slot_on_product);
END_TYPE;
 
TYPE ap239_prdi_multi_language_attribute_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_as_individual, product_definition, 
  product_definition_formation, product_definition_group_assignment, 
  slot_design_to_planned, slot_design_to_realized, slot_on_product, 
  slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_organization_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition_formation, 
  product_definition_group_assignment, selected_item, selected_item_assignment)
  ;
END_TYPE;
 
TYPE ap239_prdi_person_and_organization_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition_formation, 
  product_definition_group_assignment, selected_item, selected_item_assignment)
  ;
END_TYPE;
 
TYPE ap239_prdi_project_item = SELECT 
  (product);
END_TYPE;
 
TYPE ap239_prdi_requirement_assigned_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition_formation, 
  product_definition_group_assignment, product_in_slot);
END_TYPE;
 
TYPE ap239_prdi_security_classification_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition, 
  product_definition_formation, product_definition_group_assignment, 
  slot_design_to_planned, slot_design_to_realized, slot_on_product, 
  slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_selected_item_context_items = SELECT 
  (contract, organizational_project, product, product_concept);
END_TYPE;
 
TYPE ap239_prdi_selected_item_select = SELECT 
  (product, product_definition_formation);
END_TYPE;
 
TYPE ap239_prdi_state_of_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition, 
  product_definition_formation, product_definition_group_assignment, 
  product_in_slot, slot_design_to_planned, slot_design_to_realized, 
  slot_on_product, slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_prdi_state_type_of_item = SELECT 
  (alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute, breakdown_element_group_assignment, 
  breakdown_element_usage, product, product_definition, 
  product_definition_formation, product_definition_group_assignment, 
  product_in_slot, slot_design_to_planned, slot_design_to_realized, 
  slot_on_product, slot_planned_to_realized);
END_TYPE;
 
TYPE ap239_props_approval_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship);
END_TYPE;
 
TYPE ap239_props_attribute_classification_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship, property_definition_representation, 
  representation, representation_context, representation_item);
END_TYPE;
 
TYPE ap239_props_attribute_language_item = SELECT 
  (multi_language_attribute_assignment, general_property, 
  general_property_relationship, property_definition, 
  property_definition_relationship, representation_item);
END_TYPE;
 
TYPE ap239_props_classification_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship, property_definition_representation, 
  representation, representation_context, representation_item);
END_TYPE;
 
TYPE ap239_props_date_and_time_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship, representation);
END_TYPE;
 
TYPE ap239_props_date_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship, representation);
END_TYPE;
 
TYPE ap239_props_identification_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship);
END_TYPE;
 
TYPE ap239_props_multi_language_attribute_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship, representation_item);
END_TYPE;
 
TYPE ap239_props_organization_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship, representation);
END_TYPE;
 
TYPE ap239_props_person_and_organization_item = SELECT 
  (general_property, general_property_relationship, property_definition, 
  property_definition_relationship, representation);
END_TYPE;
 
TYPE approval_item = SELECT 
  (slot_on_product, breakdown_element_usage, product_planned_to_realized, 
  applied_action_method_assignment, general_property_relationship, 
  action_method, slot_design_to_realized, action_resource, 
  applied_organizational_project_assignment, 
  applied_event_occurrence_assignment, property_definition, 
  assembly_component_usage, event_occurrence, slot_as_realized, 
  applied_state_assignment, applied_document_reference, 
  action_method_relationship, organizational_project, 
  interface_connector_planned_to_realized, product_definition_group_assignment
  , interface_connector_design, applied_state_type_assignment, product, group, 
  certification, interface_connector_design_to_realized, product_as_realized, 
  product_definition, structured_message, applied_location_assignment, 
  interface_connection, in_zone, applied_action_assignment, 
  interface_connector_as_planned, alternate_product_relationship, envelope, 
  property_definition_relationship, applied_identification_assignment, 
  product_design_to_individual, product_in_slot, slot_planned_to_realized, 
  contract, slot_as_planned, product_definition_formation, 
  action_resource_requirement, slot_design_to_planned, product_as_planned, 
  slot_design, applied_document_usage_constraint_assignment, 
  selected_item_assignment, general_property, action, 
  breakdown_element_group_assignment, interface_connector_design_to_planned, 
  product_concept, interface_connector_as_realized, 
  action_resource_relationship, applied_contract_assignment, 
  action_resource_requirement_relationship);
END_TYPE;
 
TYPE ar_action_method_items = SELECT 
  (action, action_method, applied_action_assignment, 
  applied_action_method_assignment, event_occurrence);
END_TYPE;
 
TYPE ar_observed_context_item = SELECT 
  (action, action_directive, action_method, action_resource, 
  action_resource_requirement, event_occurrence, product, product_definition, 
  product_definition_formation, product_group, versioned_action_request);
END_TYPE;
 
TYPE area_measure = REAL;
END_TYPE;
 
TYPE attribute_classification_item = SELECT 
  (date_role, person_and_organization_address, organization_relationship, 
  breakdown_context, person_and_organization_role, representation_context, 
  breakdown_element_usage, event_occurrence_context_role, usage_association, 
  product_category, product_definition_relationship, product_definition_context
  , breakdown_element_group_assignment, representation, object_role, 
  property_definition, envelope_relationship, general_property_relationship, 
  product_definition_formation_relationship, identification_role, approval, 
  product_definition, representation_item, product_definition_group_assignment
  , structured_message, information_right, envelope, name_attribute, 
  property_definition_representation, descriptive_representation_item, group, 
  product_concept_context, document_relationship, message_relationship, 
  product_concept, approval_relationship, alternate_product_relationship, 
  approval_status, document_type, contract_type, 
  organizational_project_relationship, organization_role, certification, 
  measure_representation_item, organizational_project_role, 
  application_context_element, document_usage_role, 
  event_occurrence_relationship, information_usage_right, general_property, 
  security_classification_level, date_time_role, application_context, 
  property_definition_relationship, approval_role, certification_type, 
  organizational_address);
END_TYPE;
 
TYPE attribute_language_item = SELECT 
  (multi_language_attribute_assignment, approval_status, 
  general_property_relationship, envelope, product_definition_formation, 
  message_relationship, event_occurrence, representation_item, 
  information_right, product, organization_relationship, structured_message, 
  action_method, contract, general_property, organizational_project_role, 
  property_definition, identification_role, certification_type, 
  person_and_organization, property_definition_relationship, 
  envelope_relationship, action_method_relationship, information_usage_right, 
  applied_action_method_assignment, approval, product_definition, connector_on
  , organizational_project_relationship, organizational_project, 
  approval_relationship, certification, group, date_time_role, date_role);
END_TYPE;
 
TYPE attribute_select = SELECT 
  (product_group_context, product_group_purpose);
END_TYPE;
 
TYPE attribute_type = SELECT 
  (label, text);
END_TYPE;
 
TYPE axis2_placement = SELECT 
  (axis2_placement_2d, axis2_placement_3d);
END_TYPE;
 
TYPE b_spline_curve_form = ENUMERATION OF 
  (polyline_form, circular_arc, elliptic_arc, parabolic_arc, hyperbolic_arc, 
  unspecified);
END_TYPE;
 
TYPE b_spline_surface_form = ENUMERATION OF 
  (plane_surf, cylindrical_surf, conical_surf, spherical_surf, toroidal_surf, 
  surf_of_revolution, ruled_surf, generalised_cone, quadric_surf, 
  surf_of_linear_extrusion, unspecified);
END_TYPE;
 
TYPE boolean_operand = SELECT 
  (solid_model, half_space_solid, csg_primitive, boolean_result, half_space_2d)
  ;
END_TYPE;
 
TYPE boolean_operator = ENUMERATION OF 
  (union, intersection, difference);
END_TYPE;
 
TYPE celsius_temperature_measure = REAL;
END_TYPE;
 
TYPE certification_item = SELECT 
  (product_as_realized, product, action_resource, action, product_as_planned, 
  product_definition_formation_relationship, 
  applied_qualification_type_assignment, organizational_project, action_method
  , product_definition_formation, interface_connection);
END_TYPE;
 
TYPE characterized_action_definition = SELECT 
  (action, action_method, action_method_relationship, action_relationship);
END_TYPE;
 
TYPE characterized_definition = SELECT 
  (characterized_object, characterized_product_definition, shape_definition);
END_TYPE;
 
TYPE characterized_material_property = SELECT 
  (material_property_representation, product_material_composition_relationship)
  ;
END_TYPE;
 
TYPE characterized_product_definition = SELECT 
  (product_definition, product_definition_relationship);
END_TYPE;
 
TYPE characterized_resource_definition = SELECT 
  (action_resource, action_resource_relationship, action_resource_requirement, 
  action_resource_requirement_relationship);
END_TYPE;
 
TYPE classification_item = SELECT 
  (action_method_relationship, approval_status, organization_relationship, 
  slot_planned_to_realized, applied_document_reference, 
  event_occurrence_relationship, interface_connector_as_planned, 
  multi_language_attribute_assignment, product_concept, 
  observation_relationship, observation, information_usage_right, 
  person_and_organization_address, event_occurrence, action_method, 
  measure_representation_item, breakdown_element_group_assignment, 
  product_definition_formation, product_definition_formation_relationship, 
  structured_message, applied_approval_assignment, product, 
  document_relationship, action, state_observed_relationship, 
  representation_item, representation_context, contract, 
  general_property_relationship, representation, message_relationship, 
  applied_action_assignment, security_classification, 
  applied_action_method_assignment, applied_organizational_project_assignment, 
  group, breakdown_context, position_in_organization_relationship, 
  assembly_component_usage_substitute, address, slot_design_to_planned, 
  product_design_to_individual, applied_usage_right, 
  action_resource_requirement_relationship, product_definition_relationship, 
  applied_contract_assignment, interface_connection, 
  action_resource_relationship, state_type, approval_person_organization, 
  property_definition, usage_association, property_definition_representation, 
  requirement_assignment, action_resource, product_definition_context, 
  product_as_realized, document_file, interface_connector_planned_to_realized, 
  applied_event_occurrence_assignment, organization, location_relationship, 
  product_definition_group_assignment, 
  applied_external_identification_assignment, applied_date_and_time_assignment
  , action_resource_requirement, organizational_project_relationship, 
  applied_security_classification_assignment, 
  interface_connector_design_to_realized, product_group_relationship, 
  interface_definition_for, product_as_planned, product_definition, 
  product_category, applied_state_assignment, applied_organization_assignment, 
  product_group, state_type_relationship, organizational_project, language, 
  applied_location_assignment, envelope, information_right, requirement_source
  , general_property, action_method_assignment, approval, 
  interface_connector_as_realized, applied_person_and_organization_assignment, 
  alternate_product_relationship, certification, experience_type, 
  breakdown_element_usage, person_type_definition_relationship, 
  applied_identification_assignment, approval_relationship, 
  selected_item_assignment, selected_item, applied_state_type_assignment, 
  envelope_relationship, applied_certification_assignment, state_observed, 
  organizational_address, date_and_time, slot_design_to_realized, 
  descriptive_representation_item, applied_document_usage_constraint_assignment
  , property_definition_relationship, action_relationship, 
  product_planned_to_realized, qualification_type, applied_date_assignment, 
  person_and_organization, interface_connector_design_to_planned, 
  interface_connector_design, calendar_date);
END_TYPE;
 

(* NOT USED
TYPE classified_select = SELECT 
  ();
END_TYPE;
*)
 
TYPE compound_item_definition = SELECT 
  (list_representation_item, set_representation_item);
END_TYPE;
 
TYPE condition_action_method_items = SELECT 
  (action_method_relationship, action_resource_relationship, 
  product_related_product_category, product_as_individual, group, 
  applied_identification_assignment, date_and_time, 
  applied_organization_assignment, applied_classification_assignment, 
  applied_date_assignment, applied_person_and_organization_assignment, 
  action_relationship, action_resource_requirement_relationship, 
  applied_approval_assignment, applied_action_method_assignment, 
  applied_date_and_time_assignment, product, 
  applied_document_usage_constraint_assignment, action_resource, 
  property_definition, action_resource_requirement, 
  product_definition_formation, action_method, applied_certification_assignment
  , action, applied_contract_assignment, product_definition, calendar_date, 
  applied_document_reference);
END_TYPE;
 
TYPE condition_approval_item = SELECT 
  (action_method, applied_action_method_assignment);
END_TYPE;
 
TYPE condition_classification_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment)
  ;
END_TYPE;
 
TYPE condition_date_and_time_item = SELECT 
  (action_method, applied_action_method_assignment);
END_TYPE;
 
TYPE condition_date_item = SELECT 
  (action_method, applied_action_method_assignment);
END_TYPE;
 
TYPE condition_evaluation_action_items = SELECT 
  (product_definition, applied_identification_assignment, 
  applied_person_and_organization_assignment, applied_date_and_time_assignment
  , product, calendar_date, property_definition, 
  applied_classification_assignment, applied_organization_assignment, 
  product_as_individual, applied_document_usage_constraint_assignment, 
  date_and_time, product_definition_formation, applied_document_reference, 
  applied_contract_assignment, applied_approval_assignment, 
  applied_certification_assignment, applied_date_assignment, 
  product_related_product_category);
END_TYPE;
 
TYPE condition_evaluation_approval_item = SELECT 
  (action, applied_action_assignment);
END_TYPE;
 
TYPE condition_evaluation_classification_item = SELECT 
  (action, applied_action_assignment, group);
END_TYPE;
 
TYPE condition_evaluation_date_and_time_item = SELECT 
  (action, applied_action_assignment);
END_TYPE;
 
TYPE condition_evaluation_date_item = SELECT 
  (action, applied_action_assignment);
END_TYPE;
 
TYPE condition_evaluation_groupable_item = SELECT 
  (applied_action_assignment, applied_action_method_assignment);
END_TYPE;
 
TYPE condition_evaluation_identification_item = SELECT 
  (action);
END_TYPE;
 
TYPE condition_evaluation_name_item = SELECT 
  (applied_action_assignment);
END_TYPE;
 
TYPE condition_evaluation_organization_item = SELECT 
  (action, applied_action_assignment);
END_TYPE;
 
TYPE condition_evaluation_person_and_organization_item = SELECT 
  (action, applied_action_assignment);
END_TYPE;
 
TYPE condition_identification_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE condition_name_item = SELECT 
  (applied_action_method_assignment);
END_TYPE;
 
TYPE condition_organization_item = SELECT 
  (action_method, applied_action_method_assignment);
END_TYPE;
 
TYPE condition_person_and_organization_item = SELECT 
  (action_method, applied_action_method_assignment);
END_TYPE;
 
TYPE configuration_design_item = SELECT 
  (product_definition, product_definition_formation);
END_TYPE;
 
TYPE contents_item = SELECT 
  (representation);
END_TYPE;
 
TYPE context_dependent_measure = REAL;
END_TYPE;
 
TYPE contract_item = SELECT 
  (product_definition, action_method_relationship, product, 
  interface_connector_design, interface_connector_as_realized, action_resource
  , structured_message, requirement_assignment, product_definition_formation, 
  information_usage_right, action_method, product_as_planned, 
  interface_connector_as_planned, applied_action_method_assignment, group, 
  product_as_realized, requirement_source, action, organizational_project, 
  product_definition_relationship, product_definition_formation_relationship);
END_TYPE;
 
TYPE count_measure = NUMBER;
END_TYPE;
 
TYPE csg_primitive = SELECT 
  (sphere, ellipsoid, block, right_angular_wedge, faceted_primitive, 
  rectangular_pyramid, torus, right_circular_cone, eccentric_cone, 
  right_circular_cylinder, cyclide_segment_solid, primitive_2d);
END_TYPE;
 
TYPE csg_select = SELECT 
  (boolean_result, csg_primitive);
END_TYPE;
 
TYPE curve_on_surface = SELECT 
  (pcurve, surface_curve, composite_curve_on_surface);
END_TYPE;
 
TYPE date_and_time_item = SELECT 
  (product_concept, applied_state_assignment, general_property, 
  applied_security_classification_assignment, 
  applied_document_usage_constraint_assignment, selected_item, 
  action_method_relationship, action_resource, action_resource_requirement, 
  security_classification, applied_organizational_project_assignment, 
  assembly_component_usage, applied_usage_right, 
  applied_action_method_assignment, envelope, product_definition_formation, 
  applied_organization_assignment, applied_state_type_assignment, action_method
  , breakdown_element_usage, product_definition, product_as_planned, 
  interface_connector_as_realized, product_definition_group_assignment, product
  , event_occurrence, group, property_definition_relationship, 
  breakdown_element_group_assignment, applied_contract_assignment, 
  assembly_component_usage_substitute, slot_design_to_planned, 
  interface_connector_as_planned, product_as_realized, 
  product_design_to_individual, experience, 
  interface_connector_planned_to_realized, applied_document_reference, contract
  , interface_connector_design_to_planned, person_and_organization_address, 
  action, slot_planned_to_realized, applied_action_assignment, 
  organizational_address, property_definition, applied_location_assignment, 
  selected_item_assignment, applied_person_and_organization_assignment, 
  approval_person_organization, representation, applied_experience_assignment, 
  applied_certification_assignment, product_planned_to_realized, 
  alternate_product_relationship, applied_identification_assignment, 
  certification, structured_message, organizational_project, 
  slot_design_to_realized, interface_connector_design_to_realized, 
  general_property_relationship, applied_qualification_type_assignment);
END_TYPE;
 
TYPE date_and_time_item_approval = SELECT 
  (approval_person_organization);
END_TYPE;
 
TYPE date_item = SELECT 
  (action_method, applied_action_method_assignment, action_resource_requirement
  , slot_planned_to_realized, selected_item, product_planned_to_realized, 
  approval_person_organization, applied_state_assignment, 
  applied_document_usage_constraint_assignment, product_design_to_individual, 
  product_definition_formation, action, event_occurrence, 
  applied_security_classification_assignment, product, 
  alternate_product_relationship, applied_organization_assignment, 
  interface_connector_design_to_realized, applied_document_reference, 
  property_definition_relationship, applied_certification_assignment, 
  breakdown_element_usage, applied_qualification_type_assignment, 
  organizational_project, product_definition_group_assignment, 
  product_definition, applied_location_assignment, applied_action_assignment, 
  applied_contract_assignment, assembly_component_usage, action_resource, 
  structured_message, assembly_component_usage_substitute, 
  applied_organizational_project_assignment, applied_state_type_assignment, 
  selected_item_assignment, product_as_realized, group, 
  interface_connector_planned_to_realized, property_definition, 
  interface_connector_design_to_planned, experience, security_classification, 
  slot_design_to_realized, person_and_organization_address, applied_usage_right
  , action_method_relationship, envelope, slot_design_to_planned, 
  applied_person_and_organization_assignment, product_as_planned, 
  general_property_relationship, organizational_address, general_property, 
  certification, interface_connector_as_realized, 
  breakdown_element_group_assignment, contract, representation, 
  applied_identification_assignment, applied_experience_assignment, 
  interface_connector_as_planned, product_concept);
END_TYPE;
 
TYPE date_item_approval = SELECT 
  (approval_person_organization);
END_TYPE;
 
TYPE date_time_or_event_occurrence = SELECT 
  (date_time_select, event_occurrence);
END_TYPE;
 
TYPE date_time_select = SELECT 
  (date, local_time, date_and_time);
END_TYPE;
 
TYPE day_in_month_number = INTEGER;
WHERE
  wr1 : {1 <= SELF <= 31};
END_TYPE;
 
TYPE day_in_week_number = INTEGER;
WHERE
  wr1 : {1 <= SELF <= 7};
END_TYPE;
 
TYPE day_in_year_number = INTEGER;
WHERE
  wr1 : {1 <= SELF <= 366};
END_TYPE;
 
TYPE derived_property_select = SELECT 
  (property_definition, action_property, resource_property);
END_TYPE;
 
TYPE description_attribute_select = SELECT 
  (action_request_solution, application_context, approval_role, 
  configuration_design, date_role, date_time_role, 
  context_dependent_shape_representation, effectivity, external_source, 
  organization_role, person_and_organization_role, person_and_organization, 
  person_role, property_definition_representation, representation, time_role);
END_TYPE;
 
TYPE descriptive_measure = STRING;
END_TYPE;
 
TYPE dimension_count = INTEGER;
WHERE
  wr1 : SELF > 0;
END_TYPE;
 
TYPE dm_aliasable_item = SELECT 
  (document_file, product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE dm_approval_item = SELECT 
  (contract, certification, product_definition, product_definition_formation, 
  product_definition_relationship);
END_TYPE;
 
TYPE dm_attribute_language_item = SELECT 
  (organizational_project_role, date_time_role, date_role, contract, 
  organization_relationship, certification_type, certification, 
  organizational_project_relationship, approval, person_and_organization, 
  approval_status, organizational_project, identification_role, 
  multi_language_attribute_assignment, approval_relationship, 
  applied_document_reference, applied_document_usage_constraint_assignment, 
  applied_external_identification_assignment, document_relationship, 
  document_usage_role, external_source, object_role, product, product_category
  , product_definition, product_definition_formation, 
  product_definition_relationship);
END_TYPE;
 
TYPE dm_contract_item = SELECT 
  (product_definition_formation);
END_TYPE;
 
TYPE dm_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, document_file, product_definition
  , product_definition_formation, product_definition_relationship);
END_TYPE;
 
TYPE dm_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, document_file, product_definition, 
  product_definition_formation, product_definition_relationship);
END_TYPE;
 
TYPE dm_identification_item = SELECT 
  (security_classification_level, organization, contract, document_file, 
  product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE dm_multi_language_attribute_item = SELECT 
  (organizational_project_role, certification, contract, 
  person_and_organization, date_time_role, date_role, identification_role, 
  approval, approval_status, approval_relationship, organization_relationship, 
  organizational_project_relationship, organizational_project, 
  certification_type, applied_document_reference, 
  applied_document_usage_constraint_assignment, 
  applied_external_identification_assignment, document_relationship, 
  document_usage_role, external_source, object_role, product, product_category
  , product_definition, product_definition_formation, 
  product_definition_relationship);
END_TYPE;
 
TYPE dm_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, document_file, product, 
  product_definition, product_definition_formation);
END_TYPE;
 
TYPE dm_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, document_file, product, product_definition
  , product_definition_formation);
END_TYPE;
 
TYPE dm_security_classification_item = SELECT 
  (document_file, product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE document_location_select = SELECT 
  (product_definition);
END_TYPE;
 
TYPE document_reference_item = SELECT 
  (applied_state_type_assignment, product, interface_connector_design, 
  action_method_relationship, product_definition_formation, 
  information_usage_right, slot_planned_to_realized, 
  applied_action_method_assignment, interface_connector_design_to_planned, 
  product_concept, assembly_component_usage, action_resource_relationship, 
  certification, action_resource_requirement, 
  action_resource_requirement_relationship, information_right, 
  product_planned_to_realized, breakdown_element_usage, person, 
  applied_state_assignment, product_definition, contract, 
  product_definition_group_assignment, assembly_component_usage_substitute, 
  organizational_project, location, interface_connector_design_to_realized, 
  product_design_to_individual, breakdown_element_group_assignment, 
  action_method, interface_connector_as_realized, action, 
  interface_connector_planned_to_realized, applied_identification_assignment, 
  action_resource, interface_connector_as_planned, slot_design_to_planned, 
  alternate_product_relationship, product_definition_formation_relationship, 
  group, slot_design_to_realized, organization, product_as_realized, 
  selected_item, product_as_planned);
END_TYPE;
 
TYPE effectivity_item = SELECT 
  (applied_security_classification_assignment, slot_as_planned, 
  organizational_address, applied_document_reference, applied_usage_right, 
  slot_design_to_planned, assembly_component_usage, action_resource_requirement
  , breakdown_element_group_assignment, applied_identification_assignment, 
  requirement_source, applied_location_assignment, action_resource_relationship
  , slot_design_to_realized, product_as_individual, product_definition, 
  slot_as_realized, product_in_slot, 
  applied_document_usage_constraint_assignment, product_group_membership, 
  product_definition_relationship, property_definition, breakdown_element_usage
  , interface_connection, document_type, product_group_relationship, product, 
  slot_planned_to_realized, applied_organizational_project_assignment, 
  alternate_product_relationship, action_resource, 
  interface_connector_planned_to_realized, 
  interface_connector_design_to_planned, product_definition_formation, 
  product_design_to_individual, applied_external_identification_assignment, 
  requirement_assignment, applied_contract_assignment, 
  product_planned_to_realized, action_method, person_and_organization_address, 
  interface_connector_design_to_realized, make_from_usage_option, 
  product_definition_group_assignment, 
  product_definition_formation_relationship, slot_on_product, 
  applied_certification_assignment, document_relationship, 
  assembly_component_usage_substitute, action_resource_requirement_relationship
  , selected_item_assignment, slot_design);
END_TYPE;
 
TYPE electric_current_measure = REAL;
END_TYPE;
 
TYPE envelope_approval = SELECT 
  (envelope);
END_TYPE;
 
TYPE envelope_date = SELECT 
  (envelope);
END_TYPE;
 
TYPE envelope_date_and_time = SELECT 
  (envelope);
END_TYPE;
 
TYPE envelope_organization_item = SELECT 
  (envelope);
END_TYPE;
 
TYPE envelope_person_organization_item = SELECT 
  (envelope);
END_TYPE;
 
TYPE event_occurrence_date_and_time_item = SELECT 
  (event_occurrence);
END_TYPE;
 
TYPE event_occurrence_date_item = SELECT 
  (event_occurrence);
END_TYPE;
 
TYPE event_occurrence_item = SELECT 
  (organizational_project, certification);
END_TYPE;
 
TYPE experience_date_and_time_item = SELECT 
  (applied_experience_assignment, experience);
END_TYPE;
 
TYPE experience_date_item = SELECT 
  (applied_experience_assignment, experience);
END_TYPE;
 
TYPE experience_item = SELECT 
  (action_method, action_resource_requirement);
END_TYPE;
 
TYPE experience_type_classification_item = SELECT 
  (experience_type);
END_TYPE;
 
TYPE experience_type_item = SELECT 
  (experience, person);
END_TYPE;
 
TYPE extent_enumeration = ENUMERATION OF 
  (invalid, zero, finite_non_zero, infinite);
END_TYPE;
 
TYPE external_class_name_item = SELECT 
  (external_class_library);
END_TYPE;
 
TYPE external_identification_item = SELECT 
  (product_definition, document_file);
END_TYPE;
 
TYPE file_identification_item = SELECT 
  (document_file);
END_TYPE;
 
TYPE file_location_select = SELECT 
  (document_file);
END_TYPE;
 
TYPE file_version_item = SELECT 
  (document_file);
END_TYPE;
 
TYPE founded_item_select = SELECT 
  (founded_item, representation_item);
END_TYPE;
 
TYPE geometric_set_select = SELECT 
  (point, curve, surface);
END_TYPE;
 
TYPE groupable_item = SELECT 
  (action_method_relationship, applied_action_method_assignment, representation
  , applied_action_assignment, action_method);
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP' IN TYPEOF(SELF));
END_TYPE;
 
TYPE hour_in_day = INTEGER;
WHERE
  wr1 : {0 <= SELF <= 24};
END_TYPE;
 
TYPE id_attribute_select = SELECT 
  (action, address, product_category, property_definition, shape_aspect, 
  shape_aspect_relationship, application_context, group, organizational_project
  , representation);
END_TYPE;
 
TYPE identification_item = SELECT 
  (approval_status, general_property_relationship, shape_representation, 
  security_classification_level, action_method, applied_state_type_assignment, 
  applied_action_method_assignment, document_file, product_as_planned, 
  applied_state_assignment, action_resource_requirement_relationship, 
  action_method_relationship, product_definition_formation, product, 
  action_resource_requirement, property_definition, organization, 
  product_as_realized, property_definition_relationship, action_resource, 
  state_type, action, product_definition, general_property, certification, 
  interface_connector_as_realized, state_type_relationship, contract, 
  product_as_individual, group, interface_connector_as_planned, 
  security_classification, organizational_project, interface_connector_design, 
  event_occurrence);
END_TYPE;
 
TYPE identifier = STRING;
END_TYPE;
 
TYPE ir_approval_item = SELECT 
  (contract, certification, applied_usage_right, information_usage_right);
END_TYPE;
 
TYPE ir_contract_item = SELECT 
  (information_usage_right);
END_TYPE;
 
TYPE ir_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, information_usage_right);
END_TYPE;
 
TYPE ir_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, information_usage_right);
END_TYPE;
 
TYPE ir_identification_item = SELECT 
  (security_classification_level, organization, contract, information_right, 
  information_usage_right);
END_TYPE;
 
TYPE ir_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, information_usage_right);
END_TYPE;
 
TYPE ir_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, information_usage_right);
END_TYPE;
 
TYPE ir_usage_item = SELECT 
  (slot_design_to_planned, product_definition, requirement_assignment, 
  assembly_component_usage_substitute, product_as_planned, product_as_realized
  , security_classification, document_relationship, 
  product_definition_relationship, certification, product, structured_message, 
  document_file, product_definition_group_assignment, 
  product_definition_formation, product_definition_formation_relationship, 
  breakdown_element_group_assignment, alternate_product_relationship, 
  slot_design_to_realized, interface_connector_as_planned, 
  applied_security_classification_assignment, assembly_component_usage, 
  slot_on_product, breakdown_element_usage, interface_connection, 
  interface_connector_as_realized, interface_connector_design, 
  applied_certification_assignment);
END_TYPE;
 
TYPE justification_item = SELECT 
  (applied_location_assignment, action_resource, action_resource_requirement, 
  action_method, applied_state_assignment, action_resource_relationship, 
  action_method_relationship, applied_state_type_assignment, 
  applied_action_method_assignment, action, 
  action_resource_requirement_relationship, group);
END_TYPE;
 
TYPE justification_support_item = SELECT 
  (action_method, action, product_definition, applied_action_method_assignment
  , state_type_relationship, location, action_directive, event_occurrence, 
  product_definition_formation, applied_location_assignment, contract, 
  state_type, versioned_action_request, action_method_relationship, product, 
  organizational_project, applied_state_assignment, state_observed_relationship
  , state_observed, applied_state_type_assignment);
END_TYPE;
 
TYPE knot_type = ENUMERATION OF 
  (uniform_knots, quasi_uniform_knots, piecewise_bezier_knots, unspecified);
END_TYPE;
 
TYPE label = STRING;
END_TYPE;
 
TYPE length_measure = REAL;
END_TYPE;
 
TYPE list_of_reversible_topology_item =  LIST OF reversible_topology_item;
END_TYPE;
 
TYPE list_of_two_representation_items = list_representation_item;
WHERE
  wr1 : HIINDEX(SELF) = 2;
END_TYPE;
 
TYPE list_representation_item =  LIST [1:?] OF representation_item;
END_TYPE;
 
TYPE location_assignment_approval_item = SELECT 
  (applied_location_assignment);
END_TYPE;
 
TYPE location_assignment_classification_item = SELECT 
  (applied_location_assignment);
END_TYPE;
 
TYPE location_assignment_date_and_time_item = SELECT 
  (applied_location_assignment);
END_TYPE;
 
TYPE location_assignment_date_item = SELECT 
  (applied_location_assignment);
END_TYPE;
 
TYPE location_assignment_effectivity_item = SELECT 
  (applied_location_assignment);
END_TYPE;
 
TYPE location_assignment_organization_item = SELECT 
  (applied_location_assignment);
END_TYPE;
 
TYPE location_assignment_person_and_organization_item = SELECT 
  (applied_location_assignment);
END_TYPE;
 
TYPE location_classification_item = SELECT 
  (location_relationship);
END_TYPE;
 
TYPE location_item = SELECT 
  (product, organizational_project, position_in_organization, 
  product_definition, person_type_definition, product_definition_formation, 
  document_file, person, organization_type, organization, 
  applied_action_method_assignment, person_type, action_resource, 
  person_and_organization, position_in_organization_type, product_group, 
  action_method, action_resource_requirement);
END_TYPE;
 
TYPE location_representation_item = SELECT 
  (organizational_address, person_and_organization_address, product);
END_TYPE;
 
TYPE luminous_intensity_measure = REAL;
END_TYPE;
 
TYPE mass_measure = REAL;
END_TYPE;
 
TYPE measure_value = SELECT 
  (length_measure, mass_measure, time_measure, electric_current_measure, 
  thermodynamic_temperature_measure, celsius_temperature_measure, 
  amount_of_substance_measure, luminous_intensity_measure, plane_angle_measure
  , solid_angle_measure, area_measure, volume_measure, ratio_measure, 
  parameter_value, numeric_measure, context_dependent_measure, 
  descriptive_measure, positive_length_measure, positive_plane_angle_measure, 
  positive_ratio_measure, count_measure);
END_TYPE;
 
TYPE message = STRING;
END_TYPE;
 
TYPE message_approval = SELECT 
  (structured_message);
END_TYPE;
 
TYPE message_date = SELECT 
  (structured_message);
END_TYPE;
 
TYPE message_date_time = SELECT 
  (structured_message);
END_TYPE;
 
TYPE message_having_contents = SELECT 
  (structured_message);
END_TYPE;
 
TYPE message_organization = SELECT 
  (structured_message);
END_TYPE;
 
TYPE message_person_and_organization = SELECT 
  (structured_message);
END_TYPE;
 
TYPE message_security_classification = SELECT 
  (structured_message);
END_TYPE;
 
TYPE message_state = SELECT 
  (structured_message);
END_TYPE;
 
TYPE minute_in_hour = INTEGER;
WHERE
  wr1 : {0 <= SELF <= 59};
END_TYPE;
 
TYPE month_in_year_number = INTEGER;
WHERE
  wr1 : {1 <= SELF <= 12};
END_TYPE;
 
TYPE mri_approval_item = SELECT 
  (certification, contract, product_definition, action_method, 
  versioned_action_request, executed_action, action_request_solution, 
  action_directive, directed_action, requirement_source, 
  product_definition_relationship, applied_usage_right, 
  product_definition_formation, requirement_assignment, 
  product_definition_formation_relationship, product, observation, 
  information_usage_right);
END_TYPE;
 
TYPE mri_attribute_language_item = SELECT 
  (multi_language_attribute_assignment, approval, approval_relationship, 
  approval_status, certification, certification_type, contract, date_role, 
  date_time_role, identification_role, organization_relationship, 
  organizational_project, organizational_project_relationship, 
  organizational_project_role, person_and_organization, product_category, 
  document_usage_role, action_relationship, product_definition_relationship, 
  state_observed_relationship, state_type_relationship, product_definition, 
  applied_document_usage_constraint_assignment, executed_action, 
  applied_document_reference, applied_external_identification_assignment, 
  state_observed, requirement_assignment, object_role, document_relationship, 
  product_definition_formation, action_request_solution, external_source, 
  state_type, product_definition_formation_relationship, requirement_source, 
  action_directive, product, action_method);
END_TYPE;
 
TYPE mri_date_and_time_item = SELECT 
  (applied_organization_assignment, applied_person_and_organization_assignment
  , applied_security_classification_assignment, certification, contract, 
  security_classification, product_definition_formation_relationship, 
  action_relationship, product_definition_relationship, requirement_assignment
  , requirement_source, action_method, executed_action, product_definition, 
  state_type_relationship, product_definition_formation, observation, 
  state_observed, state_observed_relationship, versioned_action_request, 
  action_directive, directed_action, information_usage_right, 
  applied_state_assignment, document_file, product, ascribable_state, 
  applied_state_type_assignment, state_type, action_request_solution);
END_TYPE;
 
TYPE mri_date_item = SELECT 
  (applied_organization_assignment, applied_person_and_organization_assignment
  , applied_security_classification_assignment, certification, contract, 
  security_classification, action_directive, product_definition, 
  requirement_source, action_request_solution, state_observed_relationship, 
  applied_state_assignment, applied_state_type_assignment, observation, 
  information_usage_right, action_relationship, action_method, 
  versioned_action_request, document_file, executed_action, state_observed, 
  ascribable_state, directed_action, product_definition_formation, 
  requirement_assignment, state_type, product_definition_relationship, product
  , state_type_relationship, product_definition_formation_relationship);
END_TYPE;
 
TYPE mri_identification_item = SELECT 
  (contract, organization, security_classification_level, observation, 
  document_file, product, state_observed, action_method, 
  information_usage_right, product_definition, 
  product_definition_formation_relationship, information_right, 
  product_definition_relationship, state_observed_relationship, 
  product_definition_formation, observation_consequence, requirement_source, 
  versioned_action_request, state_type_relationship, action_directive, 
  requirement_assignment, directed_action, state_type, executed_action);
END_TYPE;
 
TYPE mri_multi_language_attribute_item = SELECT 
  (approval, approval_relationship, approval_status, certification, 
  certification_type, contract, date_role, date_time_role, identification_role
  , organization_relationship, organizational_project, 
  organizational_project_relationship, organizational_project_role, 
  person_and_organization, action_request_solution, document_usage_role, 
  product_definition_formation_relationship, applied_document_reference, 
  document_relationship, action_relationship, object_role, state_type, product
  , action_directive, state_observed, product_definition_formation, 
  requirement_source, requirement_assignment, state_observed_relationship, 
  applied_external_identification_assignment, 
  applied_document_usage_constraint_assignment, product_definition, 
  executed_action, state_type_relationship, action_method, 
  product_definition_relationship, product_category, external_source);
END_TYPE;
 
TYPE mri_organization_item = SELECT 
  (applied_identification_assignment, 
  applied_security_classification_assignment, contract, 
  product_definition_formation_relationship, information_usage_right, 
  requirement_source, state_type, product_definition_formation, 
  product_definition, action_directive, state_type_relationship, product, 
  action_method, action_relationship, state_observed, executed_action, 
  ascribable_state, directed_action, document_file, observation, 
  applied_state_assignment, applied_state_type_assignment, 
  requirement_assignment, state_observed_relationship, 
  product_definition_relationship, action_request_solution, 
  versioned_action_request);
END_TYPE;
 
TYPE mri_person_and_organization_item = SELECT 
  (applied_identification_assignment, 
  applied_security_classification_assignment, contract, state_type_relationship
  , applied_state_type_assignment, product, versioned_action_request, 
  product_definition_formation_relationship, executed_action, 
  action_request_solution, product_definition_relationship, action_method, 
  requirement_source, product_definition, directed_action, 
  product_definition_formation, requirement_assignment, action_relationship, 
  action_directive, document_file, observation, ascribable_state, 
  applied_state_assignment, state_type, state_observed, 
  state_observed_relationship, information_usage_right);
END_TYPE;
 
TYPE multi_language_attribute_item = SELECT 
  (slot_on_product, structured_message, product, 
  property_definition_relationship, event_occurrence, slot_design_to_realized, 
  contract, organizational_project_role, applied_action_method_assignment, 
  breakdown_element_group_assignment, information_right, identification_role, 
  product_definition, certification_type, organization_relationship, 
  alternate_product_relationship, property_definition, product_as_individual, 
  date_role, message_relationship, product_definition_formation, 
  person_and_organization, assembly_component_usage, breakdown_element_usage, 
  approval_status, information_usage_right, general_property, 
  action_method_relationship, assembly_component_usage_substitute, 
  approval_relationship, action_method, group, slot_planned_to_realized, 
  connector_on, envelope_relationship, slot_design_to_planned, certification, 
  product_definition_group_assignment, general_property_relationship, 
  date_time_role, envelope, representation_item, 
  organizational_project_relationship, organizational_project, approval);
END_TYPE;
 
TYPE name_attribute_select = SELECT 
  (action_request_solution, address, configuration_design, 
  context_dependent_shape_representation, derived_unit, effectivity, 
  person_and_organization, product_definition, product_definition_substitute, 
  property_definition_representation);
END_TYPE;
 
TYPE name_item = SELECT 
  (applied_action_assignment, applied_action_method_assignment, 
  external_class_library);
END_TYPE;
 
TYPE numeric_measure = NUMBER;
END_TYPE;
 
TYPE observation_approval = SELECT 
  (contract, certification, observation);
END_TYPE;
 
TYPE observation_classification = SELECT 
  (observation, observation_relationship);
END_TYPE;
 
TYPE observation_date = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, observation);
END_TYPE;
 
TYPE observation_date_and_time = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, observation);
END_TYPE;
 
TYPE observation_identification_item = SELECT 
  (security_classification_level, organization, contract, observation, 
  observation_consequence);
END_TYPE;
 
TYPE observation_item_representation = SELECT 
  (representation);
END_TYPE;
 
TYPE observation_organization = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, observation);
END_TYPE;
 
TYPE observation_person_and_organization = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, observation);
END_TYPE;
 
TYPE observation_recorder_item = SELECT 
  (product_as_realized);
END_TYPE;
 
TYPE observed_context_item = SELECT 
  (action, action_resource_requirement, event_occurrence, product_group, 
  product_definition, product_definition_formation, action_directive, product, 
  action_resource, versioned_action_request, action_method);
END_TYPE;
 
TYPE organization_item = SELECT 
  (applied_location_assignment, interface_connector_as_planned, 
  applied_organizational_project_assignment, selected_item, 
  applied_state_assignment, certification, assembly_component_usage_substitute
  , product, action_method, envelope, product_definition_group_assignment, 
  product_definition_formation, applied_identification_assignment, 
  action_method_relationship, product_definition, action_resource, 
  property_definition, applied_contract_assignment, group, 
  applied_state_type_assignment, applied_security_classification_assignment, 
  product_as_planned, applied_certification_assignment, 
  applied_document_usage_constraint_assignment, organizational_project, 
  assembly_component_usage, general_property_relationship, 
  applied_action_method_assignment, event_occurrence, selected_item_assignment
  , property_definition_relationship, structured_message, contract, 
  breakdown_element_group_assignment, action, applied_document_reference, 
  representation, product_as_realized, interface_connector_as_realized, 
  alternate_product_relationship, action_resource_requirement, 
  applied_event_occurrence_assignment, general_property, 
  breakdown_element_usage, applied_action_assignment);
END_TYPE;
 
TYPE organization_type_item = SELECT 
  (organization);
END_TYPE;
 
TYPE parameter_value = REAL;
END_TYPE;
 
TYPE pcurve_or_surface = SELECT 
  (pcurve, surface);
END_TYPE;
 
TYPE person_and_organization_item = SELECT 
  (general_property, interface_connector_as_planned, 
  applied_action_method_assignment, action_method_relationship, action_resource
  , applied_state_assignment, product_definition, product_definition_formation
  , group, assembly_component_usage_substitute, 
  applied_document_usage_constraint_assignment, action_method, product, 
  selected_item_assignment, applied_event_occurrence_assignment, 
  applied_action_assignment, action, breakdown_element_group_assignment, 
  representation, property_definition_relationship, selected_item, 
  assembly_component_usage, action_resource_requirement, product_as_planned, 
  structured_message, general_property_relationship, 
  applied_state_type_assignment, product_definition_group_assignment, 
  interface_connector_as_realized, property_definition, envelope, 
  applied_security_classification_assignment, alternate_product_relationship, 
  certification, applied_location_assignment, applied_certification_assignment
  , organizational_project, event_occurrence, 
  applied_qualification_type_assignment, applied_identification_assignment, 
  breakdown_element_usage, contract, applied_organizational_project_assignment
  , applied_document_reference, applied_contract_assignment, 
  product_as_realized);
END_TYPE;
 
TYPE person_definition_item = SELECT 
  (experience_type, qualification_type);
END_TYPE;
 
TYPE person_organization_item = SELECT 
  (person);
END_TYPE;
 
TYPE person_organization_select = SELECT 
  (person, organization, person_and_organization);
END_TYPE;
 
TYPE person_type_definition_relationship_classification_item = SELECT 
  (person_type_definition_relationship);
END_TYPE;
 
(* NOT USED
TYPE person_type_item = SELECT 
  ();
END_TYPE;
*)
 
TYPE plane_angle_measure = REAL;
END_TYPE;
 
TYPE position_in_organization_classification_item = SELECT 
  (group, position_in_organization_relationship);
END_TYPE;
 
TYPE position_in_organization_group_assignment_item = SELECT 
  (position_in_organization_assignment);
END_TYPE;
 
(* NOT USED
TYPE position_in_organization_group_item = SELECT 
  ();
END_TYPE;
*)
 
TYPE position_in_organization_item = SELECT 
  (address, organization, organizational_project, person);
END_TYPE;
 
TYPE position_in_organization_type_item = SELECT 
  (position_in_organization);
END_TYPE;
 
TYPE positive_length_measure = length_measure;
WHERE
  wr1 : SELF > 0.0;
END_TYPE;
 
TYPE positive_plane_angle_measure = plane_angle_measure;
WHERE
  wr1 : SELF > 0.0;
END_TYPE;
 
TYPE positive_ratio_measure = ratio_measure;
WHERE
  wr1 : SELF > 0.0;
END_TYPE;
 
TYPE preferred_surface_curve_representation = ENUMERATION OF 
  (curve_3d, pcurve_s1, pcurve_s2);
END_TYPE;
 
TYPE probability_distribution_item = SELECT 
  (representation);
END_TYPE;
 
TYPE process_or_process_relationship = SELECT 
  (product_definition_process, property_process, relationship_with_condition);
END_TYPE;
 
TYPE product_as_individual_identification_item = SELECT 
  (product_as_individual);
END_TYPE;
 
TYPE product_definition_or_breakdown_element_usage = SELECT 
  (breakdown_element_usage, product_definition);
END_TYPE;
 
TYPE product_definition_or_product_definition_relationship = SELECT 
  (product_definition, product_definition_relationship);
END_TYPE;
 
TYPE product_group_classification_item = SELECT 
  (product_group, product_group_relationship);
END_TYPE;
 
TYPE product_group_effectivity_item = SELECT 
  (product_group_membership, product_group_relationship);
END_TYPE;
 
TYPE product_or_formation_or_definition = SELECT 
  (product, product_definition_formation, product_definition);
END_TYPE;
 
TYPE product_select = SELECT 
  (product, product_as_individual, product_concept, 
  product_definition_formation, product_group);
END_TYPE;
 
TYPE project_as_date_and_time_item = SELECT 
  (organizational_project);
END_TYPE;
 
TYPE project_as_date_item = SELECT 
  (organizational_project);
END_TYPE;

(* NOT USED 
TYPE project_group_name_item = SELECT 
  (applied_position_in_organization_group_assignment);
END_TYPE;
*)
 
TYPE project_item = SELECT 
  (applied_action_method_assignment, action, product_concept, action_method, 
  action_method_relationship, product, group);
END_TYPE;
 
TYPE property_or_shape_select = SELECT 
  (property_definition, shape_definition);
END_TYPE;
 
TYPE qualification_type_certification_item = SELECT 
  (applied_qualification_type_assignment);
END_TYPE;
 
TYPE qualification_type_classification_item = SELECT 
  (qualification_type);
END_TYPE;
 
TYPE qualification_type_date_and_time_item = SELECT 
  (applied_qualification_type_assignment);
END_TYPE;
 
TYPE qualification_type_date_item = SELECT 
  (applied_qualification_type_assignment);
END_TYPE;
 
TYPE qualification_type_person_and_organization_item = SELECT 
  (applied_qualification_type_assignment);
END_TYPE;
 
TYPE ratio_measure = REAL;
END_TYPE;
 
TYPE relationship_with_condition = SELECT 
  (action_method_relationship, action_relationship, 
  context_dependent_action_method_relationship, 
  context_dependent_action_relationship);
END_TYPE;
 
TYPE representation_identification_item = SELECT 
  (shape_representation);
END_TYPE;
 
TYPE representation_version_item = SELECT 
  (shape_representation);
END_TYPE;
 
TYPE represented_definition = SELECT 
  (general_property, property_definition, property_definition_relationship, 
  shape_aspect, shape_aspect_relationship);
END_TYPE;
 
TYPE required_resource_approval_item = SELECT 
  (action_resource_requirement, action_resource_requirement_relationship);
END_TYPE;
 
TYPE required_resource_classification_item = SELECT 
  (action_method, action_resource_requirement, 
  action_resource_requirement_relationship);
END_TYPE;
 
TYPE required_resource_condition_action_method_items = SELECT 
  (action_method_relationship, action_resource_requirement, 
  action_resource_requirement_relationship);
END_TYPE;
 
TYPE required_resource_date_and_time_item = SELECT 
  (action_resource_requirement);
END_TYPE;
 
TYPE required_resource_date_item = SELECT 
  (action_resource_requirement);
END_TYPE;
 
TYPE required_resource_effectivity_item = SELECT 
  (action_resource_requirement, action_resource_requirement_relationship);
END_TYPE;
 
TYPE required_resource_identification_item = SELECT 
  (action_resource_requirement, action_resource_requirement_relationship);
END_TYPE;
 
TYPE required_resource_justification_item = SELECT 
  (action_resource_requirement, action_resource_requirement_relationship);
END_TYPE;
 
TYPE required_resource_organization_item = SELECT 
  (action_resource_requirement);
END_TYPE;
 
TYPE required_resource_person_and_organization_item = SELECT 
  (action_resource_requirement);
END_TYPE;
 
TYPE required_resource_requirement_assigned_item = SELECT 
  (action_resource_requirement);
END_TYPE;
 
TYPE requirement_assigned_item = SELECT 
  (product, action_resource_requirement, product_as_realized, 
  product_definition_formation, product_in_slot, 
  breakdown_element_group_assignment, product_definition_group_assignment, 
  organizational_project, product_as_planned, breakdown_element_usage, 
  alternate_product_relationship, assembly_component_usage, 
  assembly_component_usage_substitute);
END_TYPE;
 
TYPE requirement_identification_and_version_aliasable_item = SELECT 
  (product, product_definition_formation);
END_TYPE;
 
TYPE requirement_identification_and_version_mri_identification_item = SELECT 
  (security_classification_level, organization, contract, product, 
  product_definition_formation);
END_TYPE;
 
TYPE requirement_source_item = SELECT 
  (product_as_individual, product_definition_formation);
END_TYPE;
 
TYPE resource_as_realized_approval_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_as_realized_classification_item = SELECT 
  (action_method, action_resource, action_resource_relationship);
END_TYPE;
 
TYPE resource_as_realized_date_and_time_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_as_realized_date_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_as_realized_identification_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_as_realized_justification_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_item_approval_item = SELECT 
  (action_method, action_resource, action_resource_relationship);
END_TYPE;
 
TYPE resource_item_certification_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_item_classification_item = SELECT 
  (action_method, action_resource, action_resource_relationship);
END_TYPE;
 
TYPE resource_item_condition_action_method_items = SELECT 
  (action_method_relationship, action_method, action_resource, 
  action_resource_relationship);
END_TYPE;
 
TYPE resource_item_contract_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_item_date_and_time_item = SELECT 
  (action_method, action_resource);
END_TYPE;
 
TYPE resource_item_date_item = SELECT 
  (action_method, action_resource);
END_TYPE;
 
TYPE resource_item_document_reference_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_item_effectivity_item = SELECT 
  (action_method, action_resource, action_resource_relationship);
END_TYPE;
 
TYPE resource_item_identification_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_item_justification_item = SELECT 
  (action_method, action_resource, action_resource_relationship);
END_TYPE;
 
TYPE resource_item_organization_item = SELECT 
  (action_method, action_resource);
END_TYPE;
 
TYPE resource_item_person_and_organization_item = SELECT 
  (action_method, action_resource);
END_TYPE;
 
TYPE resource_item_security_classification_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_management_classification_item = SELECT 
  (action, action_relationship, action_resource, action_resource_relationship);
END_TYPE;
 
TYPE resource_management_condition_action_method_items = SELECT 
  (action_method_relationship, action, action_relationship, action_resource, 
  action_resource_relationship);
END_TYPE;
 
TYPE resource_management_contract_item = SELECT 
  (action, action_resource);
END_TYPE;
 
TYPE resource_management_date_and_time_item = SELECT 
  (action, action_resource);
END_TYPE;
 
TYPE resource_management_date_item = SELECT 
  (action, action_resource);
END_TYPE;
 
TYPE resource_management_document_reference_item = SELECT 
  (action, action_resource);
END_TYPE;
 
TYPE resource_management_effectivity_item = SELECT 
  (action_resource, action_resource_relationship);
END_TYPE;
 
TYPE resource_management_identification_item = SELECT 
  (action, action_resource);
END_TYPE;
 
TYPE resource_management_justification_item = SELECT 
  (action);
END_TYPE;
 
TYPE resource_management_location_item = SELECT 
  (action_resource);
END_TYPE;
 
TYPE resource_management_organization_item = SELECT 
  (action, action_resource);
END_TYPE;
 
TYPE resource_management_person_and_organization_item = SELECT 
  (action, action_resource);
END_TYPE;
 
TYPE reversible_topology = SELECT 
  (reversible_topology_item, list_of_reversible_topology_item, 
  set_of_reversible_topology_item);
END_TYPE;
 
TYPE reversible_topology_item = SELECT 
  (edge, path, face, face_bound, closed_shell, open_shell);
END_TYPE;
 
TYPE rm_aliasable_item = SELECT 
  (product, product_definition, product_definition_formation, 
  product_definition_formation_relationship, product_definition_relationship, 
  requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_contract_item = SELECT 
  (product, product_definition, product_definition_formation, 
  product_definition_formation_relationship, product_definition_relationship, 
  requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_approval_item = SELECT 
  (contract, certification, product, product_definition, 
  product_definition_formation, product_definition_formation_relationship, 
  product_definition_relationship, requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_attribute_language_item = SELECT 
  (organizational_project_role, date_time_role, date_role, contract, 
  organization_relationship, certification_type, certification, 
  organizational_project_relationship, approval, person_and_organization, 
  approval_status, organizational_project, identification_role, 
  multi_language_attribute_assignment, approval_relationship, product, 
  product_definition, product_definition_formation, 
  product_definition_formation_relationship, product_definition_relationship, 
  requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, product, product_definition, 
  product_definition_formation, product_definition_formation_relationship, 
  product_definition_relationship, requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, product, product_definition, 
  product_definition_formation, product_definition_formation_relationship, 
  product_definition_relationship, requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_identification_item = SELECT 
  (security_classification_level, organization, contract, product, 
  product_definition, product_definition_formation, 
  product_definition_formation_relationship, product_definition_relationship, 
  requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_multi_language_attribute_item = SELECT 
  (organizational_project_role, certification, contract, 
  person_and_organization, date_time_role, date_role, identification_role, 
  approval, approval_status, approval_relationship, organization_relationship, 
  organizational_project_relationship, organizational_project, 
  certification_type, product, product_definition, product_definition_formation
  , product_definition_formation_relationship, product_definition_relationship
  , requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, product, product_definition, 
  product_definition_formation, product_definition_formation_relationship, 
  product_definition_relationship, requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_mri_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, product, product_definition, 
  product_definition_formation, product_definition_formation_relationship, 
  product_definition_relationship, requirement_assignment, requirement_source);
END_TYPE;
 
TYPE rm_security_classification_item = SELECT 
  (product, product_definition, product_definition_formation, 
  product_definition_formation_relationship, product_definition_relationship, 
  requirement_assignment, requirement_source);
END_TYPE;
 
TYPE role_select = SELECT 
  (action_assignment, action_request_assignment, approval_assignment, 
  approval_date_time, certification_assignment, contract_assignment, 
  document_reference, effectivity_assignment, external_referent_assignment, 
  group_assignment, name_assignment, security_classification_assignment);
END_TYPE;
 
TYPE scheme_date_and_time_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE scheme_identification_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE scheme_person_and_organization_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE scheme_time_interval_item = SELECT 
  (action_method_relationship);
END_TYPE;
 
TYPE second_in_minute = REAL;
WHERE
  wr1 : {0 <= SELF <= 60.0};
END_TYPE;
 
TYPE security_classification_item = SELECT 
  (product_definition, alternate_product_relationship, 
  interface_connector_design, applied_state_type_assignment, product, 
  assembly_component_usage, action_method_relationship, 
  product_definition_formation, applied_state_assignment, product_as_planned, 
  product_definition_group_assignment, assembly_component_usage_substitute, 
  action_resource, action_method, breakdown_element_usage, group, 
  product_definition_formation_relationship, product_as_realized, 
  slot_design_to_realized, slot_planned_to_realized, requirement_assignment, 
  document_file, slot_on_product, action, requirement_source, 
  applied_action_method_assignment, 
  applied_document_usage_constraint_assignment, 
  breakdown_element_group_assignment, interface_connector_as_planned, 
  product_definition_relationship, applied_document_reference, 
  slot_design_to_planned, structured_message, interface_connector_as_realized);
END_TYPE;
 
TYPE selected_item_context_items = SELECT 
  (product_concept, organizational_project, product, contract);
END_TYPE;
 
TYPE selected_item_select = SELECT 
  (product, product_definition_formation);
END_TYPE;
 
TYPE set_of_reversible_topology_item = SET OF reversible_topology_item;
END_TYPE;
 
TYPE set_representation_item = SET [1:?] OF representation_item;
END_TYPE;
 
TYPE shape_definition = SELECT 
  (product_definition_shape, shape_aspect, shape_aspect_relationship);
END_TYPE;
 
TYPE shell = SELECT 
  (vertex_shell, wire_shell, open_shell, closed_shell);
END_TYPE;
 
TYPE si_prefix = ENUMERATION OF 
  (exa, peta, tera, giga, mega, kilo, hecto, deca, deci, centi, milli, micro, 
  nano, pico, femto, atto);
END_TYPE;
 
TYPE si_unit_name = ENUMERATION OF 
  (metre, gram, second, ampere, kelvin, mole, candela, radian, steradian, hertz
  , newton, pascal, joule, watt, coulomb, volt, farad, ohm, siemens, weber, 
  tesla, henry, degree_celsius, lumen, lux, becquerel, gray, sievert);
END_TYPE;
 
TYPE solid_angle_measure = REAL;
END_TYPE;
 
TYPE source = ENUMERATION OF 
  (made, bought, not_known);
END_TYPE;
 
TYPE source_item = SELECT 
  (identifier, message);
END_TYPE;
 
TYPE spr_document_reference_item = SELECT 
  (product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE spr_organization_item = SELECT 
  (product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE spr_person_and_organization_item = SELECT 
  (product, product_definition, product_definition_formation);
END_TYPE;
 
TYPE state_definition_classification_item = SELECT 
  (applied_state_type_assignment, state_type, state_type_relationship);
END_TYPE;
 
TYPE state_definition_identification_item = SELECT 
  (state_type, state_type_relationship);
END_TYPE;
 
TYPE state_observed_classification_item = SELECT 
  (applied_state_assignment, state_observed, state_observed_relationship);
END_TYPE;
 
TYPE state_of_item = SELECT 
  (organizational_project, interface_connector_as_planned, product_definition, 
  alternate_product_relationship, security_classification, slot_on_product, 
  structured_message, organization, slot_design_to_realized, 
  assembly_component_usage_substitute, contract, 
  interface_connector_as_realized, person_and_organization, product_as_realized
  , slot_planned_to_realized, product, product_definition_formation, 
  product_definition_group_assignment, connector_on, assembly_component_usage, 
  slot_design_to_planned, product_as_planned, product_in_slot, certification, 
  interface_connection, breakdown_element_usage, action_method, document_file, 
  applied_external_identification_assignment, interface_connector_design, 
  breakdown_element_group_assignment);
END_TYPE;
 
TYPE state_type_of_item = SELECT 
  (slot_design_to_planned, interface_connector_as_realized, 
  security_classification, interface_connector_as_planned, product_definition, 
  interface_connector_design, product_as_planned, person_and_organization, 
  product, slot_design_to_realized, product_definition_formation, 
  assembly_component_usage, breakdown_element_usage, contract, 
  assembly_component_usage_substitute, slot_planned_to_realized, 
  organizational_project, product_as_realized, product_in_slot, 
  breakdown_element_group_assignment, certification, connector_on, 
  slot_on_product, action_method, applied_external_identification_assignment, 
  alternate_product_relationship, document_file, 
  product_definition_group_assignment, organization, product_category, 
  interface_connection);
END_TYPE;
 
TYPE statechar_action_items = SELECT 
  (ascribable_state);
END_TYPE;
 
TYPE statechar_action_method_items = SELECT 
  (state_type, state_type_relationship);
END_TYPE;
 
TYPE statechar_ap239_mri_attribute_classification_item = SELECT 
  (name_attribute, event_occurrence_context_role, organization_role, 
  approval_relationship, contract_type, organization_relationship, 
  approval_status, group, person_and_organization_role, 
  organizational_project_role, date_role, certification, 
  person_and_organization_address, event_occurrence_relationship, 
  identification_role, certification_type, approval, 
  security_classification_level, organizational_address, approval_role, 
  organizational_project_relationship, date_time_role, object_role, 
  applied_state_assignment, applied_state_type_assignment, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE statechar_mri_attribute_language_item = SELECT 
  (organizational_project_role, date_time_role, date_role, contract, 
  organization_relationship, certification_type, certification, 
  organizational_project_relationship, approval, person_and_organization, 
  approval_status, organizational_project, identification_role, 
  multi_language_attribute_assignment, approval_relationship, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE statechar_mri_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, applied_state_assignment, 
  applied_state_type_assignment, ascribable_state, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE statechar_mri_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, applied_state_assignment, 
  applied_state_type_assignment, ascribable_state, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE statechar_mri_identification_item = SELECT 
  (security_classification_level, organization, contract, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE statechar_mri_multi_language_attribute_item = SELECT 
  (organizational_project_role, certification, contract, 
  person_and_organization, date_time_role, date_role, identification_role, 
  approval, approval_status, approval_relationship, organization_relationship, 
  organizational_project_relationship, organizational_project, 
  certification_type, state_observed, state_observed_relationship, state_type, 
  state_type_relationship);
END_TYPE;
 
TYPE statechar_mri_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, applied_state_assignment, 
  applied_state_type_assignment, ascribable_state, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE statechar_mri_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, applied_state_assignment, 
  applied_state_type_assignment, ascribable_state, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE supported_item = SELECT 
  (action_directive, action, action_method);
END_TYPE;
 
TYPE surface_boundary = SELECT 
  (boundary_curve, degenerate_pcurve);
END_TYPE;
 
TYPE surface_model = SELECT 
  (shell_based_surface_model, face_based_surface_model);
END_TYPE;
 
TYPE task_classification_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE task_specification_groupable_item = SELECT 
  (action_method, action_method_relationship);
END_TYPE;
 
TYPE task_state_of_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE task_state_type_of_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE text = STRING;
END_TYPE;
 
TYPE thermodynamic_temperature_measure = REAL;
END_TYPE;
 
TYPE time_interval_item = SELECT 
  (action_method_relationship);
END_TYPE;
 
TYPE time_measure = REAL;
END_TYPE;
 
TYPE transformation = SELECT 
  (item_defined_transformation, functionally_defined_transformation);
END_TYPE;
 
TYPE transition_code = ENUMERATION OF 
  (discontinuous, continuous, cont_same_gradient, 
  cont_same_gradient_same_curvature);
END_TYPE;
 
TYPE trimming_preference = ENUMERATION OF 
  (cartesian, parameter, unspecified);
END_TYPE;
 
TYPE trimming_select = SELECT 
  (cartesian_point, parameter_value);
END_TYPE;
 
TYPE tsr_action_method_items = SELECT 
  (action_method, action_resource, action_resource_requirement, 
  applied_action_method_assignment, breakdown_element_usage, document_file, 
  location, organization, organization_role, person, person_and_organization, 
  person_type, person_type_definition, position_in_organization, 
  position_in_organization_type, product, product_as_individual, 
  product_definition, product_definition_formation, 
  product_definition_relationship, product_group);
END_TYPE;
 
TYPE tsr_approval_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE tsr_attribute_language_item = SELECT 
  (multi_language_attribute_assignment, action_method, 
  action_method_relationship, applied_action_method_assignment);
END_TYPE;
 
TYPE tsr_certification_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE tsr_condition_action_method_items = SELECT 
  (action_method_relationship, action_method, action_method_relationship, 
  action_resource_relationship, action_resource_requirement_relationship, 
  applied_action_method_assignment);
END_TYPE;
 
TYPE tsr_contract_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment)
  ;
END_TYPE;
 
TYPE tsr_date_and_time_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE tsr_date_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE tsr_document_reference_item = SELECT 
  (action_method, action_method_relationship, action_resource_relationship, 
  action_resource_requirement, action_resource_requirement_relationship, 
  applied_action_method_assignment, applied_state_assignment, 
  applied_state_type_assignment, location);
END_TYPE;
 
TYPE tsr_identification_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE tsr_justification_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_location_assignment, applied_state_assignment, 
  applied_state_type_assignment);
END_TYPE;
 
TYPE tsr_justification_support_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_location_assignment, applied_state_assignment, 
  applied_state_type_assignment, contract, location, product, 
  product_definition, product_definition_formation, state_observed, 
  state_observed_relationship, state_type, state_type_relationship);
END_TYPE;
 
TYPE tsr_location_item = SELECT 
  (action_method, action_resource, action_resource_requirement, 
  applied_action_method_assignment, document_file, organization, 
  organization_type, organizational_project, person, person_and_organization, 
  person_type, person_type_definition, position_in_organization, 
  position_in_organization_type, product, product_definition, 
  product_definition_formation, product_group);
END_TYPE;
 
TYPE tsr_multi_language_attribute_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment)
  ;
END_TYPE;
 
TYPE tsr_organization_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE tsr_person_and_organization_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE tsr_project_item = SELECT 
  (action_method, applied_action_method_assignment);
END_TYPE;
 
TYPE tsr_resource_assignment_items = SELECT 
  (contract, location, organizational_project, product, product_definition, 
  product_definition_formation, product_group);
END_TYPE;
 
TYPE tsr_security_classification_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , applied_state_assignment, applied_state_type_assignment);
END_TYPE;
 
TYPE unit = SELECT 
  (named_unit, derived_unit);
END_TYPE;
 
TYPE value_qualifier = SELECT 
  (precision_qualifier, type_qualifier, uncertainty_qualifier);
END_TYPE;
 
TYPE vector_or_direction = SELECT 
  (vector, direction);
END_TYPE;
 
TYPE versionable_item = SELECT 
  (shape_representation, document_file);
END_TYPE;
 
TYPE volume_measure = REAL;
END_TYPE;
 
TYPE wd_action_items = SELECT 
  (action, action_method, action_resource, contract, document_file, 
  event_occurrence, organization, person, person_and_organization, product, 
  product_definition, product_definition_formation, 
  product_definition_relationship, product_group);
END_TYPE;
 
TYPE wd_action_method_items = SELECT 
  (action, action_method, contract, event_occurrence, organizational_project, 
  product, product_definition, product_definition_formation, product_group);
END_TYPE;
 
TYPE wd_action_request_item = SELECT 
  (action_method, action_resource, contract, document_file, organization, 
  person, person_and_organization, product, product_definition, 
  product_definition_formation, product_definition_relationship, product_group)
  ;
END_TYPE;
 
TYPE wd_approval_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , group);
END_TYPE;
 
TYPE wd_attribute_language_item = SELECT 
  (multi_language_attribute_assignment, action_method, 
  action_method_relationship, applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_certification_item = SELECT 
  (action, action_method);
END_TYPE;
 
TYPE wd_condition_action_method_items = SELECT 
  (action_method_relationship, action_method_relationship, 
  applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_contract_item = SELECT 
  (action, action_method, action_method_relationship, 
  applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_date_and_time_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , group);
END_TYPE;
 
TYPE wd_date_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , group);
END_TYPE;
 
TYPE wd_document_reference_item = SELECT 
  (action, action_method, action_method_relationship, 
  applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_identification_item = SELECT 
  (action, action_method, action_method_relationship, 
  applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_justification_item = SELECT 
  (action, action_method, action_method_relationship, 
  applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_justification_support_item = SELECT 
  (action, action_directive, action_method, applied_state_assignment, 
  applied_state_type_assignment, contract, event_occurrence, 
  organizational_project, product, product_definition, 
  product_definition_formation, state_observed, state_type, 
  versioned_action_request);
END_TYPE;
 
TYPE wd_multi_language_attribute_item = SELECT 
  (action_method, action_method_relationship, applied_action_method_assignment
  , group);
END_TYPE;
 
TYPE wd_organization_item = SELECT 
  (action_method_relationship, applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_person_and_organization_item = SELECT 
  (action_method_relationship, applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_project_item = SELECT 
  (action, action_method, action_method_relationship, 
  applied_action_method_assignment, group);
END_TYPE;
 
TYPE wd_security_classification_item = SELECT 
  (action, action_method, action_method_relationship, 
  applied_action_method_assignment, group);
END_TYPE;
 
TYPE week_in_year_number = INTEGER;
WHERE
  wr1 : {1 <= SELF <= 53};
END_TYPE;
 
TYPE wireframe_model = SELECT 
  (shell_based_wireframe_model, edge_based_wireframe_model);
END_TYPE;
 
TYPE wordchar_ap239_mri_attribute_classification_item = SELECT 
  (name_attribute, event_occurrence_context_role, organization_role, 
  approval_relationship, contract_type, organization_relationship, 
  approval_status, group, person_and_organization_role, 
  organizational_project_role, date_role, certification, 
  person_and_organization_address, event_occurrence_relationship, 
  identification_role, certification_type, approval, 
  security_classification_level, organizational_address, approval_role, 
  organizational_project_relationship, date_time_role, object_role, 
  action_directive);
END_TYPE;
 
TYPE wordchar_ap239_mri_classification_item = SELECT 
  (language, event_occurrence_relationship, organizational_project_relationship
  , applied_certification_assignment, certification, approval, 
  person_and_organization, applied_event_occurrence_assignment, 
  approval_person_organization, person_and_organization_address, 
  event_occurrence, applied_organizational_project_assignment, 
  applied_organization_assignment, organizational_address, contract, 
  approval_relationship, organization_relationship, 
  applied_identification_assignment, applied_date_and_time_assignment, 
  applied_approval_assignment, date_and_time, approval_status, 
  applied_date_assignment, organizational_project, applied_contract_assignment
  , security_classification, multi_language_attribute_assignment, 
  applied_person_and_organization_assignment, calendar_date, 
  applied_security_classification_assignment, organization, address, 
  action_directive, directed_action);
END_TYPE;
 
TYPE wordchar_mri_approval_item = SELECT 
  (contract, certification, action_directive, directed_action);
END_TYPE;
 
TYPE wordchar_mri_attribute_language_item = SELECT 
  (organizational_project_role, date_time_role, date_role, contract, 
  organization_relationship, certification_type, certification, 
  organizational_project_relationship, approval, person_and_organization, 
  approval_status, organizational_project, identification_role, 
  multi_language_attribute_assignment, approval_relationship, action_directive)
  ;
END_TYPE;
 
TYPE wordchar_mri_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, action_directive, directed_action
  );
END_TYPE;
 
TYPE wordchar_mri_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, action_directive, directed_action);
END_TYPE;
 
TYPE wordchar_mri_identification_item = SELECT 
  (security_classification_level, organization, contract, action_directive, 
  directed_action);
END_TYPE;
 
TYPE wordchar_mri_multi_language_attribute_item = SELECT 
  (organizational_project_role, certification, contract, 
  person_and_organization, date_time_role, date_role, identification_role, 
  approval, approval_status, approval_relationship, organization_relationship, 
  organizational_project_relationship, organizational_project, 
  certification_type, action_directive);
END_TYPE;
 
TYPE wordchar_mri_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, action_directive, directed_action
  );
END_TYPE;
 
TYPE wordchar_mri_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, action_directive, directed_action);
END_TYPE;
 
TYPE work_output_approval_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE work_output_certification_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE work_output_classification_item = SELECT 
  (action_method, action_method_assignment, action_method_relationship);
END_TYPE;
 
TYPE work_output_date_and_time_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE work_output_date_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE work_output_identification_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE work_output_organization_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE work_output_person_and_organization_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE work_output_security_classification_item = SELECT 
  (action_method);
END_TYPE;
 
TYPE wreqchar_ap239_mri_attribute_classification_item = SELECT 
  (name_attribute, event_occurrence_context_role, organization_role, 
  approval_relationship, contract_type, organization_relationship, 
  approval_status, group, person_and_organization_role, 
  organizational_project_role, date_role, certification, 
  person_and_organization_address, event_occurrence_relationship, 
  identification_role, certification_type, approval, 
  security_classification_level, organizational_address, approval_role, 
  organizational_project_relationship, date_time_role, object_role, 
  action_request_status, versioned_action_request);
END_TYPE;
 
TYPE wreqchar_ap239_mri_classification_item = SELECT 
  (language, event_occurrence_relationship, organizational_project_relationship
  , applied_certification_assignment, certification, approval, 
  person_and_organization, applied_event_occurrence_assignment, 
  approval_person_organization, person_and_organization_address, 
  event_occurrence, applied_organizational_project_assignment, 
  applied_organization_assignment, organizational_address, contract, 
  approval_relationship, organization_relationship, 
  applied_identification_assignment, applied_date_and_time_assignment, 
  applied_approval_assignment, date_and_time, approval_status, 
  applied_date_assignment, organizational_project, applied_contract_assignment
  , security_classification, multi_language_attribute_assignment, 
  applied_person_and_organization_assignment, calendar_date, 
  applied_security_classification_assignment, organization, address, 
  applied_action_request_assignment, versioned_action_request);
END_TYPE;
 
TYPE wreqchar_mri_approval_item = SELECT 
  (contract, certification, action_request_solution, versioned_action_request);
END_TYPE;
 
TYPE wreqchar_mri_attribute_language_item = SELECT 
  (organizational_project_role, date_time_role, date_role, contract, 
  organization_relationship, certification_type, certification, 
  organizational_project_relationship, approval, person_and_organization, 
  approval_status, organizational_project, identification_role, 
  multi_language_attribute_assignment, approval_relationship, 
  action_request_solution);
END_TYPE;
 
TYPE wreqchar_mri_date_and_time_item = SELECT 
  (security_classification, contract, certification, 
  applied_organization_assignment, applied_security_classification_assignment, 
  applied_person_and_organization_assignment, action_request_solution, 
  versioned_action_request);
END_TYPE;
 
TYPE wreqchar_mri_date_item = SELECT 
  (security_classification, applied_person_and_organization_assignment, 
  applied_organization_assignment, applied_security_classification_assignment, 
  contract, certification, action_request_solution, versioned_action_request);
END_TYPE;
 
TYPE wreqchar_mri_identification_item = SELECT 
  (security_classification_level, organization, contract, 
  versioned_action_request);
END_TYPE;
 
TYPE wreqchar_mri_multi_language_attribute_item = SELECT 
  (organizational_project_role, certification, contract, 
  person_and_organization, date_time_role, date_role, identification_role, 
  approval, approval_status, approval_relationship, organization_relationship, 
  organizational_project_relationship, organizational_project, 
  certification_type, action_request_solution);
END_TYPE;
 
TYPE wreqchar_mri_organization_item = SELECT 
  (contract, applied_identification_assignment, 
  applied_security_classification_assignment, action_request_solution, 
  versioned_action_request);
END_TYPE;
 
TYPE wreqchar_mri_person_and_organization_item = SELECT 
  (applied_security_classification_assignment, contract, 
  applied_identification_assignment, action_request_solution, 
  versioned_action_request);
END_TYPE;
 
TYPE year_number = INTEGER;
END_TYPE;
 
ENTITY action;
  name : label;
  description : OPTIONAL text;
  chosen_method : action_method;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY action_actual
SUBTYPE OF (action);
END_ENTITY;
 
ENTITY action_assignment ABSTRACT SUPERTYPE;
  assigned_action : action;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY action_directive;
  name : label;
  description : OPTIONAL text;
  analysis : text;
  comment : text;
  requests : SET [1:?] OF versioned_action_request;
END_ENTITY;
 
ENTITY action_happening
SUBTYPE OF (action_relationship);
END_ENTITY;
 
ENTITY action_method
SUPERTYPE OF (ONEOF (task, task_method, task_result));
  name : label;
  description : OPTIONAL text;
  consequence : text;
  purpose : text;
END_ENTITY;
 
ENTITY action_method_assignment ABSTRACT SUPERTYPE;
  assigned_action_method : action_method;
  role : action_method_role;
END_ENTITY;
 
ENTITY action_method_relationship;
  name : label;
  description : OPTIONAL text;
  relating_method : action_method;
  related_method : action_method;
END_ENTITY;
 
ENTITY action_method_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY action_method_to_select_from
SUBTYPE OF (action_method);
  number_of_elements : count_measure;
WHERE
  wr1 : number_of_elements >= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD_RELATIONSHIP.RELATING_METHOD'
    )) >= number_of_elements;
END_ENTITY;
 
ENTITY action_method_with_associated_documents
SUBTYPE OF (action_method);
  documents : SET [1:?] OF document;
END_ENTITY;
 
ENTITY action_method_with_associated_documents_constrained
SUBTYPE OF (action_method_with_associated_documents);
  usage_constraints : SET [1:?] OF document_usage_constraint;
WHERE
  wr1 : SIZEOF(QUERY(item <* usage_constraints | NOT (item.source IN SELF\
    action_method_with_associated_documents.documents))) = 0;
END_ENTITY;
 
ENTITY action_property;
  name : label;
  description : text;
  definition : characterized_action_definition;
END_ENTITY;
 
ENTITY action_property_relationship;
  name : label;
  description : text;
  relating_action_property : action_property;
  related_action_property : action_property;
WHERE
  wr1 : relating_action_property :<>: related_action_property;
END_ENTITY;
 
ENTITY action_property_representation;
  name : label;
  description : text;
  property : action_property;
  representation : representation;
END_ENTITY;
 
ENTITY action_relationship;
  name : label;
  description : OPTIONAL text;
  relating_action : action;
  related_action : action;
END_ENTITY;
 
ENTITY action_request_assignment ABSTRACT SUPERTYPE;
  assigned_action_request : versioned_action_request;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY action_request_solution;
  method : action_method;
  request : versioned_action_request;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY action_request_status;
  status : label;
  assigned_request : versioned_action_request;
END_ENTITY;
 
ENTITY action_resource;
  name : label;
  description : OPTIONAL text;
  usage : SET [1:?] OF supported_item;
  kind : action_resource_type;
END_ENTITY;
 
ENTITY action_resource_relationship;
  name : label;
  description : OPTIONAL text;
  relating_resource : action_resource;
  related_resource : action_resource;
END_ENTITY;
 
ENTITY action_resource_requirement;
  name : label;
  description : text;
  kind : resource_requirement_type;
  operations : SET [1:?] OF characterized_action_definition;
END_ENTITY;
 
ENTITY action_resource_requirement_relationship;
  name : label;
  description : text;
  relating_action_resource_requirement : action_resource_requirement;
  related_action_resource_requirement : action_resource_requirement;
WHERE
  wr1 : relating_action_resource_requirement :<>: 
    related_action_resource_requirement;
END_ENTITY;
 
ENTITY action_resource_type;
  name : label;
END_ENTITY;
 
ENTITY action_status;
  status : label;
  assigned_action : executed_action;
END_ENTITY;
 
ENTITY address;
  internal_location : OPTIONAL label;
  street_number : OPTIONAL label;
  street : OPTIONAL label;
  postal_box : OPTIONAL label;
  town : OPTIONAL label;
  region : OPTIONAL label;
  postal_code : OPTIONAL label;
  country : OPTIONAL label;
  facsimile_number : OPTIONAL label;
  telephone_number : OPTIONAL label;
  electronic_mail_address : OPTIONAL label;
  telex_number : OPTIONAL label;
DERIVE
  name : label := get_name_value(SELF);
  url : identifier := get_id_value(SELF);
WHERE
  wr1 : EXISTS(internal_location) OR EXISTS(street_number) OR EXISTS(street) OR
     EXISTS(postal_box) OR EXISTS(town) OR EXISTS(region) OR EXISTS(postal_code
    ) OR EXISTS(country) OR EXISTS(facsimile_number) OR EXISTS(telephone_number
    ) OR EXISTS(electronic_mail_address) OR EXISTS(telex_number);
END_ENTITY;
 
ENTITY advisory_task_method
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY alternate_product_relationship;
  name : label;
  definition : OPTIONAL text;
  alternate : product;
  base : product;
  basis : text;
UNIQUE
  ur1 : alternate, base;
WHERE
  wr1 : alternate :<>: base;
END_ENTITY;
 
ENTITY amount_of_substance_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AMOUNT_OF_SUBSTANCE_UNIT' IN 
    TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY amount_of_substance_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 1.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY application_context;
  application : label;
DERIVE
  description : text := get_description_value(SELF);
  id : identifier := get_id_value(SELF);
INVERSE
  context_elements : SET [1:?] OF application_context_element FOR 
  frame_of_reference;
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY application_context_element
SUPERTYPE OF (ONEOF (library_context, product_concept_context, product_context
, product_definition_context));
  name : label;
  frame_of_reference : application_context;
END_ENTITY;
 
ENTITY application_context_relationship;
  name : label;
  description : OPTIONAL text;
  relating_context : application_context;
  related_context : application_context;
END_ENTITY;
 
ENTITY application_protocol_definition;
  status : label;
  application_interpreted_model_schema_name : label;
  application_protocol_year : year_number;
  application : application_context;
END_ENTITY;
 
ENTITY applied_action_assignment
SUBTYPE OF (action_assignment);
  items : SET [1:?] OF action_items;
END_ENTITY;
 
ENTITY applied_action_method_assignment
SUBTYPE OF (action_method_assignment);
  items : SET [1:?] OF action_method_items;
END_ENTITY;
 
ENTITY applied_action_request_assignment
SUBTYPE OF (action_request_assignment);
  items : SET [1:?] OF action_request_item;
END_ENTITY;
 
ENTITY applied_approval_assignment
SUBTYPE OF (approval_assignment);
  items : SET [1:?] OF approval_item;
END_ENTITY;
 
ENTITY applied_attribute_classification_assignment
SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : class;
  items : SET [1:?] OF attribute_classification_item;
END_ENTITY;
 
ENTITY applied_certification_assignment
SUBTYPE OF (certification_assignment);
  items : SET [1:?] OF certification_item;
END_ENTITY;
 
ENTITY applied_classification_assignment
SUBTYPE OF (classification_assignment);
  items : SET [1:?] OF classification_item;
END_ENTITY;
 
ENTITY applied_connector_on_product_definition
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : connector_on;
  items : SET [1:1] OF product_definition;
END_ENTITY;
 
ENTITY applied_connector_on_product_definition_relationship
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : connector_on;
  items : SET [1:1] OF product_definition_relationship;
END_ENTITY;
 
ENTITY applied_contract_assignment
SUBTYPE OF (contract_assignment);
  items : SET [1:?] OF contract_item;
END_ENTITY;
 
ENTITY applied_date_and_time_assignment
SUBTYPE OF (date_and_time_assignment);
  items : SET [1:?] OF date_and_time_item;
END_ENTITY;
 
ENTITY applied_date_assignment
SUBTYPE OF (date_assignment);
  items : SET [1:?] OF date_item;
END_ENTITY;
 
ENTITY applied_document_reference
SUBTYPE OF (document_reference);
  items : SET [1:?] OF document_reference_item;
END_ENTITY;
 
ENTITY applied_document_usage_constraint_assignment
SUBTYPE OF (document_usage_constraint_assignment);
  items : SET [1:?] OF document_reference_item;
END_ENTITY;
 
ENTITY applied_effectivity_assignment
SUBTYPE OF (effectivity_assignment);
  items : SET [1:?] OF effectivity_item;
END_ENTITY;
 
ENTITY applied_event_occurrence_assignment
SUBTYPE OF (event_occurrence_assignment);
  items : SET [1:?] OF event_occurrence_item;
END_ENTITY;
 
ENTITY applied_experience_assignment
SUBTYPE OF (experience_assignment);
  items : SET [1:?] OF experience_item;
END_ENTITY;
 
ENTITY applied_experience_type_assignment
SUBTYPE OF (experience_type_assignment);
  items : SET [1:?] OF experience_type_item;
END_ENTITY;
 
ENTITY applied_external_identification_assignment
SUBTYPE OF (external_identification_assignment);
  items : SET [1:?] OF external_identification_item;
END_ENTITY;
 
ENTITY applied_group_assignment
SUBTYPE OF (group_assignment);
  items : SET [1:?] OF groupable_item;
END_ENTITY;
 
ENTITY applied_identification_assignment
SUBTYPE OF (identification_assignment);
  items : SET [1:?] OF identification_item;
END_ENTITY;
 
ENTITY applied_location_assignment
SUBTYPE OF (location_assignment);
  items : SET [1:?] OF location_item;
END_ENTITY;
 
ENTITY applied_location_representation_assignment
SUBTYPE OF (location_representation_assignment);
  items : SET [1:?] OF location_representation_item;
END_ENTITY;
 
ENTITY applied_name_assignment
SUBTYPE OF (name_assignment);
  item : name_item;
END_ENTITY;
 
ENTITY applied_organization_assignment
SUBTYPE OF (organization_assignment);
  items : SET [1:?] OF organization_item;
END_ENTITY;
 
ENTITY applied_organization_type_assignment
SUBTYPE OF (organization_type_assignment);
  items : SET [1:?] OF organization_type_item;
END_ENTITY;
 
ENTITY applied_organizational_project_assignment
SUBTYPE OF (organizational_project_assignment);
  items : SET [1:?] OF project_item;
END_ENTITY;
 
ENTITY applied_person_and_organization_assignment
SUBTYPE OF (person_and_organization_assignment);
  items : SET [1:?] OF person_and_organization_item;
END_ENTITY;
 
(* NOT USED
ENTITY applied_person_type_assignment
SUBTYPE OF (person_type_assignment);
  items : SET [1:?] OF person_type_item;
END_ENTITY;
*)
 
ENTITY applied_person_type_definition_assignment
SUBTYPE OF (person_type_definition_assignment);
  items : SET [1:?] OF person_definition_item;
END_ENTITY;
 
ENTITY applied_position_in_organization_assignment
SUBTYPE OF (position_in_organization_assignment);
  items : SET [1:?] OF position_in_organization_item;
END_ENTITY;
 
ENTITY applied_position_in_organization_assignment_group_assignment
SUBTYPE OF (group_assignment);
  items : SET [1:?] OF position_in_organization_group_assignment_item;
END_ENTITY;
 
(* NOT USED
ENTITY applied_position_in_organization_group_assignment
SUBTYPE OF (group_assignment);
  items : SET [1:?] OF position_in_organization_group_item;
END_ENTITY;
*)
 
ENTITY applied_position_in_organization_type_assignment
SUBTYPE OF (position_in_organization_type_assignment);
  items : SET [1:?] OF position_in_organization_type_item;
END_ENTITY;

(* NOT USED 
ENTITY applied_project_group_name_assignment
SUBTYPE OF (name_assignment);
  items : SET [1:?] OF project_group_name_item;
END_ENTITY;
*)
 
ENTITY applied_qualification_type_assignment
SUBTYPE OF (qualification_type_assignment);
  items : SET [1:?] OF person_organization_item;
END_ENTITY;
 
ENTITY applied_security_classification_assignment
SUBTYPE OF (security_classification_assignment);
  items : SET [1:?] OF security_classification_item;
END_ENTITY;
 
ENTITY applied_state_assignment;
  assigned_state : state_observed;
  item_set : SET [1:?] OF state_of_item;
  role : state_role;
END_ENTITY;
 
ENTITY applied_state_type_assignment;
  assigned_state_type : state_type;
  item_set : SET [1:?] OF state_type_of_item;
  role : state_type_role;
END_ENTITY;
 
ENTITY applied_time_interval_assignment
SUBTYPE OF (time_interval_assignment);
  items : SET OF time_interval_item;
END_ENTITY;
 
ENTITY applied_usage_right
SUBTYPE OF (applied_action_assignment);
  SELF\applied_action_assignment.items : SET [1:?] OF ir_usage_item;
END_ENTITY;
 
ENTITY approval;
  status : approval_status;
  level : label;
END_ENTITY;
 
ENTITY approval_assignment ABSTRACT SUPERTYPE;
  assigned_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY approval_date_time;
  date_time : date_time_select;
  dated_approval : approval;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY approval_person_organization;
  person_organization : person_organization_select;
  authorized_approval : approval;
  role : approval_role;
END_ENTITY;
 
ENTITY approval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_approval : approval;
  related_approval : approval;
END_ENTITY;
 
ENTITY approval_role;
  role : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY approval_status;
  name : label;
END_ENTITY;
 
ENTITY area_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AREA_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY area_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 2.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY ascribable_state;
  name : STRING;
  description : OPTIONAL STRING;
  pertaining_state : state_type;
  ascribed_state : state_observed;
END_ENTITY;
 
ENTITY ascribable_state_relationship;
  name : STRING;
  description : OPTIONAL STRING;
  relating_ascribable_state : ascribable_state;
  related_ascribable_state : ascribable_state;
END_ENTITY;
 
ENTITY assembly_component_usage
SUPERTYPE OF (ONEOF (next_assembly_usage_occurrence, 
specified_higher_usage_occurrence, promissory_usage_occurrence))
SUBTYPE OF (product_definition_usage);
  reference_designator : OPTIONAL identifier;
END_ENTITY;
 
ENTITY assembly_component_usage_substitute;
  name : label;
  definition : OPTIONAL text;
  base : assembly_component_usage;
  substitute : assembly_component_usage;
UNIQUE
  ur1 : base, substitute;
WHERE
  wr1 : base.relating_product_definition :=: substitute.
    relating_product_definition;
  wr2 : base :<>: substitute;
END_ENTITY;
 
ENTITY assembly_component_usage_substitute_with_ranking
SUBTYPE OF (assembly_component_usage_substitute);
  ranking : INTEGER;
  ranking_rationale : text;
END_ENTITY;
 
ENTITY assigned_requirement
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET [1:1] OF product_definition;
END_ENTITY;
 
ENTITY attribute_classification_assignment ABSTRACT SUPERTYPE;
  assigned_class : group;
  attribute_name : label;
  role : classification_role;
END_ENTITY;
 
ENTITY attribute_language_assignment
SUBTYPE OF (attribute_classification_assignment);
  SELF\attribute_classification_assignment.assigned_class : language;
  items : SET [1:?] OF attribute_language_item;
WHERE
  wr1 : SELF\attribute_classification_assignment.role.name IN ['primary', 
    'translated'];
  wr2 : SELF\attribute_classification_assignment.attribute_name <> '';
END_ENTITY;
 
ENTITY attribute_value_assignment ABSTRACT SUPERTYPE;
  attribute_name : label;
  attribute_value : attribute_type;
  role : attribute_value_role;
END_ENTITY;
 
ENTITY attribute_value_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY axis1_placement
SUBTYPE OF (placement);
  axis : OPTIONAL direction;
DERIVE
  z : direction := NVL(normalise(axis), dummy_gri||direction([0.0, 0.0, 1.0]));
WHERE
  wr1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;
 
ENTITY axis2_placement_2d
SUBTYPE OF (placement);
  ref_direction : OPTIONAL direction;
DERIVE
  p :  LIST [2:2] OF direction := build_2axes(ref_direction);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY;
 
ENTITY axis2_placement_3d
SUBTYPE OF (placement);
  axis : OPTIONAL direction;
  ref_direction : OPTIONAL direction;
DERIVE
  p :  LIST [3:3] OF direction := build_axes(axis, ref_direction);
WHERE
  wr1 : SELF\placement.location.dim = 3;
  wr2 : NOT EXISTS(axis) OR (axis.dim = 3);
  wr3 : NOT EXISTS(ref_direction) OR (ref_direction.dim = 3);
  wr4 : NOT EXISTS(axis) OR NOT EXISTS(ref_direction) OR (cross_product(axis, 
    ref_direction).magnitude > 0.0);
END_ENTITY;
 
ENTITY b_spline_curve
SUPERTYPE OF (ONEOF (uniform_curve, b_spline_curve_with_knots, 
quasi_uniform_curve, bezier_curve) ANDOR rational_b_spline_curve)
SUBTYPE OF (bounded_curve);
  degree : INTEGER;
  control_points_list :  LIST [2:?] OF cartesian_point;
  curve_form : b_spline_curve_form;
  closed_curve : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  upper_index_on_control_points : INTEGER := SIZEOF(control_points_list) - 1;
  control_points :  ARRAY [0 : upper_index_on_control_points] OF 
  cartesian_point := list_to_array(control_points_list, 0, 
  upper_index_on_control_points);
WHERE
  wr1 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNIFORM_CURVE' IN TYPEOF(SELF
    )) OR ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUASI_UNIFORM_CURVE' IN 
    TYPEOF(SELF)) OR ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BEZIER_CURVE' IN
     TYPEOF(SELF)) OR (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.B_SPLINE_CURVE_WITH_KNOTS' IN 
    TYPEOF(SELF));
END_ENTITY;
 
ENTITY b_spline_curve_with_knots
SUBTYPE OF (b_spline_curve);
  knot_multiplicities :  LIST [2:?] OF INTEGER;
  knots :  LIST [2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  upper_index_on_knots : INTEGER := SIZEOF(knots);
WHERE
  wr1 : constraints_param_b_spline(degree, upper_index_on_knots, 
    upper_index_on_control_points, knot_multiplicities, knots);
  wr2 : SIZEOF(knot_multiplicities) = upper_index_on_knots;
END_ENTITY;
 
ENTITY b_spline_surface
SUPERTYPE OF (ONEOF (b_spline_surface_with_knots, uniform_surface, 
quasi_uniform_surface, bezier_surface) ANDOR rational_b_spline_surface)
SUBTYPE OF (bounded_surface);
  u_degree : INTEGER;
  v_degree : INTEGER;
  control_points_list :  LIST [2:?] OF  LIST [2:?] OF cartesian_point;
  surface_form : b_spline_surface_form;
  u_closed : LOGICAL;
  v_closed : LOGICAL;
  self_intersect : LOGICAL;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  control_points :  ARRAY [0 : u_upper] OF  ARRAY [0 : v_upper] OF 
  cartesian_point := make_array_of_array(control_points_list, 0, u_upper, 0, 
  v_upper);
WHERE
  wr1 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNIFORM_SURFACE' IN TYPEOF(
    SELF)) OR ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUASI_UNIFORM_SURFACE' 
    IN TYPEOF(SELF)) OR (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BEZIER_SURFACE' IN TYPEOF(SELF)) 
    OR ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.B_SPLINE_SURFACE_WITH_KNOTS' 
    IN TYPEOF(SELF));
END_ENTITY;
 
ENTITY b_spline_surface_with_knots
SUBTYPE OF (b_spline_surface);
  u_multiplicities :  LIST [2:?] OF INTEGER;
  v_multiplicities :  LIST [2:?] OF INTEGER;
  u_knots :  LIST [2:?] OF parameter_value;
  v_knots :  LIST [2:?] OF parameter_value;
  knot_spec : knot_type;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
WHERE
  wr1 : constraints_param_b_spline(SELF\b_spline_surface.u_degree, knot_u_upper
    , SELF\b_spline_surface.u_upper, u_multiplicities, u_knots);
  wr2 : constraints_param_b_spline(SELF\b_spline_surface.v_degree, knot_v_upper
    , SELF\b_spline_surface.v_upper, v_multiplicities, v_knots);
  wr3 : SIZEOF(u_multiplicities) = knot_u_upper;
  wr4 : SIZEOF(v_multiplicities) = knot_v_upper;
END_ENTITY;
 
ENTITY b_spline_volume
SUPERTYPE OF (ONEOF (b_spline_volume_with_knots, uniform_volume, 
quasi_uniform_volume, bezier_volume) ANDOR rational_b_spline_volume)
SUBTYPE OF (volume);
  u_degree : INTEGER;
  v_degree : INTEGER;
  w_degree : INTEGER;
  control_points_list :  LIST [2:?] OF  LIST [2:?] OF  LIST [2:?] OF 
  cartesian_point;
DERIVE
  u_upper : INTEGER := SIZEOF(control_points_list) - 1;
  v_upper : INTEGER := SIZEOF(control_points_list[1]) - 1;
  w_upper : INTEGER := SIZEOF(control_points_list[1][1]) - 1;
  control_points :  ARRAY [0 : u_upper] OF  ARRAY [0 : v_upper] OF  ARRAY [0 : 
  w_upper] OF cartesian_point := make_array_of_array_of_array(
  control_points_list, 0, u_upper, 0, v_upper, 0, w_upper);
WHERE
  wr1 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BEZIER_VOLUME' IN TYPEOF(SELF
    )) OR ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.UNIFORM_VOLUME' IN TYPEOF(
    SELF)) OR ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.QUASI_UNIFORM_VOLUME' 
    IN TYPEOF(SELF)) OR (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.B_SPLINE_VOLUME_WITH_KNOTS' IN 
    TYPEOF(SELF));
END_ENTITY;
 
ENTITY b_spline_volume_with_knots
SUBTYPE OF (b_spline_volume);
  u_multiplicities :  LIST [2:?] OF INTEGER;
  v_multiplicities :  LIST [2:?] OF INTEGER;
  w_multiplicities :  LIST [2:?] OF INTEGER;
  u_knots :  LIST [2:?] OF parameter_value;
  v_knots :  LIST [2:?] OF parameter_value;
  w_knots :  LIST [2:?] OF parameter_value;
DERIVE
  knot_u_upper : INTEGER := SIZEOF(u_knots);
  knot_v_upper : INTEGER := SIZEOF(v_knots);
  knot_w_upper : INTEGER := SIZEOF(w_knots);
WHERE
  wr1 : constraints_param_b_spline(SELF\b_spline_volume.u_degree, knot_u_upper
    , SELF\b_spline_volume.u_upper, u_multiplicities, u_knots);
  wr2 : constraints_param_b_spline(SELF\b_spline_volume.v_degree, knot_v_upper
    , SELF\b_spline_volume.v_upper, v_multiplicities, v_knots);
  wr3 : constraints_param_b_spline(SELF\b_spline_volume.w_degree, knot_w_upper
    , SELF\b_spline_volume.w_upper, w_multiplicities, w_knots);
  wr4 : SIZEOF(u_multiplicities) = knot_u_upper;
  wr5 : SIZEOF(v_multiplicities) = knot_v_upper;
  wr6 : SIZEOF(w_multiplicities) = knot_w_upper;
END_ENTITY;
 
ENTITY bezier_curve
SUBTYPE OF (b_spline_curve);
END_ENTITY;
 
ENTITY bezier_surface
SUBTYPE OF (b_spline_surface);
END_ENTITY;
 
ENTITY bezier_volume
SUBTYPE OF (b_spline_volume);
END_ENTITY;
 
ENTITY block
SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;
 
ENTITY block_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
END_ENTITY;
 
ENTITY boolean_result
SUBTYPE OF (geometric_representation_item);
  operator : boolean_operator;
  first_operand : boolean_operand;
  second_operand : boolean_operand;
END_ENTITY;
 
ENTITY boundary_curve
SUBTYPE OF (composite_curve_on_surface);
WHERE
  wr1 : SELF\composite_curve.closed_curve;
END_ENTITY;
 
ENTITY bounded_curve
SUPERTYPE OF (ONEOF (polyline, b_spline_curve, trimmed_curve, bounded_pcurve, 
bounded_surface_curve, composite_curve))
SUBTYPE OF (curve);
END_ENTITY;
 
ENTITY bounded_pcurve
SUBTYPE OF (pcurve, bounded_curve);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOUNDED_CURVE' IN TYPEOF(SELF\
    pcurve.reference_to_curve.items[1]);
END_ENTITY;
 
ENTITY bounded_surface
SUPERTYPE OF (ONEOF (b_spline_surface, rectangular_trimmed_surface, 
curve_bounded_surface, rectangular_composite_surface))
SUBTYPE OF (surface);
END_ENTITY;
 
ENTITY bounded_surface_curve
SUBTYPE OF (surface_curve, bounded_curve);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOUNDED_CURVE' IN TYPEOF(SELF\
    surface_curve.curve_3d);
END_ENTITY;
 
ENTITY box_domain
SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  zlength : positive_length_measure;
WHERE
  wr1 : SIZEOF(QUERY(item <* USEDIN(SELF, '') | NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOXED_HALF_SPACE' IN TYPEOF(item))
    )) = 0;
END_ENTITY;
 
ENTITY boxed_half_space
SUBTYPE OF (half_space_solid);
  enclosure : box_domain;
END_ENTITY;
 
ENTITY breakdown_context
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY breakdown_element_group_assignment
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : 
  product_definition_element_relationship;
  items : SET [1:1] OF product_definition_or_breakdown_element_usage;
END_ENTITY;
 
ENTITY breakdown_element_realization
SUBTYPE OF (product_definition_element_relationship);
END_ENTITY;
 
ENTITY breakdown_element_usage
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY breakdown_of
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY brep_2d
SUBTYPE OF (solid_model);
  extent : face;
WHERE
  wr1 : SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FACE_SURFACE', 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SUBFACE', 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_FACE'] * TYPEOF(SELF.
    extent)) = 0;
  wr2 : SIZEOF(QUERY(bnds <* extent.bounds | NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound)))
    ) = 0;
  wr3 : SIZEOF(QUERY(bnds <* extent.bounds | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(bnds))
    ) = 1;
  wr4 : SIZEOF(QUERY(elp_fbnds <* QUERY(bnds <* extent.bounds | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EDGE_LOOP' IN TYPEOF(bnds.bound))
     | NOT (SIZEOF(QUERY(oe <* elp_fbnds.bound\path.edge_list | NOT ((
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EDGE_CURVE' IN TYPEOF(oe.
    edge_element)) AND (oe.edge_element\geometric_representation_item.dim = 2))
    )) = 0))) = 0;
END_ENTITY;
 
ENTITY brep_with_voids
SUBTYPE OF (manifold_solid_brep);
  voids : SET [1:?] OF oriented_closed_shell;
END_ENTITY;
 
ENTITY calendar_date
SUBTYPE OF (date);
  day_component : day_in_month_number;
  month_component : month_in_year_number;
WHERE
  wr1 : valid_calendar_date(SELF);
END_ENTITY;
 
ENTITY cartesian_point
SUPERTYPE OF (ONEOF (cylindrical_point, polar_point, spherical_point))
SUBTYPE OF (point);
  coordinates :  LIST [1:3] OF length_measure;
END_ENTITY;
 
ENTITY cartesian_transformation_operator
SUPERTYPE OF (ONEOF (cartesian_transformation_operator_2d, 
cartesian_transformation_operator_3d))
SUBTYPE OF (geometric_representation_item, functionally_defined_transformation)
  ;
  axis1 : OPTIONAL direction;
  axis2 : OPTIONAL direction;
  local_origin : cartesian_point;
  scale : OPTIONAL REAL;
DERIVE
  scl : REAL := NVL(scale, 1.0);
WHERE
  wr1 : scl > 0.0;
END_ENTITY;
 
ENTITY cartesian_transformation_operator_2d
SUBTYPE OF (cartesian_transformation_operator);
DERIVE
  u :  LIST [2:2] OF direction := base_axis(2, SELF\
  cartesian_transformation_operator.axis1, SELF\
  cartesian_transformation_operator.axis2, ?);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY;
 
ENTITY cartesian_transformation_operator_3d
SUBTYPE OF (cartesian_transformation_operator);
  axis3 : OPTIONAL direction;
DERIVE
  u :  LIST [3:3] OF direction := base_axis(3, SELF\
  cartesian_transformation_operator.axis1, SELF\
  cartesian_transformation_operator.axis2, axis3);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;
 
ENTITY celsius_temperature_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN
     TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY certification;
  name : label;
  purpose : text;
  kind : certification_type;
END_ENTITY;
 
ENTITY certification_assignment ABSTRACT SUPERTYPE;
  assigned_certification : certification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY certification_type;
  description : label;
END_ENTITY;
 
ENTITY characterized_applied_action_method_assignment
SUBTYPE OF (applied_action_method_assignment, characterized_object);
END_ENTITY;
 
ENTITY characterized_applied_state_assignment
SUBTYPE OF (applied_state_assignment, characterized_object);
END_ENTITY;
 
ENTITY characterized_applied_state_type_assignment
SUBTYPE OF (applied_state_type_assignment, characterized_object);
END_ENTITY;
 
ENTITY characterized_experience
SUBTYPE OF (characterized_object, experience);
END_ENTITY;
 
ENTITY characterized_location_object
SUBTYPE OF (characterized_object, location);
END_ENTITY;
 
ENTITY characterized_object;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY characterized_object_relationship;
  name : label;
  description : OPTIONAL text;
  relating_object : characterized_object;
  related_object : characterized_object;
END_ENTITY;
 
ENTITY characterized_person_type_definition
SUBTYPE OF (characterized_object, person_type_definition);
END_ENTITY;
 
ENTITY circle
SUBTYPE OF (conic);
  radius : positive_length_measure;
END_ENTITY;
 
ENTITY circular_area
SUBTYPE OF (primitive_2d);
  centre : cartesian_point;
  radius : positive_length_measure;
END_ENTITY;
 
ENTITY circular_involute
SUBTYPE OF (curve);
  position : axis2_placement;
  base_radius : positive_length_measure;
END_ENTITY;
 
ENTITY class
SUPERTYPE OF (ONEOF (class_by_extension, class_by_intension))
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY class_by_extension
SUBTYPE OF (class);
END_ENTITY;
 
ENTITY class_by_intension
SUBTYPE OF (class);
END_ENTITY;
 
(* NOT USED
ENTITY classification
SUBTYPE OF (classification_assignment);
  classified : classified_select;
DERIVE
  classifier : class := SELF\classification_assignment.assigned_class;
END_ENTITY;
*)

ENTITY classification_assignment ABSTRACT SUPERTYPE;
  assigned_class : group;
  role : classification_role;
END_ENTITY;
 
ENTITY classification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY closed_shell
SUBTYPE OF (connected_face_set);
END_ENTITY;
 
ENTITY clothoid
SUBTYPE OF (curve);
  position : axis2_placement;
  clothoid_constant : length_measure;
END_ENTITY;
 
ENTITY complement;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  set_1 : class;
  set_2 : class;
  universe : class;
END_ENTITY;
 
(* NOT USED
ENTITY complete_membership
SUBTYPE OF (classification_assignment);
  members : SET [1:?] OF classified_select;
DERIVE
  containing_set : class := SELF\classification_assignment.assigned_class;
END_ENTITY;
*)

ENTITY composite_curve
SUBTYPE OF (bounded_curve);
  segments :  LIST [1:?] OF composite_curve_segment;
  self_intersect : LOGICAL;
DERIVE
  n_segments : INTEGER := SIZEOF(segments);
  closed_curve : LOGICAL := segments[n_segments].transition <> discontinuous;
WHERE
  wr1 : NOT closed_curve AND (SIZEOF(QUERY(temp <* segments | temp.transition
     = discontinuous)) = 1) OR closed_curve AND (SIZEOF(QUERY(temp <* segments
     | temp.transition = discontinuous)) = 0);
END_ENTITY;
 
ENTITY composite_curve_on_surface
SUPERTYPE OF (boundary_curve)
SUBTYPE OF (composite_curve);
DERIVE
  basis_surface : SET [0:2] OF surface := get_basis_surface(SELF);
WHERE
  wr1 : SIZEOF(basis_surface) > 0;
  wr2 : constraints_composite_curve_on_surface(SELF);
END_ENTITY;
 
ENTITY composite_curve_segment
SUBTYPE OF (founded_item);
  transition : transition_code;
  same_sense : BOOLEAN;
  parent_curve : curve;
INVERSE
  using_curves : BAG [1:?] OF composite_curve FOR segments;
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOUNDED_CURVE' IN TYPEOF(
    parent_curve);
END_ENTITY;
 
ENTITY compound_representation_item
SUBTYPE OF (representation_item);
  item_element : compound_item_definition;
END_ENTITY;
 
ENTITY concept_feature_operator;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY concept_feature_relationship;
  name : label;
  description : OPTIONAL text;
  relating_product_concept_feature : product_concept_feature;
  related_product_concept_feature : product_concept_feature;
END_ENTITY;
 
ENTITY concept_feature_relationship_with_condition
SUBTYPE OF (concept_feature_relationship);
  conditional_operator : concept_feature_operator;
END_ENTITY;
 
ENTITY concurrent_action_method
SUBTYPE OF (action_method_relationship);
END_ENTITY;
 
ENTITY concurrent_task_method
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY conditional_concept_feature
SUBTYPE OF (product_concept_feature);
  condition : concept_feature_relationship_with_condition;
END_ENTITY;
 
ENTITY configurable_item
SUBTYPE OF (configuration_item);
  item_concept_feature : SET [1:?] OF product_concept_feature_association;
END_ENTITY;
 
ENTITY configuration_design;
  configuration : configuration_item;
  design : configuration_design_item;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
UNIQUE
  ur1 : configuration, design;
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY configuration_effectivity
SUBTYPE OF (product_definition_effectivity);
  configuration : configuration_design;
UNIQUE
  ur1 : configuration, usage, id;
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_USAGE' IN 
    TYPEOF(SELF\product_definition_effectivity.usage);
END_ENTITY;
 
ENTITY configuration_item;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  item_concept : product_concept;
  purpose : OPTIONAL label;
END_ENTITY;
 
ENTITY configuration_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_configuration_item : configuration_item;
  related_configuration_item : configuration_item;
END_ENTITY;
 
ENTITY conic
SUPERTYPE OF (ONEOF (circle, ellipse, hyperbola, parabola))
SUBTYPE OF (curve);
  position : axis2_placement;
END_ENTITY;
 
ENTITY conical_surface
SUBTYPE OF (elementary_surface);
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  wr1 : radius >= 0.0;
END_ENTITY;
 
ENTITY connected_edge_set
SUBTYPE OF (topological_representation_item);
  ces_edges : SET [1:?] OF edge;
END_ENTITY;
 
ENTITY connected_face_set
SUPERTYPE OF (ONEOF (closed_shell, open_shell))
SUBTYPE OF (topological_representation_item);
  cfs_faces : SET [1:?] OF face;
END_ENTITY;
 
ENTITY connected_face_sub_set
SUBTYPE OF (connected_face_set);
  parent_face_set : connected_face_set;
END_ENTITY;
 
ENTITY connector_on
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY containing_message
SUBTYPE OF (applied_group_assignment);
  SELF\group_assignment.assigned_group : message_contents_group;
  SELF\applied_group_assignment.items : SET [1:1] OF message_having_contents;
DERIVE
  containing_message : SET [1:1] OF message_having_contents := SELF\
  applied_group_assignment.items;
END_ENTITY;
 
ENTITY context_dependent_action_method_relationship;
  name : label;
  relating_relationship : action_method_relationship;
  related_relationship : action_method_relationship;
UNIQUE
  ur1 : relating_relationship, related_relationship;
WHERE
  wr1 : relating_relationship.relating_method :=: related_relationship.
    relating_method;
END_ENTITY;
 
ENTITY context_dependent_action_relationship;
  name : label;
  relating_relationship : action_relationship;
  related_relationship : action_relationship;
UNIQUE
  ur1 : relating_relationship, related_relationship;
WHERE
  wr1 : relating_relationship.relating_action :=: related_relationship.
    relating_action;
END_ENTITY;
 
ENTITY context_dependent_shape_representation;
  representation_relation : shape_representation_relationship;
  represented_product_relation : product_definition_shape;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value(SELF);
WHERE
  wr1 : 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP' 
    IN TYPEOF(SELF.represented_product_relation.definition);
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
  wr3 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY context_dependent_unit
SUBTYPE OF (named_unit);
  name : label;
END_ENTITY;
 
ENTITY contract;
  name : label;
  purpose : text;
  kind : contract_type;
END_ENTITY;
 
ENTITY contract_assignment ABSTRACT SUPERTYPE;
  assigned_contract : contract;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY contract_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_contract : contract;
  related_contract : contract;
END_ENTITY;
 
ENTITY contract_type;
  description : label;
END_ENTITY;
 
ENTITY conversion_based_unit
SUBTYPE OF (named_unit);
  name : label;
  conversion_factor : measure_with_unit;
END_ENTITY;
 
ENTITY convex_hexahedron
SUBTYPE OF (faceted_primitive);
WHERE
  wr1 : SIZEOF(points) = 8;
  wr2 : above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  wr3 : above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  wr4 : above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  wr5 : above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  wr6 : above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  wr7 : above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  wr8 : same_side([points[1], points[2], points[3]], [points[5], points[6], 
    points[7], points[8]]);
  wr9 : same_side([points[1], points[4], points[8]], [points[3], points[7], 
    points[6], points[2]]);
  wr10 : same_side([points[1], points[2], points[5]], [points[3], points[7], 
    points[8], points[4]]);
  wr11 : same_side([points[5], points[6], points[7]], [points[1], points[2], 
    points[3], points[4]]);
  wr12 : same_side([points[3], points[7], points[6]], [points[1], points[4], 
    points[8], points[5]]);
  wr13 : same_side([points[3], points[7], points[8]], [points[1], points[5], 
    points[6], points[2]]);
END_ENTITY;
 
ENTITY coordinated_universal_time_offset;
  hour_offset : INTEGER;
  minute_offset : OPTIONAL INTEGER;
  sense : ahead_or_behind;
DERIVE
  actual_minute_offset : INTEGER := NVL(minute_offset, 0);
WHERE
  wr1 : {0 <= hour_offset <= 24};
  wr2 : {0 <= actual_minute_offset <= 59};
  wr3 : NOT (((hour_offset <> 0) OR (actual_minute_offset <> 0)) AND (sense = 
    exact));
END_ENTITY;
 
ENTITY csg_solid
SUBTYPE OF (solid_model);
  tree_root_expression : csg_select;
END_ENTITY;
 
ENTITY curve
SUPERTYPE OF (ONEOF (line, conic, clothoid, circular_involute, pcurve, 
surface_curve, offset_curve_2d, offset_curve_3d, curve_replica))
SUBTYPE OF (geometric_representation_item);
END_ENTITY;
 
ENTITY curve_bounded_surface
SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  boundaries : SET [1:?] OF boundary_curve;
  implicit_outer : BOOLEAN;
WHERE
  wr1 : NOT implicit_outer OR (SIZEOF(QUERY(temp <* boundaries | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(
    temp))) = 0);
  wr2 : NOT implicit_outer OR (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.BOUNDED_SURFACE' IN TYPEOF(
    basis_surface));
  wr3 : SIZEOF(QUERY(temp <* boundaries | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OUTER_BOUNDARY_CURVE' IN TYPEOF(
    temp))) <= 1;
  wr4 : SIZEOF(QUERY(temp <* boundaries | temp\composite_curve_on_surface.
    basis_surface[1] <> SELF.basis_surface)) = 0;
END_ENTITY;
 
ENTITY curve_replica
SUBTYPE OF (curve);
  parent_curve : curve;
  transformation : cartesian_transformation_operator;
WHERE
  wr1 : transformation.dim = parent_curve.dim;
  wr2 : acyclic_curve_replica(SELF, parent_curve);
END_ENTITY;
 
ENTITY cyclide_segment_solid
SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  radius1 : positive_length_measure;
  radius2 : positive_length_measure;
  cone_angle1 : plane_angle_measure;
  cone_angle2 : plane_angle_measure;
  turn_angle : plane_angle_measure;
END_ENTITY;
 
ENTITY cylindrical_point
SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  z : length_measure;
DERIVE
  SELF\cartesian_point.coordinates :  LIST [1:3] OF length_measure := [r * COS(
  theta), r * SIN(theta), z];
WHERE
  wr1 : r >= 0.0;
END_ENTITY;
 
ENTITY cylindrical_surface
SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;
 
ENTITY cylindrical_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;
 
ENTITY data_environment;
  name : label;
  description : text;
  elements : SET [1:?] OF property_definition_representation;
END_ENTITY;
 
ENTITY data_environment_relationship;
  name : label;
  description : text;
  relating_data_environment : data_environment;
  related_data_environment : data_environment;
END_ENTITY;
 
ENTITY date
SUPERTYPE OF (ONEOF (calendar_date, ordinal_date, week_of_year_and_day_date));
  year_component : year_number;
END_ENTITY;
 
ENTITY date_and_time;
  date_component : date;
  time_component : local_time;
END_ENTITY;
 
ENTITY date_and_time_assignment ABSTRACT SUPERTYPE;
  assigned_date_and_time : date_and_time;
  role : date_time_role;
END_ENTITY;
 
ENTITY date_assignment ABSTRACT SUPERTYPE;
  assigned_date : date;
  role : date_role;
END_ENTITY;
 
ENTITY date_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY date_time_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY dated_effectivity
SUBTYPE OF (effectivity);
  effectivity_end_date : OPTIONAL date_time_or_event_occurrence;
  effectivity_start_date : date_time_or_event_occurrence;
END_ENTITY;
 
ENTITY definitional_representation
SUBTYPE OF (representation);
WHERE
  wr1 : 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PARAMETRIC_REPRESENTATION_CONTEXT'
     IN TYPEOF(SELF\representation.context_of_items);
END_ENTITY;
 
ENTITY degenerate_pcurve
SUBTYPE OF (point);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  wr1 : SIZEOF(reference_to_curve\representation.items) = 1;
  wr2 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CURVE' IN TYPEOF(
    reference_to_curve\representation.items[1]);
  wr3 : reference_to_curve\representation.items[1]\
    geometric_representation_item.dim = 2;
END_ENTITY;
 
ENTITY degenerate_toroidal_surface
SUBTYPE OF (toroidal_surface);
  select_outer : BOOLEAN;
WHERE
  wr1 : major_radius < minor_radius;
END_ENTITY;
 
ENTITY derived_unit;
  elements : SET [1:?] OF derived_unit_element;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  wr1 : (SIZEOF(elements) > 1) OR (SIZEOF(elements) = 1) AND (elements[1].
    exponent <> 1.0);
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY derived_unit_element;
  unit : named_unit;
  exponent : REAL;
END_ENTITY;
 
ENTITY description_attribute;
  attribute_value : text;
  described_item : description_attribute_select;
END_ENTITY;
 
ENTITY descriptive_representation_item
SUBTYPE OF (representation_item);
  description : text;
END_ENTITY;
 
ENTITY dimensional_exponents;
  length_exponent : REAL;
  mass_exponent : REAL;
  time_exponent : REAL;
  electric_current_exponent : REAL;
  thermodynamic_temperature_exponent : REAL;
  amount_of_substance_exponent : REAL;
  luminous_intensity_exponent : REAL;
END_ENTITY;
 
ENTITY directed_action
SUBTYPE OF (executed_action);
  directive : action_directive;
END_ENTITY;
 
ENTITY direction
SUBTYPE OF (geometric_representation_item);
  direction_ratios :  LIST [2:3] OF REAL;
WHERE
  wr1 : SIZEOF(QUERY(tmp <* direction_ratios | tmp <> 0.0)) > 0;
END_ENTITY;
 
ENTITY document;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  kind : document_type;
INVERSE
  representation_types : SET OF document_representation_type FOR 
  represented_document;
END_ENTITY;
 
ENTITY document_file
SUBTYPE OF (document, characterized_object);
WHERE
  wr1 : SELF\characterized_object.name = '';
  wr2 : NOT EXISTS(SELF\characterized_object.description);
  wr3 : SIZEOF(QUERY(drt <* SELF\document.representation_types | drt.name IN [
    'digital', 'physical'])) = 1;
END_ENTITY;
 
ENTITY document_product_association;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_product : product_or_formation_or_definition;
END_ENTITY;
 
ENTITY document_product_equivalence
SUBTYPE OF (document_product_association);
WHERE
  wr1 : SELF\document_product_association.name = 'equivalence';
  wr2 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT' IN TYPEOF(SELF\
    document_product_association.related_product)) OR (SELF\
    document_product_association.relating_document.kind.product_data_type = 
    'configuration controlled document') AND (SIZEOF(QUERY(prpc <* USEDIN(SELF\
    document_product_association.related_product, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS'
    ) | prpc.name = 'document')) = 1);
  wr3 : NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION' IN 
    TYPEOF(SELF.related_product)) OR (SELF\document_product_association.
    relating_document.kind.product_data_type = 
    'configuration controlled document version') AND (SIZEOF(QUERY(prpc <* 
    USEDIN(SELF.related_product\product_definition_formation.of_product, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS'
    ) | prpc.name = 'document')) = 1);
  wr4 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION' IN 
    TYPEOF(SELF.related_product)) OR (SELF\document_product_association.
    relating_document.kind.product_data_type = 
    'configuration controlled document definition') AND (SIZEOF(QUERY(prpc <* 
    USEDIN(SELF\document_product_association.related_product\product_definition
    .formation.of_product, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS'
    ) | prpc.name = 'document')) = 1);
END_ENTITY;
 
ENTITY document_reference ABSTRACT SUPERTYPE;
  assigned_document : document;
  source : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY document_relationship;
  name : label;
  description : OPTIONAL text;
  relating_document : document;
  related_document : document;
END_ENTITY;
 
ENTITY document_representation_type;
  name : label;
  represented_document : document;
END_ENTITY;
 
ENTITY document_type;
  product_data_type : label;
END_ENTITY;
 
ENTITY document_usage_constraint;
  source : document;
  subject_element : label;
  subject_element_value : text;
END_ENTITY;
 
ENTITY document_usage_constraint_assignment ABSTRACT SUPERTYPE;
  assigned_document_usage : document_usage_constraint;
  role : document_usage_role;
END_ENTITY;
 
ENTITY document_usage_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY document_with_class
SUBTYPE OF (document);
  class : identifier;
END_ENTITY;
 
ENTITY double_toleranced_measure_item
SUBTYPE OF (compound_representation_item);
  SELF\compound_representation_item.item_element : 
  list_of_two_representation_items;
END_ENTITY;
 
ENTITY dupin_cyclide_surface
SUBTYPE OF (elementary_surface);
  generalised_major_radius : positive_length_measure;
  generalised_minor_radius : positive_length_measure;
  skewness : length_measure;
WHERE
  wr1 : skewness >= 0.0;
END_ENTITY;
 
ENTITY eccentric_cone
SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  wr1 : ratio >= 0.0;
END_ENTITY;
 
ENTITY eccentric_conical_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  height : positive_length_measure;
  x_offset : length_measure;
  y_offset : length_measure;
  ratio : REAL;
WHERE
  wr1 : ratio >= 0.0;
END_ENTITY;
 
ENTITY edge
SUPERTYPE OF (ONEOF (edge_curve, oriented_edge, subedge))
SUBTYPE OF (topological_representation_item);
  edge_start : vertex;
  edge_end : vertex;
END_ENTITY;
 
ENTITY edge_based_wireframe_model
SUBTYPE OF (geometric_representation_item);
  ebwm_boundary : SET [1:?] OF connected_edge_set;
END_ENTITY;
 
ENTITY edge_curve
SUBTYPE OF (edge, geometric_representation_item);
  edge_geometry : curve;
  same_sense : BOOLEAN;
END_ENTITY;
 
ENTITY edge_loop
SUBTYPE OF (loop, path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  wr1 : SELF\path.edge_list[1].edge_start :=: SELF\path.edge_list[ne].edge_end;
END_ENTITY;
 
ENTITY effectivity
SUPERTYPE OF (ONEOF (serial_numbered_effectivity, dated_effectivity, 
lot_effectivity, time_interval_based_effectivity));
  id : identifier;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY effectivity_assignment ABSTRACT SUPERTYPE;
  assigned_effectivity : effectivity;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY effectivity_context_assignment ABSTRACT SUPERTYPE;
  assigned_effectivity_assignment : effectivity_assignment;
  role : effectivity_context_role;
END_ENTITY;
 
ENTITY effectivity_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY effectivity_relationship;
  name : label;
  description : OPTIONAL text;
  related_effectivity : effectivity;
  relating_effectivity : effectivity;
END_ENTITY;
 
ENTITY electric_current_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_CURRENT_UNIT' IN 
    TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY electric_current_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 1.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY elementary_surface
SUPERTYPE OF (ONEOF (plane, cylindrical_surface, conical_surface, 
spherical_surface, toroidal_surface))
SUBTYPE OF (surface);
  position : axis2_placement_3d;
END_ENTITY;
 
ENTITY ellipse
SUBTYPE OF (conic);
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;
 
ENTITY ellipsoid
SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;
 
ENTITY ellipsoid_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
  semi_axis_3 : positive_length_measure;
END_ENTITY;
 
ENTITY elliptic_area
SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  semi_axis_1 : positive_length_measure;
  semi_axis_2 : positive_length_measure;
END_ENTITY;
 
ENTITY end_task
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY envelope
SUBTYPE OF (characterized_object, product);
END_ENTITY;
 
ENTITY envelope_relationship
SUBTYPE OF (product_relationship);
END_ENTITY;
 
ENTITY evaluated_degenerate_pcurve
SUBTYPE OF (degenerate_pcurve);
  equivalent_point : cartesian_point;
END_ENTITY;
 
ENTITY event_occurrence;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY event_occurrence_assignment ABSTRACT SUPERTYPE;
  assigned_event_occurrence : event_occurrence;
  role : event_occurrence_role;
END_ENTITY;
 
ENTITY event_occurrence_context_assignment ABSTRACT SUPERTYPE;
  assigned_event_occurrence_assignment : event_occurrence_assignment;
  role : event_occurrence_context_role;
END_ENTITY;
 
ENTITY event_occurrence_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY event_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  relating_event : event_occurrence;
  related_event : event_occurrence;
END_ENTITY;
 
ENTITY event_occurrence_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY executed_action
SUBTYPE OF (action);
END_ENTITY;
 
ENTITY exit_loop
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY expanded_uncertainty
SUBTYPE OF (standard_uncertainty);
  coverage_factor : REAL;
END_ENTITY;
 
ENTITY experience;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY experience_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_experience : experience;
END_ENTITY;
 
ENTITY experience_relationship;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  relating_experience : experience;
  related_experience : experience;
END_ENTITY;
 
ENTITY experience_type;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY experience_type_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_experience_type : experience_type;
END_ENTITY;
 
ENTITY experience_type_relationship;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  relating_experience_type : experience_type;
  related_experience_type : experience_type;
END_ENTITY;
 
ENTITY external_class_library
SUBTYPE OF (external_source);
END_ENTITY;
 
ENTITY external_identification_assignment ABSTRACT SUPERTYPE
SUBTYPE OF (identification_assignment);
  source : external_source;
END_ENTITY;
 
ENTITY external_referent_assignment ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role(SELF);
UNIQUE
  ur1 : assigned_name;
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY external_source;
  source_id : source_item;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY external_source_relationship;
  name : label;
  description : OPTIONAL text;
  relating_source : external_source;
  related_source : external_source;
END_ENTITY;
 
ENTITY externally_defined_class
SUBTYPE OF (class, externally_defined_item);
END_ENTITY;
 
ENTITY externally_defined_item;
  item_id : source_item;
  source : external_source;
END_ENTITY;
 
ENTITY externally_defined_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_item : externally_defined_item;
  related_item : externally_defined_item;
END_ENTITY;
 
ENTITY extruded_area_solid
SUBTYPE OF (swept_area_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  wr1 : dot_product(SELF\swept_area_solid.swept_area.basis_surface\
    elementary_surface.position.p[3], extruded_direction) <> 0.0;
END_ENTITY;
 
ENTITY extruded_face_solid
SUBTYPE OF (swept_face_solid);
  extruded_direction : direction;
  depth : positive_length_measure;
WHERE
  wr1 : dot_product(SELF\swept_face_solid.swept_face.face_geometry\
    elementary_surface.position.p[3], extruded_direction) <> 0.0;
END_ENTITY;
 
ENTITY face
SUPERTYPE OF (ONEOF (face_surface, subface, oriented_face))
SUBTYPE OF (topological_representation_item);
  bounds : SET [1:?] OF face_bound;
WHERE
  wr1 : NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)));
  wr2 : SIZEOF(QUERY(temp <* bounds | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(temp))
    ) <= 1;
END_ENTITY;
 
ENTITY face_based_surface_model
SUBTYPE OF (geometric_representation_item);
  fbsm_faces : SET [1:?] OF connected_face_set;
END_ENTITY;
 
ENTITY face_bound
SUBTYPE OF (topological_representation_item);
  bound : loop;
  orientation : BOOLEAN;
END_ENTITY;
 
ENTITY face_outer_bound
SUBTYPE OF (face_bound);
END_ENTITY;
 
ENTITY face_surface
SUBTYPE OF (face, geometric_representation_item);
  face_geometry : surface;
  same_sense : BOOLEAN;
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_SURFACE' IN 
    TYPEOF(face_geometry));
END_ENTITY;
 
ENTITY faceted_brep
SUBTYPE OF (manifold_solid_brep);
END_ENTITY;
 
ENTITY faceted_primitive
SUPERTYPE OF (ONEOF (tetrahedron, convex_hexahedron))
SUBTYPE OF (geometric_representation_item);
  points :  LIST [4:?] OF UNIQUE cartesian_point;
WHERE
  wr1 : points[1].dim = 3;
END_ENTITY;
 
ENTITY fixed_reference_swept_surface
SUBTYPE OF (swept_surface);
  directrix : curve;
  fixed_reference : direction;
END_ENTITY;
 
ENTITY founded_item;
END_ENTITY;
 
ENTITY functional_breakdown_context
SUBTYPE OF (breakdown_context);
END_ENTITY;
 
ENTITY functional_element_usage
SUBTYPE OF (breakdown_element_usage);
END_ENTITY;
 
ENTITY functionally_defined_transformation;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY general_property;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY general_property_association;
  name : label;
  description : OPTIONAL text;
  base_definition : general_property;
  derived_definition : derived_property_select;
WHERE
  wr1 : SIZEOF(USEDIN(derived_definition, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERAL_PROPERTY_ASSOCIATION.DERIVED_DEFINITION'
    )) = 1;
  wr2 : derived_definition.name = base_definition.name;
END_ENTITY;
 
ENTITY general_property_relationship;
  name : label;
  description : OPTIONAL text;
  relating_property : general_property;
  related_property : general_property;
END_ENTITY;
 
ENTITY geometric_curve_set
SUBTYPE OF (geometric_set);
WHERE
  wr1 : SIZEOF(QUERY(temp <* SELF\geometric_set.elements | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE' IN TYPEOF(temp))) = 0;
END_ENTITY;
 
ENTITY geometric_representation_context
SUBTYPE OF (representation_context);
  coordinate_space_dimension : dimension_count;
END_ENTITY;
 
ENTITY geometric_representation_item
SUPERTYPE OF (ONEOF (point, direction, vector, placement, 
cartesian_transformation_operator, curve, surface, volume))
SUBTYPE OF (representation_item);
DERIVE
  dim : dimension_count := dimension_of(SELF);
WHERE
  wr1 : SIZEOF(QUERY(using_rep <* using_representations(SELF) | NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GEOMETRIC_REPRESENTATION_CONTEXT' 
    IN TYPEOF(using_rep.context_of_items)))) = 0;
END_ENTITY;
 
ENTITY geometric_set
SUPERTYPE OF (ONEOF (geometric_curve_set, geometric_set_replica))
SUBTYPE OF (geometric_representation_item);
  elements : SET [1:?] OF geometric_set_select;
END_ENTITY;
 
ENTITY geometric_set_replica
SUBTYPE OF (geometric_set);
  parent_set : geometric_set;
  transformation : cartesian_transformation_operator;
DERIVE
  SELF\geometric_set.elements : SET [1:?] OF geometric_set_select := 
  build_transformed_set(transformation, parent_set);
WHERE
  wr1 : acyclic_set_replica(SELF, parent_set);
END_ENTITY;
 
ENTITY global_uncertainty_assigned_context
SUBTYPE OF (representation_context);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;
 
ENTITY global_unit_assigned_context
SUBTYPE OF (representation_context);
  units : SET [1:?] OF unit;
END_ENTITY;
 
ENTITY group;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY group_assignment ABSTRACT SUPERTYPE;
  assigned_group : group;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY group_relationship;
  name : label;
  description : OPTIONAL text;
  relating_group : group;
  related_group : group;
END_ENTITY;
 
ENTITY half_space_2d
SUBTYPE OF (geometric_representation_item);
  base_curve : curve;
  agreement_flag : BOOLEAN;
END_ENTITY;
 
ENTITY half_space_solid
SUBTYPE OF (geometric_representation_item);
  base_surface : surface;
  agreement_flag : BOOLEAN;
END_ENTITY;
 
ENTITY hexahedron_volume
SUBTYPE OF (volume);
  points :  LIST [8:8] OF cartesian_point;
WHERE
  wr1 : above_plane(points[1], points[2], points[3], points[4]) = 0.0;
  wr2 : above_plane(points[5], points[8], points[7], points[6]) = 0.0;
  wr3 : above_plane(points[1], points[4], points[8], points[5]) = 0.0;
  wr4 : above_plane(points[4], points[3], points[7], points[8]) = 0.0;
  wr5 : above_plane(points[3], points[2], points[6], points[7]) = 0.0;
  wr6 : above_plane(points[1], points[5], points[6], points[2]) = 0.0;
  wr7 : same_side([points[1], points[2], points[3]], [points[5], points[6], 
    points[7], points[8]]);
  wr8 : same_side([points[1], points[4], points[8]], [points[3], points[7], 
    points[6], points[2]]);
  wr9 : same_side([points[1], points[2], points[5]], [points[3], points[7], 
    points[8], points[4]]);
  wr10 : same_side([points[5], points[6], points[7]], [points[1], points[2], 
    points[3], points[4]]);
  wr11 : same_side([points[3], points[7], points[6]], [points[1], points[4], 
    points[8], points[5]]);
  wr12 : same_side([points[3], points[7], points[8]], [points[1], points[5], 
    points[6], points[2]]);
  wr13 : points[1].dim = 3;
END_ENTITY;
 
ENTITY hybrid_breakdown_context
SUBTYPE OF (breakdown_context);
END_ENTITY;
 
ENTITY hybrid_element_usage
SUBTYPE OF (breakdown_element_usage);
END_ENTITY;
 
ENTITY hyperbola
SUBTYPE OF (conic);
  semi_axis : positive_length_measure;
  semi_imag_axis : positive_length_measure;
END_ENTITY;
 
ENTITY id_attribute;
  attribute_value : identifier;
  identified_item : id_attribute_select;
END_ENTITY;
 
ENTITY identification_assignment ABSTRACT SUPERTYPE;
  assigned_id : identifier;
  role : identification_role;
END_ENTITY;
 
ENTITY identification_assignment_relationship;
  name : label;
  description : OPTIONAL text;
  relating_identification_assignment : identification_assignment;
  related_identification_assignment : identification_assignment;
END_ENTITY;
 
ENTITY identification_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY in_zone
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY information_right
SUBTYPE OF (action_method);
END_ENTITY;
 
ENTITY information_usage_right
SUBTYPE OF (action_method);
END_ENTITY;
 
ENTITY interface_connection
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY interface_connector_as_planned
SUBTYPE OF (product_definition_formation);
END_ENTITY;
 
ENTITY interface_connector_as_realized
SUBTYPE OF (product_definition_formation);
END_ENTITY;
 
ENTITY interface_connector_design
SUBTYPE OF (product_definition_formation);
END_ENTITY;
 
ENTITY interface_connector_design_to_planned
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : interface_connector_as_planned;
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : interface_connector_design;
WHERE
  wr1 : SELF.relating_product_definition_formation.of_product :=: SELF.
    related_product_definition_formation.of_product;
END_ENTITY;
 
ENTITY interface_connector_design_to_realized
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : interface_connector_as_realized;
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : interface_connector_design;
WHERE
  wr1 : SELF.relating_product_definition_formation.of_product :=: SELF.
    related_product_definition_formation.of_product;
END_ENTITY;
 
ENTITY interface_connector_planned_to_realized
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : interface_connector_as_realized;
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : interface_connector_as_planned;
WHERE
  wr1 : SELF.relating_product_definition_formation.of_product :=: SELF.
    related_product_definition_formation.of_product;
END_ENTITY;
 
ENTITY interface_definition_for
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY intersection;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  operand : SET [2:?] OF class;
  resultant : class;
END_ENTITY;
 
ENTITY intersection_curve
SUBTYPE OF (surface_curve);
WHERE
  wr1 : SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  wr2 : associated_surface(SELF\surface_curve.associated_geometry[1]) <> 
    associated_surface(SELF\surface_curve.associated_geometry[2]);
END_ENTITY;
 
ENTITY item_defined_transformation;
  name : label;
  description : OPTIONAL text;
  transform_item_1 : representation_item;
  transform_item_2 : representation_item;
END_ENTITY;
 
ENTITY item_identified_representation_usage;
  name : label;
  description : OPTIONAL text;
  definition : represented_definition;
  used_representation : representation;
  identified_item : representation_item;
WHERE
  wr1 : SELF.used_representation IN using_representations(SELF.identified_item)
    ;
END_ENTITY;
 
ENTITY justification_assignment
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY justification_group_assignment
SUBTYPE OF (group_assignment);
  items : SET [1:1] OF product;
END_ENTITY;
 
ENTITY justification_item_group_assignment
SUBTYPE OF (group_assignment);
  items : SET [1:1] OF justification_item;
END_ENTITY;
 
ENTITY justification_support_assignment
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY justification_support_item_group_assignment
SUBTYPE OF (group_assignment);
  items : SET [1:1] OF justification_support_item;
END_ENTITY;
 
ENTITY language
SUBTYPE OF (group);
WHERE
  wr1 : SELF\group.name <> '';
END_ENTITY;
 
ENTITY length_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LENGTH_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY length_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 1.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY library_assignment ABSTRACT SUPERTYPE
SUBTYPE OF (external_referent_assignment);
  frame_of_reference : library_context;
UNIQUE
  ur1 : frame_of_reference;
END_ENTITY;
 
ENTITY library_context
SUBTYPE OF (application_context_element);
  library_reference : label;
END_ENTITY;
 
ENTITY line
SUBTYPE OF (curve);
  pnt : cartesian_point;
  dir : vector;
WHERE
  wr1 : dir.dim = pnt.dim;
END_ENTITY;
 
ENTITY local_time;
  hour_component : hour_in_day;
  minute_component : OPTIONAL minute_in_hour;
  second_component : OPTIONAL second_in_minute;
  zone : coordinated_universal_time_offset;
WHERE
  wr1 : valid_time(SELF);
END_ENTITY;
 
ENTITY location;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY location_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_location : location;
END_ENTITY;
 
ENTITY location_relationship;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  relating_location : location;
  related_location : location;
END_ENTITY;
 
ENTITY location_representation_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  represented_location : location;
END_ENTITY;
 
ENTITY loop
SUPERTYPE OF (ONEOF (vertex_loop, edge_loop, poly_loop))
SUBTYPE OF (topological_representation_item);
END_ENTITY;
 
ENTITY looping_method
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY lot_effectivity
SUBTYPE OF (effectivity);
  effectivity_lot_id : identifier;
  effectivity_lot_size : measure_with_unit;
END_ENTITY;
 
ENTITY luminous_intensity_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LUMINOUS_INTENSITY_UNIT' IN 
    TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY luminous_intensity_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 1.0);
END_ENTITY;
 
ENTITY make_from_usage_option
SUBTYPE OF (product_definition_usage);
  ranking : INTEGER;
  ranking_rationale : text;
  quantity : measure_with_unit;
WHERE
  wr1 : NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.
    value_component > 0);
END_ENTITY;
 
ENTITY make_from_usage_option_group;
  members : SET [2:?] OF make_from_usage_option;
WHERE
  wr1 : SIZEOF(QUERY(example <* members | example.related_product_definition
     :=: members[1].related_product_definition)) = SIZEOF(members);
END_ENTITY;
 
ENTITY manifold_solid_brep
SUBTYPE OF (solid_model);
  outer : closed_shell;
END_ENTITY;
 
ENTITY mapped_item
SUBTYPE OF (representation_item);
  mapping_source : representation_map;
  mapping_target : representation_item;
WHERE
  wr1 : acyclic_mapped_representation(using_representations(SELF), [SELF]);
END_ENTITY;
 
ENTITY mass_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MASS_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY mass_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 1.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY material_designation;
  name : label;
  definitions : SET [1:?] OF characterized_definition;
END_ENTITY;
 
ENTITY material_designation_characterization;
  name : label;
  description : text;
  designation : material_designation;
  property : characterized_material_property;
END_ENTITY;
 
ENTITY material_property
SUBTYPE OF (property_definition);
UNIQUE
  ur1 : SELF\property_definition.name, SELF\property_definition.definition;
WHERE
  wr1 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_OBJECT' IN 
    TYPEOF(SELF\property_definition.definition)) OR (SIZEOF(bag_to_set(USEDIN(
    SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
    )) - QUERY(temp <* bag_to_set(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
    )) | 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.' + 
    'MATERIAL_PROPERTY_REPRESENTATION' IN TYPEOF(temp))) = 0);
END_ENTITY;
 
ENTITY material_property_representation
SUBTYPE OF (property_definition_representation);
  dependent_environment : data_environment;
END_ENTITY;
 
ENTITY measure_qualification;
  name : label;
  description : text;
  qualified_measure : measure_with_unit;
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  wr1 : SIZEOF(QUERY(temp <* qualifiers | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(
    temp))) < 2;
END_ENTITY;
 
ENTITY measure_representation_item
SUBTYPE OF (representation_item, measure_with_unit);
END_ENTITY;
 
ENTITY measure_with_unit
SUPERTYPE OF (ONEOF (length_measure_with_unit, mass_measure_with_unit, 
time_measure_with_unit, electric_current_measure_with_unit, 
thermodynamic_temperature_measure_with_unit, 
celsius_temperature_measure_with_unit, amount_of_substance_measure_with_unit, 
luminous_intensity_measure_with_unit, plane_angle_measure_with_unit, 
solid_angle_measure_with_unit, area_measure_with_unit, volume_measure_with_unit
, ratio_measure_with_unit));
  value_component : measure_value;
  unit_component : unit;
WHERE
  wr1 : valid_units(SELF);
END_ENTITY;
 
ENTITY message_contents_assignment
SUBTYPE OF (applied_group_assignment);
  SELF\group_assignment.assigned_group : message_contents_group;
  SELF\applied_group_assignment.items : SET [1:?] OF contents_item;
END_ENTITY;
 
ENTITY message_contents_group
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY message_relationship
SUBTYPE OF (product_relationship);
  SELF\product_relationship.related_product : structured_message;
  SELF\product_relationship.relating_product : structured_message;
DERIVE
  related_message : structured_message := SELF\product_relationship.
  related_product;
  relating_message : structured_message := SELF\product_relationship.
  relating_product;
END_ENTITY;
 
ENTITY multi_language_attribute_assignment
SUBTYPE OF (attribute_value_assignment);
  items : SET [1:?] OF multi_language_attribute_item;
DERIVE
  translation_language : language := language_indication[1]\
  attribute_classification_assignment.assigned_class;
INVERSE
  language_indication : SET [1:1] OF attribute_language_assignment FOR items;
WHERE
  wr1 : SELF\attribute_value_assignment.role.name = 'alternate language';
  wr2 : SIZEOF(QUERY(ala <* language_indication | (ala\
    attribute_classification_assignment.attribute_name = 'attribute_value') AND
     (ala\attribute_classification_assignment.role.name = 'translated'))) = 1;
  wr3 : SELF\attribute_value_assignment.attribute_name <> '';
  wr4 : SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MULTI_LANGUAGE_ATTRIBUTE_ASSIGNMENT.ITEMS'
    ) | (ata\attribute_value_assignment.attribute_name = SELF\
    attribute_value_assignment.attribute_name) AND (ata.translation_language
     :=: translation_language))) > 1)) = 0;
  wr5 : SIZEOF(QUERY(ci <* items | SIZEOF(QUERY(ata <* USEDIN(ci, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ATTRIBUTE_LANGUAGE_ASSIGNMENT.ITEMS'
    ) | (ata\attribute_classification_assignment.role.name = 'primary') AND (
    ata\attribute_classification_assignment.attribute_name = SELF\
    attribute_value_assignment.attribute_name) AND (ata\
    attribute_classification_assignment.assigned_class :=: translation_language
    ))) > 0)) = 0;
END_ENTITY;
 
ENTITY name_assignment ABSTRACT SUPERTYPE;
  assigned_name : label;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY name_attribute;
  attribute_value : label;
  named_item : name_attribute_select;
END_ENTITY;
 
ENTITY named_unit
SUPERTYPE OF (ONEOF (si_unit, conversion_based_unit, context_dependent_unit)
 ANDOR ONEOF (length_unit, mass_unit, time_unit, electric_current_unit, 
thermodynamic_temperature_unit, amount_of_substance_unit, 
luminous_intensity_unit, plane_angle_unit, solid_angle_unit, area_unit, 
volume_unit, ratio_unit));
  dimensions : dimensional_exponents;
END_ENTITY;
 
ENTITY next_assembly_usage_occurrence
SUBTYPE OF (assembly_component_usage);
END_ENTITY;
 
ENTITY object_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY observation
SUBTYPE OF (action_actual);
END_ENTITY;
 
ENTITY observation_consequence
SUBTYPE OF (action_request_solution);
END_ENTITY;
 
ENTITY observation_relationship
SUBTYPE OF (action_relationship);
END_ENTITY;
 
ENTITY offset_curve_2d
SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
WHERE
  wr1 : basis_curve.dim = 2;
END_ENTITY;
 
ENTITY offset_curve_3d
SUBTYPE OF (curve);
  basis_curve : curve;
  distance : length_measure;
  self_intersect : LOGICAL;
  ref_direction : direction;
WHERE
  wr1 : (basis_curve.dim = 3) AND (ref_direction.dim = 3);
END_ENTITY;
 
ENTITY offset_surface
SUBTYPE OF (surface);
  basis_surface : surface;
  distance : length_measure;
  self_intersect : LOGICAL;
END_ENTITY;
 
ENTITY open_path
SUBTYPE OF (path);
DERIVE
  ne : INTEGER := SIZEOF(SELF\path.edge_list);
WHERE
  wr1 : SELF\path.edge_list[1].edge_element.edge_start :<>: SELF\path.edge_list
    [ne].edge_element.edge_end;
END_ENTITY;
 
ENTITY open_shell
SUBTYPE OF (connected_face_set);
END_ENTITY;
 
ENTITY ordinal_date
SUBTYPE OF (date);
  day_component : day_in_year_number;
WHERE
  wr1 : NOT leap_year(SELF.year_component) AND {1 <= day_component <= 365} OR 
    leap_year(SELF.year_component) AND {1 <= day_component <= 366};
END_ENTITY;
 
ENTITY organization;
  id : OPTIONAL identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY organization_assignment ABSTRACT SUPERTYPE;
  assigned_organization : organization;
  role : organization_role;
END_ENTITY;
 
ENTITY organization_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organization : organization;
  related_organization : organization;
END_ENTITY;
 
ENTITY organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY organization_type;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY organization_type_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_organization_type : organization_type;
END_ENTITY;
 
ENTITY organization_type_relationship;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  relating_organization_type : organization_type;
  related_organization_type : organization_type;
END_ENTITY;
 
ENTITY organizational_address
SUBTYPE OF (address);
  organizations : SET [1:?] OF organization;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY organizational_project;
  name : label;
  description : OPTIONAL text;
  responsible_organizations : SET [1:?] OF organization;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY organizational_project_assignment ABSTRACT SUPERTYPE;
  assigned_organizational_project : organizational_project;
  role : organizational_project_role;
END_ENTITY;
 
ENTITY organizational_project_relationship;
  name : label;
  description : OPTIONAL text;
  relating_organizational_project : organizational_project;
  related_organizational_project : organizational_project;
END_ENTITY;
 
ENTITY organizational_project_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY oriented_closed_shell
SUBTYPE OF (closed_shell);
  closed_shell_element : closed_shell;
  orientation : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(
  SELF.orientation, SELF.closed_shell_element.cfs_faces);
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_CLOSED_SHELL' IN
     TYPEOF(SELF.closed_shell_element));
END_ENTITY;
 
ENTITY oriented_edge
SUBTYPE OF (edge);
  edge_element : edge;
  orientation : BOOLEAN;
DERIVE
  SELF\edge.edge_start : vertex := boolean_choose(SELF.orientation, SELF.
  edge_element.edge_start, SELF.edge_element.edge_end);
  SELF\edge.edge_end : vertex := boolean_choose(SELF.orientation, SELF.
  edge_element.edge_end, SELF.edge_element.edge_start);
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_EDGE' IN TYPEOF(
    SELF.edge_element));
END_ENTITY;
 
ENTITY oriented_face
SUBTYPE OF (face);
  face_element : face;
  orientation : BOOLEAN;
DERIVE
  SELF\face.bounds : SET [1:?] OF face_bound := conditional_reverse(SELF.
  orientation, SELF.face_element.bounds);
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_FACE' IN TYPEOF(
    SELF.face_element));
END_ENTITY;
 
ENTITY oriented_open_shell
SUBTYPE OF (open_shell);
  open_shell_element : open_shell;
  orientation : BOOLEAN;
DERIVE
  SELF\connected_face_set.cfs_faces : SET [1:?] OF face := conditional_reverse(
  SELF.orientation, SELF.open_shell_element.cfs_faces);
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_OPEN_SHELL' IN 
    TYPEOF(SELF.open_shell_element));
END_ENTITY;
 
ENTITY oriented_path
SUBTYPE OF (path);
  path_element : path;
  orientation : BOOLEAN;
DERIVE
  SELF\path.edge_list :  LIST [1:?] OF UNIQUE oriented_edge := 
  conditional_reverse(SELF.orientation, SELF.path_element.edge_list);
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_PATH' IN TYPEOF(
    SELF.path_element));
END_ENTITY;
 
ENTITY oriented_surface
SUBTYPE OF (surface);
  orientation : BOOLEAN;
END_ENTITY;
 
ENTITY outer_boundary_curve
SUBTYPE OF (boundary_curve);
END_ENTITY;
 
ENTITY parabola
SUBTYPE OF (conic);
  focal_dist : length_measure;
WHERE
  wr1 : focal_dist <> 0.0;
END_ENTITY;
 
ENTITY parametric_representation_context
SUBTYPE OF (representation_context);
END_ENTITY;
 
ENTITY path
SUPERTYPE OF (ONEOF (open_path, edge_loop, oriented_path))
SUBTYPE OF (topological_representation_item);
  edge_list :  LIST [1:?] OF UNIQUE oriented_edge;
WHERE
  wr1 : path_head_to_tail(SELF);
END_ENTITY;
 
ENTITY pcurve
SUBTYPE OF (curve);
  basis_surface : surface;
  reference_to_curve : definitional_representation;
WHERE
  wr1 : SIZEOF(reference_to_curve\representation.items) = 1;
  wr2 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CURVE' IN TYPEOF(
    reference_to_curve\representation.items[1]);
  wr3 : reference_to_curve\representation.items[1]\
    geometric_representation_item.dim = 2;
END_ENTITY;
 
ENTITY person;
  id : identifier;
  last_name : OPTIONAL label;
  first_name : OPTIONAL label;
  middle_names : OPTIONAL  LIST [1:?] OF label;
  prefix_titles : OPTIONAL  LIST [1:?] OF label;
  suffix_titles : OPTIONAL  LIST [1:?] OF label;
WHERE
  wr1 : EXISTS(last_name) OR EXISTS(first_name);
END_ENTITY;
 
ENTITY person_and_organization;
  the_person : person;
  the_organization : organization;
DERIVE
  name : label := get_name_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY person_and_organization_address
SUBTYPE OF (organizational_address, personal_address);
  SELF\personal_address.people : SET [1:1] OF person;
  SELF\organizational_address.organizations : SET [1:1] OF organization;
WHERE
  wr1 : SIZEOF(QUERY(pao <* USEDIN(SELF\personal_address.people[1], 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PERSON_AND_ORGANIZATION.THE_PERSON'
    ) | pao.the_organization :=: SELF\organizational_address.organizations[1]))
     = 1;
END_ENTITY;
 
ENTITY person_and_organization_assignment ABSTRACT SUPERTYPE;
  assigned_person_and_organization : person_and_organization;
  role : person_and_organization_role;
END_ENTITY;
 
ENTITY person_and_organization_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY person_assignment ABSTRACT SUPERTYPE;
  assigned_person : person;
  role : person_role;
END_ENTITY;
 
ENTITY person_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY person_type;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY person_type_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_person_type : person_type;
END_ENTITY;
 
ENTITY person_type_definition;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  formation : person_type_definition_formation;
END_ENTITY;
 
ENTITY person_type_definition_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_person_type_definition : person_type_definition;
END_ENTITY;
 
ENTITY person_type_definition_formation;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  of_person_type : person_type;
END_ENTITY;
 
ENTITY person_type_definition_relationship;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  relating_person_type_definition : person_type_definition;
  related_person_type_definition : person_type_definition;
END_ENTITY;
 
ENTITY personal_address
SUBTYPE OF (address);
  people : SET [1:?] OF person;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY physical_breakdown_context
SUBTYPE OF (breakdown_context);
END_ENTITY;
 
ENTITY physical_element_usage
SUBTYPE OF (breakdown_element_usage);
END_ENTITY;
 
ENTITY placement
SUPERTYPE OF (ONEOF (axis1_placement, axis2_placement_2d, axis2_placement_3d))
SUBTYPE OF (geometric_representation_item);
  location : cartesian_point;
END_ENTITY;
 
ENTITY plane
SUBTYPE OF (elementary_surface);
END_ENTITY;
 
ENTITY plane_angle_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANE_ANGLE_UNIT' IN TYPEOF(
    SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY plane_angle_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY point
SUPERTYPE OF (ONEOF (cartesian_point, point_on_curve, point_on_surface, 
point_in_volume, point_replica, degenerate_pcurve))
SUBTYPE OF (geometric_representation_item);
END_ENTITY;
 
ENTITY point_in_volume
SUBTYPE OF (point);
  basis_volume : volume;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
  point_parameter_w : parameter_value;
END_ENTITY;
 
ENTITY point_on_curve
SUBTYPE OF (point);
  basis_curve : curve;
  point_parameter : parameter_value;
END_ENTITY;
 
ENTITY point_on_surface
SUBTYPE OF (point);
  basis_surface : surface;
  point_parameter_u : parameter_value;
  point_parameter_v : parameter_value;
END_ENTITY;
 
ENTITY point_replica
SUBTYPE OF (point);
  parent_pt : point;
  transformation : cartesian_transformation_operator;
WHERE
  wr1 : transformation.dim = parent_pt.dim;
  wr2 : acyclic_point_replica(SELF, parent_pt);
END_ENTITY;
 
ENTITY polar_point
SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates :  LIST [1:3] OF length_measure := [r * COS(
  theta), r * SIN(theta)];
WHERE
  wr1 : r >= 0.0;
END_ENTITY;
 
ENTITY poly_loop
SUBTYPE OF (loop, geometric_representation_item);
  polygon :  LIST [3:?] OF UNIQUE cartesian_point;
END_ENTITY;
 
ENTITY polygonal_area
SUBTYPE OF (primitive_2d);
  bounds :  LIST [3:?] OF UNIQUE cartesian_point;
END_ENTITY;
 
ENTITY polyline
SUBTYPE OF (bounded_curve);
  points :  LIST [2:?] OF cartesian_point;
END_ENTITY;
 
ENTITY position_in_organization;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY position_in_organization_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_position_in_organization : position_in_organization;
END_ENTITY;
 
ENTITY position_in_organization_relationship;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  relating_position_in_organization : position_in_organization;
  related_position_in_organization : position_in_organization;
END_ENTITY;
 
ENTITY position_in_organization_type;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY position_in_organization_type_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_position_in_organization_type : position_in_organization_type;
END_ENTITY;
 
ENTITY power_set;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  base : class;
  derived : class;
END_ENTITY;
 
ENTITY pre_defined_item;
  name : label;
END_ENTITY;
 
ENTITY precision_qualifier;
  precision_value : INTEGER;
END_ENTITY;
 
ENTITY primitive_2d
SUPERTYPE OF (ONEOF (circular_area, elliptic_area, rectangular_area, 
polygonal_area))
SUBTYPE OF (geometric_representation_item);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 2;
END_ENTITY;
 
ENTITY probability_generator ABSTRACT SUPERTYPE
SUBTYPE OF (representation);
END_ENTITY;
 
ENTITY process_or_process_relationship_effectivity
SUBTYPE OF (effectivity);
  effective_process_or_process_relationship : process_or_process_relationship;
END_ENTITY;
 
ENTITY process_product_association;
  name : label;
  description : text;
  defined_product : characterized_product_definition;
  process : product_definition_process;
END_ENTITY;
 
ENTITY process_property_association;
  name : label;
  description : text;
  process : property_process;
  property_or_shape : property_or_shape_select;
END_ENTITY;
 
ENTITY product;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  frame_of_reference : SET [1:?] OF product_context;
END_ENTITY;
 
ENTITY product_as_individual
ABSTRACT SUPERTYPE OF (ONEOF (product_as_planned, product_as_realized))
SUBTYPE OF (product_definition_formation);
END_ENTITY;
 
ENTITY product_as_planned
SUBTYPE OF (product_as_individual);
END_ENTITY;
 
ENTITY product_as_realized
SUBTYPE OF (product_as_individual);
END_ENTITY;
 
ENTITY product_category;
  name : label;
  description : OPTIONAL text;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY product_category_relationship;
  name : label;
  description : OPTIONAL text;
  category : product_category;
  sub_category : product_category;
WHERE
  wr1 : acyclic_product_category_relationship(SELF, [SELF.sub_category]);
END_ENTITY;
 
ENTITY product_concept;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  market_context : product_concept_context;
UNIQUE
  ur1 : id;
END_ENTITY;
 
ENTITY product_concept_context
SUBTYPE OF (application_context_element);
  market_segment_type : label;
END_ENTITY;
 
ENTITY product_concept_feature;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY product_concept_feature_association;
  name : label;
  description : OPTIONAL text;
  concept : product_concept;
  feature : product_concept_feature;
END_ENTITY;
 
ENTITY product_concept_relationship;
  name : label;
  description : OPTIONAL text;
  relating_product_concept : product_concept;
  related_product_concept : product_concept;
END_ENTITY;
 
ENTITY product_context
SUBTYPE OF (application_context_element);
  discipline_type : label;
END_ENTITY;
 
ENTITY product_definition;
  id : identifier;
  description : OPTIONAL text;
  formation : product_definition_formation;
  frame_of_reference : product_definition_context;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY product_definition_context
SUBTYPE OF (application_context_element);
  life_cycle_stage : label;
END_ENTITY;
 
ENTITY product_definition_context_association;
  definition : product_definition;
  frame_of_reference : product_definition_context;
  role : product_definition_context_role;
END_ENTITY;
 
ENTITY product_definition_context_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY product_definition_effectivity
SUBTYPE OF (effectivity);
  usage : product_definition_relationship;
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY_ASSIGNMENT.ASSIGNED_EFFECTIVITY'
    )) = 0;
END_ENTITY;
 
ENTITY product_definition_element_relationship
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY product_definition_formation;
  id : identifier;
  description : OPTIONAL text;
  of_product : product;
UNIQUE
  ur1 : id, of_product;
END_ENTITY;
 
ENTITY product_definition_formation_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition_formation : product_definition_formation;
  related_product_definition_formation : product_definition_formation;
END_ENTITY;
 
ENTITY product_definition_formation_with_specified_source
SUBTYPE OF (product_definition_formation);
  make_or_buy : source;
END_ENTITY;
 
ENTITY product_definition_group_assignment
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : 
  product_definition_element_relationship;
  items : SET [1:1] OF product_definition_or_product_definition_relationship;
END_ENTITY;
 
ENTITY product_definition_occurrence_relationship;
  name : label;
  description : OPTIONAL text;
  occurrence : product_definition;
  occurrence_usage : assembly_component_usage;
WHERE
  wr1 : occurrence_usage.relating_product_definition :<>: occurrence;
  wr2 : occurrence_usage.related_product_definition :<>: occurrence;
  wr3 : occurrence.formation :=: occurrence_usage.related_product_definition.
    formation;
END_ENTITY;
 
ENTITY product_definition_process
SUBTYPE OF (action);
  identification : identifier;
INVERSE
  product_definitions : SET [1:?] OF process_product_association FOR process;
END_ENTITY;
 
ENTITY product_definition_relationship
SUPERTYPE OF (ONEOF (breakdown_context, breakdown_element_usage, breakdown_of, 
in_zone, interface_connection, interface_definition_for, product_in_slot, 
slot_on_product));
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product_definition : product_definition;
  related_product_definition : product_definition;
END_ENTITY;
 
ENTITY product_definition_shape
SUBTYPE OF (property_definition);
UNIQUE
  ur1 : SELF\property_definition.definition;
WHERE
  wr1 : SIZEOF([
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_PRODUCT_DEFINITION'
    , 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_OBJECT'] * TYPEOF(
    SELF\property_definition.definition)) > 0;
END_ENTITY;
 
ENTITY product_definition_substitute;
  description : OPTIONAL text;
  context_relationship : product_definition_relationship;
  substitute_definition : product_definition;
DERIVE
  name : label := get_name_value(SELF);
WHERE
  wr1 : context_relationship.related_product_definition :<>: 
    substitute_definition;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY product_definition_usage
SUPERTYPE OF (ONEOF (make_from_usage_option, assembly_component_usage))
SUBTYPE OF (product_definition_relationship);
UNIQUE
  ur1 : SELF\product_definition_relationship.id, SELF\
    product_definition_relationship.relating_product_definition, SELF\
    product_definition_relationship.related_product_definition;
WHERE
  wr1 : acyclic_product_definition_relationship(SELF, [SELF\
    product_definition_relationship.related_product_definition], 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_USAGE');
END_ENTITY;
 
ENTITY product_definition_with_associated_documents
SUBTYPE OF (product_definition);
  documentation_ids : SET [1:?] OF document;
END_ENTITY;
 
ENTITY product_design_to_individual
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : product_as_individual;
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : product_definition_formation;
DERIVE
  individual_product : product_as_individual := SELF\
  product_definition_formation_relationship.
  related_product_definition_formation;
  product_version : product_definition_formation := SELF\
  product_definition_formation_relationship.
  relating_product_definition_formation;
END_ENTITY;
 
ENTITY product_group
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY product_group_attribute_assignment
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group_attributes;
  attributes : SET [1:1] OF attribute_select;
END_ENTITY;
 
ENTITY product_group_attribute_set
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group;
  product_group_attributes : SET [1:1] OF product_group_attributes;
END_ENTITY;
 
ENTITY product_group_attributes
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY product_group_context
SUBTYPE OF (descriptive_representation_item);
END_ENTITY;
 
ENTITY product_group_membership
SUBTYPE OF (group_assignment);
  member : product_select;
END_ENTITY;
 
ENTITY product_group_membership_rules
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group;
  product_group_rules : SET [1:1] OF product_group_rules;
END_ENTITY;
 
ENTITY product_group_purpose
SUBTYPE OF (descriptive_representation_item);
END_ENTITY;
 
ENTITY product_group_relationship
SUBTYPE OF (group_relationship);
END_ENTITY;
 
ENTITY product_group_rule
SUBTYPE OF (descriptive_representation_item);
END_ENTITY;
 
ENTITY product_group_rule_assignment
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : product_group_rules;
  product_group_rules : SET [1:?] OF product_group_rule;
END_ENTITY;
 
ENTITY product_group_rules
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY product_in_slot
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY product_material_composition_relationship
SUBTYPE OF (product_definition_relationship);
  class : label;
  constituent_amount : SET [1:?] OF measure_with_unit;
  composition_basis : label;
  determination_method : text;
END_ENTITY;
 
ENTITY product_planned_to_realized
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : product_as_planned;
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : product_as_realized;
DERIVE
  planned_product : product_as_planned := SELF\
  product_definition_formation_relationship.
  relating_product_definition_formation;
  realized_product : product_as_realized := SELF\
  product_definition_formation_relationship.
  related_product_definition_formation;
END_ENTITY;
 
ENTITY product_related_product_category
SUBTYPE OF (product_category);
  products : SET [1:?] OF product;
END_ENTITY;
 
ENTITY product_relationship;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  relating_product : product;
  related_product : product;
END_ENTITY;
 
ENTITY promissory_usage_occurrence
SUBTYPE OF (assembly_component_usage);
END_ENTITY;
 
ENTITY proper_subset;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  subset : class;
  superset : class;
END_ENTITY;
 
ENTITY property_definition;
  name : label;
  description : OPTIONAL text;
  definition : characterized_definition;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY property_definition_relationship;
  name : label;
  description : text;
  relating_property_definition : property_definition;
  related_property_definition : property_definition;
END_ENTITY;
 
ENTITY property_definition_representation;
  definition : represented_definition;
  used_representation : representation;
DERIVE
  description : text := get_description_value(SELF);
  name : label := get_name_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM')) <= 1;
END_ENTITY;
 
ENTITY property_process
SUBTYPE OF (action);
  identification : identifier;
INVERSE
  properties : SET [1:?] OF process_property_association FOR process;
END_ENTITY;
 
ENTITY pyramid_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;
 
ENTITY qualification_type;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY qualification_type_assignment ABSTRACT SUPERTYPE;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  role : OPTIONAL STRING;
  assigned_qualification_type : qualification_type;
END_ENTITY;
 
ENTITY qualification_type_relationship;
  id : STRING;
  name : STRING;
  description : OPTIONAL STRING;
  relating_qualification_type : qualification_type;
  related_qualification_type : qualification_type;
END_ENTITY;
 
ENTITY qualified_representation_item
SUBTYPE OF (representation_item);
  qualifiers : SET [1:?] OF value_qualifier;
WHERE
  wr1 : SIZEOF(QUERY(temp <* qualifiers | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRECISION_QUALIFIER' IN TYPEOF(
    temp))) < 2;
END_ENTITY;
 
ENTITY qualitative_uncertainty
SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : text;
END_ENTITY;
 
ENTITY quantified_assembly_component_usage
SUBTYPE OF (assembly_component_usage);
  quantity : measure_with_unit;
WHERE
  wr1 : NOT ('NUMBER' IN TYPEOF(quantity.value_component)) OR (quantity.
    value_component > 0);
END_ENTITY;
 
ENTITY quasi_uniform_curve
SUBTYPE OF (b_spline_curve);
END_ENTITY;
 
ENTITY quasi_uniform_surface
SUBTYPE OF (b_spline_surface);
END_ENTITY;
 
ENTITY quasi_uniform_volume
SUBTYPE OF (b_spline_volume);
END_ENTITY;
 
ENTITY ratio_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RATIO_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY ratio_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY rational_b_spline_curve
SUBTYPE OF (b_spline_curve);
  weights_data :  LIST [2:?] OF REAL;
DERIVE
  weights :  ARRAY [0 : upper_index_on_control_points] OF REAL := list_to_array
  (weights_data, 0, upper_index_on_control_points);
WHERE
  wr1 : SIZEOF(weights_data) = SIZEOF(SELF\b_spline_curve.control_points_list);
  wr2 : curve_weights_positive(SELF);
END_ENTITY;
 
ENTITY rational_b_spline_surface
SUBTYPE OF (b_spline_surface);
  weights_data :  LIST [2:?] OF  LIST [2:?] OF REAL;
DERIVE
  weights :  ARRAY [0 : u_upper] OF  ARRAY [0 : v_upper] OF REAL := 
  make_array_of_array(weights_data, 0, u_upper, 0, v_upper);
WHERE
  wr1 : (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_surface.
    control_points_list)) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\
    b_spline_surface.control_points_list[1]));
  wr2 : surface_weights_positive(SELF);
END_ENTITY;
 
ENTITY rational_b_spline_volume
SUBTYPE OF (b_spline_volume);
  weights_data :  LIST [2:?] OF  LIST [2:?] OF  LIST [2:?] OF REAL;
DERIVE
  weights :  ARRAY [0 : u_upper] OF  ARRAY [0 : v_upper] OF  ARRAY [0 : w_upper
  ] OF REAL := make_array_of_array_of_array(weights_data, 0, u_upper, 0, 
  v_upper, 0, w_upper);
WHERE
  wr1 : (SIZEOF(weights_data) = SIZEOF(SELF\b_spline_volume.control_points_list
    )) AND (SIZEOF(weights_data[1]) = SIZEOF(SELF\b_spline_volume.
    control_points_list[1])) AND (SIZEOF(weights_data[1][1]) = SIZEOF(SELF\
    b_spline_volume.control_points_list[1][1]));
  wr2 : volume_weights_positive(SELF);
END_ENTITY;
 
ENTITY rectangle_domain
SUBTYPE OF (founded_item);
  corner : cartesian_point;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
WHERE
  wr1 : SIZEOF(QUERY(item <* USEDIN(SELF, '') | NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RECTANGLED_HALF_SPACE' IN TYPEOF(
    item)))) = 0;
END_ENTITY;
 
ENTITY rectangled_half_space
SUBTYPE OF (half_space_2d);
  enclosure : rectangle_domain;
END_ENTITY;
 
ENTITY rectangular_area
SUBTYPE OF (primitive_2d);
  position : axis2_placement_2d;
  x : positive_length_measure;
  y : positive_length_measure;
END_ENTITY;
 
ENTITY rectangular_composite_surface
SUBTYPE OF (bounded_surface);
  segments :  LIST [1:?] OF  LIST [1:?] OF surface_patch;
DERIVE
  n_u : INTEGER := SIZEOF(segments);
  n_v : INTEGER := SIZEOF(segments[1]);
WHERE
  wr1 : SIZEOF(QUERY(s <* segments | n_v <> SIZEOF(s))) = 0;
  wr2 : constraints_rectangular_composite_surface(SELF);
END_ENTITY;
 
ENTITY rectangular_pyramid
SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  xlength : positive_length_measure;
  ylength : positive_length_measure;
  height : positive_length_measure;
END_ENTITY;
 
ENTITY rectangular_trimmed_surface
SUBTYPE OF (bounded_surface);
  basis_surface : surface;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  usense : BOOLEAN;
  vsense : BOOLEAN;
WHERE
  wr1 : u1 <> u2;
  wr2 : v1 <> v2;
  wr3 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELEMENTARY_SURFACE' IN TYPEOF
    (basis_surface)) AND NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANE' 
    IN TYPEOF(basis_surface)) OR (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_OF_REVOLUTION' IN TYPEOF(
    basis_surface)) OR (usense = (u2 > u1));
  wr4 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SPHERICAL_SURFACE' IN TYPEOF(
    basis_surface)) OR (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TOROIDAL_SURFACE' IN TYPEOF(
    basis_surface)) OR (vsense = (v2 > v1));
END_ENTITY;
 
ENTITY relationship_condition;
  name : label;
  applicable_relationships : SET [1:?] OF relationship_with_condition;
  condition_description : text;
END_ENTITY;
 
ENTITY relative_event_occurrence
SUBTYPE OF (event_occurrence);
  base_event : event_occurrence;
  offset : time_measure_with_unit;
END_ENTITY;
 
ENTITY reparametrised_composite_curve_segment
SUBTYPE OF (composite_curve_segment);
  param_length : parameter_value;
WHERE
  wr1 : param_length > 0.0;
END_ENTITY;
 
ENTITY replacement_relationship
SUBTYPE OF (action_relationship);
WHERE
  wr1 : acyclic_action_relationship(SELF, [SELF\action_relationship.
    related_action], 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPLACEMENT_RELATIONSHIP');
END_ENTITY;
 
ENTITY representation;
  name : label;
  items : SET [1:?] OF representation_item;
  context_of_items : representation_context;
DERIVE
  id : identifier := get_id_value(SELF);
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
  wr2 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY representation_context;
  context_identifier : identifier;
  context_type : text;
INVERSE
  representations_in_context : SET [1:?] OF representation FOR context_of_items
  ;
END_ENTITY;
 
ENTITY representation_item;
  name : label;
WHERE
  wr1 : SIZEOF(using_representations(SELF)) > 0;
END_ENTITY;
 
ENTITY representation_item_relationship;
  name : label;
  description : OPTIONAL text;
  relating_representation_item : representation_item;
  related_representation_item : representation_item;
END_ENTITY;
 
ENTITY representation_map;
  mapping_origin : representation_item;
  mapped_representation : representation;
INVERSE
  map_usage : SET [1:?] OF mapped_item FOR mapping_source;
WHERE
  wr1 : item_in_context(SELF.mapping_origin, SELF.mapped_representation.
    context_of_items);
END_ENTITY;
 
ENTITY representation_relationship;
  name : label;
  description : OPTIONAL text;
  rep_1 : representation;
  rep_2 : representation;
END_ENTITY;
 
ENTITY representation_relationship_with_transformation
SUBTYPE OF (representation_relationship);
  transformation_operator : transformation;
WHERE
  wr1 : SELF\representation_relationship.rep_1.context_of_items :<>: SELF\
    representation_relationship.rep_2.context_of_items;
END_ENTITY;
 
ENTITY requirement_assigned_object
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_assignment;
  items : SET [1:1] OF requirement_assigned_item;
END_ENTITY;
 
ENTITY requirement_assignment
SUBTYPE OF (characterized_object, group);
END_ENTITY;
 
ENTITY requirement_for_action_resource
SUBTYPE OF (action_resource_requirement);
  resources : SET [1:?] OF action_resource;
END_ENTITY;
 
ENTITY requirement_source
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY resource_property;
  name : label;
  description : text;
  resource : characterized_resource_definition;
END_ENTITY;
 
ENTITY resource_property_relationship;
  name : label;
  description : text;
  relating_resource_property : resource_property;
  related_resource_property : resource_property;
WHERE
  wr1 : relating_resource_property :<>: related_resource_property;
END_ENTITY;
 
ENTITY resource_property_representation;
  name : label;
  description : text;
  property : resource_property;
  representation : representation;
END_ENTITY;
 
ENTITY resource_requirement_type;
  name : label;
  description : text;
END_ENTITY;
 
ENTITY resource_requirement_type_relationship;
  name : label;
  description : text;
  relating_requirement_type : resource_requirement_type;
  related_requirement_type : resource_requirement_type;
WHERE
  wr1 : relating_requirement_type :<>: related_requirement_type;
END_ENTITY;
 
ENTITY revolved_area_solid
SUBTYPE OF (swept_area_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')||geometric_representation_item()
  ||curve()||line(axis.location, representation_item('')||
  geometric_representation_item()||vector(axis.z, 1.0));
END_ENTITY;
 
ENTITY revolved_face_solid
SUBTYPE OF (swept_face_solid);
  axis : axis1_placement;
  angle : plane_angle_measure;
DERIVE
  axis_line : line := representation_item('')||geometric_representation_item()
  ||curve()||line(axis.location, representation_item('')||
  geometric_representation_item()||vector(axis.z, 1.0));
END_ENTITY;
 
ENTITY right_angular_wedge
SUBTYPE OF (geometric_representation_item);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  wr1 : (0.0 <= ltx) AND (ltx < x);
END_ENTITY;
 
ENTITY right_circular_cone
SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : length_measure;
  semi_angle : plane_angle_measure;
WHERE
  wr1 : radius >= 0.0;
END_ENTITY;
 
ENTITY right_circular_cylinder
SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  height : positive_length_measure;
  radius : positive_length_measure;
END_ENTITY;
 
ENTITY right_to_usage_association
SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.related_method : information_right;
  SELF\action_method_relationship.relating_method : information_usage_right;
DERIVE
  right_applied : information_right := SELF\action_method_relationship.
  related_method;
  right_usage : information_usage_right := SELF\action_method_relationship.
  relating_method;
END_ENTITY;
 
ENTITY role_association;
  role : object_role;
  item_with_role : role_select;
END_ENTITY;
 
ENTITY same_membership;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  set_1 : class;
  set_2 : class;
END_ENTITY;
 
ENTITY seam_curve
SUBTYPE OF (surface_curve);
WHERE
  wr1 : SIZEOF(SELF\surface_curve.associated_geometry) = 2;
  wr2 : associated_surface(SELF\surface_curve.associated_geometry[1]) = 
    associated_surface(SELF\surface_curve.associated_geometry[2]);
  wr3 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(SELF\
    surface_curve.associated_geometry[1]);
  wr4 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(SELF\
    surface_curve.associated_geometry[2]);
END_ENTITY;
 
ENTITY seam_edge
SUBTYPE OF (oriented_edge);
  pcurve_reference : pcurve;
WHERE
  wr1 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EDGE_CURVE' IN TYPEOF(
    edge_element)) AND ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SEAM_CURVE' IN
     TYPEOF(edge_element\edge_curve.edge_geometry));
  wr2 : pcurve_reference IN edge_element\edge_curve.edge_geometry\surface_curve
    .associated_geometry;
END_ENTITY;
 
ENTITY sectioned_spine
SUBTYPE OF (geometric_curve_set);
  cross_sections :  LIST [2:?] OF curve;
  spine_points :  LIST [2:?] OF point;
WHERE
  wr1 : SIZEOF(SELF\geometric_set.elements) = 1;
  wr2 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CURVE' IN TYPEOF(SELF\
    geometric_set.elements[1]);
  wr3 : SIZEOF(cross_sections) = SIZEOF(spine_points);
  wr4 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;
 
ENTITY security_classification;
  name : label;
  purpose : text;
  security_level : security_classification_level;
END_ENTITY;
 
ENTITY security_classification_assignment ABSTRACT SUPERTYPE;
  assigned_security_classification : security_classification;
DERIVE
  role : object_role := get_role(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE'))
     <= 1;
END_ENTITY;
 
ENTITY security_classification_level;
  name : label;
END_ENTITY;
 
ENTITY selected_item
SUBTYPE OF (class);
END_ENTITY;
 
ENTITY selected_item_assignment;
  assigned_class : selected_item;
  item : selected_item_select;
END_ENTITY;
 
ENTITY selected_items_assignment_in_context_group
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : selected_items_context_group;
  selected_item_assignment : SET [1:1] OF selected_item_assignment;
END_ENTITY;
 
ENTITY selected_items_context_group
SUBTYPE OF (group);
END_ENTITY;
 
ENTITY selected_items_context_group_to_context
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : selected_items_context_group;
  item_context : SET [1:?] OF selected_item_context_items;
END_ENTITY;
 
ENTITY sequential_method
SUBTYPE OF (serial_action_method);
  sequence_position : count_measure;
END_ENTITY;
 
ENTITY serial_action_method
SUBTYPE OF (action_method_relationship);
END_ENTITY;
 
ENTITY serial_numbered_effectivity
SUBTYPE OF (effectivity);
  effectivity_start_id : identifier;
  effectivity_end_id : OPTIONAL identifier;
END_ENTITY;
 
ENTITY shape_aspect;
  name : label;
  description : OPTIONAL text;
  of_shape : product_definition_shape;
  product_definitional : LOGICAL;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY shape_aspect_relationship;
  name : label;
  description : OPTIONAL text;
  relating_shape_aspect : shape_aspect;
  related_shape_aspect : shape_aspect;
DERIVE
  id : identifier := get_id_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM'))
     <= 1;
END_ENTITY;
 
ENTITY shape_definition_representation
SUBTYPE OF (property_definition_representation);
WHERE
  wr1 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN 
    TYPEOF(SELF.definition)) OR (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_DEFINITION' IN TYPEOF(SELF.
    definition.definition));
  wr2 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION' IN 
    TYPEOF(SELF.used_representation);
END_ENTITY;
 
ENTITY shape_representation
SUBTYPE OF (representation);
END_ENTITY;
 
ENTITY shape_representation_relationship
SUBTYPE OF (representation_relationship);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION' IN 
    TYPEOF(SELF\representation_relationship.rep_1) + TYPEOF(SELF\
    representation_relationship.rep_2);
END_ENTITY;
 
ENTITY shell_based_surface_model
SUBTYPE OF (geometric_representation_item);
  sbsm_boundary : SET [1:?] OF shell;
WHERE
  wr1 : constraints_geometry_shell_based_surface_model(SELF);
END_ENTITY;
 
ENTITY shell_based_wireframe_model
SUBTYPE OF (geometric_representation_item);
  sbwm_boundary : SET [1:?] OF shell;
WHERE
  wr1 : constraints_geometry_shell_based_wireframe_model(SELF);
END_ENTITY;
 
ENTITY si_unit
SUBTYPE OF (named_unit);
  prefix : OPTIONAL si_prefix;
  name : si_unit_name;
DERIVE
  SELF\named_unit.dimensions : dimensional_exponents := dimensions_for_si_unit(
  name);
END_ENTITY;
 
ENTITY simultaneous_task_method
SUBTYPE OF (concurrent_task_method);
END_ENTITY;
 
ENTITY slot_as_planned
SUBTYPE OF (product_definition_formation);
END_ENTITY;
 
ENTITY slot_as_realized
SUBTYPE OF (product_definition_formation);
END_ENTITY;
 
ENTITY slot_design
SUBTYPE OF (product_definition_formation);
END_ENTITY;
 
ENTITY slot_design_to_planned
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : slot_as_planned;
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : slot_design;
WHERE
  wr1 : SELF.relating_product_definition_formation.of_product :=: SELF.
    related_product_definition_formation.of_product;
END_ENTITY;
 
ENTITY slot_design_to_realized
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : slot_as_realized;
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : slot_design;
WHERE
  wr1 : SELF.relating_product_definition_formation.of_product :=: SELF.
    related_product_definition_formation.of_product;
END_ENTITY;
 
ENTITY slot_on_product
SUBTYPE OF (product_definition_relationship);
END_ENTITY;
 
ENTITY slot_planned_to_realized
SUBTYPE OF (product_definition_formation_relationship);
  SELF\product_definition_formation_relationship.
  related_product_definition_formation : slot_as_realized;
  SELF\product_definition_formation_relationship.
  relating_product_definition_formation : slot_as_planned;
WHERE
  wr1 : SELF.relating_product_definition_formation.of_product :=: SELF.
    related_product_definition_formation.of_product;
END_ENTITY;
 
ENTITY solid_angle_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SOLID_ANGLE_UNIT' IN TYPEOF(
    SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY solid_angle_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY solid_model
SUPERTYPE OF (ONEOF (csg_solid, manifold_solid_brep, swept_face_solid, 
swept_area_solid, swept_disk_solid, solid_replica, brep_2d, trimmed_volume))
SUBTYPE OF (geometric_representation_item);
END_ENTITY;
 
ENTITY solid_replica
SUBTYPE OF (solid_model);
  parent_solid : solid_model;
  transformation : cartesian_transformation_operator_3d;
WHERE
  wr1 : acyclic_solid_replica(SELF, parent_solid);
  wr2 : parent_solid\geometric_representation_item.dim = 3;
END_ENTITY;
 
ENTITY source_for_requirement
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET [1:1] OF requirement_source_item;
END_ENTITY;
 
ENTITY sourced_requirement
SUBTYPE OF (group_assignment);
  SELF\group_assignment.assigned_group : requirement_source;
  items : SET [1:1] OF product_definition;
END_ENTITY;
 
ENTITY specified_higher_usage_occurrence
SUBTYPE OF (assembly_component_usage);
  upper_usage : assembly_component_usage;
  next_usage : next_assembly_usage_occurrence;
UNIQUE
  ur1 : upper_usage, next_usage;
WHERE
  wr1 : SELF :<>: upper_usage;
  wr2 : SELF\product_definition_relationship.relating_product_definition :=: 
    upper_usage.relating_product_definition;
  wr3 : SELF\product_definition_relationship.related_product_definition :=: 
    next_usage.related_product_definition;
  wr4 : (upper_usage.related_product_definition :=: next_usage.
    relating_product_definition) OR (SIZEOF(QUERY(pdr <* USEDIN(upper_usage.
    related_product_definition, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'
    ) | pdr.relating_product_definition :=: next_usage.
    relating_product_definition)) = 1);
  wr5 : SIZEOF([
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NEXT_ASSEMBLY_USAGE_OCCURRENCE', 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SPECIFIED_HIGHER_USAGE_OCCURRENCE'
    ] * TYPEOF(upper_usage)) = 1;
END_ENTITY;
 
ENTITY sphere
SUBTYPE OF (geometric_representation_item);
  radius : positive_length_measure;
  centre : point;
END_ENTITY;
 
ENTITY spherical_point
SUBTYPE OF (cartesian_point);
  r : length_measure;
  theta : plane_angle_measure;
  phi : plane_angle_measure;
DERIVE
  SELF\cartesian_point.coordinates :  LIST [1:3] OF length_measure := [r * SIN(
  theta) * COS(phi), r * SIN(theta) * SIN(phi), r * COS(theta)];
WHERE
  wr1 : r >= 0.0;
END_ENTITY;
 
ENTITY spherical_surface
SUBTYPE OF (elementary_surface);
  radius : positive_length_measure;
END_ENTITY;
 
ENTITY spherical_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  radius : positive_length_measure;
END_ENTITY;
 
ENTITY standard_uncertainty
SUPERTYPE OF (expanded_uncertainty)
SUBTYPE OF (uncertainty_qualifier);
  uncertainty_value : REAL;
END_ENTITY;
 
ENTITY state_characterized_object
SUBTYPE OF (characterized_object, state_type);
END_ENTITY;
 
ENTITY state_observed;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY state_observed_characterized_object
SUBTYPE OF (characterized_object, state_observed);
END_ENTITY;
 
ENTITY state_observed_relationship;
  name : STRING;
  description : OPTIONAL STRING;
  relating_state_observed : SET [1:?] OF state_observed;
  related_state_observed : SET [1:?] OF state_observed;
  role : STRING;
END_ENTITY;
 
ENTITY state_observed_relationship_characterized_object
SUBTYPE OF (characterized_object, state_observed_relationship);
END_ENTITY;
 
ENTITY state_predicted
SUBTYPE OF (state_observed);
END_ENTITY;
 
ENTITY state_relationship_characterized_object
SUBTYPE OF (characterized_object, state_type_relationship);
END_ENTITY;
 
ENTITY state_role;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY state_type;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY state_type_relationship;
  name : STRING;
  description : OPTIONAL STRING;
  relating_state_type : SET [1:?] OF state_type;
  related_state_type : SET [1:?] OF state_type;
  role : STRING;
END_ENTITY;
 
ENTITY state_type_role;
  name : STRING;
  description : OPTIONAL STRING;
END_ENTITY;
 
ENTITY structured_message
SUBTYPE OF (product);
END_ENTITY;
 
ENTITY subedge
SUBTYPE OF (edge);
  parent_edge : edge;
END_ENTITY;
 
ENTITY subface
SUBTYPE OF (face);
  parent_face : face;
WHERE
  wr1 : NOT mixed_loop_type_set(list_to_set(list_face_loops(SELF)) + 
    list_to_set(list_face_loops(parent_face)));
END_ENTITY;
 
ENTITY subset;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  subset : class;
  superset : class;
END_ENTITY;
 
ENTITY surface
SUPERTYPE OF (ONEOF (elementary_surface, swept_surface, bounded_surface, 
offset_surface, surface_replica))
SUBTYPE OF (geometric_representation_item);
END_ENTITY;
 
ENTITY surface_curve
SUPERTYPE OF (ONEOF (intersection_curve, seam_curve) ANDOR 
bounded_surface_curve)
SUBTYPE OF (curve);
  curve_3d : curve;
  associated_geometry :  LIST [1:2] OF pcurve_or_surface;
  master_representation : preferred_surface_curve_representation;
DERIVE
  basis_surface : SET [1:2] OF surface := get_basis_surface(SELF);
WHERE
  wr1 : curve_3d.dim = 3;
  wr2 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(
    associated_geometry[1])) OR (master_representation <> pcurve_s1);
  wr3 : ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(
    associated_geometry[2])) OR (master_representation <> pcurve_s2);
  wr4 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(
    curve_3d));
END_ENTITY;
 
ENTITY surface_curve_swept_area_solid
SUBTYPE OF (swept_area_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_CURVE' IN TYPEOF(
    directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface)
    ;
END_ENTITY;
 
ENTITY surface_curve_swept_face_solid
SUBTYPE OF (swept_face_solid);
  directrix : curve;
  start_param : REAL;
  end_param : REAL;
  reference_surface : surface;
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_CURVE' IN TYPEOF(
    directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface)
    ;
END_ENTITY;
 
ENTITY surface_curve_swept_surface
SUBTYPE OF (swept_surface);
  directrix : curve;
  reference_surface : surface;
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_CURVE' IN TYPEOF(
    directrix)) OR (reference_surface IN directrix\surface_curve.basis_surface)
    ;
END_ENTITY;
 
ENTITY surface_of_linear_extrusion
SUBTYPE OF (swept_surface);
  extrusion_axis : vector;
END_ENTITY;
 
ENTITY surface_of_revolution
SUBTYPE OF (swept_surface);
  axis_position : axis1_placement;
DERIVE
  axis_line : line := representation_item('')||geometric_representation_item()
  ||curve()||line(axis_position.location, representation_item('')||
  geometric_representation_item()||vector(axis_position.z, 1.0));
END_ENTITY;
 
ENTITY surface_patch
SUBTYPE OF (founded_item);
  parent_surface : bounded_surface;
  u_transition : transition_code;
  v_transition : transition_code;
  u_sense : BOOLEAN;
  v_sense : BOOLEAN;
INVERSE
  using_surfaces : BAG [1:?] OF rectangular_composite_surface FOR segments;
WHERE
  wr1 : NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CURVE_BOUNDED_SURFACE' IN
     TYPEOF(parent_surface));
END_ENTITY;
 
ENTITY surface_replica
SUBTYPE OF (surface);
  parent_surface : surface;
  transformation : cartesian_transformation_operator_3d;
WHERE
  wr1 : acyclic_surface_replica(SELF, parent_surface);
END_ENTITY;
 
ENTITY swept_area_solid
SUPERTYPE OF (ONEOF (revolved_area_solid, extruded_area_solid, 
surface_curve_swept_area_solid))
SUBTYPE OF (solid_model);
  swept_area : curve_bounded_surface;
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANE' IN TYPEOF(swept_area.
    basis_surface);
END_ENTITY;
 
ENTITY swept_disk_solid
SUBTYPE OF (solid_model);
  directrix : curve;
  radius : positive_length_measure;
  inner_radius : OPTIONAL positive_length_measure;
  start_param : REAL;
  end_param : REAL;
WHERE
  wr1 : directrix.dim = 3;
  wr2 : NOT EXISTS(inner_radius) OR (radius > inner_radius);
END_ENTITY;
 
ENTITY swept_face_solid
SUPERTYPE OF (ONEOF (extruded_face_solid, revolved_face_solid, 
surface_curve_swept_face_solid))
SUBTYPE OF (solid_model);
  swept_face : face_surface;
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANE' IN TYPEOF(swept_face.
    face_geometry);
END_ENTITY;
 
ENTITY swept_surface
SUPERTYPE OF (ONEOF (surface_of_linear_extrusion, surface_of_revolution, 
surface_curve_swept_surface, fixed_reference_swept_surface))
SUBTYPE OF (surface);
  swept_curve : curve;
END_ENTITY;
 
ENTITY system_breakdown_context
SUBTYPE OF (breakdown_context);
END_ENTITY;
 
ENTITY system_element_usage
SUBTYPE OF (breakdown_element_usage);
END_ENTITY;
 
ENTITY task
SUBTYPE OF (action_method);
END_ENTITY;
 
ENTITY task_invocation
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY task_method
SUPERTYPE OF (ONEOF (advisory_task_method, concurrent_task_method, end_task, 
exit_loop, looping_method, task_invocation, task_method_sequence, task_step))
SUBTYPE OF (action_method);
END_ENTITY;
 
ENTITY task_method_sequence
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY task_result
SUBTYPE OF (action_method);
END_ENTITY;
 
ENTITY task_step
SUBTYPE OF (task_method);
END_ENTITY;
 
ENTITY tetrahedron
SUBTYPE OF (faceted_primitive);
WHERE
  wr1 : SIZEOF(points) = 4;
  wr2 : above_plane(points[1], points[2], points[3], points[4]) <> 0.0;
END_ENTITY;
 
ENTITY tetrahedron_volume
SUBTYPE OF (volume);
  point_1 : cartesian_point;
  point_2 : cartesian_point;
  point_3 : cartesian_point;
  point_4 : cartesian_point;
WHERE
  wr1 : point_1.dim = 3;
  wr2 : above_plane(point_1, point_2, point_3, point_4) <> 0.0;
END_ENTITY;
 
ENTITY thermodynamic_temperature_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.THERMODYNAMIC_TEMPERATURE_UNIT' IN
     TYPEOF(SELF\measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY thermodynamic_temperature_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 1.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY time_assignment ABSTRACT SUPERTYPE;
  assigned_time : local_time;
  role : time_role;
END_ENTITY;
 
ENTITY time_interval;
  id : identifier;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY time_interval_assignment ABSTRACT SUPERTYPE;
  assigned_time_interval : time_interval;
  role : time_interval_role;
END_ENTITY;
 
ENTITY time_interval_based_effectivity
SUBTYPE OF (effectivity);
  effectivity_period : time_interval;
END_ENTITY;
 
ENTITY time_interval_relationship;
  name : label;
  description : OPTIONAL text;
  relating_time_interval : time_interval;
  related_time_interval : time_interval;
END_ENTITY;
 
ENTITY time_interval_role;
  name : label;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY time_interval_with_bounds
SUBTYPE OF (time_interval);
  primary_bound : OPTIONAL date_time_or_event_occurrence;
  secondary_bound : OPTIONAL date_time_or_event_occurrence;
  duration : OPTIONAL time_measure_with_unit;
WHERE
  wr1 : NOT (EXISTS(secondary_bound) AND EXISTS(duration));
  wr2 : EXISTS(primary_bound) OR EXISTS(secondary_bound);
END_ENTITY;
 
ENTITY time_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY time_role;
  name : label;
DERIVE
  description : text := get_description_value(SELF);
WHERE
  wr1 : SIZEOF(USEDIN(SELF, 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
    )) <= 1;
END_ENTITY;
 
ENTITY time_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 0.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 1.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY topological_representation_item
SUPERTYPE OF (ONEOF (vertex, edge, face_bound, face, vertex_shell, wire_shell, 
connected_edge_set, connected_face_set, loop ANDOR path))
SUBTYPE OF (representation_item);
END_ENTITY;
 
ENTITY toroidal_surface
SUBTYPE OF (elementary_surface);
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
END_ENTITY;
 
ENTITY toroidal_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  wr1 : minor_radius < major_radius;
END_ENTITY;
 
ENTITY torus
SUBTYPE OF (geometric_representation_item);
  position : axis1_placement;
  major_radius : positive_length_measure;
  minor_radius : positive_length_measure;
WHERE
  wr1 : major_radius > minor_radius;
END_ENTITY;
 
ENTITY trimmed_curve
SUBTYPE OF (bounded_curve);
  basis_curve : curve;
  trim_1 : SET [1:2] OF trimming_select;
  trim_2 : SET [1:2] OF trimming_select;
  sense_agreement : BOOLEAN;
  master_representation : trimming_preference;
WHERE
  wr1 : (HIINDEX(trim_1) = 1) OR (TYPEOF(trim_1[1]) <> TYPEOF(trim_1[2]));
  wr2 : (HIINDEX(trim_2) = 1) OR (TYPEOF(trim_2[1]) <> TYPEOF(trim_2[2]));
END_ENTITY;
 
ENTITY trimmed_volume
SUBTYPE OF (solid_model);
  basis_volume : volume;
  u1 : parameter_value;
  u2 : parameter_value;
  v1 : parameter_value;
  v2 : parameter_value;
  w1 : parameter_value;
  w2 : parameter_value;
WHERE
  wr1 : u1 <> u2;
  wr2 : v1 <> v2;
  wr3 : w1 <> w2;
END_ENTITY;
 
ENTITY type_qualifier;
  name : label;
END_ENTITY;
 
ENTITY uncertainty_assigned_representation
SUBTYPE OF (representation);
  uncertainty : SET [1:?] OF uncertainty_measure_with_unit;
END_ENTITY;
 
ENTITY uncertainty_measure_with_unit
SUBTYPE OF (measure_with_unit);
  name : label;
  description : OPTIONAL text;
WHERE
  wr1 : valid_measure_value(SELF\measure_with_unit.value_component);
END_ENTITY;
 
ENTITY uncertainty_qualifier
SUPERTYPE OF (ONEOF (standard_uncertainty, qualitative_uncertainty));
  measure_name : label;
  description : text;
END_ENTITY;
 
ENTITY uniform_curve
SUBTYPE OF (b_spline_curve);
END_ENTITY;
 
ENTITY uniform_surface
SUBTYPE OF (b_spline_surface);
END_ENTITY;
 
ENTITY uniform_volume
SUBTYPE OF (b_spline_volume);
END_ENTITY;
 
ENTITY union;
  id : identifier;
  name : label;
  description : OPTIONAL text;
  operand : SET [2:?] OF class;
  resultant : class;
END_ENTITY;
 
ENTITY usage_association
SUBTYPE OF (action_method_relationship);
  SELF\action_method_relationship.related_method : information_usage_right;
  SELF\action_method_relationship.relating_method : information_usage_right;
DERIVE
  related : information_usage_right := SELF\action_method_relationship.
  related_method;
  relating : information_usage_right := SELF\action_method_relationship.
  relating_method;
END_ENTITY;
 
ENTITY value_range
SUBTYPE OF (compound_representation_item);
WHERE
  wr1 : ('value_with_unit_mim.' + 'SET_REPRESENTATION_ITEM' IN TYPEOF(
    item_element)) AND value_range_wr1(item_element);
  wr2 : value_range_wr2(item_element);
  wr3 : value_range_wr3(item_element);
END_ENTITY;
 
ENTITY value_representation_item
SUBTYPE OF (representation_item);
  value_component : measure_value;
WHERE
  wr1 : SIZEOF(QUERY(rep <* using_representations(SELF) | NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GLOBAL_UNIT_ASSIGNED_CONTEXT' IN 
    TYPEOF(rep.context_of_items)))) = 0;
END_ENTITY;
 
ENTITY vector
SUBTYPE OF (geometric_representation_item);
  orientation : direction;
  magnitude : length_measure;
WHERE
  wr1 : magnitude >= 0.0;
END_ENTITY;
 
ENTITY versioned_action_request;
  id : identifier;
  version : label;
  purpose : text;
  description : OPTIONAL text;
END_ENTITY;
 
ENTITY vertex
SUBTYPE OF (topological_representation_item);
END_ENTITY;
 
ENTITY vertex_loop
SUBTYPE OF (loop);
  loop_vertex : vertex;
END_ENTITY;
 
ENTITY vertex_point
SUBTYPE OF (vertex, geometric_representation_item);
  vertex_geometry : point;
END_ENTITY;
 
ENTITY vertex_shell
SUBTYPE OF (topological_representation_item);
  vertex_shell_extent : vertex_loop;
END_ENTITY;
 
ENTITY volume
SUPERTYPE OF (ONEOF (block_volume, wedge_volume, spherical_volume, 
cylindrical_volume, eccentric_conical_volume, toroidal_volume, pyramid_volume, 
b_spline_volume, ellipsoid_volume, tetrahedron_volume, hexahedron_volume))
SUBTYPE OF (geometric_representation_item);
WHERE
  wr1 : SELF\geometric_representation_item.dim = 3;
END_ENTITY;
 
ENTITY volume_measure_with_unit
SUBTYPE OF (measure_with_unit);
WHERE
  wr1 : 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VOLUME_UNIT' IN TYPEOF(SELF\
    measure_with_unit.unit_component);
END_ENTITY;
 
ENTITY volume_unit
SUBTYPE OF (named_unit);
WHERE
  wr1 : (SELF\named_unit.dimensions.length_exponent = 3.0) AND (SELF\named_unit
    .dimensions.mass_exponent = 0.0) AND (SELF\named_unit.dimensions.
    time_exponent = 0.0) AND (SELF\named_unit.dimensions.
    electric_current_exponent = 0.0) AND (SELF\named_unit.dimensions.
    thermodynamic_temperature_exponent = 0.0) AND (SELF\named_unit.dimensions.
    amount_of_substance_exponent = 0.0) AND (SELF\named_unit.dimensions.
    luminous_intensity_exponent = 0.0);
END_ENTITY;
 
ENTITY wedge_volume
SUBTYPE OF (volume);
  position : axis2_placement_3d;
  x : positive_length_measure;
  y : positive_length_measure;
  z : positive_length_measure;
  ltx : length_measure;
WHERE
  wr1 : (0.0 <= ltx) AND (ltx < x);
END_ENTITY;
 
ENTITY week_of_year_and_day_date
SUBTYPE OF (date);
  week_component : week_in_year_number;
  day_component : OPTIONAL day_in_week_number;
END_ENTITY;
 
ENTITY wire_shell
SUBTYPE OF (topological_representation_item);
  wire_shell_extent : SET [1:?] OF loop;
WHERE
  wr1 : NOT mixed_loop_type_set(wire_shell_extent);
END_ENTITY;
 
ENTITY zone_breakdown_context
SUBTYPE OF (breakdown_context);
END_ENTITY;
 
ENTITY zone_element_usage
SUBTYPE OF (breakdown_element_usage);
END_ENTITY;
 
RULE aliases_are_valid FOR (applied_identification_assignment);
WHERE
  wr1 : SIZEOF(QUERY(aia <* applied_identification_assignment | NOT 
    alias_assignment_is_valid(aia))) = 0;
END_RULE;
 
FUNCTION above_plane(p1 : cartesian_point; p2 : cartesian_point; p3 : 
  cartesian_point; p4 : cartesian_point) : REAL;
LOCAL
  dir2 : direction := dummy_gri||direction([1.0, 0.0, 0.0]);
  dir3 : direction := dummy_gri||direction([1.0, 0.0, 0.0]);
  dir4 : direction := dummy_gri||direction([1.0, 0.0, 0.0]);
  val : REAL;
  mag : REAL;
END_LOCAL;
  IF p1.dim <> 3 THEN
    RETURN (?);
  END_IF;
  REPEAT i := 1 TO 3;
    dir2.direction_ratios[i] := p2.coordinates[i] - p1.coordinates[i];
    dir3.direction_ratios[i] := p3.coordinates[i] - p1.coordinates[i];
    dir4.direction_ratios[i] := p4.coordinates[i] - p1.coordinates[i];
    mag := dir4.direction_ratios[i] * dir4.direction_ratios[i];
  END_REPEAT;
  mag := (mag);
  val := mag * dot_product(dir4, cross_product(dir2, dir3).orientation);
  RETURN (val);
END_FUNCTION;
 
FUNCTION acyclic_action_method_relationship(relation : 
  action_method_relationship; relatives : SET [1:?] OF action_method; 
  specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF action_method_relationship;
END_LOCAL;
  IF relation.relating_method IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(am <* bag_to_set(USEDIN(relation.relating_method, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_METHOD_RELATIONSHIP.RELATED_METHOD'
  )) | specific_relation IN TYPEOF(am));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_method_relationship(x[i], relatives + relation.
    relating_method, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_action_relationship(relation : action_relationship; relatives
   : SET [1:?] OF action; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF action_relationship;
END_LOCAL;
  IF relation.relating_action IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(actn <* bag_to_set(USEDIN(relation.relating_action, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RELATIONSHIP.RELATED_ACTION')
  ) | specific_relation IN TYPEOF(actn));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_relationship(x[i], relatives + relation.
    relating_action, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_action_resource_relationship(relation : 
  action_resource_relationship; relatives : SET [1:?] OF action_resource; 
  specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF action_resource_relationship;
END_LOCAL;
  IF relation.relating_resource IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(ar <* bag_to_set(USEDIN(relation.relating_resource, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ACTION_RESOURCE_RELATIONSHIP.RELATED_RESOURCE'
  )) | specific_relation IN TYPEOF(ar));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_action_resource_relationship(x[i], relatives + relation.
    relating_resource, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_approval_relationship(relation : approval_relationship; 
  relatives : SET [1:?] OF approval; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF approval_relationship;
END_LOCAL;
  IF relation.relating_approval IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(app <* bag_to_set(USEDIN(relation.relating_approval, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.APPROVAL_RELATIONSHIP.RELATED_APPROVAL'
  )) | specific_relation IN TYPEOF(app));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_approval_relationship(x[i], relatives + relation.
    relating_approval, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_characterized_object_relationship(relation : 
  characterized_object_relationship; relatives : SET [1:?] OF 
  characterized_object; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF characterized_object_relationship;
END_LOCAL;
  IF relation.relating_object IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(ca <* bag_to_set(USEDIN(relation.relating_object, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CHARACTERIZED_OBJECT_RELATIONSHIP.RELATED_OBJECT'
  )) | specific_relation IN TYPEOF(ca));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_characterized_object_relationship(x[i], relatives + relation
    .relating_object, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_contract_relationship(relation : contract_relationship; 
  relatives : SET [1:?] OF contract; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF contract_relationship;
END_LOCAL;
  IF relation.relating_contract IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(cont <* bag_to_set(USEDIN(relation.relating_contract, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTRACT_RELATIONSHIP.RELATED_CONTRACT'
  )) | specific_relation IN TYPEOF(cont));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_contract_relationship(x[i], relatives + relation.
    relating_contract, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_curve_replica(rep : curve_replica; parent : curve) : BOOLEAN;
  IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CURVE_REPLICA' IN TYPEOF(
  parent)) THEN
    RETURN (TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN (FALSE);
  ELSE
    RETURN (acyclic_curve_replica(rep, parent\curve_replica.parent_curve));
  END_IF;
END_FUNCTION;
 
FUNCTION acyclic_document_relationship(relation : document_relationship; 
  relatives : SET [1:?] OF document; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF document_relationship;
END_LOCAL;
  IF relation.relating_document IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(doc <* bag_to_set(USEDIN(relation.relating_document, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DOCUMENT_RELATIONSHIP.RELATED_DOCUMENT'
  )) | specific_relation IN TYPEOF(doc));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_document_relationship(x[i], relatives + relation.
    relating_document, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_effectivity_relationship(relation : effectivity_relationship; 
  relatives : SET [1:?] OF effectivity; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF effectivity_relationship;
END_LOCAL;
  IF relation.relating_effectivity IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(eff <* bag_to_set(USEDIN(relation.relating_effectivity, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EFFECTIVITY_RELATIONSHIP.RELATED_EFFECTIVITY'
  )) | specific_relation IN TYPEOF(eff));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_effectivity_relationship(x[i], relatives + relation.
    relating_effectivity, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_event_occurrence_relationship(relation : 
  event_occurrence_relationship; relatives : SET [1:?] OF event_occurrence; 
  specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF event_occurrence_relationship;
END_LOCAL;
  IF relation.relating_event IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(evnt <* bag_to_set(USEDIN(relation.relating_event, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EVENT_OCCURRENCE_RELATIONSHIP.RELATED_EVENT'
  )) | specific_relation IN TYPEOF(evnt));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_event_occurrence_relationship(x[i], relatives + relation.
    relating_event, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_external_source_relationship(relation : 
  external_source_relationship; relatives : SET [1:?] OF external_source; 
  specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF external_source_relationship;
END_LOCAL;
  IF relation.relating_source IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(es <* bag_to_set(USEDIN(relation.relating_source, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNAL_SOURCE_RELATIONSHIP.RELATED_SOURCE'
  )) | specific_relation IN TYPEOF(es));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_external_source_relationship(x[i], relatives + relation.
    relating_source, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_externally_defined_item_relationship(relation : 
  externally_defined_item_relationship; relatives : SET [1:?] OF 
  externally_defined_item; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF externally_defined_item_relationship;
END_LOCAL;
  IF relation.relating_item IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(edi <* bag_to_set(USEDIN(relation.relating_item, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EXTERNALLY_DEFINED_ITEM_RELATIONSHIP.RELATED_ITEM'
  )) | specific_relation IN TYPEOF(edi));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_externally_defined_item_relationship(x[i], relatives + 
    relation.relating_item, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_general_property_relationship(relation : 
  general_property_relationship; relatives : SET [1:?] OF general_property; 
  specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF general_property_relationship;
END_LOCAL;
  IF relation.relating_property IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(genp <* bag_to_set(USEDIN(relation.relating_property, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GENERAL_PROPERTY_RELATIONSHIP.RELATED_PROPERTY'
  )) | specific_relation IN TYPEOF(genp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_general_property_relationship(x[i], relatives + relation.
    relating_property, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_group_relationship(relation : group_relationship; relatives : 
  SET [1:?] OF group; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF group_relationship;
END_LOCAL;
  IF relation.relating_group IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(grp <* bag_to_set(USEDIN(relation.relating_group, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GROUP_RELATIONSHIP.RELATED_GROUP'))
   | specific_relation IN TYPEOF(grp));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_group_relationship(x[i], relatives + relation.relating_group
    , specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_identification_assignment_relationship(relation : 
  identification_assignment_relationship; relatives : SET [1:?] OF 
  identification_assignment; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF identification_assignment_relationship;
END_LOCAL;
  IF relation.relating_identification_assignment IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(ia <* bag_to_set(USEDIN(relation.
  relating_identification_assignment, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.IDENTIFICATION_ASSIGNMENT_RELATIONSHIP.RELATED_IDENTIFICATION_ASSIGNMENT'
  )) | specific_relation IN TYPEOF(ia));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_identification_assignment_relationship(x[i], relatives + 
    relation.relating_identification_assignment, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_mapped_representation(parent_set : SET OF representation; 
  children_set : SET OF representation_item) : BOOLEAN;
LOCAL
  x : SET OF representation_item;
  y : SET OF representation_item;
END_LOCAL;
  x := QUERY(z <* children_set | 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MAPPED_ITEM' IN TYPEOF(z));
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      IF x[i]\mapped_item.mapping_source.mapped_representation IN parent_set
       THEN
        RETURN (FALSE);
      END_IF;
      IF NOT acyclic_mapped_representation(parent_set + x[i]\mapped_item.
      mapping_source.mapped_representation, x[i]\mapped_item.mapping_source.
      mapped_representation.items) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  x := children_set - x;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      y := QUERY(z <* bag_to_set(USEDIN(x[i], '')) | 
      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z
      ));
      IF NOT acyclic_mapped_representation(parent_set, y) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_organization_relationship(relation : organization_relationship
  ; relatives : SET [1:?] OF organization; specific_relation : STRING) : 
  BOOLEAN;
LOCAL
  x : SET OF organization_relationship;
END_LOCAL;
  IF relation.relating_organization IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(org <* bag_to_set(USEDIN(relation.relating_organization, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATION_RELATIONSHIP.RELATED_ORGANIZATION'
  )) | specific_relation IN TYPEOF(org));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organization_relationship(x[i], relatives + relation.
    relating_organization, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_organizational_project_relationship(relation : 
  organizational_project_relationship; relatives : SET [1:?] OF 
  organizational_project; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF organizational_project_relationship;
END_LOCAL;
  IF relation.relating_organizational_project IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(op <* bag_to_set(USEDIN(relation.relating_organizational_project, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORGANIZATIONAL_PROJECT_RELATIONSHIP.RELATED_ORGANIZATIONAL_PROJECT'
  )) | specific_relation IN TYPEOF(op));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_organizational_project_relationship(x[i], relatives + 
    relation.relating_organizational_project, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_point_replica(rep : point_replica; parent : point) : BOOLEAN;
  IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POINT_REPLICA' IN TYPEOF(
  parent)) THEN
    RETURN (TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN (FALSE);
  ELSE
    RETURN (acyclic_point_replica(rep, parent\point_replica.parent_pt));
  END_IF;
END_FUNCTION;
 
FUNCTION acyclic_product_category_relationship(relation : 
  product_category_relationship; children : SET OF product_category) : BOOLEAN;
LOCAL
  x : SET OF product_category_relationship;
  local_children : SET OF product_category;
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(children);
    IF relation.category :=: children[i] THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  x := bag_to_set(USEDIN(relation.category, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_CATEGORY_RELATIONSHIP.SUB_CATEGORY'
  ));
  local_children := children + relation.category;
  IF SIZEOF(x) > 0 THEN
    REPEAT i := 1 TO HIINDEX(x);
      IF NOT acyclic_product_category_relationship(x[i], local_children) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_product_definition_formation_relationship(relation : 
  product_definition_formation_relationship; relatives : SET [1:?] OF 
  product_definition_formation; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_definition_formation_relationship;
END_LOCAL;
  IF relation.relating_product_definition_formation IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(pdf <* bag_to_set(USEDIN(relation.
  relating_product_definition_formation, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION_FORMATION'
  )) | specific_relation IN TYPEOF(pdf));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_formation_relationship(x[i], relatives + 
    relation.relating_product_definition_formation, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_product_definition_relationship(relation : 
  product_definition_relationship; relatives : SET [1:?] OF product_definition
  ; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_definition_relationship;
END_LOCAL;
  IF relation.relating_product_definition IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_product_definition, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'
  )) | specific_relation IN TYPEOF(pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_definition_relationship(x[i], relatives + relation.
    relating_product_definition, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_product_relationship(relation : product_relationship; 
  relatives : SET [1:?] OF product; specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF product_relationship;
END_LOCAL;
  IF relation.relating_product IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(prod <* bag_to_set(USEDIN(relation.relating_product, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATIONSHIP.RELATED_PRODUCT'
  )) | specific_relation IN TYPEOF(prod));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_product_relationship(x[i], relatives + relation.
    relating_product, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_property_definition_relationship(relation : 
  property_definition_relationship; relatives : SET [1:?] OF 
  property_definition; specific_relation : STRING) : LOGICAL;
LOCAL
  x : SET OF property_definition_relationship;
END_LOCAL;
  IF relation.relating_property_definition IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(pd <* bag_to_set(USEDIN(relation.relating_property_definition, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_RELATIONSHIP.RELATED_PROPERTY_DEFINITION'
  )) | specific_relation IN TYPEOF(pd));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_property_definition_relationship(x[i], relatives + relation.
    relating_property_definition, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_set_replica(rep : geometric_set_replica; parent : 
  geometric_set) : BOOLEAN;
  IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.GEOMETRIC_SET_REPLICA' IN 
  TYPEOF(parent)) THEN
    RETURN (TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN (FALSE);
  ELSE
    RETURN (acyclic_set_replica(rep, parent\geometric_set_replica.parent_set));
  END_IF;
END_FUNCTION;
 
FUNCTION acyclic_shape_aspect_relationship(relation : shape_aspect_relationship
  ; relatives : SET [1:?] OF shape_aspect; specific_relation : STRING) : 
  BOOLEAN;
LOCAL
  x : SET OF shape_aspect_relationship;
END_LOCAL;
  IF relation.relating_shape_aspect IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(sa <* bag_to_set(USEDIN(relation.relating_shape_aspect, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT_RELATIONSHIP.RELATED_SHAPE_ASPECT'
  )) | specific_relation IN TYPEOF(sa));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_shape_aspect_relationship(x[i], relatives + relation.
    relating_shape_aspect, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION acyclic_solid_replica(rep : solid_replica; parent : solid_model) : 
  BOOLEAN;
  IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SOLID_REPLICA' IN TYPEOF(
  parent)) THEN
    RETURN (TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN (FALSE);
  ELSE
    RETURN (acyclic_solid_replica(rep, parent\solid_replica.parent_solid));
  END_IF;
END_FUNCTION;
 
FUNCTION acyclic_surface_replica(rep : surface_replica; parent : surface) : 
  BOOLEAN;
  IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_REPLICA' IN TYPEOF(
  parent)) THEN
    RETURN (TRUE);
  END_IF;
  IF parent :=: rep THEN
    RETURN (FALSE);
  ELSE
    RETURN (acyclic_surface_replica(rep, parent\surface_replica.parent_surface)
    );
  END_IF;
END_FUNCTION;
 
FUNCTION acyclic_time_interval_relationship(relation : 
  time_interval_relationship; relatives : SET [1:?] OF time_interval; 
  specific_relation : STRING) : BOOLEAN;
LOCAL
  x : SET OF time_interval_relationship;
END_LOCAL;
  IF relation.relating_time_interval IN relatives THEN
    RETURN (FALSE);
  END_IF;
  x := QUERY(ti <* bag_to_set(USEDIN(relation.relating_time_interval, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_INTERVAL_RELATIONSHIP.RELATED_TIME_INTERVAL'
  )) | specific_relation IN TYPEOF(ti));
  REPEAT i := 1 TO HIINDEX(x);
    IF NOT acyclic_time_interval_relationship(x[i], relatives + relation.
    relating_time_interval, specific_relation) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION alias_assignment_is_valid(aia : applied_identification_assignment) : 
  BOOLEAN;
LOCAL
  item : identification_item;
  role : identification_role;
END_LOCAL;
  role := aia.role;
  IF role.name = 'alias' THEN
    REPEAT i := LOINDEX(aia.items) TO HIINDEX(aia.items);
      item := aia.items[i];
      IF SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.' + 'ALIASABLE_ITEM']
       * TYPEOF(item)) = 0 THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;
 
FUNCTION assembly_shape_is_defined(assy : next_assembly_usage_occurrence) : 
  BOOLEAN;
LOCAL
  sdr_set : SET OF shape_definition_representation := [];
  srr_set : SET OF shape_representation_relationship := [];
  sdr1_set : SET OF shape_definition_representation := [];
  pd_set : SET OF property_definition := [];
  pdr_set : SET OF product_definition_relationship := [];
  pds_set : SET OF product_definition_shape := [];
  prop_set : SET OF property_definition := [];
END_LOCAL;
  pd_set := bag_to_set(USEDIN(assy.related_product_definition, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
  pdr_set := QUERY(pdr <* bag_to_set(USEDIN(assy.related_product_definition, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATED_PRODUCT_DEFINITION'
  )) | SIZEOF(USEDIN(pdr, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')) > 
  0);
  IF SIZEOF(pd_set) > 0 THEN
    REPEAT i := 1 TO HIINDEX(pd_set);
      sdr_set := sdr_set + QUERY(pdr <* USEDIN(pd_set[i], 
      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
      ) | schema_name + '.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr));
    END_REPEAT;
  END_IF;
  IF SIZEOF(pdr_set) > 0 THEN
    REPEAT i := 1 TO HIINDEX(pdr_set);
      prop_set := prop_set + bag_to_set(USEDIN(pdr_set[i], 
      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')
      );
    END_REPEAT;
    IF SIZEOF(prop_set) > 0 THEN
      REPEAT i := 1 TO HIINDEX(prop_set);
        sdr_set := sdr_set + QUERY(pdr <* USEDIN(prop_set[i], 
        'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
        ) | schema_name + '.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr));
      END_REPEAT;
    END_IF;
  END_IF;
  IF SIZEOF(sdr_set) > 0 THEN
    REPEAT i := 1 TO HIINDEX(sdr_set);
      srr_set := QUERY(rr <* bag_to_set(USEDIN(sdr_set[i]\
      property_definition_representation.used_representation, 
      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_2'
      )) | schema_name + '.SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(rr));
      pd_set := bag_to_set(USEDIN(assy.relating_product_definition, 
      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION')
      );
      IF SIZEOF(pd_set) > 0 THEN
        REPEAT i := 1 TO HIINDEX(pd_set);
          sdr1_set := sdr1_set + QUERY(pdr <* USEDIN(pd_set[i], 
          'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
          ) | schema_name + '.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr));
        END_REPEAT;
      END_IF;
      IF (SIZEOF(sdr_set) > 0) AND (SIZEOF(sdr1_set) > 0) THEN
        IF SIZEOF(srr_set) > 0 THEN
          REPEAT j := 1 TO HIINDEX(srr_set);
            IF SIZEOF(QUERY(pdr <* bag_to_set(USEDIN(srr_set[j]\
            representation_relationship.rep_1, 
            'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.USED_REPRESENTATION'
            )) | schema_name + '.SHAPE_DEFINITION_REPRESENTATION' IN TYPEOF(pdr
            )) * sdr1_set) >= 1 THEN
              pds_set := QUERY(x <* bag_to_set(USEDIN(assy, 
              'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'
              )) | schema_name + '.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(x));
              IF SIZEOF(pds_set) = 0 THEN
                RETURN (FALSE);
              END_IF;
              REPEAT k := 1 TO HIINDEX(pds_set);
                IF SIZEOF(QUERY(cdsr <* USEDIN(pds_set[k], 
                'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CONTEXT_DEPENDENT_SHAPE_REPRESENTATION.REPRESENTED_PRODUCT_RELATION'
                ) | cdsr.representation_relation :=: srr_set[j])) > 0 THEN
                  RETURN (FALSE);
                END_IF;
              END_REPEAT;
            END_IF;
          END_REPEAT;
        END_IF;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION associated_surface(arg : pcurve_or_surface) : surface;
LOCAL
  surf : surface;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(arg) THEN
    surf := arg.basis_surface;
  ELSE
    surf := arg;
  END_IF;
  RETURN (surf);
END_FUNCTION;
 
FUNCTION bag_to_set(the_bag :  BAG OF GENERIC : intype) : SET OF GENERIC : 
  intype;
LOCAL
  the_set : SET OF GENERIC : intype := [];
END_LOCAL;
  IF SIZEOF(the_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(the_bag);
      the_set := the_set + the_bag[i];
    END_REPEAT;
  END_IF;
  RETURN (the_set);
END_FUNCTION;
 
FUNCTION base_axis(dim : INTEGER; axis1 : direction; axis2 : direction; axis3
   : direction) :  LIST [2:3] OF direction;
LOCAL
  u :  LIST [2:3] OF direction;
  factor : REAL;
  d1 : direction;
  d2 : direction;
END_LOCAL;
  IF dim = 3 THEN
    d1 := NVL(normalise(axis3), dummy_gri||direction([0.0, 0.0, 1.0]));
    d2 := first_proj_axis(d1, axis1);
    u := [d2, second_proj_axis(d1, d2, axis2), d1];
  ELSE
    IF EXISTS(axis1) THEN
      d1 := normalise(axis1);
      u := [d1, orthogonal_complement(d1)];
      IF EXISTS(axis2) THEN
        factor := dot_product(axis2, u[2]);
        IF factor < 0.0 THEN
          u[2].direction_ratios[1] := -u[2].direction_ratios[1];
          u[2].direction_ratios[2] := -u[2].direction_ratios[2];
        END_IF;
      END_IF;
    ELSE
      IF EXISTS(axis2) THEN
        d1 := normalise(axis2);
        u := [orthogonal_complement(d1), d1];
        u[1].direction_ratios[1] := -u[1].direction_ratios[1];
        u[1].direction_ratios[2] := -u[1].direction_ratios[2];
      ELSE
        u := [dummy_gri||direction([1.0, 0.0]), dummy_gri||direction([0.0, 1.0]
        )];
      END_IF;
    END_IF;
  END_IF;
  RETURN (u);
END_FUNCTION;
 
FUNCTION boolean_choose(b : BOOLEAN; choice1 : GENERIC : item; choice2 : 
  GENERIC : item) : GENERIC : item;
  IF b THEN
    RETURN (choice1);
  ELSE
    RETURN (choice2);
  END_IF;
END_FUNCTION;
 
FUNCTION build_2axes(ref_direction : direction) :  LIST [2:2] OF direction;
LOCAL
  d : direction := NVL(normalise(ref_direction), dummy_gri||direction([1.0, 0.0
  ]));
END_LOCAL;
  RETURN ([d, orthogonal_complement(d)]);
END_FUNCTION;
 
FUNCTION build_axes(axis : direction; ref_direction : direction) :  LIST [3:3]
   OF direction;
LOCAL
  d1 : direction;
  d2 : direction;
END_LOCAL;
  d1 := NVL(normalise(axis), dummy_gri||direction([0.0, 0.0, 1.0]));
  d2 := first_proj_axis(d1, ref_direction);
  RETURN ([d2, normalise(cross_product(d1, d2)).orientation, d1]);
END_FUNCTION;
 
FUNCTION build_transformed_set(tr : cartesian_transformation_operator; gset : 
  geometric_set) : SET OF geometric_set_select;
LOCAL
  s : SET [1:?] OF geometric_set_select := gset.elements;
  trset : SET OF geometric_set_select := [];
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(s);
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CURVE' IN TYPEOF(s[j]) THEN
      trset := trset + dummy_gri||curve()||curve_replica(s[j], tr);
    ELSE
      IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POINT' IN TYPEOF(s[j]) THEN
        trset := trset + dummy_gri||point()||point_replica(s[j], tr);
      ELSE
        IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE' IN TYPEOF(s[j])
         THEN
          trset := trset + dummy_gri||surface()||surface_replica(s[j], tr||
          cartesian_transformation_operator_3d(?));
        END_IF;
      END_IF;
    END_IF;
  END_REPEAT;
  RETURN (trset);
END_FUNCTION;
 
FUNCTION categories_of_product(obj : product) : SET OF STRING;
LOCAL
  category_assignments :  BAG OF product_category;
  categories : SET OF STRING := [];
  i : INTEGER;
END_LOCAL;
  category_assignments := USEDIN(obj, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_RELATED_PRODUCT_CATEGORY.PRODUCTS'
  );
  REPEAT i := LOINDEX(category_assignments) TO HIINDEX(category_assignments);
    categories := categories + category_assignments[i].name;
  END_REPEAT;
  RETURN (categories);
END_FUNCTION;
 
FUNCTION closed_shell_reversed(a_shell : closed_shell) : oriented_closed_shell;
LOCAL
  the_reverse : oriented_closed_shell;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_CLOSED_SHELL' IN TYPEOF(
  a_shell) THEN
    the_reverse := dummy_tri||connected_face_set(a_shell\connected_face_set.
    cfs_faces)||closed_shell()||oriented_closed_shell(a_shell\
    oriented_closed_shell.closed_shell_element, NOT a_shell\
    oriented_closed_shell.orientation);
  ELSE
    the_reverse := dummy_tri||connected_face_set(a_shell\connected_face_set.
    cfs_faces)||closed_shell()||oriented_closed_shell(a_shell, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION conditional_reverse(p : BOOLEAN; an_item : reversible_topology) : 
  reversible_topology;
  IF p THEN
    RETURN (an_item);
  ELSE
    RETURN (topology_reversed(an_item));
  END_IF;
END_FUNCTION;
 
FUNCTION constraints_composite_curve_on_surface(c : composite_curve_on_surface)
   : BOOLEAN;
LOCAL
  n_segments : INTEGER := SIZEOF(c.segments);
END_LOCAL;
  REPEAT k := 1 TO n_segments;
    IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(c\
    composite_curve.segments[k].parent_curve)) AND NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_CURVE' IN TYPEOF(c\
    composite_curve.segments[k].parent_curve)) AND NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN 
    TYPEOF(c\composite_curve.segments[k].parent_curve)) THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION constraints_geometry_shell_based_surface_model(m : 
  shell_based_surface_model) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbsm_boundary);
    IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OPEN_SHELL' IN TYPEOF(m.
    sbsm_boundary[j])) AND NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLOSED_SHELL' IN TYPEOF(m.
    sbsm_boundary[j])) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;
 
FUNCTION constraints_geometry_shell_based_wireframe_model(m : 
  shell_based_wireframe_model) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT j := 1 TO SIZEOF(m.sbwm_boundary);
    IF NOT ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.WIRE_SHELL' IN TYPEOF(m.
    sbwm_boundary[j])) AND NOT (
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERTEX_SHELL' IN TYPEOF(m.
    sbwm_boundary[j])) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;
 
FUNCTION constraints_param_b_spline(degree : INTEGER; up_knots : INTEGER; up_cp
   : INTEGER; knot_mult : LIST OF INTEGER; knots : LIST OF parameter_value) : 
  BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
  k : INTEGER;
  sum : INTEGER;
END_LOCAL;
  sum := knot_mult[1];
  REPEAT i := 2 TO up_knots;
    sum := sum + knot_mult[i];
  END_REPEAT;
  IF (degree < 1) OR (up_knots < 2) OR (up_cp < degree) OR (sum <> degree + 
  up_cp + 2) THEN
    result := FALSE;
    RETURN (result);
  END_IF;
  k := knot_mult[1];
  IF (k < 1) OR (k > degree + 1) THEN
    result := FALSE;
    RETURN (result);
  END_IF;
  REPEAT i := 2 TO up_knots;
    IF (knot_mult[i] < 1) OR (knots[i] <= knots[i - 1]) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
    k := knot_mult[i];
    IF (i < up_knots) AND (k > degree) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
    IF (i = up_knots) AND (k > degree + 1) THEN
      result := FALSE;
      RETURN (result);
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;
 
FUNCTION constraints_rectangular_composite_surface(s : 
  rectangular_composite_surface) : BOOLEAN;
  REPEAT i := 1 TO s.n_u;
    REPEAT j := 1 TO s.n_v;
      IF NOT (('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.B_SPLINE_SURFACE' IN 
      TYPEOF(s.segments[i][j].parent_surface)) OR (
      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RECTANGULAR_TRIMMED_SURFACE' IN 
      TYPEOF(s.segments[i][j].parent_surface))) THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT i := 1 TO s.n_u - 1;
    REPEAT j := 1 TO s.n_v;
      IF s.segments[i][j].u_transition = discontinuous THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  REPEAT i := 1 TO s.n_u;
    REPEAT j := 1 TO s.n_v - 1;
      IF s.segments[i][j].v_transition = discontinuous THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION cross_product(arg1 : direction; arg2 : direction) : vector;
LOCAL
  mag : REAL;
  res : direction;
  v1 :  LIST [3:3] OF REAL;
  v2 :  LIST [3:3] OF REAL;
  result : vector;
END_LOCAL;
  IF NOT EXISTS(arg1) OR (arg1.dim = 2) OR NOT EXISTS(arg2) OR (arg2.dim = 2)
   THEN
    RETURN (?);
  ELSE
    v1 := normalise(arg1).direction_ratios;
    v2 := normalise(arg2).direction_ratios;
    res := dummy_gri||direction([v1[2] * v2[3] - v1[3] * v2[2], v1[3] * v2[1]
     - v1[1] * v2[3], v1[1] * v2[2] - v1[2] * v2[1]]);
    mag := 0.0;
    REPEAT i := 1 TO 3;
      mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0 THEN
      result := dummy_gri||vector(res, (mag));
    ELSE
      result := dummy_gri||vector(arg1, 0.0);
    END_IF;
    RETURN (result);
  END_IF;
END_FUNCTION;
 
FUNCTION curve_weights_positive(b : rational_b_spline_curve) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 0 TO b.upper_index_on_control_points;
    IF b.weights[i] <= 0.0 THEN
      result := FALSE;
      RETURN (result);
    END_IF;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;
 
FUNCTION default_b_spline_curve_weights(up_cp : INTEGER) :  ARRAY [0:up_cp] OF 
  REAL;
  RETURN ([1 : up_cp + 1]);
END_FUNCTION;
 
FUNCTION default_b_spline_knot_mult(degree : INTEGER; up_knots : INTEGER; 
  uniform : knot_type) :  LIST [2:?] OF INTEGER;
LOCAL
  knot_mult :  LIST [1:up_knots] OF INTEGER;
END_LOCAL;
  IF uniform = uniform_knots THEN
    knot_mult := [1 : up_knots];
  ELSE
    IF uniform = quasi_uniform_knots THEN
      knot_mult := [1 : up_knots];
      knot_mult[1] := degree + 1;
      knot_mult[up_knots] := degree + 1;
    ELSE
      IF uniform = piecewise_bezier_knots THEN
        knot_mult := [degree : up_knots];
        knot_mult[1] := degree + 1;
        knot_mult[up_knots] := degree + 1;
      ELSE
        knot_mult := [0 : up_knots];
      END_IF;
    END_IF;
  END_IF;
  RETURN (knot_mult);
END_FUNCTION;
 
FUNCTION default_b_spline_knots(degree : INTEGER; up_knots : INTEGER; uniform
   : knot_type) :  LIST [2:?] OF parameter_value;
LOCAL
  knots :  LIST [1:up_knots] OF parameter_value := [0 : up_knots];
  ishift : INTEGER := 1;
END_LOCAL;
  IF uniform = uniform_knots THEN
    ishift := degree + 1;
  END_IF;
  IF (uniform = uniform_knots) OR (uniform = quasi_uniform_knots) OR (uniform
   = piecewise_bezier_knots) THEN
    REPEAT i := 1 TO up_knots;
      knots[i] := i - ishift;
    END_REPEAT;
  END_IF;
  RETURN (knots);
END_FUNCTION;
 
FUNCTION default_b_spline_surface_weights(u_upper : INTEGER; v_upper : INTEGER)
   :  ARRAY [0:u_upper] OF  ARRAY [0:v_upper] OF REAL;
  RETURN ([[1 : v_upper + 1] : u_upper + 1]);
END_FUNCTION;
 
FUNCTION derive_dimensional_exponents(x : unit) : dimensional_exponents;
LOCAL
  result : dimensional_exponents := dimensional_exponents(0.0, 0.0, 0.0, 0.0, 
  0.0, 0.0, 0.0);
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DERIVED_UNIT' IN TYPEOF(x) THEN
    REPEAT i := LOINDEX(x.elements) TO HIINDEX(x.elements);
      result.length_exponent := result.length_exponent + x.elements[i].exponent
       * x.elements[i].unit.dimensions.length_exponent;
      result.mass_exponent := result.mass_exponent + x.elements[i].exponent * x
      .elements[i].unit.dimensions.mass_exponent;
      result.time_exponent := result.time_exponent + x.elements[i].exponent * x
      .elements[i].unit.dimensions.time_exponent;
      result.electric_current_exponent := result.electric_current_exponent + x.
      elements[i].exponent * x.elements[i].unit.dimensions.
      electric_current_exponent;
      result.thermodynamic_temperature_exponent := result.
      thermodynamic_temperature_exponent + x.elements[i].exponent * x.elements[
      i].unit.dimensions.thermodynamic_temperature_exponent;
      result.amount_of_substance_exponent := result.
      amount_of_substance_exponent + x.elements[i].exponent * x.elements[i].
      unit.dimensions.amount_of_substance_exponent;
      result.luminous_intensity_exponent := result.luminous_intensity_exponent
       + x.elements[i].exponent * x.elements[i].unit.dimensions.
      luminous_intensity_exponent;
    END_REPEAT;
  ELSE
    result := x.dimensions;
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION dimension_of(item : geometric_representation_item) : dimension_count;
LOCAL
  x : SET OF representation;
  y : representation_context;
  dim : dimension_count;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CARTESIAN_POINT' IN TYPEOF(item)
   THEN
    dim := SIZEOF(item\cartesian_point.coordinates);
    RETURN (dim);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DIRECTION' IN TYPEOF(item) THEN
    dim := SIZEOF(item\direction.direction_ratios);
    RETURN (dim);
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(item) THEN
    dim := SIZEOF(item\vector.orientation\direction.direction_ratios);
    RETURN (dim);
  END_IF;
  x := using_representations(item);
  y := x[1].context_of_items;
  dim := y\geometric_representation_context.coordinate_space_dimension;
  RETURN (dim);
END_FUNCTION;
 
FUNCTION dimensions_for_si_unit(n : si_unit_name) : dimensional_exponents;
  CASE n OF 
    metre : RETURN (dimensional_exponents(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    gram : RETURN (dimensional_exponents(0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    second : RETURN (dimensional_exponents(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0));
    ampere : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0));
    kelvin : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    mole : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0));
    candela : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0)
    );
    radian : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0));
    steradian : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
    ));
    hertz : RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 0.0));
    newton : RETURN (dimensional_exponents(1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    );
    pascal : RETURN (dimensional_exponents(-1.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    );
    joule : RETURN (dimensional_exponents(2.0, 1.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    watt : RETURN (dimensional_exponents(2.0, 1.0, -3.0, 0.0, 0.0, 0.0, 0.0));
    coulomb : RETURN (dimensional_exponents(0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0)
    );
    volt : RETURN (dimensional_exponents(2.0, 1.0, -3.0, -1.0, 0.0, 0.0, 0.0));
    farad : RETURN (dimensional_exponents(-2.0, -1.0, 4.0, 1.0, 0.0, 0.0, 0.0)
    );
    ohm : RETURN (dimensional_exponents(2.0, 1.0, -3.0, -2.0, 0.0, 0.0, 0.0));
    siemens : RETURN (dimensional_exponents(-2.0, -1.0, 3.0, 2.0, 0.0, 0.0, 0.0
    ));
    weber : RETURN (dimensional_exponents(2.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    );
    tesla : RETURN (dimensional_exponents(0.0, 1.0, -2.0, -1.0, 0.0, 0.0, 0.0)
    );
    henry : RETURN (dimensional_exponents(2.0, 1.0, -2.0, -2.0, 0.0, 0.0, 0.0)
    );
    degree_celsius : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 1.0, 0.0
    , 0.0));
    lumen : RETURN (dimensional_exponents(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    lux : RETURN (dimensional_exponents(-2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0));
    becquerel : RETURN (dimensional_exponents(0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 
    0.0));
    gray : RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0));
    sievert : RETURN (dimensional_exponents(2.0, 0.0, -2.0, 0.0, 0.0, 0.0, 0.0)
    );
    OTHERWISE  : RETURN (?);
  END_CASE;
END_FUNCTION;
 
FUNCTION dot_product(arg1 : direction; arg2 : direction) : REAL;
LOCAL
  scalar : REAL;
  vec1 : direction;
  vec2 : direction;
  ndim : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) THEN
    scalar := ?;
  ELSE
    IF arg1.dim <> arg2.dim THEN
      scalar := ?;
    ELSE
      vec1 := normalise(arg1);
      vec2 := normalise(arg2);
      ndim := arg1.dim;
      scalar := 0.0;
      REPEAT i := 1 TO ndim;
        scalar := scalar + vec1.direction_ratios[i] * vec2.direction_ratios[i];
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (scalar);
END_FUNCTION;
 
FUNCTION edge_curve_pcurves(an_edge : edge_curve; the_surface_curves : SET OF 
  surface_curve) : SET OF pcurve;
LOCAL
  a_curve : curve;
  result : SET OF pcurve;
  the_geometry :  LIST [1:2] OF pcurve_or_surface;
END_LOCAL;
  a_curve := an_edge.edge_geometry;
  result := [];
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(a_curve) THEN
    result := result + a_curve;
  ELSE
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_CURVE' IN TYPEOF(
    a_curve) THEN
      the_geometry := a_curve\surface_curve.associated_geometry;
      REPEAT k := 1 TO SIZEOF(the_geometry);
        IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(
        the_geometry[k]) THEN
          result := result + the_geometry[k];
        END_IF;
      END_REPEAT;
    ELSE
      REPEAT j := 1 TO SIZEOF(the_surface_curves);
        the_geometry := the_surface_curves[j].associated_geometry;
        IF the_surface_curves[j].curve_3d :=: a_curve THEN
          REPEAT k := 1 TO SIZEOF(the_geometry);
            IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(
            the_geometry[k]) THEN
              result := result + the_geometry[k];
            END_IF;
          END_REPEAT;
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION edge_reversed(an_edge : edge) : oriented_edge;
LOCAL
  the_reverse : oriented_edge;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_EDGE' IN TYPEOF(an_edge)
   THEN
    the_reverse := dummy_tri||edge(an_edge.edge_end, an_edge.edge_start)||
    oriented_edge(an_edge\oriented_edge.edge_element, NOT an_edge\oriented_edge
    .orientation);
  ELSE
    the_reverse := dummy_tri||edge(an_edge.edge_end, an_edge.edge_start)||
    oriented_edge(an_edge, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION face_bound_reversed(a_face_bound : face_bound) : face_bound;
LOCAL
  the_reverse : face_bound;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FACE_OUTER_BOUND' IN TYPEOF(
  a_face_bound) THEN
    the_reverse := dummy_tri||face_bound(a_face_bound\face_bound.bound, NOT 
    a_face_bound\face_bound.orientation)||face_outer_bound();
  ELSE
    the_reverse := dummy_tri||face_bound(a_face_bound.bound, NOT a_face_bound.
    orientation);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION face_reversed(a_face : face) : oriented_face;
LOCAL
  the_reverse : oriented_face;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_FACE' IN TYPEOF(a_face)
   THEN
    the_reverse := dummy_tri||face(set_of_topology_reversed(a_face.bounds))||
    oriented_face(a_face\oriented_face.face_element, NOT a_face\oriented_face.
    orientation);
  ELSE
    the_reverse := dummy_tri||face(set_of_topology_reversed(a_face.bounds))||
    oriented_face(a_face, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION first_proj_axis(z_axis : direction; arg : direction) : direction;
LOCAL
  x_axis : direction;
  v : direction;
  z : direction;
  x_vec : vector;
END_LOCAL;
  IF NOT EXISTS(z_axis) THEN
    RETURN (?);
  ELSE
    z := normalise(z_axis);
    IF NOT EXISTS(arg) THEN
      IF (z.direction_ratios <> [1.0, 0.0, 0.0]) AND (z.direction_ratios <> [-
      1.0, 0.0, 0.0]) THEN
        v := dummy_gri||direction([1.0, 0.0, 0.0]);
      ELSE
        v := dummy_gri||direction([0.0, 1.0, 0.0]);
      END_IF;
    ELSE
      IF arg.dim <> 3 THEN
        RETURN (?);
      END_IF;
      IF cross_product(arg, z).magnitude = 0.0 THEN
        RETURN (?);
      ELSE
        v := normalise(arg);
      END_IF;
    END_IF;
    x_vec := scalar_times_vector(dot_product(v, z), z);
    x_axis := vector_difference(v, x_vec).orientation;
    x_axis := normalise(x_axis);
  END_IF;
  RETURN (x_axis);
END_FUNCTION;
 
FUNCTION get_basis_surface(c : curve_on_surface) : SET [0:2] OF surface;
LOCAL
  surfs : SET [0:2] OF surface;
  n : INTEGER;
END_LOCAL;
  surfs := [];
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PCURVE' IN TYPEOF(c) THEN
    surfs := [c\pcurve.basis_surface];
  ELSE
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SURFACE_CURVE' IN TYPEOF(c)
     THEN
      n := SIZEOF(c\surface_curve.associated_geometry);
      REPEAT i := 1 TO n;
        surfs := surfs + associated_surface(c\surface_curve.associated_geometry
        [i]);
      END_REPEAT;
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.COMPOSITE_CURVE_ON_SURFACE' IN 
  TYPEOF(c) THEN
    n := SIZEOF(c\composite_curve.segments);
    surfs := get_basis_surface(c\composite_curve.segments[1].parent_curve);
    IF n > 1 THEN
      REPEAT i := 2 TO n;
        surfs := surfs * get_basis_surface(c\composite_curve.segments[i].
        parent_curve);
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (surfs);
END_FUNCTION;
 
FUNCTION get_description_value(obj : description_attribute_select) : text;
LOCAL
  description_bag :  BAG OF description_attribute := USEDIN(obj, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DESCRIPTION_ATTRIBUTE.DESCRIBED_ITEM'
  );
END_LOCAL;
  IF SIZEOF(description_bag) = 1 THEN
    RETURN (description_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;
 
FUNCTION get_id_value(obj : id_attribute_select) : identifier;
LOCAL
  id_bag :  BAG OF id_attribute := USEDIN(obj, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ID_ATTRIBUTE.IDENTIFIED_ITEM');
END_LOCAL;
  IF SIZEOF(id_bag) = 1 THEN
    RETURN (id_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;
 
FUNCTION get_name_value(obj : name_attribute_select) : label;
LOCAL
  name_bag :  BAG OF name_attribute := USEDIN(obj, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.NAME_ATTRIBUTE.NAMED_ITEM');
END_LOCAL;
  IF SIZEOF(name_bag) = 1 THEN
    RETURN (name_bag[1].attribute_value);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;
 
FUNCTION get_product_definitions(c_def_instance : product) : SET OF 
  product_definition;
LOCAL
  pd_set : SET OF product_definition_formation := [];
  pdr_set : SET OF product_definition := [];
END_LOCAL;
  pd_set := bag_to_set(USEDIN(c_def_instance, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_FORMATION.OF_PRODUCT'
  ));
  IF SIZEOF(pd_set) < 1 THEN
    RETURN (pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION.FORMATION'));
  END_REPEAT;
  RETURN (pdr_set);
END_FUNCTION;
 
FUNCTION get_property_definition_representations(c_def_instance : 
  characterized_definition) : SET OF property_definition_representation;
LOCAL
  pd_set : SET OF property_definition := [];
  pdr_set : SET OF property_definition_representation := [];
END_LOCAL;
  pd_set := bag_to_set(USEDIN(c_def_instance, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION'));
  IF SIZEOF(pd_set) < 1 THEN
    RETURN (pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION_REPRESENTATION.DEFINITION'
    ));
  END_REPEAT;
  RETURN (pdr_set);
END_FUNCTION;
 
FUNCTION get_role(obj : role_select) : object_role;
LOCAL
  role_bag :  BAG OF role_association := USEDIN(obj, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ROLE_ASSOCIATION.ITEM_WITH_ROLE');
END_LOCAL;
  IF SIZEOF(role_bag) = 1 THEN
    RETURN (role_bag[1].role);
  ELSE
    RETURN (?);
  END_IF;
END_FUNCTION;
 
FUNCTION get_shape_aspects(c_def_instance : characterized_definition) : SET OF 
  shape_aspect;
LOCAL
  pd_set : SET OF product_definition_shape := [];
  pdr_set : SET OF shape_aspect := [];
END_LOCAL;
  pd_set := bag_to_set(QUERY(pd <* USEDIN(c_def_instance, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PROPERTY_DEFINITION.DEFINITION') | 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_SHAPE' IN TYPEOF(
  pd)));
  IF SIZEOF(pd_set) < 1 THEN
    RETURN (pdr_set);
  END_IF;
  REPEAT i := 1 TO HIINDEX(pd_set);
    pdr_set := pdr_set + bag_to_set(USEDIN(pd_set[i], 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_ASPECT.OF_SHAPE'));
  END_REPEAT;
  RETURN (pdr_set);
END_FUNCTION;
 
FUNCTION initial_context_is_additional(pd : product_definition) : BOOLEAN;
LOCAL
  initial_context : product_definition_context;
  context_associations : SET OF product_definition_context_association;
END_LOCAL;
  initial_context := pd.frame_of_reference;
  context_associations := QUERY(pdca <* bag_to_set(USEDIN(pd, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_CONTEXT_ASSOCIATION.DEFINITION'
  )) | (pdca.role.name = 'additional context') AND (pdca.frame_of_reference
   :=: initial_context));
  RETURN (SIZEOF(context_associations) > 0);
END_FUNCTION;
 
FUNCTION item_in_context(item : representation_item; cntxt : 
  representation_context) : BOOLEAN;
LOCAL
  y :  BAG OF representation_item;
END_LOCAL;
  IF SIZEOF(USEDIN(item, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION.ITEMS') * cntxt.
  representations_in_context) > 0 THEN
    RETURN (TRUE);
  ELSE
    y := QUERY(z <* USEDIN(item, '') | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z))
    ;
    IF SIZEOF(y) > 0 THEN
      REPEAT i := 1 TO HIINDEX(y);
        IF item_in_context(y[i], cntxt) THEN
          RETURN (TRUE);
        END_IF;
      END_REPEAT;
    END_IF;
  END_IF;
  RETURN (FALSE);
END_FUNCTION;
 
FUNCTION leap_year(year : year_number) : BOOLEAN;
  IF (year MOD 4 = 0) AND (year MOD 100 <> 0) OR (year MOD 400 = 0) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 
FUNCTION list_face_loops(f : face) : LIST OF loop;
LOCAL
  loops : LIST OF loop := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(f.bounds);
    loops := loops + f.bounds[i].bound;
  END_REPEAT;
  RETURN (loops);
END_FUNCTION;
 
FUNCTION list_loop_edges(l : loop) : LIST OF edge;
LOCAL
  edges : LIST OF edge := [];
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EDGE_LOOP' IN TYPEOF(l) THEN
    REPEAT i := 1 TO SIZEOF(l\path.edge_list);
      edges := edges + l\path.edge_list[i].edge_element;
    END_REPEAT;
  END_IF;
  RETURN (edges);
END_FUNCTION;
 
FUNCTION list_of_topology_reversed(a_list : list_of_reversible_topology_item)
   : list_of_reversible_topology_item;
LOCAL
  the_reverse : list_of_reversible_topology_item;
END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_list);
    the_reverse := topology_reversed(a_list[i]) + the_reverse;
  END_REPEAT;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION list_shell_edges(s : shell) : LIST OF edge;
LOCAL
  edges : LIST OF edge := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(list_shell_loops(s));
    edges := edges + list_loop_edges(list_shell_loops(s)[i]);
  END_REPEAT;
  RETURN (edges);
END_FUNCTION;
 
FUNCTION list_shell_faces(s : shell) : LIST OF face;
LOCAL
  faces : LIST OF face := [];
END_LOCAL;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLOSED_SHELL' IN TYPEOF(s)) OR (
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OPEN_SHELL' IN TYPEOF(s)) THEN
    REPEAT i := 1 TO SIZEOF(s\connected_face_set.cfs_faces);
      faces := faces + s\connected_face_set.cfs_faces[i];
    END_REPEAT;
  END_IF;
  RETURN (faces);
END_FUNCTION;
 
FUNCTION list_shell_loops(s : shell) : LIST OF loop;
LOCAL
  loops : LIST OF loop := [];
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VERTEX_SHELL' IN TYPEOF(s) THEN
    loops := loops + s.vertex_shell_extent;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.WIRE_SHELL' IN TYPEOF(s) THEN
    REPEAT i := 1 TO SIZEOF(s.wire_shell_extent);
      loops := loops + s.wire_shell_extent[i];
    END_REPEAT;
  END_IF;
  IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OPEN_SHELL' IN TYPEOF(s)) OR (
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLOSED_SHELL' IN TYPEOF(s)) THEN
    REPEAT i := 1 TO SIZEOF(s.cfs_faces);
      loops := loops + list_face_loops(s.cfs_faces[i]);
    END_REPEAT;
  END_IF;
  RETURN (loops);
END_FUNCTION;
 
FUNCTION list_to_array(lis : LIST OF GENERIC : t; low : INTEGER; u : INTEGER)
   :  ARRAY [low:u] OF GENERIC : t;
LOCAL
  n : INTEGER;
  res :  ARRAY [low:u] OF GENERIC : t;
END_LOCAL;
  n := SIZEOF(lis);
  IF n <> u - low + 1 THEN
    RETURN (?);
  ELSE
    res := [lis[1] : n];
    REPEAT i := 2 TO n;
      res[low + i - 1] := lis[i];
    END_REPEAT;
    RETURN (res);
  END_IF;
END_FUNCTION;
 
FUNCTION list_to_set(l : LIST OF GENERIC : t) : SET OF GENERIC : t;
LOCAL
  s : SET OF GENERIC : t := [];
END_LOCAL;
  REPEAT i := 1 TO SIZEOF(l);
    s := s + l[i];
  END_REPEAT;
  RETURN (s);
END_FUNCTION;
 
FUNCTION local_relatives_of_product_definitions(definition_set : SET OF 
  product_definition; total_definitions : SET OF product_definition; 
  relation_subtype : STRING) : SET OF product_definition;
LOCAL
  local_def : SET OF product_definition := [];
  local_pdr : SET OF product_definition_relationship := [];
  local_total : SET OF product_definition := [];
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(definition_set);
    local_pdr := local_pdr + bag_to_set(USEDIN(definition_set[i], 
    relation_subtype + 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PRODUCT_DEFINITION_RELATIONSHIP.RELATING_PRODUCT_DEFINITION'
    ));
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(local_pdr);
    local_def := local_def + local_pdr[i].related_product_definition;
  END_REPEAT;
  IF SIZEOF(local_def) - SIZEOF(total_definitions) = 0 THEN
    RETURN (local_def);
  ELSE
    local_total := total_definitions + local_def;
    RETURN (local_def + local_relatives_of_product_definitions(local_def - 
    total_definitions, local_total, relation_subtype));
  END_IF;
END_FUNCTION;
 
FUNCTION local_relatives_of_shape_representations(shape_representation_set : 
  SET OF shape_representation; total_reps : SET OF shape_representation) : SET
   OF shape_representation;
LOCAL
  local_shape_rep : SET OF shape_representation := [];
  local_srr : SET OF shape_representation_relationship := [];
  local_total : SET OF shape_representation := [];
END_LOCAL;
  REPEAT i := 1 TO HIINDEX(shape_representation_set);
    local_srr := local_srr + QUERY(rr <* bag_to_set(USEDIN(
    shape_representation_set[i], 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_RELATIONSHIP.REP_1'
    )) | 
    'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHAPE_REPRESENTATION_RELATIONSHIP'
     IN TYPEOF(rr));
  END_REPEAT;
  REPEAT i := 1 TO HIINDEX(local_srr);
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.' + 
    'SHAPE_REPRESENTATION_RELATIONSHIP' IN TYPEOF(local_srr[i]) THEN
      local_shape_rep := local_shape_rep + local_srr[i].rep_2;
    END_IF;
  END_REPEAT;
  IF SIZEOF(local_shape_rep - total_reps) = 0 THEN
    RETURN (shape_representation_set);
  ELSE
    local_total := total_reps + local_shape_rep;
    RETURN (local_shape_rep + local_relatives_of_shape_representations(
    local_shape_rep - total_reps, local_total));
  END_IF;
END_FUNCTION;
 
FUNCTION make_array_of_array(lis :  LIST [1:?] OF  LIST [1:?] OF GENERIC : t; 
  low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2 : INTEGER) :  ARRAY [low1:u1
  ] OF  ARRAY [low2:u2] OF GENERIC : t;
LOCAL
  res :  ARRAY [low1:u1] OF  ARRAY [low2:u2] OF GENERIC : t;
END_LOCAL;
  IF u1 - low1 + 1 <> SIZEOF(lis) THEN
    RETURN (?);
  END_IF;
  IF u2 - low2 + 1 <> SIZEOF(lis[1]) THEN
    RETURN (?);
  END_IF;
  res := [list_to_array(lis[1], low2, u2) : u1 - low1 + 1];
  REPEAT i := 2 TO HIINDEX(lis);
    IF u2 - low2 + 1 <> SIZEOF(lis[i]) THEN
      RETURN (?);
    END_IF;
    res[low1 + i - 1] := list_to_array(lis[i], low2, u2);
  END_REPEAT;
  RETURN (res);
END_FUNCTION;
 
FUNCTION make_array_of_array_of_array(lis :  LIST [1:?] OF  LIST [1:?] OF 
   LIST [1:?] OF GENERIC : t; low1 : INTEGER; u1 : INTEGER; low2 : INTEGER; u2
   : INTEGER; low3 : INTEGER; u3 : INTEGER) :  ARRAY [low1:u1] OF  ARRAY [low2:
  u2] OF  ARRAY [low3:u3] OF GENERIC : t;
LOCAL
  res :  ARRAY [low1:u1] OF  ARRAY [low2:u2] OF  ARRAY [low3:u3] OF GENERIC : t
  ;
END_LOCAL;
  IF u1 - low1 + 1 <> SIZEOF(lis) THEN
    RETURN (?);
  END_IF;
  IF u2 - low2 + 1 <> SIZEOF(lis[1]) THEN
    RETURN (?);
  END_IF;
  res := [make_array_of_array(lis[1], low2, u2, low3, u3) : u1 - low1 + 1];
  REPEAT i := 2 TO HIINDEX(lis);
    IF u2 - low2 + 1 <> SIZEOF(lis[i]) THEN
      RETURN (?);
    END_IF;
    res[low1 + i - 1] := make_array_of_array(lis[i], low2, u2, low3, u3);
  END_REPEAT;
  RETURN (res);
END_FUNCTION;
 
FUNCTION mixed_loop_type_set(l : SET OF loop) : LOGICAL;
LOCAL
  poly_loop_type : LOGICAL;
END_LOCAL;
  IF SIZEOF(l) <= 1 THEN
    RETURN (FALSE);
  END_IF;
  poly_loop_type := 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POLY_LOOP' IN 
  TYPEOF(l[1]);
  REPEAT i := 2 TO SIZEOF(l);
    IF ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POLY_LOOP' IN TYPEOF(l[i]))
     <> poly_loop_type THEN
      RETURN (TRUE);
    END_IF;
  END_REPEAT;
  RETURN (FALSE);
END_FUNCTION;
 
FUNCTION msb_shells(brep : manifold_solid_brep) : SET [1:?] OF closed_shell;
  IF SIZEOF(QUERY(msbtype <* TYPEOF(brep) | msbtype LIKE '*BREP_WITH_VOIDS'))
   >= 1 THEN
    RETURN (brep\brep_with_voids.voids + brep.outer);
  ELSE
    RETURN ([brep.outer]);
  END_IF;
END_FUNCTION;
 
FUNCTION normalise(arg : vector_or_direction) : vector_or_direction;
LOCAL
  ndim : INTEGER;
  v : direction;
  result : vector_or_direction;
  vec : vector;
  mag : REAL;
END_LOCAL;
  IF NOT EXISTS(arg) THEN
    result := ?;
  ELSE
    ndim := arg.dim;
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
      v := dummy_gri||direction(arg.orientation.direction_ratios);
      IF arg.magnitude = 0.0 THEN
        RETURN (?);
      ELSE
        vec := dummy_gri||vector(v, 1.0);
      END_IF;
    ELSE
      v := dummy_gri||direction(arg.direction_ratios);
    END_IF;
    mag := 0.0;
    REPEAT i := 1 TO ndim;
      mag := mag + v.direction_ratios[i] * v.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0 THEN
      mag := (mag);
      REPEAT i := 1 TO ndim;
        v.direction_ratios[i] := v.direction_ratios[i]/mag;
      END_REPEAT;
      IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg) THEN
        vec.orientation := v;
        result := vec;
      ELSE
        result := v;
      END_IF;
    ELSE
      RETURN (?);
    END_IF;
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION open_shell_reversed(a_shell : open_shell) : oriented_open_shell;
LOCAL
  the_reverse : oriented_open_shell;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_OPEN_SHELL' IN TYPEOF(
  a_shell) THEN
    the_reverse := dummy_tri||connected_face_set(a_shell\connected_face_set.
    cfs_faces)||open_shell()||oriented_open_shell(a_shell\oriented_open_shell.
    open_shell_element, NOT a_shell\oriented_open_shell.orientation);
  ELSE
    the_reverse := dummy_tri||connected_face_set(a_shell\connected_face_set.
    cfs_faces)||open_shell()||oriented_open_shell(a_shell, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION orthogonal_complement(vec : direction) : direction;
LOCAL
  result : direction;
END_LOCAL;
  IF (vec.dim <> 2) OR NOT EXISTS(vec) THEN
    RETURN (?);
  ELSE
    result := dummy_gri||direction([-vec.direction_ratios[2], vec.
    direction_ratios[1]]);
    RETURN (result);
  END_IF;
END_FUNCTION;
 
FUNCTION path_head_to_tail(a_path : path) : LOGICAL;
LOCAL
  n : INTEGER;
  p : LOGICAL := TRUE;
END_LOCAL;
  n := SIZEOF(a_path.edge_list);
  REPEAT i := 2 TO n;
    p := p AND (a_path.edge_list[i - 1].edge_end :=: a_path.edge_list[i].
    edge_start);
  END_REPEAT;
  RETURN (p);
END_FUNCTION;
 
FUNCTION path_reversed(a_path : path) : oriented_path;
LOCAL
  the_reverse : oriented_path;
END_LOCAL;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ORIENTED_PATH' IN TYPEOF(a_path)
   THEN
    the_reverse := dummy_tri||path(list_of_topology_reversed(a_path.edge_list))
    ||oriented_path(a_path\oriented_path.path_element, NOT a_path\oriented_path
    .orientation);
  ELSE
    the_reverse := dummy_tri||path(list_of_topology_reversed(a_path.edge_list))
    ||oriented_path(a_path, FALSE);
  END_IF;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION relatives_of_product_definitions(definition_set : SET OF 
  product_definition; relation_subtype : STRING) : SET OF product_definition;
  RETURN (local_relatives_of_product_definitions(definition_set, definition_set
  , relation_subtype));
END_FUNCTION;
 
FUNCTION relatives_of_shape_representations(shape_representation_set : SET OF 
  shape_representation) : SET OF shape_representation;
  RETURN (local_relatives_of_shape_representations(shape_representation_set, 
  shape_representation_set));
END_FUNCTION;
 
FUNCTION same_side(plane_pts :  LIST [3:3] OF cartesian_point; test_points : 
   LIST [2:?] OF cartesian_point) : BOOLEAN;
LOCAL
  val1 : REAL;
  val2 : REAL;
  n : INTEGER;
END_LOCAL;
  IF (plane_pts[1].dim = 2) OR (test_points[1].dim = 2) THEN
    RETURN (?);
  END_IF;
  n := SIZEOF(test_points);
  val1 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[1])
  ;
  REPEAT i := 2 TO n;
    val2 := above_plane(plane_pts[1], plane_pts[2], plane_pts[3], test_points[i
    ]);
    IF val1 * val2 <= 0.0 THEN
      RETURN (FALSE);
    END_IF;
  END_REPEAT;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION scalar_times_vector(scalar : REAL; vec : vector_or_direction) : vector
  ;
LOCAL
  v : direction;
  mag : REAL;
  result : vector;
END_LOCAL;
  IF NOT EXISTS(scalar) OR NOT EXISTS(vec) THEN
    RETURN (?);
  ELSE
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(vec) THEN
      v := dummy_gri||direction(vec.orientation.direction_ratios);
      mag := scalar * vec.magnitude;
    ELSE
      v := dummy_gri||direction(vec.direction_ratios);
      mag := scalar;
    END_IF;
    IF mag < 0.0 THEN
      REPEAT i := 1 TO SIZEOF(v.direction_ratios);
        v.direction_ratios[i] := -v.direction_ratios[i];
      END_REPEAT;
      mag := -mag;
    END_IF;
    result := dummy_gri||vector(normalise(v), mag);
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION second_proj_axis(z_axis : direction; x_axis : direction; arg : 
  direction) : direction;
LOCAL
  y_axis : vector;
  v : direction;
  temp : vector;
END_LOCAL;
  IF NOT EXISTS(arg) THEN
    v := dummy_gri||direction([0.0, 1.0, 0.0]);
  ELSE
    v := arg;
  END_IF;
  temp := scalar_times_vector(dot_product(v, z_axis), z_axis);
  y_axis := vector_difference(v, temp);
  temp := scalar_times_vector(dot_product(v, x_axis), x_axis);
  y_axis := vector_difference(y_axis, temp);
  y_axis := normalise(y_axis);
  RETURN (y_axis.orientation);
END_FUNCTION;
 
FUNCTION set_of_topology_reversed(a_set : set_of_reversible_topology_item) : 
  set_of_reversible_topology_item;
LOCAL
  the_reverse : set_of_reversible_topology_item;
END_LOCAL;
  the_reverse := [];
  REPEAT i := 1 TO SIZEOF(a_set);
    the_reverse := the_reverse + topology_reversed(a_set[i]);
  END_REPEAT;
  RETURN (the_reverse);
END_FUNCTION;
 
FUNCTION shell_reversed(a_shell : shell) : shell;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.OPEN_SHELL' IN TYPEOF(a_shell)
   THEN
    RETURN (open_shell_reversed(a_shell));
  ELSE
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CLOSED_SHELL' IN TYPEOF(a_shell
    ) THEN
      RETURN (closed_shell_reversed(a_shell));
    ELSE
      RETURN (?);
    END_IF;
  END_IF;
END_FUNCTION;
 
FUNCTION surface_weights_positive(b : rational_b_spline_surface) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 0 TO b.u_upper;
    REPEAT j := 0 TO b.v_upper;
      IF b.weights[i][j] <= 0.0 THEN
        result := FALSE;
        RETURN (result);
      END_IF;
    END_REPEAT;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;
 
FUNCTION topology_reversed(an_item : reversible_topology) : reversible_topology
  ;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.EDGE' IN TYPEOF(an_item) THEN
    RETURN (edge_reversed(an_item));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PATH' IN TYPEOF(an_item) THEN
    RETURN (path_reversed(an_item));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FACE_BOUND' IN TYPEOF(an_item)
   THEN
    RETURN (face_bound_reversed(an_item));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FACE' IN TYPEOF(an_item) THEN
    RETURN (face_reversed(an_item));
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SHELL' IN TYPEOF(an_item) THEN
    RETURN (shell_reversed(an_item));
  END_IF;
  IF 'SET' IN TYPEOF(an_item) THEN
    RETURN (set_of_topology_reversed(an_item));
  END_IF;
  IF 'LIST' IN TYPEOF(an_item) THEN
    RETURN (list_of_topology_reversed(an_item));
  END_IF;
  RETURN (?);
END_FUNCTION;
 
FUNCTION type_check_function(the_type : GENERIC; sub_names : SET OF STRING; 
  criterion : INTEGER) : LOGICAL;
  IF NOT EXISTS(the_type) OR NOT ({0 <= criterion <= 3}) OR (SIZEOF(sub_names)
   = 0) THEN
    RETURN (UNKNOWN);
  ELSE
    CASE criterion OF 
      0 : RETURN (SIZEOF(sub_names * TYPEOF(the_type)) > 0);
      1 : RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 0);
      2 : RETURN (SIZEOF(sub_names * TYPEOF(the_type)) = 1);
      3 : RETURN (SIZEOF(sub_names * TYPEOF(the_type)) <= 1);
    END_CASE;
  END_IF;
END_FUNCTION;
 
FUNCTION using_items(item : founded_item_select; checked_items : SET OF 
  founded_item_select) : SET OF founded_item_select;
LOCAL
  new_check_items : SET OF founded_item_select;
  result_items : SET OF founded_item_select;
  next_items : SET OF founded_item_select;
END_LOCAL;
  result_items := [];
  new_check_items := checked_items + item;
  next_items := QUERY(z <* bag_to_set(USEDIN(item, '')) | (
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION_ITEM' IN TYPEOF(z)) 
  OR ('AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.FOUNDED_ITEM' IN TYPEOF(z)));
  IF SIZEOF(next_items) > 0 THEN
    REPEAT i := 1 TO HIINDEX(next_items);
      IF NOT (next_items[i] IN new_check_items) THEN
        result_items := result_items + next_items[i] + using_items(next_items[i
        ], new_check_items);
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (result_items);
END_FUNCTION;
 
FUNCTION using_representations(item : founded_item_select) : SET OF 
  representation;
LOCAL
  results : SET OF representation;
  result_bag :  BAG OF representation;
  intermediate_items : SET OF founded_item_select;
END_LOCAL;
  results := [];
  result_bag := USEDIN(item, 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION.ITEMS');
  IF SIZEOF(result_bag) > 0 THEN
    REPEAT i := 1 TO HIINDEX(result_bag);
      results := results + result_bag[i];
    END_REPEAT;
  END_IF;
  intermediate_items := using_items(item, []);
  IF SIZEOF(intermediate_items) > 0 THEN
    REPEAT i := 1 TO HIINDEX(intermediate_items);
      result_bag := USEDIN(intermediate_items[i], 
      'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.REPRESENTATION.ITEMS');
      IF SIZEOF(result_bag) > 0 THEN
        REPEAT j := 1 TO HIINDEX(result_bag);
          results := results + result_bag[j];
        END_REPEAT;
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (results);
END_FUNCTION;
 
FUNCTION valid_calendar_date(date : calendar_date) : LOGICAL;
  CASE date.month_component OF 
    1 : RETURN ({1 <= date.day_component <= 31});
    2 : 
      BEGIN
        IF leap_year(date.year_component) THEN
          RETURN ({1 <= date.day_component <= 29});
        ELSE
          RETURN ({1 <= date.day_component <= 28});
        END_IF;
      END;
    3 : RETURN ({1 <= date.day_component <= 31});
    4 : RETURN ({1 <= date.day_component <= 30});
    5 : RETURN ({1 <= date.day_component <= 31});
    6 : RETURN ({1 <= date.day_component <= 30});
    7 : RETURN ({1 <= date.day_component <= 31});
    8 : RETURN ({1 <= date.day_component <= 31});
    9 : RETURN ({1 <= date.day_component <= 30});
    10 : RETURN ({1 <= date.day_component <= 31});
    11 : RETURN ({1 <= date.day_component <= 30});
    12 : RETURN ({1 <= date.day_component <= 31});
  END_CASE;
  RETURN (FALSE);
END_FUNCTION;
 
FUNCTION valid_measure_value(m : measure_value) : BOOLEAN;
  IF 'REAL' IN TYPEOF(m) THEN
    RETURN (m > 0.0);
  ELSE
    IF 'INTEGER' IN TYPEOF(m) THEN
      RETURN (m > 0);
    ELSE
      RETURN (TRUE);
    END_IF;
  END_IF;
END_FUNCTION;
 
FUNCTION valid_time(time : local_time) : BOOLEAN;
  IF EXISTS(time.second_component) THEN
    RETURN (EXISTS(time.minute_component));
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;
 
FUNCTION valid_units(m : measure_with_unit) : BOOLEAN;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LENGTH_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MASS_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.TIME_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.ELECTRIC_CURRENT_MEASURE' IN 
  TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.THERMODYNAMIC_TEMPERATURE_MEASURE' 
  IN TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.CELSIUS_TEMPERATURE_MEASURE' IN 
  TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AMOUNT_OF_SUBSTANCE_MEASURE' IN 
  TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.LUMINOUS_INTENSITY_MEASURE' IN 
  TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.PLANE_ANGLE_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.SOLID_ANGLE_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.AREA_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VOLUME_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    3.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.RATIO_MEASURE' IN TYPEOF(m.
  value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITIVE_LENGTH_MEASURE' IN 
  TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.POSITIVE_PLANE_ANGLE_MEASURE' IN 
  TYPEOF(m.value_component) THEN
    IF derive_dimensional_exponents(m.unit_component) <> dimensional_exponents(
    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0) THEN
      RETURN (FALSE);
    END_IF;
  END_IF;
  RETURN (TRUE);
END_FUNCTION;
 
FUNCTION value_range_wr1(agg :  AGGREGATE OF representation_item) : BOOLEAN;
  IF (SIZEOF(agg) = 2) AND ((SIZEOF(QUERY(i1 <* agg | 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN 
  TYPEOF(i1))) = 2) OR (SIZEOF(QUERY(i2 <* agg | 
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VALUE_REPRESENTATION_ITEM' IN TYPEOF
  (i2))) = 2)) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 
FUNCTION value_range_wr2(agg :  AGGREGATE OF representation_item) : BOOLEAN;
  IF (SIZEOF(QUERY(i <* agg | i.name = 'upper limit')) = 1) AND (SIZEOF(QUERY(i
   <* agg | i.name = 'lower limit')) = 1) THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 
FUNCTION value_range_wr3(agg :  AGGREGATE OF representation_item) : BOOLEAN;
  IF SIZEOF(QUERY(i1 <* agg | (
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN 
  TYPEOF(i1)) AND (SIZEOF(QUERY(i2 <* agg | (
  'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.MEASURE_REPRESENTATION_ITEM' IN 
  TYPEOF(i2)) AND (i1 :<>: i2) AND (i1\measure_with_unit.unit_component :=: i2\
  measure_with_unit.unit_component))) = 1))) = 2 THEN
    RETURN (TRUE);
  ELSE
    RETURN (FALSE);
  END_IF;
END_FUNCTION;
 
FUNCTION vector_difference(arg1 : vector_or_direction; arg2 : 
  vector_or_direction) : vector;
LOCAL
  result : vector;
  res : direction;
  vec1 : direction;
  vec2 : direction;
  mag : REAL;
  mag1 : REAL;
  mag2 : REAL;
  ndim : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) OR (arg1.dim <> arg2.dim) THEN
    RETURN (?);
  ELSE
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
      mag1 := arg1.magnitude;
      vec1 := arg1.orientation;
    ELSE
      mag1 := 1.0;
      vec1 := arg1;
    END_IF;
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
      mag2 := arg2.magnitude;
      vec2 := arg2.orientation;
    ELSE
      mag2 := 1.0;
      vec2 := arg2;
    END_IF;
    vec1 := normalise(vec1);
    vec2 := normalise(vec2);
    ndim := SIZEOF(vec1.direction_ratios);
    mag := 0.0;
    res := dummy_gri||direction(vec1.direction_ratios);
    REPEAT i := 1 TO ndim;
      res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] + mag2 * vec2.
      direction_ratios[i];
      mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0 THEN
      result := dummy_gri||vector(res, (mag));
    ELSE
      result := dummy_gri||vector(vec1, 0.0);
    END_IF;
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION vector_sum(arg1 : vector_or_direction; arg2 : vector_or_direction) : 
  vector;
LOCAL
  result : vector;
  res : direction;
  vec1 : direction;
  vec2 : direction;
  mag : REAL;
  mag1 : REAL;
  mag2 : REAL;
  ndim : INTEGER;
END_LOCAL;
  IF NOT EXISTS(arg1) OR NOT EXISTS(arg2) OR (arg1.dim <> arg2.dim) THEN
    RETURN (?);
  ELSE
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg1) THEN
      mag1 := arg1.magnitude;
      vec1 := arg1.orientation;
    ELSE
      mag1 := 1.0;
      vec1 := arg1;
    END_IF;
    IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.VECTOR' IN TYPEOF(arg2) THEN
      mag2 := arg2.magnitude;
      vec2 := arg2.orientation;
    ELSE
      mag2 := 1.0;
      vec2 := arg2;
    END_IF;
    vec1 := normalise(vec1);
    vec2 := normalise(vec2);
    ndim := SIZEOF(vec1.direction_ratios);
    mag := 0.0;
    res := dummy_gri||direction(vec1.direction_ratios);
    REPEAT i := 1 TO ndim;
      res.direction_ratios[i] := mag1 * vec1.direction_ratios[i] + mag2 * vec2.
      direction_ratios[i];
      mag := mag + res.direction_ratios[i] * res.direction_ratios[i];
    END_REPEAT;
    IF mag > 0.0 THEN
      result := dummy_gri||vector(res, (mag));
    ELSE
      result := dummy_gri||vector(vec1, 0.0);
    END_IF;
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION version_assignment_is_valid(aia : applied_identification_assignment)
   : BOOLEAN;
LOCAL
  item : identification_item;
  role : identification_role;
END_LOCAL;
  role := aia.role;
  IF role.name = 'version' THEN
    REPEAT i := LOINDEX(aia.items) TO HIINDEX(aia.items);
      item := aia.items[i];
      IF SIZEOF(['AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.' + 
      'VERSIONABLE_ITEM'] * TYPEOF(item)) = 0 THEN
        RETURN (FALSE);
      END_IF;
    END_REPEAT;
    RETURN (TRUE);
  ELSE
    RETURN (TRUE);
  END_IF;
END_FUNCTION;
 
FUNCTION vertex_point_pcurves(a_vertex : vertex_point; the_degenerates : SET
   OF evaluated_degenerate_pcurve) : SET OF degenerate_pcurve;
LOCAL
  a_point : point;
  result : SET OF degenerate_pcurve;
END_LOCAL;
  a_point := a_vertex.vertex_geometry;
  result := [];
  IF 'AP239_PRODUCT_LIFE_CYCLE_SUPPORT_MIM_LF.DEGENERATE_PCURVE' IN TYPEOF(
  a_point) THEN
    result := result + a_point;
  ELSE
    REPEAT j := 1 TO SIZEOF(the_degenerates);
      IF the_degenerates[j].equivalent_point :=: a_point THEN
        result := result + the_degenerates[j];
      END_IF;
    END_REPEAT;
  END_IF;
  RETURN (result);
END_FUNCTION;
 
FUNCTION volume_weights_positive(b : rational_b_spline_volume) : BOOLEAN;
LOCAL
  result : BOOLEAN := TRUE;
END_LOCAL;
  REPEAT i := 0 TO b.u_upper;
    REPEAT j := 0 TO b.v_upper;
      REPEAT k := 0 TO b.w_upper;
        IF b.weights[i][j][k] <= 0.0 THEN
          result := FALSE;
          RETURN (result);
        END_IF;
      END_REPEAT;
    END_REPEAT;
  END_REPEAT;
  RETURN (result);
END_FUNCTION;
 
END_SCHEMA;
